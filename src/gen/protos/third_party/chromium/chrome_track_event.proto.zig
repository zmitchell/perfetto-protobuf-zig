// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
const debug_annotation = @import("src/gen/protos/perfetto/trace/track_event/debug_annotation.proto.zig");
const source_location = @import("src/gen/protos/perfetto/trace/track_event/source_location.proto.zig");
const track_event = @import("src/gen/protos/perfetto/trace/track_event/track_event.proto.zig");
const task_execution = @import("src/gen/protos/perfetto/trace/track_event/task_execution.proto.zig");
const log_message = @import("src/gen/protos/perfetto/trace/track_event/log_message.proto.zig");
const chrome_compositor_scheduler_state = @import("src/gen/protos/perfetto/trace/track_event/chrome_compositor_scheduler_state.proto.zig");
const chrome_user_event = @import("src/gen/protos/perfetto/trace/track_event/chrome_user_event.proto.zig");
const chrome_keyed_service = @import("src/gen/protos/perfetto/trace/track_event/chrome_keyed_service.proto.zig");
const chrome_legacy_ipc = @import("src/gen/protos/perfetto/trace/track_event/chrome_legacy_ipc.proto.zig");
const chrome_histogram_sample = @import("src/gen/protos/perfetto/trace/track_event/chrome_histogram_sample.proto.zig");
const chrome_latency_info = @import("src/gen/protos/perfetto/trace/track_event/chrome_latency_info.proto.zig");
const chrome_frame_reporter = @import("src/gen/protos/perfetto/trace/track_event/chrome_frame_reporter.proto.zig");
const chrome_application_state_info = @import("src/gen/protos/perfetto/trace/track_event/chrome_application_state_info.proto.zig");
const chrome_renderer_scheduler_state = @import("src/gen/protos/perfetto/trace/track_event/chrome_renderer_scheduler_state.proto.zig");
const chrome_window_handle_event_info = @import("src/gen/protos/perfetto/trace/track_event/chrome_window_handle_event_info.proto.zig");
const chrome_content_settings_event_info = @import("src/gen/protos/perfetto/trace/track_event/chrome_content_settings_event_info.proto.zig");
const chrome_active_processes = @import("src/gen/protos/perfetto/trace/track_event/chrome_active_processes.proto.zig");
const screenshot = @import("src/gen/protos/perfetto/trace/track_event/screenshot.proto.zig");
const chrome_message_pump = @import("src/gen/protos/perfetto/trace/track_event/chrome_message_pump.proto.zig");
const chrome_mojo_event_info = @import("src/gen/protos/perfetto/trace/track_event/chrome_mojo_event_info.proto.zig");
// enums
pub const ChromeAppState = enum(i32) {
    APP_STATE_FOREGROUND = 1,
    APP_STATE_BACKGROUND = 2,
    _PROTOBUF_UNKNOWN = 0,
};
pub const MemoryPressureLevel = enum(i32) {
    MEMORY_PRESSURE_LEVEL_NONE = 0,
    MEMORY_PRESSURE_LEVEL_MODERATE = 1,
    MEMORY_PRESSURE_LEVEL_CRITICAL = 2,
};
pub const FrameDeleteIntention = enum(i32) {
    FRAME_DELETE_INTENTION_NOT_MAIN_FRAME = 0,
    FRAME_DELETE_INTENTION_SPECULATIVE_MAIN_FRAME_FOR_SHUTDOWN = 1,
    FRAME_DELETE_INTENTION_SPECULATIVE_MAIN_FRAME_FOR_NAVIGATION_CANCELLED = 2,
};
pub const ShouldSwapBrowsingInstance = enum(i32) {
    SHOULD_SWAP_BROWSING_INSTANCE_NO = 0,
    SHOULD_SWAP_BROWSING_INSTANCE_YES_FORCE_SWAP = 1,
    SHOULD_SWAP_BROWSING_INSTANCE_YES_CROSS_SITE_PROACTIVE_SWAP = 2,
    SHOULD_SWAP_BROWSING_INSTANCE_YES_SAME_SITE_PROACTIVE_SWAP = 3,
    SHOULD_SWAP_BROWSING_INSTANCE_NO_PROACTIVE_SWAP_DISABLED = 4,
    SHOULD_SWAP_BROWSING_INSTANCE_NO_NOT_MAIN_FRAME = 5,
    SHOULD_SWAP_BROWSING_INSTANCE_NO_HAS_RELATED_ACTIVE_CONTENTS = 6,
    SHOULD_SWAP_BROWSING_INSTANCE_NO_DOES_NOT_HAVE_SITE = 7,
    SHOULD_SWAP_BROWSING_INSTANCE_NO_SOURCE_URL_SCHEME_NOT_HTTP_OR_HTTPS = 8,
    SHOULD_SWAP_BROWSING_INSTANCE_NO_DESTINATION_URL_SCHEME_NOT_HTTP_OR_HTTPS = 9,
    SHOULD_SWAP_BROWSING_INSTANCE_NO_SAME_SITE_NAVIGATION = 10,
    SHOULD_SWAP_BROWSING_INSTANCE_NO_RELOADING_ERROR_PAGE = 11,
    SHOULD_SWAP_BROWSING_INSTANCE_NO_ALREADY_HAS_MATCHING_BROWSING_INSTANCE = 12,
    SHOULD_SWAP_BROWSING_INSTANCE_NO_RENDERER_DEBUG_URL = 13,
    SHOULD_SWAP_BROWSING_INSTANCE_NO_NOT_NEEDED_FOR_BACK_FORWARD_CACHE = 14,
    SHOULD_SWAP_BROWSING_INSTANCE_NO_SAME_DOCUMENT_NAVIGATION = 15,
    SHOULD_SWAP_BROWSING_INSTANCE_NO_SAME_URL_NAVIGATION = 16,
    SHOULD_SWAP_BROWSING_INSTANCE_NO_WILL_REPLACE_ENTRY = 17,
    SHOULD_SWAP_BROWSING_INSTANCE_NO_RELOAD = 18,
    SHOULD_SWAP_BROWSING_INSTANCE_NO_GUEST = 19,
    SHOULD_SWAP_BROWSING_INSTANCE_NO_HAS_NOT_COMMITTED_ANY_NAVIGATION = 20,
    SHOULD_SWAP_BROWSING_INSTANCE_NO_UNLOAD_HANDLER_EXISTS_ON_SAME_SITE_NAVIGATION = 21,
    SHOULD_SWAP_BROWSING_INSTANCE_NO_NOT_PRIMARY_MAIN_FRAME = 22,
    SHOULD_SWAP_BROWSING_INSTANCE_NO_INITIATOR_REQUESTED_NO_PROACTIVE_SWAP = 23,
};
pub const DeviceThermalState = enum(i32) {
    DEVICE_THERMAL_STATE_UNKNOWN = 0,
    DEVICE_THERMAL_STATE_NOMINAL = 1,
    DEVICE_THERMAL_STATE_FAIR = 2,
    DEVICE_THERMAL_STATE_SERIOUS = 3,
    DEVICE_THERMAL_STATE_CRITICAL = 4,
};
pub const ChromeCompositorSchedulerActionV2 = enum(i32) {
    CC_SCHEDULER_ACTION_V2_UNSPECIFIED = 0,
    CC_SCHEDULER_ACTION_V2_NONE = 1,
    CC_SCHEDULER_ACTION_V2_SEND_BEGIN_MAIN_FRAME = 2,
    CC_SCHEDULER_ACTION_V2_COMMIT = 3,
    CC_SCHEDULER_ACTION_V2_POST_COMMIT = 14,
    CC_SCHEDULER_ACTION_V2_ACTIVATE_SYNC_TREE = 4,
    CC_SCHEDULER_ACTION_V2_DRAW_IF_POSSIBLE = 5,
    CC_SCHEDULER_ACTION_V2_DRAW_FORCED = 6,
    CC_SCHEDULER_ACTION_V2_DRAW_ABORT = 7,
    CC_SCHEDULER_ACTION_V2_UPDATE_DISPLAY_TREE = 15,
    CC_SCHEDULER_ACTION_V2_BEGIN_LAYER_TREE_FRAME_SINK_CREATION = 8,
    CC_SCHEDULER_ACTION_V2_PREPARE_TILES = 9,
    CC_SCHEDULER_ACTION_V2_INVALIDATE_LAYER_TREE_FRAME_SINK = 10,
    CC_SCHEDULER_ACTION_V2_PERFORM_IMPL_SIDE_INVALIDATION = 11,
    CC_SCHEDULER_ACTION_V2_NOTIFY_BEGIN_MAIN_FRAME_NOT_EXPECTED_UNTIL = 12,
    CC_SCHEDULER_ACTION_V2_NOTIFY_BEGIN_MAIN_FRAME_NOT_EXPECTED_SOON = 13,
};
// structs
const ChromeMemoryPressureNotificationWire = struct {
    const LEVEL_WIRE: gremlin.ProtoWireNumber = 1;
    const CREATION_LOCATION_IID_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const ChromeMemoryPressureNotification = struct {
    // fields
    level: MemoryPressureLevel = @enumFromInt(0),
    creation_location_iid: u64 = 0,
    pub fn calcProtobufSize(self: *const ChromeMemoryPressureNotification) usize {
        var res: usize = 0;
        if (@intFromEnum(self.level) != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeMemoryPressureNotificationWire.LEVEL_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.level));
        }
        if (self.creation_location_iid != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeMemoryPressureNotificationWire.CREATION_LOCATION_IID_WIRE) + gremlin.sizes.sizeU64(self.creation_location_iid);
        }
        return res;
    }
    pub fn encode(self: *const ChromeMemoryPressureNotification, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ChromeMemoryPressureNotification, target: *gremlin.Writer) void {
        if (@intFromEnum(self.level) != 0) {
            target.appendInt32(ChromeMemoryPressureNotificationWire.LEVEL_WIRE, @intFromEnum(self.level));
        }
        if (self.creation_location_iid != 0) {
            target.appendUint64(ChromeMemoryPressureNotificationWire.CREATION_LOCATION_IID_WIRE, self.creation_location_iid);
        }
    }
};
pub const ChromeMemoryPressureNotificationReader = struct {
    buf: gremlin.Reader,
    _level: MemoryPressureLevel = @enumFromInt(0),
    _creation_location_iid: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!ChromeMemoryPressureNotificationReader {
        const buf = gremlin.Reader.init(src);
        var res = ChromeMemoryPressureNotificationReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ChromeMemoryPressureNotificationWire.LEVEL_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._level = @enumFromInt(result.value);
                },
                ChromeMemoryPressureNotificationWire.CREATION_LOCATION_IID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._creation_location_iid = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getLevel(self: *const ChromeMemoryPressureNotificationReader) MemoryPressureLevel {
        return self._level;
    }
    pub inline fn getCreationLocationIid(self: *const ChromeMemoryPressureNotificationReader) u64 {
        return self._creation_location_iid;
    }
};
const BlinkTaskScopeWire = struct {
    const TYPE_WIRE: gremlin.ProtoWireNumber = 1;
    const SCOPE_TASK_ID_WIRE: gremlin.ProtoWireNumber = 2;
    const RUNNING_TASK_ID_TO_BE_RESTORED_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const BlinkTaskScope = struct {
    // nested enums
    pub const TaskScopeType = enum(i32) {
        TASK_SCOPE_UNKNOWN = 0,
        TASK_SCOPE_CALLBACK = 1,
        TASK_SCOPE_SCHEDULED_ACTION = 2,
        TASK_SCOPE_SCRIPT_EXECUTION = 3,
        TASK_SCOPE_POST_MESSAGE = 4,
        TASK_SCOPE_POP_STATE = 5,
        TASK_SCOPE_SCHEDULER_POST_TASK = 6,
        TASK_SCOPE_REQUEST_IDLE_CALLBACK = 7,
        TASK_SCOPE_XML_HTTP_REQUEST = 8,
        TASK_SCOPE_SOFT_NAVIGATION = 9,
        TASK_SCOPE_MISC_EVENT = 10,
        TASK_SCOPE_MICROTASK = 11,
    };
    // fields
    type: BlinkTaskScope.TaskScopeType = @enumFromInt(0),
    scope_task_id: i64 = 0,
    running_task_id_to_be_restored: i64 = 0,
    pub fn calcProtobufSize(self: *const BlinkTaskScope) usize {
        var res: usize = 0;
        if (@intFromEnum(self.type) != 0) {
            res += gremlin.sizes.sizeWireNumber(BlinkTaskScopeWire.TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.type));
        }
        if (self.scope_task_id != 0) {
            res += gremlin.sizes.sizeWireNumber(BlinkTaskScopeWire.SCOPE_TASK_ID_WIRE) + gremlin.sizes.sizeI64(self.scope_task_id);
        }
        if (self.running_task_id_to_be_restored != 0) {
            res += gremlin.sizes.sizeWireNumber(BlinkTaskScopeWire.RUNNING_TASK_ID_TO_BE_RESTORED_WIRE) + gremlin.sizes.sizeI64(self.running_task_id_to_be_restored);
        }
        return res;
    }
    pub fn encode(self: *const BlinkTaskScope, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const BlinkTaskScope, target: *gremlin.Writer) void {
        if (@intFromEnum(self.type) != 0) {
            target.appendInt32(BlinkTaskScopeWire.TYPE_WIRE, @intFromEnum(self.type));
        }
        if (self.scope_task_id != 0) {
            target.appendInt64(BlinkTaskScopeWire.SCOPE_TASK_ID_WIRE, self.scope_task_id);
        }
        if (self.running_task_id_to_be_restored != 0) {
            target.appendInt64(BlinkTaskScopeWire.RUNNING_TASK_ID_TO_BE_RESTORED_WIRE, self.running_task_id_to_be_restored);
        }
    }
};
pub const BlinkTaskScopeReader = struct {
    buf: gremlin.Reader,
    _type: BlinkTaskScope.TaskScopeType = @enumFromInt(0),
    _scope_task_id: i64 = 0,
    _running_task_id_to_be_restored: i64 = 0,
    pub fn init(src: []const u8) gremlin.Error!BlinkTaskScopeReader {
        const buf = gremlin.Reader.init(src);
        var res = BlinkTaskScopeReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                BlinkTaskScopeWire.TYPE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._type = @enumFromInt(result.value);
                },
                BlinkTaskScopeWire.SCOPE_TASK_ID_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._scope_task_id = result.value;
                },
                BlinkTaskScopeWire.RUNNING_TASK_ID_TO_BE_RESTORED_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._running_task_id_to_be_restored = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getType(self: *const BlinkTaskScopeReader) BlinkTaskScope.TaskScopeType {
        return self._type;
    }
    pub inline fn getScopeTaskId(self: *const BlinkTaskScopeReader) i64 {
        return self._scope_task_id;
    }
    pub inline fn getRunningTaskIdToBeRestored(self: *const BlinkTaskScopeReader) i64 {
        return self._running_task_id_to_be_restored;
    }
};
const ChromeTaskAnnotatorWire = struct {
    const IPC_HASH_WIRE: gremlin.ProtoWireNumber = 1;
    const TASK_DELAY_US_WIRE: gremlin.ProtoWireNumber = 2;
    const DELAY_POLICY_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const ChromeTaskAnnotator = struct {
    // nested enums
    pub const DelayPolicy = enum(i32) {
        FLEXIBLE_NO_SOONER = 0,
        FLEXIBLE_PREFER_EARLY = 1,
        PRECISE = 2,
    };
    // fields
    ipc_hash: u32 = 0,
    task_delay_us: u64 = 0,
    delay_policy: ChromeTaskAnnotator.DelayPolicy = @enumFromInt(0),
    pub fn calcProtobufSize(self: *const ChromeTaskAnnotator) usize {
        var res: usize = 0;
        if (self.ipc_hash != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeTaskAnnotatorWire.IPC_HASH_WIRE) + gremlin.sizes.sizeU32(self.ipc_hash);
        }
        if (self.task_delay_us != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeTaskAnnotatorWire.TASK_DELAY_US_WIRE) + gremlin.sizes.sizeU64(self.task_delay_us);
        }
        if (@intFromEnum(self.delay_policy) != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeTaskAnnotatorWire.DELAY_POLICY_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.delay_policy));
        }
        return res;
    }
    pub fn encode(self: *const ChromeTaskAnnotator, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ChromeTaskAnnotator, target: *gremlin.Writer) void {
        if (self.ipc_hash != 0) {
            target.appendUint32(ChromeTaskAnnotatorWire.IPC_HASH_WIRE, self.ipc_hash);
        }
        if (self.task_delay_us != 0) {
            target.appendUint64(ChromeTaskAnnotatorWire.TASK_DELAY_US_WIRE, self.task_delay_us);
        }
        if (@intFromEnum(self.delay_policy) != 0) {
            target.appendInt32(ChromeTaskAnnotatorWire.DELAY_POLICY_WIRE, @intFromEnum(self.delay_policy));
        }
    }
};
pub const ChromeTaskAnnotatorReader = struct {
    buf: gremlin.Reader,
    _ipc_hash: u32 = 0,
    _task_delay_us: u64 = 0,
    _delay_policy: ChromeTaskAnnotator.DelayPolicy = @enumFromInt(0),
    pub fn init(src: []const u8) gremlin.Error!ChromeTaskAnnotatorReader {
        const buf = gremlin.Reader.init(src);
        var res = ChromeTaskAnnotatorReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ChromeTaskAnnotatorWire.IPC_HASH_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._ipc_hash = result.value;
                },
                ChromeTaskAnnotatorWire.TASK_DELAY_US_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._task_delay_us = result.value;
                },
                ChromeTaskAnnotatorWire.DELAY_POLICY_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._delay_policy = @enumFromInt(result.value);
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getIpcHash(self: *const ChromeTaskAnnotatorReader) u32 {
        return self._ipc_hash;
    }
    pub inline fn getTaskDelayUs(self: *const ChromeTaskAnnotatorReader) u64 {
        return self._task_delay_us;
    }
    pub inline fn getDelayPolicy(self: *const ChromeTaskAnnotatorReader) ChromeTaskAnnotator.DelayPolicy {
        return self._delay_policy;
    }
};
const ChromeBrowserContextWire = struct {
    const ID_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const ChromeBrowserContext = struct {
    // fields
    id: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const ChromeBrowserContext) usize {
        var res: usize = 0;
        if (self.id) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeBrowserContextWire.ID_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const ChromeBrowserContext, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ChromeBrowserContext, target: *gremlin.Writer) void {
        if (self.id) |v| {
            if (v.len > 0) {
                target.appendBytes(ChromeBrowserContextWire.ID_WIRE, v);
            }
        }
    }
};
pub const ChromeBrowserContextReader = struct {
    buf: gremlin.Reader,
    _id: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!ChromeBrowserContextReader {
        const buf = gremlin.Reader.init(src);
        var res = ChromeBrowserContextReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ChromeBrowserContextWire.ID_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._id = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getId(self: *const ChromeBrowserContextReader) []const u8 {
        return self._id orelse &[_]u8{};
    }
};
const ChromeProfileDestroyerWire = struct {
    const PROFILE_PTR_WIRE: gremlin.ProtoWireNumber = 1;
    const IS_OFF_THE_RECORD_WIRE: gremlin.ProtoWireNumber = 2;
    const OTR_PROFILE_ID_WIRE: gremlin.ProtoWireNumber = 3;
    const HOST_COUNT_AT_CREATION_WIRE: gremlin.ProtoWireNumber = 4;
    const HOST_COUNT_AT_DESTRUCTION_WIRE: gremlin.ProtoWireNumber = 5;
    const RENDER_PROCESS_HOST_PTR_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const ChromeProfileDestroyer = struct {
    // fields
    profile_ptr: u64 = 0,
    is_off_the_record: bool = false,
    otr_profile_id: ?[]const u8 = null,
    host_count_at_creation: u32 = 0,
    host_count_at_destruction: u32 = 0,
    render_process_host_ptr: u64 = 0,
    pub fn calcProtobufSize(self: *const ChromeProfileDestroyer) usize {
        var res: usize = 0;
        if (self.profile_ptr != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeProfileDestroyerWire.PROFILE_PTR_WIRE) + gremlin.sizes.sizeFixed64(self.profile_ptr);
        }
        if (self.is_off_the_record != false) {
            res += gremlin.sizes.sizeWireNumber(ChromeProfileDestroyerWire.IS_OFF_THE_RECORD_WIRE) + gremlin.sizes.sizeBool(self.is_off_the_record);
        }
        if (self.otr_profile_id) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeProfileDestroyerWire.OTR_PROFILE_ID_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.host_count_at_creation != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeProfileDestroyerWire.HOST_COUNT_AT_CREATION_WIRE) + gremlin.sizes.sizeU32(self.host_count_at_creation);
        }
        if (self.host_count_at_destruction != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeProfileDestroyerWire.HOST_COUNT_AT_DESTRUCTION_WIRE) + gremlin.sizes.sizeU32(self.host_count_at_destruction);
        }
        if (self.render_process_host_ptr != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeProfileDestroyerWire.RENDER_PROCESS_HOST_PTR_WIRE) + gremlin.sizes.sizeFixed64(self.render_process_host_ptr);
        }
        return res;
    }
    pub fn encode(self: *const ChromeProfileDestroyer, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ChromeProfileDestroyer, target: *gremlin.Writer) void {
        if (self.profile_ptr != 0) {
            target.appendFixed64(ChromeProfileDestroyerWire.PROFILE_PTR_WIRE, self.profile_ptr);
        }
        if (self.is_off_the_record != false) {
            target.appendBool(ChromeProfileDestroyerWire.IS_OFF_THE_RECORD_WIRE, self.is_off_the_record);
        }
        if (self.otr_profile_id) |v| {
            if (v.len > 0) {
                target.appendBytes(ChromeProfileDestroyerWire.OTR_PROFILE_ID_WIRE, v);
            }
        }
        if (self.host_count_at_creation != 0) {
            target.appendUint32(ChromeProfileDestroyerWire.HOST_COUNT_AT_CREATION_WIRE, self.host_count_at_creation);
        }
        if (self.host_count_at_destruction != 0) {
            target.appendUint32(ChromeProfileDestroyerWire.HOST_COUNT_AT_DESTRUCTION_WIRE, self.host_count_at_destruction);
        }
        if (self.render_process_host_ptr != 0) {
            target.appendFixed64(ChromeProfileDestroyerWire.RENDER_PROCESS_HOST_PTR_WIRE, self.render_process_host_ptr);
        }
    }
};
pub const ChromeProfileDestroyerReader = struct {
    buf: gremlin.Reader,
    _profile_ptr: u64 = 0,
    _is_off_the_record: bool = false,
    _otr_profile_id: ?[]const u8 = null,
    _host_count_at_creation: u32 = 0,
    _host_count_at_destruction: u32 = 0,
    _render_process_host_ptr: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!ChromeProfileDestroyerReader {
        const buf = gremlin.Reader.init(src);
        var res = ChromeProfileDestroyerReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ChromeProfileDestroyerWire.PROFILE_PTR_WIRE => {
                    const result = try buf.readFixed64(offset);
                    offset += result.size;
                    res._profile_ptr = result.value;
                },
                ChromeProfileDestroyerWire.IS_OFF_THE_RECORD_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_off_the_record = result.value;
                },
                ChromeProfileDestroyerWire.OTR_PROFILE_ID_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._otr_profile_id = result.value;
                },
                ChromeProfileDestroyerWire.HOST_COUNT_AT_CREATION_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._host_count_at_creation = result.value;
                },
                ChromeProfileDestroyerWire.HOST_COUNT_AT_DESTRUCTION_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._host_count_at_destruction = result.value;
                },
                ChromeProfileDestroyerWire.RENDER_PROCESS_HOST_PTR_WIRE => {
                    const result = try buf.readFixed64(offset);
                    offset += result.size;
                    res._render_process_host_ptr = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getProfilePtr(self: *const ChromeProfileDestroyerReader) u64 {
        return self._profile_ptr;
    }
    pub inline fn getIsOffTheRecord(self: *const ChromeProfileDestroyerReader) bool {
        return self._is_off_the_record;
    }
    pub inline fn getOtrProfileId(self: *const ChromeProfileDestroyerReader) []const u8 {
        return self._otr_profile_id orelse &[_]u8{};
    }
    pub inline fn getHostCountAtCreation(self: *const ChromeProfileDestroyerReader) u32 {
        return self._host_count_at_creation;
    }
    pub inline fn getHostCountAtDestruction(self: *const ChromeProfileDestroyerReader) u32 {
        return self._host_count_at_destruction;
    }
    pub inline fn getRenderProcessHostPtr(self: *const ChromeProfileDestroyerReader) u64 {
        return self._render_process_host_ptr;
    }
};
const ChromeTaskPostedToDisabledQueueWire = struct {
    const TASK_QUEUE_NAME_WIRE: gremlin.ProtoWireNumber = 1;
    const TIME_SINCE_DISABLED_MS_WIRE: gremlin.ProtoWireNumber = 2;
    const IPC_HASH_WIRE: gremlin.ProtoWireNumber = 3;
    const SOURCE_LOCATION_IID_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const ChromeTaskPostedToDisabledQueue = struct {
    // fields
    task_queue_name: ?[]const u8 = null,
    time_since_disabled_ms: u64 = 0,
    ipc_hash: u32 = 0,
    source_location_iid: u64 = 0,
    pub fn calcProtobufSize(self: *const ChromeTaskPostedToDisabledQueue) usize {
        var res: usize = 0;
        if (self.task_queue_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeTaskPostedToDisabledQueueWire.TASK_QUEUE_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.time_since_disabled_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeTaskPostedToDisabledQueueWire.TIME_SINCE_DISABLED_MS_WIRE) + gremlin.sizes.sizeU64(self.time_since_disabled_ms);
        }
        if (self.ipc_hash != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeTaskPostedToDisabledQueueWire.IPC_HASH_WIRE) + gremlin.sizes.sizeU32(self.ipc_hash);
        }
        if (self.source_location_iid != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeTaskPostedToDisabledQueueWire.SOURCE_LOCATION_IID_WIRE) + gremlin.sizes.sizeU64(self.source_location_iid);
        }
        return res;
    }
    pub fn encode(self: *const ChromeTaskPostedToDisabledQueue, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ChromeTaskPostedToDisabledQueue, target: *gremlin.Writer) void {
        if (self.task_queue_name) |v| {
            if (v.len > 0) {
                target.appendBytes(ChromeTaskPostedToDisabledQueueWire.TASK_QUEUE_NAME_WIRE, v);
            }
        }
        if (self.time_since_disabled_ms != 0) {
            target.appendUint64(ChromeTaskPostedToDisabledQueueWire.TIME_SINCE_DISABLED_MS_WIRE, self.time_since_disabled_ms);
        }
        if (self.ipc_hash != 0) {
            target.appendUint32(ChromeTaskPostedToDisabledQueueWire.IPC_HASH_WIRE, self.ipc_hash);
        }
        if (self.source_location_iid != 0) {
            target.appendUint64(ChromeTaskPostedToDisabledQueueWire.SOURCE_LOCATION_IID_WIRE, self.source_location_iid);
        }
    }
};
pub const ChromeTaskPostedToDisabledQueueReader = struct {
    buf: gremlin.Reader,
    _task_queue_name: ?[]const u8 = null,
    _time_since_disabled_ms: u64 = 0,
    _ipc_hash: u32 = 0,
    _source_location_iid: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!ChromeTaskPostedToDisabledQueueReader {
        const buf = gremlin.Reader.init(src);
        var res = ChromeTaskPostedToDisabledQueueReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ChromeTaskPostedToDisabledQueueWire.TASK_QUEUE_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._task_queue_name = result.value;
                },
                ChromeTaskPostedToDisabledQueueWire.TIME_SINCE_DISABLED_MS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._time_since_disabled_ms = result.value;
                },
                ChromeTaskPostedToDisabledQueueWire.IPC_HASH_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._ipc_hash = result.value;
                },
                ChromeTaskPostedToDisabledQueueWire.SOURCE_LOCATION_IID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._source_location_iid = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getTaskQueueName(self: *const ChromeTaskPostedToDisabledQueueReader) []const u8 {
        return self._task_queue_name orelse &[_]u8{};
    }
    pub inline fn getTimeSinceDisabledMs(self: *const ChromeTaskPostedToDisabledQueueReader) u64 {
        return self._time_since_disabled_ms;
    }
    pub inline fn getIpcHash(self: *const ChromeTaskPostedToDisabledQueueReader) u32 {
        return self._ipc_hash;
    }
    pub inline fn getSourceLocationIid(self: *const ChromeTaskPostedToDisabledQueueReader) u64 {
        return self._source_location_iid;
    }
};
const ChromeRasterTaskWire = struct {
    const SOURCE_FRAME_NUMBER_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const ChromeRasterTask = struct {
    // fields
    source_frame_number: i64 = 0,
    pub fn calcProtobufSize(self: *const ChromeRasterTask) usize {
        var res: usize = 0;
        if (self.source_frame_number != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeRasterTaskWire.SOURCE_FRAME_NUMBER_WIRE) + gremlin.sizes.sizeI64(self.source_frame_number);
        }
        return res;
    }
    pub fn encode(self: *const ChromeRasterTask, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ChromeRasterTask, target: *gremlin.Writer) void {
        if (self.source_frame_number != 0) {
            target.appendInt64(ChromeRasterTaskWire.SOURCE_FRAME_NUMBER_WIRE, self.source_frame_number);
        }
    }
};
pub const ChromeRasterTaskReader = struct {
    buf: gremlin.Reader,
    _source_frame_number: i64 = 0,
    pub fn init(src: []const u8) gremlin.Error!ChromeRasterTaskReader {
        const buf = gremlin.Reader.init(src);
        var res = ChromeRasterTaskReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ChromeRasterTaskWire.SOURCE_FRAME_NUMBER_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._source_frame_number = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getSourceFrameNumber(self: *const ChromeRasterTaskReader) i64 {
        return self._source_frame_number;
    }
};
const ChromeMessagePumpForUIWire = struct {
    const MESSAGE_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const WAIT_FOR_OBJECT_RESULT_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const ChromeMessagePumpForUI = struct {
    // fields
    message_id: u32 = 0,
    wait_for_object_result: u32 = 0,
    pub fn calcProtobufSize(self: *const ChromeMessagePumpForUI) usize {
        var res: usize = 0;
        if (self.message_id != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeMessagePumpForUIWire.MESSAGE_ID_WIRE) + gremlin.sizes.sizeU32(self.message_id);
        }
        if (self.wait_for_object_result != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeMessagePumpForUIWire.WAIT_FOR_OBJECT_RESULT_WIRE) + gremlin.sizes.sizeU32(self.wait_for_object_result);
        }
        return res;
    }
    pub fn encode(self: *const ChromeMessagePumpForUI, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ChromeMessagePumpForUI, target: *gremlin.Writer) void {
        if (self.message_id != 0) {
            target.appendUint32(ChromeMessagePumpForUIWire.MESSAGE_ID_WIRE, self.message_id);
        }
        if (self.wait_for_object_result != 0) {
            target.appendUint32(ChromeMessagePumpForUIWire.WAIT_FOR_OBJECT_RESULT_WIRE, self.wait_for_object_result);
        }
    }
};
pub const ChromeMessagePumpForUIReader = struct {
    buf: gremlin.Reader,
    _message_id: u32 = 0,
    _wait_for_object_result: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!ChromeMessagePumpForUIReader {
        const buf = gremlin.Reader.init(src);
        var res = ChromeMessagePumpForUIReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ChromeMessagePumpForUIWire.MESSAGE_ID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._message_id = result.value;
                },
                ChromeMessagePumpForUIWire.WAIT_FOR_OBJECT_RESULT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._wait_for_object_result = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getMessageId(self: *const ChromeMessagePumpForUIReader) u32 {
        return self._message_id;
    }
    pub inline fn getWaitForObjectResult(self: *const ChromeMessagePumpForUIReader) u32 {
        return self._wait_for_object_result;
    }
};
const RenderFrameImplDeletionWire = struct {
    const INTENT_WIRE: gremlin.ProtoWireNumber = 1;
    const HAS_PENDING_COMMIT_WIRE: gremlin.ProtoWireNumber = 2;
    const HAS_PENDING_CROSS_DOCUMENT_COMMIT_WIRE: gremlin.ProtoWireNumber = 3;
    const FRAME_TREE_NODE_ID_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const RenderFrameImplDeletion = struct {
    // fields
    intent: FrameDeleteIntention = @enumFromInt(0),
    has_pending_commit: bool = false,
    has_pending_cross_document_commit: bool = false,
    frame_tree_node_id: u64 = 0,
    pub fn calcProtobufSize(self: *const RenderFrameImplDeletion) usize {
        var res: usize = 0;
        if (@intFromEnum(self.intent) != 0) {
            res += gremlin.sizes.sizeWireNumber(RenderFrameImplDeletionWire.INTENT_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.intent));
        }
        if (self.has_pending_commit != false) {
            res += gremlin.sizes.sizeWireNumber(RenderFrameImplDeletionWire.HAS_PENDING_COMMIT_WIRE) + gremlin.sizes.sizeBool(self.has_pending_commit);
        }
        if (self.has_pending_cross_document_commit != false) {
            res += gremlin.sizes.sizeWireNumber(RenderFrameImplDeletionWire.HAS_PENDING_CROSS_DOCUMENT_COMMIT_WIRE) + gremlin.sizes.sizeBool(self.has_pending_cross_document_commit);
        }
        if (self.frame_tree_node_id != 0) {
            res += gremlin.sizes.sizeWireNumber(RenderFrameImplDeletionWire.FRAME_TREE_NODE_ID_WIRE) + gremlin.sizes.sizeU64(self.frame_tree_node_id);
        }
        return res;
    }
    pub fn encode(self: *const RenderFrameImplDeletion, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const RenderFrameImplDeletion, target: *gremlin.Writer) void {
        if (@intFromEnum(self.intent) != 0) {
            target.appendInt32(RenderFrameImplDeletionWire.INTENT_WIRE, @intFromEnum(self.intent));
        }
        if (self.has_pending_commit != false) {
            target.appendBool(RenderFrameImplDeletionWire.HAS_PENDING_COMMIT_WIRE, self.has_pending_commit);
        }
        if (self.has_pending_cross_document_commit != false) {
            target.appendBool(RenderFrameImplDeletionWire.HAS_PENDING_CROSS_DOCUMENT_COMMIT_WIRE, self.has_pending_cross_document_commit);
        }
        if (self.frame_tree_node_id != 0) {
            target.appendUint64(RenderFrameImplDeletionWire.FRAME_TREE_NODE_ID_WIRE, self.frame_tree_node_id);
        }
    }
};
pub const RenderFrameImplDeletionReader = struct {
    buf: gremlin.Reader,
    _intent: FrameDeleteIntention = @enumFromInt(0),
    _has_pending_commit: bool = false,
    _has_pending_cross_document_commit: bool = false,
    _frame_tree_node_id: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!RenderFrameImplDeletionReader {
        const buf = gremlin.Reader.init(src);
        var res = RenderFrameImplDeletionReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                RenderFrameImplDeletionWire.INTENT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._intent = @enumFromInt(result.value);
                },
                RenderFrameImplDeletionWire.HAS_PENDING_COMMIT_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._has_pending_commit = result.value;
                },
                RenderFrameImplDeletionWire.HAS_PENDING_CROSS_DOCUMENT_COMMIT_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._has_pending_cross_document_commit = result.value;
                },
                RenderFrameImplDeletionWire.FRAME_TREE_NODE_ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._frame_tree_node_id = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getIntent(self: *const RenderFrameImplDeletionReader) FrameDeleteIntention {
        return self._intent;
    }
    pub inline fn getHasPendingCommit(self: *const RenderFrameImplDeletionReader) bool {
        return self._has_pending_commit;
    }
    pub inline fn getHasPendingCrossDocumentCommit(self: *const RenderFrameImplDeletionReader) bool {
        return self._has_pending_cross_document_commit;
    }
    pub inline fn getFrameTreeNodeId(self: *const RenderFrameImplDeletionReader) u64 {
        return self._frame_tree_node_id;
    }
};
const ShouldSwapBrowsingInstancesResultWire = struct {
    const FRAME_TREE_NODE_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const RESULT_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const ShouldSwapBrowsingInstancesResult = struct {
    // fields
    frame_tree_node_id: u64 = 0,
    result: ShouldSwapBrowsingInstance = @enumFromInt(0),
    pub fn calcProtobufSize(self: *const ShouldSwapBrowsingInstancesResult) usize {
        var res: usize = 0;
        if (self.frame_tree_node_id != 0) {
            res += gremlin.sizes.sizeWireNumber(ShouldSwapBrowsingInstancesResultWire.FRAME_TREE_NODE_ID_WIRE) + gremlin.sizes.sizeU64(self.frame_tree_node_id);
        }
        if (@intFromEnum(self.result) != 0) {
            res += gremlin.sizes.sizeWireNumber(ShouldSwapBrowsingInstancesResultWire.RESULT_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.result));
        }
        return res;
    }
    pub fn encode(self: *const ShouldSwapBrowsingInstancesResult, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ShouldSwapBrowsingInstancesResult, target: *gremlin.Writer) void {
        if (self.frame_tree_node_id != 0) {
            target.appendUint64(ShouldSwapBrowsingInstancesResultWire.FRAME_TREE_NODE_ID_WIRE, self.frame_tree_node_id);
        }
        if (@intFromEnum(self.result) != 0) {
            target.appendInt32(ShouldSwapBrowsingInstancesResultWire.RESULT_WIRE, @intFromEnum(self.result));
        }
    }
};
pub const ShouldSwapBrowsingInstancesResultReader = struct {
    buf: gremlin.Reader,
    _frame_tree_node_id: u64 = 0,
    _result: ShouldSwapBrowsingInstance = @enumFromInt(0),
    pub fn init(src: []const u8) gremlin.Error!ShouldSwapBrowsingInstancesResultReader {
        const buf = gremlin.Reader.init(src);
        var res = ShouldSwapBrowsingInstancesResultReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ShouldSwapBrowsingInstancesResultWire.FRAME_TREE_NODE_ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._frame_tree_node_id = result.value;
                },
                ShouldSwapBrowsingInstancesResultWire.RESULT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._result = @enumFromInt(result.value);
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getFrameTreeNodeId(self: *const ShouldSwapBrowsingInstancesResultReader) u64 {
        return self._frame_tree_node_id;
    }
    pub inline fn getResult(self: *const ShouldSwapBrowsingInstancesResultReader) ShouldSwapBrowsingInstance {
        return self._result;
    }
};
const FrameTreeNodeInfoWire = struct {
    const FRAME_TREE_NODE_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const IS_MAIN_FRAME_WIRE: gremlin.ProtoWireNumber = 2;
    const HAS_SPECULATIVE_RENDER_FRAME_HOST_WIRE: gremlin.ProtoWireNumber = 3;
    const CURRENT_FRAME_HOST_WIRE: gremlin.ProtoWireNumber = 4;
    const SPECULATIVE_FRAME_HOST_WIRE: gremlin.ProtoWireNumber = 5;
    const FRAME_TYPE_WIRE: gremlin.ProtoWireNumber = 6;
    const DEBUG_ANNOTATIONS_WIRE: gremlin.ProtoWireNumber = 99;
};
pub const FrameTreeNodeInfo = struct {
    // nested enums
    pub const FrameType = enum(i32) {
        UNSPECIFIED_FRAME_TYPE = 0,
        SUBFRAME = 1,
        PRIMARY_MAIN_FRAME = 2,
        PRERENDER_MAIN_FRAME = 3,
        FENCED_FRAME_ROOT = 4,
    };
    // fields
    frame_tree_node_id: u64 = 0,
    is_main_frame: bool = false,
    has_speculative_render_frame_host: bool = false,
    current_frame_host: ?RenderFrameHost = null,
    speculative_frame_host: ?RenderFrameHost = null,
    frame_type: FrameTreeNodeInfo.FrameType = @enumFromInt(0),
    debug_annotations: ?[]const ?debug_annotation.DebugAnnotation = null,
    pub fn calcProtobufSize(self: *const FrameTreeNodeInfo) usize {
        var res: usize = 0;
        if (self.frame_tree_node_id != 0) {
            res += gremlin.sizes.sizeWireNumber(FrameTreeNodeInfoWire.FRAME_TREE_NODE_ID_WIRE) + gremlin.sizes.sizeU64(self.frame_tree_node_id);
        }
        if (self.is_main_frame != false) {
            res += gremlin.sizes.sizeWireNumber(FrameTreeNodeInfoWire.IS_MAIN_FRAME_WIRE) + gremlin.sizes.sizeBool(self.is_main_frame);
        }
        if (self.has_speculative_render_frame_host != false) {
            res += gremlin.sizes.sizeWireNumber(FrameTreeNodeInfoWire.HAS_SPECULATIVE_RENDER_FRAME_HOST_WIRE) + gremlin.sizes.sizeBool(self.has_speculative_render_frame_host);
        }
        if (self.current_frame_host) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FrameTreeNodeInfoWire.CURRENT_FRAME_HOST_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.speculative_frame_host) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FrameTreeNodeInfoWire.SPECULATIVE_FRAME_HOST_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (@intFromEnum(self.frame_type) != 0) {
            res += gremlin.sizes.sizeWireNumber(FrameTreeNodeInfoWire.FRAME_TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.frame_type));
        }
        if (self.debug_annotations) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(FrameTreeNodeInfoWire.DEBUG_ANNOTATIONS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const FrameTreeNodeInfo, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const FrameTreeNodeInfo, target: *gremlin.Writer) void {
        if (self.frame_tree_node_id != 0) {
            target.appendUint64(FrameTreeNodeInfoWire.FRAME_TREE_NODE_ID_WIRE, self.frame_tree_node_id);
        }
        if (self.is_main_frame != false) {
            target.appendBool(FrameTreeNodeInfoWire.IS_MAIN_FRAME_WIRE, self.is_main_frame);
        }
        if (self.has_speculative_render_frame_host != false) {
            target.appendBool(FrameTreeNodeInfoWire.HAS_SPECULATIVE_RENDER_FRAME_HOST_WIRE, self.has_speculative_render_frame_host);
        }
        if (self.current_frame_host) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FrameTreeNodeInfoWire.CURRENT_FRAME_HOST_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.speculative_frame_host) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FrameTreeNodeInfoWire.SPECULATIVE_FRAME_HOST_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (@intFromEnum(self.frame_type) != 0) {
            target.appendInt32(FrameTreeNodeInfoWire.FRAME_TYPE_WIRE, @intFromEnum(self.frame_type));
        }
        if (self.debug_annotations) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(FrameTreeNodeInfoWire.DEBUG_ANNOTATIONS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(FrameTreeNodeInfoWire.DEBUG_ANNOTATIONS_WIRE, 0);
                }
            }
        }
    }
};
pub const FrameTreeNodeInfoReader = struct {
    buf: gremlin.Reader,
    _frame_tree_node_id: u64 = 0,
    _is_main_frame: bool = false,
    _has_speculative_render_frame_host: bool = false,
    _current_frame_host_buf: ?[]const u8 = null,
    _speculative_frame_host_buf: ?[]const u8 = null,
    _frame_type: FrameTreeNodeInfo.FrameType = @enumFromInt(0),
    _debug_annotations_offset: ?usize = null,
    _debug_annotations_last_offset: ?usize = null,
    _debug_annotations_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!FrameTreeNodeInfoReader {
        const buf = gremlin.Reader.init(src);
        var res = FrameTreeNodeInfoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                FrameTreeNodeInfoWire.FRAME_TREE_NODE_ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._frame_tree_node_id = result.value;
                },
                FrameTreeNodeInfoWire.IS_MAIN_FRAME_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_main_frame = result.value;
                },
                FrameTreeNodeInfoWire.HAS_SPECULATIVE_RENDER_FRAME_HOST_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._has_speculative_render_frame_host = result.value;
                },
                FrameTreeNodeInfoWire.CURRENT_FRAME_HOST_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._current_frame_host_buf = result.value;
                },
                FrameTreeNodeInfoWire.SPECULATIVE_FRAME_HOST_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._speculative_frame_host_buf = result.value;
                },
                FrameTreeNodeInfoWire.FRAME_TYPE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._frame_type = @enumFromInt(result.value);
                },
                FrameTreeNodeInfoWire.DEBUG_ANNOTATIONS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._debug_annotations_offset == null) {
                        res._debug_annotations_offset = offset - result.size;
                    }
                    res._debug_annotations_last_offset = offset;
                    res._debug_annotations_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getFrameTreeNodeId(self: *const FrameTreeNodeInfoReader) u64 {
        return self._frame_tree_node_id;
    }
    pub inline fn getIsMainFrame(self: *const FrameTreeNodeInfoReader) bool {
        return self._is_main_frame;
    }
    pub inline fn getHasSpeculativeRenderFrameHost(self: *const FrameTreeNodeInfoReader) bool {
        return self._has_speculative_render_frame_host;
    }
    pub fn getCurrentFrameHost(self: *const FrameTreeNodeInfoReader) gremlin.Error!RenderFrameHostReader {
        if (self._current_frame_host_buf) |buf| {
            return try RenderFrameHostReader.init(buf);
        }
        return try RenderFrameHostReader.init(&[_]u8{});
    }
    pub fn getSpeculativeFrameHost(self: *const FrameTreeNodeInfoReader) gremlin.Error!RenderFrameHostReader {
        if (self._speculative_frame_host_buf) |buf| {
            return try RenderFrameHostReader.init(buf);
        }
        return try RenderFrameHostReader.init(&[_]u8{});
    }
    pub inline fn getFrameType(self: *const FrameTreeNodeInfoReader) FrameTreeNodeInfo.FrameType {
        return self._frame_type;
    }
    pub fn debugAnnotationsCount(self: *const FrameTreeNodeInfoReader) usize {
        return self._debug_annotations_cnt;
    }
    pub fn debugAnnotationsNext(self: *FrameTreeNodeInfoReader) ?debug_annotation.DebugAnnotationReader {
        if (self._debug_annotations_offset == null) return null;
        const current_offset = self._debug_annotations_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = debug_annotation.DebugAnnotationReader.init(result.value) catch return null;
        if (self._debug_annotations_last_offset != null and current_offset >= self._debug_annotations_last_offset.?) {
            self._debug_annotations_offset = null;
            return msg;
        }
        if (self._debug_annotations_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._debug_annotations_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == FrameTreeNodeInfoWire.DEBUG_ANNOTATIONS_WIRE) {
                self._debug_annotations_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._debug_annotations_offset = null;
        return msg;
    }
};
const ChromeHashedPerformanceMarkWire = struct {
    const SITE_HASH_WIRE: gremlin.ProtoWireNumber = 1;
    const SITE_WIRE: gremlin.ProtoWireNumber = 2;
    const MARK_HASH_WIRE: gremlin.ProtoWireNumber = 3;
    const MARK_WIRE: gremlin.ProtoWireNumber = 4;
    const EXECUTION_CONTEXT_ID_WIRE: gremlin.ProtoWireNumber = 5;
    const SEQUENCE_NUMBER_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const ChromeHashedPerformanceMark = struct {
    // fields
    site_hash: u32 = 0,
    site: ?[]const u8 = null,
    mark_hash: u32 = 0,
    mark: ?[]const u8 = null,
    execution_context_id: u32 = 0,
    sequence_number: u32 = 0,
    pub fn calcProtobufSize(self: *const ChromeHashedPerformanceMark) usize {
        var res: usize = 0;
        if (self.site_hash != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeHashedPerformanceMarkWire.SITE_HASH_WIRE) + gremlin.sizes.sizeU32(self.site_hash);
        }
        if (self.site) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeHashedPerformanceMarkWire.SITE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.mark_hash != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeHashedPerformanceMarkWire.MARK_HASH_WIRE) + gremlin.sizes.sizeU32(self.mark_hash);
        }
        if (self.mark) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeHashedPerformanceMarkWire.MARK_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.execution_context_id != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeHashedPerformanceMarkWire.EXECUTION_CONTEXT_ID_WIRE) + gremlin.sizes.sizeU32(self.execution_context_id);
        }
        if (self.sequence_number != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeHashedPerformanceMarkWire.SEQUENCE_NUMBER_WIRE) + gremlin.sizes.sizeU32(self.sequence_number);
        }
        return res;
    }
    pub fn encode(self: *const ChromeHashedPerformanceMark, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ChromeHashedPerformanceMark, target: *gremlin.Writer) void {
        if (self.site_hash != 0) {
            target.appendUint32(ChromeHashedPerformanceMarkWire.SITE_HASH_WIRE, self.site_hash);
        }
        if (self.site) |v| {
            if (v.len > 0) {
                target.appendBytes(ChromeHashedPerformanceMarkWire.SITE_WIRE, v);
            }
        }
        if (self.mark_hash != 0) {
            target.appendUint32(ChromeHashedPerformanceMarkWire.MARK_HASH_WIRE, self.mark_hash);
        }
        if (self.mark) |v| {
            if (v.len > 0) {
                target.appendBytes(ChromeHashedPerformanceMarkWire.MARK_WIRE, v);
            }
        }
        if (self.execution_context_id != 0) {
            target.appendUint32(ChromeHashedPerformanceMarkWire.EXECUTION_CONTEXT_ID_WIRE, self.execution_context_id);
        }
        if (self.sequence_number != 0) {
            target.appendUint32(ChromeHashedPerformanceMarkWire.SEQUENCE_NUMBER_WIRE, self.sequence_number);
        }
    }
};
pub const ChromeHashedPerformanceMarkReader = struct {
    buf: gremlin.Reader,
    _site_hash: u32 = 0,
    _site: ?[]const u8 = null,
    _mark_hash: u32 = 0,
    _mark: ?[]const u8 = null,
    _execution_context_id: u32 = 0,
    _sequence_number: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!ChromeHashedPerformanceMarkReader {
        const buf = gremlin.Reader.init(src);
        var res = ChromeHashedPerformanceMarkReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ChromeHashedPerformanceMarkWire.SITE_HASH_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._site_hash = result.value;
                },
                ChromeHashedPerformanceMarkWire.SITE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._site = result.value;
                },
                ChromeHashedPerformanceMarkWire.MARK_HASH_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._mark_hash = result.value;
                },
                ChromeHashedPerformanceMarkWire.MARK_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mark = result.value;
                },
                ChromeHashedPerformanceMarkWire.EXECUTION_CONTEXT_ID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._execution_context_id = result.value;
                },
                ChromeHashedPerformanceMarkWire.SEQUENCE_NUMBER_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._sequence_number = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getSiteHash(self: *const ChromeHashedPerformanceMarkReader) u32 {
        return self._site_hash;
    }
    pub inline fn getSite(self: *const ChromeHashedPerformanceMarkReader) []const u8 {
        return self._site orelse &[_]u8{};
    }
    pub inline fn getMarkHash(self: *const ChromeHashedPerformanceMarkReader) u32 {
        return self._mark_hash;
    }
    pub inline fn getMark(self: *const ChromeHashedPerformanceMarkReader) []const u8 {
        return self._mark orelse &[_]u8{};
    }
    pub inline fn getExecutionContextId(self: *const ChromeHashedPerformanceMarkReader) u32 {
        return self._execution_context_id;
    }
    pub inline fn getSequenceNumber(self: *const ChromeHashedPerformanceMarkReader) u32 {
        return self._sequence_number;
    }
};
const ChromeSqlDiagnosticsWire = struct {
    const REPORTED_SQLITE_ERROR_CODE_WIRE: gremlin.ProtoWireNumber = 1;
    const ERROR_CODE_WIRE: gremlin.ProtoWireNumber = 2;
    const LAST_ERRNO_WIRE: gremlin.ProtoWireNumber = 3;
    const SQL_STATEMENT_WIRE: gremlin.ProtoWireNumber = 4;
    const VERSION_WIRE: gremlin.ProtoWireNumber = 5;
    const SCHEMA_SQL_ROWS_WIRE: gremlin.ProtoWireNumber = 6;
    const SCHEMA_OTHER_ROW_NAMES_WIRE: gremlin.ProtoWireNumber = 7;
    const HAS_VALID_HEADER_WIRE: gremlin.ProtoWireNumber = 8;
    const HAS_VALID_SCHEMA_WIRE: gremlin.ProtoWireNumber = 9;
    const ERROR_MESSAGE_WIRE: gremlin.ProtoWireNumber = 10;
};
pub const ChromeSqlDiagnostics = struct {
    // fields
    reported_sqlite_error_code: i32 = 0,
    error_code: i32 = 0,
    last_errno: i32 = 0,
    sql_statement: ?[]const u8 = null,
    version: i32 = 0,
    schema_sql_rows: ?[]const ?[]const u8 = null,
    schema_other_row_names: ?[]const ?[]const u8 = null,
    has_valid_header: bool = false,
    has_valid_schema: bool = false,
    error_message: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const ChromeSqlDiagnostics) usize {
        var res: usize = 0;
        if (self.reported_sqlite_error_code != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeSqlDiagnosticsWire.REPORTED_SQLITE_ERROR_CODE_WIRE) + gremlin.sizes.sizeI32(self.reported_sqlite_error_code);
        }
        if (self.error_code != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeSqlDiagnosticsWire.ERROR_CODE_WIRE) + gremlin.sizes.sizeI32(self.error_code);
        }
        if (self.last_errno != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeSqlDiagnosticsWire.LAST_ERRNO_WIRE) + gremlin.sizes.sizeI32(self.last_errno);
        }
        if (self.sql_statement) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeSqlDiagnosticsWire.SQL_STATEMENT_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.version != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeSqlDiagnosticsWire.VERSION_WIRE) + gremlin.sizes.sizeI32(self.version);
        }
        if (self.schema_sql_rows) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ChromeSqlDiagnosticsWire.SCHEMA_SQL_ROWS_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.schema_other_row_names) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ChromeSqlDiagnosticsWire.SCHEMA_OTHER_ROW_NAMES_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.has_valid_header != false) {
            res += gremlin.sizes.sizeWireNumber(ChromeSqlDiagnosticsWire.HAS_VALID_HEADER_WIRE) + gremlin.sizes.sizeBool(self.has_valid_header);
        }
        if (self.has_valid_schema != false) {
            res += gremlin.sizes.sizeWireNumber(ChromeSqlDiagnosticsWire.HAS_VALID_SCHEMA_WIRE) + gremlin.sizes.sizeBool(self.has_valid_schema);
        }
        if (self.error_message) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeSqlDiagnosticsWire.ERROR_MESSAGE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const ChromeSqlDiagnostics, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ChromeSqlDiagnostics, target: *gremlin.Writer) void {
        if (self.reported_sqlite_error_code != 0) {
            target.appendInt32(ChromeSqlDiagnosticsWire.REPORTED_SQLITE_ERROR_CODE_WIRE, self.reported_sqlite_error_code);
        }
        if (self.error_code != 0) {
            target.appendInt32(ChromeSqlDiagnosticsWire.ERROR_CODE_WIRE, self.error_code);
        }
        if (self.last_errno != 0) {
            target.appendInt32(ChromeSqlDiagnosticsWire.LAST_ERRNO_WIRE, self.last_errno);
        }
        if (self.sql_statement) |v| {
            if (v.len > 0) {
                target.appendBytes(ChromeSqlDiagnosticsWire.SQL_STATEMENT_WIRE, v);
            }
        }
        if (self.version != 0) {
            target.appendInt32(ChromeSqlDiagnosticsWire.VERSION_WIRE, self.version);
        }
        if (self.schema_sql_rows) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(ChromeSqlDiagnosticsWire.SCHEMA_SQL_ROWS_WIRE, v);
                } else {
                    target.appendBytesTag(ChromeSqlDiagnosticsWire.SCHEMA_SQL_ROWS_WIRE, 0);
                }
            }
        }
        if (self.schema_other_row_names) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(ChromeSqlDiagnosticsWire.SCHEMA_OTHER_ROW_NAMES_WIRE, v);
                } else {
                    target.appendBytesTag(ChromeSqlDiagnosticsWire.SCHEMA_OTHER_ROW_NAMES_WIRE, 0);
                }
            }
        }
        if (self.has_valid_header != false) {
            target.appendBool(ChromeSqlDiagnosticsWire.HAS_VALID_HEADER_WIRE, self.has_valid_header);
        }
        if (self.has_valid_schema != false) {
            target.appendBool(ChromeSqlDiagnosticsWire.HAS_VALID_SCHEMA_WIRE, self.has_valid_schema);
        }
        if (self.error_message) |v| {
            if (v.len > 0) {
                target.appendBytes(ChromeSqlDiagnosticsWire.ERROR_MESSAGE_WIRE, v);
            }
        }
    }
};
pub const ChromeSqlDiagnosticsReader = struct {
    buf: gremlin.Reader,
    _reported_sqlite_error_code: i32 = 0,
    _error_code: i32 = 0,
    _last_errno: i32 = 0,
    _sql_statement: ?[]const u8 = null,
    _version: i32 = 0,
    _schema_sql_rows_offset: ?usize = null,
    _schema_sql_rows_last_offset: ?usize = null,
    _schema_sql_rows_cnt: usize = 0,
    _schema_other_row_names_offset: ?usize = null,
    _schema_other_row_names_last_offset: ?usize = null,
    _schema_other_row_names_cnt: usize = 0,
    _has_valid_header: bool = false,
    _has_valid_schema: bool = false,
    _error_message: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!ChromeSqlDiagnosticsReader {
        const buf = gremlin.Reader.init(src);
        var res = ChromeSqlDiagnosticsReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ChromeSqlDiagnosticsWire.REPORTED_SQLITE_ERROR_CODE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._reported_sqlite_error_code = result.value;
                },
                ChromeSqlDiagnosticsWire.ERROR_CODE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._error_code = result.value;
                },
                ChromeSqlDiagnosticsWire.LAST_ERRNO_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._last_errno = result.value;
                },
                ChromeSqlDiagnosticsWire.SQL_STATEMENT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._sql_statement = result.value;
                },
                ChromeSqlDiagnosticsWire.VERSION_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._version = result.value;
                },
                ChromeSqlDiagnosticsWire.SCHEMA_SQL_ROWS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._schema_sql_rows_offset == null) {
                        res._schema_sql_rows_offset = offset - result.size;
                    }
                    res._schema_sql_rows_last_offset = offset;
                    res._schema_sql_rows_cnt += 1;
                },
                ChromeSqlDiagnosticsWire.SCHEMA_OTHER_ROW_NAMES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._schema_other_row_names_offset == null) {
                        res._schema_other_row_names_offset = offset - result.size;
                    }
                    res._schema_other_row_names_last_offset = offset;
                    res._schema_other_row_names_cnt += 1;
                },
                ChromeSqlDiagnosticsWire.HAS_VALID_HEADER_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._has_valid_header = result.value;
                },
                ChromeSqlDiagnosticsWire.HAS_VALID_SCHEMA_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._has_valid_schema = result.value;
                },
                ChromeSqlDiagnosticsWire.ERROR_MESSAGE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._error_message = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getReportedSqliteErrorCode(self: *const ChromeSqlDiagnosticsReader) i32 {
        return self._reported_sqlite_error_code;
    }
    pub inline fn getErrorCode(self: *const ChromeSqlDiagnosticsReader) i32 {
        return self._error_code;
    }
    pub inline fn getLastErrno(self: *const ChromeSqlDiagnosticsReader) i32 {
        return self._last_errno;
    }
    pub inline fn getSqlStatement(self: *const ChromeSqlDiagnosticsReader) []const u8 {
        return self._sql_statement orelse &[_]u8{};
    }
    pub inline fn getVersion(self: *const ChromeSqlDiagnosticsReader) i32 {
        return self._version;
    }
    pub fn schemaSqlRowsCount(self: *const ChromeSqlDiagnosticsReader) usize {
        return self._schema_sql_rows_cnt;
    }
    pub fn schemaSqlRowsNext(self: *ChromeSqlDiagnosticsReader) ?[]const u8 {
        if (self._schema_sql_rows_offset == null) return null;
        const current_offset = self._schema_sql_rows_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._schema_sql_rows_last_offset != null and current_offset >= self._schema_sql_rows_last_offset.?) {
            self._schema_sql_rows_offset = null;
            return result.value;
        }
        if (self._schema_sql_rows_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._schema_sql_rows_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ChromeSqlDiagnosticsWire.SCHEMA_SQL_ROWS_WIRE) {
                self._schema_sql_rows_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._schema_sql_rows_offset = null;
        return result.value;
    }
    pub fn schemaOtherRowNamesCount(self: *const ChromeSqlDiagnosticsReader) usize {
        return self._schema_other_row_names_cnt;
    }
    pub fn schemaOtherRowNamesNext(self: *ChromeSqlDiagnosticsReader) ?[]const u8 {
        if (self._schema_other_row_names_offset == null) return null;
        const current_offset = self._schema_other_row_names_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._schema_other_row_names_last_offset != null and current_offset >= self._schema_other_row_names_last_offset.?) {
            self._schema_other_row_names_offset = null;
            return result.value;
        }
        if (self._schema_other_row_names_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._schema_other_row_names_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ChromeSqlDiagnosticsWire.SCHEMA_OTHER_ROW_NAMES_WIRE) {
                self._schema_other_row_names_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._schema_other_row_names_offset = null;
        return result.value;
    }
    pub inline fn getHasValidHeader(self: *const ChromeSqlDiagnosticsReader) bool {
        return self._has_valid_header;
    }
    pub inline fn getHasValidSchema(self: *const ChromeSqlDiagnosticsReader) bool {
        return self._has_valid_schema;
    }
    pub inline fn getErrorMessage(self: *const ChromeSqlDiagnosticsReader) []const u8 {
        return self._error_message orelse &[_]u8{};
    }
};
const ChromeWebAppBadNavigateWire = struct {
    const IS_KIOSK_WIRE: gremlin.ProtoWireNumber = 1;
    const HAS_HOSTED_APP_CONTROLLER_WIRE: gremlin.ProtoWireNumber = 2;
    const APP_NAME_WIRE: gremlin.ProtoWireNumber = 3;
    const SYSTEM_APP_TYPE_WIRE: gremlin.ProtoWireNumber = 4;
    const WEB_APP_PROVIDER_REGISTRY_READY_WIRE: gremlin.ProtoWireNumber = 5;
    const SYSTEM_WEB_APP_MANAGER_SYNCHRONIZED_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const ChromeWebAppBadNavigate = struct {
    // fields
    is_kiosk: bool = false,
    has_hosted_app_controller: bool = false,
    app_name: ?[]const u8 = null,
    system_app_type: u32 = 0,
    web_app_provider_registry_ready: bool = false,
    system_web_app_manager_synchronized: bool = false,
    pub fn calcProtobufSize(self: *const ChromeWebAppBadNavigate) usize {
        var res: usize = 0;
        if (self.is_kiosk != false) {
            res += gremlin.sizes.sizeWireNumber(ChromeWebAppBadNavigateWire.IS_KIOSK_WIRE) + gremlin.sizes.sizeBool(self.is_kiosk);
        }
        if (self.has_hosted_app_controller != false) {
            res += gremlin.sizes.sizeWireNumber(ChromeWebAppBadNavigateWire.HAS_HOSTED_APP_CONTROLLER_WIRE) + gremlin.sizes.sizeBool(self.has_hosted_app_controller);
        }
        if (self.app_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeWebAppBadNavigateWire.APP_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.system_app_type != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeWebAppBadNavigateWire.SYSTEM_APP_TYPE_WIRE) + gremlin.sizes.sizeU32(self.system_app_type);
        }
        if (self.web_app_provider_registry_ready != false) {
            res += gremlin.sizes.sizeWireNumber(ChromeWebAppBadNavigateWire.WEB_APP_PROVIDER_REGISTRY_READY_WIRE) + gremlin.sizes.sizeBool(self.web_app_provider_registry_ready);
        }
        if (self.system_web_app_manager_synchronized != false) {
            res += gremlin.sizes.sizeWireNumber(ChromeWebAppBadNavigateWire.SYSTEM_WEB_APP_MANAGER_SYNCHRONIZED_WIRE) + gremlin.sizes.sizeBool(self.system_web_app_manager_synchronized);
        }
        return res;
    }
    pub fn encode(self: *const ChromeWebAppBadNavigate, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ChromeWebAppBadNavigate, target: *gremlin.Writer) void {
        if (self.is_kiosk != false) {
            target.appendBool(ChromeWebAppBadNavigateWire.IS_KIOSK_WIRE, self.is_kiosk);
        }
        if (self.has_hosted_app_controller != false) {
            target.appendBool(ChromeWebAppBadNavigateWire.HAS_HOSTED_APP_CONTROLLER_WIRE, self.has_hosted_app_controller);
        }
        if (self.app_name) |v| {
            if (v.len > 0) {
                target.appendBytes(ChromeWebAppBadNavigateWire.APP_NAME_WIRE, v);
            }
        }
        if (self.system_app_type != 0) {
            target.appendUint32(ChromeWebAppBadNavigateWire.SYSTEM_APP_TYPE_WIRE, self.system_app_type);
        }
        if (self.web_app_provider_registry_ready != false) {
            target.appendBool(ChromeWebAppBadNavigateWire.WEB_APP_PROVIDER_REGISTRY_READY_WIRE, self.web_app_provider_registry_ready);
        }
        if (self.system_web_app_manager_synchronized != false) {
            target.appendBool(ChromeWebAppBadNavigateWire.SYSTEM_WEB_APP_MANAGER_SYNCHRONIZED_WIRE, self.system_web_app_manager_synchronized);
        }
    }
};
pub const ChromeWebAppBadNavigateReader = struct {
    buf: gremlin.Reader,
    _is_kiosk: bool = false,
    _has_hosted_app_controller: bool = false,
    _app_name: ?[]const u8 = null,
    _system_app_type: u32 = 0,
    _web_app_provider_registry_ready: bool = false,
    _system_web_app_manager_synchronized: bool = false,
    pub fn init(src: []const u8) gremlin.Error!ChromeWebAppBadNavigateReader {
        const buf = gremlin.Reader.init(src);
        var res = ChromeWebAppBadNavigateReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ChromeWebAppBadNavigateWire.IS_KIOSK_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_kiosk = result.value;
                },
                ChromeWebAppBadNavigateWire.HAS_HOSTED_APP_CONTROLLER_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._has_hosted_app_controller = result.value;
                },
                ChromeWebAppBadNavigateWire.APP_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._app_name = result.value;
                },
                ChromeWebAppBadNavigateWire.SYSTEM_APP_TYPE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._system_app_type = result.value;
                },
                ChromeWebAppBadNavigateWire.WEB_APP_PROVIDER_REGISTRY_READY_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._web_app_provider_registry_ready = result.value;
                },
                ChromeWebAppBadNavigateWire.SYSTEM_WEB_APP_MANAGER_SYNCHRONIZED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._system_web_app_manager_synchronized = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getIsKiosk(self: *const ChromeWebAppBadNavigateReader) bool {
        return self._is_kiosk;
    }
    pub inline fn getHasHostedAppController(self: *const ChromeWebAppBadNavigateReader) bool {
        return self._has_hosted_app_controller;
    }
    pub inline fn getAppName(self: *const ChromeWebAppBadNavigateReader) []const u8 {
        return self._app_name orelse &[_]u8{};
    }
    pub inline fn getSystemAppType(self: *const ChromeWebAppBadNavigateReader) u32 {
        return self._system_app_type;
    }
    pub inline fn getWebAppProviderRegistryReady(self: *const ChromeWebAppBadNavigateReader) bool {
        return self._web_app_provider_registry_ready;
    }
    pub inline fn getSystemWebAppManagerSynchronized(self: *const ChromeWebAppBadNavigateReader) bool {
        return self._system_web_app_manager_synchronized;
    }
};
const ResourceBundleWire = struct {
    const RESOURCE_ID_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const ResourceBundle = struct {
    // fields
    resource_id: u32 = 0,
    pub fn calcProtobufSize(self: *const ResourceBundle) usize {
        var res: usize = 0;
        if (self.resource_id != 0) {
            res += gremlin.sizes.sizeWireNumber(ResourceBundleWire.RESOURCE_ID_WIRE) + gremlin.sizes.sizeU32(self.resource_id);
        }
        return res;
    }
    pub fn encode(self: *const ResourceBundle, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ResourceBundle, target: *gremlin.Writer) void {
        if (self.resource_id != 0) {
            target.appendUint32(ResourceBundleWire.RESOURCE_ID_WIRE, self.resource_id);
        }
    }
};
pub const ResourceBundleReader = struct {
    buf: gremlin.Reader,
    _resource_id: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!ResourceBundleReader {
        const buf = gremlin.Reader.init(src);
        var res = ResourceBundleReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ResourceBundleWire.RESOURCE_ID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._resource_id = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getResourceId(self: *const ResourceBundleReader) u32 {
        return self._resource_id;
    }
};
const RenderProcessHostWire = struct {
    const ID_WIRE: gremlin.ProtoWireNumber = 1;
    const PROCESS_LOCK_WIRE: gremlin.ProtoWireNumber = 2;
    const CHILD_PROCESS_ID_WIRE: gremlin.ProtoWireNumber = 3;
    const BROWSER_CONTEXT_WIRE: gremlin.ProtoWireNumber = 4;
    const DEBUG_ANNOTATIONS_WIRE: gremlin.ProtoWireNumber = 99;
};
pub const RenderProcessHost = struct {
    // fields
    id: u32 = 0,
    process_lock: ?[]const u8 = null,
    child_process_id: i32 = 0,
    browser_context: ?ChromeBrowserContext = null,
    debug_annotations: ?[]const ?debug_annotation.DebugAnnotation = null,
    pub fn calcProtobufSize(self: *const RenderProcessHost) usize {
        var res: usize = 0;
        if (self.id != 0) {
            res += gremlin.sizes.sizeWireNumber(RenderProcessHostWire.ID_WIRE) + gremlin.sizes.sizeU32(self.id);
        }
        if (self.process_lock) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(RenderProcessHostWire.PROCESS_LOCK_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.child_process_id != 0) {
            res += gremlin.sizes.sizeWireNumber(RenderProcessHostWire.CHILD_PROCESS_ID_WIRE) + gremlin.sizes.sizeI32(self.child_process_id);
        }
        if (self.browser_context) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(RenderProcessHostWire.BROWSER_CONTEXT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.debug_annotations) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(RenderProcessHostWire.DEBUG_ANNOTATIONS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const RenderProcessHost, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const RenderProcessHost, target: *gremlin.Writer) void {
        if (self.id != 0) {
            target.appendUint32(RenderProcessHostWire.ID_WIRE, self.id);
        }
        if (self.process_lock) |v| {
            if (v.len > 0) {
                target.appendBytes(RenderProcessHostWire.PROCESS_LOCK_WIRE, v);
            }
        }
        if (self.child_process_id != 0) {
            target.appendInt32(RenderProcessHostWire.CHILD_PROCESS_ID_WIRE, self.child_process_id);
        }
        if (self.browser_context) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(RenderProcessHostWire.BROWSER_CONTEXT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.debug_annotations) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(RenderProcessHostWire.DEBUG_ANNOTATIONS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(RenderProcessHostWire.DEBUG_ANNOTATIONS_WIRE, 0);
                }
            }
        }
    }
};
pub const RenderProcessHostReader = struct {
    buf: gremlin.Reader,
    _id: u32 = 0,
    _process_lock: ?[]const u8 = null,
    _child_process_id: i32 = 0,
    _browser_context_buf: ?[]const u8 = null,
    _debug_annotations_offset: ?usize = null,
    _debug_annotations_last_offset: ?usize = null,
    _debug_annotations_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!RenderProcessHostReader {
        const buf = gremlin.Reader.init(src);
        var res = RenderProcessHostReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                RenderProcessHostWire.ID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._id = result.value;
                },
                RenderProcessHostWire.PROCESS_LOCK_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._process_lock = result.value;
                },
                RenderProcessHostWire.CHILD_PROCESS_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._child_process_id = result.value;
                },
                RenderProcessHostWire.BROWSER_CONTEXT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._browser_context_buf = result.value;
                },
                RenderProcessHostWire.DEBUG_ANNOTATIONS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._debug_annotations_offset == null) {
                        res._debug_annotations_offset = offset - result.size;
                    }
                    res._debug_annotations_last_offset = offset;
                    res._debug_annotations_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getId(self: *const RenderProcessHostReader) u32 {
        return self._id;
    }
    pub inline fn getProcessLock(self: *const RenderProcessHostReader) []const u8 {
        return self._process_lock orelse &[_]u8{};
    }
    pub inline fn getChildProcessId(self: *const RenderProcessHostReader) i32 {
        return self._child_process_id;
    }
    pub fn getBrowserContext(self: *const RenderProcessHostReader) gremlin.Error!ChromeBrowserContextReader {
        if (self._browser_context_buf) |buf| {
            return try ChromeBrowserContextReader.init(buf);
        }
        return try ChromeBrowserContextReader.init(&[_]u8{});
    }
    pub fn debugAnnotationsCount(self: *const RenderProcessHostReader) usize {
        return self._debug_annotations_cnt;
    }
    pub fn debugAnnotationsNext(self: *RenderProcessHostReader) ?debug_annotation.DebugAnnotationReader {
        if (self._debug_annotations_offset == null) return null;
        const current_offset = self._debug_annotations_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = debug_annotation.DebugAnnotationReader.init(result.value) catch return null;
        if (self._debug_annotations_last_offset != null and current_offset >= self._debug_annotations_last_offset.?) {
            self._debug_annotations_offset = null;
            return msg;
        }
        if (self._debug_annotations_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._debug_annotations_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == RenderProcessHostWire.DEBUG_ANNOTATIONS_WIRE) {
                self._debug_annotations_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._debug_annotations_offset = null;
        return msg;
    }
};
const RenderProcessHostListenerWire = struct {
    const ROUTING_ID_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const RenderProcessHostListener = struct {
    // fields
    routing_id: u32 = 0,
    pub fn calcProtobufSize(self: *const RenderProcessHostListener) usize {
        var res: usize = 0;
        if (self.routing_id != 0) {
            res += gremlin.sizes.sizeWireNumber(RenderProcessHostListenerWire.ROUTING_ID_WIRE) + gremlin.sizes.sizeU32(self.routing_id);
        }
        return res;
    }
    pub fn encode(self: *const RenderProcessHostListener, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const RenderProcessHostListener, target: *gremlin.Writer) void {
        if (self.routing_id != 0) {
            target.appendUint32(RenderProcessHostListenerWire.ROUTING_ID_WIRE, self.routing_id);
        }
    }
};
pub const RenderProcessHostListenerReader = struct {
    buf: gremlin.Reader,
    _routing_id: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!RenderProcessHostListenerReader {
        const buf = gremlin.Reader.init(src);
        var res = RenderProcessHostListenerReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                RenderProcessHostListenerWire.ROUTING_ID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._routing_id = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getRoutingId(self: *const RenderProcessHostListenerReader) u32 {
        return self._routing_id;
    }
};
const RenderProcessHostCleanupWire = struct {
    const LISTENER_COUNT_WIRE: gremlin.ProtoWireNumber = 1;
    const KEEP_ALIVE_REF_COUNT_WIRE: gremlin.ProtoWireNumber = 2;
    const SHUTDOWN_DELAY_REF_COUNT_WIRE: gremlin.ProtoWireNumber = 3;
    const WORKER_REF_COUNT_WIRE: gremlin.ProtoWireNumber = 4;
    const PENDING_REUSE_REF_COUNT_WIRE: gremlin.ProtoWireNumber = 5;
    const NAVIGATION_STATE_KEEPALIVE_COUNT_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const RenderProcessHostCleanup = struct {
    // fields
    listener_count: u32 = 0,
    keep_alive_ref_count: u32 = 0,
    shutdown_delay_ref_count: u32 = 0,
    worker_ref_count: u32 = 0,
    pending_reuse_ref_count: u32 = 0,
    navigation_state_keepalive_count: u32 = 0,
    pub fn calcProtobufSize(self: *const RenderProcessHostCleanup) usize {
        var res: usize = 0;
        if (self.listener_count != 0) {
            res += gremlin.sizes.sizeWireNumber(RenderProcessHostCleanupWire.LISTENER_COUNT_WIRE) + gremlin.sizes.sizeU32(self.listener_count);
        }
        if (self.keep_alive_ref_count != 0) {
            res += gremlin.sizes.sizeWireNumber(RenderProcessHostCleanupWire.KEEP_ALIVE_REF_COUNT_WIRE) + gremlin.sizes.sizeU32(self.keep_alive_ref_count);
        }
        if (self.shutdown_delay_ref_count != 0) {
            res += gremlin.sizes.sizeWireNumber(RenderProcessHostCleanupWire.SHUTDOWN_DELAY_REF_COUNT_WIRE) + gremlin.sizes.sizeU32(self.shutdown_delay_ref_count);
        }
        if (self.worker_ref_count != 0) {
            res += gremlin.sizes.sizeWireNumber(RenderProcessHostCleanupWire.WORKER_REF_COUNT_WIRE) + gremlin.sizes.sizeU32(self.worker_ref_count);
        }
        if (self.pending_reuse_ref_count != 0) {
            res += gremlin.sizes.sizeWireNumber(RenderProcessHostCleanupWire.PENDING_REUSE_REF_COUNT_WIRE) + gremlin.sizes.sizeU32(self.pending_reuse_ref_count);
        }
        if (self.navigation_state_keepalive_count != 0) {
            res += gremlin.sizes.sizeWireNumber(RenderProcessHostCleanupWire.NAVIGATION_STATE_KEEPALIVE_COUNT_WIRE) + gremlin.sizes.sizeU32(self.navigation_state_keepalive_count);
        }
        return res;
    }
    pub fn encode(self: *const RenderProcessHostCleanup, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const RenderProcessHostCleanup, target: *gremlin.Writer) void {
        if (self.listener_count != 0) {
            target.appendUint32(RenderProcessHostCleanupWire.LISTENER_COUNT_WIRE, self.listener_count);
        }
        if (self.keep_alive_ref_count != 0) {
            target.appendUint32(RenderProcessHostCleanupWire.KEEP_ALIVE_REF_COUNT_WIRE, self.keep_alive_ref_count);
        }
        if (self.shutdown_delay_ref_count != 0) {
            target.appendUint32(RenderProcessHostCleanupWire.SHUTDOWN_DELAY_REF_COUNT_WIRE, self.shutdown_delay_ref_count);
        }
        if (self.worker_ref_count != 0) {
            target.appendUint32(RenderProcessHostCleanupWire.WORKER_REF_COUNT_WIRE, self.worker_ref_count);
        }
        if (self.pending_reuse_ref_count != 0) {
            target.appendUint32(RenderProcessHostCleanupWire.PENDING_REUSE_REF_COUNT_WIRE, self.pending_reuse_ref_count);
        }
        if (self.navigation_state_keepalive_count != 0) {
            target.appendUint32(RenderProcessHostCleanupWire.NAVIGATION_STATE_KEEPALIVE_COUNT_WIRE, self.navigation_state_keepalive_count);
        }
    }
};
pub const RenderProcessHostCleanupReader = struct {
    buf: gremlin.Reader,
    _listener_count: u32 = 0,
    _keep_alive_ref_count: u32 = 0,
    _shutdown_delay_ref_count: u32 = 0,
    _worker_ref_count: u32 = 0,
    _pending_reuse_ref_count: u32 = 0,
    _navigation_state_keepalive_count: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!RenderProcessHostCleanupReader {
        const buf = gremlin.Reader.init(src);
        var res = RenderProcessHostCleanupReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                RenderProcessHostCleanupWire.LISTENER_COUNT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._listener_count = result.value;
                },
                RenderProcessHostCleanupWire.KEEP_ALIVE_REF_COUNT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._keep_alive_ref_count = result.value;
                },
                RenderProcessHostCleanupWire.SHUTDOWN_DELAY_REF_COUNT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._shutdown_delay_ref_count = result.value;
                },
                RenderProcessHostCleanupWire.WORKER_REF_COUNT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._worker_ref_count = result.value;
                },
                RenderProcessHostCleanupWire.PENDING_REUSE_REF_COUNT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._pending_reuse_ref_count = result.value;
                },
                RenderProcessHostCleanupWire.NAVIGATION_STATE_KEEPALIVE_COUNT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._navigation_state_keepalive_count = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getListenerCount(self: *const RenderProcessHostCleanupReader) u32 {
        return self._listener_count;
    }
    pub inline fn getKeepAliveRefCount(self: *const RenderProcessHostCleanupReader) u32 {
        return self._keep_alive_ref_count;
    }
    pub inline fn getShutdownDelayRefCount(self: *const RenderProcessHostCleanupReader) u32 {
        return self._shutdown_delay_ref_count;
    }
    pub inline fn getWorkerRefCount(self: *const RenderProcessHostCleanupReader) u32 {
        return self._worker_ref_count;
    }
    pub inline fn getPendingReuseRefCount(self: *const RenderProcessHostCleanupReader) u32 {
        return self._pending_reuse_ref_count;
    }
    pub inline fn getNavigationStateKeepaliveCount(self: *const RenderProcessHostCleanupReader) u32 {
        return self._navigation_state_keepalive_count;
    }
};
const ChildProcessLauncherPriorityWire = struct {
    const IS_BACKGROUNDED_WIRE: gremlin.ProtoWireNumber = 1;
    const HAS_PENDING_VIEWS_WIRE: gremlin.ProtoWireNumber = 2;
    const IMPORTANCE_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const ChildProcessLauncherPriority = struct {
    // nested enums
    pub const Importance = enum(i32) {
        IMPORTANCE_NORMAL = 1,
        IMPORTANCE_MODERATE = 2,
        IMPORTANCE_IMPORTANT = 3,
        IMPORTANCE_PERCEPTIBLE = 4,
        _PROTOBUF_UNKNOWN = 0,
    };
    // fields
    is_backgrounded: bool = false,
    has_pending_views: bool = false,
    importance: ChildProcessLauncherPriority.Importance = @enumFromInt(0),
    pub fn calcProtobufSize(self: *const ChildProcessLauncherPriority) usize {
        var res: usize = 0;
        if (self.is_backgrounded != false) {
            res += gremlin.sizes.sizeWireNumber(ChildProcessLauncherPriorityWire.IS_BACKGROUNDED_WIRE) + gremlin.sizes.sizeBool(self.is_backgrounded);
        }
        if (self.has_pending_views != false) {
            res += gremlin.sizes.sizeWireNumber(ChildProcessLauncherPriorityWire.HAS_PENDING_VIEWS_WIRE) + gremlin.sizes.sizeBool(self.has_pending_views);
        }
        if (@intFromEnum(self.importance) != 0) {
            res += gremlin.sizes.sizeWireNumber(ChildProcessLauncherPriorityWire.IMPORTANCE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.importance));
        }
        return res;
    }
    pub fn encode(self: *const ChildProcessLauncherPriority, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ChildProcessLauncherPriority, target: *gremlin.Writer) void {
        if (self.is_backgrounded != false) {
            target.appendBool(ChildProcessLauncherPriorityWire.IS_BACKGROUNDED_WIRE, self.is_backgrounded);
        }
        if (self.has_pending_views != false) {
            target.appendBool(ChildProcessLauncherPriorityWire.HAS_PENDING_VIEWS_WIRE, self.has_pending_views);
        }
        if (@intFromEnum(self.importance) != 0) {
            target.appendInt32(ChildProcessLauncherPriorityWire.IMPORTANCE_WIRE, @intFromEnum(self.importance));
        }
    }
};
pub const ChildProcessLauncherPriorityReader = struct {
    buf: gremlin.Reader,
    _is_backgrounded: bool = false,
    _has_pending_views: bool = false,
    _importance: ChildProcessLauncherPriority.Importance = @enumFromInt(0),
    pub fn init(src: []const u8) gremlin.Error!ChildProcessLauncherPriorityReader {
        const buf = gremlin.Reader.init(src);
        var res = ChildProcessLauncherPriorityReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ChildProcessLauncherPriorityWire.IS_BACKGROUNDED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_backgrounded = result.value;
                },
                ChildProcessLauncherPriorityWire.HAS_PENDING_VIEWS_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._has_pending_views = result.value;
                },
                ChildProcessLauncherPriorityWire.IMPORTANCE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._importance = @enumFromInt(result.value);
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getIsBackgrounded(self: *const ChildProcessLauncherPriorityReader) bool {
        return self._is_backgrounded;
    }
    pub inline fn getHasPendingViews(self: *const ChildProcessLauncherPriorityReader) bool {
        return self._has_pending_views;
    }
    pub inline fn getImportance(self: *const ChildProcessLauncherPriorityReader) ChildProcessLauncherPriority.Importance {
        return self._importance;
    }
};
const ChromeExtensionIdWire = struct {
    const EXTENSION_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const PSEUDONYMIZED_EXTENSION_ID_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const ChromeExtensionId = struct {
    // fields
    extension_id: ?[]const u8 = null,
    pseudonymized_extension_id: u32 = 0,
    pub fn calcProtobufSize(self: *const ChromeExtensionId) usize {
        var res: usize = 0;
        if (self.extension_id) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeExtensionIdWire.EXTENSION_ID_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.pseudonymized_extension_id != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeExtensionIdWire.PSEUDONYMIZED_EXTENSION_ID_WIRE) + gremlin.sizes.sizeU32(self.pseudonymized_extension_id);
        }
        return res;
    }
    pub fn encode(self: *const ChromeExtensionId, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ChromeExtensionId, target: *gremlin.Writer) void {
        if (self.extension_id) |v| {
            if (v.len > 0) {
                target.appendBytes(ChromeExtensionIdWire.EXTENSION_ID_WIRE, v);
            }
        }
        if (self.pseudonymized_extension_id != 0) {
            target.appendUint32(ChromeExtensionIdWire.PSEUDONYMIZED_EXTENSION_ID_WIRE, self.pseudonymized_extension_id);
        }
    }
};
pub const ChromeExtensionIdReader = struct {
    buf: gremlin.Reader,
    _extension_id: ?[]const u8 = null,
    _pseudonymized_extension_id: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!ChromeExtensionIdReader {
        const buf = gremlin.Reader.init(src);
        var res = ChromeExtensionIdReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ChromeExtensionIdWire.EXTENSION_ID_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._extension_id = result.value;
                },
                ChromeExtensionIdWire.PSEUDONYMIZED_EXTENSION_ID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._pseudonymized_extension_id = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getExtensionId(self: *const ChromeExtensionIdReader) []const u8 {
        return self._extension_id orelse &[_]u8{};
    }
    pub inline fn getPseudonymizedExtensionId(self: *const ChromeExtensionIdReader) u32 {
        return self._pseudonymized_extension_id;
    }
};
const SiteInstanceWire = struct {
    const SITE_INSTANCE_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const BROWSING_INSTANCE_ID_WIRE: gremlin.ProtoWireNumber = 2;
    const IS_DEFAULT_WIRE: gremlin.ProtoWireNumber = 3;
    const HAS_PROCESS_WIRE: gremlin.ProtoWireNumber = 4;
    const RELATED_ACTIVE_CONTENTS_COUNT_WIRE: gremlin.ProtoWireNumber = 5;
    const ACTIVE_RFH_COUNT_WIRE: gremlin.ProtoWireNumber = 6;
    const SITE_INSTANCE_GROUP_WIRE: gremlin.ProtoWireNumber = 7;
    const DEBUG_ANNOTATIONS_WIRE: gremlin.ProtoWireNumber = 99;
};
pub const SiteInstance = struct {
    // fields
    site_instance_id: i32 = 0,
    browsing_instance_id: i32 = 0,
    is_default: bool = false,
    has_process: bool = false,
    related_active_contents_count: i32 = 0,
    active_rfh_count: i32 = 0,
    site_instance_group: ?SiteInstanceGroup = null,
    debug_annotations: ?[]const ?debug_annotation.DebugAnnotation = null,
    pub fn calcProtobufSize(self: *const SiteInstance) usize {
        var res: usize = 0;
        if (self.site_instance_id != 0) {
            res += gremlin.sizes.sizeWireNumber(SiteInstanceWire.SITE_INSTANCE_ID_WIRE) + gremlin.sizes.sizeI32(self.site_instance_id);
        }
        if (self.browsing_instance_id != 0) {
            res += gremlin.sizes.sizeWireNumber(SiteInstanceWire.BROWSING_INSTANCE_ID_WIRE) + gremlin.sizes.sizeI32(self.browsing_instance_id);
        }
        if (self.is_default != false) {
            res += gremlin.sizes.sizeWireNumber(SiteInstanceWire.IS_DEFAULT_WIRE) + gremlin.sizes.sizeBool(self.is_default);
        }
        if (self.has_process != false) {
            res += gremlin.sizes.sizeWireNumber(SiteInstanceWire.HAS_PROCESS_WIRE) + gremlin.sizes.sizeBool(self.has_process);
        }
        if (self.related_active_contents_count != 0) {
            res += gremlin.sizes.sizeWireNumber(SiteInstanceWire.RELATED_ACTIVE_CONTENTS_COUNT_WIRE) + gremlin.sizes.sizeI32(self.related_active_contents_count);
        }
        if (self.active_rfh_count != 0) {
            res += gremlin.sizes.sizeWireNumber(SiteInstanceWire.ACTIVE_RFH_COUNT_WIRE) + gremlin.sizes.sizeI32(self.active_rfh_count);
        }
        if (self.site_instance_group) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(SiteInstanceWire.SITE_INSTANCE_GROUP_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.debug_annotations) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(SiteInstanceWire.DEBUG_ANNOTATIONS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const SiteInstance, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SiteInstance, target: *gremlin.Writer) void {
        if (self.site_instance_id != 0) {
            target.appendInt32(SiteInstanceWire.SITE_INSTANCE_ID_WIRE, self.site_instance_id);
        }
        if (self.browsing_instance_id != 0) {
            target.appendInt32(SiteInstanceWire.BROWSING_INSTANCE_ID_WIRE, self.browsing_instance_id);
        }
        if (self.is_default != false) {
            target.appendBool(SiteInstanceWire.IS_DEFAULT_WIRE, self.is_default);
        }
        if (self.has_process != false) {
            target.appendBool(SiteInstanceWire.HAS_PROCESS_WIRE, self.has_process);
        }
        if (self.related_active_contents_count != 0) {
            target.appendInt32(SiteInstanceWire.RELATED_ACTIVE_CONTENTS_COUNT_WIRE, self.related_active_contents_count);
        }
        if (self.active_rfh_count != 0) {
            target.appendInt32(SiteInstanceWire.ACTIVE_RFH_COUNT_WIRE, self.active_rfh_count);
        }
        if (self.site_instance_group) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(SiteInstanceWire.SITE_INSTANCE_GROUP_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.debug_annotations) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(SiteInstanceWire.DEBUG_ANNOTATIONS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(SiteInstanceWire.DEBUG_ANNOTATIONS_WIRE, 0);
                }
            }
        }
    }
};
pub const SiteInstanceReader = struct {
    buf: gremlin.Reader,
    _site_instance_id: i32 = 0,
    _browsing_instance_id: i32 = 0,
    _is_default: bool = false,
    _has_process: bool = false,
    _related_active_contents_count: i32 = 0,
    _active_rfh_count: i32 = 0,
    _site_instance_group_buf: ?[]const u8 = null,
    _debug_annotations_offset: ?usize = null,
    _debug_annotations_last_offset: ?usize = null,
    _debug_annotations_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!SiteInstanceReader {
        const buf = gremlin.Reader.init(src);
        var res = SiteInstanceReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SiteInstanceWire.SITE_INSTANCE_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._site_instance_id = result.value;
                },
                SiteInstanceWire.BROWSING_INSTANCE_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._browsing_instance_id = result.value;
                },
                SiteInstanceWire.IS_DEFAULT_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_default = result.value;
                },
                SiteInstanceWire.HAS_PROCESS_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._has_process = result.value;
                },
                SiteInstanceWire.RELATED_ACTIVE_CONTENTS_COUNT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._related_active_contents_count = result.value;
                },
                SiteInstanceWire.ACTIVE_RFH_COUNT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._active_rfh_count = result.value;
                },
                SiteInstanceWire.SITE_INSTANCE_GROUP_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._site_instance_group_buf = result.value;
                },
                SiteInstanceWire.DEBUG_ANNOTATIONS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._debug_annotations_offset == null) {
                        res._debug_annotations_offset = offset - result.size;
                    }
                    res._debug_annotations_last_offset = offset;
                    res._debug_annotations_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getSiteInstanceId(self: *const SiteInstanceReader) i32 {
        return self._site_instance_id;
    }
    pub inline fn getBrowsingInstanceId(self: *const SiteInstanceReader) i32 {
        return self._browsing_instance_id;
    }
    pub inline fn getIsDefault(self: *const SiteInstanceReader) bool {
        return self._is_default;
    }
    pub inline fn getHasProcess(self: *const SiteInstanceReader) bool {
        return self._has_process;
    }
    pub inline fn getRelatedActiveContentsCount(self: *const SiteInstanceReader) i32 {
        return self._related_active_contents_count;
    }
    pub inline fn getActiveRfhCount(self: *const SiteInstanceReader) i32 {
        return self._active_rfh_count;
    }
    pub fn getSiteInstanceGroup(self: *const SiteInstanceReader) gremlin.Error!SiteInstanceGroupReader {
        if (self._site_instance_group_buf) |buf| {
            return try SiteInstanceGroupReader.init(buf);
        }
        return try SiteInstanceGroupReader.init(&[_]u8{});
    }
    pub fn debugAnnotationsCount(self: *const SiteInstanceReader) usize {
        return self._debug_annotations_cnt;
    }
    pub fn debugAnnotationsNext(self: *SiteInstanceReader) ?debug_annotation.DebugAnnotationReader {
        if (self._debug_annotations_offset == null) return null;
        const current_offset = self._debug_annotations_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = debug_annotation.DebugAnnotationReader.init(result.value) catch return null;
        if (self._debug_annotations_last_offset != null and current_offset >= self._debug_annotations_last_offset.?) {
            self._debug_annotations_offset = null;
            return msg;
        }
        if (self._debug_annotations_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._debug_annotations_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == SiteInstanceWire.DEBUG_ANNOTATIONS_WIRE) {
                self._debug_annotations_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._debug_annotations_offset = null;
        return msg;
    }
};
const SiteInstanceGroupWire = struct {
    const SITE_INSTANCE_GROUP_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const ACTIVE_FRAME_COUNT_WIRE: gremlin.ProtoWireNumber = 2;
    const PROCESS_WIRE: gremlin.ProtoWireNumber = 3;
    const DEBUG_ANNOTATIONS_WIRE: gremlin.ProtoWireNumber = 99;
};
pub const SiteInstanceGroup = struct {
    // fields
    site_instance_group_id: i32 = 0,
    active_frame_count: i32 = 0,
    process: ?RenderProcessHost = null,
    debug_annotations: ?[]const ?debug_annotation.DebugAnnotation = null,
    pub fn calcProtobufSize(self: *const SiteInstanceGroup) usize {
        var res: usize = 0;
        if (self.site_instance_group_id != 0) {
            res += gremlin.sizes.sizeWireNumber(SiteInstanceGroupWire.SITE_INSTANCE_GROUP_ID_WIRE) + gremlin.sizes.sizeI32(self.site_instance_group_id);
        }
        if (self.active_frame_count != 0) {
            res += gremlin.sizes.sizeWireNumber(SiteInstanceGroupWire.ACTIVE_FRAME_COUNT_WIRE) + gremlin.sizes.sizeI32(self.active_frame_count);
        }
        if (self.process) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(SiteInstanceGroupWire.PROCESS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.debug_annotations) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(SiteInstanceGroupWire.DEBUG_ANNOTATIONS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const SiteInstanceGroup, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SiteInstanceGroup, target: *gremlin.Writer) void {
        if (self.site_instance_group_id != 0) {
            target.appendInt32(SiteInstanceGroupWire.SITE_INSTANCE_GROUP_ID_WIRE, self.site_instance_group_id);
        }
        if (self.active_frame_count != 0) {
            target.appendInt32(SiteInstanceGroupWire.ACTIVE_FRAME_COUNT_WIRE, self.active_frame_count);
        }
        if (self.process) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(SiteInstanceGroupWire.PROCESS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.debug_annotations) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(SiteInstanceGroupWire.DEBUG_ANNOTATIONS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(SiteInstanceGroupWire.DEBUG_ANNOTATIONS_WIRE, 0);
                }
            }
        }
    }
};
pub const SiteInstanceGroupReader = struct {
    buf: gremlin.Reader,
    _site_instance_group_id: i32 = 0,
    _active_frame_count: i32 = 0,
    _process_buf: ?[]const u8 = null,
    _debug_annotations_offset: ?usize = null,
    _debug_annotations_last_offset: ?usize = null,
    _debug_annotations_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!SiteInstanceGroupReader {
        const buf = gremlin.Reader.init(src);
        var res = SiteInstanceGroupReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SiteInstanceGroupWire.SITE_INSTANCE_GROUP_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._site_instance_group_id = result.value;
                },
                SiteInstanceGroupWire.ACTIVE_FRAME_COUNT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._active_frame_count = result.value;
                },
                SiteInstanceGroupWire.PROCESS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._process_buf = result.value;
                },
                SiteInstanceGroupWire.DEBUG_ANNOTATIONS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._debug_annotations_offset == null) {
                        res._debug_annotations_offset = offset - result.size;
                    }
                    res._debug_annotations_last_offset = offset;
                    res._debug_annotations_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getSiteInstanceGroupId(self: *const SiteInstanceGroupReader) i32 {
        return self._site_instance_group_id;
    }
    pub inline fn getActiveFrameCount(self: *const SiteInstanceGroupReader) i32 {
        return self._active_frame_count;
    }
    pub fn getProcess(self: *const SiteInstanceGroupReader) gremlin.Error!RenderProcessHostReader {
        if (self._process_buf) |buf| {
            return try RenderProcessHostReader.init(buf);
        }
        return try RenderProcessHostReader.init(&[_]u8{});
    }
    pub fn debugAnnotationsCount(self: *const SiteInstanceGroupReader) usize {
        return self._debug_annotations_cnt;
    }
    pub fn debugAnnotationsNext(self: *SiteInstanceGroupReader) ?debug_annotation.DebugAnnotationReader {
        if (self._debug_annotations_offset == null) return null;
        const current_offset = self._debug_annotations_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = debug_annotation.DebugAnnotationReader.init(result.value) catch return null;
        if (self._debug_annotations_last_offset != null and current_offset >= self._debug_annotations_last_offset.?) {
            self._debug_annotations_offset = null;
            return msg;
        }
        if (self._debug_annotations_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._debug_annotations_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == SiteInstanceGroupWire.DEBUG_ANNOTATIONS_WIRE) {
                self._debug_annotations_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._debug_annotations_offset = null;
        return msg;
    }
};
const WebExposedIsolationInfoWire = struct {
    const IS_ISOLATED_WIRE: gremlin.ProtoWireNumber = 1;
    const ORIGIN_WIRE: gremlin.ProtoWireNumber = 2;
    const IS_ISOLATED_APPLICATION_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const WebExposedIsolationInfo = struct {
    // fields
    is_isolated: bool = false,
    origin: ?[]const u8 = null,
    is_isolated_application: bool = false,
    pub fn calcProtobufSize(self: *const WebExposedIsolationInfo) usize {
        var res: usize = 0;
        if (self.is_isolated != false) {
            res += gremlin.sizes.sizeWireNumber(WebExposedIsolationInfoWire.IS_ISOLATED_WIRE) + gremlin.sizes.sizeBool(self.is_isolated);
        }
        if (self.origin) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(WebExposedIsolationInfoWire.ORIGIN_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.is_isolated_application != false) {
            res += gremlin.sizes.sizeWireNumber(WebExposedIsolationInfoWire.IS_ISOLATED_APPLICATION_WIRE) + gremlin.sizes.sizeBool(self.is_isolated_application);
        }
        return res;
    }
    pub fn encode(self: *const WebExposedIsolationInfo, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const WebExposedIsolationInfo, target: *gremlin.Writer) void {
        if (self.is_isolated != false) {
            target.appendBool(WebExposedIsolationInfoWire.IS_ISOLATED_WIRE, self.is_isolated);
        }
        if (self.origin) |v| {
            if (v.len > 0) {
                target.appendBytes(WebExposedIsolationInfoWire.ORIGIN_WIRE, v);
            }
        }
        if (self.is_isolated_application != false) {
            target.appendBool(WebExposedIsolationInfoWire.IS_ISOLATED_APPLICATION_WIRE, self.is_isolated_application);
        }
    }
};
pub const WebExposedIsolationInfoReader = struct {
    buf: gremlin.Reader,
    _is_isolated: bool = false,
    _origin: ?[]const u8 = null,
    _is_isolated_application: bool = false,
    pub fn init(src: []const u8) gremlin.Error!WebExposedIsolationInfoReader {
        const buf = gremlin.Reader.init(src);
        var res = WebExposedIsolationInfoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                WebExposedIsolationInfoWire.IS_ISOLATED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_isolated = result.value;
                },
                WebExposedIsolationInfoWire.ORIGIN_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._origin = result.value;
                },
                WebExposedIsolationInfoWire.IS_ISOLATED_APPLICATION_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_isolated_application = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getIsIsolated(self: *const WebExposedIsolationInfoReader) bool {
        return self._is_isolated;
    }
    pub inline fn getOrigin(self: *const WebExposedIsolationInfoReader) []const u8 {
        return self._origin orelse &[_]u8{};
    }
    pub inline fn getIsIsolatedApplication(self: *const WebExposedIsolationInfoReader) bool {
        return self._is_isolated_application;
    }
};
const UrlInfoWire = struct {
    const URL_WIRE: gremlin.ProtoWireNumber = 1;
    const ORIGIN_WIRE: gremlin.ProtoWireNumber = 2;
    const IS_SANDBOXED_WIRE: gremlin.ProtoWireNumber = 3;
    const IS_PDF_WIRE: gremlin.ProtoWireNumber = 4;
    const IS_COOP_ISOLATION_REQUESTED_WIRE: gremlin.ProtoWireNumber = 5;
    const ORIGIN_ISOLATION_REQUEST_WIRE: gremlin.ProtoWireNumber = 6;
    const IS_PREFETCH_WITH_CROSS_SITE_CONTAMINATION_WIRE: gremlin.ProtoWireNumber = 7;
    const WEB_EXPOSED_ISOLATION_INFO_WIRE: gremlin.ProtoWireNumber = 8;
    const STORAGE_PARTITION_CONFIG_WIRE: gremlin.ProtoWireNumber = 9;
};
pub const UrlInfo = struct {
    // fields
    url: ?[]const u8 = null,
    origin: ?[]const u8 = null,
    is_sandboxed: bool = false,
    is_pdf: bool = false,
    is_coop_isolation_requested: bool = false,
    origin_isolation_request: i32 = 0,
    is_prefetch_with_cross_site_contamination: bool = false,
    web_exposed_isolation_info: ?WebExposedIsolationInfo = null,
    storage_partition_config: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const UrlInfo) usize {
        var res: usize = 0;
        if (self.url) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(UrlInfoWire.URL_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.origin) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(UrlInfoWire.ORIGIN_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.is_sandboxed != false) {
            res += gremlin.sizes.sizeWireNumber(UrlInfoWire.IS_SANDBOXED_WIRE) + gremlin.sizes.sizeBool(self.is_sandboxed);
        }
        if (self.is_pdf != false) {
            res += gremlin.sizes.sizeWireNumber(UrlInfoWire.IS_PDF_WIRE) + gremlin.sizes.sizeBool(self.is_pdf);
        }
        if (self.is_coop_isolation_requested != false) {
            res += gremlin.sizes.sizeWireNumber(UrlInfoWire.IS_COOP_ISOLATION_REQUESTED_WIRE) + gremlin.sizes.sizeBool(self.is_coop_isolation_requested);
        }
        if (self.origin_isolation_request != 0) {
            res += gremlin.sizes.sizeWireNumber(UrlInfoWire.ORIGIN_ISOLATION_REQUEST_WIRE) + gremlin.sizes.sizeI32(self.origin_isolation_request);
        }
        if (self.is_prefetch_with_cross_site_contamination != false) {
            res += gremlin.sizes.sizeWireNumber(UrlInfoWire.IS_PREFETCH_WITH_CROSS_SITE_CONTAMINATION_WIRE) + gremlin.sizes.sizeBool(self.is_prefetch_with_cross_site_contamination);
        }
        if (self.web_exposed_isolation_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(UrlInfoWire.WEB_EXPOSED_ISOLATION_INFO_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.storage_partition_config) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(UrlInfoWire.STORAGE_PARTITION_CONFIG_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const UrlInfo, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const UrlInfo, target: *gremlin.Writer) void {
        if (self.url) |v| {
            if (v.len > 0) {
                target.appendBytes(UrlInfoWire.URL_WIRE, v);
            }
        }
        if (self.origin) |v| {
            if (v.len > 0) {
                target.appendBytes(UrlInfoWire.ORIGIN_WIRE, v);
            }
        }
        if (self.is_sandboxed != false) {
            target.appendBool(UrlInfoWire.IS_SANDBOXED_WIRE, self.is_sandboxed);
        }
        if (self.is_pdf != false) {
            target.appendBool(UrlInfoWire.IS_PDF_WIRE, self.is_pdf);
        }
        if (self.is_coop_isolation_requested != false) {
            target.appendBool(UrlInfoWire.IS_COOP_ISOLATION_REQUESTED_WIRE, self.is_coop_isolation_requested);
        }
        if (self.origin_isolation_request != 0) {
            target.appendInt32(UrlInfoWire.ORIGIN_ISOLATION_REQUEST_WIRE, self.origin_isolation_request);
        }
        if (self.is_prefetch_with_cross_site_contamination != false) {
            target.appendBool(UrlInfoWire.IS_PREFETCH_WITH_CROSS_SITE_CONTAMINATION_WIRE, self.is_prefetch_with_cross_site_contamination);
        }
        if (self.web_exposed_isolation_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(UrlInfoWire.WEB_EXPOSED_ISOLATION_INFO_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.storage_partition_config) |v| {
            if (v.len > 0) {
                target.appendBytes(UrlInfoWire.STORAGE_PARTITION_CONFIG_WIRE, v);
            }
        }
    }
};
pub const UrlInfoReader = struct {
    buf: gremlin.Reader,
    _url: ?[]const u8 = null,
    _origin: ?[]const u8 = null,
    _is_sandboxed: bool = false,
    _is_pdf: bool = false,
    _is_coop_isolation_requested: bool = false,
    _origin_isolation_request: i32 = 0,
    _is_prefetch_with_cross_site_contamination: bool = false,
    _web_exposed_isolation_info_buf: ?[]const u8 = null,
    _storage_partition_config: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!UrlInfoReader {
        const buf = gremlin.Reader.init(src);
        var res = UrlInfoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                UrlInfoWire.URL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._url = result.value;
                },
                UrlInfoWire.ORIGIN_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._origin = result.value;
                },
                UrlInfoWire.IS_SANDBOXED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_sandboxed = result.value;
                },
                UrlInfoWire.IS_PDF_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_pdf = result.value;
                },
                UrlInfoWire.IS_COOP_ISOLATION_REQUESTED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_coop_isolation_requested = result.value;
                },
                UrlInfoWire.ORIGIN_ISOLATION_REQUEST_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._origin_isolation_request = result.value;
                },
                UrlInfoWire.IS_PREFETCH_WITH_CROSS_SITE_CONTAMINATION_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_prefetch_with_cross_site_contamination = result.value;
                },
                UrlInfoWire.WEB_EXPOSED_ISOLATION_INFO_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._web_exposed_isolation_info_buf = result.value;
                },
                UrlInfoWire.STORAGE_PARTITION_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._storage_partition_config = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getUrl(self: *const UrlInfoReader) []const u8 {
        return self._url orelse &[_]u8{};
    }
    pub inline fn getOrigin(self: *const UrlInfoReader) []const u8 {
        return self._origin orelse &[_]u8{};
    }
    pub inline fn getIsSandboxed(self: *const UrlInfoReader) bool {
        return self._is_sandboxed;
    }
    pub inline fn getIsPdf(self: *const UrlInfoReader) bool {
        return self._is_pdf;
    }
    pub inline fn getIsCoopIsolationRequested(self: *const UrlInfoReader) bool {
        return self._is_coop_isolation_requested;
    }
    pub inline fn getOriginIsolationRequest(self: *const UrlInfoReader) i32 {
        return self._origin_isolation_request;
    }
    pub inline fn getIsPrefetchWithCrossSiteContamination(self: *const UrlInfoReader) bool {
        return self._is_prefetch_with_cross_site_contamination;
    }
    pub fn getWebExposedIsolationInfo(self: *const UrlInfoReader) gremlin.Error!WebExposedIsolationInfoReader {
        if (self._web_exposed_isolation_info_buf) |buf| {
            return try WebExposedIsolationInfoReader.init(buf);
        }
        return try WebExposedIsolationInfoReader.init(&[_]u8{});
    }
    pub inline fn getStoragePartitionConfig(self: *const UrlInfoReader) []const u8 {
        return self._storage_partition_config orelse &[_]u8{};
    }
};
const RenderViewHostWire = struct {
    const RVH_MAP_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const ROUTING_ID_WIRE: gremlin.ProtoWireNumber = 2;
    const PROCESS_ID_WIRE: gremlin.ProtoWireNumber = 3;
    const PROCESS_WIRE: gremlin.ProtoWireNumber = 6;
    const IS_IN_BACK_FORWARD_CACHE_WIRE: gremlin.ProtoWireNumber = 4;
    const RENDERER_VIEW_CREATED_WIRE: gremlin.ProtoWireNumber = 5;
    const DEBUG_ANNOTATIONS_WIRE: gremlin.ProtoWireNumber = 99;
};
pub const RenderViewHost = struct {
    // fields
    rvh_map_id: i32 = 0,
    routing_id: i32 = 0,
    process_id: i32 = 0,
    process: ?RenderProcessHost = null,
    is_in_back_forward_cache: bool = false,
    renderer_view_created: bool = false,
    debug_annotations: ?[]const ?debug_annotation.DebugAnnotation = null,
    pub fn calcProtobufSize(self: *const RenderViewHost) usize {
        var res: usize = 0;
        if (self.rvh_map_id != 0) {
            res += gremlin.sizes.sizeWireNumber(RenderViewHostWire.RVH_MAP_ID_WIRE) + gremlin.sizes.sizeI32(self.rvh_map_id);
        }
        if (self.routing_id != 0) {
            res += gremlin.sizes.sizeWireNumber(RenderViewHostWire.ROUTING_ID_WIRE) + gremlin.sizes.sizeI32(self.routing_id);
        }
        if (self.process_id != 0) {
            res += gremlin.sizes.sizeWireNumber(RenderViewHostWire.PROCESS_ID_WIRE) + gremlin.sizes.sizeI32(self.process_id);
        }
        if (self.process) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(RenderViewHostWire.PROCESS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.is_in_back_forward_cache != false) {
            res += gremlin.sizes.sizeWireNumber(RenderViewHostWire.IS_IN_BACK_FORWARD_CACHE_WIRE) + gremlin.sizes.sizeBool(self.is_in_back_forward_cache);
        }
        if (self.renderer_view_created != false) {
            res += gremlin.sizes.sizeWireNumber(RenderViewHostWire.RENDERER_VIEW_CREATED_WIRE) + gremlin.sizes.sizeBool(self.renderer_view_created);
        }
        if (self.debug_annotations) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(RenderViewHostWire.DEBUG_ANNOTATIONS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const RenderViewHost, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const RenderViewHost, target: *gremlin.Writer) void {
        if (self.rvh_map_id != 0) {
            target.appendInt32(RenderViewHostWire.RVH_MAP_ID_WIRE, self.rvh_map_id);
        }
        if (self.routing_id != 0) {
            target.appendInt32(RenderViewHostWire.ROUTING_ID_WIRE, self.routing_id);
        }
        if (self.process_id != 0) {
            target.appendInt32(RenderViewHostWire.PROCESS_ID_WIRE, self.process_id);
        }
        if (self.process) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(RenderViewHostWire.PROCESS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.is_in_back_forward_cache != false) {
            target.appendBool(RenderViewHostWire.IS_IN_BACK_FORWARD_CACHE_WIRE, self.is_in_back_forward_cache);
        }
        if (self.renderer_view_created != false) {
            target.appendBool(RenderViewHostWire.RENDERER_VIEW_CREATED_WIRE, self.renderer_view_created);
        }
        if (self.debug_annotations) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(RenderViewHostWire.DEBUG_ANNOTATIONS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(RenderViewHostWire.DEBUG_ANNOTATIONS_WIRE, 0);
                }
            }
        }
    }
};
pub const RenderViewHostReader = struct {
    buf: gremlin.Reader,
    _rvh_map_id: i32 = 0,
    _routing_id: i32 = 0,
    _process_id: i32 = 0,
    _process_buf: ?[]const u8 = null,
    _is_in_back_forward_cache: bool = false,
    _renderer_view_created: bool = false,
    _debug_annotations_offset: ?usize = null,
    _debug_annotations_last_offset: ?usize = null,
    _debug_annotations_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!RenderViewHostReader {
        const buf = gremlin.Reader.init(src);
        var res = RenderViewHostReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                RenderViewHostWire.RVH_MAP_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._rvh_map_id = result.value;
                },
                RenderViewHostWire.ROUTING_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._routing_id = result.value;
                },
                RenderViewHostWire.PROCESS_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._process_id = result.value;
                },
                RenderViewHostWire.PROCESS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._process_buf = result.value;
                },
                RenderViewHostWire.IS_IN_BACK_FORWARD_CACHE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_in_back_forward_cache = result.value;
                },
                RenderViewHostWire.RENDERER_VIEW_CREATED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._renderer_view_created = result.value;
                },
                RenderViewHostWire.DEBUG_ANNOTATIONS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._debug_annotations_offset == null) {
                        res._debug_annotations_offset = offset - result.size;
                    }
                    res._debug_annotations_last_offset = offset;
                    res._debug_annotations_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getRvhMapId(self: *const RenderViewHostReader) i32 {
        return self._rvh_map_id;
    }
    pub inline fn getRoutingId(self: *const RenderViewHostReader) i32 {
        return self._routing_id;
    }
    pub inline fn getProcessId(self: *const RenderViewHostReader) i32 {
        return self._process_id;
    }
    pub fn getProcess(self: *const RenderViewHostReader) gremlin.Error!RenderProcessHostReader {
        if (self._process_buf) |buf| {
            return try RenderProcessHostReader.init(buf);
        }
        return try RenderProcessHostReader.init(&[_]u8{});
    }
    pub inline fn getIsInBackForwardCache(self: *const RenderViewHostReader) bool {
        return self._is_in_back_forward_cache;
    }
    pub inline fn getRendererViewCreated(self: *const RenderViewHostReader) bool {
        return self._renderer_view_created;
    }
    pub fn debugAnnotationsCount(self: *const RenderViewHostReader) usize {
        return self._debug_annotations_cnt;
    }
    pub fn debugAnnotationsNext(self: *RenderViewHostReader) ?debug_annotation.DebugAnnotationReader {
        if (self._debug_annotations_offset == null) return null;
        const current_offset = self._debug_annotations_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = debug_annotation.DebugAnnotationReader.init(result.value) catch return null;
        if (self._debug_annotations_last_offset != null and current_offset >= self._debug_annotations_last_offset.?) {
            self._debug_annotations_offset = null;
            return msg;
        }
        if (self._debug_annotations_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._debug_annotations_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == RenderViewHostWire.DEBUG_ANNOTATIONS_WIRE) {
                self._debug_annotations_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._debug_annotations_offset = null;
        return msg;
    }
};
const RenderFrameProxyHostWire = struct {
    const ROUTING_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const PROCESS_ID_WIRE: gremlin.ProtoWireNumber = 2;
    const RVH_MAP_ID_WIRE: gremlin.ProtoWireNumber = 3;
    const SITE_INSTANCE_ID_WIRE: gremlin.ProtoWireNumber = 4;
    const IS_RENDER_FRAME_PROXY_LIVE_WIRE: gremlin.ProtoWireNumber = 5;
    const SITE_INSTANCE_GROUP_ID_WIRE: gremlin.ProtoWireNumber = 6;
    const DEBUG_ANNOTATIONS_WIRE: gremlin.ProtoWireNumber = 99;
};
pub const RenderFrameProxyHost = struct {
    // fields
    routing_id: i32 = 0,
    process_id: i32 = 0,
    rvh_map_id: i32 = 0,
    site_instance_id: i32 = 0,
    is_render_frame_proxy_live: bool = false,
    site_instance_group_id: i32 = 0,
    debug_annotations: ?[]const ?debug_annotation.DebugAnnotation = null,
    pub fn calcProtobufSize(self: *const RenderFrameProxyHost) usize {
        var res: usize = 0;
        if (self.routing_id != 0) {
            res += gremlin.sizes.sizeWireNumber(RenderFrameProxyHostWire.ROUTING_ID_WIRE) + gremlin.sizes.sizeI32(self.routing_id);
        }
        if (self.process_id != 0) {
            res += gremlin.sizes.sizeWireNumber(RenderFrameProxyHostWire.PROCESS_ID_WIRE) + gremlin.sizes.sizeI32(self.process_id);
        }
        if (self.rvh_map_id != 0) {
            res += gremlin.sizes.sizeWireNumber(RenderFrameProxyHostWire.RVH_MAP_ID_WIRE) + gremlin.sizes.sizeI32(self.rvh_map_id);
        }
        if (self.site_instance_id != 0) {
            res += gremlin.sizes.sizeWireNumber(RenderFrameProxyHostWire.SITE_INSTANCE_ID_WIRE) + gremlin.sizes.sizeI32(self.site_instance_id);
        }
        if (self.is_render_frame_proxy_live != false) {
            res += gremlin.sizes.sizeWireNumber(RenderFrameProxyHostWire.IS_RENDER_FRAME_PROXY_LIVE_WIRE) + gremlin.sizes.sizeBool(self.is_render_frame_proxy_live);
        }
        if (self.site_instance_group_id != 0) {
            res += gremlin.sizes.sizeWireNumber(RenderFrameProxyHostWire.SITE_INSTANCE_GROUP_ID_WIRE) + gremlin.sizes.sizeI32(self.site_instance_group_id);
        }
        if (self.debug_annotations) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(RenderFrameProxyHostWire.DEBUG_ANNOTATIONS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const RenderFrameProxyHost, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const RenderFrameProxyHost, target: *gremlin.Writer) void {
        if (self.routing_id != 0) {
            target.appendInt32(RenderFrameProxyHostWire.ROUTING_ID_WIRE, self.routing_id);
        }
        if (self.process_id != 0) {
            target.appendInt32(RenderFrameProxyHostWire.PROCESS_ID_WIRE, self.process_id);
        }
        if (self.rvh_map_id != 0) {
            target.appendInt32(RenderFrameProxyHostWire.RVH_MAP_ID_WIRE, self.rvh_map_id);
        }
        if (self.site_instance_id != 0) {
            target.appendInt32(RenderFrameProxyHostWire.SITE_INSTANCE_ID_WIRE, self.site_instance_id);
        }
        if (self.is_render_frame_proxy_live != false) {
            target.appendBool(RenderFrameProxyHostWire.IS_RENDER_FRAME_PROXY_LIVE_WIRE, self.is_render_frame_proxy_live);
        }
        if (self.site_instance_group_id != 0) {
            target.appendInt32(RenderFrameProxyHostWire.SITE_INSTANCE_GROUP_ID_WIRE, self.site_instance_group_id);
        }
        if (self.debug_annotations) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(RenderFrameProxyHostWire.DEBUG_ANNOTATIONS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(RenderFrameProxyHostWire.DEBUG_ANNOTATIONS_WIRE, 0);
                }
            }
        }
    }
};
pub const RenderFrameProxyHostReader = struct {
    buf: gremlin.Reader,
    _routing_id: i32 = 0,
    _process_id: i32 = 0,
    _rvh_map_id: i32 = 0,
    _site_instance_id: i32 = 0,
    _is_render_frame_proxy_live: bool = false,
    _site_instance_group_id: i32 = 0,
    _debug_annotations_offset: ?usize = null,
    _debug_annotations_last_offset: ?usize = null,
    _debug_annotations_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!RenderFrameProxyHostReader {
        const buf = gremlin.Reader.init(src);
        var res = RenderFrameProxyHostReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                RenderFrameProxyHostWire.ROUTING_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._routing_id = result.value;
                },
                RenderFrameProxyHostWire.PROCESS_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._process_id = result.value;
                },
                RenderFrameProxyHostWire.RVH_MAP_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._rvh_map_id = result.value;
                },
                RenderFrameProxyHostWire.SITE_INSTANCE_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._site_instance_id = result.value;
                },
                RenderFrameProxyHostWire.IS_RENDER_FRAME_PROXY_LIVE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_render_frame_proxy_live = result.value;
                },
                RenderFrameProxyHostWire.SITE_INSTANCE_GROUP_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._site_instance_group_id = result.value;
                },
                RenderFrameProxyHostWire.DEBUG_ANNOTATIONS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._debug_annotations_offset == null) {
                        res._debug_annotations_offset = offset - result.size;
                    }
                    res._debug_annotations_last_offset = offset;
                    res._debug_annotations_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getRoutingId(self: *const RenderFrameProxyHostReader) i32 {
        return self._routing_id;
    }
    pub inline fn getProcessId(self: *const RenderFrameProxyHostReader) i32 {
        return self._process_id;
    }
    pub inline fn getRvhMapId(self: *const RenderFrameProxyHostReader) i32 {
        return self._rvh_map_id;
    }
    pub inline fn getSiteInstanceId(self: *const RenderFrameProxyHostReader) i32 {
        return self._site_instance_id;
    }
    pub inline fn getIsRenderFrameProxyLive(self: *const RenderFrameProxyHostReader) bool {
        return self._is_render_frame_proxy_live;
    }
    pub inline fn getSiteInstanceGroupId(self: *const RenderFrameProxyHostReader) i32 {
        return self._site_instance_group_id;
    }
    pub fn debugAnnotationsCount(self: *const RenderFrameProxyHostReader) usize {
        return self._debug_annotations_cnt;
    }
    pub fn debugAnnotationsNext(self: *RenderFrameProxyHostReader) ?debug_annotation.DebugAnnotationReader {
        if (self._debug_annotations_offset == null) return null;
        const current_offset = self._debug_annotations_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = debug_annotation.DebugAnnotationReader.init(result.value) catch return null;
        if (self._debug_annotations_last_offset != null and current_offset >= self._debug_annotations_last_offset.?) {
            self._debug_annotations_offset = null;
            return msg;
        }
        if (self._debug_annotations_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._debug_annotations_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == RenderFrameProxyHostWire.DEBUG_ANNOTATIONS_WIRE) {
                self._debug_annotations_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._debug_annotations_offset = null;
        return msg;
    }
};
const AndroidViewWire = struct {
    const ID_WIRE: gremlin.ProtoWireNumber = 1;
    const PARENT_ID_WIRE: gremlin.ProtoWireNumber = 2;
    const IS_SHOWN_WIRE: gremlin.ProtoWireNumber = 3;
    const IS_DIRTY_WIRE: gremlin.ProtoWireNumber = 4;
    const CLASS_NAME_WIRE: gremlin.ProtoWireNumber = 5;
    const RESOURCE_NAME_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const AndroidView = struct {
    // fields
    id: i32 = 0,
    parent_id: i32 = 0,
    is_shown: bool = false,
    is_dirty: bool = false,
    class_name: ?[]const u8 = null,
    resource_name: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const AndroidView) usize {
        var res: usize = 0;
        if (self.id != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidViewWire.ID_WIRE) + gremlin.sizes.sizeI32(self.id);
        }
        if (self.parent_id != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidViewWire.PARENT_ID_WIRE) + gremlin.sizes.sizeI32(self.parent_id);
        }
        if (self.is_shown != false) {
            res += gremlin.sizes.sizeWireNumber(AndroidViewWire.IS_SHOWN_WIRE) + gremlin.sizes.sizeBool(self.is_shown);
        }
        if (self.is_dirty != false) {
            res += gremlin.sizes.sizeWireNumber(AndroidViewWire.IS_DIRTY_WIRE) + gremlin.sizes.sizeBool(self.is_dirty);
        }
        if (self.class_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidViewWire.CLASS_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.resource_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidViewWire.RESOURCE_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidView, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidView, target: *gremlin.Writer) void {
        if (self.id != 0) {
            target.appendInt32(AndroidViewWire.ID_WIRE, self.id);
        }
        if (self.parent_id != 0) {
            target.appendInt32(AndroidViewWire.PARENT_ID_WIRE, self.parent_id);
        }
        if (self.is_shown != false) {
            target.appendBool(AndroidViewWire.IS_SHOWN_WIRE, self.is_shown);
        }
        if (self.is_dirty != false) {
            target.appendBool(AndroidViewWire.IS_DIRTY_WIRE, self.is_dirty);
        }
        if (self.class_name) |v| {
            if (v.len > 0) {
                target.appendBytes(AndroidViewWire.CLASS_NAME_WIRE, v);
            }
        }
        if (self.resource_name) |v| {
            if (v.len > 0) {
                target.appendBytes(AndroidViewWire.RESOURCE_NAME_WIRE, v);
            }
        }
    }
};
pub const AndroidViewReader = struct {
    buf: gremlin.Reader,
    _id: i32 = 0,
    _parent_id: i32 = 0,
    _is_shown: bool = false,
    _is_dirty: bool = false,
    _class_name: ?[]const u8 = null,
    _resource_name: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!AndroidViewReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidViewReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidViewWire.ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._id = result.value;
                },
                AndroidViewWire.PARENT_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._parent_id = result.value;
                },
                AndroidViewWire.IS_SHOWN_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_shown = result.value;
                },
                AndroidViewWire.IS_DIRTY_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_dirty = result.value;
                },
                AndroidViewWire.CLASS_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._class_name = result.value;
                },
                AndroidViewWire.RESOURCE_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._resource_name = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getId(self: *const AndroidViewReader) i32 {
        return self._id;
    }
    pub inline fn getParentId(self: *const AndroidViewReader) i32 {
        return self._parent_id;
    }
    pub inline fn getIsShown(self: *const AndroidViewReader) bool {
        return self._is_shown;
    }
    pub inline fn getIsDirty(self: *const AndroidViewReader) bool {
        return self._is_dirty;
    }
    pub inline fn getClassName(self: *const AndroidViewReader) []const u8 {
        return self._class_name orelse &[_]u8{};
    }
    pub inline fn getResourceName(self: *const AndroidViewReader) []const u8 {
        return self._resource_name orelse &[_]u8{};
    }
};
const AndroidActivityWire = struct {
    const NAME_WIRE: gremlin.ProtoWireNumber = 1;
    const VIEW_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const AndroidActivity = struct {
    // fields
    name: ?[]const u8 = null,
    view: ?[]const ?AndroidView = null,
    pub fn calcProtobufSize(self: *const AndroidActivity) usize {
        var res: usize = 0;
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidActivityWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.view) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidActivityWire.VIEW_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidActivity, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidActivity, target: *gremlin.Writer) void {
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(AndroidActivityWire.NAME_WIRE, v);
            }
        }
        if (self.view) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidActivityWire.VIEW_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidActivityWire.VIEW_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidActivityReader = struct {
    buf: gremlin.Reader,
    _name: ?[]const u8 = null,
    _view_offset: ?usize = null,
    _view_last_offset: ?usize = null,
    _view_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidActivityReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidActivityReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidActivityWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                AndroidActivityWire.VIEW_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._view_offset == null) {
                        res._view_offset = offset - result.size;
                    }
                    res._view_last_offset = offset;
                    res._view_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getName(self: *const AndroidActivityReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub fn viewCount(self: *const AndroidActivityReader) usize {
        return self._view_cnt;
    }
    pub fn viewNext(self: *AndroidActivityReader) ?AndroidViewReader {
        if (self._view_offset == null) return null;
        const current_offset = self._view_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidViewReader.init(result.value) catch return null;
        if (self._view_last_offset != null and current_offset >= self._view_last_offset.?) {
            self._view_offset = null;
            return msg;
        }
        if (self._view_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._view_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidActivityWire.VIEW_WIRE) {
                self._view_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._view_offset = null;
        return msg;
    }
};
const AndroidViewDumpWire = struct {
    const ACTIVITY_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const AndroidViewDump = struct {
    // fields
    activity: ?[]const ?AndroidActivity = null,
    pub fn calcProtobufSize(self: *const AndroidViewDump) usize {
        var res: usize = 0;
        if (self.activity) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidViewDumpWire.ACTIVITY_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidViewDump, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidViewDump, target: *gremlin.Writer) void {
        if (self.activity) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidViewDumpWire.ACTIVITY_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidViewDumpWire.ACTIVITY_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidViewDumpReader = struct {
    buf: gremlin.Reader,
    _activity_offset: ?usize = null,
    _activity_last_offset: ?usize = null,
    _activity_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidViewDumpReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidViewDumpReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidViewDumpWire.ACTIVITY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._activity_offset == null) {
                        res._activity_offset = offset - result.size;
                    }
                    res._activity_last_offset = offset;
                    res._activity_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn activityCount(self: *const AndroidViewDumpReader) usize {
        return self._activity_cnt;
    }
    pub fn activityNext(self: *AndroidViewDumpReader) ?AndroidActivityReader {
        if (self._activity_offset == null) return null;
        const current_offset = self._activity_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidActivityReader.init(result.value) catch return null;
        if (self._activity_last_offset != null and current_offset >= self._activity_last_offset.?) {
            self._activity_offset = null;
            return msg;
        }
        if (self._activity_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._activity_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidViewDumpWire.ACTIVITY_WIRE) {
                self._activity_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._activity_offset = null;
        return msg;
    }
};
const ParkableStringCompressInBackgroundWire = struct {
    const SIZE_BYTES_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const ParkableStringCompressInBackground = struct {
    // fields
    size_bytes: i32 = 0,
    pub fn calcProtobufSize(self: *const ParkableStringCompressInBackground) usize {
        var res: usize = 0;
        if (self.size_bytes != 0) {
            res += gremlin.sizes.sizeWireNumber(ParkableStringCompressInBackgroundWire.SIZE_BYTES_WIRE) + gremlin.sizes.sizeI32(self.size_bytes);
        }
        return res;
    }
    pub fn encode(self: *const ParkableStringCompressInBackground, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ParkableStringCompressInBackground, target: *gremlin.Writer) void {
        if (self.size_bytes != 0) {
            target.appendInt32(ParkableStringCompressInBackgroundWire.SIZE_BYTES_WIRE, self.size_bytes);
        }
    }
};
pub const ParkableStringCompressInBackgroundReader = struct {
    buf: gremlin.Reader,
    _size_bytes: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!ParkableStringCompressInBackgroundReader {
        const buf = gremlin.Reader.init(src);
        var res = ParkableStringCompressInBackgroundReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ParkableStringCompressInBackgroundWire.SIZE_BYTES_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._size_bytes = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getSizeBytes(self: *const ParkableStringCompressInBackgroundReader) i32 {
        return self._size_bytes;
    }
};
const ParkableStringUnparkWire = struct {
    const SIZE_BYTES_WIRE: gremlin.ProtoWireNumber = 1;
    const TIME_SINCE_LAST_DISK_WRITE_SEC_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const ParkableStringUnpark = struct {
    // fields
    size_bytes: i32 = 0,
    time_since_last_disk_write_sec: i32 = 0,
    pub fn calcProtobufSize(self: *const ParkableStringUnpark) usize {
        var res: usize = 0;
        if (self.size_bytes != 0) {
            res += gremlin.sizes.sizeWireNumber(ParkableStringUnparkWire.SIZE_BYTES_WIRE) + gremlin.sizes.sizeI32(self.size_bytes);
        }
        if (self.time_since_last_disk_write_sec != 0) {
            res += gremlin.sizes.sizeWireNumber(ParkableStringUnparkWire.TIME_SINCE_LAST_DISK_WRITE_SEC_WIRE) + gremlin.sizes.sizeI32(self.time_since_last_disk_write_sec);
        }
        return res;
    }
    pub fn encode(self: *const ParkableStringUnpark, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ParkableStringUnpark, target: *gremlin.Writer) void {
        if (self.size_bytes != 0) {
            target.appendInt32(ParkableStringUnparkWire.SIZE_BYTES_WIRE, self.size_bytes);
        }
        if (self.time_since_last_disk_write_sec != 0) {
            target.appendInt32(ParkableStringUnparkWire.TIME_SINCE_LAST_DISK_WRITE_SEC_WIRE, self.time_since_last_disk_write_sec);
        }
    }
};
pub const ParkableStringUnparkReader = struct {
    buf: gremlin.Reader,
    _size_bytes: i32 = 0,
    _time_since_last_disk_write_sec: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!ParkableStringUnparkReader {
        const buf = gremlin.Reader.init(src);
        var res = ParkableStringUnparkReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ParkableStringUnparkWire.SIZE_BYTES_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._size_bytes = result.value;
                },
                ParkableStringUnparkWire.TIME_SINCE_LAST_DISK_WRITE_SEC_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._time_since_last_disk_write_sec = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getSizeBytes(self: *const ParkableStringUnparkReader) i32 {
        return self._size_bytes;
    }
    pub inline fn getTimeSinceLastDiskWriteSec(self: *const ParkableStringUnparkReader) i32 {
        return self._time_since_last_disk_write_sec;
    }
};
const ChromeSamplingProfilerSampleCollectedWire = struct {
    const FRAME_COUNT_WIRE: gremlin.ProtoWireNumber = 1;
    const WRITE_STATUS_WIRE: gremlin.ProtoWireNumber = 2;
    const SAMPLED_THREAD_ID_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const ChromeSamplingProfilerSampleCollected = struct {
    // nested enums
    pub const WriteStatus = enum(i32) {
        WRITE_STATUS_NONE = 0,
        WRITE_STATUS_BUFFERING_SAMPLE = 1,
        WRITE_STATUS_WRITING_BUFFERED = 2,
        WRITE_STATUS_WRITING_TO_TRACE = 3,
    };
    // fields
    frame_count: i32 = 0,
    write_status: ChromeSamplingProfilerSampleCollected.WriteStatus = @enumFromInt(0),
    sampled_thread_id: i32 = 0,
    pub fn calcProtobufSize(self: *const ChromeSamplingProfilerSampleCollected) usize {
        var res: usize = 0;
        if (self.frame_count != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeSamplingProfilerSampleCollectedWire.FRAME_COUNT_WIRE) + gremlin.sizes.sizeI32(self.frame_count);
        }
        if (@intFromEnum(self.write_status) != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeSamplingProfilerSampleCollectedWire.WRITE_STATUS_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.write_status));
        }
        if (self.sampled_thread_id != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeSamplingProfilerSampleCollectedWire.SAMPLED_THREAD_ID_WIRE) + gremlin.sizes.sizeI32(self.sampled_thread_id);
        }
        return res;
    }
    pub fn encode(self: *const ChromeSamplingProfilerSampleCollected, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ChromeSamplingProfilerSampleCollected, target: *gremlin.Writer) void {
        if (self.frame_count != 0) {
            target.appendInt32(ChromeSamplingProfilerSampleCollectedWire.FRAME_COUNT_WIRE, self.frame_count);
        }
        if (@intFromEnum(self.write_status) != 0) {
            target.appendInt32(ChromeSamplingProfilerSampleCollectedWire.WRITE_STATUS_WIRE, @intFromEnum(self.write_status));
        }
        if (self.sampled_thread_id != 0) {
            target.appendInt32(ChromeSamplingProfilerSampleCollectedWire.SAMPLED_THREAD_ID_WIRE, self.sampled_thread_id);
        }
    }
};
pub const ChromeSamplingProfilerSampleCollectedReader = struct {
    buf: gremlin.Reader,
    _frame_count: i32 = 0,
    _write_status: ChromeSamplingProfilerSampleCollected.WriteStatus = @enumFromInt(0),
    _sampled_thread_id: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!ChromeSamplingProfilerSampleCollectedReader {
        const buf = gremlin.Reader.init(src);
        var res = ChromeSamplingProfilerSampleCollectedReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ChromeSamplingProfilerSampleCollectedWire.FRAME_COUNT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._frame_count = result.value;
                },
                ChromeSamplingProfilerSampleCollectedWire.WRITE_STATUS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._write_status = @enumFromInt(result.value);
                },
                ChromeSamplingProfilerSampleCollectedWire.SAMPLED_THREAD_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._sampled_thread_id = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getFrameCount(self: *const ChromeSamplingProfilerSampleCollectedReader) i32 {
        return self._frame_count;
    }
    pub inline fn getWriteStatus(self: *const ChromeSamplingProfilerSampleCollectedReader) ChromeSamplingProfilerSampleCollected.WriteStatus {
        return self._write_status;
    }
    pub inline fn getSampledThreadId(self: *const ChromeSamplingProfilerSampleCollectedReader) i32 {
        return self._sampled_thread_id;
    }
};
const SendBeginMainFrameToCommitBreakdownWire = struct {
    const HANDLE_INPUT_EVENTS_US_WIRE: gremlin.ProtoWireNumber = 1;
    const ANIMATE_US_WIRE: gremlin.ProtoWireNumber = 2;
    const STYLE_UPDATE_US_WIRE: gremlin.ProtoWireNumber = 3;
    const LAYOUT_UPDATE_US_WIRE: gremlin.ProtoWireNumber = 4;
    const ACCESSIBILITY_UPDATE_US_WIRE: gremlin.ProtoWireNumber = 12;
    const PREPAINT_US_WIRE: gremlin.ProtoWireNumber = 5;
    const COMPOSITING_INPUTS_US_WIRE: gremlin.ProtoWireNumber = 6;
    const COMPOSITING_ASSIGNMENTS_US_WIRE: gremlin.ProtoWireNumber = 7;
    const PAINT_US_WIRE: gremlin.ProtoWireNumber = 8;
    const COMPOSITE_COMMIT_US_WIRE: gremlin.ProtoWireNumber = 9;
    const UPDATE_LAYERS_US_WIRE: gremlin.ProtoWireNumber = 10;
    const BEGIN_MAIN_SENT_TO_STARTED_US_WIRE: gremlin.ProtoWireNumber = 11;
};
pub const SendBeginMainFrameToCommitBreakdown = struct {
    // fields
    handle_input_events_us: u64 = 0,
    animate_us: u64 = 0,
    style_update_us: u64 = 0,
    layout_update_us: u64 = 0,
    accessibility_update_us: u64 = 0,
    prepaint_us: u64 = 0,
    compositing_inputs_us: u64 = 0,
    compositing_assignments_us: u64 = 0,
    paint_us: u64 = 0,
    composite_commit_us: u64 = 0,
    update_layers_us: u64 = 0,
    begin_main_sent_to_started_us: u64 = 0,
    pub fn calcProtobufSize(self: *const SendBeginMainFrameToCommitBreakdown) usize {
        var res: usize = 0;
        if (self.handle_input_events_us != 0) {
            res += gremlin.sizes.sizeWireNumber(SendBeginMainFrameToCommitBreakdownWire.HANDLE_INPUT_EVENTS_US_WIRE) + gremlin.sizes.sizeU64(self.handle_input_events_us);
        }
        if (self.animate_us != 0) {
            res += gremlin.sizes.sizeWireNumber(SendBeginMainFrameToCommitBreakdownWire.ANIMATE_US_WIRE) + gremlin.sizes.sizeU64(self.animate_us);
        }
        if (self.style_update_us != 0) {
            res += gremlin.sizes.sizeWireNumber(SendBeginMainFrameToCommitBreakdownWire.STYLE_UPDATE_US_WIRE) + gremlin.sizes.sizeU64(self.style_update_us);
        }
        if (self.layout_update_us != 0) {
            res += gremlin.sizes.sizeWireNumber(SendBeginMainFrameToCommitBreakdownWire.LAYOUT_UPDATE_US_WIRE) + gremlin.sizes.sizeU64(self.layout_update_us);
        }
        if (self.accessibility_update_us != 0) {
            res += gremlin.sizes.sizeWireNumber(SendBeginMainFrameToCommitBreakdownWire.ACCESSIBILITY_UPDATE_US_WIRE) + gremlin.sizes.sizeU64(self.accessibility_update_us);
        }
        if (self.prepaint_us != 0) {
            res += gremlin.sizes.sizeWireNumber(SendBeginMainFrameToCommitBreakdownWire.PREPAINT_US_WIRE) + gremlin.sizes.sizeU64(self.prepaint_us);
        }
        if (self.compositing_inputs_us != 0) {
            res += gremlin.sizes.sizeWireNumber(SendBeginMainFrameToCommitBreakdownWire.COMPOSITING_INPUTS_US_WIRE) + gremlin.sizes.sizeU64(self.compositing_inputs_us);
        }
        if (self.compositing_assignments_us != 0) {
            res += gremlin.sizes.sizeWireNumber(SendBeginMainFrameToCommitBreakdownWire.COMPOSITING_ASSIGNMENTS_US_WIRE) + gremlin.sizes.sizeU64(self.compositing_assignments_us);
        }
        if (self.paint_us != 0) {
            res += gremlin.sizes.sizeWireNumber(SendBeginMainFrameToCommitBreakdownWire.PAINT_US_WIRE) + gremlin.sizes.sizeU64(self.paint_us);
        }
        if (self.composite_commit_us != 0) {
            res += gremlin.sizes.sizeWireNumber(SendBeginMainFrameToCommitBreakdownWire.COMPOSITE_COMMIT_US_WIRE) + gremlin.sizes.sizeU64(self.composite_commit_us);
        }
        if (self.update_layers_us != 0) {
            res += gremlin.sizes.sizeWireNumber(SendBeginMainFrameToCommitBreakdownWire.UPDATE_LAYERS_US_WIRE) + gremlin.sizes.sizeU64(self.update_layers_us);
        }
        if (self.begin_main_sent_to_started_us != 0) {
            res += gremlin.sizes.sizeWireNumber(SendBeginMainFrameToCommitBreakdownWire.BEGIN_MAIN_SENT_TO_STARTED_US_WIRE) + gremlin.sizes.sizeU64(self.begin_main_sent_to_started_us);
        }
        return res;
    }
    pub fn encode(self: *const SendBeginMainFrameToCommitBreakdown, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SendBeginMainFrameToCommitBreakdown, target: *gremlin.Writer) void {
        if (self.handle_input_events_us != 0) {
            target.appendUint64(SendBeginMainFrameToCommitBreakdownWire.HANDLE_INPUT_EVENTS_US_WIRE, self.handle_input_events_us);
        }
        if (self.animate_us != 0) {
            target.appendUint64(SendBeginMainFrameToCommitBreakdownWire.ANIMATE_US_WIRE, self.animate_us);
        }
        if (self.style_update_us != 0) {
            target.appendUint64(SendBeginMainFrameToCommitBreakdownWire.STYLE_UPDATE_US_WIRE, self.style_update_us);
        }
        if (self.layout_update_us != 0) {
            target.appendUint64(SendBeginMainFrameToCommitBreakdownWire.LAYOUT_UPDATE_US_WIRE, self.layout_update_us);
        }
        if (self.accessibility_update_us != 0) {
            target.appendUint64(SendBeginMainFrameToCommitBreakdownWire.ACCESSIBILITY_UPDATE_US_WIRE, self.accessibility_update_us);
        }
        if (self.prepaint_us != 0) {
            target.appendUint64(SendBeginMainFrameToCommitBreakdownWire.PREPAINT_US_WIRE, self.prepaint_us);
        }
        if (self.compositing_inputs_us != 0) {
            target.appendUint64(SendBeginMainFrameToCommitBreakdownWire.COMPOSITING_INPUTS_US_WIRE, self.compositing_inputs_us);
        }
        if (self.compositing_assignments_us != 0) {
            target.appendUint64(SendBeginMainFrameToCommitBreakdownWire.COMPOSITING_ASSIGNMENTS_US_WIRE, self.compositing_assignments_us);
        }
        if (self.paint_us != 0) {
            target.appendUint64(SendBeginMainFrameToCommitBreakdownWire.PAINT_US_WIRE, self.paint_us);
        }
        if (self.composite_commit_us != 0) {
            target.appendUint64(SendBeginMainFrameToCommitBreakdownWire.COMPOSITE_COMMIT_US_WIRE, self.composite_commit_us);
        }
        if (self.update_layers_us != 0) {
            target.appendUint64(SendBeginMainFrameToCommitBreakdownWire.UPDATE_LAYERS_US_WIRE, self.update_layers_us);
        }
        if (self.begin_main_sent_to_started_us != 0) {
            target.appendUint64(SendBeginMainFrameToCommitBreakdownWire.BEGIN_MAIN_SENT_TO_STARTED_US_WIRE, self.begin_main_sent_to_started_us);
        }
    }
};
pub const SendBeginMainFrameToCommitBreakdownReader = struct {
    buf: gremlin.Reader,
    _handle_input_events_us: u64 = 0,
    _animate_us: u64 = 0,
    _style_update_us: u64 = 0,
    _layout_update_us: u64 = 0,
    _accessibility_update_us: u64 = 0,
    _prepaint_us: u64 = 0,
    _compositing_inputs_us: u64 = 0,
    _compositing_assignments_us: u64 = 0,
    _paint_us: u64 = 0,
    _composite_commit_us: u64 = 0,
    _update_layers_us: u64 = 0,
    _begin_main_sent_to_started_us: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!SendBeginMainFrameToCommitBreakdownReader {
        const buf = gremlin.Reader.init(src);
        var res = SendBeginMainFrameToCommitBreakdownReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SendBeginMainFrameToCommitBreakdownWire.HANDLE_INPUT_EVENTS_US_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._handle_input_events_us = result.value;
                },
                SendBeginMainFrameToCommitBreakdownWire.ANIMATE_US_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._animate_us = result.value;
                },
                SendBeginMainFrameToCommitBreakdownWire.STYLE_UPDATE_US_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._style_update_us = result.value;
                },
                SendBeginMainFrameToCommitBreakdownWire.LAYOUT_UPDATE_US_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._layout_update_us = result.value;
                },
                SendBeginMainFrameToCommitBreakdownWire.ACCESSIBILITY_UPDATE_US_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._accessibility_update_us = result.value;
                },
                SendBeginMainFrameToCommitBreakdownWire.PREPAINT_US_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._prepaint_us = result.value;
                },
                SendBeginMainFrameToCommitBreakdownWire.COMPOSITING_INPUTS_US_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._compositing_inputs_us = result.value;
                },
                SendBeginMainFrameToCommitBreakdownWire.COMPOSITING_ASSIGNMENTS_US_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._compositing_assignments_us = result.value;
                },
                SendBeginMainFrameToCommitBreakdownWire.PAINT_US_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._paint_us = result.value;
                },
                SendBeginMainFrameToCommitBreakdownWire.COMPOSITE_COMMIT_US_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._composite_commit_us = result.value;
                },
                SendBeginMainFrameToCommitBreakdownWire.UPDATE_LAYERS_US_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._update_layers_us = result.value;
                },
                SendBeginMainFrameToCommitBreakdownWire.BEGIN_MAIN_SENT_TO_STARTED_US_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._begin_main_sent_to_started_us = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getHandleInputEventsUs(self: *const SendBeginMainFrameToCommitBreakdownReader) u64 {
        return self._handle_input_events_us;
    }
    pub inline fn getAnimateUs(self: *const SendBeginMainFrameToCommitBreakdownReader) u64 {
        return self._animate_us;
    }
    pub inline fn getStyleUpdateUs(self: *const SendBeginMainFrameToCommitBreakdownReader) u64 {
        return self._style_update_us;
    }
    pub inline fn getLayoutUpdateUs(self: *const SendBeginMainFrameToCommitBreakdownReader) u64 {
        return self._layout_update_us;
    }
    pub inline fn getAccessibilityUpdateUs(self: *const SendBeginMainFrameToCommitBreakdownReader) u64 {
        return self._accessibility_update_us;
    }
    pub inline fn getPrepaintUs(self: *const SendBeginMainFrameToCommitBreakdownReader) u64 {
        return self._prepaint_us;
    }
    pub inline fn getCompositingInputsUs(self: *const SendBeginMainFrameToCommitBreakdownReader) u64 {
        return self._compositing_inputs_us;
    }
    pub inline fn getCompositingAssignmentsUs(self: *const SendBeginMainFrameToCommitBreakdownReader) u64 {
        return self._compositing_assignments_us;
    }
    pub inline fn getPaintUs(self: *const SendBeginMainFrameToCommitBreakdownReader) u64 {
        return self._paint_us;
    }
    pub inline fn getCompositeCommitUs(self: *const SendBeginMainFrameToCommitBreakdownReader) u64 {
        return self._composite_commit_us;
    }
    pub inline fn getUpdateLayersUs(self: *const SendBeginMainFrameToCommitBreakdownReader) u64 {
        return self._update_layers_us;
    }
    pub inline fn getBeginMainSentToStartedUs(self: *const SendBeginMainFrameToCommitBreakdownReader) u64 {
        return self._begin_main_sent_to_started_us;
    }
};
const GlobalRenderFrameHostIdWire = struct {
    const ROUTING_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const PROCESS_ID_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const GlobalRenderFrameHostId = struct {
    // fields
    routing_id: i32 = 0,
    process_id: i32 = 0,
    pub fn calcProtobufSize(self: *const GlobalRenderFrameHostId) usize {
        var res: usize = 0;
        if (self.routing_id != 0) {
            res += gremlin.sizes.sizeWireNumber(GlobalRenderFrameHostIdWire.ROUTING_ID_WIRE) + gremlin.sizes.sizeI32(self.routing_id);
        }
        if (self.process_id != 0) {
            res += gremlin.sizes.sizeWireNumber(GlobalRenderFrameHostIdWire.PROCESS_ID_WIRE) + gremlin.sizes.sizeI32(self.process_id);
        }
        return res;
    }
    pub fn encode(self: *const GlobalRenderFrameHostId, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const GlobalRenderFrameHostId, target: *gremlin.Writer) void {
        if (self.routing_id != 0) {
            target.appendInt32(GlobalRenderFrameHostIdWire.ROUTING_ID_WIRE, self.routing_id);
        }
        if (self.process_id != 0) {
            target.appendInt32(GlobalRenderFrameHostIdWire.PROCESS_ID_WIRE, self.process_id);
        }
    }
};
pub const GlobalRenderFrameHostIdReader = struct {
    buf: gremlin.Reader,
    _routing_id: i32 = 0,
    _process_id: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!GlobalRenderFrameHostIdReader {
        const buf = gremlin.Reader.init(src);
        var res = GlobalRenderFrameHostIdReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                GlobalRenderFrameHostIdWire.ROUTING_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._routing_id = result.value;
                },
                GlobalRenderFrameHostIdWire.PROCESS_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._process_id = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getRoutingId(self: *const GlobalRenderFrameHostIdReader) i32 {
        return self._routing_id;
    }
    pub inline fn getProcessId(self: *const GlobalRenderFrameHostIdReader) i32 {
        return self._process_id;
    }
};
const BrowsingContextStateWire = struct {
    const BROWSING_INSTANCE_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const COOP_RELATED_GROUP_ID_WIRE: gremlin.ProtoWireNumber = 2;
    const COOP_RELATED_GROUP_TOKEN_WIRE: gremlin.ProtoWireNumber = 3;
    const DEBUG_ANNOTATIONS_WIRE: gremlin.ProtoWireNumber = 99;
};
pub const BrowsingContextState = struct {
    // fields
    browsing_instance_id: i32 = 0,
    coop_related_group_id: i32 = 0,
    coop_related_group_token: ?[]const u8 = null,
    debug_annotations: ?[]const ?debug_annotation.DebugAnnotation = null,
    pub fn calcProtobufSize(self: *const BrowsingContextState) usize {
        var res: usize = 0;
        if (self.browsing_instance_id != 0) {
            res += gremlin.sizes.sizeWireNumber(BrowsingContextStateWire.BROWSING_INSTANCE_ID_WIRE) + gremlin.sizes.sizeI32(self.browsing_instance_id);
        }
        if (self.coop_related_group_id != 0) {
            res += gremlin.sizes.sizeWireNumber(BrowsingContextStateWire.COOP_RELATED_GROUP_ID_WIRE) + gremlin.sizes.sizeI32(self.coop_related_group_id);
        }
        if (self.coop_related_group_token) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(BrowsingContextStateWire.COOP_RELATED_GROUP_TOKEN_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.debug_annotations) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(BrowsingContextStateWire.DEBUG_ANNOTATIONS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const BrowsingContextState, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const BrowsingContextState, target: *gremlin.Writer) void {
        if (self.browsing_instance_id != 0) {
            target.appendInt32(BrowsingContextStateWire.BROWSING_INSTANCE_ID_WIRE, self.browsing_instance_id);
        }
        if (self.coop_related_group_id != 0) {
            target.appendInt32(BrowsingContextStateWire.COOP_RELATED_GROUP_ID_WIRE, self.coop_related_group_id);
        }
        if (self.coop_related_group_token) |v| {
            if (v.len > 0) {
                target.appendBytes(BrowsingContextStateWire.COOP_RELATED_GROUP_TOKEN_WIRE, v);
            }
        }
        if (self.debug_annotations) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(BrowsingContextStateWire.DEBUG_ANNOTATIONS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(BrowsingContextStateWire.DEBUG_ANNOTATIONS_WIRE, 0);
                }
            }
        }
    }
};
pub const BrowsingContextStateReader = struct {
    buf: gremlin.Reader,
    _browsing_instance_id: i32 = 0,
    _coop_related_group_id: i32 = 0,
    _coop_related_group_token: ?[]const u8 = null,
    _debug_annotations_offset: ?usize = null,
    _debug_annotations_last_offset: ?usize = null,
    _debug_annotations_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!BrowsingContextStateReader {
        const buf = gremlin.Reader.init(src);
        var res = BrowsingContextStateReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                BrowsingContextStateWire.BROWSING_INSTANCE_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._browsing_instance_id = result.value;
                },
                BrowsingContextStateWire.COOP_RELATED_GROUP_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._coop_related_group_id = result.value;
                },
                BrowsingContextStateWire.COOP_RELATED_GROUP_TOKEN_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._coop_related_group_token = result.value;
                },
                BrowsingContextStateWire.DEBUG_ANNOTATIONS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._debug_annotations_offset == null) {
                        res._debug_annotations_offset = offset - result.size;
                    }
                    res._debug_annotations_last_offset = offset;
                    res._debug_annotations_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getBrowsingInstanceId(self: *const BrowsingContextStateReader) i32 {
        return self._browsing_instance_id;
    }
    pub inline fn getCoopRelatedGroupId(self: *const BrowsingContextStateReader) i32 {
        return self._coop_related_group_id;
    }
    pub inline fn getCoopRelatedGroupToken(self: *const BrowsingContextStateReader) []const u8 {
        return self._coop_related_group_token orelse &[_]u8{};
    }
    pub fn debugAnnotationsCount(self: *const BrowsingContextStateReader) usize {
        return self._debug_annotations_cnt;
    }
    pub fn debugAnnotationsNext(self: *BrowsingContextStateReader) ?debug_annotation.DebugAnnotationReader {
        if (self._debug_annotations_offset == null) return null;
        const current_offset = self._debug_annotations_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = debug_annotation.DebugAnnotationReader.init(result.value) catch return null;
        if (self._debug_annotations_last_offset != null and current_offset >= self._debug_annotations_last_offset.?) {
            self._debug_annotations_offset = null;
            return msg;
        }
        if (self._debug_annotations_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._debug_annotations_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == BrowsingContextStateWire.DEBUG_ANNOTATIONS_WIRE) {
                self._debug_annotations_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._debug_annotations_offset = null;
        return msg;
    }
};
const RenderFrameHostWire = struct {
    const PROCESS_WIRE: gremlin.ProtoWireNumber = 1;
    const RENDER_FRAME_HOST_ID_WIRE: gremlin.ProtoWireNumber = 2;
    const LIFECYCLE_STATE_WIRE: gremlin.ProtoWireNumber = 3;
    const ORIGIN_WIRE: gremlin.ProtoWireNumber = 4;
    const URL_WIRE: gremlin.ProtoWireNumber = 5;
    const FRAME_TREE_NODE_ID_WIRE: gremlin.ProtoWireNumber = 6;
    const SITE_INSTANCE_WIRE: gremlin.ProtoWireNumber = 7;
    const PARENT_WIRE: gremlin.ProtoWireNumber = 8;
    const OUTER_DOCUMENT_WIRE: gremlin.ProtoWireNumber = 9;
    const EMBEDDER_WIRE: gremlin.ProtoWireNumber = 10;
    const BROWSING_CONTEXT_STATE_WIRE: gremlin.ProtoWireNumber = 11;
    const FRAME_TYPE_WIRE: gremlin.ProtoWireNumber = 12;
    const DEBUG_ANNOTATIONS_WIRE: gremlin.ProtoWireNumber = 99;
};
pub const RenderFrameHost = struct {
    // nested enums
    pub const LifecycleState = enum(i32) {
        UNSPECIFIED = 0,
        SPECULATIVE = 1,
        PENDING_COMMIT = 2,
        PRERENDERING = 3,
        ACTIVE = 4,
        IN_BACK_FORWARD_CACHE = 5,
        RUNNING_UNLOAD_HANDLERS = 6,
        READY_TO_BE_DELETED = 7,
    };
    // fields
    process: ?RenderProcessHost = null,
    render_frame_host_id: ?GlobalRenderFrameHostId = null,
    lifecycle_state: RenderFrameHost.LifecycleState = @enumFromInt(0),
    origin: ?[]const u8 = null,
    url: ?[]const u8 = null,
    frame_tree_node_id: u64 = 0,
    site_instance: ?SiteInstance = null,
    parent: ?RenderFrameHost = null,
    outer_document: ?RenderFrameHost = null,
    embedder: ?RenderFrameHost = null,
    browsing_context_state: ?BrowsingContextState = null,
    frame_type: FrameTreeNodeInfo.FrameType = @enumFromInt(0),
    debug_annotations: ?[]const ?debug_annotation.DebugAnnotation = null,
    pub fn calcProtobufSize(self: *const RenderFrameHost) usize {
        var res: usize = 0;
        if (self.process) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(RenderFrameHostWire.PROCESS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.render_frame_host_id) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(RenderFrameHostWire.RENDER_FRAME_HOST_ID_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (@intFromEnum(self.lifecycle_state) != 0) {
            res += gremlin.sizes.sizeWireNumber(RenderFrameHostWire.LIFECYCLE_STATE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.lifecycle_state));
        }
        if (self.origin) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(RenderFrameHostWire.ORIGIN_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.url) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(RenderFrameHostWire.URL_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.frame_tree_node_id != 0) {
            res += gremlin.sizes.sizeWireNumber(RenderFrameHostWire.FRAME_TREE_NODE_ID_WIRE) + gremlin.sizes.sizeU64(self.frame_tree_node_id);
        }
        if (self.site_instance) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(RenderFrameHostWire.SITE_INSTANCE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.parent) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(RenderFrameHostWire.PARENT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.outer_document) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(RenderFrameHostWire.OUTER_DOCUMENT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.embedder) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(RenderFrameHostWire.EMBEDDER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.browsing_context_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(RenderFrameHostWire.BROWSING_CONTEXT_STATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (@intFromEnum(self.frame_type) != 0) {
            res += gremlin.sizes.sizeWireNumber(RenderFrameHostWire.FRAME_TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.frame_type));
        }
        if (self.debug_annotations) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(RenderFrameHostWire.DEBUG_ANNOTATIONS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const RenderFrameHost, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const RenderFrameHost, target: *gremlin.Writer) void {
        if (self.process) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(RenderFrameHostWire.PROCESS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.render_frame_host_id) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(RenderFrameHostWire.RENDER_FRAME_HOST_ID_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (@intFromEnum(self.lifecycle_state) != 0) {
            target.appendInt32(RenderFrameHostWire.LIFECYCLE_STATE_WIRE, @intFromEnum(self.lifecycle_state));
        }
        if (self.origin) |v| {
            if (v.len > 0) {
                target.appendBytes(RenderFrameHostWire.ORIGIN_WIRE, v);
            }
        }
        if (self.url) |v| {
            if (v.len > 0) {
                target.appendBytes(RenderFrameHostWire.URL_WIRE, v);
            }
        }
        if (self.frame_tree_node_id != 0) {
            target.appendUint64(RenderFrameHostWire.FRAME_TREE_NODE_ID_WIRE, self.frame_tree_node_id);
        }
        if (self.site_instance) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(RenderFrameHostWire.SITE_INSTANCE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.parent) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(RenderFrameHostWire.PARENT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.outer_document) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(RenderFrameHostWire.OUTER_DOCUMENT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.embedder) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(RenderFrameHostWire.EMBEDDER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.browsing_context_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(RenderFrameHostWire.BROWSING_CONTEXT_STATE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (@intFromEnum(self.frame_type) != 0) {
            target.appendInt32(RenderFrameHostWire.FRAME_TYPE_WIRE, @intFromEnum(self.frame_type));
        }
        if (self.debug_annotations) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(RenderFrameHostWire.DEBUG_ANNOTATIONS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(RenderFrameHostWire.DEBUG_ANNOTATIONS_WIRE, 0);
                }
            }
        }
    }
};
pub const RenderFrameHostReader = struct {
    buf: gremlin.Reader,
    _process_buf: ?[]const u8 = null,
    _render_frame_host_id_buf: ?[]const u8 = null,
    _lifecycle_state: RenderFrameHost.LifecycleState = @enumFromInt(0),
    _origin: ?[]const u8 = null,
    _url: ?[]const u8 = null,
    _frame_tree_node_id: u64 = 0,
    _site_instance_buf: ?[]const u8 = null,
    _parent_buf: ?[]const u8 = null,
    _outer_document_buf: ?[]const u8 = null,
    _embedder_buf: ?[]const u8 = null,
    _browsing_context_state_buf: ?[]const u8 = null,
    _frame_type: FrameTreeNodeInfo.FrameType = @enumFromInt(0),
    _debug_annotations_offset: ?usize = null,
    _debug_annotations_last_offset: ?usize = null,
    _debug_annotations_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!RenderFrameHostReader {
        const buf = gremlin.Reader.init(src);
        var res = RenderFrameHostReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                RenderFrameHostWire.PROCESS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._process_buf = result.value;
                },
                RenderFrameHostWire.RENDER_FRAME_HOST_ID_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._render_frame_host_id_buf = result.value;
                },
                RenderFrameHostWire.LIFECYCLE_STATE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._lifecycle_state = @enumFromInt(result.value);
                },
                RenderFrameHostWire.ORIGIN_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._origin = result.value;
                },
                RenderFrameHostWire.URL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._url = result.value;
                },
                RenderFrameHostWire.FRAME_TREE_NODE_ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._frame_tree_node_id = result.value;
                },
                RenderFrameHostWire.SITE_INSTANCE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._site_instance_buf = result.value;
                },
                RenderFrameHostWire.PARENT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._parent_buf = result.value;
                },
                RenderFrameHostWire.OUTER_DOCUMENT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._outer_document_buf = result.value;
                },
                RenderFrameHostWire.EMBEDDER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._embedder_buf = result.value;
                },
                RenderFrameHostWire.BROWSING_CONTEXT_STATE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._browsing_context_state_buf = result.value;
                },
                RenderFrameHostWire.FRAME_TYPE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._frame_type = @enumFromInt(result.value);
                },
                RenderFrameHostWire.DEBUG_ANNOTATIONS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._debug_annotations_offset == null) {
                        res._debug_annotations_offset = offset - result.size;
                    }
                    res._debug_annotations_last_offset = offset;
                    res._debug_annotations_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getProcess(self: *const RenderFrameHostReader) gremlin.Error!RenderProcessHostReader {
        if (self._process_buf) |buf| {
            return try RenderProcessHostReader.init(buf);
        }
        return try RenderProcessHostReader.init(&[_]u8{});
    }
    pub fn getRenderFrameHostId(self: *const RenderFrameHostReader) gremlin.Error!GlobalRenderFrameHostIdReader {
        if (self._render_frame_host_id_buf) |buf| {
            return try GlobalRenderFrameHostIdReader.init(buf);
        }
        return try GlobalRenderFrameHostIdReader.init(&[_]u8{});
    }
    pub inline fn getLifecycleState(self: *const RenderFrameHostReader) RenderFrameHost.LifecycleState {
        return self._lifecycle_state;
    }
    pub inline fn getOrigin(self: *const RenderFrameHostReader) []const u8 {
        return self._origin orelse &[_]u8{};
    }
    pub inline fn getUrl(self: *const RenderFrameHostReader) []const u8 {
        return self._url orelse &[_]u8{};
    }
    pub inline fn getFrameTreeNodeId(self: *const RenderFrameHostReader) u64 {
        return self._frame_tree_node_id;
    }
    pub fn getSiteInstance(self: *const RenderFrameHostReader) gremlin.Error!SiteInstanceReader {
        if (self._site_instance_buf) |buf| {
            return try SiteInstanceReader.init(buf);
        }
        return try SiteInstanceReader.init(&[_]u8{});
    }
    pub fn getParent(self: *const RenderFrameHostReader) gremlin.Error!RenderFrameHostReader {
        if (self._parent_buf) |buf| {
            return try RenderFrameHostReader.init(buf);
        }
        return try RenderFrameHostReader.init(&[_]u8{});
    }
    pub fn getOuterDocument(self: *const RenderFrameHostReader) gremlin.Error!RenderFrameHostReader {
        if (self._outer_document_buf) |buf| {
            return try RenderFrameHostReader.init(buf);
        }
        return try RenderFrameHostReader.init(&[_]u8{});
    }
    pub fn getEmbedder(self: *const RenderFrameHostReader) gremlin.Error!RenderFrameHostReader {
        if (self._embedder_buf) |buf| {
            return try RenderFrameHostReader.init(buf);
        }
        return try RenderFrameHostReader.init(&[_]u8{});
    }
    pub fn getBrowsingContextState(self: *const RenderFrameHostReader) gremlin.Error!BrowsingContextStateReader {
        if (self._browsing_context_state_buf) |buf| {
            return try BrowsingContextStateReader.init(buf);
        }
        return try BrowsingContextStateReader.init(&[_]u8{});
    }
    pub inline fn getFrameType(self: *const RenderFrameHostReader) FrameTreeNodeInfo.FrameType {
        return self._frame_type;
    }
    pub fn debugAnnotationsCount(self: *const RenderFrameHostReader) usize {
        return self._debug_annotations_cnt;
    }
    pub fn debugAnnotationsNext(self: *RenderFrameHostReader) ?debug_annotation.DebugAnnotationReader {
        if (self._debug_annotations_offset == null) return null;
        const current_offset = self._debug_annotations_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = debug_annotation.DebugAnnotationReader.init(result.value) catch return null;
        if (self._debug_annotations_last_offset != null and current_offset >= self._debug_annotations_last_offset.?) {
            self._debug_annotations_offset = null;
            return msg;
        }
        if (self._debug_annotations_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._debug_annotations_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == RenderFrameHostWire.DEBUG_ANNOTATIONS_WIRE) {
                self._debug_annotations_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._debug_annotations_offset = null;
        return msg;
    }
};
const ChromeThreadPoolTaskWire = struct {
    const TASK_PRIORITY_WIRE: gremlin.ProtoWireNumber = 1;
    const EXECUTION_MODE_WIRE: gremlin.ProtoWireNumber = 2;
    const SEQUENCE_TOKEN_WIRE: gremlin.ProtoWireNumber = 3;
    const SHUTDOWN_BEHAVIOR_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const ChromeThreadPoolTask = struct {
    // nested enums
    pub const Priority = enum(i32) {
        PRIORITY_UNSPECIFIED = 0,
        PRIORITY_BEST_EFFORT = 1,
        PRIORITY_USER_VISIBLE = 2,
        PRIORITY_USER_BLOCKING = 3,
    };
    pub const ExecutionMode = enum(i32) {
        EXECTUION_MODE_UNSPECIFIED = 0,
        EXECUTION_MODE_PARALLEL = 1,
        EXECUTION_MODE_SEQUENCED = 2,
        EXECUTION_MODE_SINGLE_THREAD = 3,
        EXECUTION_MODE_JOB = 4,
    };
    pub const ShutdownBehavior = enum(i32) {
        SHUTDOWN_BEHAVIOR_UNSPECIFIED = 0,
        SHUTDOWN_BEHAVIOR_CONTINUE_ON_SHUTDOWN = 1,
        SHUTDOWN_BEHAVIOR_SKIP_ON_SHUTDOWN = 2,
        SHUTDOWN_BEHAVIOR_BLOCK_SHUTDOWN = 3,
    };
    // fields
    task_priority: ChromeThreadPoolTask.Priority = @enumFromInt(0),
    execution_mode: ChromeThreadPoolTask.ExecutionMode = @enumFromInt(0),
    sequence_token: i64 = 0,
    shutdown_behavior: ChromeThreadPoolTask.ShutdownBehavior = @enumFromInt(0),
    pub fn calcProtobufSize(self: *const ChromeThreadPoolTask) usize {
        var res: usize = 0;
        if (@intFromEnum(self.task_priority) != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeThreadPoolTaskWire.TASK_PRIORITY_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.task_priority));
        }
        if (@intFromEnum(self.execution_mode) != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeThreadPoolTaskWire.EXECUTION_MODE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.execution_mode));
        }
        if (self.sequence_token != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeThreadPoolTaskWire.SEQUENCE_TOKEN_WIRE) + gremlin.sizes.sizeI64(self.sequence_token);
        }
        if (@intFromEnum(self.shutdown_behavior) != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeThreadPoolTaskWire.SHUTDOWN_BEHAVIOR_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.shutdown_behavior));
        }
        return res;
    }
    pub fn encode(self: *const ChromeThreadPoolTask, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ChromeThreadPoolTask, target: *gremlin.Writer) void {
        if (@intFromEnum(self.task_priority) != 0) {
            target.appendInt32(ChromeThreadPoolTaskWire.TASK_PRIORITY_WIRE, @intFromEnum(self.task_priority));
        }
        if (@intFromEnum(self.execution_mode) != 0) {
            target.appendInt32(ChromeThreadPoolTaskWire.EXECUTION_MODE_WIRE, @intFromEnum(self.execution_mode));
        }
        if (self.sequence_token != 0) {
            target.appendInt64(ChromeThreadPoolTaskWire.SEQUENCE_TOKEN_WIRE, self.sequence_token);
        }
        if (@intFromEnum(self.shutdown_behavior) != 0) {
            target.appendInt32(ChromeThreadPoolTaskWire.SHUTDOWN_BEHAVIOR_WIRE, @intFromEnum(self.shutdown_behavior));
        }
    }
};
pub const ChromeThreadPoolTaskReader = struct {
    buf: gremlin.Reader,
    _task_priority: ChromeThreadPoolTask.Priority = @enumFromInt(0),
    _execution_mode: ChromeThreadPoolTask.ExecutionMode = @enumFromInt(0),
    _sequence_token: i64 = 0,
    _shutdown_behavior: ChromeThreadPoolTask.ShutdownBehavior = @enumFromInt(0),
    pub fn init(src: []const u8) gremlin.Error!ChromeThreadPoolTaskReader {
        const buf = gremlin.Reader.init(src);
        var res = ChromeThreadPoolTaskReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ChromeThreadPoolTaskWire.TASK_PRIORITY_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._task_priority = @enumFromInt(result.value);
                },
                ChromeThreadPoolTaskWire.EXECUTION_MODE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._execution_mode = @enumFromInt(result.value);
                },
                ChromeThreadPoolTaskWire.SEQUENCE_TOKEN_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._sequence_token = result.value;
                },
                ChromeThreadPoolTaskWire.SHUTDOWN_BEHAVIOR_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._shutdown_behavior = @enumFromInt(result.value);
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getTaskPriority(self: *const ChromeThreadPoolTaskReader) ChromeThreadPoolTask.Priority {
        return self._task_priority;
    }
    pub inline fn getExecutionMode(self: *const ChromeThreadPoolTaskReader) ChromeThreadPoolTask.ExecutionMode {
        return self._execution_mode;
    }
    pub inline fn getSequenceToken(self: *const ChromeThreadPoolTaskReader) i64 {
        return self._sequence_token;
    }
    pub inline fn getShutdownBehavior(self: *const ChromeThreadPoolTaskReader) ChromeThreadPoolTask.ShutdownBehavior {
        return self._shutdown_behavior;
    }
};
const BackForwardCacheCanStoreDocumentResultWire = struct {
    const BACK_FORWARD_CACHE_NOT_RESTORED_REASON_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const BackForwardCacheCanStoreDocumentResult = struct {
    // nested enums
    pub const BackForwardCacheNotRestoredReason = enum(i32) {
        NOT_MAIN_FRAME = 1,
        BACK_FORWARD_CACHE_DISABLED = 2,
        RELATED_ACTIVE_CONTENTS_EXIST = 3,
        HTTP_STATUS_NOT_OK = 4,
        SCHEME_NOT_HTTP_OR_HTTPS = 5,
        LOADING = 6,
        WAS_GRANTED_MEDIA_ACCESS = 7,
        BLOCKLISTED_FEATURES = 8,
        DISABLE_FOR_RENDER_FRAME_HOST_CALLED = 9,
        DOMAIN_NOT_ALLOWED = 10,
        HTTP_METHOD_NOT_GET = 11,
        SUBFRAME_IS_NAVIGATING = 12,
        TIMEOUT = 13,
        CACHE_LIMIT = 14,
        JAVASCRIPT_EXECUTION = 15,
        RENDERER_PROCESS_KILLED = 16,
        RENDERER_PROCESS_CRASHED = 17,
        GRANTED_MEDIA_STREAM_ACCESS = 19,
        SCHEDULER_TRACKED_FEATURE_USED = 20,
        CONFLICTING_BROWSING_INSTANCE = 21,
        CACHE_FLUSHED = 22,
        SERVICE_WORKER_VERSION_ACTIVATION = 23,
        SESSION_RESTORED = 24,
        UNKNOWN = 25,
        SERVICE_WORKER_POST_MESSAGE = 26,
        ENTERED_BACK_FORWARD_CACHE_BEFORE_SERVICE_WORKER_HOST_ADDED = 27,
        NOT_MOST_RECENT_NAVIGATION_ENTRY = 28,
        SERVICE_WORKER_CLAIM = 29,
        IGNORE_EVENT_AND_EVICT = 30,
        HAVE_INNER_CONTENTS = 31,
        TIMEOUT_PUTTING_IN_CACHE = 32,
        BACK_FORWARD_CACHE_DISABLED_BY_LOW_MEMORY = 33,
        BACK_FORWARD_CACHE_DISABLED_BY_COMMAND_LINE = 34,
        NETWORK_REQUEST_REDIRECTED = 35,
        NETWORK_REQUEST_TIMEOUT = 36,
        NETWORK_EXCEEDS_BUFFER_LIMIT = 37,
        NAVIGATION_CANCELLED_WHILE_RESTORING = 38,
        BACK_FORWARD_CACHE_DISABLED_FOR_PRERENDER = 39,
        USER_AGENT_OVERRIDE_DIFFERS = 40,
        NETWORK_REQUEST_DATAPIPE_DRAINED_AS_BYTES_CONSUMER = 41,
        FOREGROUND_CACHE_LIMIT = 42,
        BROWSING_INSTANCE_NOT_SWAPPED = 43,
        BACK_FORWARD_CACHE_DISABLED_FOR_DELEGATE = 44,
        OPT_IN_UNLOAD_HEADER_NOT_PRESENT = 45,
        UNLOAD_HANDLER_EXISTS_IN_MAIN_FRAME = 46,
        UNLOAD_HANDLER_EXISTS_IN_SUBFRAME = 47,
        SERVICE_WORKER_UNREGISTRATION = 48,
        CACHE_CONTROL_NO_STORE = 49,
        CACHE_CONTROL_NO_STORE_COOKIE_MODIFIED = 50,
        CACHE_CONTROL_NO_STORE_HTTP_ONLY_COOKIE_MODIFIED = 51,
        NO_RESPONSE_HEAD = 52,
        ACTIVATION_NAVIGATION_DISALLOWED_FOR_BUG_1234857 = 53,
        ERROR_DOCUMENT = 54,
        FENCED_FRAMES_EMBEDDER = 55,
        COOKIE_DISABLED = 56,
        HTTP_AUTH_REQUIRED = 57,
        COOKIE_FLUSHED = 58,
        BROADCAST_CHANNEL_ON_MESSAGE = 59,
        WEBVIEW_SETTINGS_CHANGED = 60,
        WEBVIEW_JAVASCRIPT_OBJECT_CHANGED = 61,
        WEBVIEW_MESSAGE_LISTENER_INJECTED = 62,
        WEBVIEW_SAFE_BROWSING_ALLOWLIST_CHANGED = 63,
        WEBVIEW_DOCUMENT_START_JAVASCRIPT_CHANGED = 64,
        CACHE_CONTROL_NO_STORE_DEVICE_BOUND_SESSION_TERMINATED = 65,
        CACHE_LIMIT_PRUNED_ON_MODERATE_MEMORY_PRESSURE = 66,
        CACHE_LIMIT_PRUNED_ON_CRITICAL_MEMORY_PRESSURE = 67,
        SHARED_WORKER_MESSAGE = 68,
        SHARED_WORKER_WITH_NO_ACTIVE_CLIENT = 69,
        _PROTOBUF_UNKNOWN = 0,
    };
    // fields
    back_forward_cache_not_restored_reason: BackForwardCacheCanStoreDocumentResult.BackForwardCacheNotRestoredReason = @enumFromInt(0),
    pub fn calcProtobufSize(self: *const BackForwardCacheCanStoreDocumentResult) usize {
        var res: usize = 0;
        if (@intFromEnum(self.back_forward_cache_not_restored_reason) != 0) {
            res += gremlin.sizes.sizeWireNumber(BackForwardCacheCanStoreDocumentResultWire.BACK_FORWARD_CACHE_NOT_RESTORED_REASON_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.back_forward_cache_not_restored_reason));
        }
        return res;
    }
    pub fn encode(self: *const BackForwardCacheCanStoreDocumentResult, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const BackForwardCacheCanStoreDocumentResult, target: *gremlin.Writer) void {
        if (@intFromEnum(self.back_forward_cache_not_restored_reason) != 0) {
            target.appendInt32(BackForwardCacheCanStoreDocumentResultWire.BACK_FORWARD_CACHE_NOT_RESTORED_REASON_WIRE, @intFromEnum(self.back_forward_cache_not_restored_reason));
        }
    }
};
pub const BackForwardCacheCanStoreDocumentResultReader = struct {
    buf: gremlin.Reader,
    _back_forward_cache_not_restored_reason: BackForwardCacheCanStoreDocumentResult.BackForwardCacheNotRestoredReason = @enumFromInt(0),
    pub fn init(src: []const u8) gremlin.Error!BackForwardCacheCanStoreDocumentResultReader {
        const buf = gremlin.Reader.init(src);
        var res = BackForwardCacheCanStoreDocumentResultReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                BackForwardCacheCanStoreDocumentResultWire.BACK_FORWARD_CACHE_NOT_RESTORED_REASON_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._back_forward_cache_not_restored_reason = @enumFromInt(result.value);
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getBackForwardCacheNotRestoredReason(self: *const BackForwardCacheCanStoreDocumentResultReader) BackForwardCacheCanStoreDocumentResult.BackForwardCacheNotRestoredReason {
        return self._back_forward_cache_not_restored_reason;
    }
};
const RendererMainThreadTaskExecutionWire = struct {
    const TASK_TYPE_WIRE: gremlin.ProtoWireNumber = 1;
    const FRAME_VISIBLE_WIRE: gremlin.ProtoWireNumber = 2;
    const PAGE_VISIBLE_WIRE: gremlin.ProtoWireNumber = 3;
    const FRAME_TYPE_WIRE: gremlin.ProtoWireNumber = 4;
    const IS_AD_FRAME_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const RendererMainThreadTaskExecution = struct {
    // nested enums
    pub const TaskType = enum(i32) {
        TASK_TYPE_UNKNOWN = 0,
        TASK_TYPE_DOM_MANIPULATION = 1,
        TASK_TYPE_USER_INTERACTION = 2,
        TASK_TYPE_NETWORKING = 3,
        TASK_TYPE_NETWORKING_CONTROL = 4,
        TASK_TYPE_HISTORY_TRAVERSAL = 5,
        TASK_TYPE_EMBED = 6,
        TASK_TYPE_MEDIA_ELEMENT_EVENT = 7,
        TASK_TYPE_CANVAS_BLOB_SERIALIZATION = 8,
        TASK_TYPE_MICROTASK = 9,
        TASK_TYPE_JAVASCRIPT_TIMER_DELAYED_HIGH_NESTING = 10,
        TASK_TYPE_REMOTE_EVENT = 11,
        TASK_TYPE_WEB_SOCKET = 12,
        TASK_TYPE_POSTED_MESSAGE = 13,
        TASK_TYPE_UNSHIPPED_PORT_MESSAGE = 14,
        TASK_TYPE_FILE_READING = 15,
        TASK_TYPE_DATABASE_ACCESS = 16,
        TASK_TYPE_PRESENTATION = 17,
        TASK_TYPE_SENSOR = 18,
        TASK_TYPE_PERFORMANCE_TIMELINE = 19,
        TASK_TYPE_WEB_GL = 20,
        TASK_TYPE_IDLE_TASK = 21,
        TASK_TYPE_MISC_PLATFORM_API = 22,
        TASK_TYPE_INTERNAL_DEFAULT = 23,
        TASK_TYPE_INTERNAL_LOADING = 24,
        TASK_TYPE_INTERNAL_TEST = 26,
        TASK_TYPE_INTERNAL_WEB_CRYPTO = 27,
        TASK_TYPE_INTERNAL_MEDIA = 29,
        TASK_TYPE_INTERNAL_MEDIA_REALTIME = 30,
        TASK_TYPE_INTERNAL_USER_INTERACTION = 32,
        TASK_TYPE_INTERNAL_INSPECTOR = 33,
        TASK_TYPE_MAIN_THREAD_TASK_QUEUE_V8 = 37,
        TASK_TYPE_MAIN_THREAD_TASK_QUEUE_COMPOSITOR = 38,
        TASK_TYPE_MAIN_THREAD_TASK_QUEUE_DEFAULT = 39,
        TASK_TYPE_MAIN_THREAD_TASK_QUEUE_INPUT = 40,
        TASK_TYPE_MAIN_THREAD_TASK_QUEUE_IDLE = 41,
        TASK_TYPE_MAIN_THREAD_TASK_QUEUE_CONTROL = 43,
        TASK_TYPE_INTERNAL_INTERSECTION_OBSERVER = 44,
        TASK_TYPE_COMPOSITOR_THREAD_TASK_QUEUE_DEFAULT = 45,
        TASK_TYPE_WORKER_THREAD_TASK_QUEUE_DEFAULT = 46,
        TASK_TYPE_WORKER_THREAD_TASK_QUEUE_V8 = 47,
        TASK_TYPE_WORKER_THREAD_TASK_QUEUE_COMPOSITOR = 48,
        TASK_TYPE_COMPOSITOR_THREAD_TASK_QUEUE_INPUT = 49,
        TASK_TYPE_NETWORKING_WITH_URL_LOADER_ANNOTATION = 50,
        TASK_TYPE_WORKER_ANIMATION = 51,
        TASK_TYPE_INTERNAL_TRANSLATION = 55,
        TASK_TYPE_FONT_LOADING = 56,
        TASK_TYPE_APPLICATION_LIFECYCLE = 57,
        TASK_TYPE_BACKGROUND_FETCH = 58,
        TASK_TYPE_PERMISSION = 59,
        TASK_TYPE_SERVICE_WORKER_CLIENT_MESSAGE = 60,
        TASK_TYPE_INTERNAL_CONTENT_CAPTURE = 61,
        TASK_TYPE_MAIN_THREAD_TASK_QUEUE_MEMORY_PURGE = 62,
        TASK_TYPE_INTERNAL_NAVIGATION_ASSOCIATED = 63,
        TASK_TYPE_INTERNAL_NAVIGATION_ASSOCIATED_UNFREEZABLE = 64,
        TASK_TYPE_INTERNAL_CONTINUE_SCRIPT_LOADING = 65,
        TASK_TYPE_WEB_LOCKS = 66,
        TASK_TYPE_WEB_SCHEDULING_POSTED_TASK = 67,
        TASK_TYPE_INTERNAL_FRAME_LIFE_CYCLE_CONTROL = 68,
        TASK_TYPE_MAIN_THREAD_TASK_QUEUE_NON_WAKING = 69,
        TASK_TYPE_INTERNAL_FIND_IN_PAGE = 70,
        TASK_TYPE_INTERNAL_HIGH_PRIORITY_LOCAL_FRAME = 71,
        TASK_TYPE_JAVASCRIPT_TIMER_IMMEDIATE = 72,
        TASK_TYPE_JAVASCRIPT_TIMER_DELAYED_LOW_NESTING = 73,
        TASK_TYPE_MAIN_THREAD_TASK_QUEUE_IPC_TRACKING = 74,
        TASK_TYPE_NETWORKING_UNFREEZABLE = 75,
        TASK_TYPE_WAKE_LOCK = 76,
        TASK_TYPE_INTERNAL_INPUT_BLOCKING = 77,
        TASK_TYPE_WEB_GPU = 78,
        TASK_TYPE_INTERNAL_POST_MESSAGE_FORWARDING = 79,
        TASK_TYPE_INTERNAL_NAVIGATION_CANCELLATION = 80,
        TASK_TYPE_LOW_PRIORITY_SCRIPT_EXECUTION = 81,
        TASK_TYPE_STORAGE = 82,
        TASK_TYPE_NETWORKING_UNFREEZABLE_RENDER_BLOCKING_LOADING = 83,
        TASK_TYPE_MAIN_THREAD_TASK_QUEUE_V8_USER_VISIBLE = 84,
        TASK_TYPE_CLIPBOARD = 85,
        TASK_TYPE_MACHINE_LEARNING = 86,
        TASK_TYPE_MAIN_THREAD_TASK_QUEUE_V8_BEST_EFFORT = 87,
        TASK_TYPE_INTERNAL_AUTOFILL = 88,
        TASK_TYPE_BACK_FORWARD_CACHE_POSTED_MESSAGE = 89,
    };
    pub const FrameType = enum(i32) {
        FRAME_TYPE_UNSPECIFIED = 0,
        FRAME_TYPE_MAIN_FRAME = 1,
        FRAME_TYPE_SAME_ORIGIN_SUBFRAME = 2,
        FRAME_TYPE_CROSS_ORIGIN_SUBFRAME = 3,
    };
    // fields
    task_type: RendererMainThreadTaskExecution.TaskType = @enumFromInt(0),
    frame_visible: bool = false,
    page_visible: bool = false,
    frame_type: RendererMainThreadTaskExecution.FrameType = @enumFromInt(0),
    is_ad_frame: bool = false,
    pub fn calcProtobufSize(self: *const RendererMainThreadTaskExecution) usize {
        var res: usize = 0;
        if (@intFromEnum(self.task_type) != 0) {
            res += gremlin.sizes.sizeWireNumber(RendererMainThreadTaskExecutionWire.TASK_TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.task_type));
        }
        if (self.frame_visible != false) {
            res += gremlin.sizes.sizeWireNumber(RendererMainThreadTaskExecutionWire.FRAME_VISIBLE_WIRE) + gremlin.sizes.sizeBool(self.frame_visible);
        }
        if (self.page_visible != false) {
            res += gremlin.sizes.sizeWireNumber(RendererMainThreadTaskExecutionWire.PAGE_VISIBLE_WIRE) + gremlin.sizes.sizeBool(self.page_visible);
        }
        if (@intFromEnum(self.frame_type) != 0) {
            res += gremlin.sizes.sizeWireNumber(RendererMainThreadTaskExecutionWire.FRAME_TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.frame_type));
        }
        if (self.is_ad_frame != false) {
            res += gremlin.sizes.sizeWireNumber(RendererMainThreadTaskExecutionWire.IS_AD_FRAME_WIRE) + gremlin.sizes.sizeBool(self.is_ad_frame);
        }
        return res;
    }
    pub fn encode(self: *const RendererMainThreadTaskExecution, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const RendererMainThreadTaskExecution, target: *gremlin.Writer) void {
        if (@intFromEnum(self.task_type) != 0) {
            target.appendInt32(RendererMainThreadTaskExecutionWire.TASK_TYPE_WIRE, @intFromEnum(self.task_type));
        }
        if (self.frame_visible != false) {
            target.appendBool(RendererMainThreadTaskExecutionWire.FRAME_VISIBLE_WIRE, self.frame_visible);
        }
        if (self.page_visible != false) {
            target.appendBool(RendererMainThreadTaskExecutionWire.PAGE_VISIBLE_WIRE, self.page_visible);
        }
        if (@intFromEnum(self.frame_type) != 0) {
            target.appendInt32(RendererMainThreadTaskExecutionWire.FRAME_TYPE_WIRE, @intFromEnum(self.frame_type));
        }
        if (self.is_ad_frame != false) {
            target.appendBool(RendererMainThreadTaskExecutionWire.IS_AD_FRAME_WIRE, self.is_ad_frame);
        }
    }
};
pub const RendererMainThreadTaskExecutionReader = struct {
    buf: gremlin.Reader,
    _task_type: RendererMainThreadTaskExecution.TaskType = @enumFromInt(0),
    _frame_visible: bool = false,
    _page_visible: bool = false,
    _frame_type: RendererMainThreadTaskExecution.FrameType = @enumFromInt(0),
    _is_ad_frame: bool = false,
    pub fn init(src: []const u8) gremlin.Error!RendererMainThreadTaskExecutionReader {
        const buf = gremlin.Reader.init(src);
        var res = RendererMainThreadTaskExecutionReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                RendererMainThreadTaskExecutionWire.TASK_TYPE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._task_type = @enumFromInt(result.value);
                },
                RendererMainThreadTaskExecutionWire.FRAME_VISIBLE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._frame_visible = result.value;
                },
                RendererMainThreadTaskExecutionWire.PAGE_VISIBLE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._page_visible = result.value;
                },
                RendererMainThreadTaskExecutionWire.FRAME_TYPE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._frame_type = @enumFromInt(result.value);
                },
                RendererMainThreadTaskExecutionWire.IS_AD_FRAME_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_ad_frame = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getTaskType(self: *const RendererMainThreadTaskExecutionReader) RendererMainThreadTaskExecution.TaskType {
        return self._task_type;
    }
    pub inline fn getFrameVisible(self: *const RendererMainThreadTaskExecutionReader) bool {
        return self._frame_visible;
    }
    pub inline fn getPageVisible(self: *const RendererMainThreadTaskExecutionReader) bool {
        return self._page_visible;
    }
    pub inline fn getFrameType(self: *const RendererMainThreadTaskExecutionReader) RendererMainThreadTaskExecution.FrameType {
        return self._frame_type;
    }
    pub inline fn getIsAdFrame(self: *const RendererMainThreadTaskExecutionReader) bool {
        return self._is_ad_frame;
    }
};
const EventLatencyWire = struct {
    const EVENT_TYPE_WIRE: gremlin.ProtoWireNumber = 1;
    const HAS_HIGH_LATENCY_WIRE: gremlin.ProtoWireNumber = 2;
    const HIGH_LATENCY_STAGE_WIRE: gremlin.ProtoWireNumber = 3;
    const EVENT_LATENCY_ID_WIRE: gremlin.ProtoWireNumber = 4;
    const IS_JANKY_SCROLLED_FRAME_WIRE: gremlin.ProtoWireNumber = 5;
    const VSYNC_INTERVAL_MS_WIRE: gremlin.ProtoWireNumber = 6;
    const SURFACE_FRAME_TRACE_ID_WIRE: gremlin.ProtoWireNumber = 7;
    const DISPLAY_TRACE_ID_WIRE: gremlin.ProtoWireNumber = 8;
    const IS_JANKY_SCROLLED_FRAME_V3_WIRE: gremlin.ProtoWireNumber = 9;
    const SCROLL_JANK_V4_WIRE: gremlin.ProtoWireNumber = 10;
};
pub const EventLatency = struct {
    // nested enums
    pub const EventType = enum(i32) {
        EVENT_TYPE_UNSPECIFIED = 0,
        MOUSE_PRESSED = 1,
        MOUSE_RELEASED = 2,
        MOUSE_WHEEL = 3,
        KEY_PRESSED = 4,
        KEY_RELEASED = 5,
        TOUCH_PRESSED = 6,
        TOUCH_RELEASED = 7,
        TOUCH_MOVED = 8,
        GESTURE_SCROLL_BEGIN = 9,
        GESTURE_SCROLL_UPDATE = 10,
        GESTURE_SCROLL_END = 11,
        GESTURE_DOUBLE_TAP = 12,
        GESTURE_LONG_PRESS = 13,
        GESTURE_LONG_TAP = 14,
        GESTURE_SHOW_PRESS = 15,
        GESTURE_TAP = 16,
        GESTURE_TAP_CANCEL = 17,
        GESTURE_TAP_DOWN = 18,
        GESTURE_TAP_UNCONFIRMED = 19,
        GESTURE_TWO_FINGER_TAP = 20,
        FIRST_GESTURE_SCROLL_UPDATE = 21,
        MOUSE_DRAGGED = 22,
        GESTURE_PINCH_BEGIN = 23,
        GESTURE_PINCH_END = 24,
        GESTURE_PINCH_UPDATE = 25,
        INERTIAL_GESTURE_SCROLL_UPDATE = 26,
        MOUSE_MOVED_EVENT = 27,
        INERTIAL_GESTURE_SCROLL_END = 28,
    };
    // nested structs
    const ScrollJankV4ResultWire = struct {
        const IS_JANKY_WIRE: gremlin.ProtoWireNumber = 1;
        const MISSED_VSYNCS_PER_JANK_REASON_WIRE: gremlin.ProtoWireNumber = 2;
        const ABS_TOTAL_RAW_DELTA_PIXELS_WIRE: gremlin.ProtoWireNumber = 3;
        const MAX_ABS_INERTIAL_RAW_DELTA_PIXELS_WIRE: gremlin.ProtoWireNumber = 4;
        const VSYNCS_SINCE_PREVIOUS_FRAME_WIRE: gremlin.ProtoWireNumber = 5;
        const RUNNING_DELIVERY_CUTOFF_US_WIRE: gremlin.ProtoWireNumber = 6;
        const ADJUSTED_DELIVERY_CUTOFF_US_WIRE: gremlin.ProtoWireNumber = 7;
        const CURRENT_DELIVERY_CUTOFF_US_WIRE: gremlin.ProtoWireNumber = 8;
        const IS_DAMAGING_FRAME_WIRE: gremlin.ProtoWireNumber = 9;
    };
    pub const ScrollJankV4Result = struct {
        // nested enums
        pub const JankReason = enum(i32) {
            JANK_REASON_UNSPECIFIED = 0,
            MISSED_VSYNC_DUE_TO_DECELERATING_INPUT_FRAME_DELIVERY = 1,
            MISSED_VSYNC_DURING_FAST_SCROLL = 2,
            MISSED_VSYNC_AT_START_OF_FLING = 3,
            MISSED_VSYNC_DURING_FLING = 4,
        };
        // nested structs
        const MissedVsyncsForJankReasonWire = struct {
            const JANK_REASON_WIRE: gremlin.ProtoWireNumber = 1;
            const MISSED_VSYNCS_WIRE: gremlin.ProtoWireNumber = 2;
        };
        pub const MissedVsyncsForJankReason = struct {
            // fields
            jank_reason: EventLatency.ScrollJankV4Result.JankReason = @enumFromInt(0),
            missed_vsyncs: i32 = 0,
            pub fn calcProtobufSize(self: *const EventLatency.ScrollJankV4Result.MissedVsyncsForJankReason) usize {
                var res: usize = 0;
                if (@intFromEnum(self.jank_reason) != 0) {
                    res += gremlin.sizes.sizeWireNumber(EventLatency.ScrollJankV4Result.MissedVsyncsForJankReasonWire.JANK_REASON_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.jank_reason));
                }
                if (self.missed_vsyncs != 0) {
                    res += gremlin.sizes.sizeWireNumber(EventLatency.ScrollJankV4Result.MissedVsyncsForJankReasonWire.MISSED_VSYNCS_WIRE) + gremlin.sizes.sizeI32(self.missed_vsyncs);
                }
                return res;
            }
            pub fn encode(self: *const EventLatency.ScrollJankV4Result.MissedVsyncsForJankReason, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const EventLatency.ScrollJankV4Result.MissedVsyncsForJankReason, target: *gremlin.Writer) void {
                if (@intFromEnum(self.jank_reason) != 0) {
                    target.appendInt32(EventLatency.ScrollJankV4Result.MissedVsyncsForJankReasonWire.JANK_REASON_WIRE, @intFromEnum(self.jank_reason));
                }
                if (self.missed_vsyncs != 0) {
                    target.appendInt32(EventLatency.ScrollJankV4Result.MissedVsyncsForJankReasonWire.MISSED_VSYNCS_WIRE, self.missed_vsyncs);
                }
            }
        };
        pub const MissedVsyncsForJankReasonReader = struct {
            buf: gremlin.Reader,
            _jank_reason: EventLatency.ScrollJankV4Result.JankReason = @enumFromInt(0),
            _missed_vsyncs: i32 = 0,
            pub fn init(src: []const u8) gremlin.Error!EventLatency.ScrollJankV4Result.MissedVsyncsForJankReasonReader {
                const buf = gremlin.Reader.init(src);
                var res = EventLatency.ScrollJankV4Result.MissedVsyncsForJankReasonReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        EventLatency.ScrollJankV4Result.MissedVsyncsForJankReasonWire.JANK_REASON_WIRE => {
                            const result = try buf.readInt32(offset);
                            offset += result.size;
                            res._jank_reason = @enumFromInt(result.value);
                        },
                        EventLatency.ScrollJankV4Result.MissedVsyncsForJankReasonWire.MISSED_VSYNCS_WIRE => {
                            const result = try buf.readInt32(offset);
                            offset += result.size;
                            res._missed_vsyncs = result.value;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub inline fn getJankReason(self: *const EventLatency.ScrollJankV4Result.MissedVsyncsForJankReasonReader) EventLatency.ScrollJankV4Result.JankReason {
                return self._jank_reason;
            }
            pub inline fn getMissedVsyncs(self: *const EventLatency.ScrollJankV4Result.MissedVsyncsForJankReasonReader) i32 {
                return self._missed_vsyncs;
            }
        };
        // fields
        is_janky: bool = false,
        missed_vsyncs_per_jank_reason: ?[]const ?EventLatency.ScrollJankV4Result.MissedVsyncsForJankReason = null,
        abs_total_raw_delta_pixels: f32 = 0.0,
        max_abs_inertial_raw_delta_pixels: f32 = 0.0,
        vsyncs_since_previous_frame: i32 = 0,
        running_delivery_cutoff_us: i64 = 0,
        adjusted_delivery_cutoff_us: i64 = 0,
        current_delivery_cutoff_us: i64 = 0,
        is_damaging_frame: bool = false,
        pub fn calcProtobufSize(self: *const EventLatency.ScrollJankV4Result) usize {
            var res: usize = 0;
            if (self.is_janky != false) {
                res += gremlin.sizes.sizeWireNumber(EventLatency.ScrollJankV4ResultWire.IS_JANKY_WIRE) + gremlin.sizes.sizeBool(self.is_janky);
            }
            if (self.missed_vsyncs_per_jank_reason) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(EventLatency.ScrollJankV4ResultWire.MISSED_VSYNCS_PER_JANK_REASON_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.abs_total_raw_delta_pixels != 0.0) {
                res += gremlin.sizes.sizeWireNumber(EventLatency.ScrollJankV4ResultWire.ABS_TOTAL_RAW_DELTA_PIXELS_WIRE) + gremlin.sizes.sizeFloat(self.abs_total_raw_delta_pixels);
            }
            if (self.max_abs_inertial_raw_delta_pixels != 0.0) {
                res += gremlin.sizes.sizeWireNumber(EventLatency.ScrollJankV4ResultWire.MAX_ABS_INERTIAL_RAW_DELTA_PIXELS_WIRE) + gremlin.sizes.sizeFloat(self.max_abs_inertial_raw_delta_pixels);
            }
            if (self.vsyncs_since_previous_frame != 0) {
                res += gremlin.sizes.sizeWireNumber(EventLatency.ScrollJankV4ResultWire.VSYNCS_SINCE_PREVIOUS_FRAME_WIRE) + gremlin.sizes.sizeI32(self.vsyncs_since_previous_frame);
            }
            if (self.running_delivery_cutoff_us != 0) {
                res += gremlin.sizes.sizeWireNumber(EventLatency.ScrollJankV4ResultWire.RUNNING_DELIVERY_CUTOFF_US_WIRE) + gremlin.sizes.sizeI64(self.running_delivery_cutoff_us);
            }
            if (self.adjusted_delivery_cutoff_us != 0) {
                res += gremlin.sizes.sizeWireNumber(EventLatency.ScrollJankV4ResultWire.ADJUSTED_DELIVERY_CUTOFF_US_WIRE) + gremlin.sizes.sizeI64(self.adjusted_delivery_cutoff_us);
            }
            if (self.current_delivery_cutoff_us != 0) {
                res += gremlin.sizes.sizeWireNumber(EventLatency.ScrollJankV4ResultWire.CURRENT_DELIVERY_CUTOFF_US_WIRE) + gremlin.sizes.sizeI64(self.current_delivery_cutoff_us);
            }
            if (self.is_damaging_frame != false) {
                res += gremlin.sizes.sizeWireNumber(EventLatency.ScrollJankV4ResultWire.IS_DAMAGING_FRAME_WIRE) + gremlin.sizes.sizeBool(self.is_damaging_frame);
            }
            return res;
        }
        pub fn encode(self: *const EventLatency.ScrollJankV4Result, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const EventLatency.ScrollJankV4Result, target: *gremlin.Writer) void {
            if (self.is_janky != false) {
                target.appendBool(EventLatency.ScrollJankV4ResultWire.IS_JANKY_WIRE, self.is_janky);
            }
            if (self.missed_vsyncs_per_jank_reason) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(EventLatency.ScrollJankV4ResultWire.MISSED_VSYNCS_PER_JANK_REASON_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(EventLatency.ScrollJankV4ResultWire.MISSED_VSYNCS_PER_JANK_REASON_WIRE, 0);
                    }
                }
            }
            if (self.abs_total_raw_delta_pixels != 0.0) {
                target.appendFloat32(EventLatency.ScrollJankV4ResultWire.ABS_TOTAL_RAW_DELTA_PIXELS_WIRE, self.abs_total_raw_delta_pixels);
            }
            if (self.max_abs_inertial_raw_delta_pixels != 0.0) {
                target.appendFloat32(EventLatency.ScrollJankV4ResultWire.MAX_ABS_INERTIAL_RAW_DELTA_PIXELS_WIRE, self.max_abs_inertial_raw_delta_pixels);
            }
            if (self.vsyncs_since_previous_frame != 0) {
                target.appendInt32(EventLatency.ScrollJankV4ResultWire.VSYNCS_SINCE_PREVIOUS_FRAME_WIRE, self.vsyncs_since_previous_frame);
            }
            if (self.running_delivery_cutoff_us != 0) {
                target.appendInt64(EventLatency.ScrollJankV4ResultWire.RUNNING_DELIVERY_CUTOFF_US_WIRE, self.running_delivery_cutoff_us);
            }
            if (self.adjusted_delivery_cutoff_us != 0) {
                target.appendInt64(EventLatency.ScrollJankV4ResultWire.ADJUSTED_DELIVERY_CUTOFF_US_WIRE, self.adjusted_delivery_cutoff_us);
            }
            if (self.current_delivery_cutoff_us != 0) {
                target.appendInt64(EventLatency.ScrollJankV4ResultWire.CURRENT_DELIVERY_CUTOFF_US_WIRE, self.current_delivery_cutoff_us);
            }
            if (self.is_damaging_frame != false) {
                target.appendBool(EventLatency.ScrollJankV4ResultWire.IS_DAMAGING_FRAME_WIRE, self.is_damaging_frame);
            }
        }
    };
    pub const ScrollJankV4ResultReader = struct {
        buf: gremlin.Reader,
        _is_janky: bool = false,
        _missed_vsyncs_per_jank_reason_offset: ?usize = null,
        _missed_vsyncs_per_jank_reason_last_offset: ?usize = null,
        _missed_vsyncs_per_jank_reason_cnt: usize = 0,
        _abs_total_raw_delta_pixels: f32 = 0.0,
        _max_abs_inertial_raw_delta_pixels: f32 = 0.0,
        _vsyncs_since_previous_frame: i32 = 0,
        _running_delivery_cutoff_us: i64 = 0,
        _adjusted_delivery_cutoff_us: i64 = 0,
        _current_delivery_cutoff_us: i64 = 0,
        _is_damaging_frame: bool = false,
        pub fn init(src: []const u8) gremlin.Error!EventLatency.ScrollJankV4ResultReader {
            const buf = gremlin.Reader.init(src);
            var res = EventLatency.ScrollJankV4ResultReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    EventLatency.ScrollJankV4ResultWire.IS_JANKY_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._is_janky = result.value;
                    },
                    EventLatency.ScrollJankV4ResultWire.MISSED_VSYNCS_PER_JANK_REASON_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._missed_vsyncs_per_jank_reason_offset == null) {
                            res._missed_vsyncs_per_jank_reason_offset = offset - result.size;
                        }
                        res._missed_vsyncs_per_jank_reason_last_offset = offset;
                        res._missed_vsyncs_per_jank_reason_cnt += 1;
                    },
                    EventLatency.ScrollJankV4ResultWire.ABS_TOTAL_RAW_DELTA_PIXELS_WIRE => {
                        const result = try buf.readFloat32(offset);
                        offset += result.size;
                        res._abs_total_raw_delta_pixels = result.value;
                    },
                    EventLatency.ScrollJankV4ResultWire.MAX_ABS_INERTIAL_RAW_DELTA_PIXELS_WIRE => {
                        const result = try buf.readFloat32(offset);
                        offset += result.size;
                        res._max_abs_inertial_raw_delta_pixels = result.value;
                    },
                    EventLatency.ScrollJankV4ResultWire.VSYNCS_SINCE_PREVIOUS_FRAME_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._vsyncs_since_previous_frame = result.value;
                    },
                    EventLatency.ScrollJankV4ResultWire.RUNNING_DELIVERY_CUTOFF_US_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._running_delivery_cutoff_us = result.value;
                    },
                    EventLatency.ScrollJankV4ResultWire.ADJUSTED_DELIVERY_CUTOFF_US_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._adjusted_delivery_cutoff_us = result.value;
                    },
                    EventLatency.ScrollJankV4ResultWire.CURRENT_DELIVERY_CUTOFF_US_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._current_delivery_cutoff_us = result.value;
                    },
                    EventLatency.ScrollJankV4ResultWire.IS_DAMAGING_FRAME_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._is_damaging_frame = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getIsJanky(self: *const EventLatency.ScrollJankV4ResultReader) bool {
            return self._is_janky;
        }
        pub fn missedVsyncsPerJankReasonCount(self: *const EventLatency.ScrollJankV4ResultReader) usize {
            return self._missed_vsyncs_per_jank_reason_cnt;
        }
        pub fn missedVsyncsPerJankReasonNext(self: *EventLatency.ScrollJankV4ResultReader) ?EventLatency.ScrollJankV4Result.MissedVsyncsForJankReasonReader {
            if (self._missed_vsyncs_per_jank_reason_offset == null) return null;
            const current_offset = self._missed_vsyncs_per_jank_reason_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = EventLatency.ScrollJankV4Result.MissedVsyncsForJankReasonReader.init(result.value) catch return null;
            if (self._missed_vsyncs_per_jank_reason_last_offset != null and current_offset >= self._missed_vsyncs_per_jank_reason_last_offset.?) {
                self._missed_vsyncs_per_jank_reason_offset = null;
                return msg;
            }
            if (self._missed_vsyncs_per_jank_reason_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._missed_vsyncs_per_jank_reason_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == EventLatency.ScrollJankV4ResultWire.MISSED_VSYNCS_PER_JANK_REASON_WIRE) {
                    self._missed_vsyncs_per_jank_reason_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._missed_vsyncs_per_jank_reason_offset = null;
            return msg;
        }
        pub inline fn getAbsTotalRawDeltaPixels(self: *const EventLatency.ScrollJankV4ResultReader) f32 {
            return self._abs_total_raw_delta_pixels;
        }
        pub inline fn getMaxAbsInertialRawDeltaPixels(self: *const EventLatency.ScrollJankV4ResultReader) f32 {
            return self._max_abs_inertial_raw_delta_pixels;
        }
        pub inline fn getVsyncsSincePreviousFrame(self: *const EventLatency.ScrollJankV4ResultReader) i32 {
            return self._vsyncs_since_previous_frame;
        }
        pub inline fn getRunningDeliveryCutoffUs(self: *const EventLatency.ScrollJankV4ResultReader) i64 {
            return self._running_delivery_cutoff_us;
        }
        pub inline fn getAdjustedDeliveryCutoffUs(self: *const EventLatency.ScrollJankV4ResultReader) i64 {
            return self._adjusted_delivery_cutoff_us;
        }
        pub inline fn getCurrentDeliveryCutoffUs(self: *const EventLatency.ScrollJankV4ResultReader) i64 {
            return self._current_delivery_cutoff_us;
        }
        pub inline fn getIsDamagingFrame(self: *const EventLatency.ScrollJankV4ResultReader) bool {
            return self._is_damaging_frame;
        }
    };
    // fields
    event_type: EventLatency.EventType = @enumFromInt(0),
    has_high_latency: bool = false,
    high_latency_stage: ?[]const ?[]const u8 = null,
    event_latency_id: i64 = 0,
    is_janky_scrolled_frame: bool = false,
    vsync_interval_ms: f64 = 0.0,
    surface_frame_trace_id: i64 = 0,
    display_trace_id: i64 = 0,
    is_janky_scrolled_frame_v3: bool = false,
    scroll_jank_v4: ?EventLatency.ScrollJankV4Result = null,
    pub fn calcProtobufSize(self: *const EventLatency) usize {
        var res: usize = 0;
        if (@intFromEnum(self.event_type) != 0) {
            res += gremlin.sizes.sizeWireNumber(EventLatencyWire.EVENT_TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.event_type));
        }
        if (self.has_high_latency != false) {
            res += gremlin.sizes.sizeWireNumber(EventLatencyWire.HAS_HIGH_LATENCY_WIRE) + gremlin.sizes.sizeBool(self.has_high_latency);
        }
        if (self.high_latency_stage) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(EventLatencyWire.HIGH_LATENCY_STAGE_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.event_latency_id != 0) {
            res += gremlin.sizes.sizeWireNumber(EventLatencyWire.EVENT_LATENCY_ID_WIRE) + gremlin.sizes.sizeI64(self.event_latency_id);
        }
        if (self.is_janky_scrolled_frame != false) {
            res += gremlin.sizes.sizeWireNumber(EventLatencyWire.IS_JANKY_SCROLLED_FRAME_WIRE) + gremlin.sizes.sizeBool(self.is_janky_scrolled_frame);
        }
        if (self.vsync_interval_ms != 0.0) {
            res += gremlin.sizes.sizeWireNumber(EventLatencyWire.VSYNC_INTERVAL_MS_WIRE) + gremlin.sizes.sizeDouble(self.vsync_interval_ms);
        }
        if (self.surface_frame_trace_id != 0) {
            res += gremlin.sizes.sizeWireNumber(EventLatencyWire.SURFACE_FRAME_TRACE_ID_WIRE) + gremlin.sizes.sizeI64(self.surface_frame_trace_id);
        }
        if (self.display_trace_id != 0) {
            res += gremlin.sizes.sizeWireNumber(EventLatencyWire.DISPLAY_TRACE_ID_WIRE) + gremlin.sizes.sizeI64(self.display_trace_id);
        }
        if (self.is_janky_scrolled_frame_v3 != false) {
            res += gremlin.sizes.sizeWireNumber(EventLatencyWire.IS_JANKY_SCROLLED_FRAME_V3_WIRE) + gremlin.sizes.sizeBool(self.is_janky_scrolled_frame_v3);
        }
        if (self.scroll_jank_v4) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(EventLatencyWire.SCROLL_JANK_V4_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const EventLatency, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const EventLatency, target: *gremlin.Writer) void {
        if (@intFromEnum(self.event_type) != 0) {
            target.appendInt32(EventLatencyWire.EVENT_TYPE_WIRE, @intFromEnum(self.event_type));
        }
        if (self.has_high_latency != false) {
            target.appendBool(EventLatencyWire.HAS_HIGH_LATENCY_WIRE, self.has_high_latency);
        }
        if (self.high_latency_stage) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(EventLatencyWire.HIGH_LATENCY_STAGE_WIRE, v);
                } else {
                    target.appendBytesTag(EventLatencyWire.HIGH_LATENCY_STAGE_WIRE, 0);
                }
            }
        }
        if (self.event_latency_id != 0) {
            target.appendInt64(EventLatencyWire.EVENT_LATENCY_ID_WIRE, self.event_latency_id);
        }
        if (self.is_janky_scrolled_frame != false) {
            target.appendBool(EventLatencyWire.IS_JANKY_SCROLLED_FRAME_WIRE, self.is_janky_scrolled_frame);
        }
        if (self.vsync_interval_ms != 0.0) {
            target.appendFloat64(EventLatencyWire.VSYNC_INTERVAL_MS_WIRE, self.vsync_interval_ms);
        }
        if (self.surface_frame_trace_id != 0) {
            target.appendInt64(EventLatencyWire.SURFACE_FRAME_TRACE_ID_WIRE, self.surface_frame_trace_id);
        }
        if (self.display_trace_id != 0) {
            target.appendInt64(EventLatencyWire.DISPLAY_TRACE_ID_WIRE, self.display_trace_id);
        }
        if (self.is_janky_scrolled_frame_v3 != false) {
            target.appendBool(EventLatencyWire.IS_JANKY_SCROLLED_FRAME_V3_WIRE, self.is_janky_scrolled_frame_v3);
        }
        if (self.scroll_jank_v4) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(EventLatencyWire.SCROLL_JANK_V4_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const EventLatencyReader = struct {
    buf: gremlin.Reader,
    _event_type: EventLatency.EventType = @enumFromInt(0),
    _has_high_latency: bool = false,
    _high_latency_stage_offset: ?usize = null,
    _high_latency_stage_last_offset: ?usize = null,
    _high_latency_stage_cnt: usize = 0,
    _event_latency_id: i64 = 0,
    _is_janky_scrolled_frame: bool = false,
    _vsync_interval_ms: f64 = 0.0,
    _surface_frame_trace_id: i64 = 0,
    _display_trace_id: i64 = 0,
    _is_janky_scrolled_frame_v3: bool = false,
    _scroll_jank_v4_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!EventLatencyReader {
        const buf = gremlin.Reader.init(src);
        var res = EventLatencyReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                EventLatencyWire.EVENT_TYPE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._event_type = @enumFromInt(result.value);
                },
                EventLatencyWire.HAS_HIGH_LATENCY_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._has_high_latency = result.value;
                },
                EventLatencyWire.HIGH_LATENCY_STAGE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._high_latency_stage_offset == null) {
                        res._high_latency_stage_offset = offset - result.size;
                    }
                    res._high_latency_stage_last_offset = offset;
                    res._high_latency_stage_cnt += 1;
                },
                EventLatencyWire.EVENT_LATENCY_ID_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._event_latency_id = result.value;
                },
                EventLatencyWire.IS_JANKY_SCROLLED_FRAME_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_janky_scrolled_frame = result.value;
                },
                EventLatencyWire.VSYNC_INTERVAL_MS_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._vsync_interval_ms = result.value;
                },
                EventLatencyWire.SURFACE_FRAME_TRACE_ID_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._surface_frame_trace_id = result.value;
                },
                EventLatencyWire.DISPLAY_TRACE_ID_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._display_trace_id = result.value;
                },
                EventLatencyWire.IS_JANKY_SCROLLED_FRAME_V3_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_janky_scrolled_frame_v3 = result.value;
                },
                EventLatencyWire.SCROLL_JANK_V4_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._scroll_jank_v4_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getEventType(self: *const EventLatencyReader) EventLatency.EventType {
        return self._event_type;
    }
    pub inline fn getHasHighLatency(self: *const EventLatencyReader) bool {
        return self._has_high_latency;
    }
    pub fn highLatencyStageCount(self: *const EventLatencyReader) usize {
        return self._high_latency_stage_cnt;
    }
    pub fn highLatencyStageNext(self: *EventLatencyReader) ?[]const u8 {
        if (self._high_latency_stage_offset == null) return null;
        const current_offset = self._high_latency_stage_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._high_latency_stage_last_offset != null and current_offset >= self._high_latency_stage_last_offset.?) {
            self._high_latency_stage_offset = null;
            return result.value;
        }
        if (self._high_latency_stage_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._high_latency_stage_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == EventLatencyWire.HIGH_LATENCY_STAGE_WIRE) {
                self._high_latency_stage_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._high_latency_stage_offset = null;
        return result.value;
    }
    pub inline fn getEventLatencyId(self: *const EventLatencyReader) i64 {
        return self._event_latency_id;
    }
    pub inline fn getIsJankyScrolledFrame(self: *const EventLatencyReader) bool {
        return self._is_janky_scrolled_frame;
    }
    pub inline fn getVsyncIntervalMs(self: *const EventLatencyReader) f64 {
        return self._vsync_interval_ms;
    }
    pub inline fn getSurfaceFrameTraceId(self: *const EventLatencyReader) i64 {
        return self._surface_frame_trace_id;
    }
    pub inline fn getDisplayTraceId(self: *const EventLatencyReader) i64 {
        return self._display_trace_id;
    }
    pub inline fn getIsJankyScrolledFrameV3(self: *const EventLatencyReader) bool {
        return self._is_janky_scrolled_frame_v3;
    }
    pub fn getScrollJankV4(self: *const EventLatencyReader) gremlin.Error!EventLatency.ScrollJankV4ResultReader {
        if (self._scroll_jank_v4_buf) |buf| {
            return try EventLatency.ScrollJankV4ResultReader.init(buf);
        }
        return try EventLatency.ScrollJankV4ResultReader.init(&[_]u8{});
    }
};
const ProcessSingletonWire = struct {
    const REMOTE_PROCESS_INTERACTION_RESULT_WIRE: gremlin.ProtoWireNumber = 1;
    const REMOTE_PROCESS_TERMINATE_REASON_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const ProcessSingleton = struct {
    // nested enums
    pub const RemoteProcessInteractionResult = enum(i32) {
        INTERACTION_RESULT_UNSPECIFIED = 0,
        TERMINATE_FAILED = 1,
        REMOTE_PROCESS_NOT_FOUND = 2,
        TERMINATE_WAIT_TIMEOUT = 3,
        RUNNING_PROCESS_NOTIFY_ERROR = 4,
        TERMINATE_NOT_ENOUGH_PERMISSIONS = 5,
        REMOTE_PROCESS_SHUTTING_DOWN = 6,
        PROFILE_UNLOCKED = 7,
        PROFILE_UNLOCKED_BEFORE_KILL = 8,
        SAME_BROWSER_INSTANCE = 9,
        SAME_BROWSER_INSTANCE_BEFORE_KILL = 10,
        FAILED_TO_EXTRACT_PID = 11,
        INVALID_LOCK_FILE = 12,
        ORPHANED_LOCK_FILE = 13,
        USER_REFUSED_TERMINATION = 14,
        TERMINATE_SUCCEEDED = 100,
    };
    pub const RemoteHungProcessTerminateReason = enum(i32) {
        TERMINATE_REASON_UNSPECIFIED = 0,
        USER_ACCEPTED_TERMINATION = 1,
        NO_VISIBLE_WINDOW_FOUND = 2,
        NOTIFY_ATTEMPTS_EXCEEDED = 3,
        SOCKET_WRITE_FAILED = 4,
        SOCKET_READ_FAILED = 5,
    };
    // fields
    remote_process_interaction_result: ProcessSingleton.RemoteProcessInteractionResult = @enumFromInt(0),
    remote_process_terminate_reason: ProcessSingleton.RemoteHungProcessTerminateReason = @enumFromInt(0),
    pub fn calcProtobufSize(self: *const ProcessSingleton) usize {
        var res: usize = 0;
        if (@intFromEnum(self.remote_process_interaction_result) != 0) {
            res += gremlin.sizes.sizeWireNumber(ProcessSingletonWire.REMOTE_PROCESS_INTERACTION_RESULT_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.remote_process_interaction_result));
        }
        if (@intFromEnum(self.remote_process_terminate_reason) != 0) {
            res += gremlin.sizes.sizeWireNumber(ProcessSingletonWire.REMOTE_PROCESS_TERMINATE_REASON_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.remote_process_terminate_reason));
        }
        return res;
    }
    pub fn encode(self: *const ProcessSingleton, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ProcessSingleton, target: *gremlin.Writer) void {
        if (@intFromEnum(self.remote_process_interaction_result) != 0) {
            target.appendInt32(ProcessSingletonWire.REMOTE_PROCESS_INTERACTION_RESULT_WIRE, @intFromEnum(self.remote_process_interaction_result));
        }
        if (@intFromEnum(self.remote_process_terminate_reason) != 0) {
            target.appendInt32(ProcessSingletonWire.REMOTE_PROCESS_TERMINATE_REASON_WIRE, @intFromEnum(self.remote_process_terminate_reason));
        }
    }
};
pub const ProcessSingletonReader = struct {
    buf: gremlin.Reader,
    _remote_process_interaction_result: ProcessSingleton.RemoteProcessInteractionResult = @enumFromInt(0),
    _remote_process_terminate_reason: ProcessSingleton.RemoteHungProcessTerminateReason = @enumFromInt(0),
    pub fn init(src: []const u8) gremlin.Error!ProcessSingletonReader {
        const buf = gremlin.Reader.init(src);
        var res = ProcessSingletonReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ProcessSingletonWire.REMOTE_PROCESS_INTERACTION_RESULT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._remote_process_interaction_result = @enumFromInt(result.value);
                },
                ProcessSingletonWire.REMOTE_PROCESS_TERMINATE_REASON_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._remote_process_terminate_reason = @enumFromInt(result.value);
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getRemoteProcessInteractionResult(self: *const ProcessSingletonReader) ProcessSingleton.RemoteProcessInteractionResult {
        return self._remote_process_interaction_result;
    }
    pub inline fn getRemoteProcessTerminateReason(self: *const ProcessSingletonReader) ProcessSingleton.RemoteHungProcessTerminateReason {
        return self._remote_process_terminate_reason;
    }
};
const NavigationHandleWire = struct {
    const NAVIGATION_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const HAS_COMMITTED_WIRE: gremlin.ProtoWireNumber = 2;
    const IS_ERROR_PAGE_WIRE: gremlin.ProtoWireNumber = 3;
    const FRAME_TREE_NODE_WIRE: gremlin.ProtoWireNumber = 4;
    const RENDER_FRAME_HOST_WIRE: gremlin.ProtoWireNumber = 5;
    const DEBUG_ANNOTATIONS_WIRE: gremlin.ProtoWireNumber = 99;
};
pub const NavigationHandle = struct {
    // fields
    navigation_id: i64 = 0,
    has_committed: bool = false,
    is_error_page: bool = false,
    frame_tree_node: ?FrameTreeNodeInfo = null,
    render_frame_host: ?RenderFrameHost = null,
    debug_annotations: ?[]const ?debug_annotation.DebugAnnotation = null,
    pub fn calcProtobufSize(self: *const NavigationHandle) usize {
        var res: usize = 0;
        if (self.navigation_id != 0) {
            res += gremlin.sizes.sizeWireNumber(NavigationHandleWire.NAVIGATION_ID_WIRE) + gremlin.sizes.sizeI64(self.navigation_id);
        }
        if (self.has_committed != false) {
            res += gremlin.sizes.sizeWireNumber(NavigationHandleWire.HAS_COMMITTED_WIRE) + gremlin.sizes.sizeBool(self.has_committed);
        }
        if (self.is_error_page != false) {
            res += gremlin.sizes.sizeWireNumber(NavigationHandleWire.IS_ERROR_PAGE_WIRE) + gremlin.sizes.sizeBool(self.is_error_page);
        }
        if (self.frame_tree_node) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(NavigationHandleWire.FRAME_TREE_NODE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.render_frame_host) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(NavigationHandleWire.RENDER_FRAME_HOST_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.debug_annotations) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(NavigationHandleWire.DEBUG_ANNOTATIONS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const NavigationHandle, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const NavigationHandle, target: *gremlin.Writer) void {
        if (self.navigation_id != 0) {
            target.appendInt64(NavigationHandleWire.NAVIGATION_ID_WIRE, self.navigation_id);
        }
        if (self.has_committed != false) {
            target.appendBool(NavigationHandleWire.HAS_COMMITTED_WIRE, self.has_committed);
        }
        if (self.is_error_page != false) {
            target.appendBool(NavigationHandleWire.IS_ERROR_PAGE_WIRE, self.is_error_page);
        }
        if (self.frame_tree_node) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(NavigationHandleWire.FRAME_TREE_NODE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.render_frame_host) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(NavigationHandleWire.RENDER_FRAME_HOST_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.debug_annotations) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(NavigationHandleWire.DEBUG_ANNOTATIONS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(NavigationHandleWire.DEBUG_ANNOTATIONS_WIRE, 0);
                }
            }
        }
    }
};
pub const NavigationHandleReader = struct {
    buf: gremlin.Reader,
    _navigation_id: i64 = 0,
    _has_committed: bool = false,
    _is_error_page: bool = false,
    _frame_tree_node_buf: ?[]const u8 = null,
    _render_frame_host_buf: ?[]const u8 = null,
    _debug_annotations_offset: ?usize = null,
    _debug_annotations_last_offset: ?usize = null,
    _debug_annotations_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!NavigationHandleReader {
        const buf = gremlin.Reader.init(src);
        var res = NavigationHandleReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                NavigationHandleWire.NAVIGATION_ID_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._navigation_id = result.value;
                },
                NavigationHandleWire.HAS_COMMITTED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._has_committed = result.value;
                },
                NavigationHandleWire.IS_ERROR_PAGE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_error_page = result.value;
                },
                NavigationHandleWire.FRAME_TREE_NODE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._frame_tree_node_buf = result.value;
                },
                NavigationHandleWire.RENDER_FRAME_HOST_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._render_frame_host_buf = result.value;
                },
                NavigationHandleWire.DEBUG_ANNOTATIONS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._debug_annotations_offset == null) {
                        res._debug_annotations_offset = offset - result.size;
                    }
                    res._debug_annotations_last_offset = offset;
                    res._debug_annotations_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getNavigationId(self: *const NavigationHandleReader) i64 {
        return self._navigation_id;
    }
    pub inline fn getHasCommitted(self: *const NavigationHandleReader) bool {
        return self._has_committed;
    }
    pub inline fn getIsErrorPage(self: *const NavigationHandleReader) bool {
        return self._is_error_page;
    }
    pub fn getFrameTreeNode(self: *const NavigationHandleReader) gremlin.Error!FrameTreeNodeInfoReader {
        if (self._frame_tree_node_buf) |buf| {
            return try FrameTreeNodeInfoReader.init(buf);
        }
        return try FrameTreeNodeInfoReader.init(&[_]u8{});
    }
    pub fn getRenderFrameHost(self: *const NavigationHandleReader) gremlin.Error!RenderFrameHostReader {
        if (self._render_frame_host_buf) |buf| {
            return try RenderFrameHostReader.init(buf);
        }
        return try RenderFrameHostReader.init(&[_]u8{});
    }
    pub fn debugAnnotationsCount(self: *const NavigationHandleReader) usize {
        return self._debug_annotations_cnt;
    }
    pub fn debugAnnotationsNext(self: *NavigationHandleReader) ?debug_annotation.DebugAnnotationReader {
        if (self._debug_annotations_offset == null) return null;
        const current_offset = self._debug_annotations_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = debug_annotation.DebugAnnotationReader.init(result.value) catch return null;
        if (self._debug_annotations_last_offset != null and current_offset >= self._debug_annotations_last_offset.?) {
            self._debug_annotations_offset = null;
            return msg;
        }
        if (self._debug_annotations_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._debug_annotations_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == NavigationHandleWire.DEBUG_ANNOTATIONS_WIRE) {
                self._debug_annotations_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._debug_annotations_offset = null;
        return msg;
    }
};
const AndroidIPCWire = struct {
    const NAME_WIRE: gremlin.ProtoWireNumber = 1;
    const DUR_MS_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const AndroidIPC = struct {
    // fields
    name: ?[]const u8 = null,
    dur_ms: i64 = 0,
    pub fn calcProtobufSize(self: *const AndroidIPC) usize {
        var res: usize = 0;
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidIPCWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.dur_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidIPCWire.DUR_MS_WIRE) + gremlin.sizes.sizeI64(self.dur_ms);
        }
        return res;
    }
    pub fn encode(self: *const AndroidIPC, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidIPC, target: *gremlin.Writer) void {
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(AndroidIPCWire.NAME_WIRE, v);
            }
        }
        if (self.dur_ms != 0) {
            target.appendInt64(AndroidIPCWire.DUR_MS_WIRE, self.dur_ms);
        }
    }
};
pub const AndroidIPCReader = struct {
    buf: gremlin.Reader,
    _name: ?[]const u8 = null,
    _dur_ms: i64 = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidIPCReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidIPCReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidIPCWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                AndroidIPCWire.DUR_MS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._dur_ms = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getName(self: *const AndroidIPCReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub inline fn getDurMs(self: *const AndroidIPCReader) i64 {
        return self._dur_ms;
    }
};
const SequenceManagerTaskWire = struct {
    const PRIORITY_WIRE: gremlin.ProtoWireNumber = 1;
    const QUEUE_NAME_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const SequenceManagerTask = struct {
    // nested enums
    pub const Priority = enum(i32) {
        UNKNOWN = 0,
        CONTROL_PRIORITY = 1,
        HIGHEST_PRIORITY = 2,
        VERY_HIGH_PRIORITY = 3,
        HIGH_PRIORITY = 4,
        NORMAL_PRIORITY = 5,
        LOW_PRIORITY = 6,
        BEST_EFFORT_PRIORITY = 7,
        HIGH_PRIORITY_CONTINUATION = 8,
        NORMAL_PRIORITY_CONTINUATION = 9,
        LOW_PRIORITY_CONTINUATION = 10,
        EXTREMELY_HIGH_PRIORITY = 11,
        MEDIUM_PRIORITY = 12,
        LOWEST_PRIORITY = 13,
        IDLE_PRIORITY = 14,
        THROTTLED_PRIORITY = 15,
    };
    pub const QueueName = enum(i32) {
        UNKNOWN_TQ = 0,
        DEFAULT_TQ = 1,
        TASK_ENVIRONMENT_DEFAULT_TQ = 2,
        TEST2_TQ = 3,
        TEST_TQ = 4,
        CONTROL_TQ = 5,
        SUBTHREAD_CONTROL_TQ = 6,
        SUBTHREAD_DEFAULT_TQ = 7,
        SUBTHREAD_INPUT_TQ = 8,
        UI_BEST_EFFORT_TQ = 9,
        UI_BOOTSTRAP_TQ = 10,
        UI_CONTROL_TQ = 11,
        UI_DEFAULT_TQ = 12,
        UI_NAVIGATION_NETWORK_RESPONSE_TQ = 13,
        UI_RUN_ALL_PENDING_TQ = 14,
        UI_SERVICE_WORKER_STORAGE_CONTROL_RESPONSE_TQ = 15,
        UI_THREAD_TQ = 16,
        UI_USER_BLOCKING_TQ = 17,
        UI_USER_INPUT_TQ = 18,
        UI_USER_VISIBLE_TQ = 19,
        IO_BEST_EFFORT_TQ = 20,
        IO_BOOTSTRAP_TQ = 21,
        IO_CONTROL_TQ = 22,
        IO_DEFAULT_TQ = 23,
        IO_NAVIGATION_NETWORK_RESPONSE_TQ = 24,
        IO_RUN_ALL_PENDING_TQ = 25,
        IO_SERVICE_WORKER_STORAGE_CONTROL_RESPONSE_TQ = 26,
        IO_THREAD_TQ = 27,
        IO_USER_BLOCKING_TQ = 28,
        IO_USER_INPUT_TQ = 29,
        IO_USER_VISIBLE_TQ = 30,
        COMPOSITOR_TQ = 31,
        DETACHED_TQ = 32,
        FRAME_DEFERRABLE_TQ = 33,
        FRAME_LOADING_CONTROL_TQ = 34,
        FRAME_LOADING_TQ = 35,
        FRAME_PAUSABLE_TQ = 36,
        FRAME_THROTTLEABLE_TQ = 37,
        FRAME_UNPAUSABLE_TQ = 38,
        IDLE_TQ = 39,
        INPUT_TQ = 40,
        IPC_TRACKING_FOR_CACHED_PAGES_TQ = 41,
        NON_WAKING_TQ = 42,
        OTHER_TQ = 43,
        V8_TQ = 44,
        WEB_SCHEDULING_TQ = 45,
        WORKER_IDLE_TQ = 46,
        WORKER_PAUSABLE_TQ = 47,
        WORKER_THREAD_INTERNAL_TQ = 48,
        WORKER_THROTTLEABLE_TQ = 49,
        WORKER_UNPAUSABLE_TQ = 50,
        WORKER_WEB_SCHEDULING_TQ = 51,
        UI_USER_BLOCKING_DEFERRABLE_TQ = 52,
        IO_USER_BLOCKING_DEFERRABLE_TQ = 53,
        UI_BEFORE_UNLOAD_BROWSER_RESPONSE_TQ = 54,
        IO_BEFORE_UNLOAD_BROWSER_RESPONSE_TQ = 55,
        V8_USER_VISIBLE_TQ = 56,
        V8_BEST_EFFORT_TQ = 57,
        NETWORK_SERVICE_THREAD_HIGH_TQ = 58,
        NETWORK_SERVICE_THREAD_DEFAULT_TQ = 59,
        UI_STARTUP_TQ = 60,
        IO_STARTUP_TQ = 61,
        NETWORK_SERVICE_THREAD_THROTTLED_TQ = 62,
        NETWORK_SERVICE_THREAD_IDLE_TQ = 63,
        NETWORK_SERVICE_THREAD_LOWEST_TQ = 64,
        NETWORK_SERVICE_THREAD_LOW_TQ = 65,
        NETWORK_SERVICE_THREAD_MEDIUM_TQ = 66,
        NETWORK_SERVICE_THREAD_HIGHEST_TQ = 67,
    };
    // fields
    priority: SequenceManagerTask.Priority = @enumFromInt(0),
    queue_name: SequenceManagerTask.QueueName = @enumFromInt(0),
    pub fn calcProtobufSize(self: *const SequenceManagerTask) usize {
        var res: usize = 0;
        if (@intFromEnum(self.priority) != 0) {
            res += gremlin.sizes.sizeWireNumber(SequenceManagerTaskWire.PRIORITY_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.priority));
        }
        if (@intFromEnum(self.queue_name) != 0) {
            res += gremlin.sizes.sizeWireNumber(SequenceManagerTaskWire.QUEUE_NAME_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.queue_name));
        }
        return res;
    }
    pub fn encode(self: *const SequenceManagerTask, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SequenceManagerTask, target: *gremlin.Writer) void {
        if (@intFromEnum(self.priority) != 0) {
            target.appendInt32(SequenceManagerTaskWire.PRIORITY_WIRE, @intFromEnum(self.priority));
        }
        if (@intFromEnum(self.queue_name) != 0) {
            target.appendInt32(SequenceManagerTaskWire.QUEUE_NAME_WIRE, @intFromEnum(self.queue_name));
        }
    }
};
pub const SequenceManagerTaskReader = struct {
    buf: gremlin.Reader,
    _priority: SequenceManagerTask.Priority = @enumFromInt(0),
    _queue_name: SequenceManagerTask.QueueName = @enumFromInt(0),
    pub fn init(src: []const u8) gremlin.Error!SequenceManagerTaskReader {
        const buf = gremlin.Reader.init(src);
        var res = SequenceManagerTaskReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SequenceManagerTaskWire.PRIORITY_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._priority = @enumFromInt(result.value);
                },
                SequenceManagerTaskWire.QUEUE_NAME_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._queue_name = @enumFromInt(result.value);
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getPriority(self: *const SequenceManagerTaskReader) SequenceManagerTask.Priority {
        return self._priority;
    }
    pub inline fn getQueueName(self: *const SequenceManagerTaskReader) SequenceManagerTask.QueueName {
        return self._queue_name;
    }
};
const AndroidToolbarWire = struct {
    const BLOCK_CAPTURE_REASON_WIRE: gremlin.ProtoWireNumber = 1;
    const ALLOW_CAPTURE_REASON_WIRE: gremlin.ProtoWireNumber = 2;
    const SNAPSHOT_DIFFERENCE_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const AndroidToolbar = struct {
    // nested enums
    pub const BlockCaptureReason = enum(i32) {
        BLOCKED_UNKNOWN = 0,
        BLOCKED_TOOLBAR_OR_RESULT_NULL = 1,
        BLOCKED_VIEW_NOT_DIRTY = 2,
        BLOCKED_SNAPSHOT_SAME = 3,
        BLOCKED_URL_BAR_HAS_FOCUS = 4,
        BLOCKED_URL_BAR_FOCUS_IN_PROGRESS = 5,
        BLOCKED_OPTIONAL_BUTTON_ANIMATION_IN_PROGRESS = 6,
        BLOCKED_STATUS_ICON_ANIMATION_IN_PROGRESS = 7,
        BLOCKED_SCROLL_ABLATION = 8,
        BLOCKED_BROWSER_CONTROLS_LOCKED = 9,
        BLOCKED_TAB_SWITCHER_MODE = 10,
        BLOCKED_COMPOSITOR_IN_MOTION = 11,
        BLOCKED_NTP_Y_TRANSLATION = 12,
        BLOCKED_FULLSCREEN = 13,
        BLOCKED_TABLET_BUTTON_ANIMATION_IN_PROGRESS = 14,
        BLOCKED_LAYOUT_REQUESTED = 15,
    };
    pub const AllowCaptureReason = enum(i32) {
        ALLOWED_UNKNOWN = 0,
        ALLOWED_FORCE_CAPTURE = 1,
        ALLOWED_SNAPSHOT_DIFFERENCE = 2,
    };
    pub const SnapshotDifference = enum(i32) {
        DIFF_NONE = 0,
        DIFF_NULL = 1,
        DIFF_TINT = 2,
        DIFF_TAB_COUNT = 3,
        DIFF_OPTIONAL_BUTTON = 4,
        DIFF_VISUAL_STATE = 5,
        DIFF_SECURITY_ICON = 6,
        DIFF_SHOWING_UPDATE_BADGE = 7,
        DIFF_PAINT_PREVIEW = 8,
        DIFF_PROGRESS = 9,
        DIFF_LOCATION_BAR_WIDTH = 10,
        DIFF_URL_TEXT = 11,
        DIFF_HOME_BUTTON = 12,
        DIFF_TITLE_TEXT = 13,
        DIFF_CCT_ANIMATION = 14,
        DIFF_BOOKMARK_BUTTON = 15,
        DIFF_BACK_BUTTON = 16,
        DIFF_FORWARD_BUTTON = 17,
        DIFF_RELOAD_BUTTON = 18,
    };
    // fields
    block_capture_reason: AndroidToolbar.BlockCaptureReason = @enumFromInt(0),
    allow_capture_reason: AndroidToolbar.AllowCaptureReason = @enumFromInt(0),
    snapshot_difference: AndroidToolbar.SnapshotDifference = @enumFromInt(0),
    pub fn calcProtobufSize(self: *const AndroidToolbar) usize {
        var res: usize = 0;
        if (@intFromEnum(self.block_capture_reason) != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidToolbarWire.BLOCK_CAPTURE_REASON_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.block_capture_reason));
        }
        if (@intFromEnum(self.allow_capture_reason) != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidToolbarWire.ALLOW_CAPTURE_REASON_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.allow_capture_reason));
        }
        if (@intFromEnum(self.snapshot_difference) != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidToolbarWire.SNAPSHOT_DIFFERENCE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.snapshot_difference));
        }
        return res;
    }
    pub fn encode(self: *const AndroidToolbar, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidToolbar, target: *gremlin.Writer) void {
        if (@intFromEnum(self.block_capture_reason) != 0) {
            target.appendInt32(AndroidToolbarWire.BLOCK_CAPTURE_REASON_WIRE, @intFromEnum(self.block_capture_reason));
        }
        if (@intFromEnum(self.allow_capture_reason) != 0) {
            target.appendInt32(AndroidToolbarWire.ALLOW_CAPTURE_REASON_WIRE, @intFromEnum(self.allow_capture_reason));
        }
        if (@intFromEnum(self.snapshot_difference) != 0) {
            target.appendInt32(AndroidToolbarWire.SNAPSHOT_DIFFERENCE_WIRE, @intFromEnum(self.snapshot_difference));
        }
    }
};
pub const AndroidToolbarReader = struct {
    buf: gremlin.Reader,
    _block_capture_reason: AndroidToolbar.BlockCaptureReason = @enumFromInt(0),
    _allow_capture_reason: AndroidToolbar.AllowCaptureReason = @enumFromInt(0),
    _snapshot_difference: AndroidToolbar.SnapshotDifference = @enumFromInt(0),
    pub fn init(src: []const u8) gremlin.Error!AndroidToolbarReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidToolbarReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidToolbarWire.BLOCK_CAPTURE_REASON_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._block_capture_reason = @enumFromInt(result.value);
                },
                AndroidToolbarWire.ALLOW_CAPTURE_REASON_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._allow_capture_reason = @enumFromInt(result.value);
                },
                AndroidToolbarWire.SNAPSHOT_DIFFERENCE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._snapshot_difference = @enumFromInt(result.value);
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getBlockCaptureReason(self: *const AndroidToolbarReader) AndroidToolbar.BlockCaptureReason {
        return self._block_capture_reason;
    }
    pub inline fn getAllowCaptureReason(self: *const AndroidToolbarReader) AndroidToolbar.AllowCaptureReason {
        return self._allow_capture_reason;
    }
    pub inline fn getSnapshotDifference(self: *const AndroidToolbarReader) AndroidToolbar.SnapshotDifference {
        return self._snapshot_difference;
    }
};
const ActiveProcessesWire = struct {
    const PID_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const ActiveProcesses = struct {
    // fields
    pid: ?[]const i32 = null,
    pub fn calcProtobufSize(self: *const ActiveProcesses) usize {
        var res: usize = 0;
        if (self.pid) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(ActiveProcessesWire.PID_WIRE) + gremlin.sizes.sizeI32(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(v);
                }
                res += gremlin.sizes.sizeWireNumber(ActiveProcessesWire.PID_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        return res;
    }
    pub fn encode(self: *const ActiveProcesses, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ActiveProcesses, target: *gremlin.Writer) void {
        if (self.pid) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt32(ActiveProcessesWire.PID_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(v);
                }
                target.appendBytesTag(ActiveProcessesWire.PID_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt32WithoutTag(v);
                }
            }
        }
    }
};
pub const ActiveProcessesReader = struct {
    buf: gremlin.Reader,
    _pid_offset: ?usize = null,
    _pid_last_offset: ?usize = null,
    _pid_packed: bool = false,
    pub fn init(src: []const u8) gremlin.Error!ActiveProcessesReader {
        const buf = gremlin.Reader.init(src);
        var res = ActiveProcessesReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ActiveProcessesWire.PID_WIRE => {
                    if (res._pid_offset == null) {
                        res._pid_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._pid_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._pid_offset = offset + length_result.size;
                        res._pid_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._pid_last_offset.?;
                    } else {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._pid_last_offset = offset;
                    }
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn pidNext(self: *ActiveProcessesReader) gremlin.Error!?i32 {
        if (self._pid_offset == null) return null;
        const current_offset = self._pid_offset.?;
        if (current_offset >= self._pid_last_offset.?) {
            self._pid_offset = null;
            return null;
        }
        if (self._pid_packed) {
            const value_result = try self.buf.readInt32(current_offset);
            self._pid_offset = current_offset + value_result.size;
            if (self._pid_offset.? >= self._pid_last_offset.?) {
                self._pid_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._pid_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == ActiveProcessesWire.PID_WIRE) {
                    self._pid_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._pid_offset = null;
            return value_result.value;
        }
    }
};
const UkmPageLoadTimingUpdateWire = struct {
    const UKM_SOURCE_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const LATEST_URL_WIRE: gremlin.ProtoWireNumber = 2;
    const LATEST_CUMULATIVE_LAYOUT_SHIFT_WIRE: gremlin.ProtoWireNumber = 3;
    const LATEST_LARGEST_CONTENTFUL_PAINT_MS_WIRE: gremlin.ProtoWireNumber = 4;
    const FIRST_CONTENTFUL_PAINT_MS_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const UkmPageLoadTimingUpdate = struct {
    // fields
    ukm_source_id: i64 = 0,
    latest_url: ?[]const u8 = null,
    latest_cumulative_layout_shift: f32 = 0.0,
    latest_largest_contentful_paint_ms: f64 = 0.0,
    first_contentful_paint_ms: f64 = 0.0,
    pub fn calcProtobufSize(self: *const UkmPageLoadTimingUpdate) usize {
        var res: usize = 0;
        if (self.ukm_source_id != 0) {
            res += gremlin.sizes.sizeWireNumber(UkmPageLoadTimingUpdateWire.UKM_SOURCE_ID_WIRE) + gremlin.sizes.sizeI64(self.ukm_source_id);
        }
        if (self.latest_url) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(UkmPageLoadTimingUpdateWire.LATEST_URL_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.latest_cumulative_layout_shift != 0.0) {
            res += gremlin.sizes.sizeWireNumber(UkmPageLoadTimingUpdateWire.LATEST_CUMULATIVE_LAYOUT_SHIFT_WIRE) + gremlin.sizes.sizeFloat(self.latest_cumulative_layout_shift);
        }
        if (self.latest_largest_contentful_paint_ms != 0.0) {
            res += gremlin.sizes.sizeWireNumber(UkmPageLoadTimingUpdateWire.LATEST_LARGEST_CONTENTFUL_PAINT_MS_WIRE) + gremlin.sizes.sizeDouble(self.latest_largest_contentful_paint_ms);
        }
        if (self.first_contentful_paint_ms != 0.0) {
            res += gremlin.sizes.sizeWireNumber(UkmPageLoadTimingUpdateWire.FIRST_CONTENTFUL_PAINT_MS_WIRE) + gremlin.sizes.sizeDouble(self.first_contentful_paint_ms);
        }
        return res;
    }
    pub fn encode(self: *const UkmPageLoadTimingUpdate, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const UkmPageLoadTimingUpdate, target: *gremlin.Writer) void {
        if (self.ukm_source_id != 0) {
            target.appendInt64(UkmPageLoadTimingUpdateWire.UKM_SOURCE_ID_WIRE, self.ukm_source_id);
        }
        if (self.latest_url) |v| {
            if (v.len > 0) {
                target.appendBytes(UkmPageLoadTimingUpdateWire.LATEST_URL_WIRE, v);
            }
        }
        if (self.latest_cumulative_layout_shift != 0.0) {
            target.appendFloat32(UkmPageLoadTimingUpdateWire.LATEST_CUMULATIVE_LAYOUT_SHIFT_WIRE, self.latest_cumulative_layout_shift);
        }
        if (self.latest_largest_contentful_paint_ms != 0.0) {
            target.appendFloat64(UkmPageLoadTimingUpdateWire.LATEST_LARGEST_CONTENTFUL_PAINT_MS_WIRE, self.latest_largest_contentful_paint_ms);
        }
        if (self.first_contentful_paint_ms != 0.0) {
            target.appendFloat64(UkmPageLoadTimingUpdateWire.FIRST_CONTENTFUL_PAINT_MS_WIRE, self.first_contentful_paint_ms);
        }
    }
};
pub const UkmPageLoadTimingUpdateReader = struct {
    buf: gremlin.Reader,
    _ukm_source_id: i64 = 0,
    _latest_url: ?[]const u8 = null,
    _latest_cumulative_layout_shift: f32 = 0.0,
    _latest_largest_contentful_paint_ms: f64 = 0.0,
    _first_contentful_paint_ms: f64 = 0.0,
    pub fn init(src: []const u8) gremlin.Error!UkmPageLoadTimingUpdateReader {
        const buf = gremlin.Reader.init(src);
        var res = UkmPageLoadTimingUpdateReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                UkmPageLoadTimingUpdateWire.UKM_SOURCE_ID_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._ukm_source_id = result.value;
                },
                UkmPageLoadTimingUpdateWire.LATEST_URL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._latest_url = result.value;
                },
                UkmPageLoadTimingUpdateWire.LATEST_CUMULATIVE_LAYOUT_SHIFT_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._latest_cumulative_layout_shift = result.value;
                },
                UkmPageLoadTimingUpdateWire.LATEST_LARGEST_CONTENTFUL_PAINT_MS_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._latest_largest_contentful_paint_ms = result.value;
                },
                UkmPageLoadTimingUpdateWire.FIRST_CONTENTFUL_PAINT_MS_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._first_contentful_paint_ms = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getUkmSourceId(self: *const UkmPageLoadTimingUpdateReader) i64 {
        return self._ukm_source_id;
    }
    pub inline fn getLatestUrl(self: *const UkmPageLoadTimingUpdateReader) []const u8 {
        return self._latest_url orelse &[_]u8{};
    }
    pub inline fn getLatestCumulativeLayoutShift(self: *const UkmPageLoadTimingUpdateReader) f32 {
        return self._latest_cumulative_layout_shift;
    }
    pub inline fn getLatestLargestContentfulPaintMs(self: *const UkmPageLoadTimingUpdateReader) f64 {
        return self._latest_largest_contentful_paint_ms;
    }
    pub inline fn getFirstContentfulPaintMs(self: *const UkmPageLoadTimingUpdateReader) f64 {
        return self._first_contentful_paint_ms;
    }
};
const V8StackFrameWire = struct {
    const FUNCTION_NAME_WIRE: gremlin.ProtoWireNumber = 1;
    const SCRIPT_LOCATION_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const V8StackFrame = struct {
    // nested structs
    const ScriptLocationWire = struct {
        const SOURCE_URL_WIRE: gremlin.ProtoWireNumber = 1;
        const LINE_NUMBER_WIRE: gremlin.ProtoWireNumber = 2;
        const COLUMN_NUMBER_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const ScriptLocation = struct {
        // fields
        source_url: ?[]const u8 = null,
        line_number: i64 = 0,
        column_number: i64 = 0,
        pub fn calcProtobufSize(self: *const V8StackFrame.ScriptLocation) usize {
            var res: usize = 0;
            if (self.source_url) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(V8StackFrame.ScriptLocationWire.SOURCE_URL_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.line_number != 0) {
                res += gremlin.sizes.sizeWireNumber(V8StackFrame.ScriptLocationWire.LINE_NUMBER_WIRE) + gremlin.sizes.sizeI64(self.line_number);
            }
            if (self.column_number != 0) {
                res += gremlin.sizes.sizeWireNumber(V8StackFrame.ScriptLocationWire.COLUMN_NUMBER_WIRE) + gremlin.sizes.sizeI64(self.column_number);
            }
            return res;
        }
        pub fn encode(self: *const V8StackFrame.ScriptLocation, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const V8StackFrame.ScriptLocation, target: *gremlin.Writer) void {
            if (self.source_url) |v| {
                if (v.len > 0) {
                    target.appendBytes(V8StackFrame.ScriptLocationWire.SOURCE_URL_WIRE, v);
                }
            }
            if (self.line_number != 0) {
                target.appendInt64(V8StackFrame.ScriptLocationWire.LINE_NUMBER_WIRE, self.line_number);
            }
            if (self.column_number != 0) {
                target.appendInt64(V8StackFrame.ScriptLocationWire.COLUMN_NUMBER_WIRE, self.column_number);
            }
        }
    };
    pub const ScriptLocationReader = struct {
        buf: gremlin.Reader,
        _source_url: ?[]const u8 = null,
        _line_number: i64 = 0,
        _column_number: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!V8StackFrame.ScriptLocationReader {
            const buf = gremlin.Reader.init(src);
            var res = V8StackFrame.ScriptLocationReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    V8StackFrame.ScriptLocationWire.SOURCE_URL_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._source_url = result.value;
                    },
                    V8StackFrame.ScriptLocationWire.LINE_NUMBER_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._line_number = result.value;
                    },
                    V8StackFrame.ScriptLocationWire.COLUMN_NUMBER_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._column_number = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getSourceUrl(self: *const V8StackFrame.ScriptLocationReader) []const u8 {
            return self._source_url orelse &[_]u8{};
        }
        pub inline fn getLineNumber(self: *const V8StackFrame.ScriptLocationReader) i64 {
            return self._line_number;
        }
        pub inline fn getColumnNumber(self: *const V8StackFrame.ScriptLocationReader) i64 {
            return self._column_number;
        }
    };
    // fields
    function_name: ?[]const u8 = null,
    script_location: ?V8StackFrame.ScriptLocation = null,
    pub fn calcProtobufSize(self: *const V8StackFrame) usize {
        var res: usize = 0;
        if (self.function_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(V8StackFrameWire.FUNCTION_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.script_location) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(V8StackFrameWire.SCRIPT_LOCATION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const V8StackFrame, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const V8StackFrame, target: *gremlin.Writer) void {
        if (self.function_name) |v| {
            if (v.len > 0) {
                target.appendBytes(V8StackFrameWire.FUNCTION_NAME_WIRE, v);
            }
        }
        if (self.script_location) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(V8StackFrameWire.SCRIPT_LOCATION_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const V8StackFrameReader = struct {
    buf: gremlin.Reader,
    _function_name: ?[]const u8 = null,
    _script_location_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!V8StackFrameReader {
        const buf = gremlin.Reader.init(src);
        var res = V8StackFrameReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                V8StackFrameWire.FUNCTION_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._function_name = result.value;
                },
                V8StackFrameWire.SCRIPT_LOCATION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._script_location_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getFunctionName(self: *const V8StackFrameReader) []const u8 {
        return self._function_name orelse &[_]u8{};
    }
    pub fn getScriptLocation(self: *const V8StackFrameReader) gremlin.Error!V8StackFrame.ScriptLocationReader {
        if (self._script_location_buf) |buf| {
            return try V8StackFrame.ScriptLocationReader.init(buf);
        }
        return try V8StackFrame.ScriptLocationReader.init(&[_]u8{});
    }
};
const BlinkExecutionContextWire = struct {
    const TYPE_WIRE: gremlin.ProtoWireNumber = 1;
    const URL_WIRE: gremlin.ProtoWireNumber = 2;
    const ORIGIN_WIRE: gremlin.ProtoWireNumber = 3;
    const WORLD_TYPE_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const BlinkExecutionContext = struct {
    // nested enums
    pub const ContextType = enum(i32) {
        UNKNOWN_CONTEXT = 0,
        WINDOW = 1,
        WORKLET = 2,
        DEDICATED_WORKER = 3,
        SHARED_WORKER = 4,
        SERVICE_WORKER = 5,
    };
    pub const WorldType = enum(i32) {
        WORLD_UNKNOWN = 0,
        WORLD_MAIN = 1,
        WORLD_ISOLATED = 2,
        WORLD_INSPECTOR_ISOLATED = 3,
        WORLD_REG_EXP = 4,
        WORLD_FOR_V8_CONTEXT_SNAPSHOT_NON_MAIN = 5,
        WORLD_WORKER = 6,
        WORLD_SHADOW_REALM = 7,
    };
    // fields
    type: BlinkExecutionContext.ContextType = @enumFromInt(0),
    url: ?[]const u8 = null,
    origin: ?[]const u8 = null,
    world_type: BlinkExecutionContext.WorldType = @enumFromInt(0),
    pub fn calcProtobufSize(self: *const BlinkExecutionContext) usize {
        var res: usize = 0;
        if (@intFromEnum(self.type) != 0) {
            res += gremlin.sizes.sizeWireNumber(BlinkExecutionContextWire.TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.type));
        }
        if (self.url) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(BlinkExecutionContextWire.URL_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.origin) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(BlinkExecutionContextWire.ORIGIN_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (@intFromEnum(self.world_type) != 0) {
            res += gremlin.sizes.sizeWireNumber(BlinkExecutionContextWire.WORLD_TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.world_type));
        }
        return res;
    }
    pub fn encode(self: *const BlinkExecutionContext, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const BlinkExecutionContext, target: *gremlin.Writer) void {
        if (@intFromEnum(self.type) != 0) {
            target.appendInt32(BlinkExecutionContextWire.TYPE_WIRE, @intFromEnum(self.type));
        }
        if (self.url) |v| {
            if (v.len > 0) {
                target.appendBytes(BlinkExecutionContextWire.URL_WIRE, v);
            }
        }
        if (self.origin) |v| {
            if (v.len > 0) {
                target.appendBytes(BlinkExecutionContextWire.ORIGIN_WIRE, v);
            }
        }
        if (@intFromEnum(self.world_type) != 0) {
            target.appendInt32(BlinkExecutionContextWire.WORLD_TYPE_WIRE, @intFromEnum(self.world_type));
        }
    }
};
pub const BlinkExecutionContextReader = struct {
    buf: gremlin.Reader,
    _type: BlinkExecutionContext.ContextType = @enumFromInt(0),
    _url: ?[]const u8 = null,
    _origin: ?[]const u8 = null,
    _world_type: BlinkExecutionContext.WorldType = @enumFromInt(0),
    pub fn init(src: []const u8) gremlin.Error!BlinkExecutionContextReader {
        const buf = gremlin.Reader.init(src);
        var res = BlinkExecutionContextReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                BlinkExecutionContextWire.TYPE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._type = @enumFromInt(result.value);
                },
                BlinkExecutionContextWire.URL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._url = result.value;
                },
                BlinkExecutionContextWire.ORIGIN_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._origin = result.value;
                },
                BlinkExecutionContextWire.WORLD_TYPE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._world_type = @enumFromInt(result.value);
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getType(self: *const BlinkExecutionContextReader) BlinkExecutionContext.ContextType {
        return self._type;
    }
    pub inline fn getUrl(self: *const BlinkExecutionContextReader) []const u8 {
        return self._url orelse &[_]u8{};
    }
    pub inline fn getOrigin(self: *const BlinkExecutionContextReader) []const u8 {
        return self._origin orelse &[_]u8{};
    }
    pub inline fn getWorldType(self: *const BlinkExecutionContextReader) BlinkExecutionContext.WorldType {
        return self._world_type;
    }
};
const BlinkSourceLocationWire = struct {
    const FUNCTION_NAME_WIRE: gremlin.ProtoWireNumber = 1;
    const SCRIPT_ID_WIRE: gremlin.ProtoWireNumber = 2;
    const URL_WIRE: gremlin.ProtoWireNumber = 3;
    const LINE_NUMBER_WIRE: gremlin.ProtoWireNumber = 4;
    const COLUMN_NUMBER_WIRE: gremlin.ProtoWireNumber = 5;
    const STACK_TRACE_WIRE: gremlin.ProtoWireNumber = 6;
    const STACK_FRAMES_WIRE: gremlin.ProtoWireNumber = 7;
};
pub const BlinkSourceLocation = struct {
    // fields
    function_name: ?[]const u8 = null,
    script_id: i32 = 0,
    url: ?[]const u8 = null,
    line_number: i32 = 0,
    column_number: i32 = 0,
    stack_trace: ?[]const u8 = null,
    stack_frames: ?[]const ?V8StackFrame = null,
    pub fn calcProtobufSize(self: *const BlinkSourceLocation) usize {
        var res: usize = 0;
        if (self.function_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(BlinkSourceLocationWire.FUNCTION_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.script_id != 0) {
            res += gremlin.sizes.sizeWireNumber(BlinkSourceLocationWire.SCRIPT_ID_WIRE) + gremlin.sizes.sizeI32(self.script_id);
        }
        if (self.url) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(BlinkSourceLocationWire.URL_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.line_number != 0) {
            res += gremlin.sizes.sizeWireNumber(BlinkSourceLocationWire.LINE_NUMBER_WIRE) + gremlin.sizes.sizeI32(self.line_number);
        }
        if (self.column_number != 0) {
            res += gremlin.sizes.sizeWireNumber(BlinkSourceLocationWire.COLUMN_NUMBER_WIRE) + gremlin.sizes.sizeI32(self.column_number);
        }
        if (self.stack_trace) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(BlinkSourceLocationWire.STACK_TRACE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.stack_frames) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(BlinkSourceLocationWire.STACK_FRAMES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const BlinkSourceLocation, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const BlinkSourceLocation, target: *gremlin.Writer) void {
        if (self.function_name) |v| {
            if (v.len > 0) {
                target.appendBytes(BlinkSourceLocationWire.FUNCTION_NAME_WIRE, v);
            }
        }
        if (self.script_id != 0) {
            target.appendInt32(BlinkSourceLocationWire.SCRIPT_ID_WIRE, self.script_id);
        }
        if (self.url) |v| {
            if (v.len > 0) {
                target.appendBytes(BlinkSourceLocationWire.URL_WIRE, v);
            }
        }
        if (self.line_number != 0) {
            target.appendInt32(BlinkSourceLocationWire.LINE_NUMBER_WIRE, self.line_number);
        }
        if (self.column_number != 0) {
            target.appendInt32(BlinkSourceLocationWire.COLUMN_NUMBER_WIRE, self.column_number);
        }
        if (self.stack_trace) |v| {
            if (v.len > 0) {
                target.appendBytes(BlinkSourceLocationWire.STACK_TRACE_WIRE, v);
            }
        }
        if (self.stack_frames) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(BlinkSourceLocationWire.STACK_FRAMES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(BlinkSourceLocationWire.STACK_FRAMES_WIRE, 0);
                }
            }
        }
    }
};
pub const BlinkSourceLocationReader = struct {
    buf: gremlin.Reader,
    _function_name: ?[]const u8 = null,
    _script_id: i32 = 0,
    _url: ?[]const u8 = null,
    _line_number: i32 = 0,
    _column_number: i32 = 0,
    _stack_trace: ?[]const u8 = null,
    _stack_frames_offset: ?usize = null,
    _stack_frames_last_offset: ?usize = null,
    _stack_frames_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!BlinkSourceLocationReader {
        const buf = gremlin.Reader.init(src);
        var res = BlinkSourceLocationReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                BlinkSourceLocationWire.FUNCTION_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._function_name = result.value;
                },
                BlinkSourceLocationWire.SCRIPT_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._script_id = result.value;
                },
                BlinkSourceLocationWire.URL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._url = result.value;
                },
                BlinkSourceLocationWire.LINE_NUMBER_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._line_number = result.value;
                },
                BlinkSourceLocationWire.COLUMN_NUMBER_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._column_number = result.value;
                },
                BlinkSourceLocationWire.STACK_TRACE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._stack_trace = result.value;
                },
                BlinkSourceLocationWire.STACK_FRAMES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._stack_frames_offset == null) {
                        res._stack_frames_offset = offset - result.size;
                    }
                    res._stack_frames_last_offset = offset;
                    res._stack_frames_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getFunctionName(self: *const BlinkSourceLocationReader) []const u8 {
        return self._function_name orelse &[_]u8{};
    }
    pub inline fn getScriptId(self: *const BlinkSourceLocationReader) i32 {
        return self._script_id;
    }
    pub inline fn getUrl(self: *const BlinkSourceLocationReader) []const u8 {
        return self._url orelse &[_]u8{};
    }
    pub inline fn getLineNumber(self: *const BlinkSourceLocationReader) i32 {
        return self._line_number;
    }
    pub inline fn getColumnNumber(self: *const BlinkSourceLocationReader) i32 {
        return self._column_number;
    }
    pub inline fn getStackTrace(self: *const BlinkSourceLocationReader) []const u8 {
        return self._stack_trace orelse &[_]u8{};
    }
    pub fn stackFramesCount(self: *const BlinkSourceLocationReader) usize {
        return self._stack_frames_cnt;
    }
    pub fn stackFramesNext(self: *BlinkSourceLocationReader) ?V8StackFrameReader {
        if (self._stack_frames_offset == null) return null;
        const current_offset = self._stack_frames_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = V8StackFrameReader.init(result.value) catch return null;
        if (self._stack_frames_last_offset != null and current_offset >= self._stack_frames_last_offset.?) {
            self._stack_frames_offset = null;
            return msg;
        }
        if (self._stack_frames_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._stack_frames_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == BlinkSourceLocationWire.STACK_FRAMES_WIRE) {
                self._stack_frames_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._stack_frames_offset = null;
        return msg;
    }
};
const BlinkHighEntropyAPIWire = struct {
    const EXECUTION_CONTEXT_WIRE: gremlin.ProtoWireNumber = 1;
    const CALLED_API_WIRE: gremlin.ProtoWireNumber = 2;
    const SOURCE_LOCATION_WIRE: gremlin.ProtoWireNumber = 3;
    const FONT_LOOKUP_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const BlinkHighEntropyAPI = struct {
    // nested structs
    const JSFunctionArgumentWire = struct {
        const TYPE_WIRE: gremlin.ProtoWireNumber = 1;
        const VALUE_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const JSFunctionArgument = struct {
        // nested enums
        pub const ArgumentType = enum(i32) {
            UNKNOWN_TYPE = 0,
            NULL_TYPE = 1,
            UNDEFINED = 2,
            BIGINT = 3,
            BOOLEAN = 4,
            FUNCTION = 5,
            NUMBER = 6,
            STRING = 7,
            SYMBOL = 8,
            OBJECT = 9,
        };
        // fields
        type: BlinkHighEntropyAPI.JSFunctionArgument.ArgumentType = @enumFromInt(0),
        value: ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const BlinkHighEntropyAPI.JSFunctionArgument) usize {
            var res: usize = 0;
            if (@intFromEnum(self.type) != 0) {
                res += gremlin.sizes.sizeWireNumber(BlinkHighEntropyAPI.JSFunctionArgumentWire.TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.type));
            }
            if (self.value) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(BlinkHighEntropyAPI.JSFunctionArgumentWire.VALUE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            return res;
        }
        pub fn encode(self: *const BlinkHighEntropyAPI.JSFunctionArgument, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const BlinkHighEntropyAPI.JSFunctionArgument, target: *gremlin.Writer) void {
            if (@intFromEnum(self.type) != 0) {
                target.appendInt32(BlinkHighEntropyAPI.JSFunctionArgumentWire.TYPE_WIRE, @intFromEnum(self.type));
            }
            if (self.value) |v| {
                if (v.len > 0) {
                    target.appendBytes(BlinkHighEntropyAPI.JSFunctionArgumentWire.VALUE_WIRE, v);
                }
            }
        }
    };
    pub const JSFunctionArgumentReader = struct {
        buf: gremlin.Reader,
        _type: BlinkHighEntropyAPI.JSFunctionArgument.ArgumentType = @enumFromInt(0),
        _value: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!BlinkHighEntropyAPI.JSFunctionArgumentReader {
            const buf = gremlin.Reader.init(src);
            var res = BlinkHighEntropyAPI.JSFunctionArgumentReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    BlinkHighEntropyAPI.JSFunctionArgumentWire.TYPE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._type = @enumFromInt(result.value);
                    },
                    BlinkHighEntropyAPI.JSFunctionArgumentWire.VALUE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._value = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getType(self: *const BlinkHighEntropyAPI.JSFunctionArgumentReader) BlinkHighEntropyAPI.JSFunctionArgument.ArgumentType {
            return self._type;
        }
        pub inline fn getValue(self: *const BlinkHighEntropyAPI.JSFunctionArgumentReader) []const u8 {
            return self._value orelse &[_]u8{};
        }
    };
    const CalledJsApiWire = struct {
        const IDENTIFIER_WIRE: gremlin.ProtoWireNumber = 1;
        const FUNC_ARGUMENTS_WIRE: gremlin.ProtoWireNumber = 2;
        const SOURCE_LOCATION_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const CalledJsApi = struct {
        // fields
        identifier: ?[]const u8 = null,
        func_arguments: ?[]const ?BlinkHighEntropyAPI.JSFunctionArgument = null,
        source_location: ?BlinkSourceLocation = null,
        pub fn calcProtobufSize(self: *const BlinkHighEntropyAPI.CalledJsApi) usize {
            var res: usize = 0;
            if (self.identifier) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(BlinkHighEntropyAPI.CalledJsApiWire.IDENTIFIER_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.func_arguments) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(BlinkHighEntropyAPI.CalledJsApiWire.FUNC_ARGUMENTS_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.source_location) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(BlinkHighEntropyAPI.CalledJsApiWire.SOURCE_LOCATION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            return res;
        }
        pub fn encode(self: *const BlinkHighEntropyAPI.CalledJsApi, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const BlinkHighEntropyAPI.CalledJsApi, target: *gremlin.Writer) void {
            if (self.identifier) |v| {
                if (v.len > 0) {
                    target.appendBytes(BlinkHighEntropyAPI.CalledJsApiWire.IDENTIFIER_WIRE, v);
                }
            }
            if (self.func_arguments) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(BlinkHighEntropyAPI.CalledJsApiWire.FUNC_ARGUMENTS_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(BlinkHighEntropyAPI.CalledJsApiWire.FUNC_ARGUMENTS_WIRE, 0);
                    }
                }
            }
            if (self.source_location) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(BlinkHighEntropyAPI.CalledJsApiWire.SOURCE_LOCATION_WIRE, size);
                    v.encodeTo(target);
                }
            }
        }
    };
    pub const CalledJsApiReader = struct {
        buf: gremlin.Reader,
        _identifier: ?[]const u8 = null,
        _func_arguments_offset: ?usize = null,
        _func_arguments_last_offset: ?usize = null,
        _func_arguments_cnt: usize = 0,
        _source_location_buf: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!BlinkHighEntropyAPI.CalledJsApiReader {
            const buf = gremlin.Reader.init(src);
            var res = BlinkHighEntropyAPI.CalledJsApiReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    BlinkHighEntropyAPI.CalledJsApiWire.IDENTIFIER_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._identifier = result.value;
                    },
                    BlinkHighEntropyAPI.CalledJsApiWire.FUNC_ARGUMENTS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._func_arguments_offset == null) {
                            res._func_arguments_offset = offset - result.size;
                        }
                        res._func_arguments_last_offset = offset;
                        res._func_arguments_cnt += 1;
                    },
                    BlinkHighEntropyAPI.CalledJsApiWire.SOURCE_LOCATION_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._source_location_buf = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getIdentifier(self: *const BlinkHighEntropyAPI.CalledJsApiReader) []const u8 {
            return self._identifier orelse &[_]u8{};
        }
        pub fn funcArgumentsCount(self: *const BlinkHighEntropyAPI.CalledJsApiReader) usize {
            return self._func_arguments_cnt;
        }
        pub fn funcArgumentsNext(self: *BlinkHighEntropyAPI.CalledJsApiReader) ?BlinkHighEntropyAPI.JSFunctionArgumentReader {
            if (self._func_arguments_offset == null) return null;
            const current_offset = self._func_arguments_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = BlinkHighEntropyAPI.JSFunctionArgumentReader.init(result.value) catch return null;
            if (self._func_arguments_last_offset != null and current_offset >= self._func_arguments_last_offset.?) {
                self._func_arguments_offset = null;
                return msg;
            }
            if (self._func_arguments_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._func_arguments_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == BlinkHighEntropyAPI.CalledJsApiWire.FUNC_ARGUMENTS_WIRE) {
                    self._func_arguments_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._func_arguments_offset = null;
            return msg;
        }
        pub fn getSourceLocation(self: *const BlinkHighEntropyAPI.CalledJsApiReader) gremlin.Error!BlinkSourceLocationReader {
            if (self._source_location_buf) |buf| {
                return try BlinkSourceLocationReader.init(buf);
            }
            return try BlinkSourceLocationReader.init(&[_]u8{});
        }
    };
    const FontLookupWire = struct {
        const TYPE_WIRE: gremlin.ProtoWireNumber = 1;
        const NAME_WIRE: gremlin.ProtoWireNumber = 2;
        const WEIGHT_WIRE: gremlin.ProtoWireNumber = 3;
        const WIDTH_WIRE: gremlin.ProtoWireNumber = 4;
        const SLOPE_WIRE: gremlin.ProtoWireNumber = 5;
    };
    pub const FontLookup = struct {
        // nested enums
        pub const FontLookupType = enum(i32) {
            FONT_LOOKUP_UNKNOWN_TYPE = 0,
            FONT_LOOKUP_UNIQUE_OR_FAMILY_NAME = 1,
            FONT_LOOKUP_UNIQUE_NAME_ONLY = 2,
        };
        // fields
        type: BlinkHighEntropyAPI.FontLookup.FontLookupType = @enumFromInt(0),
        name: ?[]const u8 = null,
        weight: u64 = 0,
        width: u64 = 0,
        slope: u64 = 0,
        pub fn calcProtobufSize(self: *const BlinkHighEntropyAPI.FontLookup) usize {
            var res: usize = 0;
            if (@intFromEnum(self.type) != 0) {
                res += gremlin.sizes.sizeWireNumber(BlinkHighEntropyAPI.FontLookupWire.TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.type));
            }
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(BlinkHighEntropyAPI.FontLookupWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.weight != 0) {
                res += gremlin.sizes.sizeWireNumber(BlinkHighEntropyAPI.FontLookupWire.WEIGHT_WIRE) + gremlin.sizes.sizeU64(self.weight);
            }
            if (self.width != 0) {
                res += gremlin.sizes.sizeWireNumber(BlinkHighEntropyAPI.FontLookupWire.WIDTH_WIRE) + gremlin.sizes.sizeU64(self.width);
            }
            if (self.slope != 0) {
                res += gremlin.sizes.sizeWireNumber(BlinkHighEntropyAPI.FontLookupWire.SLOPE_WIRE) + gremlin.sizes.sizeU64(self.slope);
            }
            return res;
        }
        pub fn encode(self: *const BlinkHighEntropyAPI.FontLookup, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const BlinkHighEntropyAPI.FontLookup, target: *gremlin.Writer) void {
            if (@intFromEnum(self.type) != 0) {
                target.appendInt32(BlinkHighEntropyAPI.FontLookupWire.TYPE_WIRE, @intFromEnum(self.type));
            }
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(BlinkHighEntropyAPI.FontLookupWire.NAME_WIRE, v);
                }
            }
            if (self.weight != 0) {
                target.appendUint64(BlinkHighEntropyAPI.FontLookupWire.WEIGHT_WIRE, self.weight);
            }
            if (self.width != 0) {
                target.appendUint64(BlinkHighEntropyAPI.FontLookupWire.WIDTH_WIRE, self.width);
            }
            if (self.slope != 0) {
                target.appendUint64(BlinkHighEntropyAPI.FontLookupWire.SLOPE_WIRE, self.slope);
            }
        }
    };
    pub const FontLookupReader = struct {
        buf: gremlin.Reader,
        _type: BlinkHighEntropyAPI.FontLookup.FontLookupType = @enumFromInt(0),
        _name: ?[]const u8 = null,
        _weight: u64 = 0,
        _width: u64 = 0,
        _slope: u64 = 0,
        pub fn init(src: []const u8) gremlin.Error!BlinkHighEntropyAPI.FontLookupReader {
            const buf = gremlin.Reader.init(src);
            var res = BlinkHighEntropyAPI.FontLookupReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    BlinkHighEntropyAPI.FontLookupWire.TYPE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._type = @enumFromInt(result.value);
                    },
                    BlinkHighEntropyAPI.FontLookupWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    BlinkHighEntropyAPI.FontLookupWire.WEIGHT_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._weight = result.value;
                    },
                    BlinkHighEntropyAPI.FontLookupWire.WIDTH_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._width = result.value;
                    },
                    BlinkHighEntropyAPI.FontLookupWire.SLOPE_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._slope = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getType(self: *const BlinkHighEntropyAPI.FontLookupReader) BlinkHighEntropyAPI.FontLookup.FontLookupType {
            return self._type;
        }
        pub inline fn getName(self: *const BlinkHighEntropyAPI.FontLookupReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub inline fn getWeight(self: *const BlinkHighEntropyAPI.FontLookupReader) u64 {
            return self._weight;
        }
        pub inline fn getWidth(self: *const BlinkHighEntropyAPI.FontLookupReader) u64 {
            return self._width;
        }
        pub inline fn getSlope(self: *const BlinkHighEntropyAPI.FontLookupReader) u64 {
            return self._slope;
        }
    };
    // fields
    execution_context: ?BlinkExecutionContext = null,
    called_api: ?BlinkHighEntropyAPI.CalledJsApi = null,
    source_location: ?BlinkSourceLocation = null,
    font_lookup: ?BlinkHighEntropyAPI.FontLookup = null,
    pub fn calcProtobufSize(self: *const BlinkHighEntropyAPI) usize {
        var res: usize = 0;
        if (self.execution_context) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(BlinkHighEntropyAPIWire.EXECUTION_CONTEXT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.called_api) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(BlinkHighEntropyAPIWire.CALLED_API_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.source_location) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(BlinkHighEntropyAPIWire.SOURCE_LOCATION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.font_lookup) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(BlinkHighEntropyAPIWire.FONT_LOOKUP_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const BlinkHighEntropyAPI, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const BlinkHighEntropyAPI, target: *gremlin.Writer) void {
        if (self.execution_context) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(BlinkHighEntropyAPIWire.EXECUTION_CONTEXT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.called_api) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(BlinkHighEntropyAPIWire.CALLED_API_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.source_location) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(BlinkHighEntropyAPIWire.SOURCE_LOCATION_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.font_lookup) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(BlinkHighEntropyAPIWire.FONT_LOOKUP_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const BlinkHighEntropyAPIReader = struct {
    buf: gremlin.Reader,
    _execution_context_buf: ?[]const u8 = null,
    _called_api_buf: ?[]const u8 = null,
    _source_location_buf: ?[]const u8 = null,
    _font_lookup_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!BlinkHighEntropyAPIReader {
        const buf = gremlin.Reader.init(src);
        var res = BlinkHighEntropyAPIReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                BlinkHighEntropyAPIWire.EXECUTION_CONTEXT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._execution_context_buf = result.value;
                },
                BlinkHighEntropyAPIWire.CALLED_API_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._called_api_buf = result.value;
                },
                BlinkHighEntropyAPIWire.SOURCE_LOCATION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._source_location_buf = result.value;
                },
                BlinkHighEntropyAPIWire.FONT_LOOKUP_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._font_lookup_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getExecutionContext(self: *const BlinkHighEntropyAPIReader) gremlin.Error!BlinkExecutionContextReader {
        if (self._execution_context_buf) |buf| {
            return try BlinkExecutionContextReader.init(buf);
        }
        return try BlinkExecutionContextReader.init(&[_]u8{});
    }
    pub fn getCalledApi(self: *const BlinkHighEntropyAPIReader) gremlin.Error!BlinkHighEntropyAPI.CalledJsApiReader {
        if (self._called_api_buf) |buf| {
            return try BlinkHighEntropyAPI.CalledJsApiReader.init(buf);
        }
        return try BlinkHighEntropyAPI.CalledJsApiReader.init(&[_]u8{});
    }
    pub fn getSourceLocation(self: *const BlinkHighEntropyAPIReader) gremlin.Error!BlinkSourceLocationReader {
        if (self._source_location_buf) |buf| {
            return try BlinkSourceLocationReader.init(buf);
        }
        return try BlinkSourceLocationReader.init(&[_]u8{});
    }
    pub fn getFontLookup(self: *const BlinkHighEntropyAPIReader) gremlin.Error!BlinkHighEntropyAPI.FontLookupReader {
        if (self._font_lookup_buf) |buf| {
            return try BlinkHighEntropyAPI.FontLookupReader.init(buf);
        }
        return try BlinkHighEntropyAPI.FontLookupReader.init(&[_]u8{});
    }
};
const TabSwitchMeasurementWire = struct {
    const RESULT_WIRE: gremlin.ProtoWireNumber = 1;
    const TAB_STATE_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const TabSwitchMeasurement = struct {
    // nested enums
    pub const Result = enum(i32) {
        RESULT_UNSPECIFIED = 0,
        RESULT_SUCCESS = 1,
        RESULT_INCOMPLETE = 2,
        RESULT_MISSED_TAB_HIDE = 3,
    };
    pub const TabState = enum(i32) {
        STATE_UNSPECIFIED = 0,
        STATE_WITH_SAVED_FRAMES = 1,
        STATE_LOADED_NO_SAVED_FRAMES = 2,
        STATE_NOT_LOADED_NO_SAVED_FRAMES = 3,
    };
    // fields
    result: TabSwitchMeasurement.Result = @enumFromInt(0),
    tab_state: TabSwitchMeasurement.TabState = @enumFromInt(0),
    pub fn calcProtobufSize(self: *const TabSwitchMeasurement) usize {
        var res: usize = 0;
        if (@intFromEnum(self.result) != 0) {
            res += gremlin.sizes.sizeWireNumber(TabSwitchMeasurementWire.RESULT_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.result));
        }
        if (@intFromEnum(self.tab_state) != 0) {
            res += gremlin.sizes.sizeWireNumber(TabSwitchMeasurementWire.TAB_STATE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.tab_state));
        }
        return res;
    }
    pub fn encode(self: *const TabSwitchMeasurement, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TabSwitchMeasurement, target: *gremlin.Writer) void {
        if (@intFromEnum(self.result) != 0) {
            target.appendInt32(TabSwitchMeasurementWire.RESULT_WIRE, @intFromEnum(self.result));
        }
        if (@intFromEnum(self.tab_state) != 0) {
            target.appendInt32(TabSwitchMeasurementWire.TAB_STATE_WIRE, @intFromEnum(self.tab_state));
        }
    }
};
pub const TabSwitchMeasurementReader = struct {
    buf: gremlin.Reader,
    _result: TabSwitchMeasurement.Result = @enumFromInt(0),
    _tab_state: TabSwitchMeasurement.TabState = @enumFromInt(0),
    pub fn init(src: []const u8) gremlin.Error!TabSwitchMeasurementReader {
        const buf = gremlin.Reader.init(src);
        var res = TabSwitchMeasurementReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TabSwitchMeasurementWire.RESULT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._result = @enumFromInt(result.value);
                },
                TabSwitchMeasurementWire.TAB_STATE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._tab_state = @enumFromInt(result.value);
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getResult(self: *const TabSwitchMeasurementReader) TabSwitchMeasurement.Result {
        return self._result;
    }
    pub inline fn getTabState(self: *const TabSwitchMeasurementReader) TabSwitchMeasurement.TabState {
        return self._tab_state;
    }
};
const ScrollDeltasWire = struct {
    const TRACE_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const ORIGINAL_DELTA_X_WIRE: gremlin.ProtoWireNumber = 2;
    const ORIGINAL_DELTA_Y_WIRE: gremlin.ProtoWireNumber = 3;
    const COALESCED_TO_TRACE_ID_WIRE: gremlin.ProtoWireNumber = 4;
    const PROVIDED_TO_COMPOSITOR_DELTA_X_WIRE: gremlin.ProtoWireNumber = 5;
    const PROVIDED_TO_COMPOSITOR_DELTA_Y_WIRE: gremlin.ProtoWireNumber = 6;
    const VISUAL_OFFSET_X_WIRE: gremlin.ProtoWireNumber = 7;
    const VISUAL_OFFSET_Y_WIRE: gremlin.ProtoWireNumber = 8;
    const EVENT_COUNT_IN_GPU_FRAME_WIRE: gremlin.ProtoWireNumber = 9;
    const TRACE_IDS_IN_GPU_FRAME_WIRE: gremlin.ProtoWireNumber = 10;
    const ORIGINAL_DELTA_IN_GPU_FRAME_Y_WIRE: gremlin.ProtoWireNumber = 11;
    const PREDICTED_DELTA_IN_GPU_FRAME_Y_WIRE: gremlin.ProtoWireNumber = 12;
    const SEGREGATED_ORIGINAL_DELTAS_IN_GPU_FRAME_Y_WIRE: gremlin.ProtoWireNumber = 13;
    const SEGREGATED_PREDICTED_DELTAS_IN_GPU_FRAME_Y_WIRE: gremlin.ProtoWireNumber = 14;
    const DID_OVERSCROLL_ROOT_WIRE: gremlin.ProtoWireNumber = 15;
    const UNUSED_DELTA_X_WIRE: gremlin.ProtoWireNumber = 16;
    const UNUSED_DELTA_Y_WIRE: gremlin.ProtoWireNumber = 17;
};
pub const ScrollDeltas = struct {
    // fields
    trace_id: i64 = 0,
    original_delta_x: f32 = 0.0,
    original_delta_y: f32 = 0.0,
    coalesced_to_trace_id: i64 = 0,
    provided_to_compositor_delta_x: f32 = 0.0,
    provided_to_compositor_delta_y: f32 = 0.0,
    visual_offset_x: i64 = 0,
    visual_offset_y: i64 = 0,
    event_count_in_gpu_frame: i32 = 0,
    trace_ids_in_gpu_frame: ?[]const i64 = null,
    original_delta_in_gpu_frame_y: f32 = 0.0,
    predicted_delta_in_gpu_frame_y: f32 = 0.0,
    segregated_original_deltas_in_gpu_frame_y: ?[]const f32 = null,
    segregated_predicted_deltas_in_gpu_frame_y: ?[]const f32 = null,
    did_overscroll_root: bool = false,
    unused_delta_x: f32 = 0.0,
    unused_delta_y: f32 = 0.0,
    pub fn calcProtobufSize(self: *const ScrollDeltas) usize {
        var res: usize = 0;
        if (self.trace_id != 0) {
            res += gremlin.sizes.sizeWireNumber(ScrollDeltasWire.TRACE_ID_WIRE) + gremlin.sizes.sizeI64(self.trace_id);
        }
        if (self.original_delta_x != 0.0) {
            res += gremlin.sizes.sizeWireNumber(ScrollDeltasWire.ORIGINAL_DELTA_X_WIRE) + gremlin.sizes.sizeFloat(self.original_delta_x);
        }
        if (self.original_delta_y != 0.0) {
            res += gremlin.sizes.sizeWireNumber(ScrollDeltasWire.ORIGINAL_DELTA_Y_WIRE) + gremlin.sizes.sizeFloat(self.original_delta_y);
        }
        if (self.coalesced_to_trace_id != 0) {
            res += gremlin.sizes.sizeWireNumber(ScrollDeltasWire.COALESCED_TO_TRACE_ID_WIRE) + gremlin.sizes.sizeI64(self.coalesced_to_trace_id);
        }
        if (self.provided_to_compositor_delta_x != 0.0) {
            res += gremlin.sizes.sizeWireNumber(ScrollDeltasWire.PROVIDED_TO_COMPOSITOR_DELTA_X_WIRE) + gremlin.sizes.sizeFloat(self.provided_to_compositor_delta_x);
        }
        if (self.provided_to_compositor_delta_y != 0.0) {
            res += gremlin.sizes.sizeWireNumber(ScrollDeltasWire.PROVIDED_TO_COMPOSITOR_DELTA_Y_WIRE) + gremlin.sizes.sizeFloat(self.provided_to_compositor_delta_y);
        }
        if (self.visual_offset_x != 0) {
            res += gremlin.sizes.sizeWireNumber(ScrollDeltasWire.VISUAL_OFFSET_X_WIRE) + gremlin.sizes.sizeI64(self.visual_offset_x);
        }
        if (self.visual_offset_y != 0) {
            res += gremlin.sizes.sizeWireNumber(ScrollDeltasWire.VISUAL_OFFSET_Y_WIRE) + gremlin.sizes.sizeI64(self.visual_offset_y);
        }
        if (self.event_count_in_gpu_frame != 0) {
            res += gremlin.sizes.sizeWireNumber(ScrollDeltasWire.EVENT_COUNT_IN_GPU_FRAME_WIRE) + gremlin.sizes.sizeI32(self.event_count_in_gpu_frame);
        }
        if (self.trace_ids_in_gpu_frame) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(ScrollDeltasWire.TRACE_IDS_IN_GPU_FRAME_WIRE) + gremlin.sizes.sizeI64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI64(v);
                }
                res += gremlin.sizes.sizeWireNumber(ScrollDeltasWire.TRACE_IDS_IN_GPU_FRAME_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.original_delta_in_gpu_frame_y != 0.0) {
            res += gremlin.sizes.sizeWireNumber(ScrollDeltasWire.ORIGINAL_DELTA_IN_GPU_FRAME_Y_WIRE) + gremlin.sizes.sizeFloat(self.original_delta_in_gpu_frame_y);
        }
        if (self.predicted_delta_in_gpu_frame_y != 0.0) {
            res += gremlin.sizes.sizeWireNumber(ScrollDeltasWire.PREDICTED_DELTA_IN_GPU_FRAME_Y_WIRE) + gremlin.sizes.sizeFloat(self.predicted_delta_in_gpu_frame_y);
        }
        if (self.segregated_original_deltas_in_gpu_frame_y) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(ScrollDeltasWire.SEGREGATED_ORIGINAL_DELTAS_IN_GPU_FRAME_Y_WIRE) + gremlin.sizes.sizeFloat(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeFloat(v);
                }
                res += gremlin.sizes.sizeWireNumber(ScrollDeltasWire.SEGREGATED_ORIGINAL_DELTAS_IN_GPU_FRAME_Y_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.segregated_predicted_deltas_in_gpu_frame_y) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(ScrollDeltasWire.SEGREGATED_PREDICTED_DELTAS_IN_GPU_FRAME_Y_WIRE) + gremlin.sizes.sizeFloat(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeFloat(v);
                }
                res += gremlin.sizes.sizeWireNumber(ScrollDeltasWire.SEGREGATED_PREDICTED_DELTAS_IN_GPU_FRAME_Y_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.did_overscroll_root != false) {
            res += gremlin.sizes.sizeWireNumber(ScrollDeltasWire.DID_OVERSCROLL_ROOT_WIRE) + gremlin.sizes.sizeBool(self.did_overscroll_root);
        }
        if (self.unused_delta_x != 0.0) {
            res += gremlin.sizes.sizeWireNumber(ScrollDeltasWire.UNUSED_DELTA_X_WIRE) + gremlin.sizes.sizeFloat(self.unused_delta_x);
        }
        if (self.unused_delta_y != 0.0) {
            res += gremlin.sizes.sizeWireNumber(ScrollDeltasWire.UNUSED_DELTA_Y_WIRE) + gremlin.sizes.sizeFloat(self.unused_delta_y);
        }
        return res;
    }
    pub fn encode(self: *const ScrollDeltas, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ScrollDeltas, target: *gremlin.Writer) void {
        if (self.trace_id != 0) {
            target.appendInt64(ScrollDeltasWire.TRACE_ID_WIRE, self.trace_id);
        }
        if (self.original_delta_x != 0.0) {
            target.appendFloat32(ScrollDeltasWire.ORIGINAL_DELTA_X_WIRE, self.original_delta_x);
        }
        if (self.original_delta_y != 0.0) {
            target.appendFloat32(ScrollDeltasWire.ORIGINAL_DELTA_Y_WIRE, self.original_delta_y);
        }
        if (self.coalesced_to_trace_id != 0) {
            target.appendInt64(ScrollDeltasWire.COALESCED_TO_TRACE_ID_WIRE, self.coalesced_to_trace_id);
        }
        if (self.provided_to_compositor_delta_x != 0.0) {
            target.appendFloat32(ScrollDeltasWire.PROVIDED_TO_COMPOSITOR_DELTA_X_WIRE, self.provided_to_compositor_delta_x);
        }
        if (self.provided_to_compositor_delta_y != 0.0) {
            target.appendFloat32(ScrollDeltasWire.PROVIDED_TO_COMPOSITOR_DELTA_Y_WIRE, self.provided_to_compositor_delta_y);
        }
        if (self.visual_offset_x != 0) {
            target.appendInt64(ScrollDeltasWire.VISUAL_OFFSET_X_WIRE, self.visual_offset_x);
        }
        if (self.visual_offset_y != 0) {
            target.appendInt64(ScrollDeltasWire.VISUAL_OFFSET_Y_WIRE, self.visual_offset_y);
        }
        if (self.event_count_in_gpu_frame != 0) {
            target.appendInt32(ScrollDeltasWire.EVENT_COUNT_IN_GPU_FRAME_WIRE, self.event_count_in_gpu_frame);
        }
        if (self.trace_ids_in_gpu_frame) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt64(ScrollDeltasWire.TRACE_IDS_IN_GPU_FRAME_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI64(v);
                }
                target.appendBytesTag(ScrollDeltasWire.TRACE_IDS_IN_GPU_FRAME_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt64WithoutTag(v);
                }
            }
        }
        if (self.original_delta_in_gpu_frame_y != 0.0) {
            target.appendFloat32(ScrollDeltasWire.ORIGINAL_DELTA_IN_GPU_FRAME_Y_WIRE, self.original_delta_in_gpu_frame_y);
        }
        if (self.predicted_delta_in_gpu_frame_y != 0.0) {
            target.appendFloat32(ScrollDeltasWire.PREDICTED_DELTA_IN_GPU_FRAME_Y_WIRE, self.predicted_delta_in_gpu_frame_y);
        }
        if (self.segregated_original_deltas_in_gpu_frame_y) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendFloat32(ScrollDeltasWire.SEGREGATED_ORIGINAL_DELTAS_IN_GPU_FRAME_Y_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeFloat(v);
                }
                target.appendBytesTag(ScrollDeltasWire.SEGREGATED_ORIGINAL_DELTAS_IN_GPU_FRAME_Y_WIRE, packed_size);
                for (arr) |v| {
                    target.appendFloat32WithoutTag(v);
                }
            }
        }
        if (self.segregated_predicted_deltas_in_gpu_frame_y) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendFloat32(ScrollDeltasWire.SEGREGATED_PREDICTED_DELTAS_IN_GPU_FRAME_Y_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeFloat(v);
                }
                target.appendBytesTag(ScrollDeltasWire.SEGREGATED_PREDICTED_DELTAS_IN_GPU_FRAME_Y_WIRE, packed_size);
                for (arr) |v| {
                    target.appendFloat32WithoutTag(v);
                }
            }
        }
        if (self.did_overscroll_root != false) {
            target.appendBool(ScrollDeltasWire.DID_OVERSCROLL_ROOT_WIRE, self.did_overscroll_root);
        }
        if (self.unused_delta_x != 0.0) {
            target.appendFloat32(ScrollDeltasWire.UNUSED_DELTA_X_WIRE, self.unused_delta_x);
        }
        if (self.unused_delta_y != 0.0) {
            target.appendFloat32(ScrollDeltasWire.UNUSED_DELTA_Y_WIRE, self.unused_delta_y);
        }
    }
};
pub const ScrollDeltasReader = struct {
    buf: gremlin.Reader,
    _trace_id: i64 = 0,
    _original_delta_x: f32 = 0.0,
    _original_delta_y: f32 = 0.0,
    _coalesced_to_trace_id: i64 = 0,
    _provided_to_compositor_delta_x: f32 = 0.0,
    _provided_to_compositor_delta_y: f32 = 0.0,
    _visual_offset_x: i64 = 0,
    _visual_offset_y: i64 = 0,
    _event_count_in_gpu_frame: i32 = 0,
    _trace_ids_in_gpu_frame_offset: ?usize = null,
    _trace_ids_in_gpu_frame_last_offset: ?usize = null,
    _trace_ids_in_gpu_frame_packed: bool = false,
    _original_delta_in_gpu_frame_y: f32 = 0.0,
    _predicted_delta_in_gpu_frame_y: f32 = 0.0,
    _segregated_original_deltas_in_gpu_frame_y_offset: ?usize = null,
    _segregated_original_deltas_in_gpu_frame_y_last_offset: ?usize = null,
    _segregated_original_deltas_in_gpu_frame_y_packed: bool = false,
    _segregated_predicted_deltas_in_gpu_frame_y_offset: ?usize = null,
    _segregated_predicted_deltas_in_gpu_frame_y_last_offset: ?usize = null,
    _segregated_predicted_deltas_in_gpu_frame_y_packed: bool = false,
    _did_overscroll_root: bool = false,
    _unused_delta_x: f32 = 0.0,
    _unused_delta_y: f32 = 0.0,
    pub fn init(src: []const u8) gremlin.Error!ScrollDeltasReader {
        const buf = gremlin.Reader.init(src);
        var res = ScrollDeltasReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ScrollDeltasWire.TRACE_ID_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._trace_id = result.value;
                },
                ScrollDeltasWire.ORIGINAL_DELTA_X_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._original_delta_x = result.value;
                },
                ScrollDeltasWire.ORIGINAL_DELTA_Y_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._original_delta_y = result.value;
                },
                ScrollDeltasWire.COALESCED_TO_TRACE_ID_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._coalesced_to_trace_id = result.value;
                },
                ScrollDeltasWire.PROVIDED_TO_COMPOSITOR_DELTA_X_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._provided_to_compositor_delta_x = result.value;
                },
                ScrollDeltasWire.PROVIDED_TO_COMPOSITOR_DELTA_Y_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._provided_to_compositor_delta_y = result.value;
                },
                ScrollDeltasWire.VISUAL_OFFSET_X_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._visual_offset_x = result.value;
                },
                ScrollDeltasWire.VISUAL_OFFSET_Y_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._visual_offset_y = result.value;
                },
                ScrollDeltasWire.EVENT_COUNT_IN_GPU_FRAME_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._event_count_in_gpu_frame = result.value;
                },
                ScrollDeltasWire.TRACE_IDS_IN_GPU_FRAME_WIRE => {
                    if (res._trace_ids_in_gpu_frame_offset == null) {
                        res._trace_ids_in_gpu_frame_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._trace_ids_in_gpu_frame_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._trace_ids_in_gpu_frame_offset = offset + length_result.size;
                        res._trace_ids_in_gpu_frame_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._trace_ids_in_gpu_frame_last_offset.?;
                    } else {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._trace_ids_in_gpu_frame_last_offset = offset;
                    }
                },
                ScrollDeltasWire.ORIGINAL_DELTA_IN_GPU_FRAME_Y_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._original_delta_in_gpu_frame_y = result.value;
                },
                ScrollDeltasWire.PREDICTED_DELTA_IN_GPU_FRAME_Y_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._predicted_delta_in_gpu_frame_y = result.value;
                },
                ScrollDeltasWire.SEGREGATED_ORIGINAL_DELTAS_IN_GPU_FRAME_Y_WIRE => {
                    if (res._segregated_original_deltas_in_gpu_frame_y_offset == null) {
                        res._segregated_original_deltas_in_gpu_frame_y_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._segregated_original_deltas_in_gpu_frame_y_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._segregated_original_deltas_in_gpu_frame_y_offset = offset + length_result.size;
                        res._segregated_original_deltas_in_gpu_frame_y_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._segregated_original_deltas_in_gpu_frame_y_last_offset.?;
                    } else {
                        const result = try buf.readFloat32(offset);
                        offset += result.size;
                        res._segregated_original_deltas_in_gpu_frame_y_last_offset = offset;
                    }
                },
                ScrollDeltasWire.SEGREGATED_PREDICTED_DELTAS_IN_GPU_FRAME_Y_WIRE => {
                    if (res._segregated_predicted_deltas_in_gpu_frame_y_offset == null) {
                        res._segregated_predicted_deltas_in_gpu_frame_y_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._segregated_predicted_deltas_in_gpu_frame_y_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._segregated_predicted_deltas_in_gpu_frame_y_offset = offset + length_result.size;
                        res._segregated_predicted_deltas_in_gpu_frame_y_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._segregated_predicted_deltas_in_gpu_frame_y_last_offset.?;
                    } else {
                        const result = try buf.readFloat32(offset);
                        offset += result.size;
                        res._segregated_predicted_deltas_in_gpu_frame_y_last_offset = offset;
                    }
                },
                ScrollDeltasWire.DID_OVERSCROLL_ROOT_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._did_overscroll_root = result.value;
                },
                ScrollDeltasWire.UNUSED_DELTA_X_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._unused_delta_x = result.value;
                },
                ScrollDeltasWire.UNUSED_DELTA_Y_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._unused_delta_y = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getTraceId(self: *const ScrollDeltasReader) i64 {
        return self._trace_id;
    }
    pub inline fn getOriginalDeltaX(self: *const ScrollDeltasReader) f32 {
        return self._original_delta_x;
    }
    pub inline fn getOriginalDeltaY(self: *const ScrollDeltasReader) f32 {
        return self._original_delta_y;
    }
    pub inline fn getCoalescedToTraceId(self: *const ScrollDeltasReader) i64 {
        return self._coalesced_to_trace_id;
    }
    pub inline fn getProvidedToCompositorDeltaX(self: *const ScrollDeltasReader) f32 {
        return self._provided_to_compositor_delta_x;
    }
    pub inline fn getProvidedToCompositorDeltaY(self: *const ScrollDeltasReader) f32 {
        return self._provided_to_compositor_delta_y;
    }
    pub inline fn getVisualOffsetX(self: *const ScrollDeltasReader) i64 {
        return self._visual_offset_x;
    }
    pub inline fn getVisualOffsetY(self: *const ScrollDeltasReader) i64 {
        return self._visual_offset_y;
    }
    pub inline fn getEventCountInGpuFrame(self: *const ScrollDeltasReader) i32 {
        return self._event_count_in_gpu_frame;
    }
    pub fn traceIdsInGpuFrameNext(self: *ScrollDeltasReader) gremlin.Error!?i64 {
        if (self._trace_ids_in_gpu_frame_offset == null) return null;
        const current_offset = self._trace_ids_in_gpu_frame_offset.?;
        if (current_offset >= self._trace_ids_in_gpu_frame_last_offset.?) {
            self._trace_ids_in_gpu_frame_offset = null;
            return null;
        }
        if (self._trace_ids_in_gpu_frame_packed) {
            const value_result = try self.buf.readInt64(current_offset);
            self._trace_ids_in_gpu_frame_offset = current_offset + value_result.size;
            if (self._trace_ids_in_gpu_frame_offset.? >= self._trace_ids_in_gpu_frame_last_offset.?) {
                self._trace_ids_in_gpu_frame_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._trace_ids_in_gpu_frame_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == ScrollDeltasWire.TRACE_IDS_IN_GPU_FRAME_WIRE) {
                    self._trace_ids_in_gpu_frame_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._trace_ids_in_gpu_frame_offset = null;
            return value_result.value;
        }
    }
    pub inline fn getOriginalDeltaInGpuFrameY(self: *const ScrollDeltasReader) f32 {
        return self._original_delta_in_gpu_frame_y;
    }
    pub inline fn getPredictedDeltaInGpuFrameY(self: *const ScrollDeltasReader) f32 {
        return self._predicted_delta_in_gpu_frame_y;
    }
    pub fn segregatedOriginalDeltasInGpuFrameYNext(self: *ScrollDeltasReader) gremlin.Error!?f32 {
        if (self._segregated_original_deltas_in_gpu_frame_y_offset == null) return null;
        const current_offset = self._segregated_original_deltas_in_gpu_frame_y_offset.?;
        if (current_offset >= self._segregated_original_deltas_in_gpu_frame_y_last_offset.?) {
            self._segregated_original_deltas_in_gpu_frame_y_offset = null;
            return null;
        }
        if (self._segregated_original_deltas_in_gpu_frame_y_packed) {
            const value_result = try self.buf.readFloat32(current_offset);
            self._segregated_original_deltas_in_gpu_frame_y_offset = current_offset + value_result.size;
            if (self._segregated_original_deltas_in_gpu_frame_y_offset.? >= self._segregated_original_deltas_in_gpu_frame_y_last_offset.?) {
                self._segregated_original_deltas_in_gpu_frame_y_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readFloat32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._segregated_original_deltas_in_gpu_frame_y_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == ScrollDeltasWire.SEGREGATED_ORIGINAL_DELTAS_IN_GPU_FRAME_Y_WIRE) {
                    self._segregated_original_deltas_in_gpu_frame_y_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._segregated_original_deltas_in_gpu_frame_y_offset = null;
            return value_result.value;
        }
    }
    pub fn segregatedPredictedDeltasInGpuFrameYNext(self: *ScrollDeltasReader) gremlin.Error!?f32 {
        if (self._segregated_predicted_deltas_in_gpu_frame_y_offset == null) return null;
        const current_offset = self._segregated_predicted_deltas_in_gpu_frame_y_offset.?;
        if (current_offset >= self._segregated_predicted_deltas_in_gpu_frame_y_last_offset.?) {
            self._segregated_predicted_deltas_in_gpu_frame_y_offset = null;
            return null;
        }
        if (self._segregated_predicted_deltas_in_gpu_frame_y_packed) {
            const value_result = try self.buf.readFloat32(current_offset);
            self._segregated_predicted_deltas_in_gpu_frame_y_offset = current_offset + value_result.size;
            if (self._segregated_predicted_deltas_in_gpu_frame_y_offset.? >= self._segregated_predicted_deltas_in_gpu_frame_y_last_offset.?) {
                self._segregated_predicted_deltas_in_gpu_frame_y_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readFloat32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._segregated_predicted_deltas_in_gpu_frame_y_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == ScrollDeltasWire.SEGREGATED_PREDICTED_DELTAS_IN_GPU_FRAME_Y_WIRE) {
                    self._segregated_predicted_deltas_in_gpu_frame_y_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._segregated_predicted_deltas_in_gpu_frame_y_offset = null;
            return value_result.value;
        }
    }
    pub inline fn getDidOverscrollRoot(self: *const ScrollDeltasReader) bool {
        return self._did_overscroll_root;
    }
    pub inline fn getUnusedDeltaX(self: *const ScrollDeltasReader) f32 {
        return self._unused_delta_x;
    }
    pub inline fn getUnusedDeltaY(self: *const ScrollDeltasReader) f32 {
        return self._unused_delta_y;
    }
};
const WinRenderAudioFromSourceWire = struct {
    const IAUDIOCLIENT_BUFFER_SIZE_FRAMES_WIRE: gremlin.ProtoWireNumber = 1;
    const IAUDIOCLIENT_BUFFER_UNFILLED_FRAMES_WIRE: gremlin.ProtoWireNumber = 2;
    const PACKET_SIZE_FRAMES_WIRE: gremlin.ProtoWireNumber = 3;
    const NUM_WRITTEN_FRAMES_WIRE: gremlin.ProtoWireNumber = 4;
    const NUM_PLAYED_OUT_FRAMES_WIRE: gremlin.ProtoWireNumber = 5;
    const IAUDIOCLOCK_DEVICE_FREQUENCY_WIRE: gremlin.ProtoWireNumber = 6;
    const IAUDIOCLOCK_STREAM_POSITION_WIRE: gremlin.ProtoWireNumber = 7;
    const IAUDIOCLOCK_QPC_POSITION_WIRE: gremlin.ProtoWireNumber = 8;
    const IAUDIOCLOCK_STREAM_POSITION_INCREASE_MS_WIRE: gremlin.ProtoWireNumber = 9;
    const IAUDIOCLOCK_QPC_POSITION_INCREASE_MS_WIRE: gremlin.ProtoWireNumber = 10;
    const PLAYOUT_DELAY_MS_WIRE: gremlin.ProtoWireNumber = 11;
};
pub const WinRenderAudioFromSource = struct {
    // fields
    iaudioclient_buffer_size_frames: u32 = 0,
    iaudioclient_buffer_unfilled_frames: u32 = 0,
    packet_size_frames: u32 = 0,
    num_written_frames: u64 = 0,
    num_played_out_frames: u64 = 0,
    iaudioclock_device_frequency: u64 = 0,
    iaudioclock_stream_position: u64 = 0,
    iaudioclock_qpc_position: u64 = 0,
    iaudioclock_stream_position_increase_ms: i64 = 0,
    iaudioclock_qpc_position_increase_ms: i64 = 0,
    playout_delay_ms: i64 = 0,
    pub fn calcProtobufSize(self: *const WinRenderAudioFromSource) usize {
        var res: usize = 0;
        if (self.iaudioclient_buffer_size_frames != 0) {
            res += gremlin.sizes.sizeWireNumber(WinRenderAudioFromSourceWire.IAUDIOCLIENT_BUFFER_SIZE_FRAMES_WIRE) + gremlin.sizes.sizeU32(self.iaudioclient_buffer_size_frames);
        }
        if (self.iaudioclient_buffer_unfilled_frames != 0) {
            res += gremlin.sizes.sizeWireNumber(WinRenderAudioFromSourceWire.IAUDIOCLIENT_BUFFER_UNFILLED_FRAMES_WIRE) + gremlin.sizes.sizeU32(self.iaudioclient_buffer_unfilled_frames);
        }
        if (self.packet_size_frames != 0) {
            res += gremlin.sizes.sizeWireNumber(WinRenderAudioFromSourceWire.PACKET_SIZE_FRAMES_WIRE) + gremlin.sizes.sizeU32(self.packet_size_frames);
        }
        if (self.num_written_frames != 0) {
            res += gremlin.sizes.sizeWireNumber(WinRenderAudioFromSourceWire.NUM_WRITTEN_FRAMES_WIRE) + gremlin.sizes.sizeU64(self.num_written_frames);
        }
        if (self.num_played_out_frames != 0) {
            res += gremlin.sizes.sizeWireNumber(WinRenderAudioFromSourceWire.NUM_PLAYED_OUT_FRAMES_WIRE) + gremlin.sizes.sizeU64(self.num_played_out_frames);
        }
        if (self.iaudioclock_device_frequency != 0) {
            res += gremlin.sizes.sizeWireNumber(WinRenderAudioFromSourceWire.IAUDIOCLOCK_DEVICE_FREQUENCY_WIRE) + gremlin.sizes.sizeU64(self.iaudioclock_device_frequency);
        }
        if (self.iaudioclock_stream_position != 0) {
            res += gremlin.sizes.sizeWireNumber(WinRenderAudioFromSourceWire.IAUDIOCLOCK_STREAM_POSITION_WIRE) + gremlin.sizes.sizeU64(self.iaudioclock_stream_position);
        }
        if (self.iaudioclock_qpc_position != 0) {
            res += gremlin.sizes.sizeWireNumber(WinRenderAudioFromSourceWire.IAUDIOCLOCK_QPC_POSITION_WIRE) + gremlin.sizes.sizeU64(self.iaudioclock_qpc_position);
        }
        if (self.iaudioclock_stream_position_increase_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(WinRenderAudioFromSourceWire.IAUDIOCLOCK_STREAM_POSITION_INCREASE_MS_WIRE) + gremlin.sizes.sizeI64(self.iaudioclock_stream_position_increase_ms);
        }
        if (self.iaudioclock_qpc_position_increase_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(WinRenderAudioFromSourceWire.IAUDIOCLOCK_QPC_POSITION_INCREASE_MS_WIRE) + gremlin.sizes.sizeI64(self.iaudioclock_qpc_position_increase_ms);
        }
        if (self.playout_delay_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(WinRenderAudioFromSourceWire.PLAYOUT_DELAY_MS_WIRE) + gremlin.sizes.sizeI64(self.playout_delay_ms);
        }
        return res;
    }
    pub fn encode(self: *const WinRenderAudioFromSource, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const WinRenderAudioFromSource, target: *gremlin.Writer) void {
        if (self.iaudioclient_buffer_size_frames != 0) {
            target.appendUint32(WinRenderAudioFromSourceWire.IAUDIOCLIENT_BUFFER_SIZE_FRAMES_WIRE, self.iaudioclient_buffer_size_frames);
        }
        if (self.iaudioclient_buffer_unfilled_frames != 0) {
            target.appendUint32(WinRenderAudioFromSourceWire.IAUDIOCLIENT_BUFFER_UNFILLED_FRAMES_WIRE, self.iaudioclient_buffer_unfilled_frames);
        }
        if (self.packet_size_frames != 0) {
            target.appendUint32(WinRenderAudioFromSourceWire.PACKET_SIZE_FRAMES_WIRE, self.packet_size_frames);
        }
        if (self.num_written_frames != 0) {
            target.appendUint64(WinRenderAudioFromSourceWire.NUM_WRITTEN_FRAMES_WIRE, self.num_written_frames);
        }
        if (self.num_played_out_frames != 0) {
            target.appendUint64(WinRenderAudioFromSourceWire.NUM_PLAYED_OUT_FRAMES_WIRE, self.num_played_out_frames);
        }
        if (self.iaudioclock_device_frequency != 0) {
            target.appendUint64(WinRenderAudioFromSourceWire.IAUDIOCLOCK_DEVICE_FREQUENCY_WIRE, self.iaudioclock_device_frequency);
        }
        if (self.iaudioclock_stream_position != 0) {
            target.appendUint64(WinRenderAudioFromSourceWire.IAUDIOCLOCK_STREAM_POSITION_WIRE, self.iaudioclock_stream_position);
        }
        if (self.iaudioclock_qpc_position != 0) {
            target.appendUint64(WinRenderAudioFromSourceWire.IAUDIOCLOCK_QPC_POSITION_WIRE, self.iaudioclock_qpc_position);
        }
        if (self.iaudioclock_stream_position_increase_ms != 0) {
            target.appendInt64(WinRenderAudioFromSourceWire.IAUDIOCLOCK_STREAM_POSITION_INCREASE_MS_WIRE, self.iaudioclock_stream_position_increase_ms);
        }
        if (self.iaudioclock_qpc_position_increase_ms != 0) {
            target.appendInt64(WinRenderAudioFromSourceWire.IAUDIOCLOCK_QPC_POSITION_INCREASE_MS_WIRE, self.iaudioclock_qpc_position_increase_ms);
        }
        if (self.playout_delay_ms != 0) {
            target.appendInt64(WinRenderAudioFromSourceWire.PLAYOUT_DELAY_MS_WIRE, self.playout_delay_ms);
        }
    }
};
pub const WinRenderAudioFromSourceReader = struct {
    buf: gremlin.Reader,
    _iaudioclient_buffer_size_frames: u32 = 0,
    _iaudioclient_buffer_unfilled_frames: u32 = 0,
    _packet_size_frames: u32 = 0,
    _num_written_frames: u64 = 0,
    _num_played_out_frames: u64 = 0,
    _iaudioclock_device_frequency: u64 = 0,
    _iaudioclock_stream_position: u64 = 0,
    _iaudioclock_qpc_position: u64 = 0,
    _iaudioclock_stream_position_increase_ms: i64 = 0,
    _iaudioclock_qpc_position_increase_ms: i64 = 0,
    _playout_delay_ms: i64 = 0,
    pub fn init(src: []const u8) gremlin.Error!WinRenderAudioFromSourceReader {
        const buf = gremlin.Reader.init(src);
        var res = WinRenderAudioFromSourceReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                WinRenderAudioFromSourceWire.IAUDIOCLIENT_BUFFER_SIZE_FRAMES_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._iaudioclient_buffer_size_frames = result.value;
                },
                WinRenderAudioFromSourceWire.IAUDIOCLIENT_BUFFER_UNFILLED_FRAMES_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._iaudioclient_buffer_unfilled_frames = result.value;
                },
                WinRenderAudioFromSourceWire.PACKET_SIZE_FRAMES_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._packet_size_frames = result.value;
                },
                WinRenderAudioFromSourceWire.NUM_WRITTEN_FRAMES_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._num_written_frames = result.value;
                },
                WinRenderAudioFromSourceWire.NUM_PLAYED_OUT_FRAMES_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._num_played_out_frames = result.value;
                },
                WinRenderAudioFromSourceWire.IAUDIOCLOCK_DEVICE_FREQUENCY_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._iaudioclock_device_frequency = result.value;
                },
                WinRenderAudioFromSourceWire.IAUDIOCLOCK_STREAM_POSITION_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._iaudioclock_stream_position = result.value;
                },
                WinRenderAudioFromSourceWire.IAUDIOCLOCK_QPC_POSITION_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._iaudioclock_qpc_position = result.value;
                },
                WinRenderAudioFromSourceWire.IAUDIOCLOCK_STREAM_POSITION_INCREASE_MS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._iaudioclock_stream_position_increase_ms = result.value;
                },
                WinRenderAudioFromSourceWire.IAUDIOCLOCK_QPC_POSITION_INCREASE_MS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._iaudioclock_qpc_position_increase_ms = result.value;
                },
                WinRenderAudioFromSourceWire.PLAYOUT_DELAY_MS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._playout_delay_ms = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getIaudioclientBufferSizeFrames(self: *const WinRenderAudioFromSourceReader) u32 {
        return self._iaudioclient_buffer_size_frames;
    }
    pub inline fn getIaudioclientBufferUnfilledFrames(self: *const WinRenderAudioFromSourceReader) u32 {
        return self._iaudioclient_buffer_unfilled_frames;
    }
    pub inline fn getPacketSizeFrames(self: *const WinRenderAudioFromSourceReader) u32 {
        return self._packet_size_frames;
    }
    pub inline fn getNumWrittenFrames(self: *const WinRenderAudioFromSourceReader) u64 {
        return self._num_written_frames;
    }
    pub inline fn getNumPlayedOutFrames(self: *const WinRenderAudioFromSourceReader) u64 {
        return self._num_played_out_frames;
    }
    pub inline fn getIaudioclockDeviceFrequency(self: *const WinRenderAudioFromSourceReader) u64 {
        return self._iaudioclock_device_frequency;
    }
    pub inline fn getIaudioclockStreamPosition(self: *const WinRenderAudioFromSourceReader) u64 {
        return self._iaudioclock_stream_position;
    }
    pub inline fn getIaudioclockQpcPosition(self: *const WinRenderAudioFromSourceReader) u64 {
        return self._iaudioclock_qpc_position;
    }
    pub inline fn getIaudioclockStreamPositionIncreaseMs(self: *const WinRenderAudioFromSourceReader) i64 {
        return self._iaudioclock_stream_position_increase_ms;
    }
    pub inline fn getIaudioclockQpcPositionIncreaseMs(self: *const WinRenderAudioFromSourceReader) i64 {
        return self._iaudioclock_qpc_position_increase_ms;
    }
    pub inline fn getPlayoutDelayMs(self: *const WinRenderAudioFromSourceReader) i64 {
        return self._playout_delay_ms;
    }
};
const MacAUHALStreamWire = struct {
    const INPUT_BUFFER_SIZE_WIRE: gremlin.ProtoWireNumber = 1;
    const OUTPUT_BUFFER_SIZE_WIRE: gremlin.ProtoWireNumber = 2;
    const SAMPLE_RATE_WIRE: gremlin.ProtoWireNumber = 3;
    const OS_REQUEST_PLAYOUT_TIMETICKS_US_WIRE: gremlin.ProtoWireNumber = 4;
    const SOURCE_REQUEST_FRAMES_WIRE: gremlin.ProtoWireNumber = 5;
    const SOURCE_REQUEST_PLAYOUT_DELAY_US_WIRE: gremlin.ProtoWireNumber = 6;
    const SOURCE_REQUEST_PLAYOUT_TIMETICKS_US_WIRE: gremlin.ProtoWireNumber = 7;
    const SOURCE_REQUEST_CURRENT_TIMETICKS_US_WIRE: gremlin.ProtoWireNumber = 8;
    const HARDWARE_LATENCY_US_WIRE: gremlin.ProtoWireNumber = 9;
    const AUDIOTIMESTAMP_HOST_TIME_VALID_WIRE: gremlin.ProtoWireNumber = 10;
    const AUDIOTIMESTAMP_MACH_TIMETICKS_US_WIRE: gremlin.ProtoWireNumber = 11;
    const AUDIOTIMESTAMP_SAMPLE_TIME_FRAMES_WIRE: gremlin.ProtoWireNumber = 12;
    const AUDIOTIMESTAMP_LAST_SAMPLE_TIME_FRAMES_WIRE: gremlin.ProtoWireNumber = 13;
    const LOST_AUDIO_DURATION_US_WIRE: gremlin.ProtoWireNumber = 14;
};
pub const MacAUHALStream = struct {
    // fields
    input_buffer_size: i32 = 0,
    output_buffer_size: u32 = 0,
    sample_rate: i32 = 0,
    os_request_playout_timeticks_us: i64 = 0,
    source_request_frames: i32 = 0,
    source_request_playout_delay_us: i64 = 0,
    source_request_playout_timeticks_us: i64 = 0,
    source_request_current_timeticks_us: i64 = 0,
    hardware_latency_us: i64 = 0,
    audiotimestamp_host_time_valid: bool = false,
    audiotimestamp_mach_timeticks_us: i64 = 0,
    audiotimestamp_sample_time_frames: f64 = 0.0,
    audiotimestamp_last_sample_time_frames: f64 = 0.0,
    lost_audio_duration_us: i64 = 0,
    pub fn calcProtobufSize(self: *const MacAUHALStream) usize {
        var res: usize = 0;
        if (self.input_buffer_size != 0) {
            res += gremlin.sizes.sizeWireNumber(MacAUHALStreamWire.INPUT_BUFFER_SIZE_WIRE) + gremlin.sizes.sizeI32(self.input_buffer_size);
        }
        if (self.output_buffer_size != 0) {
            res += gremlin.sizes.sizeWireNumber(MacAUHALStreamWire.OUTPUT_BUFFER_SIZE_WIRE) + gremlin.sizes.sizeU32(self.output_buffer_size);
        }
        if (self.sample_rate != 0) {
            res += gremlin.sizes.sizeWireNumber(MacAUHALStreamWire.SAMPLE_RATE_WIRE) + gremlin.sizes.sizeI32(self.sample_rate);
        }
        if (self.os_request_playout_timeticks_us != 0) {
            res += gremlin.sizes.sizeWireNumber(MacAUHALStreamWire.OS_REQUEST_PLAYOUT_TIMETICKS_US_WIRE) + gremlin.sizes.sizeI64(self.os_request_playout_timeticks_us);
        }
        if (self.source_request_frames != 0) {
            res += gremlin.sizes.sizeWireNumber(MacAUHALStreamWire.SOURCE_REQUEST_FRAMES_WIRE) + gremlin.sizes.sizeI32(self.source_request_frames);
        }
        if (self.source_request_playout_delay_us != 0) {
            res += gremlin.sizes.sizeWireNumber(MacAUHALStreamWire.SOURCE_REQUEST_PLAYOUT_DELAY_US_WIRE) + gremlin.sizes.sizeI64(self.source_request_playout_delay_us);
        }
        if (self.source_request_playout_timeticks_us != 0) {
            res += gremlin.sizes.sizeWireNumber(MacAUHALStreamWire.SOURCE_REQUEST_PLAYOUT_TIMETICKS_US_WIRE) + gremlin.sizes.sizeI64(self.source_request_playout_timeticks_us);
        }
        if (self.source_request_current_timeticks_us != 0) {
            res += gremlin.sizes.sizeWireNumber(MacAUHALStreamWire.SOURCE_REQUEST_CURRENT_TIMETICKS_US_WIRE) + gremlin.sizes.sizeI64(self.source_request_current_timeticks_us);
        }
        if (self.hardware_latency_us != 0) {
            res += gremlin.sizes.sizeWireNumber(MacAUHALStreamWire.HARDWARE_LATENCY_US_WIRE) + gremlin.sizes.sizeI64(self.hardware_latency_us);
        }
        if (self.audiotimestamp_host_time_valid != false) {
            res += gremlin.sizes.sizeWireNumber(MacAUHALStreamWire.AUDIOTIMESTAMP_HOST_TIME_VALID_WIRE) + gremlin.sizes.sizeBool(self.audiotimestamp_host_time_valid);
        }
        if (self.audiotimestamp_mach_timeticks_us != 0) {
            res += gremlin.sizes.sizeWireNumber(MacAUHALStreamWire.AUDIOTIMESTAMP_MACH_TIMETICKS_US_WIRE) + gremlin.sizes.sizeI64(self.audiotimestamp_mach_timeticks_us);
        }
        if (self.audiotimestamp_sample_time_frames != 0.0) {
            res += gremlin.sizes.sizeWireNumber(MacAUHALStreamWire.AUDIOTIMESTAMP_SAMPLE_TIME_FRAMES_WIRE) + gremlin.sizes.sizeDouble(self.audiotimestamp_sample_time_frames);
        }
        if (self.audiotimestamp_last_sample_time_frames != 0.0) {
            res += gremlin.sizes.sizeWireNumber(MacAUHALStreamWire.AUDIOTIMESTAMP_LAST_SAMPLE_TIME_FRAMES_WIRE) + gremlin.sizes.sizeDouble(self.audiotimestamp_last_sample_time_frames);
        }
        if (self.lost_audio_duration_us != 0) {
            res += gremlin.sizes.sizeWireNumber(MacAUHALStreamWire.LOST_AUDIO_DURATION_US_WIRE) + gremlin.sizes.sizeI64(self.lost_audio_duration_us);
        }
        return res;
    }
    pub fn encode(self: *const MacAUHALStream, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const MacAUHALStream, target: *gremlin.Writer) void {
        if (self.input_buffer_size != 0) {
            target.appendInt32(MacAUHALStreamWire.INPUT_BUFFER_SIZE_WIRE, self.input_buffer_size);
        }
        if (self.output_buffer_size != 0) {
            target.appendUint32(MacAUHALStreamWire.OUTPUT_BUFFER_SIZE_WIRE, self.output_buffer_size);
        }
        if (self.sample_rate != 0) {
            target.appendInt32(MacAUHALStreamWire.SAMPLE_RATE_WIRE, self.sample_rate);
        }
        if (self.os_request_playout_timeticks_us != 0) {
            target.appendInt64(MacAUHALStreamWire.OS_REQUEST_PLAYOUT_TIMETICKS_US_WIRE, self.os_request_playout_timeticks_us);
        }
        if (self.source_request_frames != 0) {
            target.appendInt32(MacAUHALStreamWire.SOURCE_REQUEST_FRAMES_WIRE, self.source_request_frames);
        }
        if (self.source_request_playout_delay_us != 0) {
            target.appendInt64(MacAUHALStreamWire.SOURCE_REQUEST_PLAYOUT_DELAY_US_WIRE, self.source_request_playout_delay_us);
        }
        if (self.source_request_playout_timeticks_us != 0) {
            target.appendInt64(MacAUHALStreamWire.SOURCE_REQUEST_PLAYOUT_TIMETICKS_US_WIRE, self.source_request_playout_timeticks_us);
        }
        if (self.source_request_current_timeticks_us != 0) {
            target.appendInt64(MacAUHALStreamWire.SOURCE_REQUEST_CURRENT_TIMETICKS_US_WIRE, self.source_request_current_timeticks_us);
        }
        if (self.hardware_latency_us != 0) {
            target.appendInt64(MacAUHALStreamWire.HARDWARE_LATENCY_US_WIRE, self.hardware_latency_us);
        }
        if (self.audiotimestamp_host_time_valid != false) {
            target.appendBool(MacAUHALStreamWire.AUDIOTIMESTAMP_HOST_TIME_VALID_WIRE, self.audiotimestamp_host_time_valid);
        }
        if (self.audiotimestamp_mach_timeticks_us != 0) {
            target.appendInt64(MacAUHALStreamWire.AUDIOTIMESTAMP_MACH_TIMETICKS_US_WIRE, self.audiotimestamp_mach_timeticks_us);
        }
        if (self.audiotimestamp_sample_time_frames != 0.0) {
            target.appendFloat64(MacAUHALStreamWire.AUDIOTIMESTAMP_SAMPLE_TIME_FRAMES_WIRE, self.audiotimestamp_sample_time_frames);
        }
        if (self.audiotimestamp_last_sample_time_frames != 0.0) {
            target.appendFloat64(MacAUHALStreamWire.AUDIOTIMESTAMP_LAST_SAMPLE_TIME_FRAMES_WIRE, self.audiotimestamp_last_sample_time_frames);
        }
        if (self.lost_audio_duration_us != 0) {
            target.appendInt64(MacAUHALStreamWire.LOST_AUDIO_DURATION_US_WIRE, self.lost_audio_duration_us);
        }
    }
};
pub const MacAUHALStreamReader = struct {
    buf: gremlin.Reader,
    _input_buffer_size: i32 = 0,
    _output_buffer_size: u32 = 0,
    _sample_rate: i32 = 0,
    _os_request_playout_timeticks_us: i64 = 0,
    _source_request_frames: i32 = 0,
    _source_request_playout_delay_us: i64 = 0,
    _source_request_playout_timeticks_us: i64 = 0,
    _source_request_current_timeticks_us: i64 = 0,
    _hardware_latency_us: i64 = 0,
    _audiotimestamp_host_time_valid: bool = false,
    _audiotimestamp_mach_timeticks_us: i64 = 0,
    _audiotimestamp_sample_time_frames: f64 = 0.0,
    _audiotimestamp_last_sample_time_frames: f64 = 0.0,
    _lost_audio_duration_us: i64 = 0,
    pub fn init(src: []const u8) gremlin.Error!MacAUHALStreamReader {
        const buf = gremlin.Reader.init(src);
        var res = MacAUHALStreamReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MacAUHALStreamWire.INPUT_BUFFER_SIZE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._input_buffer_size = result.value;
                },
                MacAUHALStreamWire.OUTPUT_BUFFER_SIZE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._output_buffer_size = result.value;
                },
                MacAUHALStreamWire.SAMPLE_RATE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._sample_rate = result.value;
                },
                MacAUHALStreamWire.OS_REQUEST_PLAYOUT_TIMETICKS_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._os_request_playout_timeticks_us = result.value;
                },
                MacAUHALStreamWire.SOURCE_REQUEST_FRAMES_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._source_request_frames = result.value;
                },
                MacAUHALStreamWire.SOURCE_REQUEST_PLAYOUT_DELAY_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._source_request_playout_delay_us = result.value;
                },
                MacAUHALStreamWire.SOURCE_REQUEST_PLAYOUT_TIMETICKS_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._source_request_playout_timeticks_us = result.value;
                },
                MacAUHALStreamWire.SOURCE_REQUEST_CURRENT_TIMETICKS_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._source_request_current_timeticks_us = result.value;
                },
                MacAUHALStreamWire.HARDWARE_LATENCY_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._hardware_latency_us = result.value;
                },
                MacAUHALStreamWire.AUDIOTIMESTAMP_HOST_TIME_VALID_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._audiotimestamp_host_time_valid = result.value;
                },
                MacAUHALStreamWire.AUDIOTIMESTAMP_MACH_TIMETICKS_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._audiotimestamp_mach_timeticks_us = result.value;
                },
                MacAUHALStreamWire.AUDIOTIMESTAMP_SAMPLE_TIME_FRAMES_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._audiotimestamp_sample_time_frames = result.value;
                },
                MacAUHALStreamWire.AUDIOTIMESTAMP_LAST_SAMPLE_TIME_FRAMES_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._audiotimestamp_last_sample_time_frames = result.value;
                },
                MacAUHALStreamWire.LOST_AUDIO_DURATION_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._lost_audio_duration_us = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getInputBufferSize(self: *const MacAUHALStreamReader) i32 {
        return self._input_buffer_size;
    }
    pub inline fn getOutputBufferSize(self: *const MacAUHALStreamReader) u32 {
        return self._output_buffer_size;
    }
    pub inline fn getSampleRate(self: *const MacAUHALStreamReader) i32 {
        return self._sample_rate;
    }
    pub inline fn getOsRequestPlayoutTimeticksUs(self: *const MacAUHALStreamReader) i64 {
        return self._os_request_playout_timeticks_us;
    }
    pub inline fn getSourceRequestFrames(self: *const MacAUHALStreamReader) i32 {
        return self._source_request_frames;
    }
    pub inline fn getSourceRequestPlayoutDelayUs(self: *const MacAUHALStreamReader) i64 {
        return self._source_request_playout_delay_us;
    }
    pub inline fn getSourceRequestPlayoutTimeticksUs(self: *const MacAUHALStreamReader) i64 {
        return self._source_request_playout_timeticks_us;
    }
    pub inline fn getSourceRequestCurrentTimeticksUs(self: *const MacAUHALStreamReader) i64 {
        return self._source_request_current_timeticks_us;
    }
    pub inline fn getHardwareLatencyUs(self: *const MacAUHALStreamReader) i64 {
        return self._hardware_latency_us;
    }
    pub inline fn getAudiotimestampHostTimeValid(self: *const MacAUHALStreamReader) bool {
        return self._audiotimestamp_host_time_valid;
    }
    pub inline fn getAudiotimestampMachTimeticksUs(self: *const MacAUHALStreamReader) i64 {
        return self._audiotimestamp_mach_timeticks_us;
    }
    pub inline fn getAudiotimestampSampleTimeFrames(self: *const MacAUHALStreamReader) f64 {
        return self._audiotimestamp_sample_time_frames;
    }
    pub inline fn getAudiotimestampLastSampleTimeFrames(self: *const MacAUHALStreamReader) f64 {
        return self._audiotimestamp_last_sample_time_frames;
    }
    pub inline fn getLostAudioDurationUs(self: *const MacAUHALStreamReader) i64 {
        return self._lost_audio_duration_us;
    }
};
const LinuxAlsaOutputWire = struct {
    const SOURCE_REQUEST_PLAYOUT_DELAY_US_WIRE: gremlin.ProtoWireNumber = 1;
    const FORWARD_BYTES_WIRE: gremlin.ProtoWireNumber = 2;
    const SAMPLE_RATE_WIRE: gremlin.ProtoWireNumber = 3;
    const GETCURRENTDELAY_PCM_DELAY_FRAMES_WIRE: gremlin.ProtoWireNumber = 4;
    const GETCURRENTDELAY_ALSA_BUFFER_FRAMES_WIRE: gremlin.ProtoWireNumber = 5;
    const GETCURRENTDELAY_AVAILABLE_FRAMES_WIRE: gremlin.ProtoWireNumber = 6;
    const GETCURRENTDELAY_FINAL_DELAY_FRAMES_WIRE: gremlin.ProtoWireNumber = 7;
};
pub const LinuxAlsaOutput = struct {
    // fields
    source_request_playout_delay_us: i64 = 0,
    forward_bytes: i32 = 0,
    sample_rate: i32 = 0,
    getcurrentdelay_pcm_delay_frames: i32 = 0,
    getcurrentdelay_alsa_buffer_frames: i32 = 0,
    getcurrentdelay_available_frames: i32 = 0,
    getcurrentdelay_final_delay_frames: i32 = 0,
    pub fn calcProtobufSize(self: *const LinuxAlsaOutput) usize {
        var res: usize = 0;
        if (self.source_request_playout_delay_us != 0) {
            res += gremlin.sizes.sizeWireNumber(LinuxAlsaOutputWire.SOURCE_REQUEST_PLAYOUT_DELAY_US_WIRE) + gremlin.sizes.sizeI64(self.source_request_playout_delay_us);
        }
        if (self.forward_bytes != 0) {
            res += gremlin.sizes.sizeWireNumber(LinuxAlsaOutputWire.FORWARD_BYTES_WIRE) + gremlin.sizes.sizeI32(self.forward_bytes);
        }
        if (self.sample_rate != 0) {
            res += gremlin.sizes.sizeWireNumber(LinuxAlsaOutputWire.SAMPLE_RATE_WIRE) + gremlin.sizes.sizeI32(self.sample_rate);
        }
        if (self.getcurrentdelay_pcm_delay_frames != 0) {
            res += gremlin.sizes.sizeWireNumber(LinuxAlsaOutputWire.GETCURRENTDELAY_PCM_DELAY_FRAMES_WIRE) + gremlin.sizes.sizeI32(self.getcurrentdelay_pcm_delay_frames);
        }
        if (self.getcurrentdelay_alsa_buffer_frames != 0) {
            res += gremlin.sizes.sizeWireNumber(LinuxAlsaOutputWire.GETCURRENTDELAY_ALSA_BUFFER_FRAMES_WIRE) + gremlin.sizes.sizeI32(self.getcurrentdelay_alsa_buffer_frames);
        }
        if (self.getcurrentdelay_available_frames != 0) {
            res += gremlin.sizes.sizeWireNumber(LinuxAlsaOutputWire.GETCURRENTDELAY_AVAILABLE_FRAMES_WIRE) + gremlin.sizes.sizeI32(self.getcurrentdelay_available_frames);
        }
        if (self.getcurrentdelay_final_delay_frames != 0) {
            res += gremlin.sizes.sizeWireNumber(LinuxAlsaOutputWire.GETCURRENTDELAY_FINAL_DELAY_FRAMES_WIRE) + gremlin.sizes.sizeI32(self.getcurrentdelay_final_delay_frames);
        }
        return res;
    }
    pub fn encode(self: *const LinuxAlsaOutput, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const LinuxAlsaOutput, target: *gremlin.Writer) void {
        if (self.source_request_playout_delay_us != 0) {
            target.appendInt64(LinuxAlsaOutputWire.SOURCE_REQUEST_PLAYOUT_DELAY_US_WIRE, self.source_request_playout_delay_us);
        }
        if (self.forward_bytes != 0) {
            target.appendInt32(LinuxAlsaOutputWire.FORWARD_BYTES_WIRE, self.forward_bytes);
        }
        if (self.sample_rate != 0) {
            target.appendInt32(LinuxAlsaOutputWire.SAMPLE_RATE_WIRE, self.sample_rate);
        }
        if (self.getcurrentdelay_pcm_delay_frames != 0) {
            target.appendInt32(LinuxAlsaOutputWire.GETCURRENTDELAY_PCM_DELAY_FRAMES_WIRE, self.getcurrentdelay_pcm_delay_frames);
        }
        if (self.getcurrentdelay_alsa_buffer_frames != 0) {
            target.appendInt32(LinuxAlsaOutputWire.GETCURRENTDELAY_ALSA_BUFFER_FRAMES_WIRE, self.getcurrentdelay_alsa_buffer_frames);
        }
        if (self.getcurrentdelay_available_frames != 0) {
            target.appendInt32(LinuxAlsaOutputWire.GETCURRENTDELAY_AVAILABLE_FRAMES_WIRE, self.getcurrentdelay_available_frames);
        }
        if (self.getcurrentdelay_final_delay_frames != 0) {
            target.appendInt32(LinuxAlsaOutputWire.GETCURRENTDELAY_FINAL_DELAY_FRAMES_WIRE, self.getcurrentdelay_final_delay_frames);
        }
    }
};
pub const LinuxAlsaOutputReader = struct {
    buf: gremlin.Reader,
    _source_request_playout_delay_us: i64 = 0,
    _forward_bytes: i32 = 0,
    _sample_rate: i32 = 0,
    _getcurrentdelay_pcm_delay_frames: i32 = 0,
    _getcurrentdelay_alsa_buffer_frames: i32 = 0,
    _getcurrentdelay_available_frames: i32 = 0,
    _getcurrentdelay_final_delay_frames: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!LinuxAlsaOutputReader {
        const buf = gremlin.Reader.init(src);
        var res = LinuxAlsaOutputReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                LinuxAlsaOutputWire.SOURCE_REQUEST_PLAYOUT_DELAY_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._source_request_playout_delay_us = result.value;
                },
                LinuxAlsaOutputWire.FORWARD_BYTES_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._forward_bytes = result.value;
                },
                LinuxAlsaOutputWire.SAMPLE_RATE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._sample_rate = result.value;
                },
                LinuxAlsaOutputWire.GETCURRENTDELAY_PCM_DELAY_FRAMES_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._getcurrentdelay_pcm_delay_frames = result.value;
                },
                LinuxAlsaOutputWire.GETCURRENTDELAY_ALSA_BUFFER_FRAMES_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._getcurrentdelay_alsa_buffer_frames = result.value;
                },
                LinuxAlsaOutputWire.GETCURRENTDELAY_AVAILABLE_FRAMES_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._getcurrentdelay_available_frames = result.value;
                },
                LinuxAlsaOutputWire.GETCURRENTDELAY_FINAL_DELAY_FRAMES_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._getcurrentdelay_final_delay_frames = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getSourceRequestPlayoutDelayUs(self: *const LinuxAlsaOutputReader) i64 {
        return self._source_request_playout_delay_us;
    }
    pub inline fn getForwardBytes(self: *const LinuxAlsaOutputReader) i32 {
        return self._forward_bytes;
    }
    pub inline fn getSampleRate(self: *const LinuxAlsaOutputReader) i32 {
        return self._sample_rate;
    }
    pub inline fn getGetcurrentdelayPcmDelayFrames(self: *const LinuxAlsaOutputReader) i32 {
        return self._getcurrentdelay_pcm_delay_frames;
    }
    pub inline fn getGetcurrentdelayAlsaBufferFrames(self: *const LinuxAlsaOutputReader) i32 {
        return self._getcurrentdelay_alsa_buffer_frames;
    }
    pub inline fn getGetcurrentdelayAvailableFrames(self: *const LinuxAlsaOutputReader) i32 {
        return self._getcurrentdelay_available_frames;
    }
    pub inline fn getGetcurrentdelayFinalDelayFrames(self: *const LinuxAlsaOutputReader) i32 {
        return self._getcurrentdelay_final_delay_frames;
    }
};
const LinuxPulseOutputWire = struct {
    const SOURCE_REQUEST_PLAYOUT_DELAY_US_WIRE: gremlin.ProtoWireNumber = 1;
    const SAMPLE_RATE_WIRE: gremlin.ProtoWireNumber = 2;
    const INPUT_BUFFER_SIZE_FRAMES_WIRE: gremlin.ProtoWireNumber = 3;
    const STREAM_REQUEST_BYTES_WIRE: gremlin.ProtoWireNumber = 4;
    const FRAME_SIZE_BYTES_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const LinuxPulseOutput = struct {
    // fields
    source_request_playout_delay_us: i64 = 0,
    sample_rate: i32 = 0,
    input_buffer_size_frames: i32 = 0,
    stream_request_bytes: u32 = 0,
    frame_size_bytes: u32 = 0,
    pub fn calcProtobufSize(self: *const LinuxPulseOutput) usize {
        var res: usize = 0;
        if (self.source_request_playout_delay_us != 0) {
            res += gremlin.sizes.sizeWireNumber(LinuxPulseOutputWire.SOURCE_REQUEST_PLAYOUT_DELAY_US_WIRE) + gremlin.sizes.sizeI64(self.source_request_playout_delay_us);
        }
        if (self.sample_rate != 0) {
            res += gremlin.sizes.sizeWireNumber(LinuxPulseOutputWire.SAMPLE_RATE_WIRE) + gremlin.sizes.sizeI32(self.sample_rate);
        }
        if (self.input_buffer_size_frames != 0) {
            res += gremlin.sizes.sizeWireNumber(LinuxPulseOutputWire.INPUT_BUFFER_SIZE_FRAMES_WIRE) + gremlin.sizes.sizeI32(self.input_buffer_size_frames);
        }
        if (self.stream_request_bytes != 0) {
            res += gremlin.sizes.sizeWireNumber(LinuxPulseOutputWire.STREAM_REQUEST_BYTES_WIRE) + gremlin.sizes.sizeU32(self.stream_request_bytes);
        }
        if (self.frame_size_bytes != 0) {
            res += gremlin.sizes.sizeWireNumber(LinuxPulseOutputWire.FRAME_SIZE_BYTES_WIRE) + gremlin.sizes.sizeU32(self.frame_size_bytes);
        }
        return res;
    }
    pub fn encode(self: *const LinuxPulseOutput, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const LinuxPulseOutput, target: *gremlin.Writer) void {
        if (self.source_request_playout_delay_us != 0) {
            target.appendInt64(LinuxPulseOutputWire.SOURCE_REQUEST_PLAYOUT_DELAY_US_WIRE, self.source_request_playout_delay_us);
        }
        if (self.sample_rate != 0) {
            target.appendInt32(LinuxPulseOutputWire.SAMPLE_RATE_WIRE, self.sample_rate);
        }
        if (self.input_buffer_size_frames != 0) {
            target.appendInt32(LinuxPulseOutputWire.INPUT_BUFFER_SIZE_FRAMES_WIRE, self.input_buffer_size_frames);
        }
        if (self.stream_request_bytes != 0) {
            target.appendUint32(LinuxPulseOutputWire.STREAM_REQUEST_BYTES_WIRE, self.stream_request_bytes);
        }
        if (self.frame_size_bytes != 0) {
            target.appendUint32(LinuxPulseOutputWire.FRAME_SIZE_BYTES_WIRE, self.frame_size_bytes);
        }
    }
};
pub const LinuxPulseOutputReader = struct {
    buf: gremlin.Reader,
    _source_request_playout_delay_us: i64 = 0,
    _sample_rate: i32 = 0,
    _input_buffer_size_frames: i32 = 0,
    _stream_request_bytes: u32 = 0,
    _frame_size_bytes: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!LinuxPulseOutputReader {
        const buf = gremlin.Reader.init(src);
        var res = LinuxPulseOutputReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                LinuxPulseOutputWire.SOURCE_REQUEST_PLAYOUT_DELAY_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._source_request_playout_delay_us = result.value;
                },
                LinuxPulseOutputWire.SAMPLE_RATE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._sample_rate = result.value;
                },
                LinuxPulseOutputWire.INPUT_BUFFER_SIZE_FRAMES_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._input_buffer_size_frames = result.value;
                },
                LinuxPulseOutputWire.STREAM_REQUEST_BYTES_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._stream_request_bytes = result.value;
                },
                LinuxPulseOutputWire.FRAME_SIZE_BYTES_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._frame_size_bytes = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getSourceRequestPlayoutDelayUs(self: *const LinuxPulseOutputReader) i64 {
        return self._source_request_playout_delay_us;
    }
    pub inline fn getSampleRate(self: *const LinuxPulseOutputReader) i32 {
        return self._sample_rate;
    }
    pub inline fn getInputBufferSizeFrames(self: *const LinuxPulseOutputReader) i32 {
        return self._input_buffer_size_frames;
    }
    pub inline fn getStreamRequestBytes(self: *const LinuxPulseOutputReader) u32 {
        return self._stream_request_bytes;
    }
    pub inline fn getFrameSizeBytes(self: *const LinuxPulseOutputReader) u32 {
        return self._frame_size_bytes;
    }
};
const CrasUnifiedWire = struct {
    const UNDERRUN_DURATION_US_WIRE: gremlin.ProtoWireNumber = 1;
    const LAST_UNDERRUN_DURATION_US_WIRE: gremlin.ProtoWireNumber = 2;
    const UNDERRUN_GLITCH_DURATION_US_WIRE: gremlin.ProtoWireNumber = 3;
    const LATENCY_US_WIRE: gremlin.ProtoWireNumber = 4;
    const REQUESTED_FRAMES_WIRE: gremlin.ProtoWireNumber = 5;
    const FILLED_FRAMES_WIRE: gremlin.ProtoWireNumber = 6;
    const SAMPLE_RATE_WIRE: gremlin.ProtoWireNumber = 7;
};
pub const CrasUnified = struct {
    // fields
    underrun_duration_us: i64 = 0,
    last_underrun_duration_us: i64 = 0,
    underrun_glitch_duration_us: i64 = 0,
    latency_us: i64 = 0,
    requested_frames: i32 = 0,
    filled_frames: u32 = 0,
    sample_rate: i32 = 0,
    pub fn calcProtobufSize(self: *const CrasUnified) usize {
        var res: usize = 0;
        if (self.underrun_duration_us != 0) {
            res += gremlin.sizes.sizeWireNumber(CrasUnifiedWire.UNDERRUN_DURATION_US_WIRE) + gremlin.sizes.sizeI64(self.underrun_duration_us);
        }
        if (self.last_underrun_duration_us != 0) {
            res += gremlin.sizes.sizeWireNumber(CrasUnifiedWire.LAST_UNDERRUN_DURATION_US_WIRE) + gremlin.sizes.sizeI64(self.last_underrun_duration_us);
        }
        if (self.underrun_glitch_duration_us != 0) {
            res += gremlin.sizes.sizeWireNumber(CrasUnifiedWire.UNDERRUN_GLITCH_DURATION_US_WIRE) + gremlin.sizes.sizeI64(self.underrun_glitch_duration_us);
        }
        if (self.latency_us != 0) {
            res += gremlin.sizes.sizeWireNumber(CrasUnifiedWire.LATENCY_US_WIRE) + gremlin.sizes.sizeI64(self.latency_us);
        }
        if (self.requested_frames != 0) {
            res += gremlin.sizes.sizeWireNumber(CrasUnifiedWire.REQUESTED_FRAMES_WIRE) + gremlin.sizes.sizeI32(self.requested_frames);
        }
        if (self.filled_frames != 0) {
            res += gremlin.sizes.sizeWireNumber(CrasUnifiedWire.FILLED_FRAMES_WIRE) + gremlin.sizes.sizeU32(self.filled_frames);
        }
        if (self.sample_rate != 0) {
            res += gremlin.sizes.sizeWireNumber(CrasUnifiedWire.SAMPLE_RATE_WIRE) + gremlin.sizes.sizeI32(self.sample_rate);
        }
        return res;
    }
    pub fn encode(self: *const CrasUnified, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const CrasUnified, target: *gremlin.Writer) void {
        if (self.underrun_duration_us != 0) {
            target.appendInt64(CrasUnifiedWire.UNDERRUN_DURATION_US_WIRE, self.underrun_duration_us);
        }
        if (self.last_underrun_duration_us != 0) {
            target.appendInt64(CrasUnifiedWire.LAST_UNDERRUN_DURATION_US_WIRE, self.last_underrun_duration_us);
        }
        if (self.underrun_glitch_duration_us != 0) {
            target.appendInt64(CrasUnifiedWire.UNDERRUN_GLITCH_DURATION_US_WIRE, self.underrun_glitch_duration_us);
        }
        if (self.latency_us != 0) {
            target.appendInt64(CrasUnifiedWire.LATENCY_US_WIRE, self.latency_us);
        }
        if (self.requested_frames != 0) {
            target.appendInt32(CrasUnifiedWire.REQUESTED_FRAMES_WIRE, self.requested_frames);
        }
        if (self.filled_frames != 0) {
            target.appendUint32(CrasUnifiedWire.FILLED_FRAMES_WIRE, self.filled_frames);
        }
        if (self.sample_rate != 0) {
            target.appendInt32(CrasUnifiedWire.SAMPLE_RATE_WIRE, self.sample_rate);
        }
    }
};
pub const CrasUnifiedReader = struct {
    buf: gremlin.Reader,
    _underrun_duration_us: i64 = 0,
    _last_underrun_duration_us: i64 = 0,
    _underrun_glitch_duration_us: i64 = 0,
    _latency_us: i64 = 0,
    _requested_frames: i32 = 0,
    _filled_frames: u32 = 0,
    _sample_rate: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!CrasUnifiedReader {
        const buf = gremlin.Reader.init(src);
        var res = CrasUnifiedReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                CrasUnifiedWire.UNDERRUN_DURATION_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._underrun_duration_us = result.value;
                },
                CrasUnifiedWire.LAST_UNDERRUN_DURATION_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._last_underrun_duration_us = result.value;
                },
                CrasUnifiedWire.UNDERRUN_GLITCH_DURATION_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._underrun_glitch_duration_us = result.value;
                },
                CrasUnifiedWire.LATENCY_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._latency_us = result.value;
                },
                CrasUnifiedWire.REQUESTED_FRAMES_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._requested_frames = result.value;
                },
                CrasUnifiedWire.FILLED_FRAMES_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._filled_frames = result.value;
                },
                CrasUnifiedWire.SAMPLE_RATE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._sample_rate = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getUnderrunDurationUs(self: *const CrasUnifiedReader) i64 {
        return self._underrun_duration_us;
    }
    pub inline fn getLastUnderrunDurationUs(self: *const CrasUnifiedReader) i64 {
        return self._last_underrun_duration_us;
    }
    pub inline fn getUnderrunGlitchDurationUs(self: *const CrasUnifiedReader) i64 {
        return self._underrun_glitch_duration_us;
    }
    pub inline fn getLatencyUs(self: *const CrasUnifiedReader) i64 {
        return self._latency_us;
    }
    pub inline fn getRequestedFrames(self: *const CrasUnifiedReader) i32 {
        return self._requested_frames;
    }
    pub inline fn getFilledFrames(self: *const CrasUnifiedReader) u32 {
        return self._filled_frames;
    }
    pub inline fn getSampleRate(self: *const CrasUnifiedReader) i32 {
        return self._sample_rate;
    }
};
const ChromeUnguessableTokenWire = struct {
    const LOW_TOKEN_WIRE: gremlin.ProtoWireNumber = 1;
    const HIGH_TOKEN_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const ChromeUnguessableToken = struct {
    // fields
    low_token: u64 = 0,
    high_token: u64 = 0,
    pub fn calcProtobufSize(self: *const ChromeUnguessableToken) usize {
        var res: usize = 0;
        if (self.low_token != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeUnguessableTokenWire.LOW_TOKEN_WIRE) + gremlin.sizes.sizeU64(self.low_token);
        }
        if (self.high_token != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeUnguessableTokenWire.HIGH_TOKEN_WIRE) + gremlin.sizes.sizeU64(self.high_token);
        }
        return res;
    }
    pub fn encode(self: *const ChromeUnguessableToken, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ChromeUnguessableToken, target: *gremlin.Writer) void {
        if (self.low_token != 0) {
            target.appendUint64(ChromeUnguessableTokenWire.LOW_TOKEN_WIRE, self.low_token);
        }
        if (self.high_token != 0) {
            target.appendUint64(ChromeUnguessableTokenWire.HIGH_TOKEN_WIRE, self.high_token);
        }
    }
};
pub const ChromeUnguessableTokenReader = struct {
    buf: gremlin.Reader,
    _low_token: u64 = 0,
    _high_token: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!ChromeUnguessableTokenReader {
        const buf = gremlin.Reader.init(src);
        var res = ChromeUnguessableTokenReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ChromeUnguessableTokenWire.LOW_TOKEN_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._low_token = result.value;
                },
                ChromeUnguessableTokenWire.HIGH_TOKEN_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._high_token = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getLowToken(self: *const ChromeUnguessableTokenReader) u64 {
        return self._low_token;
    }
    pub inline fn getHighToken(self: *const ChromeUnguessableTokenReader) u64 {
        return self._high_token;
    }
};
const FrameSinkIdWire = struct {
    const FRAME_SINK_CLIENT_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const FRAME_SINK_ID_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const FrameSinkId = struct {
    // fields
    frame_sink_client_id: u32 = 0,
    frame_sink_id: u32 = 0,
    pub fn calcProtobufSize(self: *const FrameSinkId) usize {
        var res: usize = 0;
        if (self.frame_sink_client_id != 0) {
            res += gremlin.sizes.sizeWireNumber(FrameSinkIdWire.FRAME_SINK_CLIENT_ID_WIRE) + gremlin.sizes.sizeU32(self.frame_sink_client_id);
        }
        if (self.frame_sink_id != 0) {
            res += gremlin.sizes.sizeWireNumber(FrameSinkIdWire.FRAME_SINK_ID_WIRE) + gremlin.sizes.sizeU32(self.frame_sink_id);
        }
        return res;
    }
    pub fn encode(self: *const FrameSinkId, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const FrameSinkId, target: *gremlin.Writer) void {
        if (self.frame_sink_client_id != 0) {
            target.appendUint32(FrameSinkIdWire.FRAME_SINK_CLIENT_ID_WIRE, self.frame_sink_client_id);
        }
        if (self.frame_sink_id != 0) {
            target.appendUint32(FrameSinkIdWire.FRAME_SINK_ID_WIRE, self.frame_sink_id);
        }
    }
};
pub const FrameSinkIdReader = struct {
    buf: gremlin.Reader,
    _frame_sink_client_id: u32 = 0,
    _frame_sink_id: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!FrameSinkIdReader {
        const buf = gremlin.Reader.init(src);
        var res = FrameSinkIdReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                FrameSinkIdWire.FRAME_SINK_CLIENT_ID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._frame_sink_client_id = result.value;
                },
                FrameSinkIdWire.FRAME_SINK_ID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._frame_sink_id = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getFrameSinkClientId(self: *const FrameSinkIdReader) u32 {
        return self._frame_sink_client_id;
    }
    pub inline fn getFrameSinkId(self: *const FrameSinkIdReader) u32 {
        return self._frame_sink_id;
    }
};
const LocalSurfaceIdWire = struct {
    const PARENT_SEQUENCE_NUMBER_WIRE: gremlin.ProtoWireNumber = 1;
    const CHILD_SEQUENCE_NUMBER_WIRE: gremlin.ProtoWireNumber = 2;
    const UNGUESSABLE_TOKEN_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const LocalSurfaceId = struct {
    // fields
    parent_sequence_number: u32 = 0,
    child_sequence_number: u32 = 0,
    unguessable_token: ?ChromeUnguessableToken = null,
    pub fn calcProtobufSize(self: *const LocalSurfaceId) usize {
        var res: usize = 0;
        if (self.parent_sequence_number != 0) {
            res += gremlin.sizes.sizeWireNumber(LocalSurfaceIdWire.PARENT_SEQUENCE_NUMBER_WIRE) + gremlin.sizes.sizeU32(self.parent_sequence_number);
        }
        if (self.child_sequence_number != 0) {
            res += gremlin.sizes.sizeWireNumber(LocalSurfaceIdWire.CHILD_SEQUENCE_NUMBER_WIRE) + gremlin.sizes.sizeU32(self.child_sequence_number);
        }
        if (self.unguessable_token) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LocalSurfaceIdWire.UNGUESSABLE_TOKEN_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const LocalSurfaceId, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const LocalSurfaceId, target: *gremlin.Writer) void {
        if (self.parent_sequence_number != 0) {
            target.appendUint32(LocalSurfaceIdWire.PARENT_SEQUENCE_NUMBER_WIRE, self.parent_sequence_number);
        }
        if (self.child_sequence_number != 0) {
            target.appendUint32(LocalSurfaceIdWire.CHILD_SEQUENCE_NUMBER_WIRE, self.child_sequence_number);
        }
        if (self.unguessable_token) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LocalSurfaceIdWire.UNGUESSABLE_TOKEN_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const LocalSurfaceIdReader = struct {
    buf: gremlin.Reader,
    _parent_sequence_number: u32 = 0,
    _child_sequence_number: u32 = 0,
    _unguessable_token_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!LocalSurfaceIdReader {
        const buf = gremlin.Reader.init(src);
        var res = LocalSurfaceIdReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                LocalSurfaceIdWire.PARENT_SEQUENCE_NUMBER_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._parent_sequence_number = result.value;
                },
                LocalSurfaceIdWire.CHILD_SEQUENCE_NUMBER_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._child_sequence_number = result.value;
                },
                LocalSurfaceIdWire.UNGUESSABLE_TOKEN_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._unguessable_token_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getParentSequenceNumber(self: *const LocalSurfaceIdReader) u32 {
        return self._parent_sequence_number;
    }
    pub inline fn getChildSequenceNumber(self: *const LocalSurfaceIdReader) u32 {
        return self._child_sequence_number;
    }
    pub fn getUnguessableToken(self: *const LocalSurfaceIdReader) gremlin.Error!ChromeUnguessableTokenReader {
        if (self._unguessable_token_buf) |buf| {
            return try ChromeUnguessableTokenReader.init(buf);
        }
        return try ChromeUnguessableTokenReader.init(&[_]u8{});
    }
};
const ChromeGraphicsPipelineWire = struct {
    const STEP_WIRE: gremlin.ProtoWireNumber = 1;
    const FRAME_SINK_ID_WIRE: gremlin.ProtoWireNumber = 2;
    const SURFACE_FRAME_TRACE_ID_WIRE: gremlin.ProtoWireNumber = 10;
    const DISPLAY_TRACE_ID_WIRE: gremlin.ProtoWireNumber = 3;
    const AGGREGATED_SURFACE_FRAME_TRACE_IDS_WIRE: gremlin.ProtoWireNumber = 8;
    const LOCAL_SURFACE_ID_WIRE: gremlin.ProtoWireNumber = 4;
    const FRAME_SEQUENCE_WIRE: gremlin.ProtoWireNumber = 5;
    const FRAME_SKIPPED_REASON_WIRE: gremlin.ProtoWireNumber = 6;
    const BACKEND_FRAME_ID_WIRE: gremlin.ProtoWireNumber = 7;
    const LATENCY_IDS_WIRE: gremlin.ProtoWireNumber = 9;
    const POSSIBLE_DEADLINES_WIRE: gremlin.ProtoWireNumber = 11;
};
pub const ChromeGraphicsPipeline = struct {
    // nested enums
    pub const StepName = enum(i32) {
        STEP_UNKNOWN = 0,
        STEP_DID_NOT_PRODUCE_FRAME = 1,
        STEP_DID_NOT_PRODUCE_COMPOSITOR_FRAME = 22,
        STEP_GENERATE_COMPOSITOR_FRAME = 2,
        STEP_GENERATE_RENDER_PASS = 3,
        STEP_ISSUE_BEGIN_FRAME = 4,
        STEP_RECEIVE_COMPOSITOR_FRAME = 5,
        STEP_RECEIVE_BEGIN_FRAME = 6,
        STEP_RECEIVE_BEGIN_FRAME_DISCARD = 7,
        STEP_SEND_BEGIN_MAIN_FRAME = 8,
        STEP_SUBMIT_COMPOSITOR_FRAME = 9,
        STEP_DRAW_AND_SWAP = 21,
        STEP_SURFACE_AGGREGATION = 10,
        STEP_SEND_BUFFER_SWAP = 11,
        STEP_BUFFER_SWAP_POST_SUBMIT = 12,
        STEP_FINISH_BUFFER_SWAP = 13,
        STEP_SWAP_BUFFERS_ACK = 14,
        STEP_EXO_CONSTRUCT_COMPOSITOR_FRAME = 15,
        STEP_EXO_SUBMIT_COMPOSITOR_FRAME = 16,
        STEP_EXO_DISCARD_COMPOSITOR_FRAME = 17,
        STEP_BACKEND_SEND_BUFFER_SWAP = 18,
        STEP_BACKEND_SEND_BUFFER_POST_SUBMIT = 19,
        STEP_BACKEND_FINISH_BUFFER_SWAP = 20,
        STEP_SEND_ON_BEGIN_FRAME_MOJO_MESSAGE = 23,
        STEP_SEND_ON_STANDALONE_BEGIN_FRAME_MOJO_MESSAGE = 24,
        STEP_SEND_SUBMIT_COMPOSITOR_FRAME_MOJO_MESSAGE = 25,
    };
    pub const FrameSkippedReason = enum(i32) {
        SKIPPED_REASON_UNKNOWN = 0,
        SKIPPED_REASON_RECOVER_LATENCY = 1,
        SKIPPED_REASON_NO_DAMAGE = 2,
        SKIPPED_REASON_WAITING_ON_MAIN = 3,
        SKIPPED_REASON_DRAW_THROTTLED = 4,
    };
    // fields
    step: ChromeGraphicsPipeline.StepName = @enumFromInt(0),
    frame_sink_id: ?FrameSinkId = null,
    surface_frame_trace_id: i64 = 0,
    display_trace_id: i64 = 0,
    aggregated_surface_frame_trace_ids: ?[]const i64 = null,
    local_surface_id: ?LocalSurfaceId = null,
    frame_sequence: i64 = 0,
    frame_skipped_reason: ChromeGraphicsPipeline.FrameSkippedReason = @enumFromInt(0),
    backend_frame_id: i64 = 0,
    latency_ids: ?[]const i64 = null,
    possible_deadlines: ?AndroidChoreographerFrameCallbackData = null,
    pub fn calcProtobufSize(self: *const ChromeGraphicsPipeline) usize {
        var res: usize = 0;
        if (@intFromEnum(self.step) != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeGraphicsPipelineWire.STEP_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.step));
        }
        if (self.frame_sink_id) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeGraphicsPipelineWire.FRAME_SINK_ID_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.surface_frame_trace_id != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeGraphicsPipelineWire.SURFACE_FRAME_TRACE_ID_WIRE) + gremlin.sizes.sizeI64(self.surface_frame_trace_id);
        }
        if (self.display_trace_id != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeGraphicsPipelineWire.DISPLAY_TRACE_ID_WIRE) + gremlin.sizes.sizeI64(self.display_trace_id);
        }
        if (self.aggregated_surface_frame_trace_ids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(ChromeGraphicsPipelineWire.AGGREGATED_SURFACE_FRAME_TRACE_IDS_WIRE) + gremlin.sizes.sizeI64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI64(v);
                }
                res += gremlin.sizes.sizeWireNumber(ChromeGraphicsPipelineWire.AGGREGATED_SURFACE_FRAME_TRACE_IDS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.local_surface_id) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeGraphicsPipelineWire.LOCAL_SURFACE_ID_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.frame_sequence != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeGraphicsPipelineWire.FRAME_SEQUENCE_WIRE) + gremlin.sizes.sizeI64(self.frame_sequence);
        }
        if (@intFromEnum(self.frame_skipped_reason) != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeGraphicsPipelineWire.FRAME_SKIPPED_REASON_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.frame_skipped_reason));
        }
        if (self.backend_frame_id != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeGraphicsPipelineWire.BACKEND_FRAME_ID_WIRE) + gremlin.sizes.sizeI64(self.backend_frame_id);
        }
        if (self.latency_ids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(ChromeGraphicsPipelineWire.LATENCY_IDS_WIRE) + gremlin.sizes.sizeI64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI64(v);
                }
                res += gremlin.sizes.sizeWireNumber(ChromeGraphicsPipelineWire.LATENCY_IDS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.possible_deadlines) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeGraphicsPipelineWire.POSSIBLE_DEADLINES_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const ChromeGraphicsPipeline, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ChromeGraphicsPipeline, target: *gremlin.Writer) void {
        if (@intFromEnum(self.step) != 0) {
            target.appendInt32(ChromeGraphicsPipelineWire.STEP_WIRE, @intFromEnum(self.step));
        }
        if (self.frame_sink_id) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeGraphicsPipelineWire.FRAME_SINK_ID_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.surface_frame_trace_id != 0) {
            target.appendInt64(ChromeGraphicsPipelineWire.SURFACE_FRAME_TRACE_ID_WIRE, self.surface_frame_trace_id);
        }
        if (self.display_trace_id != 0) {
            target.appendInt64(ChromeGraphicsPipelineWire.DISPLAY_TRACE_ID_WIRE, self.display_trace_id);
        }
        if (self.aggregated_surface_frame_trace_ids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt64(ChromeGraphicsPipelineWire.AGGREGATED_SURFACE_FRAME_TRACE_IDS_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI64(v);
                }
                target.appendBytesTag(ChromeGraphicsPipelineWire.AGGREGATED_SURFACE_FRAME_TRACE_IDS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt64WithoutTag(v);
                }
            }
        }
        if (self.local_surface_id) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeGraphicsPipelineWire.LOCAL_SURFACE_ID_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.frame_sequence != 0) {
            target.appendInt64(ChromeGraphicsPipelineWire.FRAME_SEQUENCE_WIRE, self.frame_sequence);
        }
        if (@intFromEnum(self.frame_skipped_reason) != 0) {
            target.appendInt32(ChromeGraphicsPipelineWire.FRAME_SKIPPED_REASON_WIRE, @intFromEnum(self.frame_skipped_reason));
        }
        if (self.backend_frame_id != 0) {
            target.appendInt64(ChromeGraphicsPipelineWire.BACKEND_FRAME_ID_WIRE, self.backend_frame_id);
        }
        if (self.latency_ids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt64(ChromeGraphicsPipelineWire.LATENCY_IDS_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI64(v);
                }
                target.appendBytesTag(ChromeGraphicsPipelineWire.LATENCY_IDS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt64WithoutTag(v);
                }
            }
        }
        if (self.possible_deadlines) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeGraphicsPipelineWire.POSSIBLE_DEADLINES_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const ChromeGraphicsPipelineReader = struct {
    buf: gremlin.Reader,
    _step: ChromeGraphicsPipeline.StepName = @enumFromInt(0),
    _frame_sink_id_buf: ?[]const u8 = null,
    _surface_frame_trace_id: i64 = 0,
    _display_trace_id: i64 = 0,
    _aggregated_surface_frame_trace_ids_offset: ?usize = null,
    _aggregated_surface_frame_trace_ids_last_offset: ?usize = null,
    _aggregated_surface_frame_trace_ids_packed: bool = false,
    _local_surface_id_buf: ?[]const u8 = null,
    _frame_sequence: i64 = 0,
    _frame_skipped_reason: ChromeGraphicsPipeline.FrameSkippedReason = @enumFromInt(0),
    _backend_frame_id: i64 = 0,
    _latency_ids_offset: ?usize = null,
    _latency_ids_last_offset: ?usize = null,
    _latency_ids_packed: bool = false,
    _possible_deadlines_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!ChromeGraphicsPipelineReader {
        const buf = gremlin.Reader.init(src);
        var res = ChromeGraphicsPipelineReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ChromeGraphicsPipelineWire.STEP_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._step = @enumFromInt(result.value);
                },
                ChromeGraphicsPipelineWire.FRAME_SINK_ID_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._frame_sink_id_buf = result.value;
                },
                ChromeGraphicsPipelineWire.SURFACE_FRAME_TRACE_ID_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._surface_frame_trace_id = result.value;
                },
                ChromeGraphicsPipelineWire.DISPLAY_TRACE_ID_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._display_trace_id = result.value;
                },
                ChromeGraphicsPipelineWire.AGGREGATED_SURFACE_FRAME_TRACE_IDS_WIRE => {
                    if (res._aggregated_surface_frame_trace_ids_offset == null) {
                        res._aggregated_surface_frame_trace_ids_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._aggregated_surface_frame_trace_ids_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._aggregated_surface_frame_trace_ids_offset = offset + length_result.size;
                        res._aggregated_surface_frame_trace_ids_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._aggregated_surface_frame_trace_ids_last_offset.?;
                    } else {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._aggregated_surface_frame_trace_ids_last_offset = offset;
                    }
                },
                ChromeGraphicsPipelineWire.LOCAL_SURFACE_ID_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._local_surface_id_buf = result.value;
                },
                ChromeGraphicsPipelineWire.FRAME_SEQUENCE_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._frame_sequence = result.value;
                },
                ChromeGraphicsPipelineWire.FRAME_SKIPPED_REASON_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._frame_skipped_reason = @enumFromInt(result.value);
                },
                ChromeGraphicsPipelineWire.BACKEND_FRAME_ID_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._backend_frame_id = result.value;
                },
                ChromeGraphicsPipelineWire.LATENCY_IDS_WIRE => {
                    if (res._latency_ids_offset == null) {
                        res._latency_ids_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._latency_ids_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._latency_ids_offset = offset + length_result.size;
                        res._latency_ids_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._latency_ids_last_offset.?;
                    } else {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._latency_ids_last_offset = offset;
                    }
                },
                ChromeGraphicsPipelineWire.POSSIBLE_DEADLINES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._possible_deadlines_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getStep(self: *const ChromeGraphicsPipelineReader) ChromeGraphicsPipeline.StepName {
        return self._step;
    }
    pub fn getFrameSinkId(self: *const ChromeGraphicsPipelineReader) gremlin.Error!FrameSinkIdReader {
        if (self._frame_sink_id_buf) |buf| {
            return try FrameSinkIdReader.init(buf);
        }
        return try FrameSinkIdReader.init(&[_]u8{});
    }
    pub inline fn getSurfaceFrameTraceId(self: *const ChromeGraphicsPipelineReader) i64 {
        return self._surface_frame_trace_id;
    }
    pub inline fn getDisplayTraceId(self: *const ChromeGraphicsPipelineReader) i64 {
        return self._display_trace_id;
    }
    pub fn aggregatedSurfaceFrameTraceIdsNext(self: *ChromeGraphicsPipelineReader) gremlin.Error!?i64 {
        if (self._aggregated_surface_frame_trace_ids_offset == null) return null;
        const current_offset = self._aggregated_surface_frame_trace_ids_offset.?;
        if (current_offset >= self._aggregated_surface_frame_trace_ids_last_offset.?) {
            self._aggregated_surface_frame_trace_ids_offset = null;
            return null;
        }
        if (self._aggregated_surface_frame_trace_ids_packed) {
            const value_result = try self.buf.readInt64(current_offset);
            self._aggregated_surface_frame_trace_ids_offset = current_offset + value_result.size;
            if (self._aggregated_surface_frame_trace_ids_offset.? >= self._aggregated_surface_frame_trace_ids_last_offset.?) {
                self._aggregated_surface_frame_trace_ids_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._aggregated_surface_frame_trace_ids_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == ChromeGraphicsPipelineWire.AGGREGATED_SURFACE_FRAME_TRACE_IDS_WIRE) {
                    self._aggregated_surface_frame_trace_ids_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._aggregated_surface_frame_trace_ids_offset = null;
            return value_result.value;
        }
    }
    pub fn getLocalSurfaceId(self: *const ChromeGraphicsPipelineReader) gremlin.Error!LocalSurfaceIdReader {
        if (self._local_surface_id_buf) |buf| {
            return try LocalSurfaceIdReader.init(buf);
        }
        return try LocalSurfaceIdReader.init(&[_]u8{});
    }
    pub inline fn getFrameSequence(self: *const ChromeGraphicsPipelineReader) i64 {
        return self._frame_sequence;
    }
    pub inline fn getFrameSkippedReason(self: *const ChromeGraphicsPipelineReader) ChromeGraphicsPipeline.FrameSkippedReason {
        return self._frame_skipped_reason;
    }
    pub inline fn getBackendFrameId(self: *const ChromeGraphicsPipelineReader) i64 {
        return self._backend_frame_id;
    }
    pub fn latencyIdsNext(self: *ChromeGraphicsPipelineReader) gremlin.Error!?i64 {
        if (self._latency_ids_offset == null) return null;
        const current_offset = self._latency_ids_offset.?;
        if (current_offset >= self._latency_ids_last_offset.?) {
            self._latency_ids_offset = null;
            return null;
        }
        if (self._latency_ids_packed) {
            const value_result = try self.buf.readInt64(current_offset);
            self._latency_ids_offset = current_offset + value_result.size;
            if (self._latency_ids_offset.? >= self._latency_ids_last_offset.?) {
                self._latency_ids_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._latency_ids_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == ChromeGraphicsPipelineWire.LATENCY_IDS_WIRE) {
                    self._latency_ids_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._latency_ids_offset = null;
            return value_result.value;
        }
    }
    pub fn getPossibleDeadlines(self: *const ChromeGraphicsPipelineReader) gremlin.Error!AndroidChoreographerFrameCallbackDataReader {
        if (self._possible_deadlines_buf) |buf| {
            return try AndroidChoreographerFrameCallbackDataReader.init(buf);
        }
        return try AndroidChoreographerFrameCallbackDataReader.init(&[_]u8{});
    }
};
const LibunwindstackUnwinderWire = struct {
    const ERROR_CODE_WIRE: gremlin.ProtoWireNumber = 1;
    const NUM_FRAMES_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const LibunwindstackUnwinder = struct {
    // nested enums
    pub const ErrorCode = enum(i32) {
        ERROR_NONE = 0,
        ERROR_MEMORY_INVALID = 1,
        ERROR_UNWIND_INFO = 2,
        ERROR_UNSUPPORTED = 3,
        ERROR_INVALID_MAP = 4,
        ERROR_MAX_FRAMES_EXCEEDED = 5,
        ERROR_REPEATED_FRAME = 6,
        ERROR_INVALID_ELF = 7,
        ERROR_THREAD_DOES_NOT_EXIST = 8,
        ERROR_THREAD_TIMEOUT = 9,
        ERROR_SYSTEM_CALL = 10,
        ERROR_BAD_ARCH = 11,
        ERROR_MAPS_PARSE = 12,
        ERROR_INVALID_PARAMETER_LIBUNWINDSTACK = 13,
        ERROR_PTRACE_CALL = 14,
    };
    // fields
    error_code: LibunwindstackUnwinder.ErrorCode = @enumFromInt(0),
    num_frames: i32 = 0,
    pub fn calcProtobufSize(self: *const LibunwindstackUnwinder) usize {
        var res: usize = 0;
        if (@intFromEnum(self.error_code) != 0) {
            res += gremlin.sizes.sizeWireNumber(LibunwindstackUnwinderWire.ERROR_CODE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.error_code));
        }
        if (self.num_frames != 0) {
            res += gremlin.sizes.sizeWireNumber(LibunwindstackUnwinderWire.NUM_FRAMES_WIRE) + gremlin.sizes.sizeI32(self.num_frames);
        }
        return res;
    }
    pub fn encode(self: *const LibunwindstackUnwinder, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const LibunwindstackUnwinder, target: *gremlin.Writer) void {
        if (@intFromEnum(self.error_code) != 0) {
            target.appendInt32(LibunwindstackUnwinderWire.ERROR_CODE_WIRE, @intFromEnum(self.error_code));
        }
        if (self.num_frames != 0) {
            target.appendInt32(LibunwindstackUnwinderWire.NUM_FRAMES_WIRE, self.num_frames);
        }
    }
};
pub const LibunwindstackUnwinderReader = struct {
    buf: gremlin.Reader,
    _error_code: LibunwindstackUnwinder.ErrorCode = @enumFromInt(0),
    _num_frames: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!LibunwindstackUnwinderReader {
        const buf = gremlin.Reader.init(src);
        var res = LibunwindstackUnwinderReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                LibunwindstackUnwinderWire.ERROR_CODE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._error_code = @enumFromInt(result.value);
                },
                LibunwindstackUnwinderWire.NUM_FRAMES_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._num_frames = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getErrorCode(self: *const LibunwindstackUnwinderReader) LibunwindstackUnwinder.ErrorCode {
        return self._error_code;
    }
    pub inline fn getNumFrames(self: *const LibunwindstackUnwinderReader) i32 {
        return self._num_frames;
    }
};
const ScrollPredictorMetricsWire = struct {
    const PREV_EVENT_FRAME_VALUE_WIRE: gremlin.ProtoWireNumber = 1;
    const CUR_EVENT_FRAME_VALUE_WIRE: gremlin.ProtoWireNumber = 2;
    const NEXT_EVENT_FRAME_VALUE_WIRE: gremlin.ProtoWireNumber = 3;
    const JANKY_VALUE_PIXELS_WIRE: gremlin.ProtoWireNumber = 4;
    const HAS_MISSED_VSYNCS_WIRE: gremlin.ProtoWireNumber = 5;
    const IS_SLOW_SCROLL_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const ScrollPredictorMetrics = struct {
    // nested structs
    const EventFrameValueWire = struct {
        const EVENT_TRACE_ID_WIRE: gremlin.ProtoWireNumber = 1;
        const DELTA_VALUE_PIXELS_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const EventFrameValue = struct {
        // fields
        event_trace_id: i64 = 0,
        delta_value_pixels: f32 = 0.0,
        pub fn calcProtobufSize(self: *const ScrollPredictorMetrics.EventFrameValue) usize {
            var res: usize = 0;
            if (self.event_trace_id != 0) {
                res += gremlin.sizes.sizeWireNumber(ScrollPredictorMetrics.EventFrameValueWire.EVENT_TRACE_ID_WIRE) + gremlin.sizes.sizeI64(self.event_trace_id);
            }
            if (self.delta_value_pixels != 0.0) {
                res += gremlin.sizes.sizeWireNumber(ScrollPredictorMetrics.EventFrameValueWire.DELTA_VALUE_PIXELS_WIRE) + gremlin.sizes.sizeFloat(self.delta_value_pixels);
            }
            return res;
        }
        pub fn encode(self: *const ScrollPredictorMetrics.EventFrameValue, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const ScrollPredictorMetrics.EventFrameValue, target: *gremlin.Writer) void {
            if (self.event_trace_id != 0) {
                target.appendInt64(ScrollPredictorMetrics.EventFrameValueWire.EVENT_TRACE_ID_WIRE, self.event_trace_id);
            }
            if (self.delta_value_pixels != 0.0) {
                target.appendFloat32(ScrollPredictorMetrics.EventFrameValueWire.DELTA_VALUE_PIXELS_WIRE, self.delta_value_pixels);
            }
        }
    };
    pub const EventFrameValueReader = struct {
        buf: gremlin.Reader,
        _event_trace_id: i64 = 0,
        _delta_value_pixels: f32 = 0.0,
        pub fn init(src: []const u8) gremlin.Error!ScrollPredictorMetrics.EventFrameValueReader {
            const buf = gremlin.Reader.init(src);
            var res = ScrollPredictorMetrics.EventFrameValueReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    ScrollPredictorMetrics.EventFrameValueWire.EVENT_TRACE_ID_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._event_trace_id = result.value;
                    },
                    ScrollPredictorMetrics.EventFrameValueWire.DELTA_VALUE_PIXELS_WIRE => {
                        const result = try buf.readFloat32(offset);
                        offset += result.size;
                        res._delta_value_pixels = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getEventTraceId(self: *const ScrollPredictorMetrics.EventFrameValueReader) i64 {
            return self._event_trace_id;
        }
        pub inline fn getDeltaValuePixels(self: *const ScrollPredictorMetrics.EventFrameValueReader) f32 {
            return self._delta_value_pixels;
        }
    };
    // fields
    prev_event_frame_value: ?ScrollPredictorMetrics.EventFrameValue = null,
    cur_event_frame_value: ?ScrollPredictorMetrics.EventFrameValue = null,
    next_event_frame_value: ?ScrollPredictorMetrics.EventFrameValue = null,
    janky_value_pixels: f32 = 0.0,
    has_missed_vsyncs: bool = false,
    is_slow_scroll: bool = false,
    pub fn calcProtobufSize(self: *const ScrollPredictorMetrics) usize {
        var res: usize = 0;
        if (self.prev_event_frame_value) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ScrollPredictorMetricsWire.PREV_EVENT_FRAME_VALUE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cur_event_frame_value) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ScrollPredictorMetricsWire.CUR_EVENT_FRAME_VALUE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.next_event_frame_value) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ScrollPredictorMetricsWire.NEXT_EVENT_FRAME_VALUE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.janky_value_pixels != 0.0) {
            res += gremlin.sizes.sizeWireNumber(ScrollPredictorMetricsWire.JANKY_VALUE_PIXELS_WIRE) + gremlin.sizes.sizeFloat(self.janky_value_pixels);
        }
        if (self.has_missed_vsyncs != false) {
            res += gremlin.sizes.sizeWireNumber(ScrollPredictorMetricsWire.HAS_MISSED_VSYNCS_WIRE) + gremlin.sizes.sizeBool(self.has_missed_vsyncs);
        }
        if (self.is_slow_scroll != false) {
            res += gremlin.sizes.sizeWireNumber(ScrollPredictorMetricsWire.IS_SLOW_SCROLL_WIRE) + gremlin.sizes.sizeBool(self.is_slow_scroll);
        }
        return res;
    }
    pub fn encode(self: *const ScrollPredictorMetrics, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ScrollPredictorMetrics, target: *gremlin.Writer) void {
        if (self.prev_event_frame_value) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ScrollPredictorMetricsWire.PREV_EVENT_FRAME_VALUE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cur_event_frame_value) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ScrollPredictorMetricsWire.CUR_EVENT_FRAME_VALUE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.next_event_frame_value) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ScrollPredictorMetricsWire.NEXT_EVENT_FRAME_VALUE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.janky_value_pixels != 0.0) {
            target.appendFloat32(ScrollPredictorMetricsWire.JANKY_VALUE_PIXELS_WIRE, self.janky_value_pixels);
        }
        if (self.has_missed_vsyncs != false) {
            target.appendBool(ScrollPredictorMetricsWire.HAS_MISSED_VSYNCS_WIRE, self.has_missed_vsyncs);
        }
        if (self.is_slow_scroll != false) {
            target.appendBool(ScrollPredictorMetricsWire.IS_SLOW_SCROLL_WIRE, self.is_slow_scroll);
        }
    }
};
pub const ScrollPredictorMetricsReader = struct {
    buf: gremlin.Reader,
    _prev_event_frame_value_buf: ?[]const u8 = null,
    _cur_event_frame_value_buf: ?[]const u8 = null,
    _next_event_frame_value_buf: ?[]const u8 = null,
    _janky_value_pixels: f32 = 0.0,
    _has_missed_vsyncs: bool = false,
    _is_slow_scroll: bool = false,
    pub fn init(src: []const u8) gremlin.Error!ScrollPredictorMetricsReader {
        const buf = gremlin.Reader.init(src);
        var res = ScrollPredictorMetricsReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ScrollPredictorMetricsWire.PREV_EVENT_FRAME_VALUE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._prev_event_frame_value_buf = result.value;
                },
                ScrollPredictorMetricsWire.CUR_EVENT_FRAME_VALUE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cur_event_frame_value_buf = result.value;
                },
                ScrollPredictorMetricsWire.NEXT_EVENT_FRAME_VALUE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._next_event_frame_value_buf = result.value;
                },
                ScrollPredictorMetricsWire.JANKY_VALUE_PIXELS_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._janky_value_pixels = result.value;
                },
                ScrollPredictorMetricsWire.HAS_MISSED_VSYNCS_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._has_missed_vsyncs = result.value;
                },
                ScrollPredictorMetricsWire.IS_SLOW_SCROLL_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_slow_scroll = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getPrevEventFrameValue(self: *const ScrollPredictorMetricsReader) gremlin.Error!ScrollPredictorMetrics.EventFrameValueReader {
        if (self._prev_event_frame_value_buf) |buf| {
            return try ScrollPredictorMetrics.EventFrameValueReader.init(buf);
        }
        return try ScrollPredictorMetrics.EventFrameValueReader.init(&[_]u8{});
    }
    pub fn getCurEventFrameValue(self: *const ScrollPredictorMetricsReader) gremlin.Error!ScrollPredictorMetrics.EventFrameValueReader {
        if (self._cur_event_frame_value_buf) |buf| {
            return try ScrollPredictorMetrics.EventFrameValueReader.init(buf);
        }
        return try ScrollPredictorMetrics.EventFrameValueReader.init(&[_]u8{});
    }
    pub fn getNextEventFrameValue(self: *const ScrollPredictorMetricsReader) gremlin.Error!ScrollPredictorMetrics.EventFrameValueReader {
        if (self._next_event_frame_value_buf) |buf| {
            return try ScrollPredictorMetrics.EventFrameValueReader.init(buf);
        }
        return try ScrollPredictorMetrics.EventFrameValueReader.init(&[_]u8{});
    }
    pub inline fn getJankyValuePixels(self: *const ScrollPredictorMetricsReader) f32 {
        return self._janky_value_pixels;
    }
    pub inline fn getHasMissedVsyncs(self: *const ScrollPredictorMetricsReader) bool {
        return self._has_missed_vsyncs;
    }
    pub inline fn getIsSlowScroll(self: *const ScrollPredictorMetricsReader) bool {
        return self._is_slow_scroll;
    }
};
const PageLoadWire = struct {
    const NAVIGATION_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const URL_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const PageLoad = struct {
    // fields
    navigation_id: i64 = 0,
    url: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const PageLoad) usize {
        var res: usize = 0;
        if (self.navigation_id != 0) {
            res += gremlin.sizes.sizeWireNumber(PageLoadWire.NAVIGATION_ID_WIRE) + gremlin.sizes.sizeI64(self.navigation_id);
        }
        if (self.url) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(PageLoadWire.URL_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const PageLoad, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const PageLoad, target: *gremlin.Writer) void {
        if (self.navigation_id != 0) {
            target.appendInt64(PageLoadWire.NAVIGATION_ID_WIRE, self.navigation_id);
        }
        if (self.url) |v| {
            if (v.len > 0) {
                target.appendBytes(PageLoadWire.URL_WIRE, v);
            }
        }
    }
};
pub const PageLoadReader = struct {
    buf: gremlin.Reader,
    _navigation_id: i64 = 0,
    _url: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!PageLoadReader {
        const buf = gremlin.Reader.init(src);
        var res = PageLoadReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                PageLoadWire.NAVIGATION_ID_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._navigation_id = result.value;
                },
                PageLoadWire.URL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._url = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getNavigationId(self: *const PageLoadReader) i64 {
        return self._navigation_id;
    }
    pub inline fn getUrl(self: *const PageLoadReader) []const u8 {
        return self._url orelse &[_]u8{};
    }
};
const StartUpWire = struct {
    const ACTIVITY_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const LAUNCH_CAUSE_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const StartUp = struct {
    // nested enums
    pub const LaunchCauseType = enum(i32) {
        UNINITIALIZED = -1,
        OTHER = 0,
        CUSTOM_TAB = 1,
        TWA = 2,
        RECENTS = 3,
        RECENTS_OR_BACK = 4,
        FOREGROUND_WHEN_LOCKED = 5,
        MAIN_LAUNCHER_ICON = 6,
        MAIN_LAUNCHER_ICON_SHORTCUT = 7,
        HOME_SCREEN_WIDGET = 8,
        OPEN_IN_BROWSER_FROM_MENU = 9,
        EXTERNAL_SEARCH_ACTION_INTENT = 10,
        NOTIFICATION = 11,
        EXTERNAL_VIEW_INTENT = 12,
        OTHER_CHROME = 13,
        WEBAPK_CHROME_DISTRIBUTOR = 14,
        WEBAPK_OTHER_DISTRIBUTOR = 15,
        HOME_SCREEN_SHORTCUT = 16,
        SHARE_INTENT = 17,
        NFC = 18,
        AUTH_TAB = 19,
    };
    // fields
    activity_id: i64 = 0,
    launch_cause: StartUp.LaunchCauseType = @enumFromInt(0),
    pub fn calcProtobufSize(self: *const StartUp) usize {
        var res: usize = 0;
        if (self.activity_id != 0) {
            res += gremlin.sizes.sizeWireNumber(StartUpWire.ACTIVITY_ID_WIRE) + gremlin.sizes.sizeI64(self.activity_id);
        }
        if (@intFromEnum(self.launch_cause) != 0) {
            res += gremlin.sizes.sizeWireNumber(StartUpWire.LAUNCH_CAUSE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.launch_cause));
        }
        return res;
    }
    pub fn encode(self: *const StartUp, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const StartUp, target: *gremlin.Writer) void {
        if (self.activity_id != 0) {
            target.appendInt64(StartUpWire.ACTIVITY_ID_WIRE, self.activity_id);
        }
        if (@intFromEnum(self.launch_cause) != 0) {
            target.appendInt32(StartUpWire.LAUNCH_CAUSE_WIRE, @intFromEnum(self.launch_cause));
        }
    }
};
pub const StartUpReader = struct {
    buf: gremlin.Reader,
    _activity_id: i64 = 0,
    _launch_cause: StartUp.LaunchCauseType = @enumFromInt(0),
    pub fn init(src: []const u8) gremlin.Error!StartUpReader {
        const buf = gremlin.Reader.init(src);
        var res = StartUpReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                StartUpWire.ACTIVITY_ID_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._activity_id = result.value;
                },
                StartUpWire.LAUNCH_CAUSE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._launch_cause = @enumFromInt(result.value);
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getActivityId(self: *const StartUpReader) i64 {
        return self._activity_id;
    }
    pub inline fn getLaunchCause(self: *const StartUpReader) StartUp.LaunchCauseType {
        return self._launch_cause;
    }
};
const WebContentInteractionWire = struct {
    const TYPE_WIRE: gremlin.ProtoWireNumber = 1;
    const TOTAL_DURATION_MS_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const WebContentInteraction = struct {
    // nested enums
    pub const Type = enum(i32) {
        INTERACTION_UNSPECIFIED = 0,
        INTERACTION_KEYBOARD = 1,
        INTERACTION_CLICK_TAP = 2,
        INTERACTION_DRAG = 3,
    };
    // fields
    type: WebContentInteraction.Type = @enumFromInt(0),
    total_duration_ms: i64 = 0,
    pub fn calcProtobufSize(self: *const WebContentInteraction) usize {
        var res: usize = 0;
        if (@intFromEnum(self.type) != 0) {
            res += gremlin.sizes.sizeWireNumber(WebContentInteractionWire.TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.type));
        }
        if (self.total_duration_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(WebContentInteractionWire.TOTAL_DURATION_MS_WIRE) + gremlin.sizes.sizeI64(self.total_duration_ms);
        }
        return res;
    }
    pub fn encode(self: *const WebContentInteraction, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const WebContentInteraction, target: *gremlin.Writer) void {
        if (@intFromEnum(self.type) != 0) {
            target.appendInt32(WebContentInteractionWire.TYPE_WIRE, @intFromEnum(self.type));
        }
        if (self.total_duration_ms != 0) {
            target.appendInt64(WebContentInteractionWire.TOTAL_DURATION_MS_WIRE, self.total_duration_ms);
        }
    }
};
pub const WebContentInteractionReader = struct {
    buf: gremlin.Reader,
    _type: WebContentInteraction.Type = @enumFromInt(0),
    _total_duration_ms: i64 = 0,
    pub fn init(src: []const u8) gremlin.Error!WebContentInteractionReader {
        const buf = gremlin.Reader.init(src);
        var res = WebContentInteractionReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                WebContentInteractionWire.TYPE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._type = @enumFromInt(result.value);
                },
                WebContentInteractionWire.TOTAL_DURATION_MS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._total_duration_ms = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getType(self: *const WebContentInteractionReader) WebContentInteraction.Type {
        return self._type;
    }
    pub inline fn getTotalDurationMs(self: *const WebContentInteractionReader) i64 {
        return self._total_duration_ms;
    }
};
const ScrollMetricsWire = struct {
    const FRAME_COUNT_WIRE: gremlin.ProtoWireNumber = 1;
    const VSYNC_COUNT_WIRE: gremlin.ProtoWireNumber = 2;
    const MISSED_VSYNC_MAX_WIRE: gremlin.ProtoWireNumber = 3;
    const MISSED_VSYNC_SUM_WIRE: gremlin.ProtoWireNumber = 4;
    const DELAYED_FRAME_COUNT_WIRE: gremlin.ProtoWireNumber = 5;
    const PREDICTOR_JANKY_FRAME_COUNT_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const ScrollMetrics = struct {
    // fields
    frame_count: i64 = 0,
    vsync_count: i64 = 0,
    missed_vsync_max: i64 = 0,
    missed_vsync_sum: i64 = 0,
    delayed_frame_count: i64 = 0,
    predictor_janky_frame_count: i64 = 0,
    pub fn calcProtobufSize(self: *const ScrollMetrics) usize {
        var res: usize = 0;
        if (self.frame_count != 0) {
            res += gremlin.sizes.sizeWireNumber(ScrollMetricsWire.FRAME_COUNT_WIRE) + gremlin.sizes.sizeI64(self.frame_count);
        }
        if (self.vsync_count != 0) {
            res += gremlin.sizes.sizeWireNumber(ScrollMetricsWire.VSYNC_COUNT_WIRE) + gremlin.sizes.sizeI64(self.vsync_count);
        }
        if (self.missed_vsync_max != 0) {
            res += gremlin.sizes.sizeWireNumber(ScrollMetricsWire.MISSED_VSYNC_MAX_WIRE) + gremlin.sizes.sizeI64(self.missed_vsync_max);
        }
        if (self.missed_vsync_sum != 0) {
            res += gremlin.sizes.sizeWireNumber(ScrollMetricsWire.MISSED_VSYNC_SUM_WIRE) + gremlin.sizes.sizeI64(self.missed_vsync_sum);
        }
        if (self.delayed_frame_count != 0) {
            res += gremlin.sizes.sizeWireNumber(ScrollMetricsWire.DELAYED_FRAME_COUNT_WIRE) + gremlin.sizes.sizeI64(self.delayed_frame_count);
        }
        if (self.predictor_janky_frame_count != 0) {
            res += gremlin.sizes.sizeWireNumber(ScrollMetricsWire.PREDICTOR_JANKY_FRAME_COUNT_WIRE) + gremlin.sizes.sizeI64(self.predictor_janky_frame_count);
        }
        return res;
    }
    pub fn encode(self: *const ScrollMetrics, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ScrollMetrics, target: *gremlin.Writer) void {
        if (self.frame_count != 0) {
            target.appendInt64(ScrollMetricsWire.FRAME_COUNT_WIRE, self.frame_count);
        }
        if (self.vsync_count != 0) {
            target.appendInt64(ScrollMetricsWire.VSYNC_COUNT_WIRE, self.vsync_count);
        }
        if (self.missed_vsync_max != 0) {
            target.appendInt64(ScrollMetricsWire.MISSED_VSYNC_MAX_WIRE, self.missed_vsync_max);
        }
        if (self.missed_vsync_sum != 0) {
            target.appendInt64(ScrollMetricsWire.MISSED_VSYNC_SUM_WIRE, self.missed_vsync_sum);
        }
        if (self.delayed_frame_count != 0) {
            target.appendInt64(ScrollMetricsWire.DELAYED_FRAME_COUNT_WIRE, self.delayed_frame_count);
        }
        if (self.predictor_janky_frame_count != 0) {
            target.appendInt64(ScrollMetricsWire.PREDICTOR_JANKY_FRAME_COUNT_WIRE, self.predictor_janky_frame_count);
        }
    }
};
pub const ScrollMetricsReader = struct {
    buf: gremlin.Reader,
    _frame_count: i64 = 0,
    _vsync_count: i64 = 0,
    _missed_vsync_max: i64 = 0,
    _missed_vsync_sum: i64 = 0,
    _delayed_frame_count: i64 = 0,
    _predictor_janky_frame_count: i64 = 0,
    pub fn init(src: []const u8) gremlin.Error!ScrollMetricsReader {
        const buf = gremlin.Reader.init(src);
        var res = ScrollMetricsReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ScrollMetricsWire.FRAME_COUNT_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._frame_count = result.value;
                },
                ScrollMetricsWire.VSYNC_COUNT_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._vsync_count = result.value;
                },
                ScrollMetricsWire.MISSED_VSYNC_MAX_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._missed_vsync_max = result.value;
                },
                ScrollMetricsWire.MISSED_VSYNC_SUM_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._missed_vsync_sum = result.value;
                },
                ScrollMetricsWire.DELAYED_FRAME_COUNT_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._delayed_frame_count = result.value;
                },
                ScrollMetricsWire.PREDICTOR_JANKY_FRAME_COUNT_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._predictor_janky_frame_count = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getFrameCount(self: *const ScrollMetricsReader) i64 {
        return self._frame_count;
    }
    pub inline fn getVsyncCount(self: *const ScrollMetricsReader) i64 {
        return self._vsync_count;
    }
    pub inline fn getMissedVsyncMax(self: *const ScrollMetricsReader) i64 {
        return self._missed_vsync_max;
    }
    pub inline fn getMissedVsyncSum(self: *const ScrollMetricsReader) i64 {
        return self._missed_vsync_sum;
    }
    pub inline fn getDelayedFrameCount(self: *const ScrollMetricsReader) i64 {
        return self._delayed_frame_count;
    }
    pub inline fn getPredictorJankyFrameCount(self: *const ScrollMetricsReader) i64 {
        return self._predictor_janky_frame_count;
    }
};
const EventForwarderWire = struct {
    const HISTORY_SIZE_WIRE: gremlin.ProtoWireNumber = 1;
    const OLDEST_TIME_NS_WIRE: gremlin.ProtoWireNumber = 2;
    const LATEST_TIME_NS_WIRE: gremlin.ProtoWireNumber = 5;
    const DOWN_TIME_NS_WIRE: gremlin.ProtoWireNumber = 8;
    const X_PIXEL_WIRE: gremlin.ProtoWireNumber = 3;
    const Y_PIXEL_WIRE: gremlin.ProtoWireNumber = 4;
    const HAS_X_MOVEMENT_WIRE: gremlin.ProtoWireNumber = 6;
    const HAS_Y_MOVEMENT_WIRE: gremlin.ProtoWireNumber = 7;
    const ACTION_WIRE: gremlin.ProtoWireNumber = 9;
    const VERIFIED_EVENT_WIRE: gremlin.ProtoWireNumber = 10;
};
pub const EventForwarder = struct {
    // nested enums
    pub const AMotionEventAction = enum(i32) {
        AMOTION_EVENT_ACTION_DOWN = 0,
        AMOTION_EVENT_ACTION_UP = 1,
        AMOTION_EVENT_ACTION_MOVE = 2,
        AMOTION_EVENT_ACTION_CANCEL = 3,
        AMOTION_EVENT_ACTION_OUTSIDE = 4,
        AMOTION_EVENT_ACTION_POINTER_DOWN = 5,
        AMOTION_EVENT_ACTION_POINTER_UP = 6,
        AMOTION_EVENT_ACTION_HOVER_MOVE = 7,
        AMOTION_EVENT_ACTION_SCROLL = 8,
        AMOTION_EVENT_ACTION_HOVER_ENTER = 9,
        AMOTION_EVENT_ACTION_HOVER_EXIT = 10,
        AMOTION_EVENT_ACTION_BUTTON_PRESS = 11,
        AMOTION_EVENT_ACTION_BUTTON_RELEASE = 12,
    };
    // fields
    history_size: i32 = 0,
    oldest_time_ns: i64 = 0,
    latest_time_ns: i64 = 0,
    down_time_ns: i64 = 0,
    x_pixel: f32 = 0.0,
    y_pixel: f32 = 0.0,
    has_x_movement: bool = false,
    has_y_movement: bool = false,
    action: EventForwarder.AMotionEventAction = @enumFromInt(0),
    verified_event: bool = false,
    pub fn calcProtobufSize(self: *const EventForwarder) usize {
        var res: usize = 0;
        if (self.history_size != 0) {
            res += gremlin.sizes.sizeWireNumber(EventForwarderWire.HISTORY_SIZE_WIRE) + gremlin.sizes.sizeI32(self.history_size);
        }
        if (self.oldest_time_ns != 0) {
            res += gremlin.sizes.sizeWireNumber(EventForwarderWire.OLDEST_TIME_NS_WIRE) + gremlin.sizes.sizeI64(self.oldest_time_ns);
        }
        if (self.latest_time_ns != 0) {
            res += gremlin.sizes.sizeWireNumber(EventForwarderWire.LATEST_TIME_NS_WIRE) + gremlin.sizes.sizeI64(self.latest_time_ns);
        }
        if (self.down_time_ns != 0) {
            res += gremlin.sizes.sizeWireNumber(EventForwarderWire.DOWN_TIME_NS_WIRE) + gremlin.sizes.sizeI64(self.down_time_ns);
        }
        if (self.x_pixel != 0.0) {
            res += gremlin.sizes.sizeWireNumber(EventForwarderWire.X_PIXEL_WIRE) + gremlin.sizes.sizeFloat(self.x_pixel);
        }
        if (self.y_pixel != 0.0) {
            res += gremlin.sizes.sizeWireNumber(EventForwarderWire.Y_PIXEL_WIRE) + gremlin.sizes.sizeFloat(self.y_pixel);
        }
        if (self.has_x_movement != false) {
            res += gremlin.sizes.sizeWireNumber(EventForwarderWire.HAS_X_MOVEMENT_WIRE) + gremlin.sizes.sizeBool(self.has_x_movement);
        }
        if (self.has_y_movement != false) {
            res += gremlin.sizes.sizeWireNumber(EventForwarderWire.HAS_Y_MOVEMENT_WIRE) + gremlin.sizes.sizeBool(self.has_y_movement);
        }
        if (@intFromEnum(self.action) != 0) {
            res += gremlin.sizes.sizeWireNumber(EventForwarderWire.ACTION_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.action));
        }
        if (self.verified_event != false) {
            res += gremlin.sizes.sizeWireNumber(EventForwarderWire.VERIFIED_EVENT_WIRE) + gremlin.sizes.sizeBool(self.verified_event);
        }
        return res;
    }
    pub fn encode(self: *const EventForwarder, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const EventForwarder, target: *gremlin.Writer) void {
        if (self.history_size != 0) {
            target.appendInt32(EventForwarderWire.HISTORY_SIZE_WIRE, self.history_size);
        }
        if (self.oldest_time_ns != 0) {
            target.appendInt64(EventForwarderWire.OLDEST_TIME_NS_WIRE, self.oldest_time_ns);
        }
        if (self.latest_time_ns != 0) {
            target.appendInt64(EventForwarderWire.LATEST_TIME_NS_WIRE, self.latest_time_ns);
        }
        if (self.down_time_ns != 0) {
            target.appendInt64(EventForwarderWire.DOWN_TIME_NS_WIRE, self.down_time_ns);
        }
        if (self.x_pixel != 0.0) {
            target.appendFloat32(EventForwarderWire.X_PIXEL_WIRE, self.x_pixel);
        }
        if (self.y_pixel != 0.0) {
            target.appendFloat32(EventForwarderWire.Y_PIXEL_WIRE, self.y_pixel);
        }
        if (self.has_x_movement != false) {
            target.appendBool(EventForwarderWire.HAS_X_MOVEMENT_WIRE, self.has_x_movement);
        }
        if (self.has_y_movement != false) {
            target.appendBool(EventForwarderWire.HAS_Y_MOVEMENT_WIRE, self.has_y_movement);
        }
        if (@intFromEnum(self.action) != 0) {
            target.appendInt32(EventForwarderWire.ACTION_WIRE, @intFromEnum(self.action));
        }
        if (self.verified_event != false) {
            target.appendBool(EventForwarderWire.VERIFIED_EVENT_WIRE, self.verified_event);
        }
    }
};
pub const EventForwarderReader = struct {
    buf: gremlin.Reader,
    _history_size: i32 = 0,
    _oldest_time_ns: i64 = 0,
    _latest_time_ns: i64 = 0,
    _down_time_ns: i64 = 0,
    _x_pixel: f32 = 0.0,
    _y_pixel: f32 = 0.0,
    _has_x_movement: bool = false,
    _has_y_movement: bool = false,
    _action: EventForwarder.AMotionEventAction = @enumFromInt(0),
    _verified_event: bool = false,
    pub fn init(src: []const u8) gremlin.Error!EventForwarderReader {
        const buf = gremlin.Reader.init(src);
        var res = EventForwarderReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                EventForwarderWire.HISTORY_SIZE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._history_size = result.value;
                },
                EventForwarderWire.OLDEST_TIME_NS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._oldest_time_ns = result.value;
                },
                EventForwarderWire.LATEST_TIME_NS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._latest_time_ns = result.value;
                },
                EventForwarderWire.DOWN_TIME_NS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._down_time_ns = result.value;
                },
                EventForwarderWire.X_PIXEL_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._x_pixel = result.value;
                },
                EventForwarderWire.Y_PIXEL_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._y_pixel = result.value;
                },
                EventForwarderWire.HAS_X_MOVEMENT_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._has_x_movement = result.value;
                },
                EventForwarderWire.HAS_Y_MOVEMENT_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._has_y_movement = result.value;
                },
                EventForwarderWire.ACTION_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._action = @enumFromInt(result.value);
                },
                EventForwarderWire.VERIFIED_EVENT_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._verified_event = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getHistorySize(self: *const EventForwarderReader) i32 {
        return self._history_size;
    }
    pub inline fn getOldestTimeNs(self: *const EventForwarderReader) i64 {
        return self._oldest_time_ns;
    }
    pub inline fn getLatestTimeNs(self: *const EventForwarderReader) i64 {
        return self._latest_time_ns;
    }
    pub inline fn getDownTimeNs(self: *const EventForwarderReader) i64 {
        return self._down_time_ns;
    }
    pub inline fn getXPixel(self: *const EventForwarderReader) f32 {
        return self._x_pixel;
    }
    pub inline fn getYPixel(self: *const EventForwarderReader) f32 {
        return self._y_pixel;
    }
    pub inline fn getHasXMovement(self: *const EventForwarderReader) bool {
        return self._has_x_movement;
    }
    pub inline fn getHasYMovement(self: *const EventForwarderReader) bool {
        return self._has_y_movement;
    }
    pub inline fn getAction(self: *const EventForwarderReader) EventForwarder.AMotionEventAction {
        return self._action;
    }
    pub inline fn getVerifiedEvent(self: *const EventForwarderReader) bool {
        return self._verified_event;
    }
};
const TouchDispositionGestureFilterWire = struct {
    const GESTURE_COUNT_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const TouchDispositionGestureFilter = struct {
    // fields
    gesture_count: i32 = 0,
    pub fn calcProtobufSize(self: *const TouchDispositionGestureFilter) usize {
        var res: usize = 0;
        if (self.gesture_count != 0) {
            res += gremlin.sizes.sizeWireNumber(TouchDispositionGestureFilterWire.GESTURE_COUNT_WIRE) + gremlin.sizes.sizeI32(self.gesture_count);
        }
        return res;
    }
    pub fn encode(self: *const TouchDispositionGestureFilter, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TouchDispositionGestureFilter, target: *gremlin.Writer) void {
        if (self.gesture_count != 0) {
            target.appendInt32(TouchDispositionGestureFilterWire.GESTURE_COUNT_WIRE, self.gesture_count);
        }
    }
};
pub const TouchDispositionGestureFilterReader = struct {
    buf: gremlin.Reader,
    _gesture_count: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!TouchDispositionGestureFilterReader {
        const buf = gremlin.Reader.init(src);
        var res = TouchDispositionGestureFilterReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TouchDispositionGestureFilterWire.GESTURE_COUNT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._gesture_count = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getGestureCount(self: *const TouchDispositionGestureFilterReader) i32 {
        return self._gesture_count;
    }
};
const ViewClassNameWire = struct {
    const NAME_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const ViewClassName = struct {
    // fields
    name: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const ViewClassName) usize {
        var res: usize = 0;
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(ViewClassNameWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const ViewClassName, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ViewClassName, target: *gremlin.Writer) void {
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(ViewClassNameWire.NAME_WIRE, v);
            }
        }
    }
};
pub const ViewClassNameReader = struct {
    buf: gremlin.Reader,
    _name: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!ViewClassNameReader {
        const buf = gremlin.Reader.init(src);
        var res = ViewClassNameReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ViewClassNameWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getName(self: *const ViewClassNameReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
};
const ChromeCompositorSchedulerStateV2Wire = struct {
    const STATE_MACHINE_WIRE: gremlin.ProtoWireNumber = 1;
    const OBSERVING_BEGIN_FRAME_SOURCE_WIRE: gremlin.ProtoWireNumber = 2;
    const BEGIN_IMPL_FRAME_DEADLINE_TASK_WIRE: gremlin.ProtoWireNumber = 3;
    const PENDING_BEGIN_FRAME_TASK_WIRE: gremlin.ProtoWireNumber = 4;
    const SKIPPED_LAST_FRAME_MISSED_EXCEEDED_DEADLINE_WIRE: gremlin.ProtoWireNumber = 5;
    const INSIDE_ACTION_WIRE: gremlin.ProtoWireNumber = 7;
    const DEADLINE_MODE_WIRE: gremlin.ProtoWireNumber = 8;
    const DEADLINE_US_WIRE: gremlin.ProtoWireNumber = 9;
    const DEADLINE_SCHEDULED_AT_US_WIRE: gremlin.ProtoWireNumber = 10;
    const NOW_US_WIRE: gremlin.ProtoWireNumber = 11;
    const NOW_TO_DEADLINE_DELTA_US_WIRE: gremlin.ProtoWireNumber = 12;
    const NOW_TO_DEADLINE_SCHEDULED_AT_DELTA_US_WIRE: gremlin.ProtoWireNumber = 13;
    const BEGIN_IMPL_FRAME_ARGS_WIRE: gremlin.ProtoWireNumber = 14;
    const BEGIN_FRAME_OBSERVER_STATE_WIRE: gremlin.ProtoWireNumber = 15;
    const BEGIN_FRAME_SOURCE_STATE_WIRE: gremlin.ProtoWireNumber = 16;
    const COMPOSITOR_TIMING_HISTORY_WIRE: gremlin.ProtoWireNumber = 17;
};
pub const ChromeCompositorSchedulerStateV2 = struct {
    // nested enums
    pub const BeginImplFrameDeadlineMode = enum(i32) {
        DEADLINE_MODE_UNSPECIFIED = 0,
        DEADLINE_MODE_NONE = 1,
        DEADLINE_MODE_IMMEDIATE = 2,
        DEADLINE_MODE_REGULAR = 3,
        DEADLINE_MODE_LATE = 4,
        DEADLINE_MODE_BLOCKED = 5,
        DEADLINE_MODE_WAIT_FOR_SCROLL = 6,
    };
    // fields
    state_machine: ?ChromeCompositorStateMachineV2 = null,
    observing_begin_frame_source: bool = false,
    begin_impl_frame_deadline_task: bool = false,
    pending_begin_frame_task: bool = false,
    skipped_last_frame_missed_exceeded_deadline: bool = false,
    inside_action: ChromeCompositorSchedulerActionV2 = @enumFromInt(0),
    deadline_mode: ChromeCompositorSchedulerStateV2.BeginImplFrameDeadlineMode = @enumFromInt(0),
    deadline_us: i64 = 0,
    deadline_scheduled_at_us: i64 = 0,
    now_us: i64 = 0,
    now_to_deadline_delta_us: i64 = 0,
    now_to_deadline_scheduled_at_delta_us: i64 = 0,
    begin_impl_frame_args: ?BeginImplFrameArgsV2 = null,
    begin_frame_observer_state: ?BeginFrameObserverStateV2 = null,
    begin_frame_source_state: ?BeginFrameSourceStateV2 = null,
    compositor_timing_history: ?CompositorTimingHistoryV2 = null,
    pub fn calcProtobufSize(self: *const ChromeCompositorSchedulerStateV2) usize {
        var res: usize = 0;
        if (self.state_machine) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorSchedulerStateV2Wire.STATE_MACHINE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.observing_begin_frame_source != false) {
            res += gremlin.sizes.sizeWireNumber(ChromeCompositorSchedulerStateV2Wire.OBSERVING_BEGIN_FRAME_SOURCE_WIRE) + gremlin.sizes.sizeBool(self.observing_begin_frame_source);
        }
        if (self.begin_impl_frame_deadline_task != false) {
            res += gremlin.sizes.sizeWireNumber(ChromeCompositorSchedulerStateV2Wire.BEGIN_IMPL_FRAME_DEADLINE_TASK_WIRE) + gremlin.sizes.sizeBool(self.begin_impl_frame_deadline_task);
        }
        if (self.pending_begin_frame_task != false) {
            res += gremlin.sizes.sizeWireNumber(ChromeCompositorSchedulerStateV2Wire.PENDING_BEGIN_FRAME_TASK_WIRE) + gremlin.sizes.sizeBool(self.pending_begin_frame_task);
        }
        if (self.skipped_last_frame_missed_exceeded_deadline != false) {
            res += gremlin.sizes.sizeWireNumber(ChromeCompositorSchedulerStateV2Wire.SKIPPED_LAST_FRAME_MISSED_EXCEEDED_DEADLINE_WIRE) + gremlin.sizes.sizeBool(self.skipped_last_frame_missed_exceeded_deadline);
        }
        if (@intFromEnum(self.inside_action) != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeCompositorSchedulerStateV2Wire.INSIDE_ACTION_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.inside_action));
        }
        if (@intFromEnum(self.deadline_mode) != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeCompositorSchedulerStateV2Wire.DEADLINE_MODE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.deadline_mode));
        }
        if (self.deadline_us != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeCompositorSchedulerStateV2Wire.DEADLINE_US_WIRE) + gremlin.sizes.sizeI64(self.deadline_us);
        }
        if (self.deadline_scheduled_at_us != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeCompositorSchedulerStateV2Wire.DEADLINE_SCHEDULED_AT_US_WIRE) + gremlin.sizes.sizeI64(self.deadline_scheduled_at_us);
        }
        if (self.now_us != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeCompositorSchedulerStateV2Wire.NOW_US_WIRE) + gremlin.sizes.sizeI64(self.now_us);
        }
        if (self.now_to_deadline_delta_us != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeCompositorSchedulerStateV2Wire.NOW_TO_DEADLINE_DELTA_US_WIRE) + gremlin.sizes.sizeI64(self.now_to_deadline_delta_us);
        }
        if (self.now_to_deadline_scheduled_at_delta_us != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeCompositorSchedulerStateV2Wire.NOW_TO_DEADLINE_SCHEDULED_AT_DELTA_US_WIRE) + gremlin.sizes.sizeI64(self.now_to_deadline_scheduled_at_delta_us);
        }
        if (self.begin_impl_frame_args) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorSchedulerStateV2Wire.BEGIN_IMPL_FRAME_ARGS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.begin_frame_observer_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorSchedulerStateV2Wire.BEGIN_FRAME_OBSERVER_STATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.begin_frame_source_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorSchedulerStateV2Wire.BEGIN_FRAME_SOURCE_STATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.compositor_timing_history) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorSchedulerStateV2Wire.COMPOSITOR_TIMING_HISTORY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const ChromeCompositorSchedulerStateV2, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ChromeCompositorSchedulerStateV2, target: *gremlin.Writer) void {
        if (self.state_machine) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeCompositorSchedulerStateV2Wire.STATE_MACHINE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.observing_begin_frame_source != false) {
            target.appendBool(ChromeCompositorSchedulerStateV2Wire.OBSERVING_BEGIN_FRAME_SOURCE_WIRE, self.observing_begin_frame_source);
        }
        if (self.begin_impl_frame_deadline_task != false) {
            target.appendBool(ChromeCompositorSchedulerStateV2Wire.BEGIN_IMPL_FRAME_DEADLINE_TASK_WIRE, self.begin_impl_frame_deadline_task);
        }
        if (self.pending_begin_frame_task != false) {
            target.appendBool(ChromeCompositorSchedulerStateV2Wire.PENDING_BEGIN_FRAME_TASK_WIRE, self.pending_begin_frame_task);
        }
        if (self.skipped_last_frame_missed_exceeded_deadline != false) {
            target.appendBool(ChromeCompositorSchedulerStateV2Wire.SKIPPED_LAST_FRAME_MISSED_EXCEEDED_DEADLINE_WIRE, self.skipped_last_frame_missed_exceeded_deadline);
        }
        if (@intFromEnum(self.inside_action) != 0) {
            target.appendInt32(ChromeCompositorSchedulerStateV2Wire.INSIDE_ACTION_WIRE, @intFromEnum(self.inside_action));
        }
        if (@intFromEnum(self.deadline_mode) != 0) {
            target.appendInt32(ChromeCompositorSchedulerStateV2Wire.DEADLINE_MODE_WIRE, @intFromEnum(self.deadline_mode));
        }
        if (self.deadline_us != 0) {
            target.appendInt64(ChromeCompositorSchedulerStateV2Wire.DEADLINE_US_WIRE, self.deadline_us);
        }
        if (self.deadline_scheduled_at_us != 0) {
            target.appendInt64(ChromeCompositorSchedulerStateV2Wire.DEADLINE_SCHEDULED_AT_US_WIRE, self.deadline_scheduled_at_us);
        }
        if (self.now_us != 0) {
            target.appendInt64(ChromeCompositorSchedulerStateV2Wire.NOW_US_WIRE, self.now_us);
        }
        if (self.now_to_deadline_delta_us != 0) {
            target.appendInt64(ChromeCompositorSchedulerStateV2Wire.NOW_TO_DEADLINE_DELTA_US_WIRE, self.now_to_deadline_delta_us);
        }
        if (self.now_to_deadline_scheduled_at_delta_us != 0) {
            target.appendInt64(ChromeCompositorSchedulerStateV2Wire.NOW_TO_DEADLINE_SCHEDULED_AT_DELTA_US_WIRE, self.now_to_deadline_scheduled_at_delta_us);
        }
        if (self.begin_impl_frame_args) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeCompositorSchedulerStateV2Wire.BEGIN_IMPL_FRAME_ARGS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.begin_frame_observer_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeCompositorSchedulerStateV2Wire.BEGIN_FRAME_OBSERVER_STATE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.begin_frame_source_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeCompositorSchedulerStateV2Wire.BEGIN_FRAME_SOURCE_STATE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.compositor_timing_history) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeCompositorSchedulerStateV2Wire.COMPOSITOR_TIMING_HISTORY_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const ChromeCompositorSchedulerStateV2Reader = struct {
    buf: gremlin.Reader,
    _state_machine_buf: ?[]const u8 = null,
    _observing_begin_frame_source: bool = false,
    _begin_impl_frame_deadline_task: bool = false,
    _pending_begin_frame_task: bool = false,
    _skipped_last_frame_missed_exceeded_deadline: bool = false,
    _inside_action: ChromeCompositorSchedulerActionV2 = @enumFromInt(0),
    _deadline_mode: ChromeCompositorSchedulerStateV2.BeginImplFrameDeadlineMode = @enumFromInt(0),
    _deadline_us: i64 = 0,
    _deadline_scheduled_at_us: i64 = 0,
    _now_us: i64 = 0,
    _now_to_deadline_delta_us: i64 = 0,
    _now_to_deadline_scheduled_at_delta_us: i64 = 0,
    _begin_impl_frame_args_buf: ?[]const u8 = null,
    _begin_frame_observer_state_buf: ?[]const u8 = null,
    _begin_frame_source_state_buf: ?[]const u8 = null,
    _compositor_timing_history_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!ChromeCompositorSchedulerStateV2Reader {
        const buf = gremlin.Reader.init(src);
        var res = ChromeCompositorSchedulerStateV2Reader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ChromeCompositorSchedulerStateV2Wire.STATE_MACHINE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._state_machine_buf = result.value;
                },
                ChromeCompositorSchedulerStateV2Wire.OBSERVING_BEGIN_FRAME_SOURCE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._observing_begin_frame_source = result.value;
                },
                ChromeCompositorSchedulerStateV2Wire.BEGIN_IMPL_FRAME_DEADLINE_TASK_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._begin_impl_frame_deadline_task = result.value;
                },
                ChromeCompositorSchedulerStateV2Wire.PENDING_BEGIN_FRAME_TASK_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._pending_begin_frame_task = result.value;
                },
                ChromeCompositorSchedulerStateV2Wire.SKIPPED_LAST_FRAME_MISSED_EXCEEDED_DEADLINE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._skipped_last_frame_missed_exceeded_deadline = result.value;
                },
                ChromeCompositorSchedulerStateV2Wire.INSIDE_ACTION_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._inside_action = @enumFromInt(result.value);
                },
                ChromeCompositorSchedulerStateV2Wire.DEADLINE_MODE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._deadline_mode = @enumFromInt(result.value);
                },
                ChromeCompositorSchedulerStateV2Wire.DEADLINE_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._deadline_us = result.value;
                },
                ChromeCompositorSchedulerStateV2Wire.DEADLINE_SCHEDULED_AT_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._deadline_scheduled_at_us = result.value;
                },
                ChromeCompositorSchedulerStateV2Wire.NOW_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._now_us = result.value;
                },
                ChromeCompositorSchedulerStateV2Wire.NOW_TO_DEADLINE_DELTA_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._now_to_deadline_delta_us = result.value;
                },
                ChromeCompositorSchedulerStateV2Wire.NOW_TO_DEADLINE_SCHEDULED_AT_DELTA_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._now_to_deadline_scheduled_at_delta_us = result.value;
                },
                ChromeCompositorSchedulerStateV2Wire.BEGIN_IMPL_FRAME_ARGS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._begin_impl_frame_args_buf = result.value;
                },
                ChromeCompositorSchedulerStateV2Wire.BEGIN_FRAME_OBSERVER_STATE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._begin_frame_observer_state_buf = result.value;
                },
                ChromeCompositorSchedulerStateV2Wire.BEGIN_FRAME_SOURCE_STATE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._begin_frame_source_state_buf = result.value;
                },
                ChromeCompositorSchedulerStateV2Wire.COMPOSITOR_TIMING_HISTORY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._compositor_timing_history_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getStateMachine(self: *const ChromeCompositorSchedulerStateV2Reader) gremlin.Error!ChromeCompositorStateMachineV2Reader {
        if (self._state_machine_buf) |buf| {
            return try ChromeCompositorStateMachineV2Reader.init(buf);
        }
        return try ChromeCompositorStateMachineV2Reader.init(&[_]u8{});
    }
    pub inline fn getObservingBeginFrameSource(self: *const ChromeCompositorSchedulerStateV2Reader) bool {
        return self._observing_begin_frame_source;
    }
    pub inline fn getBeginImplFrameDeadlineTask(self: *const ChromeCompositorSchedulerStateV2Reader) bool {
        return self._begin_impl_frame_deadline_task;
    }
    pub inline fn getPendingBeginFrameTask(self: *const ChromeCompositorSchedulerStateV2Reader) bool {
        return self._pending_begin_frame_task;
    }
    pub inline fn getSkippedLastFrameMissedExceededDeadline(self: *const ChromeCompositorSchedulerStateV2Reader) bool {
        return self._skipped_last_frame_missed_exceeded_deadline;
    }
    pub inline fn getInsideAction(self: *const ChromeCompositorSchedulerStateV2Reader) ChromeCompositorSchedulerActionV2 {
        return self._inside_action;
    }
    pub inline fn getDeadlineMode(self: *const ChromeCompositorSchedulerStateV2Reader) ChromeCompositorSchedulerStateV2.BeginImplFrameDeadlineMode {
        return self._deadline_mode;
    }
    pub inline fn getDeadlineUs(self: *const ChromeCompositorSchedulerStateV2Reader) i64 {
        return self._deadline_us;
    }
    pub inline fn getDeadlineScheduledAtUs(self: *const ChromeCompositorSchedulerStateV2Reader) i64 {
        return self._deadline_scheduled_at_us;
    }
    pub inline fn getNowUs(self: *const ChromeCompositorSchedulerStateV2Reader) i64 {
        return self._now_us;
    }
    pub inline fn getNowToDeadlineDeltaUs(self: *const ChromeCompositorSchedulerStateV2Reader) i64 {
        return self._now_to_deadline_delta_us;
    }
    pub inline fn getNowToDeadlineScheduledAtDeltaUs(self: *const ChromeCompositorSchedulerStateV2Reader) i64 {
        return self._now_to_deadline_scheduled_at_delta_us;
    }
    pub fn getBeginImplFrameArgs(self: *const ChromeCompositorSchedulerStateV2Reader) gremlin.Error!BeginImplFrameArgsV2Reader {
        if (self._begin_impl_frame_args_buf) |buf| {
            return try BeginImplFrameArgsV2Reader.init(buf);
        }
        return try BeginImplFrameArgsV2Reader.init(&[_]u8{});
    }
    pub fn getBeginFrameObserverState(self: *const ChromeCompositorSchedulerStateV2Reader) gremlin.Error!BeginFrameObserverStateV2Reader {
        if (self._begin_frame_observer_state_buf) |buf| {
            return try BeginFrameObserverStateV2Reader.init(buf);
        }
        return try BeginFrameObserverStateV2Reader.init(&[_]u8{});
    }
    pub fn getBeginFrameSourceState(self: *const ChromeCompositorSchedulerStateV2Reader) gremlin.Error!BeginFrameSourceStateV2Reader {
        if (self._begin_frame_source_state_buf) |buf| {
            return try BeginFrameSourceStateV2Reader.init(buf);
        }
        return try BeginFrameSourceStateV2Reader.init(&[_]u8{});
    }
    pub fn getCompositorTimingHistory(self: *const ChromeCompositorSchedulerStateV2Reader) gremlin.Error!CompositorTimingHistoryV2Reader {
        if (self._compositor_timing_history_buf) |buf| {
            return try CompositorTimingHistoryV2Reader.init(buf);
        }
        return try CompositorTimingHistoryV2Reader.init(&[_]u8{});
    }
};
const ChromeCompositorStateMachineV2Wire = struct {
    const MAJOR_STATE_WIRE: gremlin.ProtoWireNumber = 1;
    const MINOR_STATE_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const ChromeCompositorStateMachineV2 = struct {
    // nested structs
    const MajorStateV2Wire = struct {
        const NEXT_ACTION_WIRE: gremlin.ProtoWireNumber = 1;
        const BEGIN_IMPL_FRAME_STATE_WIRE: gremlin.ProtoWireNumber = 2;
        const BEGIN_MAIN_FRAME_STATE_WIRE: gremlin.ProtoWireNumber = 3;
        const LAYER_TREE_FRAME_SINK_STATE_WIRE: gremlin.ProtoWireNumber = 4;
        const FORCED_REDRAW_STATE_WIRE: gremlin.ProtoWireNumber = 5;
    };
    pub const MajorStateV2 = struct {
        // nested enums
        pub const BeginImplFrameState = enum(i32) {
            BEGIN_IMPL_FRAME_UNSPECIFIED = 0,
            BEGIN_IMPL_FRAME_IDLE = 1,
            BEGIN_IMPL_FRAME_INSIDE_BEGIN_FRAME = 2,
            BEGIN_IMPL_FRAME_INSIDE_DEADLINE = 3,
        };
        pub const BeginMainFrameState = enum(i32) {
            BEGIN_MAIN_FRAME_UNSPECIFIED = 0,
            BEGIN_MAIN_FRAME_IDLE = 1,
            BEGIN_MAIN_FRAME_SENT = 2,
            BEGIN_MAIN_FRAME_READY_TO_COMMIT = 3,
        };
        pub const LayerTreeFrameSinkState = enum(i32) {
            LAYER_TREE_FRAME_UNSPECIFIED = 0,
            LAYER_TREE_FRAME_NONE = 1,
            LAYER_TREE_FRAME_ACTIVE = 2,
            LAYER_TREE_FRAME_CREATING = 3,
            LAYER_TREE_FRAME_WAITING_FOR_FIRST_COMMIT = 4,
            LAYER_TREE_FRAME_WAITING_FOR_FIRST_ACTIVATION = 5,
        };
        pub const ForcedRedrawOnTimeoutState = enum(i32) {
            FORCED_REDRAW_UNSPECIFIED = 0,
            FORCED_REDRAW_IDLE = 1,
            FORCED_REDRAW_WAITING_FOR_COMMIT = 2,
            FORCED_REDRAW_WAITING_FOR_ACTIVATION = 3,
            FORCED_REDRAW_WAITING_FOR_DRAW = 4,
        };
        // fields
        next_action: ChromeCompositorSchedulerActionV2 = @enumFromInt(0),
        begin_impl_frame_state: ChromeCompositorStateMachineV2.MajorStateV2.BeginImplFrameState = @enumFromInt(0),
        begin_main_frame_state: ChromeCompositorStateMachineV2.MajorStateV2.BeginMainFrameState = @enumFromInt(0),
        layer_tree_frame_sink_state: ChromeCompositorStateMachineV2.MajorStateV2.LayerTreeFrameSinkState = @enumFromInt(0),
        forced_redraw_state: ChromeCompositorStateMachineV2.MajorStateV2.ForcedRedrawOnTimeoutState = @enumFromInt(0),
        pub fn calcProtobufSize(self: *const ChromeCompositorStateMachineV2.MajorStateV2) usize {
            var res: usize = 0;
            if (@intFromEnum(self.next_action) != 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MajorStateV2Wire.NEXT_ACTION_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.next_action));
            }
            if (@intFromEnum(self.begin_impl_frame_state) != 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MajorStateV2Wire.BEGIN_IMPL_FRAME_STATE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.begin_impl_frame_state));
            }
            if (@intFromEnum(self.begin_main_frame_state) != 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MajorStateV2Wire.BEGIN_MAIN_FRAME_STATE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.begin_main_frame_state));
            }
            if (@intFromEnum(self.layer_tree_frame_sink_state) != 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MajorStateV2Wire.LAYER_TREE_FRAME_SINK_STATE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.layer_tree_frame_sink_state));
            }
            if (@intFromEnum(self.forced_redraw_state) != 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MajorStateV2Wire.FORCED_REDRAW_STATE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.forced_redraw_state));
            }
            return res;
        }
        pub fn encode(self: *const ChromeCompositorStateMachineV2.MajorStateV2, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const ChromeCompositorStateMachineV2.MajorStateV2, target: *gremlin.Writer) void {
            if (@intFromEnum(self.next_action) != 0) {
                target.appendInt32(ChromeCompositorStateMachineV2.MajorStateV2Wire.NEXT_ACTION_WIRE, @intFromEnum(self.next_action));
            }
            if (@intFromEnum(self.begin_impl_frame_state) != 0) {
                target.appendInt32(ChromeCompositorStateMachineV2.MajorStateV2Wire.BEGIN_IMPL_FRAME_STATE_WIRE, @intFromEnum(self.begin_impl_frame_state));
            }
            if (@intFromEnum(self.begin_main_frame_state) != 0) {
                target.appendInt32(ChromeCompositorStateMachineV2.MajorStateV2Wire.BEGIN_MAIN_FRAME_STATE_WIRE, @intFromEnum(self.begin_main_frame_state));
            }
            if (@intFromEnum(self.layer_tree_frame_sink_state) != 0) {
                target.appendInt32(ChromeCompositorStateMachineV2.MajorStateV2Wire.LAYER_TREE_FRAME_SINK_STATE_WIRE, @intFromEnum(self.layer_tree_frame_sink_state));
            }
            if (@intFromEnum(self.forced_redraw_state) != 0) {
                target.appendInt32(ChromeCompositorStateMachineV2.MajorStateV2Wire.FORCED_REDRAW_STATE_WIRE, @intFromEnum(self.forced_redraw_state));
            }
        }
    };
    pub const MajorStateV2Reader = struct {
        buf: gremlin.Reader,
        _next_action: ChromeCompositorSchedulerActionV2 = @enumFromInt(0),
        _begin_impl_frame_state: ChromeCompositorStateMachineV2.MajorStateV2.BeginImplFrameState = @enumFromInt(0),
        _begin_main_frame_state: ChromeCompositorStateMachineV2.MajorStateV2.BeginMainFrameState = @enumFromInt(0),
        _layer_tree_frame_sink_state: ChromeCompositorStateMachineV2.MajorStateV2.LayerTreeFrameSinkState = @enumFromInt(0),
        _forced_redraw_state: ChromeCompositorStateMachineV2.MajorStateV2.ForcedRedrawOnTimeoutState = @enumFromInt(0),
        pub fn init(src: []const u8) gremlin.Error!ChromeCompositorStateMachineV2.MajorStateV2Reader {
            const buf = gremlin.Reader.init(src);
            var res = ChromeCompositorStateMachineV2.MajorStateV2Reader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    ChromeCompositorStateMachineV2.MajorStateV2Wire.NEXT_ACTION_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._next_action = @enumFromInt(result.value);
                    },
                    ChromeCompositorStateMachineV2.MajorStateV2Wire.BEGIN_IMPL_FRAME_STATE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._begin_impl_frame_state = @enumFromInt(result.value);
                    },
                    ChromeCompositorStateMachineV2.MajorStateV2Wire.BEGIN_MAIN_FRAME_STATE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._begin_main_frame_state = @enumFromInt(result.value);
                    },
                    ChromeCompositorStateMachineV2.MajorStateV2Wire.LAYER_TREE_FRAME_SINK_STATE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._layer_tree_frame_sink_state = @enumFromInt(result.value);
                    },
                    ChromeCompositorStateMachineV2.MajorStateV2Wire.FORCED_REDRAW_STATE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._forced_redraw_state = @enumFromInt(result.value);
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getNextAction(self: *const ChromeCompositorStateMachineV2.MajorStateV2Reader) ChromeCompositorSchedulerActionV2 {
            return self._next_action;
        }
        pub inline fn getBeginImplFrameState(self: *const ChromeCompositorStateMachineV2.MajorStateV2Reader) ChromeCompositorStateMachineV2.MajorStateV2.BeginImplFrameState {
            return self._begin_impl_frame_state;
        }
        pub inline fn getBeginMainFrameState(self: *const ChromeCompositorStateMachineV2.MajorStateV2Reader) ChromeCompositorStateMachineV2.MajorStateV2.BeginMainFrameState {
            return self._begin_main_frame_state;
        }
        pub inline fn getLayerTreeFrameSinkState(self: *const ChromeCompositorStateMachineV2.MajorStateV2Reader) ChromeCompositorStateMachineV2.MajorStateV2.LayerTreeFrameSinkState {
            return self._layer_tree_frame_sink_state;
        }
        pub inline fn getForcedRedrawState(self: *const ChromeCompositorStateMachineV2.MajorStateV2Reader) ChromeCompositorStateMachineV2.MajorStateV2.ForcedRedrawOnTimeoutState {
            return self._forced_redraw_state;
        }
    };
    const MinorStateV2Wire = struct {
        const COMMIT_COUNT_WIRE: gremlin.ProtoWireNumber = 1;
        const CURRENT_FRAME_NUMBER_WIRE: gremlin.ProtoWireNumber = 2;
        const LAST_FRAME_NUMBER_SUBMIT_PERFORMED_WIRE: gremlin.ProtoWireNumber = 3;
        const LAST_FRAME_NUMBER_DRAW_PERFORMED_WIRE: gremlin.ProtoWireNumber = 4;
        const LAST_FRAME_NUMBER_BEGIN_MAIN_FRAME_SENT_WIRE: gremlin.ProtoWireNumber = 5;
        const DID_DRAW_WIRE: gremlin.ProtoWireNumber = 6;
        const DID_SEND_BEGIN_MAIN_FRAME_FOR_CURRENT_FRAME_WIRE: gremlin.ProtoWireNumber = 7;
        const DID_NOTIFY_BEGIN_MAIN_FRAME_NOT_EXPECTED_UNTIL_WIRE: gremlin.ProtoWireNumber = 8;
        const DID_NOTIFY_BEGIN_MAIN_FRAME_NOT_EXPECTED_SOON_WIRE: gremlin.ProtoWireNumber = 9;
        const WANTS_BEGIN_MAIN_FRAME_NOT_EXPECTED_WIRE: gremlin.ProtoWireNumber = 10;
        const DID_COMMIT_DURING_FRAME_WIRE: gremlin.ProtoWireNumber = 11;
        const DID_INVALIDATE_LAYER_TREE_FRAME_SINK_WIRE: gremlin.ProtoWireNumber = 12;
        const DID_PERFORM_IMPL_SIDE_INVALIDAION_WIRE: gremlin.ProtoWireNumber = 13;
        const DID_PREPARE_TILES_WIRE: gremlin.ProtoWireNumber = 14;
        const CONSECUTIVE_CHECKERBOARD_ANIMATIONS_WIRE: gremlin.ProtoWireNumber = 15;
        const PENDING_SUBMIT_FRAMES_WIRE: gremlin.ProtoWireNumber = 16;
        const SUBMIT_FRAMES_WITH_CURRENT_LAYER_TREE_FRAME_SINK_WIRE: gremlin.ProtoWireNumber = 17;
        const NEEDS_REDRAW_WIRE: gremlin.ProtoWireNumber = 18;
        const NEEDS_PREPARE_TILES_WIRE: gremlin.ProtoWireNumber = 19;
        const NEEDS_BEGIN_MAIN_FRAME_WIRE: gremlin.ProtoWireNumber = 20;
        const NEEDS_ONE_BEGIN_IMPL_FRAME_WIRE: gremlin.ProtoWireNumber = 21;
        const VISIBLE_WIRE: gremlin.ProtoWireNumber = 22;
        const BEGIN_FRAME_SOURCE_PAUSED_WIRE: gremlin.ProtoWireNumber = 23;
        const CAN_DRAW_WIRE: gremlin.ProtoWireNumber = 24;
        const RESOURCELESS_DRAW_WIRE: gremlin.ProtoWireNumber = 25;
        const HAS_PENDING_TREE_WIRE: gremlin.ProtoWireNumber = 26;
        const PENDING_TREE_IS_READY_FOR_ACTIVATION_WIRE: gremlin.ProtoWireNumber = 27;
        const ACTIVE_TREE_NEEDS_FIRST_DRAW_WIRE: gremlin.ProtoWireNumber = 28;
        const ACTIVE_TREE_IS_READY_TO_DRAW_WIRE: gremlin.ProtoWireNumber = 29;
        const DID_CREATE_AND_INITIALIZE_FIRST_LAYER_TREE_FRAME_SINK_WIRE: gremlin.ProtoWireNumber = 30;
        const TREE_PRIORITY_WIRE: gremlin.ProtoWireNumber = 31;
        const SCROLL_HANDLER_STATE_WIRE: gremlin.ProtoWireNumber = 32;
        const CRITICAL_BEGIN_MAIN_FRAME_TO_ACTIVATE_IS_FAST_WIRE: gremlin.ProtoWireNumber = 33;
        const MAIN_THREAD_MISSED_LAST_DEADLINE_WIRE: gremlin.ProtoWireNumber = 34;
        const VIDEO_NEEDS_BEGIN_FRAMES_WIRE: gremlin.ProtoWireNumber = 36;
        const DEFER_BEGIN_MAIN_FRAME_WIRE: gremlin.ProtoWireNumber = 37;
        const LAST_COMMIT_HAD_NO_UPDATES_WIRE: gremlin.ProtoWireNumber = 38;
        const DID_DRAW_IN_LAST_FRAME_WIRE: gremlin.ProtoWireNumber = 39;
        const DID_SUBMIT_IN_LAST_FRAME_WIRE: gremlin.ProtoWireNumber = 40;
        const NEEDS_IMPL_SIDE_INVALIDATION_WIRE: gremlin.ProtoWireNumber = 41;
        const CURRENT_PENDING_TREE_IS_IMPL_SIDE_WIRE: gremlin.ProtoWireNumber = 42;
        const PREVIOUS_PENDING_TREE_WAS_IMPL_SIDE_WIRE: gremlin.ProtoWireNumber = 43;
        const PROCESSING_ANIMATION_WORKLETS_FOR_ACTIVE_TREE_WIRE: gremlin.ProtoWireNumber = 44;
        const PROCESSING_ANIMATION_WORKLETS_FOR_PENDING_TREE_WIRE: gremlin.ProtoWireNumber = 45;
        const PROCESSING_PAINT_WORKLETS_FOR_PENDING_TREE_WIRE: gremlin.ProtoWireNumber = 46;
        const SHOULD_WARM_UP_WIRE: gremlin.ProtoWireNumber = 47;
    };
    pub const MinorStateV2 = struct {
        // nested enums
        pub const TreePriority = enum(i32) {
            TREE_PRIORITY_UNSPECIFIED = 0,
            TREE_PRIORITY_SAME_PRIORITY_FOR_BOTH_TREES = 1,
            TREE_PRIORITY_SMOOTHNESS_TAKES_PRIORITY = 2,
            TREE_PRIORITY_NEW_CONTENT_TAKES_PRIORITY = 3,
        };
        pub const ScrollHandlerState = enum(i32) {
            SCROLL_HANDLER_UNSPECIFIED = 0,
            SCROLL_AFFECTS_SCROLL_HANDLER = 1,
            SCROLL_DOES_NOT_AFFECT_SCROLL_HANDLER = 2,
        };
        // fields
        commit_count: i32 = 0,
        current_frame_number: i32 = 0,
        last_frame_number_submit_performed: i32 = 0,
        last_frame_number_draw_performed: i32 = 0,
        last_frame_number_begin_main_frame_sent: i32 = 0,
        did_draw: bool = false,
        did_send_begin_main_frame_for_current_frame: bool = false,
        did_notify_begin_main_frame_not_expected_until: bool = false,
        did_notify_begin_main_frame_not_expected_soon: bool = false,
        wants_begin_main_frame_not_expected: bool = false,
        did_commit_during_frame: bool = false,
        did_invalidate_layer_tree_frame_sink: bool = false,
        did_perform_impl_side_invalidaion: bool = false,
        did_prepare_tiles: bool = false,
        consecutive_checkerboard_animations: i32 = 0,
        pending_submit_frames: i32 = 0,
        submit_frames_with_current_layer_tree_frame_sink: i32 = 0,
        needs_redraw: bool = false,
        needs_prepare_tiles: bool = false,
        needs_begin_main_frame: bool = false,
        needs_one_begin_impl_frame: bool = false,
        visible: bool = false,
        begin_frame_source_paused: bool = false,
        can_draw: bool = false,
        resourceless_draw: bool = false,
        has_pending_tree: bool = false,
        pending_tree_is_ready_for_activation: bool = false,
        active_tree_needs_first_draw: bool = false,
        active_tree_is_ready_to_draw: bool = false,
        did_create_and_initialize_first_layer_tree_frame_sink: bool = false,
        tree_priority: ChromeCompositorStateMachineV2.MinorStateV2.TreePriority = @enumFromInt(0),
        scroll_handler_state: ChromeCompositorStateMachineV2.MinorStateV2.ScrollHandlerState = @enumFromInt(0),
        critical_begin_main_frame_to_activate_is_fast: bool = false,
        main_thread_missed_last_deadline: bool = false,
        video_needs_begin_frames: bool = false,
        defer_begin_main_frame: bool = false,
        last_commit_had_no_updates: bool = false,
        did_draw_in_last_frame: bool = false,
        did_submit_in_last_frame: bool = false,
        needs_impl_side_invalidation: bool = false,
        current_pending_tree_is_impl_side: bool = false,
        previous_pending_tree_was_impl_side: bool = false,
        processing_animation_worklets_for_active_tree: bool = false,
        processing_animation_worklets_for_pending_tree: bool = false,
        processing_paint_worklets_for_pending_tree: bool = false,
        should_warm_up: bool = false,
        pub fn calcProtobufSize(self: *const ChromeCompositorStateMachineV2.MinorStateV2) usize {
            var res: usize = 0;
            if (self.commit_count != 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.COMMIT_COUNT_WIRE) + gremlin.sizes.sizeI32(self.commit_count);
            }
            if (self.current_frame_number != 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.CURRENT_FRAME_NUMBER_WIRE) + gremlin.sizes.sizeI32(self.current_frame_number);
            }
            if (self.last_frame_number_submit_performed != 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.LAST_FRAME_NUMBER_SUBMIT_PERFORMED_WIRE) + gremlin.sizes.sizeI32(self.last_frame_number_submit_performed);
            }
            if (self.last_frame_number_draw_performed != 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.LAST_FRAME_NUMBER_DRAW_PERFORMED_WIRE) + gremlin.sizes.sizeI32(self.last_frame_number_draw_performed);
            }
            if (self.last_frame_number_begin_main_frame_sent != 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.LAST_FRAME_NUMBER_BEGIN_MAIN_FRAME_SENT_WIRE) + gremlin.sizes.sizeI32(self.last_frame_number_begin_main_frame_sent);
            }
            if (self.did_draw != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.DID_DRAW_WIRE) + gremlin.sizes.sizeBool(self.did_draw);
            }
            if (self.did_send_begin_main_frame_for_current_frame != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.DID_SEND_BEGIN_MAIN_FRAME_FOR_CURRENT_FRAME_WIRE) + gremlin.sizes.sizeBool(self.did_send_begin_main_frame_for_current_frame);
            }
            if (self.did_notify_begin_main_frame_not_expected_until != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.DID_NOTIFY_BEGIN_MAIN_FRAME_NOT_EXPECTED_UNTIL_WIRE) + gremlin.sizes.sizeBool(self.did_notify_begin_main_frame_not_expected_until);
            }
            if (self.did_notify_begin_main_frame_not_expected_soon != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.DID_NOTIFY_BEGIN_MAIN_FRAME_NOT_EXPECTED_SOON_WIRE) + gremlin.sizes.sizeBool(self.did_notify_begin_main_frame_not_expected_soon);
            }
            if (self.wants_begin_main_frame_not_expected != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.WANTS_BEGIN_MAIN_FRAME_NOT_EXPECTED_WIRE) + gremlin.sizes.sizeBool(self.wants_begin_main_frame_not_expected);
            }
            if (self.did_commit_during_frame != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.DID_COMMIT_DURING_FRAME_WIRE) + gremlin.sizes.sizeBool(self.did_commit_during_frame);
            }
            if (self.did_invalidate_layer_tree_frame_sink != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.DID_INVALIDATE_LAYER_TREE_FRAME_SINK_WIRE) + gremlin.sizes.sizeBool(self.did_invalidate_layer_tree_frame_sink);
            }
            if (self.did_perform_impl_side_invalidaion != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.DID_PERFORM_IMPL_SIDE_INVALIDAION_WIRE) + gremlin.sizes.sizeBool(self.did_perform_impl_side_invalidaion);
            }
            if (self.did_prepare_tiles != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.DID_PREPARE_TILES_WIRE) + gremlin.sizes.sizeBool(self.did_prepare_tiles);
            }
            if (self.consecutive_checkerboard_animations != 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.CONSECUTIVE_CHECKERBOARD_ANIMATIONS_WIRE) + gremlin.sizes.sizeI32(self.consecutive_checkerboard_animations);
            }
            if (self.pending_submit_frames != 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.PENDING_SUBMIT_FRAMES_WIRE) + gremlin.sizes.sizeI32(self.pending_submit_frames);
            }
            if (self.submit_frames_with_current_layer_tree_frame_sink != 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.SUBMIT_FRAMES_WITH_CURRENT_LAYER_TREE_FRAME_SINK_WIRE) + gremlin.sizes.sizeI32(self.submit_frames_with_current_layer_tree_frame_sink);
            }
            if (self.needs_redraw != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.NEEDS_REDRAW_WIRE) + gremlin.sizes.sizeBool(self.needs_redraw);
            }
            if (self.needs_prepare_tiles != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.NEEDS_PREPARE_TILES_WIRE) + gremlin.sizes.sizeBool(self.needs_prepare_tiles);
            }
            if (self.needs_begin_main_frame != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.NEEDS_BEGIN_MAIN_FRAME_WIRE) + gremlin.sizes.sizeBool(self.needs_begin_main_frame);
            }
            if (self.needs_one_begin_impl_frame != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.NEEDS_ONE_BEGIN_IMPL_FRAME_WIRE) + gremlin.sizes.sizeBool(self.needs_one_begin_impl_frame);
            }
            if (self.visible != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.VISIBLE_WIRE) + gremlin.sizes.sizeBool(self.visible);
            }
            if (self.begin_frame_source_paused != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.BEGIN_FRAME_SOURCE_PAUSED_WIRE) + gremlin.sizes.sizeBool(self.begin_frame_source_paused);
            }
            if (self.can_draw != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.CAN_DRAW_WIRE) + gremlin.sizes.sizeBool(self.can_draw);
            }
            if (self.resourceless_draw != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.RESOURCELESS_DRAW_WIRE) + gremlin.sizes.sizeBool(self.resourceless_draw);
            }
            if (self.has_pending_tree != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.HAS_PENDING_TREE_WIRE) + gremlin.sizes.sizeBool(self.has_pending_tree);
            }
            if (self.pending_tree_is_ready_for_activation != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.PENDING_TREE_IS_READY_FOR_ACTIVATION_WIRE) + gremlin.sizes.sizeBool(self.pending_tree_is_ready_for_activation);
            }
            if (self.active_tree_needs_first_draw != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.ACTIVE_TREE_NEEDS_FIRST_DRAW_WIRE) + gremlin.sizes.sizeBool(self.active_tree_needs_first_draw);
            }
            if (self.active_tree_is_ready_to_draw != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.ACTIVE_TREE_IS_READY_TO_DRAW_WIRE) + gremlin.sizes.sizeBool(self.active_tree_is_ready_to_draw);
            }
            if (self.did_create_and_initialize_first_layer_tree_frame_sink != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.DID_CREATE_AND_INITIALIZE_FIRST_LAYER_TREE_FRAME_SINK_WIRE) + gremlin.sizes.sizeBool(self.did_create_and_initialize_first_layer_tree_frame_sink);
            }
            if (@intFromEnum(self.tree_priority) != 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.TREE_PRIORITY_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.tree_priority));
            }
            if (@intFromEnum(self.scroll_handler_state) != 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.SCROLL_HANDLER_STATE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.scroll_handler_state));
            }
            if (self.critical_begin_main_frame_to_activate_is_fast != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.CRITICAL_BEGIN_MAIN_FRAME_TO_ACTIVATE_IS_FAST_WIRE) + gremlin.sizes.sizeBool(self.critical_begin_main_frame_to_activate_is_fast);
            }
            if (self.main_thread_missed_last_deadline != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.MAIN_THREAD_MISSED_LAST_DEADLINE_WIRE) + gremlin.sizes.sizeBool(self.main_thread_missed_last_deadline);
            }
            if (self.video_needs_begin_frames != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.VIDEO_NEEDS_BEGIN_FRAMES_WIRE) + gremlin.sizes.sizeBool(self.video_needs_begin_frames);
            }
            if (self.defer_begin_main_frame != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.DEFER_BEGIN_MAIN_FRAME_WIRE) + gremlin.sizes.sizeBool(self.defer_begin_main_frame);
            }
            if (self.last_commit_had_no_updates != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.LAST_COMMIT_HAD_NO_UPDATES_WIRE) + gremlin.sizes.sizeBool(self.last_commit_had_no_updates);
            }
            if (self.did_draw_in_last_frame != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.DID_DRAW_IN_LAST_FRAME_WIRE) + gremlin.sizes.sizeBool(self.did_draw_in_last_frame);
            }
            if (self.did_submit_in_last_frame != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.DID_SUBMIT_IN_LAST_FRAME_WIRE) + gremlin.sizes.sizeBool(self.did_submit_in_last_frame);
            }
            if (self.needs_impl_side_invalidation != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.NEEDS_IMPL_SIDE_INVALIDATION_WIRE) + gremlin.sizes.sizeBool(self.needs_impl_side_invalidation);
            }
            if (self.current_pending_tree_is_impl_side != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.CURRENT_PENDING_TREE_IS_IMPL_SIDE_WIRE) + gremlin.sizes.sizeBool(self.current_pending_tree_is_impl_side);
            }
            if (self.previous_pending_tree_was_impl_side != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.PREVIOUS_PENDING_TREE_WAS_IMPL_SIDE_WIRE) + gremlin.sizes.sizeBool(self.previous_pending_tree_was_impl_side);
            }
            if (self.processing_animation_worklets_for_active_tree != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.PROCESSING_ANIMATION_WORKLETS_FOR_ACTIVE_TREE_WIRE) + gremlin.sizes.sizeBool(self.processing_animation_worklets_for_active_tree);
            }
            if (self.processing_animation_worklets_for_pending_tree != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.PROCESSING_ANIMATION_WORKLETS_FOR_PENDING_TREE_WIRE) + gremlin.sizes.sizeBool(self.processing_animation_worklets_for_pending_tree);
            }
            if (self.processing_paint_worklets_for_pending_tree != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.PROCESSING_PAINT_WORKLETS_FOR_PENDING_TREE_WIRE) + gremlin.sizes.sizeBool(self.processing_paint_worklets_for_pending_tree);
            }
            if (self.should_warm_up != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2.MinorStateV2Wire.SHOULD_WARM_UP_WIRE) + gremlin.sizes.sizeBool(self.should_warm_up);
            }
            return res;
        }
        pub fn encode(self: *const ChromeCompositorStateMachineV2.MinorStateV2, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const ChromeCompositorStateMachineV2.MinorStateV2, target: *gremlin.Writer) void {
            if (self.commit_count != 0) {
                target.appendInt32(ChromeCompositorStateMachineV2.MinorStateV2Wire.COMMIT_COUNT_WIRE, self.commit_count);
            }
            if (self.current_frame_number != 0) {
                target.appendInt32(ChromeCompositorStateMachineV2.MinorStateV2Wire.CURRENT_FRAME_NUMBER_WIRE, self.current_frame_number);
            }
            if (self.last_frame_number_submit_performed != 0) {
                target.appendInt32(ChromeCompositorStateMachineV2.MinorStateV2Wire.LAST_FRAME_NUMBER_SUBMIT_PERFORMED_WIRE, self.last_frame_number_submit_performed);
            }
            if (self.last_frame_number_draw_performed != 0) {
                target.appendInt32(ChromeCompositorStateMachineV2.MinorStateV2Wire.LAST_FRAME_NUMBER_DRAW_PERFORMED_WIRE, self.last_frame_number_draw_performed);
            }
            if (self.last_frame_number_begin_main_frame_sent != 0) {
                target.appendInt32(ChromeCompositorStateMachineV2.MinorStateV2Wire.LAST_FRAME_NUMBER_BEGIN_MAIN_FRAME_SENT_WIRE, self.last_frame_number_begin_main_frame_sent);
            }
            if (self.did_draw != false) {
                target.appendBool(ChromeCompositorStateMachineV2.MinorStateV2Wire.DID_DRAW_WIRE, self.did_draw);
            }
            if (self.did_send_begin_main_frame_for_current_frame != false) {
                target.appendBool(ChromeCompositorStateMachineV2.MinorStateV2Wire.DID_SEND_BEGIN_MAIN_FRAME_FOR_CURRENT_FRAME_WIRE, self.did_send_begin_main_frame_for_current_frame);
            }
            if (self.did_notify_begin_main_frame_not_expected_until != false) {
                target.appendBool(ChromeCompositorStateMachineV2.MinorStateV2Wire.DID_NOTIFY_BEGIN_MAIN_FRAME_NOT_EXPECTED_UNTIL_WIRE, self.did_notify_begin_main_frame_not_expected_until);
            }
            if (self.did_notify_begin_main_frame_not_expected_soon != false) {
                target.appendBool(ChromeCompositorStateMachineV2.MinorStateV2Wire.DID_NOTIFY_BEGIN_MAIN_FRAME_NOT_EXPECTED_SOON_WIRE, self.did_notify_begin_main_frame_not_expected_soon);
            }
            if (self.wants_begin_main_frame_not_expected != false) {
                target.appendBool(ChromeCompositorStateMachineV2.MinorStateV2Wire.WANTS_BEGIN_MAIN_FRAME_NOT_EXPECTED_WIRE, self.wants_begin_main_frame_not_expected);
            }
            if (self.did_commit_during_frame != false) {
                target.appendBool(ChromeCompositorStateMachineV2.MinorStateV2Wire.DID_COMMIT_DURING_FRAME_WIRE, self.did_commit_during_frame);
            }
            if (self.did_invalidate_layer_tree_frame_sink != false) {
                target.appendBool(ChromeCompositorStateMachineV2.MinorStateV2Wire.DID_INVALIDATE_LAYER_TREE_FRAME_SINK_WIRE, self.did_invalidate_layer_tree_frame_sink);
            }
            if (self.did_perform_impl_side_invalidaion != false) {
                target.appendBool(ChromeCompositorStateMachineV2.MinorStateV2Wire.DID_PERFORM_IMPL_SIDE_INVALIDAION_WIRE, self.did_perform_impl_side_invalidaion);
            }
            if (self.did_prepare_tiles != false) {
                target.appendBool(ChromeCompositorStateMachineV2.MinorStateV2Wire.DID_PREPARE_TILES_WIRE, self.did_prepare_tiles);
            }
            if (self.consecutive_checkerboard_animations != 0) {
                target.appendInt32(ChromeCompositorStateMachineV2.MinorStateV2Wire.CONSECUTIVE_CHECKERBOARD_ANIMATIONS_WIRE, self.consecutive_checkerboard_animations);
            }
            if (self.pending_submit_frames != 0) {
                target.appendInt32(ChromeCompositorStateMachineV2.MinorStateV2Wire.PENDING_SUBMIT_FRAMES_WIRE, self.pending_submit_frames);
            }
            if (self.submit_frames_with_current_layer_tree_frame_sink != 0) {
                target.appendInt32(ChromeCompositorStateMachineV2.MinorStateV2Wire.SUBMIT_FRAMES_WITH_CURRENT_LAYER_TREE_FRAME_SINK_WIRE, self.submit_frames_with_current_layer_tree_frame_sink);
            }
            if (self.needs_redraw != false) {
                target.appendBool(ChromeCompositorStateMachineV2.MinorStateV2Wire.NEEDS_REDRAW_WIRE, self.needs_redraw);
            }
            if (self.needs_prepare_tiles != false) {
                target.appendBool(ChromeCompositorStateMachineV2.MinorStateV2Wire.NEEDS_PREPARE_TILES_WIRE, self.needs_prepare_tiles);
            }
            if (self.needs_begin_main_frame != false) {
                target.appendBool(ChromeCompositorStateMachineV2.MinorStateV2Wire.NEEDS_BEGIN_MAIN_FRAME_WIRE, self.needs_begin_main_frame);
            }
            if (self.needs_one_begin_impl_frame != false) {
                target.appendBool(ChromeCompositorStateMachineV2.MinorStateV2Wire.NEEDS_ONE_BEGIN_IMPL_FRAME_WIRE, self.needs_one_begin_impl_frame);
            }
            if (self.visible != false) {
                target.appendBool(ChromeCompositorStateMachineV2.MinorStateV2Wire.VISIBLE_WIRE, self.visible);
            }
            if (self.begin_frame_source_paused != false) {
                target.appendBool(ChromeCompositorStateMachineV2.MinorStateV2Wire.BEGIN_FRAME_SOURCE_PAUSED_WIRE, self.begin_frame_source_paused);
            }
            if (self.can_draw != false) {
                target.appendBool(ChromeCompositorStateMachineV2.MinorStateV2Wire.CAN_DRAW_WIRE, self.can_draw);
            }
            if (self.resourceless_draw != false) {
                target.appendBool(ChromeCompositorStateMachineV2.MinorStateV2Wire.RESOURCELESS_DRAW_WIRE, self.resourceless_draw);
            }
            if (self.has_pending_tree != false) {
                target.appendBool(ChromeCompositorStateMachineV2.MinorStateV2Wire.HAS_PENDING_TREE_WIRE, self.has_pending_tree);
            }
            if (self.pending_tree_is_ready_for_activation != false) {
                target.appendBool(ChromeCompositorStateMachineV2.MinorStateV2Wire.PENDING_TREE_IS_READY_FOR_ACTIVATION_WIRE, self.pending_tree_is_ready_for_activation);
            }
            if (self.active_tree_needs_first_draw != false) {
                target.appendBool(ChromeCompositorStateMachineV2.MinorStateV2Wire.ACTIVE_TREE_NEEDS_FIRST_DRAW_WIRE, self.active_tree_needs_first_draw);
            }
            if (self.active_tree_is_ready_to_draw != false) {
                target.appendBool(ChromeCompositorStateMachineV2.MinorStateV2Wire.ACTIVE_TREE_IS_READY_TO_DRAW_WIRE, self.active_tree_is_ready_to_draw);
            }
            if (self.did_create_and_initialize_first_layer_tree_frame_sink != false) {
                target.appendBool(ChromeCompositorStateMachineV2.MinorStateV2Wire.DID_CREATE_AND_INITIALIZE_FIRST_LAYER_TREE_FRAME_SINK_WIRE, self.did_create_and_initialize_first_layer_tree_frame_sink);
            }
            if (@intFromEnum(self.tree_priority) != 0) {
                target.appendInt32(ChromeCompositorStateMachineV2.MinorStateV2Wire.TREE_PRIORITY_WIRE, @intFromEnum(self.tree_priority));
            }
            if (@intFromEnum(self.scroll_handler_state) != 0) {
                target.appendInt32(ChromeCompositorStateMachineV2.MinorStateV2Wire.SCROLL_HANDLER_STATE_WIRE, @intFromEnum(self.scroll_handler_state));
            }
            if (self.critical_begin_main_frame_to_activate_is_fast != false) {
                target.appendBool(ChromeCompositorStateMachineV2.MinorStateV2Wire.CRITICAL_BEGIN_MAIN_FRAME_TO_ACTIVATE_IS_FAST_WIRE, self.critical_begin_main_frame_to_activate_is_fast);
            }
            if (self.main_thread_missed_last_deadline != false) {
                target.appendBool(ChromeCompositorStateMachineV2.MinorStateV2Wire.MAIN_THREAD_MISSED_LAST_DEADLINE_WIRE, self.main_thread_missed_last_deadline);
            }
            if (self.video_needs_begin_frames != false) {
                target.appendBool(ChromeCompositorStateMachineV2.MinorStateV2Wire.VIDEO_NEEDS_BEGIN_FRAMES_WIRE, self.video_needs_begin_frames);
            }
            if (self.defer_begin_main_frame != false) {
                target.appendBool(ChromeCompositorStateMachineV2.MinorStateV2Wire.DEFER_BEGIN_MAIN_FRAME_WIRE, self.defer_begin_main_frame);
            }
            if (self.last_commit_had_no_updates != false) {
                target.appendBool(ChromeCompositorStateMachineV2.MinorStateV2Wire.LAST_COMMIT_HAD_NO_UPDATES_WIRE, self.last_commit_had_no_updates);
            }
            if (self.did_draw_in_last_frame != false) {
                target.appendBool(ChromeCompositorStateMachineV2.MinorStateV2Wire.DID_DRAW_IN_LAST_FRAME_WIRE, self.did_draw_in_last_frame);
            }
            if (self.did_submit_in_last_frame != false) {
                target.appendBool(ChromeCompositorStateMachineV2.MinorStateV2Wire.DID_SUBMIT_IN_LAST_FRAME_WIRE, self.did_submit_in_last_frame);
            }
            if (self.needs_impl_side_invalidation != false) {
                target.appendBool(ChromeCompositorStateMachineV2.MinorStateV2Wire.NEEDS_IMPL_SIDE_INVALIDATION_WIRE, self.needs_impl_side_invalidation);
            }
            if (self.current_pending_tree_is_impl_side != false) {
                target.appendBool(ChromeCompositorStateMachineV2.MinorStateV2Wire.CURRENT_PENDING_TREE_IS_IMPL_SIDE_WIRE, self.current_pending_tree_is_impl_side);
            }
            if (self.previous_pending_tree_was_impl_side != false) {
                target.appendBool(ChromeCompositorStateMachineV2.MinorStateV2Wire.PREVIOUS_PENDING_TREE_WAS_IMPL_SIDE_WIRE, self.previous_pending_tree_was_impl_side);
            }
            if (self.processing_animation_worklets_for_active_tree != false) {
                target.appendBool(ChromeCompositorStateMachineV2.MinorStateV2Wire.PROCESSING_ANIMATION_WORKLETS_FOR_ACTIVE_TREE_WIRE, self.processing_animation_worklets_for_active_tree);
            }
            if (self.processing_animation_worklets_for_pending_tree != false) {
                target.appendBool(ChromeCompositorStateMachineV2.MinorStateV2Wire.PROCESSING_ANIMATION_WORKLETS_FOR_PENDING_TREE_WIRE, self.processing_animation_worklets_for_pending_tree);
            }
            if (self.processing_paint_worklets_for_pending_tree != false) {
                target.appendBool(ChromeCompositorStateMachineV2.MinorStateV2Wire.PROCESSING_PAINT_WORKLETS_FOR_PENDING_TREE_WIRE, self.processing_paint_worklets_for_pending_tree);
            }
            if (self.should_warm_up != false) {
                target.appendBool(ChromeCompositorStateMachineV2.MinorStateV2Wire.SHOULD_WARM_UP_WIRE, self.should_warm_up);
            }
        }
    };
    pub const MinorStateV2Reader = struct {
        buf: gremlin.Reader,
        _commit_count: i32 = 0,
        _current_frame_number: i32 = 0,
        _last_frame_number_submit_performed: i32 = 0,
        _last_frame_number_draw_performed: i32 = 0,
        _last_frame_number_begin_main_frame_sent: i32 = 0,
        _did_draw: bool = false,
        _did_send_begin_main_frame_for_current_frame: bool = false,
        _did_notify_begin_main_frame_not_expected_until: bool = false,
        _did_notify_begin_main_frame_not_expected_soon: bool = false,
        _wants_begin_main_frame_not_expected: bool = false,
        _did_commit_during_frame: bool = false,
        _did_invalidate_layer_tree_frame_sink: bool = false,
        _did_perform_impl_side_invalidaion: bool = false,
        _did_prepare_tiles: bool = false,
        _consecutive_checkerboard_animations: i32 = 0,
        _pending_submit_frames: i32 = 0,
        _submit_frames_with_current_layer_tree_frame_sink: i32 = 0,
        _needs_redraw: bool = false,
        _needs_prepare_tiles: bool = false,
        _needs_begin_main_frame: bool = false,
        _needs_one_begin_impl_frame: bool = false,
        _visible: bool = false,
        _begin_frame_source_paused: bool = false,
        _can_draw: bool = false,
        _resourceless_draw: bool = false,
        _has_pending_tree: bool = false,
        _pending_tree_is_ready_for_activation: bool = false,
        _active_tree_needs_first_draw: bool = false,
        _active_tree_is_ready_to_draw: bool = false,
        _did_create_and_initialize_first_layer_tree_frame_sink: bool = false,
        _tree_priority: ChromeCompositorStateMachineV2.MinorStateV2.TreePriority = @enumFromInt(0),
        _scroll_handler_state: ChromeCompositorStateMachineV2.MinorStateV2.ScrollHandlerState = @enumFromInt(0),
        _critical_begin_main_frame_to_activate_is_fast: bool = false,
        _main_thread_missed_last_deadline: bool = false,
        _video_needs_begin_frames: bool = false,
        _defer_begin_main_frame: bool = false,
        _last_commit_had_no_updates: bool = false,
        _did_draw_in_last_frame: bool = false,
        _did_submit_in_last_frame: bool = false,
        _needs_impl_side_invalidation: bool = false,
        _current_pending_tree_is_impl_side: bool = false,
        _previous_pending_tree_was_impl_side: bool = false,
        _processing_animation_worklets_for_active_tree: bool = false,
        _processing_animation_worklets_for_pending_tree: bool = false,
        _processing_paint_worklets_for_pending_tree: bool = false,
        _should_warm_up: bool = false,
        pub fn init(src: []const u8) gremlin.Error!ChromeCompositorStateMachineV2.MinorStateV2Reader {
            const buf = gremlin.Reader.init(src);
            var res = ChromeCompositorStateMachineV2.MinorStateV2Reader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.COMMIT_COUNT_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._commit_count = result.value;
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.CURRENT_FRAME_NUMBER_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._current_frame_number = result.value;
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.LAST_FRAME_NUMBER_SUBMIT_PERFORMED_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._last_frame_number_submit_performed = result.value;
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.LAST_FRAME_NUMBER_DRAW_PERFORMED_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._last_frame_number_draw_performed = result.value;
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.LAST_FRAME_NUMBER_BEGIN_MAIN_FRAME_SENT_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._last_frame_number_begin_main_frame_sent = result.value;
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.DID_DRAW_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._did_draw = result.value;
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.DID_SEND_BEGIN_MAIN_FRAME_FOR_CURRENT_FRAME_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._did_send_begin_main_frame_for_current_frame = result.value;
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.DID_NOTIFY_BEGIN_MAIN_FRAME_NOT_EXPECTED_UNTIL_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._did_notify_begin_main_frame_not_expected_until = result.value;
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.DID_NOTIFY_BEGIN_MAIN_FRAME_NOT_EXPECTED_SOON_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._did_notify_begin_main_frame_not_expected_soon = result.value;
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.WANTS_BEGIN_MAIN_FRAME_NOT_EXPECTED_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._wants_begin_main_frame_not_expected = result.value;
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.DID_COMMIT_DURING_FRAME_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._did_commit_during_frame = result.value;
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.DID_INVALIDATE_LAYER_TREE_FRAME_SINK_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._did_invalidate_layer_tree_frame_sink = result.value;
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.DID_PERFORM_IMPL_SIDE_INVALIDAION_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._did_perform_impl_side_invalidaion = result.value;
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.DID_PREPARE_TILES_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._did_prepare_tiles = result.value;
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.CONSECUTIVE_CHECKERBOARD_ANIMATIONS_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._consecutive_checkerboard_animations = result.value;
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.PENDING_SUBMIT_FRAMES_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._pending_submit_frames = result.value;
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.SUBMIT_FRAMES_WITH_CURRENT_LAYER_TREE_FRAME_SINK_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._submit_frames_with_current_layer_tree_frame_sink = result.value;
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.NEEDS_REDRAW_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._needs_redraw = result.value;
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.NEEDS_PREPARE_TILES_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._needs_prepare_tiles = result.value;
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.NEEDS_BEGIN_MAIN_FRAME_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._needs_begin_main_frame = result.value;
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.NEEDS_ONE_BEGIN_IMPL_FRAME_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._needs_one_begin_impl_frame = result.value;
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.VISIBLE_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._visible = result.value;
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.BEGIN_FRAME_SOURCE_PAUSED_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._begin_frame_source_paused = result.value;
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.CAN_DRAW_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._can_draw = result.value;
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.RESOURCELESS_DRAW_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._resourceless_draw = result.value;
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.HAS_PENDING_TREE_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._has_pending_tree = result.value;
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.PENDING_TREE_IS_READY_FOR_ACTIVATION_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._pending_tree_is_ready_for_activation = result.value;
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.ACTIVE_TREE_NEEDS_FIRST_DRAW_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._active_tree_needs_first_draw = result.value;
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.ACTIVE_TREE_IS_READY_TO_DRAW_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._active_tree_is_ready_to_draw = result.value;
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.DID_CREATE_AND_INITIALIZE_FIRST_LAYER_TREE_FRAME_SINK_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._did_create_and_initialize_first_layer_tree_frame_sink = result.value;
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.TREE_PRIORITY_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._tree_priority = @enumFromInt(result.value);
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.SCROLL_HANDLER_STATE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._scroll_handler_state = @enumFromInt(result.value);
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.CRITICAL_BEGIN_MAIN_FRAME_TO_ACTIVATE_IS_FAST_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._critical_begin_main_frame_to_activate_is_fast = result.value;
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.MAIN_THREAD_MISSED_LAST_DEADLINE_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._main_thread_missed_last_deadline = result.value;
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.VIDEO_NEEDS_BEGIN_FRAMES_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._video_needs_begin_frames = result.value;
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.DEFER_BEGIN_MAIN_FRAME_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._defer_begin_main_frame = result.value;
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.LAST_COMMIT_HAD_NO_UPDATES_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._last_commit_had_no_updates = result.value;
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.DID_DRAW_IN_LAST_FRAME_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._did_draw_in_last_frame = result.value;
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.DID_SUBMIT_IN_LAST_FRAME_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._did_submit_in_last_frame = result.value;
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.NEEDS_IMPL_SIDE_INVALIDATION_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._needs_impl_side_invalidation = result.value;
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.CURRENT_PENDING_TREE_IS_IMPL_SIDE_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._current_pending_tree_is_impl_side = result.value;
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.PREVIOUS_PENDING_TREE_WAS_IMPL_SIDE_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._previous_pending_tree_was_impl_side = result.value;
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.PROCESSING_ANIMATION_WORKLETS_FOR_ACTIVE_TREE_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._processing_animation_worklets_for_active_tree = result.value;
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.PROCESSING_ANIMATION_WORKLETS_FOR_PENDING_TREE_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._processing_animation_worklets_for_pending_tree = result.value;
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.PROCESSING_PAINT_WORKLETS_FOR_PENDING_TREE_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._processing_paint_worklets_for_pending_tree = result.value;
                    },
                    ChromeCompositorStateMachineV2.MinorStateV2Wire.SHOULD_WARM_UP_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._should_warm_up = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getCommitCount(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) i32 {
            return self._commit_count;
        }
        pub inline fn getCurrentFrameNumber(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) i32 {
            return self._current_frame_number;
        }
        pub inline fn getLastFrameNumberSubmitPerformed(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) i32 {
            return self._last_frame_number_submit_performed;
        }
        pub inline fn getLastFrameNumberDrawPerformed(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) i32 {
            return self._last_frame_number_draw_performed;
        }
        pub inline fn getLastFrameNumberBeginMainFrameSent(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) i32 {
            return self._last_frame_number_begin_main_frame_sent;
        }
        pub inline fn getDidDraw(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) bool {
            return self._did_draw;
        }
        pub inline fn getDidSendBeginMainFrameForCurrentFrame(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) bool {
            return self._did_send_begin_main_frame_for_current_frame;
        }
        pub inline fn getDidNotifyBeginMainFrameNotExpectedUntil(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) bool {
            return self._did_notify_begin_main_frame_not_expected_until;
        }
        pub inline fn getDidNotifyBeginMainFrameNotExpectedSoon(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) bool {
            return self._did_notify_begin_main_frame_not_expected_soon;
        }
        pub inline fn getWantsBeginMainFrameNotExpected(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) bool {
            return self._wants_begin_main_frame_not_expected;
        }
        pub inline fn getDidCommitDuringFrame(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) bool {
            return self._did_commit_during_frame;
        }
        pub inline fn getDidInvalidateLayerTreeFrameSink(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) bool {
            return self._did_invalidate_layer_tree_frame_sink;
        }
        pub inline fn getDidPerformImplSideInvalidaion(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) bool {
            return self._did_perform_impl_side_invalidaion;
        }
        pub inline fn getDidPrepareTiles(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) bool {
            return self._did_prepare_tiles;
        }
        pub inline fn getConsecutiveCheckerboardAnimations(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) i32 {
            return self._consecutive_checkerboard_animations;
        }
        pub inline fn getPendingSubmitFrames(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) i32 {
            return self._pending_submit_frames;
        }
        pub inline fn getSubmitFramesWithCurrentLayerTreeFrameSink(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) i32 {
            return self._submit_frames_with_current_layer_tree_frame_sink;
        }
        pub inline fn getNeedsRedraw(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) bool {
            return self._needs_redraw;
        }
        pub inline fn getNeedsPrepareTiles(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) bool {
            return self._needs_prepare_tiles;
        }
        pub inline fn getNeedsBeginMainFrame(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) bool {
            return self._needs_begin_main_frame;
        }
        pub inline fn getNeedsOneBeginImplFrame(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) bool {
            return self._needs_one_begin_impl_frame;
        }
        pub inline fn getVisible(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) bool {
            return self._visible;
        }
        pub inline fn getBeginFrameSourcePaused(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) bool {
            return self._begin_frame_source_paused;
        }
        pub inline fn getCanDraw(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) bool {
            return self._can_draw;
        }
        pub inline fn getResourcelessDraw(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) bool {
            return self._resourceless_draw;
        }
        pub inline fn getHasPendingTree(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) bool {
            return self._has_pending_tree;
        }
        pub inline fn getPendingTreeIsReadyForActivation(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) bool {
            return self._pending_tree_is_ready_for_activation;
        }
        pub inline fn getActiveTreeNeedsFirstDraw(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) bool {
            return self._active_tree_needs_first_draw;
        }
        pub inline fn getActiveTreeIsReadyToDraw(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) bool {
            return self._active_tree_is_ready_to_draw;
        }
        pub inline fn getDidCreateAndInitializeFirstLayerTreeFrameSink(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) bool {
            return self._did_create_and_initialize_first_layer_tree_frame_sink;
        }
        pub inline fn getTreePriority(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) ChromeCompositorStateMachineV2.MinorStateV2.TreePriority {
            return self._tree_priority;
        }
        pub inline fn getScrollHandlerState(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) ChromeCompositorStateMachineV2.MinorStateV2.ScrollHandlerState {
            return self._scroll_handler_state;
        }
        pub inline fn getCriticalBeginMainFrameToActivateIsFast(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) bool {
            return self._critical_begin_main_frame_to_activate_is_fast;
        }
        pub inline fn getMainThreadMissedLastDeadline(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) bool {
            return self._main_thread_missed_last_deadline;
        }
        pub inline fn getVideoNeedsBeginFrames(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) bool {
            return self._video_needs_begin_frames;
        }
        pub inline fn getDeferBeginMainFrame(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) bool {
            return self._defer_begin_main_frame;
        }
        pub inline fn getLastCommitHadNoUpdates(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) bool {
            return self._last_commit_had_no_updates;
        }
        pub inline fn getDidDrawInLastFrame(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) bool {
            return self._did_draw_in_last_frame;
        }
        pub inline fn getDidSubmitInLastFrame(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) bool {
            return self._did_submit_in_last_frame;
        }
        pub inline fn getNeedsImplSideInvalidation(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) bool {
            return self._needs_impl_side_invalidation;
        }
        pub inline fn getCurrentPendingTreeIsImplSide(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) bool {
            return self._current_pending_tree_is_impl_side;
        }
        pub inline fn getPreviousPendingTreeWasImplSide(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) bool {
            return self._previous_pending_tree_was_impl_side;
        }
        pub inline fn getProcessingAnimationWorkletsForActiveTree(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) bool {
            return self._processing_animation_worklets_for_active_tree;
        }
        pub inline fn getProcessingAnimationWorkletsForPendingTree(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) bool {
            return self._processing_animation_worklets_for_pending_tree;
        }
        pub inline fn getProcessingPaintWorkletsForPendingTree(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) bool {
            return self._processing_paint_worklets_for_pending_tree;
        }
        pub inline fn getShouldWarmUp(self: *const ChromeCompositorStateMachineV2.MinorStateV2Reader) bool {
            return self._should_warm_up;
        }
    };
    // fields
    major_state: ?ChromeCompositorStateMachineV2.MajorStateV2 = null,
    minor_state: ?ChromeCompositorStateMachineV2.MinorStateV2 = null,
    pub fn calcProtobufSize(self: *const ChromeCompositorStateMachineV2) usize {
        var res: usize = 0;
        if (self.major_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2Wire.MAJOR_STATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.minor_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineV2Wire.MINOR_STATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const ChromeCompositorStateMachineV2, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ChromeCompositorStateMachineV2, target: *gremlin.Writer) void {
        if (self.major_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeCompositorStateMachineV2Wire.MAJOR_STATE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.minor_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeCompositorStateMachineV2Wire.MINOR_STATE_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const ChromeCompositorStateMachineV2Reader = struct {
    buf: gremlin.Reader,
    _major_state_buf: ?[]const u8 = null,
    _minor_state_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!ChromeCompositorStateMachineV2Reader {
        const buf = gremlin.Reader.init(src);
        var res = ChromeCompositorStateMachineV2Reader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ChromeCompositorStateMachineV2Wire.MAJOR_STATE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._major_state_buf = result.value;
                },
                ChromeCompositorStateMachineV2Wire.MINOR_STATE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._minor_state_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getMajorState(self: *const ChromeCompositorStateMachineV2Reader) gremlin.Error!ChromeCompositorStateMachineV2.MajorStateV2Reader {
        if (self._major_state_buf) |buf| {
            return try ChromeCompositorStateMachineV2.MajorStateV2Reader.init(buf);
        }
        return try ChromeCompositorStateMachineV2.MajorStateV2Reader.init(&[_]u8{});
    }
    pub fn getMinorState(self: *const ChromeCompositorStateMachineV2Reader) gremlin.Error!ChromeCompositorStateMachineV2.MinorStateV2Reader {
        if (self._minor_state_buf) |buf| {
            return try ChromeCompositorStateMachineV2.MinorStateV2Reader.init(buf);
        }
        return try ChromeCompositorStateMachineV2.MinorStateV2Reader.init(&[_]u8{});
    }
};
const BeginFrameArgsV2Wire = struct {
    const TYPE_WIRE: gremlin.ProtoWireNumber = 1;
    const SOURCE_ID_WIRE: gremlin.ProtoWireNumber = 2;
    const SEQUENCE_NUMBER_WIRE: gremlin.ProtoWireNumber = 3;
    const FRAME_TIME_US_WIRE: gremlin.ProtoWireNumber = 4;
    const DEADLINE_US_WIRE: gremlin.ProtoWireNumber = 5;
    const INTERVAL_DELTA_US_WIRE: gremlin.ProtoWireNumber = 6;
    const ON_CRITICAL_PATH_WIRE: gremlin.ProtoWireNumber = 7;
    const ANIMATE_ONLY_WIRE: gremlin.ProtoWireNumber = 8;
    const FRAMES_THROTTLED_SINCE_LAST_WIRE: gremlin.ProtoWireNumber = 11;
    const SOURCE_LOCATION_IID_WIRE: gremlin.ProtoWireNumber = 9;
    const SOURCE_LOCATION_WIRE: gremlin.ProtoWireNumber = 10;
};
pub const BeginFrameArgsV2 = struct {
    // nested enums
    pub const BeginFrameArgsType = enum(i32) {
        BEGIN_FRAME_ARGS_TYPE_UNSPECIFIED = 0,
        BEGIN_FRAME_ARGS_TYPE_INVALID = 1,
        BEGIN_FRAME_ARGS_TYPE_NORMAL = 2,
        BEGIN_FRAME_ARGS_TYPE_MISSED = 3,
    };
    // fields
    type: BeginFrameArgsV2.BeginFrameArgsType = @enumFromInt(0),
    source_id: u64 = 0,
    sequence_number: u64 = 0,
    frame_time_us: i64 = 0,
    deadline_us: i64 = 0,
    interval_delta_us: i64 = 0,
    on_critical_path: bool = false,
    animate_only: bool = false,
    frames_throttled_since_last: i64 = 0,
    source_location_iid: u64 = 0,
    source_location: ?source_location.SourceLocation = null,
    pub fn calcProtobufSize(self: *const BeginFrameArgsV2) usize {
        var res: usize = 0;
        if (@intFromEnum(self.type) != 0) {
            res += gremlin.sizes.sizeWireNumber(BeginFrameArgsV2Wire.TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.type));
        }
        if (self.source_id != 0) {
            res += gremlin.sizes.sizeWireNumber(BeginFrameArgsV2Wire.SOURCE_ID_WIRE) + gremlin.sizes.sizeU64(self.source_id);
        }
        if (self.sequence_number != 0) {
            res += gremlin.sizes.sizeWireNumber(BeginFrameArgsV2Wire.SEQUENCE_NUMBER_WIRE) + gremlin.sizes.sizeU64(self.sequence_number);
        }
        if (self.frame_time_us != 0) {
            res += gremlin.sizes.sizeWireNumber(BeginFrameArgsV2Wire.FRAME_TIME_US_WIRE) + gremlin.sizes.sizeI64(self.frame_time_us);
        }
        if (self.deadline_us != 0) {
            res += gremlin.sizes.sizeWireNumber(BeginFrameArgsV2Wire.DEADLINE_US_WIRE) + gremlin.sizes.sizeI64(self.deadline_us);
        }
        if (self.interval_delta_us != 0) {
            res += gremlin.sizes.sizeWireNumber(BeginFrameArgsV2Wire.INTERVAL_DELTA_US_WIRE) + gremlin.sizes.sizeI64(self.interval_delta_us);
        }
        if (self.on_critical_path != false) {
            res += gremlin.sizes.sizeWireNumber(BeginFrameArgsV2Wire.ON_CRITICAL_PATH_WIRE) + gremlin.sizes.sizeBool(self.on_critical_path);
        }
        if (self.animate_only != false) {
            res += gremlin.sizes.sizeWireNumber(BeginFrameArgsV2Wire.ANIMATE_ONLY_WIRE) + gremlin.sizes.sizeBool(self.animate_only);
        }
        if (self.frames_throttled_since_last != 0) {
            res += gremlin.sizes.sizeWireNumber(BeginFrameArgsV2Wire.FRAMES_THROTTLED_SINCE_LAST_WIRE) + gremlin.sizes.sizeI64(self.frames_throttled_since_last);
        }
        if (self.source_location_iid != 0) {
            res += gremlin.sizes.sizeWireNumber(BeginFrameArgsV2Wire.SOURCE_LOCATION_IID_WIRE) + gremlin.sizes.sizeU64(self.source_location_iid);
        }
        if (self.source_location) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(BeginFrameArgsV2Wire.SOURCE_LOCATION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const BeginFrameArgsV2, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const BeginFrameArgsV2, target: *gremlin.Writer) void {
        if (@intFromEnum(self.type) != 0) {
            target.appendInt32(BeginFrameArgsV2Wire.TYPE_WIRE, @intFromEnum(self.type));
        }
        if (self.source_id != 0) {
            target.appendUint64(BeginFrameArgsV2Wire.SOURCE_ID_WIRE, self.source_id);
        }
        if (self.sequence_number != 0) {
            target.appendUint64(BeginFrameArgsV2Wire.SEQUENCE_NUMBER_WIRE, self.sequence_number);
        }
        if (self.frame_time_us != 0) {
            target.appendInt64(BeginFrameArgsV2Wire.FRAME_TIME_US_WIRE, self.frame_time_us);
        }
        if (self.deadline_us != 0) {
            target.appendInt64(BeginFrameArgsV2Wire.DEADLINE_US_WIRE, self.deadline_us);
        }
        if (self.interval_delta_us != 0) {
            target.appendInt64(BeginFrameArgsV2Wire.INTERVAL_DELTA_US_WIRE, self.interval_delta_us);
        }
        if (self.on_critical_path != false) {
            target.appendBool(BeginFrameArgsV2Wire.ON_CRITICAL_PATH_WIRE, self.on_critical_path);
        }
        if (self.animate_only != false) {
            target.appendBool(BeginFrameArgsV2Wire.ANIMATE_ONLY_WIRE, self.animate_only);
        }
        if (self.frames_throttled_since_last != 0) {
            target.appendInt64(BeginFrameArgsV2Wire.FRAMES_THROTTLED_SINCE_LAST_WIRE, self.frames_throttled_since_last);
        }
        if (self.source_location_iid != 0) {
            target.appendUint64(BeginFrameArgsV2Wire.SOURCE_LOCATION_IID_WIRE, self.source_location_iid);
        }
        if (self.source_location) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(BeginFrameArgsV2Wire.SOURCE_LOCATION_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const BeginFrameArgsV2Reader = struct {
    buf: gremlin.Reader,
    _type: BeginFrameArgsV2.BeginFrameArgsType = @enumFromInt(0),
    _source_id: u64 = 0,
    _sequence_number: u64 = 0,
    _frame_time_us: i64 = 0,
    _deadline_us: i64 = 0,
    _interval_delta_us: i64 = 0,
    _on_critical_path: bool = false,
    _animate_only: bool = false,
    _frames_throttled_since_last: i64 = 0,
    _source_location_iid: u64 = 0,
    _source_location_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!BeginFrameArgsV2Reader {
        const buf = gremlin.Reader.init(src);
        var res = BeginFrameArgsV2Reader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                BeginFrameArgsV2Wire.TYPE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._type = @enumFromInt(result.value);
                },
                BeginFrameArgsV2Wire.SOURCE_ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._source_id = result.value;
                },
                BeginFrameArgsV2Wire.SEQUENCE_NUMBER_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._sequence_number = result.value;
                },
                BeginFrameArgsV2Wire.FRAME_TIME_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._frame_time_us = result.value;
                },
                BeginFrameArgsV2Wire.DEADLINE_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._deadline_us = result.value;
                },
                BeginFrameArgsV2Wire.INTERVAL_DELTA_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._interval_delta_us = result.value;
                },
                BeginFrameArgsV2Wire.ON_CRITICAL_PATH_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._on_critical_path = result.value;
                },
                BeginFrameArgsV2Wire.ANIMATE_ONLY_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._animate_only = result.value;
                },
                BeginFrameArgsV2Wire.FRAMES_THROTTLED_SINCE_LAST_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._frames_throttled_since_last = result.value;
                },
                BeginFrameArgsV2Wire.SOURCE_LOCATION_IID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._source_location_iid = result.value;
                },
                BeginFrameArgsV2Wire.SOURCE_LOCATION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._source_location_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getType(self: *const BeginFrameArgsV2Reader) BeginFrameArgsV2.BeginFrameArgsType {
        return self._type;
    }
    pub inline fn getSourceId(self: *const BeginFrameArgsV2Reader) u64 {
        return self._source_id;
    }
    pub inline fn getSequenceNumber(self: *const BeginFrameArgsV2Reader) u64 {
        return self._sequence_number;
    }
    pub inline fn getFrameTimeUs(self: *const BeginFrameArgsV2Reader) i64 {
        return self._frame_time_us;
    }
    pub inline fn getDeadlineUs(self: *const BeginFrameArgsV2Reader) i64 {
        return self._deadline_us;
    }
    pub inline fn getIntervalDeltaUs(self: *const BeginFrameArgsV2Reader) i64 {
        return self._interval_delta_us;
    }
    pub inline fn getOnCriticalPath(self: *const BeginFrameArgsV2Reader) bool {
        return self._on_critical_path;
    }
    pub inline fn getAnimateOnly(self: *const BeginFrameArgsV2Reader) bool {
        return self._animate_only;
    }
    pub inline fn getFramesThrottledSinceLast(self: *const BeginFrameArgsV2Reader) i64 {
        return self._frames_throttled_since_last;
    }
    pub inline fn getSourceLocationIid(self: *const BeginFrameArgsV2Reader) u64 {
        return self._source_location_iid;
    }
    pub fn getSourceLocation(self: *const BeginFrameArgsV2Reader) gremlin.Error!source_location.SourceLocationReader {
        if (self._source_location_buf) |buf| {
            return try source_location.SourceLocationReader.init(buf);
        }
        return try source_location.SourceLocationReader.init(&[_]u8{});
    }
};
const BeginImplFrameArgsV2Wire = struct {
    const UPDATED_AT_US_WIRE: gremlin.ProtoWireNumber = 1;
    const FINISHED_AT_US_WIRE: gremlin.ProtoWireNumber = 2;
    const STATE_WIRE: gremlin.ProtoWireNumber = 3;
    const TIMESTAMPS_IN_US_WIRE: gremlin.ProtoWireNumber = 6;
    const CURRENT_ARGS_WIRE: gremlin.ProtoWireNumber = 4;
    const LAST_ARGS_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const BeginImplFrameArgsV2 = struct {
    // nested enums
    pub const State = enum(i32) {
        BEGIN_FRAME_FINISHED = 0,
        BEGIN_FRAME_USING = 1,
    };
    // nested structs
    const TimestampsInUsWire = struct {
        const INTERVAL_DELTA_WIRE: gremlin.ProtoWireNumber = 1;
        const NOW_TO_DEADLINE_DELTA_WIRE: gremlin.ProtoWireNumber = 2;
        const FRAME_TIME_TO_NOW_DELTA_WIRE: gremlin.ProtoWireNumber = 3;
        const FRAME_TIME_TO_DEADLINE_DELTA_WIRE: gremlin.ProtoWireNumber = 4;
        const NOW_WIRE: gremlin.ProtoWireNumber = 5;
        const FRAME_TIME_WIRE: gremlin.ProtoWireNumber = 6;
        const DEADLINE_WIRE: gremlin.ProtoWireNumber = 7;
    };
    pub const TimestampsInUs = struct {
        // fields
        interval_delta: i64 = 0,
        now_to_deadline_delta: i64 = 0,
        frame_time_to_now_delta: i64 = 0,
        frame_time_to_deadline_delta: i64 = 0,
        now: i64 = 0,
        frame_time: i64 = 0,
        deadline: i64 = 0,
        pub fn calcProtobufSize(self: *const BeginImplFrameArgsV2.TimestampsInUs) usize {
            var res: usize = 0;
            if (self.interval_delta != 0) {
                res += gremlin.sizes.sizeWireNumber(BeginImplFrameArgsV2.TimestampsInUsWire.INTERVAL_DELTA_WIRE) + gremlin.sizes.sizeI64(self.interval_delta);
            }
            if (self.now_to_deadline_delta != 0) {
                res += gremlin.sizes.sizeWireNumber(BeginImplFrameArgsV2.TimestampsInUsWire.NOW_TO_DEADLINE_DELTA_WIRE) + gremlin.sizes.sizeI64(self.now_to_deadline_delta);
            }
            if (self.frame_time_to_now_delta != 0) {
                res += gremlin.sizes.sizeWireNumber(BeginImplFrameArgsV2.TimestampsInUsWire.FRAME_TIME_TO_NOW_DELTA_WIRE) + gremlin.sizes.sizeI64(self.frame_time_to_now_delta);
            }
            if (self.frame_time_to_deadline_delta != 0) {
                res += gremlin.sizes.sizeWireNumber(BeginImplFrameArgsV2.TimestampsInUsWire.FRAME_TIME_TO_DEADLINE_DELTA_WIRE) + gremlin.sizes.sizeI64(self.frame_time_to_deadline_delta);
            }
            if (self.now != 0) {
                res += gremlin.sizes.sizeWireNumber(BeginImplFrameArgsV2.TimestampsInUsWire.NOW_WIRE) + gremlin.sizes.sizeI64(self.now);
            }
            if (self.frame_time != 0) {
                res += gremlin.sizes.sizeWireNumber(BeginImplFrameArgsV2.TimestampsInUsWire.FRAME_TIME_WIRE) + gremlin.sizes.sizeI64(self.frame_time);
            }
            if (self.deadline != 0) {
                res += gremlin.sizes.sizeWireNumber(BeginImplFrameArgsV2.TimestampsInUsWire.DEADLINE_WIRE) + gremlin.sizes.sizeI64(self.deadline);
            }
            return res;
        }
        pub fn encode(self: *const BeginImplFrameArgsV2.TimestampsInUs, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const BeginImplFrameArgsV2.TimestampsInUs, target: *gremlin.Writer) void {
            if (self.interval_delta != 0) {
                target.appendInt64(BeginImplFrameArgsV2.TimestampsInUsWire.INTERVAL_DELTA_WIRE, self.interval_delta);
            }
            if (self.now_to_deadline_delta != 0) {
                target.appendInt64(BeginImplFrameArgsV2.TimestampsInUsWire.NOW_TO_DEADLINE_DELTA_WIRE, self.now_to_deadline_delta);
            }
            if (self.frame_time_to_now_delta != 0) {
                target.appendInt64(BeginImplFrameArgsV2.TimestampsInUsWire.FRAME_TIME_TO_NOW_DELTA_WIRE, self.frame_time_to_now_delta);
            }
            if (self.frame_time_to_deadline_delta != 0) {
                target.appendInt64(BeginImplFrameArgsV2.TimestampsInUsWire.FRAME_TIME_TO_DEADLINE_DELTA_WIRE, self.frame_time_to_deadline_delta);
            }
            if (self.now != 0) {
                target.appendInt64(BeginImplFrameArgsV2.TimestampsInUsWire.NOW_WIRE, self.now);
            }
            if (self.frame_time != 0) {
                target.appendInt64(BeginImplFrameArgsV2.TimestampsInUsWire.FRAME_TIME_WIRE, self.frame_time);
            }
            if (self.deadline != 0) {
                target.appendInt64(BeginImplFrameArgsV2.TimestampsInUsWire.DEADLINE_WIRE, self.deadline);
            }
        }
    };
    pub const TimestampsInUsReader = struct {
        buf: gremlin.Reader,
        _interval_delta: i64 = 0,
        _now_to_deadline_delta: i64 = 0,
        _frame_time_to_now_delta: i64 = 0,
        _frame_time_to_deadline_delta: i64 = 0,
        _now: i64 = 0,
        _frame_time: i64 = 0,
        _deadline: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!BeginImplFrameArgsV2.TimestampsInUsReader {
            const buf = gremlin.Reader.init(src);
            var res = BeginImplFrameArgsV2.TimestampsInUsReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    BeginImplFrameArgsV2.TimestampsInUsWire.INTERVAL_DELTA_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._interval_delta = result.value;
                    },
                    BeginImplFrameArgsV2.TimestampsInUsWire.NOW_TO_DEADLINE_DELTA_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._now_to_deadline_delta = result.value;
                    },
                    BeginImplFrameArgsV2.TimestampsInUsWire.FRAME_TIME_TO_NOW_DELTA_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._frame_time_to_now_delta = result.value;
                    },
                    BeginImplFrameArgsV2.TimestampsInUsWire.FRAME_TIME_TO_DEADLINE_DELTA_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._frame_time_to_deadline_delta = result.value;
                    },
                    BeginImplFrameArgsV2.TimestampsInUsWire.NOW_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._now = result.value;
                    },
                    BeginImplFrameArgsV2.TimestampsInUsWire.FRAME_TIME_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._frame_time = result.value;
                    },
                    BeginImplFrameArgsV2.TimestampsInUsWire.DEADLINE_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._deadline = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getIntervalDelta(self: *const BeginImplFrameArgsV2.TimestampsInUsReader) i64 {
            return self._interval_delta;
        }
        pub inline fn getNowToDeadlineDelta(self: *const BeginImplFrameArgsV2.TimestampsInUsReader) i64 {
            return self._now_to_deadline_delta;
        }
        pub inline fn getFrameTimeToNowDelta(self: *const BeginImplFrameArgsV2.TimestampsInUsReader) i64 {
            return self._frame_time_to_now_delta;
        }
        pub inline fn getFrameTimeToDeadlineDelta(self: *const BeginImplFrameArgsV2.TimestampsInUsReader) i64 {
            return self._frame_time_to_deadline_delta;
        }
        pub inline fn getNow(self: *const BeginImplFrameArgsV2.TimestampsInUsReader) i64 {
            return self._now;
        }
        pub inline fn getFrameTime(self: *const BeginImplFrameArgsV2.TimestampsInUsReader) i64 {
            return self._frame_time;
        }
        pub inline fn getDeadline(self: *const BeginImplFrameArgsV2.TimestampsInUsReader) i64 {
            return self._deadline;
        }
    };
    // fields
    updated_at_us: i64 = 0,
    finished_at_us: i64 = 0,
    state: BeginImplFrameArgsV2.State = @enumFromInt(0),
    timestamps_in_us: ?BeginImplFrameArgsV2.TimestampsInUs = null,
    current_args: ?BeginFrameArgsV2 = null,
    last_args: ?BeginFrameArgsV2 = null,
    pub fn calcProtobufSize(self: *const BeginImplFrameArgsV2) usize {
        var res: usize = 0;
        if (self.updated_at_us != 0) {
            res += gremlin.sizes.sizeWireNumber(BeginImplFrameArgsV2Wire.UPDATED_AT_US_WIRE) + gremlin.sizes.sizeI64(self.updated_at_us);
        }
        if (self.finished_at_us != 0) {
            res += gremlin.sizes.sizeWireNumber(BeginImplFrameArgsV2Wire.FINISHED_AT_US_WIRE) + gremlin.sizes.sizeI64(self.finished_at_us);
        }
        if (@intFromEnum(self.state) != 0) {
            res += gremlin.sizes.sizeWireNumber(BeginImplFrameArgsV2Wire.STATE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.state));
        }
        if (self.timestamps_in_us) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(BeginImplFrameArgsV2Wire.TIMESTAMPS_IN_US_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.current_args) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(BeginImplFrameArgsV2Wire.CURRENT_ARGS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.last_args) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(BeginImplFrameArgsV2Wire.LAST_ARGS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const BeginImplFrameArgsV2, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const BeginImplFrameArgsV2, target: *gremlin.Writer) void {
        if (self.updated_at_us != 0) {
            target.appendInt64(BeginImplFrameArgsV2Wire.UPDATED_AT_US_WIRE, self.updated_at_us);
        }
        if (self.finished_at_us != 0) {
            target.appendInt64(BeginImplFrameArgsV2Wire.FINISHED_AT_US_WIRE, self.finished_at_us);
        }
        if (@intFromEnum(self.state) != 0) {
            target.appendInt32(BeginImplFrameArgsV2Wire.STATE_WIRE, @intFromEnum(self.state));
        }
        if (self.timestamps_in_us) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(BeginImplFrameArgsV2Wire.TIMESTAMPS_IN_US_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.current_args) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(BeginImplFrameArgsV2Wire.CURRENT_ARGS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.last_args) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(BeginImplFrameArgsV2Wire.LAST_ARGS_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const BeginImplFrameArgsV2Reader = struct {
    buf: gremlin.Reader,
    _updated_at_us: i64 = 0,
    _finished_at_us: i64 = 0,
    _state: BeginImplFrameArgsV2.State = @enumFromInt(0),
    _timestamps_in_us_buf: ?[]const u8 = null,
    _current_args_buf: ?[]const u8 = null,
    _last_args_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!BeginImplFrameArgsV2Reader {
        const buf = gremlin.Reader.init(src);
        var res = BeginImplFrameArgsV2Reader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                BeginImplFrameArgsV2Wire.UPDATED_AT_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._updated_at_us = result.value;
                },
                BeginImplFrameArgsV2Wire.FINISHED_AT_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._finished_at_us = result.value;
                },
                BeginImplFrameArgsV2Wire.STATE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._state = @enumFromInt(result.value);
                },
                BeginImplFrameArgsV2Wire.TIMESTAMPS_IN_US_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._timestamps_in_us_buf = result.value;
                },
                BeginImplFrameArgsV2Wire.CURRENT_ARGS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._current_args_buf = result.value;
                },
                BeginImplFrameArgsV2Wire.LAST_ARGS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._last_args_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getUpdatedAtUs(self: *const BeginImplFrameArgsV2Reader) i64 {
        return self._updated_at_us;
    }
    pub inline fn getFinishedAtUs(self: *const BeginImplFrameArgsV2Reader) i64 {
        return self._finished_at_us;
    }
    pub inline fn getState(self: *const BeginImplFrameArgsV2Reader) BeginImplFrameArgsV2.State {
        return self._state;
    }
    pub fn getTimestampsInUs(self: *const BeginImplFrameArgsV2Reader) gremlin.Error!BeginImplFrameArgsV2.TimestampsInUsReader {
        if (self._timestamps_in_us_buf) |buf| {
            return try BeginImplFrameArgsV2.TimestampsInUsReader.init(buf);
        }
        return try BeginImplFrameArgsV2.TimestampsInUsReader.init(&[_]u8{});
    }
    pub fn getCurrentArgs(self: *const BeginImplFrameArgsV2Reader) gremlin.Error!BeginFrameArgsV2Reader {
        if (self._current_args_buf) |buf| {
            return try BeginFrameArgsV2Reader.init(buf);
        }
        return try BeginFrameArgsV2Reader.init(&[_]u8{});
    }
    pub fn getLastArgs(self: *const BeginImplFrameArgsV2Reader) gremlin.Error!BeginFrameArgsV2Reader {
        if (self._last_args_buf) |buf| {
            return try BeginFrameArgsV2Reader.init(buf);
        }
        return try BeginFrameArgsV2Reader.init(&[_]u8{});
    }
};
const BeginFrameObserverStateV2Wire = struct {
    const DROPPED_BEGIN_FRAME_ARGS_WIRE: gremlin.ProtoWireNumber = 1;
    const LAST_BEGIN_FRAME_ARGS_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const BeginFrameObserverStateV2 = struct {
    // fields
    dropped_begin_frame_args: i64 = 0,
    last_begin_frame_args: ?BeginFrameArgsV2 = null,
    pub fn calcProtobufSize(self: *const BeginFrameObserverStateV2) usize {
        var res: usize = 0;
        if (self.dropped_begin_frame_args != 0) {
            res += gremlin.sizes.sizeWireNumber(BeginFrameObserverStateV2Wire.DROPPED_BEGIN_FRAME_ARGS_WIRE) + gremlin.sizes.sizeI64(self.dropped_begin_frame_args);
        }
        if (self.last_begin_frame_args) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(BeginFrameObserverStateV2Wire.LAST_BEGIN_FRAME_ARGS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const BeginFrameObserverStateV2, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const BeginFrameObserverStateV2, target: *gremlin.Writer) void {
        if (self.dropped_begin_frame_args != 0) {
            target.appendInt64(BeginFrameObserverStateV2Wire.DROPPED_BEGIN_FRAME_ARGS_WIRE, self.dropped_begin_frame_args);
        }
        if (self.last_begin_frame_args) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(BeginFrameObserverStateV2Wire.LAST_BEGIN_FRAME_ARGS_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const BeginFrameObserverStateV2Reader = struct {
    buf: gremlin.Reader,
    _dropped_begin_frame_args: i64 = 0,
    _last_begin_frame_args_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!BeginFrameObserverStateV2Reader {
        const buf = gremlin.Reader.init(src);
        var res = BeginFrameObserverStateV2Reader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                BeginFrameObserverStateV2Wire.DROPPED_BEGIN_FRAME_ARGS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._dropped_begin_frame_args = result.value;
                },
                BeginFrameObserverStateV2Wire.LAST_BEGIN_FRAME_ARGS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._last_begin_frame_args_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDroppedBeginFrameArgs(self: *const BeginFrameObserverStateV2Reader) i64 {
        return self._dropped_begin_frame_args;
    }
    pub fn getLastBeginFrameArgs(self: *const BeginFrameObserverStateV2Reader) gremlin.Error!BeginFrameArgsV2Reader {
        if (self._last_begin_frame_args_buf) |buf| {
            return try BeginFrameArgsV2Reader.init(buf);
        }
        return try BeginFrameArgsV2Reader.init(&[_]u8{});
    }
};
const BeginFrameSourceStateV2Wire = struct {
    const SOURCE_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const PAUSED_WIRE: gremlin.ProtoWireNumber = 2;
    const NUM_OBSERVERS_WIRE: gremlin.ProtoWireNumber = 3;
    const LAST_BEGIN_FRAME_ARGS_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const BeginFrameSourceStateV2 = struct {
    // fields
    source_id: u32 = 0,
    paused: bool = false,
    num_observers: u32 = 0,
    last_begin_frame_args: ?BeginFrameArgsV2 = null,
    pub fn calcProtobufSize(self: *const BeginFrameSourceStateV2) usize {
        var res: usize = 0;
        if (self.source_id != 0) {
            res += gremlin.sizes.sizeWireNumber(BeginFrameSourceStateV2Wire.SOURCE_ID_WIRE) + gremlin.sizes.sizeU32(self.source_id);
        }
        if (self.paused != false) {
            res += gremlin.sizes.sizeWireNumber(BeginFrameSourceStateV2Wire.PAUSED_WIRE) + gremlin.sizes.sizeBool(self.paused);
        }
        if (self.num_observers != 0) {
            res += gremlin.sizes.sizeWireNumber(BeginFrameSourceStateV2Wire.NUM_OBSERVERS_WIRE) + gremlin.sizes.sizeU32(self.num_observers);
        }
        if (self.last_begin_frame_args) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(BeginFrameSourceStateV2Wire.LAST_BEGIN_FRAME_ARGS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const BeginFrameSourceStateV2, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const BeginFrameSourceStateV2, target: *gremlin.Writer) void {
        if (self.source_id != 0) {
            target.appendUint32(BeginFrameSourceStateV2Wire.SOURCE_ID_WIRE, self.source_id);
        }
        if (self.paused != false) {
            target.appendBool(BeginFrameSourceStateV2Wire.PAUSED_WIRE, self.paused);
        }
        if (self.num_observers != 0) {
            target.appendUint32(BeginFrameSourceStateV2Wire.NUM_OBSERVERS_WIRE, self.num_observers);
        }
        if (self.last_begin_frame_args) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(BeginFrameSourceStateV2Wire.LAST_BEGIN_FRAME_ARGS_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const BeginFrameSourceStateV2Reader = struct {
    buf: gremlin.Reader,
    _source_id: u32 = 0,
    _paused: bool = false,
    _num_observers: u32 = 0,
    _last_begin_frame_args_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!BeginFrameSourceStateV2Reader {
        const buf = gremlin.Reader.init(src);
        var res = BeginFrameSourceStateV2Reader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                BeginFrameSourceStateV2Wire.SOURCE_ID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._source_id = result.value;
                },
                BeginFrameSourceStateV2Wire.PAUSED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._paused = result.value;
                },
                BeginFrameSourceStateV2Wire.NUM_OBSERVERS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._num_observers = result.value;
                },
                BeginFrameSourceStateV2Wire.LAST_BEGIN_FRAME_ARGS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._last_begin_frame_args_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getSourceId(self: *const BeginFrameSourceStateV2Reader) u32 {
        return self._source_id;
    }
    pub inline fn getPaused(self: *const BeginFrameSourceStateV2Reader) bool {
        return self._paused;
    }
    pub inline fn getNumObservers(self: *const BeginFrameSourceStateV2Reader) u32 {
        return self._num_observers;
    }
    pub fn getLastBeginFrameArgs(self: *const BeginFrameSourceStateV2Reader) gremlin.Error!BeginFrameArgsV2Reader {
        if (self._last_begin_frame_args_buf) |buf| {
            return try BeginFrameArgsV2Reader.init(buf);
        }
        return try BeginFrameArgsV2Reader.init(&[_]u8{});
    }
};
const CompositorTimingHistoryV2Wire = struct {
    const BEGIN_MAIN_FRAME_QUEUE_CRITICAL_ESTIMATE_DELTA_US_WIRE: gremlin.ProtoWireNumber = 1;
    const BEGIN_MAIN_FRAME_QUEUE_NOT_CRITICAL_ESTIMATE_DELTA_US_WIRE: gremlin.ProtoWireNumber = 2;
    const BEGIN_MAIN_FRAME_START_TO_READY_TO_COMMIT_ESTIMATE_DELTA_US_WIRE: gremlin.ProtoWireNumber = 3;
    const COMMIT_TO_READY_TO_ACTIVATE_ESTIMATE_DELTA_US_WIRE: gremlin.ProtoWireNumber = 4;
    const PREPARE_TILES_ESTIMATE_DELTA_US_WIRE: gremlin.ProtoWireNumber = 5;
    const ACTIVATE_ESTIMATE_DELTA_US_WIRE: gremlin.ProtoWireNumber = 6;
    const DRAW_ESTIMATE_DELTA_US_WIRE: gremlin.ProtoWireNumber = 7;
};
pub const CompositorTimingHistoryV2 = struct {
    // fields
    begin_main_frame_queue_critical_estimate_delta_us: i64 = 0,
    begin_main_frame_queue_not_critical_estimate_delta_us: i64 = 0,
    begin_main_frame_start_to_ready_to_commit_estimate_delta_us: i64 = 0,
    commit_to_ready_to_activate_estimate_delta_us: i64 = 0,
    prepare_tiles_estimate_delta_us: i64 = 0,
    activate_estimate_delta_us: i64 = 0,
    draw_estimate_delta_us: i64 = 0,
    pub fn calcProtobufSize(self: *const CompositorTimingHistoryV2) usize {
        var res: usize = 0;
        if (self.begin_main_frame_queue_critical_estimate_delta_us != 0) {
            res += gremlin.sizes.sizeWireNumber(CompositorTimingHistoryV2Wire.BEGIN_MAIN_FRAME_QUEUE_CRITICAL_ESTIMATE_DELTA_US_WIRE) + gremlin.sizes.sizeI64(self.begin_main_frame_queue_critical_estimate_delta_us);
        }
        if (self.begin_main_frame_queue_not_critical_estimate_delta_us != 0) {
            res += gremlin.sizes.sizeWireNumber(CompositorTimingHistoryV2Wire.BEGIN_MAIN_FRAME_QUEUE_NOT_CRITICAL_ESTIMATE_DELTA_US_WIRE) + gremlin.sizes.sizeI64(self.begin_main_frame_queue_not_critical_estimate_delta_us);
        }
        if (self.begin_main_frame_start_to_ready_to_commit_estimate_delta_us != 0) {
            res += gremlin.sizes.sizeWireNumber(CompositorTimingHistoryV2Wire.BEGIN_MAIN_FRAME_START_TO_READY_TO_COMMIT_ESTIMATE_DELTA_US_WIRE) + gremlin.sizes.sizeI64(self.begin_main_frame_start_to_ready_to_commit_estimate_delta_us);
        }
        if (self.commit_to_ready_to_activate_estimate_delta_us != 0) {
            res += gremlin.sizes.sizeWireNumber(CompositorTimingHistoryV2Wire.COMMIT_TO_READY_TO_ACTIVATE_ESTIMATE_DELTA_US_WIRE) + gremlin.sizes.sizeI64(self.commit_to_ready_to_activate_estimate_delta_us);
        }
        if (self.prepare_tiles_estimate_delta_us != 0) {
            res += gremlin.sizes.sizeWireNumber(CompositorTimingHistoryV2Wire.PREPARE_TILES_ESTIMATE_DELTA_US_WIRE) + gremlin.sizes.sizeI64(self.prepare_tiles_estimate_delta_us);
        }
        if (self.activate_estimate_delta_us != 0) {
            res += gremlin.sizes.sizeWireNumber(CompositorTimingHistoryV2Wire.ACTIVATE_ESTIMATE_DELTA_US_WIRE) + gremlin.sizes.sizeI64(self.activate_estimate_delta_us);
        }
        if (self.draw_estimate_delta_us != 0) {
            res += gremlin.sizes.sizeWireNumber(CompositorTimingHistoryV2Wire.DRAW_ESTIMATE_DELTA_US_WIRE) + gremlin.sizes.sizeI64(self.draw_estimate_delta_us);
        }
        return res;
    }
    pub fn encode(self: *const CompositorTimingHistoryV2, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const CompositorTimingHistoryV2, target: *gremlin.Writer) void {
        if (self.begin_main_frame_queue_critical_estimate_delta_us != 0) {
            target.appendInt64(CompositorTimingHistoryV2Wire.BEGIN_MAIN_FRAME_QUEUE_CRITICAL_ESTIMATE_DELTA_US_WIRE, self.begin_main_frame_queue_critical_estimate_delta_us);
        }
        if (self.begin_main_frame_queue_not_critical_estimate_delta_us != 0) {
            target.appendInt64(CompositorTimingHistoryV2Wire.BEGIN_MAIN_FRAME_QUEUE_NOT_CRITICAL_ESTIMATE_DELTA_US_WIRE, self.begin_main_frame_queue_not_critical_estimate_delta_us);
        }
        if (self.begin_main_frame_start_to_ready_to_commit_estimate_delta_us != 0) {
            target.appendInt64(CompositorTimingHistoryV2Wire.BEGIN_MAIN_FRAME_START_TO_READY_TO_COMMIT_ESTIMATE_DELTA_US_WIRE, self.begin_main_frame_start_to_ready_to_commit_estimate_delta_us);
        }
        if (self.commit_to_ready_to_activate_estimate_delta_us != 0) {
            target.appendInt64(CompositorTimingHistoryV2Wire.COMMIT_TO_READY_TO_ACTIVATE_ESTIMATE_DELTA_US_WIRE, self.commit_to_ready_to_activate_estimate_delta_us);
        }
        if (self.prepare_tiles_estimate_delta_us != 0) {
            target.appendInt64(CompositorTimingHistoryV2Wire.PREPARE_TILES_ESTIMATE_DELTA_US_WIRE, self.prepare_tiles_estimate_delta_us);
        }
        if (self.activate_estimate_delta_us != 0) {
            target.appendInt64(CompositorTimingHistoryV2Wire.ACTIVATE_ESTIMATE_DELTA_US_WIRE, self.activate_estimate_delta_us);
        }
        if (self.draw_estimate_delta_us != 0) {
            target.appendInt64(CompositorTimingHistoryV2Wire.DRAW_ESTIMATE_DELTA_US_WIRE, self.draw_estimate_delta_us);
        }
    }
};
pub const CompositorTimingHistoryV2Reader = struct {
    buf: gremlin.Reader,
    _begin_main_frame_queue_critical_estimate_delta_us: i64 = 0,
    _begin_main_frame_queue_not_critical_estimate_delta_us: i64 = 0,
    _begin_main_frame_start_to_ready_to_commit_estimate_delta_us: i64 = 0,
    _commit_to_ready_to_activate_estimate_delta_us: i64 = 0,
    _prepare_tiles_estimate_delta_us: i64 = 0,
    _activate_estimate_delta_us: i64 = 0,
    _draw_estimate_delta_us: i64 = 0,
    pub fn init(src: []const u8) gremlin.Error!CompositorTimingHistoryV2Reader {
        const buf = gremlin.Reader.init(src);
        var res = CompositorTimingHistoryV2Reader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                CompositorTimingHistoryV2Wire.BEGIN_MAIN_FRAME_QUEUE_CRITICAL_ESTIMATE_DELTA_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._begin_main_frame_queue_critical_estimate_delta_us = result.value;
                },
                CompositorTimingHistoryV2Wire.BEGIN_MAIN_FRAME_QUEUE_NOT_CRITICAL_ESTIMATE_DELTA_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._begin_main_frame_queue_not_critical_estimate_delta_us = result.value;
                },
                CompositorTimingHistoryV2Wire.BEGIN_MAIN_FRAME_START_TO_READY_TO_COMMIT_ESTIMATE_DELTA_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._begin_main_frame_start_to_ready_to_commit_estimate_delta_us = result.value;
                },
                CompositorTimingHistoryV2Wire.COMMIT_TO_READY_TO_ACTIVATE_ESTIMATE_DELTA_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._commit_to_ready_to_activate_estimate_delta_us = result.value;
                },
                CompositorTimingHistoryV2Wire.PREPARE_TILES_ESTIMATE_DELTA_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._prepare_tiles_estimate_delta_us = result.value;
                },
                CompositorTimingHistoryV2Wire.ACTIVATE_ESTIMATE_DELTA_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._activate_estimate_delta_us = result.value;
                },
                CompositorTimingHistoryV2Wire.DRAW_ESTIMATE_DELTA_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._draw_estimate_delta_us = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getBeginMainFrameQueueCriticalEstimateDeltaUs(self: *const CompositorTimingHistoryV2Reader) i64 {
        return self._begin_main_frame_queue_critical_estimate_delta_us;
    }
    pub inline fn getBeginMainFrameQueueNotCriticalEstimateDeltaUs(self: *const CompositorTimingHistoryV2Reader) i64 {
        return self._begin_main_frame_queue_not_critical_estimate_delta_us;
    }
    pub inline fn getBeginMainFrameStartToReadyToCommitEstimateDeltaUs(self: *const CompositorTimingHistoryV2Reader) i64 {
        return self._begin_main_frame_start_to_ready_to_commit_estimate_delta_us;
    }
    pub inline fn getCommitToReadyToActivateEstimateDeltaUs(self: *const CompositorTimingHistoryV2Reader) i64 {
        return self._commit_to_ready_to_activate_estimate_delta_us;
    }
    pub inline fn getPrepareTilesEstimateDeltaUs(self: *const CompositorTimingHistoryV2Reader) i64 {
        return self._prepare_tiles_estimate_delta_us;
    }
    pub inline fn getActivateEstimateDeltaUs(self: *const CompositorTimingHistoryV2Reader) i64 {
        return self._activate_estimate_delta_us;
    }
    pub inline fn getDrawEstimateDeltaUs(self: *const CompositorTimingHistoryV2Reader) i64 {
        return self._draw_estimate_delta_us;
    }
};
const WebViewStartupWire = struct {
    const FROM_UI_THREAD_WIRE: gremlin.ProtoWireNumber = 1;
    const START_CALL_SITE_WIRE: gremlin.ProtoWireNumber = 2;
    const FINISH_CALL_SITE_WIRE: gremlin.ProtoWireNumber = 3;
    const STARTUP_MODE_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const WebViewStartup = struct {
    // nested enums
    pub const CallSite = enum(i32) {
        GET_AW_TRACING_CONTROLLER = 0,
        GET_AW_PROXY_CONTROLLER = 1,
        WEBVIEW_INSTANCE = 2,
        GET_STATICS = 3,
        GET_DEFAULT_GEOLOCATION_PERMISSIONS = 4,
        GET_DEFAULT_SERVICE_WORKER_CONTROLLER = 5,
        GET_WEB_ICON_DATABASE = 6,
        GET_DEFAULT_WEB_STORAGE = 7,
        GET_DEFAULT_WEBVIEW_DATABASE = 8,
        GET_TRACING_CONTROLLER = 9,
        ASYNC_WEBVIEW_STARTUP = 10,
        WEBVIEW_INSTANCE_OVERLAY_HORIZONTAL_SCROLLBAR = 11,
        WEBVIEW_INSTANCE_OVERLAY_VERTICAL_SCROLLBAR = 12,
        WEBVIEW_INSTANCE_GET_CERTIFICATE = 13,
        WEBVIEW_INSTANCE_GET_HTTP_AUTH_USERNAME_PASSWORD = 14,
        WEBVIEW_INSTANCE_SAVE_STATE = 15,
        WEBVIEW_INSTANCE_RESTORE_STATE = 16,
        WEBVIEW_INSTANCE_LOAD_URL = 17,
        WEBVIEW_INSTANCE_POST_URL = 18,
        WEBVIEW_INSTANCE_LOAD_DATA = 19,
        WEBVIEW_INSTANCE_LOAD_DATA_WITH_BASE_URL = 20,
        WEBVIEW_INSTANCE_EVALUATE_JAVASCRIPT = 21,
        WEBVIEW_INSTANCE_CAN_GO_BACK = 22,
        WEBVIEW_INSTANCE_CAN_GO_FORWARD = 23,
        WEBVIEW_INSTANCE_CAN_GO_BACK_OR_FORWARD = 24,
        WEBVIEW_INSTANCE_IS_PAUSED = 25,
        WEBVIEW_INSTANCE_COPY_BACK_FORWARD_LIST = 26,
        WEBVIEW_INSTANCE_SHOW_FIND_DIALOG = 27,
        WEBVIEW_INSTANCE_SET_WEBVIEW_CLIENT = 28,
        WEBVIEW_INSTANCE_SET_WEBCHROME_CLIENT = 29,
        WEBVIEW_INSTANCE_CREATE_WEBMESSAGE_CHANNEL = 30,
        WEBVIEW_INSTANCE_GET_ZOOM_CONTROLS = 31,
        WEBVIEW_INSTANCE_ZOOM_IN = 32,
        WEBVIEW_INSTANCE_ZOOM_OUT = 33,
        WEBVIEW_INSTANCE_ZOOM_BY = 34,
        WEBVIEW_INSTANCE_SET_RENDERER_PRIORITY_POLICY = 35,
        WEBVIEW_INSTANCE_GET_RENDERER_REQUESTED_PRIORITY = 36,
        WEBVIEW_INSTANCE_GET_RENDERER_PRIORITY_WAIVED_WHEN_NOT_VISIBLE = 37,
        WEBVIEW_INSTANCE_SET_TEXT_CLASSIFIER = 38,
        WEBVIEW_INSTANCE_GET_TEXT_CLASSIFIER = 39,
        WEBVIEW_INSTANCE_AUTOFILL = 40,
        WEBVIEW_INSTANCE_ON_PROVIDE_AUTOFILL_VIRTUAL_STRUCTURE = 41,
        WEBVIEW_INSTANCE_ON_PROVIDE_CONTENT_CAPTURE_STRUCTURE = 42,
        WEBVIEW_INSTANCE_SHOULD_DELAY_CHILD_PRESSED_STATE = 43,
        WEBVIEW_INSTANCE_GET_ACCESSIBILITY_NODE_PROVIDER = 44,
        WEBVIEW_INSTANCE_ON_PROVIDE_VIRTUAL_STRUCTURE = 45,
        WEBVIEW_INSTANCE_PERFORM_ACCESSIBILITY_ACTION = 46,
        WEBVIEW_INSTANCE_ON_DRAW = 47,
        WEBVIEW_INSTANCE_SET_LAYOUT_PARAMS = 48,
        WEBVIEW_INSTANCE_ON_DRAG_EVENT = 49,
        WEBVIEW_INSTANCE_ON_CREATE_INPUT_CONNECTION = 50,
        WEBVIEW_INSTANCE_ON_KEY_MULTIPLE = 51,
        WEBVIEW_INSTANCE_ON_KEY_DOWN = 52,
        WEBVIEW_INSTANCE_ON_KEY_UP = 53,
        WEBVIEW_INSTANCE_ON_ATTACHED_TO_WINDOW = 54,
        WEBVIEW_INSTANCE_DISPATCH_KEY_EVENT = 55,
        WEBVIEW_INSTANCE_ON_TOUCH_EVENT = 56,
        WEBVIEW_INSTANCE_ON_HOVER_EVENT = 57,
        WEBVIEW_INSTANCE_ON_GENERIC_MOTION_EVENT = 58,
        WEBVIEW_INSTANCE_REQUEST_FOCUS = 59,
        WEBVIEW_INSTANCE_ON_MEASURE = 60,
        WEBVIEW_INSTANCE_REQUEST_CHILD_RECTANGLE_ON_SCREEN = 61,
        WEBVIEW_INSTANCE_SET_BACKGROUND_COLOR = 62,
        WEBVIEW_INSTANCE_ON_START_TEMPORARY_DETACH = 63,
        WEBVIEW_INSTANCE_ON_FINISH_TEMPORARY_DETACH = 64,
        WEBVIEW_INSTANCE_ON_CHECK_IS_TEXT_EDITOR = 65,
        WEBVIEW_INSTANCE_ON_APPLY_WINDOW_INSETS = 66,
        WEBVIEW_INSTANCE_ON_RESOLVE_POINTER_ICON = 67,
        WEBVIEW_INSTANCE_COMPUTE_HORIZONTAL_SCROLL_RANGE = 68,
        WEBVIEW_INSTANCE_COMPUTE_HORIZONTAL_SCROLL_OFFSET = 69,
        WEBVIEW_INSTANCE_COMPUTE_VERTICAL_SCROLL_RANGE = 70,
        WEBVIEW_INSTANCE_COMPUTE_VERTICAL_SCROLL_OFFSET = 71,
        WEBVIEW_INSTANCE_COMPUTE_VERTICAL_SCROLL_EXTENT = 72,
        WEBVIEW_INSTANCE_COMPUTE_SCROLL = 73,
        WEBVIEW_INSTANCE_CREATE_PRINT_DOCUMENT_ADAPTER = 74,
        WEBVIEW_INSTANCE_EXTRACT_SMART_CLIP_DATA = 75,
        WEBVIEW_INSTANCE_SET_SMART_CLIP_RESULT_HANDLER = 76,
        WEBVIEW_INSTANCE_GET_RENDER_PROCESS = 77,
        WEBVIEW_INSTANCE_GET_WEBVIEW_RENDERER_CLIENT_ADAPTER = 78,
        WEBVIEW_INSTANCE_PAGE_UP = 79,
        WEBVIEW_INSTANCE_PAGE_DOWN = 80,
        WEBVIEW_INSTANCE_LOAD_URL_ADDITIONAL_HEADERS = 81,
        WEBVIEW_INSTANCE_INIT = 82,
        WEBVIEW_INSTANCE_CAPTURE_PICTURE = 83,
        WEBVIEW_INSTANCE_GET_SCALE = 84,
        WEBVIEW_INSTANCE_SET_INITIAL_SCALE = 85,
        WEBVIEW_INSTANCE_GET_HIT_TEST_RESULT = 86,
        WEBVIEW_INSTANCE_GET_URL = 87,
        WEBVIEW_INSTANCE_GET_ORIGINAL_URL = 88,
        WEBVIEW_INSTANCE_GET_TITLE = 89,
        WEBVIEW_INSTANCE_GET_FAVICON = 90,
        STATIC_FIND_ADDRESS = 91,
        STATIC_GET_DEFAULT_USER_AGENT = 92,
        STATIC_SET_WEB_CONTENTS_DEBUGGING_ENABLED = 93,
        STATIC_CLEAR_CLIENT_CERT_PREFERENCES = 94,
        STATIC_FREE_MEMORY_FOR_TESTS = 95,
        STATIC_ENABLE_SLOW_WHOLE_DOCUMENT_DRAW = 96,
        STATIC_PARSE_FILE_CHOOSER_RESULT = 97,
        STATIC_INIT_SAFE_BROWSING = 98,
        STATIC_SET_SAFE_BROWSING_ALLOWLIST = 99,
        STATIC_GET_SAFE_BROWSING_PRIVACY_POLICY_URL = 100,
        STATIC_IS_MULTI_PROCESS_ENABLED = 101,
        STATIC_GET_VARIATIONS_HEADER = 102,
        STATIC_SET_RENDERER_LIBRARY_PREFETCH_MODE = 105,
        STATIC_GET_RENDERER_LIBRARY_PREFETCH_MODE = 106,
        GET_DEFAULT_COOKIE_MANAGER = 107,
    };
    pub const StartupMode = enum(i32) {
        FULLY_SYNC = 0,
        FULLY_ASYNC = 1,
        PARTIAL_ASYNC_THEN_SYNC = 2,
        ASYNC_BUT_FULLY_SYNC = 3,
    };
    // fields
    from_ui_thread: bool = false,
    start_call_site: WebViewStartup.CallSite = @enumFromInt(0),
    finish_call_site: WebViewStartup.CallSite = @enumFromInt(0),
    startup_mode: WebViewStartup.StartupMode = @enumFromInt(0),
    pub fn calcProtobufSize(self: *const WebViewStartup) usize {
        var res: usize = 0;
        if (self.from_ui_thread != false) {
            res += gremlin.sizes.sizeWireNumber(WebViewStartupWire.FROM_UI_THREAD_WIRE) + gremlin.sizes.sizeBool(self.from_ui_thread);
        }
        if (@intFromEnum(self.start_call_site) != 0) {
            res += gremlin.sizes.sizeWireNumber(WebViewStartupWire.START_CALL_SITE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.start_call_site));
        }
        if (@intFromEnum(self.finish_call_site) != 0) {
            res += gremlin.sizes.sizeWireNumber(WebViewStartupWire.FINISH_CALL_SITE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.finish_call_site));
        }
        if (@intFromEnum(self.startup_mode) != 0) {
            res += gremlin.sizes.sizeWireNumber(WebViewStartupWire.STARTUP_MODE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.startup_mode));
        }
        return res;
    }
    pub fn encode(self: *const WebViewStartup, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const WebViewStartup, target: *gremlin.Writer) void {
        if (self.from_ui_thread != false) {
            target.appendBool(WebViewStartupWire.FROM_UI_THREAD_WIRE, self.from_ui_thread);
        }
        if (@intFromEnum(self.start_call_site) != 0) {
            target.appendInt32(WebViewStartupWire.START_CALL_SITE_WIRE, @intFromEnum(self.start_call_site));
        }
        if (@intFromEnum(self.finish_call_site) != 0) {
            target.appendInt32(WebViewStartupWire.FINISH_CALL_SITE_WIRE, @intFromEnum(self.finish_call_site));
        }
        if (@intFromEnum(self.startup_mode) != 0) {
            target.appendInt32(WebViewStartupWire.STARTUP_MODE_WIRE, @intFromEnum(self.startup_mode));
        }
    }
};
pub const WebViewStartupReader = struct {
    buf: gremlin.Reader,
    _from_ui_thread: bool = false,
    _start_call_site: WebViewStartup.CallSite = @enumFromInt(0),
    _finish_call_site: WebViewStartup.CallSite = @enumFromInt(0),
    _startup_mode: WebViewStartup.StartupMode = @enumFromInt(0),
    pub fn init(src: []const u8) gremlin.Error!WebViewStartupReader {
        const buf = gremlin.Reader.init(src);
        var res = WebViewStartupReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                WebViewStartupWire.FROM_UI_THREAD_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._from_ui_thread = result.value;
                },
                WebViewStartupWire.START_CALL_SITE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._start_call_site = @enumFromInt(result.value);
                },
                WebViewStartupWire.FINISH_CALL_SITE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._finish_call_site = @enumFromInt(result.value);
                },
                WebViewStartupWire.STARTUP_MODE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._startup_mode = @enumFromInt(result.value);
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getFromUiThread(self: *const WebViewStartupReader) bool {
        return self._from_ui_thread;
    }
    pub inline fn getStartCallSite(self: *const WebViewStartupReader) WebViewStartup.CallSite {
        return self._start_call_site;
    }
    pub inline fn getFinishCallSite(self: *const WebViewStartupReader) WebViewStartup.CallSite {
        return self._finish_call_site;
    }
    pub inline fn getStartupMode(self: *const WebViewStartupReader) WebViewStartup.StartupMode {
        return self._startup_mode;
    }
};
const AnimationFrameTimingInfoWire = struct {
    const BLOCKING_DURATION_MS_WIRE: gremlin.ProtoWireNumber = 1;
    const DURATION_MS_WIRE: gremlin.ProtoWireNumber = 2;
    const NUM_SCRIPTS_WIRE: gremlin.ProtoWireNumber = 3;
    const BEGIN_FRAME_ID_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const AnimationFrameTimingInfo = struct {
    // fields
    blocking_duration_ms: i64 = 0,
    duration_ms: i64 = 0,
    num_scripts: i64 = 0,
    begin_frame_id: ?BeginFrameId = null,
    pub fn calcProtobufSize(self: *const AnimationFrameTimingInfo) usize {
        var res: usize = 0;
        if (self.blocking_duration_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(AnimationFrameTimingInfoWire.BLOCKING_DURATION_MS_WIRE) + gremlin.sizes.sizeI64(self.blocking_duration_ms);
        }
        if (self.duration_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(AnimationFrameTimingInfoWire.DURATION_MS_WIRE) + gremlin.sizes.sizeI64(self.duration_ms);
        }
        if (self.num_scripts != 0) {
            res += gremlin.sizes.sizeWireNumber(AnimationFrameTimingInfoWire.NUM_SCRIPTS_WIRE) + gremlin.sizes.sizeI64(self.num_scripts);
        }
        if (self.begin_frame_id) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AnimationFrameTimingInfoWire.BEGIN_FRAME_ID_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const AnimationFrameTimingInfo, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AnimationFrameTimingInfo, target: *gremlin.Writer) void {
        if (self.blocking_duration_ms != 0) {
            target.appendInt64(AnimationFrameTimingInfoWire.BLOCKING_DURATION_MS_WIRE, self.blocking_duration_ms);
        }
        if (self.duration_ms != 0) {
            target.appendInt64(AnimationFrameTimingInfoWire.DURATION_MS_WIRE, self.duration_ms);
        }
        if (self.num_scripts != 0) {
            target.appendInt64(AnimationFrameTimingInfoWire.NUM_SCRIPTS_WIRE, self.num_scripts);
        }
        if (self.begin_frame_id) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AnimationFrameTimingInfoWire.BEGIN_FRAME_ID_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const AnimationFrameTimingInfoReader = struct {
    buf: gremlin.Reader,
    _blocking_duration_ms: i64 = 0,
    _duration_ms: i64 = 0,
    _num_scripts: i64 = 0,
    _begin_frame_id_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!AnimationFrameTimingInfoReader {
        const buf = gremlin.Reader.init(src);
        var res = AnimationFrameTimingInfoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AnimationFrameTimingInfoWire.BLOCKING_DURATION_MS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._blocking_duration_ms = result.value;
                },
                AnimationFrameTimingInfoWire.DURATION_MS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._duration_ms = result.value;
                },
                AnimationFrameTimingInfoWire.NUM_SCRIPTS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._num_scripts = result.value;
                },
                AnimationFrameTimingInfoWire.BEGIN_FRAME_ID_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._begin_frame_id_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getBlockingDurationMs(self: *const AnimationFrameTimingInfoReader) i64 {
        return self._blocking_duration_ms;
    }
    pub inline fn getDurationMs(self: *const AnimationFrameTimingInfoReader) i64 {
        return self._duration_ms;
    }
    pub inline fn getNumScripts(self: *const AnimationFrameTimingInfoReader) i64 {
        return self._num_scripts;
    }
    pub fn getBeginFrameId(self: *const AnimationFrameTimingInfoReader) gremlin.Error!BeginFrameIdReader {
        if (self._begin_frame_id_buf) |buf| {
            return try BeginFrameIdReader.init(buf);
        }
        return try BeginFrameIdReader.init(&[_]u8{});
    }
};
const AnimationFrameScriptTimingInfoWire = struct {
    const STYLE_DURATION_MS_WIRE: gremlin.ProtoWireNumber = 1;
    const LAYOUT_DURATION_MS_WIRE: gremlin.ProtoWireNumber = 2;
    const PAUSE_DURATION_MS_WIRE: gremlin.ProtoWireNumber = 3;
    const CLASS_LIKE_NAME_WIRE: gremlin.ProtoWireNumber = 4;
    const PROPERTY_LIKE_NAME_WIRE: gremlin.ProtoWireNumber = 5;
    const SOURCE_LOCATION_URL_WIRE: gremlin.ProtoWireNumber = 6;
    const SOURCE_LOCATION_FUNCTION_NAME_WIRE: gremlin.ProtoWireNumber = 7;
    const SOURCE_LOCATION_CHAR_POSITION_WIRE: gremlin.ProtoWireNumber = 8;
    const INVOKER_TYPE_WIRE: gremlin.ProtoWireNumber = 9;
    const THIRD_PARTY_TECHNOLOGY_WIRE: gremlin.ProtoWireNumber = 10;
};
pub const AnimationFrameScriptTimingInfo = struct {
    // nested enums
    pub const InvokerType = enum(i32) {
        UNDEFINED = 0,
        CLASSIC_SCRIPT = 1,
        MODULE_SCRIPT = 2,
        USER_CALLBACK = 3,
        EVENT_HANDLER = 4,
        PROMISE_RESOLVE = 5,
        PROMISE_REJECT = 6,
    };
    pub const ThirdPartyTechnology = enum(i32) {
        UNSPECIFIED = 0,
        NONE = 1,
        WORD_PRESS = 2,
        GOOGLE_ANALYTICS = 3,
        GOOGLE_FONT_API = 4,
        GOOGLE_TAG_MANAGER = 5,
        GOOGLE_MAPS = 6,
        META_PIXEL = 7,
        YOUTUBE = 8,
        ADOBE_ANALYTICS = 9,
        TIKTOK_PIXEL = 10,
        HOTJAR = 11,
        GOOGLE_ADSENSE = 12,
        GOOGLE_PUBLISHER_TAG = 13,
        GOOGLE_ADS_LIBRARIES = 14,
        FUNDING_CHOICES = 15,
        ELEMENTOR = 16,
        SLIDER_REVOLUTION = 17,
    };
    // fields
    style_duration_ms: i64 = 0,
    layout_duration_ms: i64 = 0,
    pause_duration_ms: i64 = 0,
    class_like_name: ?[]const u8 = null,
    property_like_name: ?[]const u8 = null,
    source_location_url: ?[]const u8 = null,
    source_location_function_name: ?[]const u8 = null,
    source_location_char_position: i64 = 0,
    invoker_type: AnimationFrameScriptTimingInfo.InvokerType = @enumFromInt(0),
    third_party_technology: AnimationFrameScriptTimingInfo.ThirdPartyTechnology = @enumFromInt(0),
    pub fn calcProtobufSize(self: *const AnimationFrameScriptTimingInfo) usize {
        var res: usize = 0;
        if (self.style_duration_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(AnimationFrameScriptTimingInfoWire.STYLE_DURATION_MS_WIRE) + gremlin.sizes.sizeI64(self.style_duration_ms);
        }
        if (self.layout_duration_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(AnimationFrameScriptTimingInfoWire.LAYOUT_DURATION_MS_WIRE) + gremlin.sizes.sizeI64(self.layout_duration_ms);
        }
        if (self.pause_duration_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(AnimationFrameScriptTimingInfoWire.PAUSE_DURATION_MS_WIRE) + gremlin.sizes.sizeI64(self.pause_duration_ms);
        }
        if (self.class_like_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(AnimationFrameScriptTimingInfoWire.CLASS_LIKE_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.property_like_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(AnimationFrameScriptTimingInfoWire.PROPERTY_LIKE_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.source_location_url) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(AnimationFrameScriptTimingInfoWire.SOURCE_LOCATION_URL_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.source_location_function_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(AnimationFrameScriptTimingInfoWire.SOURCE_LOCATION_FUNCTION_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.source_location_char_position != 0) {
            res += gremlin.sizes.sizeWireNumber(AnimationFrameScriptTimingInfoWire.SOURCE_LOCATION_CHAR_POSITION_WIRE) + gremlin.sizes.sizeI64(self.source_location_char_position);
        }
        if (@intFromEnum(self.invoker_type) != 0) {
            res += gremlin.sizes.sizeWireNumber(AnimationFrameScriptTimingInfoWire.INVOKER_TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.invoker_type));
        }
        if (@intFromEnum(self.third_party_technology) != 0) {
            res += gremlin.sizes.sizeWireNumber(AnimationFrameScriptTimingInfoWire.THIRD_PARTY_TECHNOLOGY_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.third_party_technology));
        }
        return res;
    }
    pub fn encode(self: *const AnimationFrameScriptTimingInfo, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AnimationFrameScriptTimingInfo, target: *gremlin.Writer) void {
        if (self.style_duration_ms != 0) {
            target.appendInt64(AnimationFrameScriptTimingInfoWire.STYLE_DURATION_MS_WIRE, self.style_duration_ms);
        }
        if (self.layout_duration_ms != 0) {
            target.appendInt64(AnimationFrameScriptTimingInfoWire.LAYOUT_DURATION_MS_WIRE, self.layout_duration_ms);
        }
        if (self.pause_duration_ms != 0) {
            target.appendInt64(AnimationFrameScriptTimingInfoWire.PAUSE_DURATION_MS_WIRE, self.pause_duration_ms);
        }
        if (self.class_like_name) |v| {
            if (v.len > 0) {
                target.appendBytes(AnimationFrameScriptTimingInfoWire.CLASS_LIKE_NAME_WIRE, v);
            }
        }
        if (self.property_like_name) |v| {
            if (v.len > 0) {
                target.appendBytes(AnimationFrameScriptTimingInfoWire.PROPERTY_LIKE_NAME_WIRE, v);
            }
        }
        if (self.source_location_url) |v| {
            if (v.len > 0) {
                target.appendBytes(AnimationFrameScriptTimingInfoWire.SOURCE_LOCATION_URL_WIRE, v);
            }
        }
        if (self.source_location_function_name) |v| {
            if (v.len > 0) {
                target.appendBytes(AnimationFrameScriptTimingInfoWire.SOURCE_LOCATION_FUNCTION_NAME_WIRE, v);
            }
        }
        if (self.source_location_char_position != 0) {
            target.appendInt64(AnimationFrameScriptTimingInfoWire.SOURCE_LOCATION_CHAR_POSITION_WIRE, self.source_location_char_position);
        }
        if (@intFromEnum(self.invoker_type) != 0) {
            target.appendInt32(AnimationFrameScriptTimingInfoWire.INVOKER_TYPE_WIRE, @intFromEnum(self.invoker_type));
        }
        if (@intFromEnum(self.third_party_technology) != 0) {
            target.appendInt32(AnimationFrameScriptTimingInfoWire.THIRD_PARTY_TECHNOLOGY_WIRE, @intFromEnum(self.third_party_technology));
        }
    }
};
pub const AnimationFrameScriptTimingInfoReader = struct {
    buf: gremlin.Reader,
    _style_duration_ms: i64 = 0,
    _layout_duration_ms: i64 = 0,
    _pause_duration_ms: i64 = 0,
    _class_like_name: ?[]const u8 = null,
    _property_like_name: ?[]const u8 = null,
    _source_location_url: ?[]const u8 = null,
    _source_location_function_name: ?[]const u8 = null,
    _source_location_char_position: i64 = 0,
    _invoker_type: AnimationFrameScriptTimingInfo.InvokerType = @enumFromInt(0),
    _third_party_technology: AnimationFrameScriptTimingInfo.ThirdPartyTechnology = @enumFromInt(0),
    pub fn init(src: []const u8) gremlin.Error!AnimationFrameScriptTimingInfoReader {
        const buf = gremlin.Reader.init(src);
        var res = AnimationFrameScriptTimingInfoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AnimationFrameScriptTimingInfoWire.STYLE_DURATION_MS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._style_duration_ms = result.value;
                },
                AnimationFrameScriptTimingInfoWire.LAYOUT_DURATION_MS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._layout_duration_ms = result.value;
                },
                AnimationFrameScriptTimingInfoWire.PAUSE_DURATION_MS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._pause_duration_ms = result.value;
                },
                AnimationFrameScriptTimingInfoWire.CLASS_LIKE_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._class_like_name = result.value;
                },
                AnimationFrameScriptTimingInfoWire.PROPERTY_LIKE_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._property_like_name = result.value;
                },
                AnimationFrameScriptTimingInfoWire.SOURCE_LOCATION_URL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._source_location_url = result.value;
                },
                AnimationFrameScriptTimingInfoWire.SOURCE_LOCATION_FUNCTION_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._source_location_function_name = result.value;
                },
                AnimationFrameScriptTimingInfoWire.SOURCE_LOCATION_CHAR_POSITION_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._source_location_char_position = result.value;
                },
                AnimationFrameScriptTimingInfoWire.INVOKER_TYPE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._invoker_type = @enumFromInt(result.value);
                },
                AnimationFrameScriptTimingInfoWire.THIRD_PARTY_TECHNOLOGY_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._third_party_technology = @enumFromInt(result.value);
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getStyleDurationMs(self: *const AnimationFrameScriptTimingInfoReader) i64 {
        return self._style_duration_ms;
    }
    pub inline fn getLayoutDurationMs(self: *const AnimationFrameScriptTimingInfoReader) i64 {
        return self._layout_duration_ms;
    }
    pub inline fn getPauseDurationMs(self: *const AnimationFrameScriptTimingInfoReader) i64 {
        return self._pause_duration_ms;
    }
    pub inline fn getClassLikeName(self: *const AnimationFrameScriptTimingInfoReader) []const u8 {
        return self._class_like_name orelse &[_]u8{};
    }
    pub inline fn getPropertyLikeName(self: *const AnimationFrameScriptTimingInfoReader) []const u8 {
        return self._property_like_name orelse &[_]u8{};
    }
    pub inline fn getSourceLocationUrl(self: *const AnimationFrameScriptTimingInfoReader) []const u8 {
        return self._source_location_url orelse &[_]u8{};
    }
    pub inline fn getSourceLocationFunctionName(self: *const AnimationFrameScriptTimingInfoReader) []const u8 {
        return self._source_location_function_name orelse &[_]u8{};
    }
    pub inline fn getSourceLocationCharPosition(self: *const AnimationFrameScriptTimingInfoReader) i64 {
        return self._source_location_char_position;
    }
    pub inline fn getInvokerType(self: *const AnimationFrameScriptTimingInfoReader) AnimationFrameScriptTimingInfo.InvokerType {
        return self._invoker_type;
    }
    pub inline fn getThirdPartyTechnology(self: *const AnimationFrameScriptTimingInfoReader) AnimationFrameScriptTimingInfo.ThirdPartyTechnology {
        return self._third_party_technology;
    }
};
const BeginFrameIdWire = struct {
    const SOURCE_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const SEQUENCE_NUMBER_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const BeginFrameId = struct {
    // fields
    source_id: u64 = 0,
    sequence_number: u64 = 0,
    pub fn calcProtobufSize(self: *const BeginFrameId) usize {
        var res: usize = 0;
        if (self.source_id != 0) {
            res += gremlin.sizes.sizeWireNumber(BeginFrameIdWire.SOURCE_ID_WIRE) + gremlin.sizes.sizeU64(self.source_id);
        }
        if (self.sequence_number != 0) {
            res += gremlin.sizes.sizeWireNumber(BeginFrameIdWire.SEQUENCE_NUMBER_WIRE) + gremlin.sizes.sizeU64(self.sequence_number);
        }
        return res;
    }
    pub fn encode(self: *const BeginFrameId, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const BeginFrameId, target: *gremlin.Writer) void {
        if (self.source_id != 0) {
            target.appendUint64(BeginFrameIdWire.SOURCE_ID_WIRE, self.source_id);
        }
        if (self.sequence_number != 0) {
            target.appendUint64(BeginFrameIdWire.SEQUENCE_NUMBER_WIRE, self.sequence_number);
        }
    }
};
pub const BeginFrameIdReader = struct {
    buf: gremlin.Reader,
    _source_id: u64 = 0,
    _sequence_number: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!BeginFrameIdReader {
        const buf = gremlin.Reader.init(src);
        var res = BeginFrameIdReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                BeginFrameIdWire.SOURCE_ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._source_id = result.value;
                },
                BeginFrameIdWire.SEQUENCE_NUMBER_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._sequence_number = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getSourceId(self: *const BeginFrameIdReader) u64 {
        return self._source_id;
    }
    pub inline fn getSequenceNumber(self: *const BeginFrameIdReader) u64 {
        return self._sequence_number;
    }
};
const MainFramePipelineWire = struct {
    const MAIN_FRAME_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const STEP_WIRE: gremlin.ProtoWireNumber = 2;
    const BEGIN_FRAME_ID_WIRE: gremlin.ProtoWireNumber = 3;
    const ABORTED_ON_MAIN_REASON_WIRE: gremlin.ProtoWireNumber = 4;
    const LAST_BEGIN_FRAME_ID_DURING_FIRST_DRAW_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const MainFramePipeline = struct {
    // nested enums
    pub const Step = enum(i32) {
        UNKNOWN = 0,
        SEND_BEGIN_MAIN_FRAME = 1,
        BEGIN_MAIN_FRAME = 2,
        ABORTED_ON_MAIN = 3,
        COMMIT_ON_MAIN = 4,
        READY_TO_COMMIT_ON_IMPL = 5,
        COMMIT_ON_IMPL = 6,
        COMMIT_COMPLETE = 7,
        READY_TO_ACTIVATE = 8,
        ACTIVATE = 9,
        DRAW = 10,
        UPDATE_DISPLAY_TREE = 11,
    };
    pub const AbortedOnMainReason = enum(i32) {
        ABORTED_MAIN_REASON_UNKNOWN = 0,
        NOT_VISIBLE = 1,
        DEFERRED_UPDATE = 2,
        DEFERRED_COMMIT_ABORTED = 3,
        NO_UPDATE = 4,
    };
    // fields
    main_frame_id: u64 = 0,
    step: MainFramePipeline.Step = @enumFromInt(0),
    begin_frame_id: ?BeginFrameId = null,
    aborted_on_main_reason: MainFramePipeline.AbortedOnMainReason = @enumFromInt(0),
    last_begin_frame_id_during_first_draw: ?BeginFrameId = null,
    pub fn calcProtobufSize(self: *const MainFramePipeline) usize {
        var res: usize = 0;
        if (self.main_frame_id != 0) {
            res += gremlin.sizes.sizeWireNumber(MainFramePipelineWire.MAIN_FRAME_ID_WIRE) + gremlin.sizes.sizeU64(self.main_frame_id);
        }
        if (@intFromEnum(self.step) != 0) {
            res += gremlin.sizes.sizeWireNumber(MainFramePipelineWire.STEP_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.step));
        }
        if (self.begin_frame_id) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(MainFramePipelineWire.BEGIN_FRAME_ID_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (@intFromEnum(self.aborted_on_main_reason) != 0) {
            res += gremlin.sizes.sizeWireNumber(MainFramePipelineWire.ABORTED_ON_MAIN_REASON_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.aborted_on_main_reason));
        }
        if (self.last_begin_frame_id_during_first_draw) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(MainFramePipelineWire.LAST_BEGIN_FRAME_ID_DURING_FIRST_DRAW_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const MainFramePipeline, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const MainFramePipeline, target: *gremlin.Writer) void {
        if (self.main_frame_id != 0) {
            target.appendUint64(MainFramePipelineWire.MAIN_FRAME_ID_WIRE, self.main_frame_id);
        }
        if (@intFromEnum(self.step) != 0) {
            target.appendInt32(MainFramePipelineWire.STEP_WIRE, @intFromEnum(self.step));
        }
        if (self.begin_frame_id) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(MainFramePipelineWire.BEGIN_FRAME_ID_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (@intFromEnum(self.aborted_on_main_reason) != 0) {
            target.appendInt32(MainFramePipelineWire.ABORTED_ON_MAIN_REASON_WIRE, @intFromEnum(self.aborted_on_main_reason));
        }
        if (self.last_begin_frame_id_during_first_draw) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(MainFramePipelineWire.LAST_BEGIN_FRAME_ID_DURING_FIRST_DRAW_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const MainFramePipelineReader = struct {
    buf: gremlin.Reader,
    _main_frame_id: u64 = 0,
    _step: MainFramePipeline.Step = @enumFromInt(0),
    _begin_frame_id_buf: ?[]const u8 = null,
    _aborted_on_main_reason: MainFramePipeline.AbortedOnMainReason = @enumFromInt(0),
    _last_begin_frame_id_during_first_draw_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!MainFramePipelineReader {
        const buf = gremlin.Reader.init(src);
        var res = MainFramePipelineReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MainFramePipelineWire.MAIN_FRAME_ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._main_frame_id = result.value;
                },
                MainFramePipelineWire.STEP_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._step = @enumFromInt(result.value);
                },
                MainFramePipelineWire.BEGIN_FRAME_ID_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._begin_frame_id_buf = result.value;
                },
                MainFramePipelineWire.ABORTED_ON_MAIN_REASON_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._aborted_on_main_reason = @enumFromInt(result.value);
                },
                MainFramePipelineWire.LAST_BEGIN_FRAME_ID_DURING_FIRST_DRAW_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._last_begin_frame_id_during_first_draw_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getMainFrameId(self: *const MainFramePipelineReader) u64 {
        return self._main_frame_id;
    }
    pub inline fn getStep(self: *const MainFramePipelineReader) MainFramePipeline.Step {
        return self._step;
    }
    pub fn getBeginFrameId(self: *const MainFramePipelineReader) gremlin.Error!BeginFrameIdReader {
        if (self._begin_frame_id_buf) |buf| {
            return try BeginFrameIdReader.init(buf);
        }
        return try BeginFrameIdReader.init(&[_]u8{});
    }
    pub inline fn getAbortedOnMainReason(self: *const MainFramePipelineReader) MainFramePipeline.AbortedOnMainReason {
        return self._aborted_on_main_reason;
    }
    pub fn getLastBeginFrameIdDuringFirstDraw(self: *const MainFramePipelineReader) gremlin.Error!BeginFrameIdReader {
        if (self._last_begin_frame_id_during_first_draw_buf) |buf| {
            return try BeginFrameIdReader.init(buf);
        }
        return try BeginFrameIdReader.init(&[_]u8{});
    }
};
const CurrentTaskWire = struct {
    const EVENT_OFFSET_FROM_TASK_START_TIME_US_WIRE: gremlin.ProtoWireNumber = 1;
    const TASK_START_TIME_US_WIRE: gremlin.ProtoWireNumber = 2;
    const TASK_QUEUEING_TIME_US_WIRE: gremlin.ProtoWireNumber = 3;
    const TASK_QUEUED_TIME_US_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const CurrentTask = struct {
    // fields
    event_offset_from_task_start_time_us: u64 = 0,
    task_start_time_us: u64 = 0,
    task_queueing_time_us: u64 = 0,
    task_queued_time_us: u64 = 0,
    pub fn calcProtobufSize(self: *const CurrentTask) usize {
        var res: usize = 0;
        if (self.event_offset_from_task_start_time_us != 0) {
            res += gremlin.sizes.sizeWireNumber(CurrentTaskWire.EVENT_OFFSET_FROM_TASK_START_TIME_US_WIRE) + gremlin.sizes.sizeU64(self.event_offset_from_task_start_time_us);
        }
        if (self.task_start_time_us != 0) {
            res += gremlin.sizes.sizeWireNumber(CurrentTaskWire.TASK_START_TIME_US_WIRE) + gremlin.sizes.sizeU64(self.task_start_time_us);
        }
        if (self.task_queueing_time_us != 0) {
            res += gremlin.sizes.sizeWireNumber(CurrentTaskWire.TASK_QUEUEING_TIME_US_WIRE) + gremlin.sizes.sizeU64(self.task_queueing_time_us);
        }
        if (self.task_queued_time_us != 0) {
            res += gremlin.sizes.sizeWireNumber(CurrentTaskWire.TASK_QUEUED_TIME_US_WIRE) + gremlin.sizes.sizeU64(self.task_queued_time_us);
        }
        return res;
    }
    pub fn encode(self: *const CurrentTask, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const CurrentTask, target: *gremlin.Writer) void {
        if (self.event_offset_from_task_start_time_us != 0) {
            target.appendUint64(CurrentTaskWire.EVENT_OFFSET_FROM_TASK_START_TIME_US_WIRE, self.event_offset_from_task_start_time_us);
        }
        if (self.task_start_time_us != 0) {
            target.appendUint64(CurrentTaskWire.TASK_START_TIME_US_WIRE, self.task_start_time_us);
        }
        if (self.task_queueing_time_us != 0) {
            target.appendUint64(CurrentTaskWire.TASK_QUEUEING_TIME_US_WIRE, self.task_queueing_time_us);
        }
        if (self.task_queued_time_us != 0) {
            target.appendUint64(CurrentTaskWire.TASK_QUEUED_TIME_US_WIRE, self.task_queued_time_us);
        }
    }
};
pub const CurrentTaskReader = struct {
    buf: gremlin.Reader,
    _event_offset_from_task_start_time_us: u64 = 0,
    _task_start_time_us: u64 = 0,
    _task_queueing_time_us: u64 = 0,
    _task_queued_time_us: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!CurrentTaskReader {
        const buf = gremlin.Reader.init(src);
        var res = CurrentTaskReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                CurrentTaskWire.EVENT_OFFSET_FROM_TASK_START_TIME_US_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._event_offset_from_task_start_time_us = result.value;
                },
                CurrentTaskWire.TASK_START_TIME_US_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._task_start_time_us = result.value;
                },
                CurrentTaskWire.TASK_QUEUEING_TIME_US_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._task_queueing_time_us = result.value;
                },
                CurrentTaskWire.TASK_QUEUED_TIME_US_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._task_queued_time_us = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getEventOffsetFromTaskStartTimeUs(self: *const CurrentTaskReader) u64 {
        return self._event_offset_from_task_start_time_us;
    }
    pub inline fn getTaskStartTimeUs(self: *const CurrentTaskReader) u64 {
        return self._task_start_time_us;
    }
    pub inline fn getTaskQueueingTimeUs(self: *const CurrentTaskReader) u64 {
        return self._task_queueing_time_us;
    }
    pub inline fn getTaskQueuedTimeUs(self: *const CurrentTaskReader) u64 {
        return self._task_queued_time_us;
    }
};
const ChromeLatencyInfo2Wire = struct {
    const TRACE_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const STEP_WIRE: gremlin.ProtoWireNumber = 2;
    const FRAME_TREE_NODE_ID_WIRE: gremlin.ProtoWireNumber = 3;
    const COMPONENT_INFO_WIRE: gremlin.ProtoWireNumber = 4;
    const IS_COALESCED_WIRE: gremlin.ProtoWireNumber = 5;
    const GESTURE_SCROLL_ID_WIRE: gremlin.ProtoWireNumber = 6;
    const TOUCH_ID_WIRE: gremlin.ProtoWireNumber = 7;
    const INPUT_TYPE_WIRE: gremlin.ProtoWireNumber = 8;
    const INPUT_RESULT_STATE_WIRE: gremlin.ProtoWireNumber = 9;
    const COALESCED_TRACE_IDS_WIRE: gremlin.ProtoWireNumber = 10;
};
pub const ChromeLatencyInfo2 = struct {
    // nested enums
    pub const Step = enum(i32) {
        STEP_UNSPECIFIED = 0,
        STEP_SEND_INPUT_EVENT_UI = 3,
        STEP_SEND_DISPATCH_EVENT_MOJO_MESSAGE = 15,
        STEP_HANDLE_INPUT_EVENT_IMPL = 5,
        STEP_RESAMPLE_SCROLL_EVENTS = 14,
        STEP_DID_HANDLE_INPUT_AND_OVERSCROLL = 8,
        STEP_HANDLE_INPUT_EVENT_MAIN = 4,
        STEP_MAIN_THREAD_SCROLL_UPDATE = 2,
        STEP_HANDLE_INPUT_EVENT_MAIN_COMMIT = 1,
        STEP_HANDLED_INPUT_EVENT_MAIN_OR_IMPL = 9,
        STEP_HANDLED_INPUT_EVENT_IMPL = 10,
        STEP_TOUCH_EVENT_HANDLED = 12,
        STEP_GESTURE_EVENT_HANDLED = 13,
        STEP_SWAP_BUFFERS = 6,
        STEP_DRAW_AND_SWAP = 7,
        STEP_FINISHED_SWAP_BUFFERS = 11,
    };
    pub const LatencyComponentType = enum(i32) {
        COMPONENT_UNSPECIFIED = 0,
        COMPONENT_INPUT_EVENT_LATENCY_BEGIN_RWH = 1,
        COMPONENT_INPUT_EVENT_LATENCY_SCROLL_UPDATE_ORIGINAL = 2,
        COMPONENT_INPUT_EVENT_LATENCY_FIRST_SCROLL_UPDATE_ORIGINAL = 3,
        COMPONENT_INPUT_EVENT_LATENCY_ORIGINAL = 4,
        COMPONENT_INPUT_EVENT_LATENCY_UI = 5,
        COMPONENT_INPUT_EVENT_LATENCY_RENDERER_MAIN = 6,
        COMPONENT_INPUT_EVENT_LATENCY_RENDERING_SCHEDULED_MAIN = 7,
        COMPONENT_INPUT_EVENT_LATENCY_RENDERING_SCHEDULED_IMPL = 8,
        COMPONENT_INPUT_EVENT_LATENCY_SCROLL_UPDATE_LAST_EVENT = 9,
        COMPONENT_INPUT_EVENT_LATENCY_ACK_RWH = 10,
        COMPONENT_INPUT_EVENT_LATENCY_RENDERER_SWAP = 11,
        COMPONENT_DISPLAY_COMPOSITOR_RECEIVED_FRAME = 12,
        COMPONENT_INPUT_EVENT_GPU_SWAP_BUFFER = 13,
        COMPONENT_INPUT_EVENT_LATENCY_FRAME_SWAP = 14,
    };
    pub const InputType = enum(i32) {
        UNDEFINED_EVENT = 0,
        MOUSE_DOWN_EVENT = 1,
        MOUSE_UP_EVENT = 2,
        MOUSE_MOVE_EVENT = 3,
        MOUSE_ENTER_EVENT = 4,
        MOUSE_LEAVE_EVENT = 5,
        CONTEXT_MENU_EVENT = 6,
        MOUSE_WHEEL_EVENT = 7,
        RAW_KEY_DOWN_EVENT = 8,
        KEY_DOWN_EVENT = 9,
        KEY_UP_EVENT = 10,
        CHAR_EVENT = 11,
        GESTURE_SCROLL_BEGIN_EVENT = 12,
        GESTURE_SCROLL_END_EVENT = 13,
        GESTURE_SCROLL_UPDATE_EVENT = 14,
        GESTURE_FLING_START_EVENT = 15,
        GESTURE_FLING_CANCEL_EVENT = 16,
        GESTURE_PINCH_BEGIN_EVENT = 17,
        GESTURE_PINCH_END_EVENT = 18,
        GESTURE_PINCH_UPDATE_EVENT = 19,
        GESTURE_BEGIN_EVENT = 20,
        GESTURE_TAP_DOWN_EVENT = 21,
        GESTURE_SHOW_PRESS_EVENT = 22,
        GESTURE_TAP_EVENT = 23,
        GESTURE_TAP_CANCEL_EVENT = 24,
        GESTURE_SHORT_PRESS_EVENT = 25,
        GESTURE_LONG_PRESS_EVENT = 26,
        GESTURE_LONG_TAP_EVENT = 27,
        GESTURE_TWO_FINGER_TAP_EVENT = 28,
        GESTURE_TAP_UNCONFIRMED_EVENT = 29,
        GESTURE_DOUBLE_TAP_EVENT = 30,
        GESTURE_END_EVENT = 31,
        TOUCH_START_EVENT = 32,
        TOUCH_MOVE_EVENT = 33,
        TOUCH_END_EVENT = 34,
        TOUCH_CANCEL_EVENT = 35,
        TOUCH_SCROLL_STARTED_EVENT = 36,
        POINTER_DOWN_EVENT = 37,
        POINTER_UP_EVENT = 38,
        POINTER_MOVE_EVENT = 39,
        POINTER_RAW_UPDATE_EVENT = 40,
        POINTER_CANCEL_EVENT = 41,
        POINTER_CAUSED_UA_ACTION_EVENT = 42,
    };
    pub const InputResultState = enum(i32) {
        UNKNOWN = 0,
        CONSUMED = 1,
        NOT_CONSUMED = 2,
        NO_CONSUMER_EXISTS = 3,
        IGNORED = 4,
        SET_NON_BLOCKING = 5,
        SET_NON_BLOCKING_DUE_TO_FLING = 6,
    };
    // nested structs
    const ComponentInfoWire = struct {
        const COMPONENT_TYPE_WIRE: gremlin.ProtoWireNumber = 1;
        const TIME_US_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const ComponentInfo = struct {
        // fields
        component_type: ChromeLatencyInfo2.LatencyComponentType = @enumFromInt(0),
        time_us: u64 = 0,
        pub fn calcProtobufSize(self: *const ChromeLatencyInfo2.ComponentInfo) usize {
            var res: usize = 0;
            if (@intFromEnum(self.component_type) != 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeLatencyInfo2.ComponentInfoWire.COMPONENT_TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.component_type));
            }
            if (self.time_us != 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeLatencyInfo2.ComponentInfoWire.TIME_US_WIRE) + gremlin.sizes.sizeU64(self.time_us);
            }
            return res;
        }
        pub fn encode(self: *const ChromeLatencyInfo2.ComponentInfo, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const ChromeLatencyInfo2.ComponentInfo, target: *gremlin.Writer) void {
            if (@intFromEnum(self.component_type) != 0) {
                target.appendInt32(ChromeLatencyInfo2.ComponentInfoWire.COMPONENT_TYPE_WIRE, @intFromEnum(self.component_type));
            }
            if (self.time_us != 0) {
                target.appendUint64(ChromeLatencyInfo2.ComponentInfoWire.TIME_US_WIRE, self.time_us);
            }
        }
    };
    pub const ComponentInfoReader = struct {
        buf: gremlin.Reader,
        _component_type: ChromeLatencyInfo2.LatencyComponentType = @enumFromInt(0),
        _time_us: u64 = 0,
        pub fn init(src: []const u8) gremlin.Error!ChromeLatencyInfo2.ComponentInfoReader {
            const buf = gremlin.Reader.init(src);
            var res = ChromeLatencyInfo2.ComponentInfoReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    ChromeLatencyInfo2.ComponentInfoWire.COMPONENT_TYPE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._component_type = @enumFromInt(result.value);
                    },
                    ChromeLatencyInfo2.ComponentInfoWire.TIME_US_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._time_us = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getComponentType(self: *const ChromeLatencyInfo2.ComponentInfoReader) ChromeLatencyInfo2.LatencyComponentType {
            return self._component_type;
        }
        pub inline fn getTimeUs(self: *const ChromeLatencyInfo2.ComponentInfoReader) u64 {
            return self._time_us;
        }
    };
    // fields
    trace_id: i64 = 0,
    step: ChromeLatencyInfo2.Step = @enumFromInt(0),
    frame_tree_node_id: i32 = 0,
    component_info: ?[]const ?ChromeLatencyInfo2.ComponentInfo = null,
    is_coalesced: bool = false,
    gesture_scroll_id: i64 = 0,
    touch_id: i64 = 0,
    input_type: ChromeLatencyInfo2.InputType = @enumFromInt(0),
    input_result_state: ChromeLatencyInfo2.InputResultState = @enumFromInt(0),
    coalesced_trace_ids: ?[]const i64 = null,
    pub fn calcProtobufSize(self: *const ChromeLatencyInfo2) usize {
        var res: usize = 0;
        if (self.trace_id != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeLatencyInfo2Wire.TRACE_ID_WIRE) + gremlin.sizes.sizeI64(self.trace_id);
        }
        if (@intFromEnum(self.step) != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeLatencyInfo2Wire.STEP_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.step));
        }
        if (self.frame_tree_node_id != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeLatencyInfo2Wire.FRAME_TREE_NODE_ID_WIRE) + gremlin.sizes.sizeI32(self.frame_tree_node_id);
        }
        if (self.component_info) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ChromeLatencyInfo2Wire.COMPONENT_INFO_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.is_coalesced != false) {
            res += gremlin.sizes.sizeWireNumber(ChromeLatencyInfo2Wire.IS_COALESCED_WIRE) + gremlin.sizes.sizeBool(self.is_coalesced);
        }
        if (self.gesture_scroll_id != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeLatencyInfo2Wire.GESTURE_SCROLL_ID_WIRE) + gremlin.sizes.sizeI64(self.gesture_scroll_id);
        }
        if (self.touch_id != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeLatencyInfo2Wire.TOUCH_ID_WIRE) + gremlin.sizes.sizeI64(self.touch_id);
        }
        if (@intFromEnum(self.input_type) != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeLatencyInfo2Wire.INPUT_TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.input_type));
        }
        if (@intFromEnum(self.input_result_state) != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeLatencyInfo2Wire.INPUT_RESULT_STATE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.input_result_state));
        }
        if (self.coalesced_trace_ids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(ChromeLatencyInfo2Wire.COALESCED_TRACE_IDS_WIRE) + gremlin.sizes.sizeI64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI64(v);
                }
                res += gremlin.sizes.sizeWireNumber(ChromeLatencyInfo2Wire.COALESCED_TRACE_IDS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        return res;
    }
    pub fn encode(self: *const ChromeLatencyInfo2, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ChromeLatencyInfo2, target: *gremlin.Writer) void {
        if (self.trace_id != 0) {
            target.appendInt64(ChromeLatencyInfo2Wire.TRACE_ID_WIRE, self.trace_id);
        }
        if (@intFromEnum(self.step) != 0) {
            target.appendInt32(ChromeLatencyInfo2Wire.STEP_WIRE, @intFromEnum(self.step));
        }
        if (self.frame_tree_node_id != 0) {
            target.appendInt32(ChromeLatencyInfo2Wire.FRAME_TREE_NODE_ID_WIRE, self.frame_tree_node_id);
        }
        if (self.component_info) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(ChromeLatencyInfo2Wire.COMPONENT_INFO_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(ChromeLatencyInfo2Wire.COMPONENT_INFO_WIRE, 0);
                }
            }
        }
        if (self.is_coalesced != false) {
            target.appendBool(ChromeLatencyInfo2Wire.IS_COALESCED_WIRE, self.is_coalesced);
        }
        if (self.gesture_scroll_id != 0) {
            target.appendInt64(ChromeLatencyInfo2Wire.GESTURE_SCROLL_ID_WIRE, self.gesture_scroll_id);
        }
        if (self.touch_id != 0) {
            target.appendInt64(ChromeLatencyInfo2Wire.TOUCH_ID_WIRE, self.touch_id);
        }
        if (@intFromEnum(self.input_type) != 0) {
            target.appendInt32(ChromeLatencyInfo2Wire.INPUT_TYPE_WIRE, @intFromEnum(self.input_type));
        }
        if (@intFromEnum(self.input_result_state) != 0) {
            target.appendInt32(ChromeLatencyInfo2Wire.INPUT_RESULT_STATE_WIRE, @intFromEnum(self.input_result_state));
        }
        if (self.coalesced_trace_ids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt64(ChromeLatencyInfo2Wire.COALESCED_TRACE_IDS_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI64(v);
                }
                target.appendBytesTag(ChromeLatencyInfo2Wire.COALESCED_TRACE_IDS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt64WithoutTag(v);
                }
            }
        }
    }
};
pub const ChromeLatencyInfo2Reader = struct {
    buf: gremlin.Reader,
    _trace_id: i64 = 0,
    _step: ChromeLatencyInfo2.Step = @enumFromInt(0),
    _frame_tree_node_id: i32 = 0,
    _component_info_offset: ?usize = null,
    _component_info_last_offset: ?usize = null,
    _component_info_cnt: usize = 0,
    _is_coalesced: bool = false,
    _gesture_scroll_id: i64 = 0,
    _touch_id: i64 = 0,
    _input_type: ChromeLatencyInfo2.InputType = @enumFromInt(0),
    _input_result_state: ChromeLatencyInfo2.InputResultState = @enumFromInt(0),
    _coalesced_trace_ids_offset: ?usize = null,
    _coalesced_trace_ids_last_offset: ?usize = null,
    _coalesced_trace_ids_packed: bool = false,
    pub fn init(src: []const u8) gremlin.Error!ChromeLatencyInfo2Reader {
        const buf = gremlin.Reader.init(src);
        var res = ChromeLatencyInfo2Reader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ChromeLatencyInfo2Wire.TRACE_ID_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._trace_id = result.value;
                },
                ChromeLatencyInfo2Wire.STEP_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._step = @enumFromInt(result.value);
                },
                ChromeLatencyInfo2Wire.FRAME_TREE_NODE_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._frame_tree_node_id = result.value;
                },
                ChromeLatencyInfo2Wire.COMPONENT_INFO_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._component_info_offset == null) {
                        res._component_info_offset = offset - result.size;
                    }
                    res._component_info_last_offset = offset;
                    res._component_info_cnt += 1;
                },
                ChromeLatencyInfo2Wire.IS_COALESCED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_coalesced = result.value;
                },
                ChromeLatencyInfo2Wire.GESTURE_SCROLL_ID_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._gesture_scroll_id = result.value;
                },
                ChromeLatencyInfo2Wire.TOUCH_ID_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._touch_id = result.value;
                },
                ChromeLatencyInfo2Wire.INPUT_TYPE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._input_type = @enumFromInt(result.value);
                },
                ChromeLatencyInfo2Wire.INPUT_RESULT_STATE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._input_result_state = @enumFromInt(result.value);
                },
                ChromeLatencyInfo2Wire.COALESCED_TRACE_IDS_WIRE => {
                    if (res._coalesced_trace_ids_offset == null) {
                        res._coalesced_trace_ids_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._coalesced_trace_ids_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._coalesced_trace_ids_offset = offset + length_result.size;
                        res._coalesced_trace_ids_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._coalesced_trace_ids_last_offset.?;
                    } else {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._coalesced_trace_ids_last_offset = offset;
                    }
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getTraceId(self: *const ChromeLatencyInfo2Reader) i64 {
        return self._trace_id;
    }
    pub inline fn getStep(self: *const ChromeLatencyInfo2Reader) ChromeLatencyInfo2.Step {
        return self._step;
    }
    pub inline fn getFrameTreeNodeId(self: *const ChromeLatencyInfo2Reader) i32 {
        return self._frame_tree_node_id;
    }
    pub fn componentInfoCount(self: *const ChromeLatencyInfo2Reader) usize {
        return self._component_info_cnt;
    }
    pub fn componentInfoNext(self: *ChromeLatencyInfo2Reader) ?ChromeLatencyInfo2.ComponentInfoReader {
        if (self._component_info_offset == null) return null;
        const current_offset = self._component_info_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = ChromeLatencyInfo2.ComponentInfoReader.init(result.value) catch return null;
        if (self._component_info_last_offset != null and current_offset >= self._component_info_last_offset.?) {
            self._component_info_offset = null;
            return msg;
        }
        if (self._component_info_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._component_info_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ChromeLatencyInfo2Wire.COMPONENT_INFO_WIRE) {
                self._component_info_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._component_info_offset = null;
        return msg;
    }
    pub inline fn getIsCoalesced(self: *const ChromeLatencyInfo2Reader) bool {
        return self._is_coalesced;
    }
    pub inline fn getGestureScrollId(self: *const ChromeLatencyInfo2Reader) i64 {
        return self._gesture_scroll_id;
    }
    pub inline fn getTouchId(self: *const ChromeLatencyInfo2Reader) i64 {
        return self._touch_id;
    }
    pub inline fn getInputType(self: *const ChromeLatencyInfo2Reader) ChromeLatencyInfo2.InputType {
        return self._input_type;
    }
    pub inline fn getInputResultState(self: *const ChromeLatencyInfo2Reader) ChromeLatencyInfo2.InputResultState {
        return self._input_result_state;
    }
    pub fn coalescedTraceIdsNext(self: *ChromeLatencyInfo2Reader) gremlin.Error!?i64 {
        if (self._coalesced_trace_ids_offset == null) return null;
        const current_offset = self._coalesced_trace_ids_offset.?;
        if (current_offset >= self._coalesced_trace_ids_last_offset.?) {
            self._coalesced_trace_ids_offset = null;
            return null;
        }
        if (self._coalesced_trace_ids_packed) {
            const value_result = try self.buf.readInt64(current_offset);
            self._coalesced_trace_ids_offset = current_offset + value_result.size;
            if (self._coalesced_trace_ids_offset.? >= self._coalesced_trace_ids_last_offset.?) {
                self._coalesced_trace_ids_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._coalesced_trace_ids_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == ChromeLatencyInfo2Wire.COALESCED_TRACE_IDS_WIRE) {
                    self._coalesced_trace_ids_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._coalesced_trace_ids_offset = null;
            return value_result.value;
        }
    }
};
const EventTimingWire = struct {
    const CANCELABLE_WIRE: gremlin.ProtoWireNumber = 1;
    const FRAME_WIRE: gremlin.ProtoWireNumber = 2;
    const INTERACTION_ID_WIRE: gremlin.ProtoWireNumber = 3;
    const INTERACTION_OFFSET_WIRE: gremlin.ProtoWireNumber = 4;
    const NODE_ID_WIRE: gremlin.ProtoWireNumber = 5;
    const KEY_CODE_WIRE: gremlin.ProtoWireNumber = 6;
    const POINTER_ID_WIRE: gremlin.ProtoWireNumber = 7;
    const FALLBACK_TIME_US_WIRE: gremlin.ProtoWireNumber = 8;
    const TYPE_WIRE: gremlin.ProtoWireNumber = 9;
};
pub const EventTiming = struct {
    // nested enums
    pub const EventType = enum(i32) {
        UNDEFINED = 0,
        AUX_CLICK_EVENT = 1,
        CLICK_EVENT = 2,
        CONTEXT_MENU_EVENT = 3,
        DOUBLE_CLICK_EVENT = 4,
        MOUSE_DOWN_EVENT = 5,
        MOUSE_ENTER_EVENT = 6,
        MOUSE_LEAVE_EVENT = 7,
        MOUSE_OUT_EVENT = 9,
        MOUSE_OVER_EVENT = 10,
        MOUSE_UP_EVENT = 11,
        POINTER_OVER_EVENT = 12,
        POINTER_ENTER_EVENT = 13,
        POINTER_DOWN_EVENT = 14,
        POINTER_UP_EVENT = 15,
        POINTER_CANCEL_EVENT = 16,
        POINTER_OUT_EVENT = 17,
        POINTER_LEAVE_EVENT = 18,
        GOT_POINTER_CAPTURE_EVENT = 19,
        LOST_POINTER_CAPTURE_EVENT = 20,
        TOUCH_START_EVENT = 21,
        TOUCH_END_EVENT = 22,
        TOUCH_CANCEL_EVENT = 23,
        KEY_DOWN_EVENT = 24,
        KEY_PRESS_EVENT = 25,
        KEY_UP_EVENT = 26,
        BEFORE_INPUT_EVENT = 27,
        INPUT_EVENT = 28,
        COMPOSITION_START_EVENT = 29,
        COMPOSITION_UPDATE_EVENT = 30,
        COMPOSITION_END_EVENT = 31,
        DRAG_START_EVENT = 32,
        DRAG_END_EVENT = 33,
        DRAG_ENTER_EVENT = 34,
        DRAG_LEAVE_EVENT = 35,
        DRAG_OVER_EVENT = 36,
        DROP_EVENT = 37,
    };
    // fields
    cancelable: bool = false,
    frame: ?[]const u8 = null,
    interaction_id: u32 = 0,
    interaction_offset: u32 = 0,
    node_id: i64 = 0,
    key_code: i64 = 0,
    pointer_id: i32 = 0,
    fallback_time_us: u64 = 0,
    type: EventTiming.EventType = @enumFromInt(0),
    pub fn calcProtobufSize(self: *const EventTiming) usize {
        var res: usize = 0;
        if (self.cancelable != false) {
            res += gremlin.sizes.sizeWireNumber(EventTimingWire.CANCELABLE_WIRE) + gremlin.sizes.sizeBool(self.cancelable);
        }
        if (self.frame) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(EventTimingWire.FRAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.interaction_id != 0) {
            res += gremlin.sizes.sizeWireNumber(EventTimingWire.INTERACTION_ID_WIRE) + gremlin.sizes.sizeU32(self.interaction_id);
        }
        if (self.interaction_offset != 0) {
            res += gremlin.sizes.sizeWireNumber(EventTimingWire.INTERACTION_OFFSET_WIRE) + gremlin.sizes.sizeU32(self.interaction_offset);
        }
        if (self.node_id != 0) {
            res += gremlin.sizes.sizeWireNumber(EventTimingWire.NODE_ID_WIRE) + gremlin.sizes.sizeI64(self.node_id);
        }
        if (self.key_code != 0) {
            res += gremlin.sizes.sizeWireNumber(EventTimingWire.KEY_CODE_WIRE) + gremlin.sizes.sizeI64(self.key_code);
        }
        if (self.pointer_id != 0) {
            res += gremlin.sizes.sizeWireNumber(EventTimingWire.POINTER_ID_WIRE) + gremlin.sizes.sizeI32(self.pointer_id);
        }
        if (self.fallback_time_us != 0) {
            res += gremlin.sizes.sizeWireNumber(EventTimingWire.FALLBACK_TIME_US_WIRE) + gremlin.sizes.sizeU64(self.fallback_time_us);
        }
        if (@intFromEnum(self.type) != 0) {
            res += gremlin.sizes.sizeWireNumber(EventTimingWire.TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.type));
        }
        return res;
    }
    pub fn encode(self: *const EventTiming, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const EventTiming, target: *gremlin.Writer) void {
        if (self.cancelable != false) {
            target.appendBool(EventTimingWire.CANCELABLE_WIRE, self.cancelable);
        }
        if (self.frame) |v| {
            if (v.len > 0) {
                target.appendBytes(EventTimingWire.FRAME_WIRE, v);
            }
        }
        if (self.interaction_id != 0) {
            target.appendUint32(EventTimingWire.INTERACTION_ID_WIRE, self.interaction_id);
        }
        if (self.interaction_offset != 0) {
            target.appendUint32(EventTimingWire.INTERACTION_OFFSET_WIRE, self.interaction_offset);
        }
        if (self.node_id != 0) {
            target.appendInt64(EventTimingWire.NODE_ID_WIRE, self.node_id);
        }
        if (self.key_code != 0) {
            target.appendInt64(EventTimingWire.KEY_CODE_WIRE, self.key_code);
        }
        if (self.pointer_id != 0) {
            target.appendInt32(EventTimingWire.POINTER_ID_WIRE, self.pointer_id);
        }
        if (self.fallback_time_us != 0) {
            target.appendUint64(EventTimingWire.FALLBACK_TIME_US_WIRE, self.fallback_time_us);
        }
        if (@intFromEnum(self.type) != 0) {
            target.appendInt32(EventTimingWire.TYPE_WIRE, @intFromEnum(self.type));
        }
    }
};
pub const EventTimingReader = struct {
    buf: gremlin.Reader,
    _cancelable: bool = false,
    _frame: ?[]const u8 = null,
    _interaction_id: u32 = 0,
    _interaction_offset: u32 = 0,
    _node_id: i64 = 0,
    _key_code: i64 = 0,
    _pointer_id: i32 = 0,
    _fallback_time_us: u64 = 0,
    _type: EventTiming.EventType = @enumFromInt(0),
    pub fn init(src: []const u8) gremlin.Error!EventTimingReader {
        const buf = gremlin.Reader.init(src);
        var res = EventTimingReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                EventTimingWire.CANCELABLE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._cancelable = result.value;
                },
                EventTimingWire.FRAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._frame = result.value;
                },
                EventTimingWire.INTERACTION_ID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._interaction_id = result.value;
                },
                EventTimingWire.INTERACTION_OFFSET_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._interaction_offset = result.value;
                },
                EventTimingWire.NODE_ID_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._node_id = result.value;
                },
                EventTimingWire.KEY_CODE_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._key_code = result.value;
                },
                EventTimingWire.POINTER_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._pointer_id = result.value;
                },
                EventTimingWire.FALLBACK_TIME_US_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._fallback_time_us = result.value;
                },
                EventTimingWire.TYPE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._type = @enumFromInt(result.value);
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getCancelable(self: *const EventTimingReader) bool {
        return self._cancelable;
    }
    pub inline fn getFrame(self: *const EventTimingReader) []const u8 {
        return self._frame orelse &[_]u8{};
    }
    pub inline fn getInteractionId(self: *const EventTimingReader) u32 {
        return self._interaction_id;
    }
    pub inline fn getInteractionOffset(self: *const EventTimingReader) u32 {
        return self._interaction_offset;
    }
    pub inline fn getNodeId(self: *const EventTimingReader) i64 {
        return self._node_id;
    }
    pub inline fn getKeyCode(self: *const EventTimingReader) i64 {
        return self._key_code;
    }
    pub inline fn getPointerId(self: *const EventTimingReader) i32 {
        return self._pointer_id;
    }
    pub inline fn getFallbackTimeUs(self: *const EventTimingReader) u64 {
        return self._fallback_time_us;
    }
    pub inline fn getType(self: *const EventTimingReader) EventTiming.EventType {
        return self._type;
    }
};
const AndroidChoreographerFrameCallbackDataWire = struct {
    const FRAME_TIME_US_WIRE: gremlin.ProtoWireNumber = 1;
    const FRAME_TIMELINE_WIRE: gremlin.ProtoWireNumber = 2;
    const PREFERRED_FRAME_TIMELINE_INDEX_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const AndroidChoreographerFrameCallbackData = struct {
    // nested structs
    const FrameTimelineWire = struct {
        const VSYNC_ID_WIRE: gremlin.ProtoWireNumber = 1;
        const LATCH_DELTA_US_WIRE: gremlin.ProtoWireNumber = 2;
        const PRESENT_DELTA_US_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const FrameTimeline = struct {
        // fields
        vsync_id: i64 = 0,
        latch_delta_us: i64 = 0,
        present_delta_us: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidChoreographerFrameCallbackData.FrameTimeline) usize {
            var res: usize = 0;
            if (self.vsync_id != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidChoreographerFrameCallbackData.FrameTimelineWire.VSYNC_ID_WIRE) + gremlin.sizes.sizeI64(self.vsync_id);
            }
            if (self.latch_delta_us != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidChoreographerFrameCallbackData.FrameTimelineWire.LATCH_DELTA_US_WIRE) + gremlin.sizes.sizeI64(self.latch_delta_us);
            }
            if (self.present_delta_us != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidChoreographerFrameCallbackData.FrameTimelineWire.PRESENT_DELTA_US_WIRE) + gremlin.sizes.sizeI64(self.present_delta_us);
            }
            return res;
        }
        pub fn encode(self: *const AndroidChoreographerFrameCallbackData.FrameTimeline, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidChoreographerFrameCallbackData.FrameTimeline, target: *gremlin.Writer) void {
            if (self.vsync_id != 0) {
                target.appendInt64(AndroidChoreographerFrameCallbackData.FrameTimelineWire.VSYNC_ID_WIRE, self.vsync_id);
            }
            if (self.latch_delta_us != 0) {
                target.appendInt64(AndroidChoreographerFrameCallbackData.FrameTimelineWire.LATCH_DELTA_US_WIRE, self.latch_delta_us);
            }
            if (self.present_delta_us != 0) {
                target.appendInt64(AndroidChoreographerFrameCallbackData.FrameTimelineWire.PRESENT_DELTA_US_WIRE, self.present_delta_us);
            }
        }
    };
    pub const FrameTimelineReader = struct {
        buf: gremlin.Reader,
        _vsync_id: i64 = 0,
        _latch_delta_us: i64 = 0,
        _present_delta_us: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidChoreographerFrameCallbackData.FrameTimelineReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidChoreographerFrameCallbackData.FrameTimelineReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidChoreographerFrameCallbackData.FrameTimelineWire.VSYNC_ID_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._vsync_id = result.value;
                    },
                    AndroidChoreographerFrameCallbackData.FrameTimelineWire.LATCH_DELTA_US_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._latch_delta_us = result.value;
                    },
                    AndroidChoreographerFrameCallbackData.FrameTimelineWire.PRESENT_DELTA_US_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._present_delta_us = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getVsyncId(self: *const AndroidChoreographerFrameCallbackData.FrameTimelineReader) i64 {
            return self._vsync_id;
        }
        pub inline fn getLatchDeltaUs(self: *const AndroidChoreographerFrameCallbackData.FrameTimelineReader) i64 {
            return self._latch_delta_us;
        }
        pub inline fn getPresentDeltaUs(self: *const AndroidChoreographerFrameCallbackData.FrameTimelineReader) i64 {
            return self._present_delta_us;
        }
    };
    // fields
    frame_time_us: i64 = 0,
    frame_timeline: ?[]const ?AndroidChoreographerFrameCallbackData.FrameTimeline = null,
    preferred_frame_timeline_index: i64 = 0,
    pub fn calcProtobufSize(self: *const AndroidChoreographerFrameCallbackData) usize {
        var res: usize = 0;
        if (self.frame_time_us != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidChoreographerFrameCallbackDataWire.FRAME_TIME_US_WIRE) + gremlin.sizes.sizeI64(self.frame_time_us);
        }
        if (self.frame_timeline) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidChoreographerFrameCallbackDataWire.FRAME_TIMELINE_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.preferred_frame_timeline_index != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidChoreographerFrameCallbackDataWire.PREFERRED_FRAME_TIMELINE_INDEX_WIRE) + gremlin.sizes.sizeI64(self.preferred_frame_timeline_index);
        }
        return res;
    }
    pub fn encode(self: *const AndroidChoreographerFrameCallbackData, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidChoreographerFrameCallbackData, target: *gremlin.Writer) void {
        if (self.frame_time_us != 0) {
            target.appendInt64(AndroidChoreographerFrameCallbackDataWire.FRAME_TIME_US_WIRE, self.frame_time_us);
        }
        if (self.frame_timeline) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidChoreographerFrameCallbackDataWire.FRAME_TIMELINE_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidChoreographerFrameCallbackDataWire.FRAME_TIMELINE_WIRE, 0);
                }
            }
        }
        if (self.preferred_frame_timeline_index != 0) {
            target.appendInt64(AndroidChoreographerFrameCallbackDataWire.PREFERRED_FRAME_TIMELINE_INDEX_WIRE, self.preferred_frame_timeline_index);
        }
    }
};
pub const AndroidChoreographerFrameCallbackDataReader = struct {
    buf: gremlin.Reader,
    _frame_time_us: i64 = 0,
    _frame_timeline_offset: ?usize = null,
    _frame_timeline_last_offset: ?usize = null,
    _frame_timeline_cnt: usize = 0,
    _preferred_frame_timeline_index: i64 = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidChoreographerFrameCallbackDataReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidChoreographerFrameCallbackDataReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidChoreographerFrameCallbackDataWire.FRAME_TIME_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._frame_time_us = result.value;
                },
                AndroidChoreographerFrameCallbackDataWire.FRAME_TIMELINE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._frame_timeline_offset == null) {
                        res._frame_timeline_offset = offset - result.size;
                    }
                    res._frame_timeline_last_offset = offset;
                    res._frame_timeline_cnt += 1;
                },
                AndroidChoreographerFrameCallbackDataWire.PREFERRED_FRAME_TIMELINE_INDEX_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._preferred_frame_timeline_index = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getFrameTimeUs(self: *const AndroidChoreographerFrameCallbackDataReader) i64 {
        return self._frame_time_us;
    }
    pub fn frameTimelineCount(self: *const AndroidChoreographerFrameCallbackDataReader) usize {
        return self._frame_timeline_cnt;
    }
    pub fn frameTimelineNext(self: *AndroidChoreographerFrameCallbackDataReader) ?AndroidChoreographerFrameCallbackData.FrameTimelineReader {
        if (self._frame_timeline_offset == null) return null;
        const current_offset = self._frame_timeline_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidChoreographerFrameCallbackData.FrameTimelineReader.init(result.value) catch return null;
        if (self._frame_timeline_last_offset != null and current_offset >= self._frame_timeline_last_offset.?) {
            self._frame_timeline_offset = null;
            return msg;
        }
        if (self._frame_timeline_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._frame_timeline_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidChoreographerFrameCallbackDataWire.FRAME_TIMELINE_WIRE) {
                self._frame_timeline_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._frame_timeline_offset = null;
        return msg;
    }
    pub inline fn getPreferredFrameTimelineIndex(self: *const AndroidChoreographerFrameCallbackDataReader) i64 {
        return self._preferred_frame_timeline_index;
    }
};
const ChromeFrameReporter2Wire = struct {
    const STATE_WIRE: gremlin.ProtoWireNumber = 1;
    const REASON_WIRE: gremlin.ProtoWireNumber = 2;
    const FRAME_SOURCE_WIRE: gremlin.ProtoWireNumber = 3;
    const FRAME_SEQUENCE_WIRE: gremlin.ProtoWireNumber = 4;
    const AFFECTS_SMOOTHNESS_WIRE: gremlin.ProtoWireNumber = 5;
    const SCROLL_STATE_WIRE: gremlin.ProtoWireNumber = 6;
    const HAS_MAIN_ANIMATION_WIRE: gremlin.ProtoWireNumber = 7;
    const HAS_COMPOSITOR_ANIMATION_WIRE: gremlin.ProtoWireNumber = 8;
    const HAS_SMOOTH_INPUT_MAIN_WIRE: gremlin.ProtoWireNumber = 9;
    const HAS_MISSING_CONTENT_WIRE: gremlin.ProtoWireNumber = 10;
    const LAYER_TREE_HOST_ID_WIRE: gremlin.ProtoWireNumber = 11;
    const HAS_HIGH_LATENCY_WIRE: gremlin.ProtoWireNumber = 12;
    const FRAME_TYPE_WIRE: gremlin.ProtoWireNumber = 13;
    const HIGH_LATENCY_CONTRIBUTION_STAGE_WIRE: gremlin.ProtoWireNumber = 14;
    const CHECKERBOARDED_NEEDS_RASTER_WIRE: gremlin.ProtoWireNumber = 15;
    const CHECKERBOARDED_NEEDS_RECORD_WIRE: gremlin.ProtoWireNumber = 16;
    const SURFACE_FRAME_TRACE_ID_WIRE: gremlin.ProtoWireNumber = 17;
    const DISPLAY_TRACE_ID_WIRE: gremlin.ProtoWireNumber = 18;
};
pub const ChromeFrameReporter2 = struct {
    // nested enums
    pub const State = enum(i32) {
        STATE_NO_UPDATE_DESIRED = 0,
        STATE_PRESENTED_ALL = 1,
        STATE_PRESENTED_PARTIAL = 2,
        STATE_DROPPED = 3,
    };
    pub const FrameDropReason = enum(i32) {
        REASON_UNSPECIFIED = 0,
        REASON_DISPLAY_COMPOSITOR = 1,
        REASON_MAIN_THREAD = 2,
        REASON_CLIENT_COMPOSITOR = 3,
    };
    pub const ScrollState = enum(i32) {
        SCROLL_NONE = 0,
        SCROLL_MAIN_THREAD = 1,
        SCROLL_COMPOSITOR_THREAD = 2,
        SCROLL_RASTER = 3,
        SCROLL_UNKNOWN = 4,
    };
    pub const FrameType = enum(i32) {
        FORKED = 0,
        BACKFILL = 1,
    };
    // fields
    state: ChromeFrameReporter2.State = @enumFromInt(0),
    reason: ChromeFrameReporter2.FrameDropReason = @enumFromInt(0),
    frame_source: u64 = 0,
    frame_sequence: u64 = 0,
    affects_smoothness: bool = false,
    scroll_state: ChromeFrameReporter2.ScrollState = @enumFromInt(0),
    has_main_animation: bool = false,
    has_compositor_animation: bool = false,
    has_smooth_input_main: bool = false,
    has_missing_content: bool = false,
    layer_tree_host_id: u64 = 0,
    has_high_latency: bool = false,
    frame_type: ChromeFrameReporter2.FrameType = @enumFromInt(0),
    high_latency_contribution_stage: ?[]const ?[]const u8 = null,
    checkerboarded_needs_raster: bool = false,
    checkerboarded_needs_record: bool = false,
    surface_frame_trace_id: i64 = 0,
    display_trace_id: i64 = 0,
    pub fn calcProtobufSize(self: *const ChromeFrameReporter2) usize {
        var res: usize = 0;
        if (@intFromEnum(self.state) != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeFrameReporter2Wire.STATE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.state));
        }
        if (@intFromEnum(self.reason) != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeFrameReporter2Wire.REASON_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.reason));
        }
        if (self.frame_source != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeFrameReporter2Wire.FRAME_SOURCE_WIRE) + gremlin.sizes.sizeU64(self.frame_source);
        }
        if (self.frame_sequence != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeFrameReporter2Wire.FRAME_SEQUENCE_WIRE) + gremlin.sizes.sizeU64(self.frame_sequence);
        }
        if (self.affects_smoothness != false) {
            res += gremlin.sizes.sizeWireNumber(ChromeFrameReporter2Wire.AFFECTS_SMOOTHNESS_WIRE) + gremlin.sizes.sizeBool(self.affects_smoothness);
        }
        if (@intFromEnum(self.scroll_state) != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeFrameReporter2Wire.SCROLL_STATE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.scroll_state));
        }
        if (self.has_main_animation != false) {
            res += gremlin.sizes.sizeWireNumber(ChromeFrameReporter2Wire.HAS_MAIN_ANIMATION_WIRE) + gremlin.sizes.sizeBool(self.has_main_animation);
        }
        if (self.has_compositor_animation != false) {
            res += gremlin.sizes.sizeWireNumber(ChromeFrameReporter2Wire.HAS_COMPOSITOR_ANIMATION_WIRE) + gremlin.sizes.sizeBool(self.has_compositor_animation);
        }
        if (self.has_smooth_input_main != false) {
            res += gremlin.sizes.sizeWireNumber(ChromeFrameReporter2Wire.HAS_SMOOTH_INPUT_MAIN_WIRE) + gremlin.sizes.sizeBool(self.has_smooth_input_main);
        }
        if (self.has_missing_content != false) {
            res += gremlin.sizes.sizeWireNumber(ChromeFrameReporter2Wire.HAS_MISSING_CONTENT_WIRE) + gremlin.sizes.sizeBool(self.has_missing_content);
        }
        if (self.layer_tree_host_id != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeFrameReporter2Wire.LAYER_TREE_HOST_ID_WIRE) + gremlin.sizes.sizeU64(self.layer_tree_host_id);
        }
        if (self.has_high_latency != false) {
            res += gremlin.sizes.sizeWireNumber(ChromeFrameReporter2Wire.HAS_HIGH_LATENCY_WIRE) + gremlin.sizes.sizeBool(self.has_high_latency);
        }
        if (@intFromEnum(self.frame_type) != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeFrameReporter2Wire.FRAME_TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.frame_type));
        }
        if (self.high_latency_contribution_stage) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ChromeFrameReporter2Wire.HIGH_LATENCY_CONTRIBUTION_STAGE_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.checkerboarded_needs_raster != false) {
            res += gremlin.sizes.sizeWireNumber(ChromeFrameReporter2Wire.CHECKERBOARDED_NEEDS_RASTER_WIRE) + gremlin.sizes.sizeBool(self.checkerboarded_needs_raster);
        }
        if (self.checkerboarded_needs_record != false) {
            res += gremlin.sizes.sizeWireNumber(ChromeFrameReporter2Wire.CHECKERBOARDED_NEEDS_RECORD_WIRE) + gremlin.sizes.sizeBool(self.checkerboarded_needs_record);
        }
        if (self.surface_frame_trace_id != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeFrameReporter2Wire.SURFACE_FRAME_TRACE_ID_WIRE) + gremlin.sizes.sizeI64(self.surface_frame_trace_id);
        }
        if (self.display_trace_id != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeFrameReporter2Wire.DISPLAY_TRACE_ID_WIRE) + gremlin.sizes.sizeI64(self.display_trace_id);
        }
        return res;
    }
    pub fn encode(self: *const ChromeFrameReporter2, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ChromeFrameReporter2, target: *gremlin.Writer) void {
        if (@intFromEnum(self.state) != 0) {
            target.appendInt32(ChromeFrameReporter2Wire.STATE_WIRE, @intFromEnum(self.state));
        }
        if (@intFromEnum(self.reason) != 0) {
            target.appendInt32(ChromeFrameReporter2Wire.REASON_WIRE, @intFromEnum(self.reason));
        }
        if (self.frame_source != 0) {
            target.appendUint64(ChromeFrameReporter2Wire.FRAME_SOURCE_WIRE, self.frame_source);
        }
        if (self.frame_sequence != 0) {
            target.appendUint64(ChromeFrameReporter2Wire.FRAME_SEQUENCE_WIRE, self.frame_sequence);
        }
        if (self.affects_smoothness != false) {
            target.appendBool(ChromeFrameReporter2Wire.AFFECTS_SMOOTHNESS_WIRE, self.affects_smoothness);
        }
        if (@intFromEnum(self.scroll_state) != 0) {
            target.appendInt32(ChromeFrameReporter2Wire.SCROLL_STATE_WIRE, @intFromEnum(self.scroll_state));
        }
        if (self.has_main_animation != false) {
            target.appendBool(ChromeFrameReporter2Wire.HAS_MAIN_ANIMATION_WIRE, self.has_main_animation);
        }
        if (self.has_compositor_animation != false) {
            target.appendBool(ChromeFrameReporter2Wire.HAS_COMPOSITOR_ANIMATION_WIRE, self.has_compositor_animation);
        }
        if (self.has_smooth_input_main != false) {
            target.appendBool(ChromeFrameReporter2Wire.HAS_SMOOTH_INPUT_MAIN_WIRE, self.has_smooth_input_main);
        }
        if (self.has_missing_content != false) {
            target.appendBool(ChromeFrameReporter2Wire.HAS_MISSING_CONTENT_WIRE, self.has_missing_content);
        }
        if (self.layer_tree_host_id != 0) {
            target.appendUint64(ChromeFrameReporter2Wire.LAYER_TREE_HOST_ID_WIRE, self.layer_tree_host_id);
        }
        if (self.has_high_latency != false) {
            target.appendBool(ChromeFrameReporter2Wire.HAS_HIGH_LATENCY_WIRE, self.has_high_latency);
        }
        if (@intFromEnum(self.frame_type) != 0) {
            target.appendInt32(ChromeFrameReporter2Wire.FRAME_TYPE_WIRE, @intFromEnum(self.frame_type));
        }
        if (self.high_latency_contribution_stage) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(ChromeFrameReporter2Wire.HIGH_LATENCY_CONTRIBUTION_STAGE_WIRE, v);
                } else {
                    target.appendBytesTag(ChromeFrameReporter2Wire.HIGH_LATENCY_CONTRIBUTION_STAGE_WIRE, 0);
                }
            }
        }
        if (self.checkerboarded_needs_raster != false) {
            target.appendBool(ChromeFrameReporter2Wire.CHECKERBOARDED_NEEDS_RASTER_WIRE, self.checkerboarded_needs_raster);
        }
        if (self.checkerboarded_needs_record != false) {
            target.appendBool(ChromeFrameReporter2Wire.CHECKERBOARDED_NEEDS_RECORD_WIRE, self.checkerboarded_needs_record);
        }
        if (self.surface_frame_trace_id != 0) {
            target.appendInt64(ChromeFrameReporter2Wire.SURFACE_FRAME_TRACE_ID_WIRE, self.surface_frame_trace_id);
        }
        if (self.display_trace_id != 0) {
            target.appendInt64(ChromeFrameReporter2Wire.DISPLAY_TRACE_ID_WIRE, self.display_trace_id);
        }
    }
};
pub const ChromeFrameReporter2Reader = struct {
    buf: gremlin.Reader,
    _state: ChromeFrameReporter2.State = @enumFromInt(0),
    _reason: ChromeFrameReporter2.FrameDropReason = @enumFromInt(0),
    _frame_source: u64 = 0,
    _frame_sequence: u64 = 0,
    _affects_smoothness: bool = false,
    _scroll_state: ChromeFrameReporter2.ScrollState = @enumFromInt(0),
    _has_main_animation: bool = false,
    _has_compositor_animation: bool = false,
    _has_smooth_input_main: bool = false,
    _has_missing_content: bool = false,
    _layer_tree_host_id: u64 = 0,
    _has_high_latency: bool = false,
    _frame_type: ChromeFrameReporter2.FrameType = @enumFromInt(0),
    _high_latency_contribution_stage_offset: ?usize = null,
    _high_latency_contribution_stage_last_offset: ?usize = null,
    _high_latency_contribution_stage_cnt: usize = 0,
    _checkerboarded_needs_raster: bool = false,
    _checkerboarded_needs_record: bool = false,
    _surface_frame_trace_id: i64 = 0,
    _display_trace_id: i64 = 0,
    pub fn init(src: []const u8) gremlin.Error!ChromeFrameReporter2Reader {
        const buf = gremlin.Reader.init(src);
        var res = ChromeFrameReporter2Reader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ChromeFrameReporter2Wire.STATE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._state = @enumFromInt(result.value);
                },
                ChromeFrameReporter2Wire.REASON_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._reason = @enumFromInt(result.value);
                },
                ChromeFrameReporter2Wire.FRAME_SOURCE_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._frame_source = result.value;
                },
                ChromeFrameReporter2Wire.FRAME_SEQUENCE_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._frame_sequence = result.value;
                },
                ChromeFrameReporter2Wire.AFFECTS_SMOOTHNESS_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._affects_smoothness = result.value;
                },
                ChromeFrameReporter2Wire.SCROLL_STATE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._scroll_state = @enumFromInt(result.value);
                },
                ChromeFrameReporter2Wire.HAS_MAIN_ANIMATION_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._has_main_animation = result.value;
                },
                ChromeFrameReporter2Wire.HAS_COMPOSITOR_ANIMATION_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._has_compositor_animation = result.value;
                },
                ChromeFrameReporter2Wire.HAS_SMOOTH_INPUT_MAIN_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._has_smooth_input_main = result.value;
                },
                ChromeFrameReporter2Wire.HAS_MISSING_CONTENT_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._has_missing_content = result.value;
                },
                ChromeFrameReporter2Wire.LAYER_TREE_HOST_ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._layer_tree_host_id = result.value;
                },
                ChromeFrameReporter2Wire.HAS_HIGH_LATENCY_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._has_high_latency = result.value;
                },
                ChromeFrameReporter2Wire.FRAME_TYPE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._frame_type = @enumFromInt(result.value);
                },
                ChromeFrameReporter2Wire.HIGH_LATENCY_CONTRIBUTION_STAGE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._high_latency_contribution_stage_offset == null) {
                        res._high_latency_contribution_stage_offset = offset - result.size;
                    }
                    res._high_latency_contribution_stage_last_offset = offset;
                    res._high_latency_contribution_stage_cnt += 1;
                },
                ChromeFrameReporter2Wire.CHECKERBOARDED_NEEDS_RASTER_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._checkerboarded_needs_raster = result.value;
                },
                ChromeFrameReporter2Wire.CHECKERBOARDED_NEEDS_RECORD_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._checkerboarded_needs_record = result.value;
                },
                ChromeFrameReporter2Wire.SURFACE_FRAME_TRACE_ID_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._surface_frame_trace_id = result.value;
                },
                ChromeFrameReporter2Wire.DISPLAY_TRACE_ID_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._display_trace_id = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getState(self: *const ChromeFrameReporter2Reader) ChromeFrameReporter2.State {
        return self._state;
    }
    pub inline fn getReason(self: *const ChromeFrameReporter2Reader) ChromeFrameReporter2.FrameDropReason {
        return self._reason;
    }
    pub inline fn getFrameSource(self: *const ChromeFrameReporter2Reader) u64 {
        return self._frame_source;
    }
    pub inline fn getFrameSequence(self: *const ChromeFrameReporter2Reader) u64 {
        return self._frame_sequence;
    }
    pub inline fn getAffectsSmoothness(self: *const ChromeFrameReporter2Reader) bool {
        return self._affects_smoothness;
    }
    pub inline fn getScrollState(self: *const ChromeFrameReporter2Reader) ChromeFrameReporter2.ScrollState {
        return self._scroll_state;
    }
    pub inline fn getHasMainAnimation(self: *const ChromeFrameReporter2Reader) bool {
        return self._has_main_animation;
    }
    pub inline fn getHasCompositorAnimation(self: *const ChromeFrameReporter2Reader) bool {
        return self._has_compositor_animation;
    }
    pub inline fn getHasSmoothInputMain(self: *const ChromeFrameReporter2Reader) bool {
        return self._has_smooth_input_main;
    }
    pub inline fn getHasMissingContent(self: *const ChromeFrameReporter2Reader) bool {
        return self._has_missing_content;
    }
    pub inline fn getLayerTreeHostId(self: *const ChromeFrameReporter2Reader) u64 {
        return self._layer_tree_host_id;
    }
    pub inline fn getHasHighLatency(self: *const ChromeFrameReporter2Reader) bool {
        return self._has_high_latency;
    }
    pub inline fn getFrameType(self: *const ChromeFrameReporter2Reader) ChromeFrameReporter2.FrameType {
        return self._frame_type;
    }
    pub fn highLatencyContributionStageCount(self: *const ChromeFrameReporter2Reader) usize {
        return self._high_latency_contribution_stage_cnt;
    }
    pub fn highLatencyContributionStageNext(self: *ChromeFrameReporter2Reader) ?[]const u8 {
        if (self._high_latency_contribution_stage_offset == null) return null;
        const current_offset = self._high_latency_contribution_stage_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._high_latency_contribution_stage_last_offset != null and current_offset >= self._high_latency_contribution_stage_last_offset.?) {
            self._high_latency_contribution_stage_offset = null;
            return result.value;
        }
        if (self._high_latency_contribution_stage_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._high_latency_contribution_stage_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ChromeFrameReporter2Wire.HIGH_LATENCY_CONTRIBUTION_STAGE_WIRE) {
                self._high_latency_contribution_stage_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._high_latency_contribution_stage_offset = null;
        return result.value;
    }
    pub inline fn getCheckerboardedNeedsRaster(self: *const ChromeFrameReporter2Reader) bool {
        return self._checkerboarded_needs_raster;
    }
    pub inline fn getCheckerboardedNeedsRecord(self: *const ChromeFrameReporter2Reader) bool {
        return self._checkerboarded_needs_record;
    }
    pub inline fn getSurfaceFrameTraceId(self: *const ChromeFrameReporter2Reader) i64 {
        return self._surface_frame_trace_id;
    }
    pub inline fn getDisplayTraceId(self: *const ChromeFrameReporter2Reader) i64 {
        return self._display_trace_id;
    }
};
const InputTransferHandlerWire = struct {
    const TRANSFER_RESULT_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const InputTransferHandler = struct {
    // nested enums
    pub const TransferInputToVizResult = enum(i32) {
        UNKNOWN = 0,
        SUCCESSFULLY_TRANSFERRED = 1,
        INPUT_TRANSFER_HANDLER_NOT_FOUND_IN_MAP = 2,
        NON_FINGER_TOOL_TYPE = 3,
        VIZ_INITIALIZATION_NOT_COMPLETE = 4,
        SELECTION_HANDLES_ACTIVE = 5,
        CAN_TRIGGER_BACK_GESTURE = 6,
        IME_IS_ACTIVE = 7,
        REQUESTED_BY_EMBEDDER = 8,
        SYSTEM_SERVER_DID_NOT_TRANSFER = 9,
        BROWSER_TOKEN_CHANGED = 10,
        MULTIPLE_BROWSER_WINDOWS_OPEN = 11,
        DOWN_TIME_AFTER_EVENT_TIME = 12,
        SEQUENCE_TRANSFERRED_BACK_FROM_VIZ = 13,
    };
    // fields
    transfer_result: InputTransferHandler.TransferInputToVizResult = @enumFromInt(0),
    pub fn calcProtobufSize(self: *const InputTransferHandler) usize {
        var res: usize = 0;
        if (@intFromEnum(self.transfer_result) != 0) {
            res += gremlin.sizes.sizeWireNumber(InputTransferHandlerWire.TRANSFER_RESULT_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.transfer_result));
        }
        return res;
    }
    pub fn encode(self: *const InputTransferHandler, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const InputTransferHandler, target: *gremlin.Writer) void {
        if (@intFromEnum(self.transfer_result) != 0) {
            target.appendInt32(InputTransferHandlerWire.TRANSFER_RESULT_WIRE, @intFromEnum(self.transfer_result));
        }
    }
};
pub const InputTransferHandlerReader = struct {
    buf: gremlin.Reader,
    _transfer_result: InputTransferHandler.TransferInputToVizResult = @enumFromInt(0),
    pub fn init(src: []const u8) gremlin.Error!InputTransferHandlerReader {
        const buf = gremlin.Reader.init(src);
        var res = InputTransferHandlerReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                InputTransferHandlerWire.TRANSFER_RESULT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._transfer_result = @enumFromInt(result.value);
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getTransferResult(self: *const InputTransferHandlerReader) InputTransferHandler.TransferInputToVizResult {
        return self._transfer_result;
    }
};
const ResponseInfoWire = struct {
    const RESPONSE_CODE_WIRE: gremlin.ProtoWireNumber = 1;
    const WAS_HTTP_CACHE_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const ResponseInfo = struct {
    // fields
    response_code: i64 = 0,
    was_http_cache: bool = false,
    pub fn calcProtobufSize(self: *const ResponseInfo) usize {
        var res: usize = 0;
        if (self.response_code != 0) {
            res += gremlin.sizes.sizeWireNumber(ResponseInfoWire.RESPONSE_CODE_WIRE) + gremlin.sizes.sizeI64(self.response_code);
        }
        if (self.was_http_cache != false) {
            res += gremlin.sizes.sizeWireNumber(ResponseInfoWire.WAS_HTTP_CACHE_WIRE) + gremlin.sizes.sizeBool(self.was_http_cache);
        }
        return res;
    }
    pub fn encode(self: *const ResponseInfo, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ResponseInfo, target: *gremlin.Writer) void {
        if (self.response_code != 0) {
            target.appendInt64(ResponseInfoWire.RESPONSE_CODE_WIRE, self.response_code);
        }
        if (self.was_http_cache != false) {
            target.appendBool(ResponseInfoWire.WAS_HTTP_CACHE_WIRE, self.was_http_cache);
        }
    }
};
pub const ResponseInfoReader = struct {
    buf: gremlin.Reader,
    _response_code: i64 = 0,
    _was_http_cache: bool = false,
    pub fn init(src: []const u8) gremlin.Error!ResponseInfoReader {
        const buf = gremlin.Reader.init(src);
        var res = ResponseInfoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ResponseInfoWire.RESPONSE_CODE_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._response_code = result.value;
                },
                ResponseInfoWire.WAS_HTTP_CACHE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._was_http_cache = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getResponseCode(self: *const ResponseInfoReader) i64 {
        return self._response_code;
    }
    pub inline fn getWasHttpCache(self: *const ResponseInfoReader) bool {
        return self._was_http_cache;
    }
};
const ChromeTrackEventWire = struct {
    const CATEGORY_IIDS_WIRE: gremlin.ProtoWireNumber = 3;
    const CATEGORIES_WIRE: gremlin.ProtoWireNumber = 22;
    const TYPE_WIRE: gremlin.ProtoWireNumber = 9;
    const TRACK_UUID_WIRE: gremlin.ProtoWireNumber = 11;
    const EXTRA_COUNTER_TRACK_UUIDS_WIRE: gremlin.ProtoWireNumber = 31;
    const EXTRA_COUNTER_VALUES_WIRE: gremlin.ProtoWireNumber = 12;
    const EXTRA_DOUBLE_COUNTER_TRACK_UUIDS_WIRE: gremlin.ProtoWireNumber = 45;
    const EXTRA_DOUBLE_COUNTER_VALUES_WIRE: gremlin.ProtoWireNumber = 46;
    const FLOW_IDS_OLD_WIRE: gremlin.ProtoWireNumber = 36;
    const FLOW_IDS_WIRE: gremlin.ProtoWireNumber = 47;
    const TERMINATING_FLOW_IDS_OLD_WIRE: gremlin.ProtoWireNumber = 42;
    const TERMINATING_FLOW_IDS_WIRE: gremlin.ProtoWireNumber = 48;
    const DEBUG_ANNOTATIONS_WIRE: gremlin.ProtoWireNumber = 4;
    const TASK_EXECUTION_WIRE: gremlin.ProtoWireNumber = 5;
    const LOG_MESSAGE_WIRE: gremlin.ProtoWireNumber = 21;
    const CC_SCHEDULER_STATE_WIRE: gremlin.ProtoWireNumber = 24;
    const CHROME_USER_EVENT_WIRE: gremlin.ProtoWireNumber = 25;
    const CHROME_KEYED_SERVICE_WIRE: gremlin.ProtoWireNumber = 26;
    const CHROME_LEGACY_IPC_WIRE: gremlin.ProtoWireNumber = 27;
    const CHROME_HISTOGRAM_SAMPLE_WIRE: gremlin.ProtoWireNumber = 28;
    const CHROME_LATENCY_INFO_WIRE: gremlin.ProtoWireNumber = 29;
    const CHROME_FRAME_REPORTER_WIRE: gremlin.ProtoWireNumber = 32;
    const CHROME_APPLICATION_STATE_INFO_WIRE: gremlin.ProtoWireNumber = 39;
    const CHROME_RENDERER_SCHEDULER_STATE_WIRE: gremlin.ProtoWireNumber = 40;
    const CHROME_WINDOW_HANDLE_EVENT_INFO_WIRE: gremlin.ProtoWireNumber = 41;
    const CHROME_CONTENT_SETTINGS_EVENT_INFO_WIRE: gremlin.ProtoWireNumber = 43;
    const CHROME_ACTIVE_PROCESSES_WIRE: gremlin.ProtoWireNumber = 49;
    const SCREENSHOT_WIRE: gremlin.ProtoWireNumber = 50;
    const CHROME_MESSAGE_PUMP_WIRE: gremlin.ProtoWireNumber = 35;
    const CHROME_MOJO_EVENT_INFO_WIRE: gremlin.ProtoWireNumber = 38;
    const LEGACY_EVENT_WIRE: gremlin.ProtoWireNumber = 6;
    const NAME_IID_WIRE: gremlin.ProtoWireNumber = 10;
    const NAME_WIRE: gremlin.ProtoWireNumber = 23;
    const COUNTER_VALUE_WIRE: gremlin.ProtoWireNumber = 30;
    const DOUBLE_COUNTER_VALUE_WIRE: gremlin.ProtoWireNumber = 44;
    const CORRELATION_ID_WIRE: gremlin.ProtoWireNumber = 52;
    const CORRELATION_ID_STR_WIRE: gremlin.ProtoWireNumber = 53;
    const CORRELATION_ID_STR_IID_WIRE: gremlin.ProtoWireNumber = 54;
    const CALLSTACK_WIRE: gremlin.ProtoWireNumber = 55;
    const CALLSTACK_IID_WIRE: gremlin.ProtoWireNumber = 56;
    const SOURCE_LOCATION_WIRE: gremlin.ProtoWireNumber = 33;
    const SOURCE_LOCATION_IID_WIRE: gremlin.ProtoWireNumber = 34;
    const TIMESTAMP_DELTA_US_WIRE: gremlin.ProtoWireNumber = 1;
    const TIMESTAMP_ABSOLUTE_US_WIRE: gremlin.ProtoWireNumber = 16;
    const THREAD_TIME_DELTA_US_WIRE: gremlin.ProtoWireNumber = 2;
    const THREAD_TIME_ABSOLUTE_US_WIRE: gremlin.ProtoWireNumber = 17;
    const THREAD_INSTRUCTION_COUNT_DELTA_WIRE: gremlin.ProtoWireNumber = 8;
    const THREAD_INSTRUCTION_COUNT_ABSOLUTE_WIRE: gremlin.ProtoWireNumber = 20;
};
pub const ChromeTrackEvent = struct {
    // fields
    category_iids: ?[]const u64 = null,
    categories: ?[]const ?[]const u8 = null,
    type: track_event.TrackEvent.Type = @enumFromInt(0),
    track_uuid: u64 = 0,
    extra_counter_track_uuids: ?[]const u64 = null,
    extra_counter_values: ?[]const i64 = null,
    extra_double_counter_track_uuids: ?[]const u64 = null,
    extra_double_counter_values: ?[]const f64 = null,
    flow_ids_old: ?[]const u64 = null,
    flow_ids: ?[]const u64 = null,
    terminating_flow_ids_old: ?[]const u64 = null,
    terminating_flow_ids: ?[]const u64 = null,
    debug_annotations: ?[]const ?debug_annotation.DebugAnnotation = null,
    task_execution: ?task_execution.TaskExecution = null,
    log_message: ?log_message.LogMessage = null,
    cc_scheduler_state: ?chrome_compositor_scheduler_state.ChromeCompositorSchedulerState = null,
    chrome_user_event: ?chrome_user_event.ChromeUserEvent = null,
    chrome_keyed_service: ?chrome_keyed_service.ChromeKeyedService = null,
    chrome_legacy_ipc: ?chrome_legacy_ipc.ChromeLegacyIpc = null,
    chrome_histogram_sample: ?chrome_histogram_sample.ChromeHistogramSample = null,
    chrome_latency_info: ?chrome_latency_info.ChromeLatencyInfo = null,
    chrome_frame_reporter: ?chrome_frame_reporter.ChromeFrameReporter = null,
    chrome_application_state_info: ?chrome_application_state_info.ChromeApplicationStateInfo = null,
    chrome_renderer_scheduler_state: ?chrome_renderer_scheduler_state.ChromeRendererSchedulerState = null,
    chrome_window_handle_event_info: ?chrome_window_handle_event_info.ChromeWindowHandleEventInfo = null,
    chrome_content_settings_event_info: ?chrome_content_settings_event_info.ChromeContentSettingsEventInfo = null,
    chrome_active_processes: ?chrome_active_processes.ChromeActiveProcesses = null,
    screenshot: ?screenshot.Screenshot = null,
    chrome_message_pump: ?chrome_message_pump.ChromeMessagePump = null,
    chrome_mojo_event_info: ?chrome_mojo_event_info.ChromeMojoEventInfo = null,
    legacy_event: ?track_event.TrackEvent.LegacyEvent = null,
    name_iid: u64 = 0,
    name: ?[]const u8 = null,
    counter_value: i64 = 0,
    double_counter_value: f64 = 0.0,
    correlation_id: u64 = 0,
    correlation_id_str: ?[]const u8 = null,
    correlation_id_str_iid: u64 = 0,
    callstack: ?track_event.TrackEvent.Callstack = null,
    callstack_iid: u64 = 0,
    source_location: ?source_location.SourceLocation = null,
    source_location_iid: u64 = 0,
    timestamp_delta_us: i64 = 0,
    timestamp_absolute_us: i64 = 0,
    thread_time_delta_us: i64 = 0,
    thread_time_absolute_us: i64 = 0,
    thread_instruction_count_delta: i64 = 0,
    thread_instruction_count_absolute: i64 = 0,
    pub fn calcProtobufSize(self: *const ChromeTrackEvent) usize {
        var res: usize = 0;
        if (self.category_iids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.CATEGORY_IIDS_WIRE) + gremlin.sizes.sizeU64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.CATEGORY_IIDS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.categories) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.CATEGORIES_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (@intFromEnum(self.type) != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.type));
        }
        if (self.track_uuid != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.TRACK_UUID_WIRE) + gremlin.sizes.sizeU64(self.track_uuid);
        }
        if (self.extra_counter_track_uuids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.EXTRA_COUNTER_TRACK_UUIDS_WIRE) + gremlin.sizes.sizeU64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.EXTRA_COUNTER_TRACK_UUIDS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.extra_counter_values) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.EXTRA_COUNTER_VALUES_WIRE) + gremlin.sizes.sizeI64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI64(v);
                }
                res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.EXTRA_COUNTER_VALUES_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.extra_double_counter_track_uuids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.EXTRA_DOUBLE_COUNTER_TRACK_UUIDS_WIRE) + gremlin.sizes.sizeU64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.EXTRA_DOUBLE_COUNTER_TRACK_UUIDS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.extra_double_counter_values) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.EXTRA_DOUBLE_COUNTER_VALUES_WIRE) + gremlin.sizes.sizeDouble(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeDouble(v);
                }
                res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.EXTRA_DOUBLE_COUNTER_VALUES_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.flow_ids_old) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.FLOW_IDS_OLD_WIRE) + gremlin.sizes.sizeU64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.FLOW_IDS_OLD_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.flow_ids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.FLOW_IDS_WIRE) + gremlin.sizes.sizeFixed64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeFixed64(v);
                }
                res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.FLOW_IDS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.terminating_flow_ids_old) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.TERMINATING_FLOW_IDS_OLD_WIRE) + gremlin.sizes.sizeU64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.TERMINATING_FLOW_IDS_OLD_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.terminating_flow_ids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.TERMINATING_FLOW_IDS_WIRE) + gremlin.sizes.sizeFixed64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeFixed64(v);
                }
                res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.TERMINATING_FLOW_IDS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.debug_annotations) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.DEBUG_ANNOTATIONS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.task_execution) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.TASK_EXECUTION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.log_message) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.LOG_MESSAGE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cc_scheduler_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.CC_SCHEDULER_STATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_user_event) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.CHROME_USER_EVENT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_keyed_service) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.CHROME_KEYED_SERVICE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_legacy_ipc) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.CHROME_LEGACY_IPC_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_histogram_sample) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.CHROME_HISTOGRAM_SAMPLE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_latency_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.CHROME_LATENCY_INFO_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_frame_reporter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.CHROME_FRAME_REPORTER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_application_state_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.CHROME_APPLICATION_STATE_INFO_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_renderer_scheduler_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.CHROME_RENDERER_SCHEDULER_STATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_window_handle_event_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.CHROME_WINDOW_HANDLE_EVENT_INFO_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_content_settings_event_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.CHROME_CONTENT_SETTINGS_EVENT_INFO_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_active_processes) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.CHROME_ACTIVE_PROCESSES_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.screenshot) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.SCREENSHOT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_message_pump) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.CHROME_MESSAGE_PUMP_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_mojo_event_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.CHROME_MOJO_EVENT_INFO_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.legacy_event) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.LEGACY_EVENT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.name_iid != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.NAME_IID_WIRE) + gremlin.sizes.sizeU64(self.name_iid);
        }
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.counter_value != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.COUNTER_VALUE_WIRE) + gremlin.sizes.sizeI64(self.counter_value);
        }
        if (self.double_counter_value != 0.0) {
            res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.DOUBLE_COUNTER_VALUE_WIRE) + gremlin.sizes.sizeDouble(self.double_counter_value);
        }
        if (self.correlation_id != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.CORRELATION_ID_WIRE) + gremlin.sizes.sizeU64(self.correlation_id);
        }
        if (self.correlation_id_str) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.CORRELATION_ID_STR_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.correlation_id_str_iid != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.CORRELATION_ID_STR_IID_WIRE) + gremlin.sizes.sizeU64(self.correlation_id_str_iid);
        }
        if (self.callstack) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.CALLSTACK_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.callstack_iid != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.CALLSTACK_IID_WIRE) + gremlin.sizes.sizeU64(self.callstack_iid);
        }
        if (self.source_location) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.SOURCE_LOCATION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.source_location_iid != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.SOURCE_LOCATION_IID_WIRE) + gremlin.sizes.sizeU64(self.source_location_iid);
        }
        if (self.timestamp_delta_us != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.TIMESTAMP_DELTA_US_WIRE) + gremlin.sizes.sizeI64(self.timestamp_delta_us);
        }
        if (self.timestamp_absolute_us != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.TIMESTAMP_ABSOLUTE_US_WIRE) + gremlin.sizes.sizeI64(self.timestamp_absolute_us);
        }
        if (self.thread_time_delta_us != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.THREAD_TIME_DELTA_US_WIRE) + gremlin.sizes.sizeI64(self.thread_time_delta_us);
        }
        if (self.thread_time_absolute_us != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.THREAD_TIME_ABSOLUTE_US_WIRE) + gremlin.sizes.sizeI64(self.thread_time_absolute_us);
        }
        if (self.thread_instruction_count_delta != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.THREAD_INSTRUCTION_COUNT_DELTA_WIRE) + gremlin.sizes.sizeI64(self.thread_instruction_count_delta);
        }
        if (self.thread_instruction_count_absolute != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeTrackEventWire.THREAD_INSTRUCTION_COUNT_ABSOLUTE_WIRE) + gremlin.sizes.sizeI64(self.thread_instruction_count_absolute);
        }
        return res;
    }
    pub fn encode(self: *const ChromeTrackEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ChromeTrackEvent, target: *gremlin.Writer) void {
        if (self.category_iids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint64(ChromeTrackEventWire.CATEGORY_IIDS_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                target.appendBytesTag(ChromeTrackEventWire.CATEGORY_IIDS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint64WithoutTag(v);
                }
            }
        }
        if (self.categories) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(ChromeTrackEventWire.CATEGORIES_WIRE, v);
                } else {
                    target.appendBytesTag(ChromeTrackEventWire.CATEGORIES_WIRE, 0);
                }
            }
        }
        if (@intFromEnum(self.type) != 0) {
            target.appendInt32(ChromeTrackEventWire.TYPE_WIRE, @intFromEnum(self.type));
        }
        if (self.track_uuid != 0) {
            target.appendUint64(ChromeTrackEventWire.TRACK_UUID_WIRE, self.track_uuid);
        }
        if (self.extra_counter_track_uuids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint64(ChromeTrackEventWire.EXTRA_COUNTER_TRACK_UUIDS_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                target.appendBytesTag(ChromeTrackEventWire.EXTRA_COUNTER_TRACK_UUIDS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint64WithoutTag(v);
                }
            }
        }
        if (self.extra_counter_values) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt64(ChromeTrackEventWire.EXTRA_COUNTER_VALUES_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI64(v);
                }
                target.appendBytesTag(ChromeTrackEventWire.EXTRA_COUNTER_VALUES_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt64WithoutTag(v);
                }
            }
        }
        if (self.extra_double_counter_track_uuids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint64(ChromeTrackEventWire.EXTRA_DOUBLE_COUNTER_TRACK_UUIDS_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                target.appendBytesTag(ChromeTrackEventWire.EXTRA_DOUBLE_COUNTER_TRACK_UUIDS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint64WithoutTag(v);
                }
            }
        }
        if (self.extra_double_counter_values) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendFloat64(ChromeTrackEventWire.EXTRA_DOUBLE_COUNTER_VALUES_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeDouble(v);
                }
                target.appendBytesTag(ChromeTrackEventWire.EXTRA_DOUBLE_COUNTER_VALUES_WIRE, packed_size);
                for (arr) |v| {
                    target.appendFloat64WithoutTag(v);
                }
            }
        }
        if (self.flow_ids_old) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint64(ChromeTrackEventWire.FLOW_IDS_OLD_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                target.appendBytesTag(ChromeTrackEventWire.FLOW_IDS_OLD_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint64WithoutTag(v);
                }
            }
        }
        if (self.flow_ids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendFixed64(ChromeTrackEventWire.FLOW_IDS_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeFixed64(v);
                }
                target.appendBytesTag(ChromeTrackEventWire.FLOW_IDS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendFixed64WithoutTag(v);
                }
            }
        }
        if (self.terminating_flow_ids_old) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint64(ChromeTrackEventWire.TERMINATING_FLOW_IDS_OLD_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                target.appendBytesTag(ChromeTrackEventWire.TERMINATING_FLOW_IDS_OLD_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint64WithoutTag(v);
                }
            }
        }
        if (self.terminating_flow_ids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendFixed64(ChromeTrackEventWire.TERMINATING_FLOW_IDS_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeFixed64(v);
                }
                target.appendBytesTag(ChromeTrackEventWire.TERMINATING_FLOW_IDS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendFixed64WithoutTag(v);
                }
            }
        }
        if (self.debug_annotations) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(ChromeTrackEventWire.DEBUG_ANNOTATIONS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(ChromeTrackEventWire.DEBUG_ANNOTATIONS_WIRE, 0);
                }
            }
        }
        if (self.task_execution) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeTrackEventWire.TASK_EXECUTION_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.log_message) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeTrackEventWire.LOG_MESSAGE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cc_scheduler_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeTrackEventWire.CC_SCHEDULER_STATE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_user_event) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeTrackEventWire.CHROME_USER_EVENT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_keyed_service) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeTrackEventWire.CHROME_KEYED_SERVICE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_legacy_ipc) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeTrackEventWire.CHROME_LEGACY_IPC_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_histogram_sample) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeTrackEventWire.CHROME_HISTOGRAM_SAMPLE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_latency_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeTrackEventWire.CHROME_LATENCY_INFO_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_frame_reporter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeTrackEventWire.CHROME_FRAME_REPORTER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_application_state_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeTrackEventWire.CHROME_APPLICATION_STATE_INFO_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_renderer_scheduler_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeTrackEventWire.CHROME_RENDERER_SCHEDULER_STATE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_window_handle_event_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeTrackEventWire.CHROME_WINDOW_HANDLE_EVENT_INFO_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_content_settings_event_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeTrackEventWire.CHROME_CONTENT_SETTINGS_EVENT_INFO_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_active_processes) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeTrackEventWire.CHROME_ACTIVE_PROCESSES_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.screenshot) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeTrackEventWire.SCREENSHOT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_message_pump) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeTrackEventWire.CHROME_MESSAGE_PUMP_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_mojo_event_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeTrackEventWire.CHROME_MOJO_EVENT_INFO_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.legacy_event) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeTrackEventWire.LEGACY_EVENT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.name_iid != 0) {
            target.appendUint64(ChromeTrackEventWire.NAME_IID_WIRE, self.name_iid);
        }
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(ChromeTrackEventWire.NAME_WIRE, v);
            }
        }
        if (self.counter_value != 0) {
            target.appendInt64(ChromeTrackEventWire.COUNTER_VALUE_WIRE, self.counter_value);
        }
        if (self.double_counter_value != 0.0) {
            target.appendFloat64(ChromeTrackEventWire.DOUBLE_COUNTER_VALUE_WIRE, self.double_counter_value);
        }
        if (self.correlation_id != 0) {
            target.appendUint64(ChromeTrackEventWire.CORRELATION_ID_WIRE, self.correlation_id);
        }
        if (self.correlation_id_str) |v| {
            if (v.len > 0) {
                target.appendBytes(ChromeTrackEventWire.CORRELATION_ID_STR_WIRE, v);
            }
        }
        if (self.correlation_id_str_iid != 0) {
            target.appendUint64(ChromeTrackEventWire.CORRELATION_ID_STR_IID_WIRE, self.correlation_id_str_iid);
        }
        if (self.callstack) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeTrackEventWire.CALLSTACK_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.callstack_iid != 0) {
            target.appendUint64(ChromeTrackEventWire.CALLSTACK_IID_WIRE, self.callstack_iid);
        }
        if (self.source_location) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeTrackEventWire.SOURCE_LOCATION_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.source_location_iid != 0) {
            target.appendUint64(ChromeTrackEventWire.SOURCE_LOCATION_IID_WIRE, self.source_location_iid);
        }
        if (self.timestamp_delta_us != 0) {
            target.appendInt64(ChromeTrackEventWire.TIMESTAMP_DELTA_US_WIRE, self.timestamp_delta_us);
        }
        if (self.timestamp_absolute_us != 0) {
            target.appendInt64(ChromeTrackEventWire.TIMESTAMP_ABSOLUTE_US_WIRE, self.timestamp_absolute_us);
        }
        if (self.thread_time_delta_us != 0) {
            target.appendInt64(ChromeTrackEventWire.THREAD_TIME_DELTA_US_WIRE, self.thread_time_delta_us);
        }
        if (self.thread_time_absolute_us != 0) {
            target.appendInt64(ChromeTrackEventWire.THREAD_TIME_ABSOLUTE_US_WIRE, self.thread_time_absolute_us);
        }
        if (self.thread_instruction_count_delta != 0) {
            target.appendInt64(ChromeTrackEventWire.THREAD_INSTRUCTION_COUNT_DELTA_WIRE, self.thread_instruction_count_delta);
        }
        if (self.thread_instruction_count_absolute != 0) {
            target.appendInt64(ChromeTrackEventWire.THREAD_INSTRUCTION_COUNT_ABSOLUTE_WIRE, self.thread_instruction_count_absolute);
        }
    }
};
pub const ChromeTrackEventReader = struct {
    buf: gremlin.Reader,
    _category_iids_offset: ?usize = null,
    _category_iids_last_offset: ?usize = null,
    _category_iids_packed: bool = false,
    _categories_offset: ?usize = null,
    _categories_last_offset: ?usize = null,
    _categories_cnt: usize = 0,
    _type: track_event.TrackEvent.Type = @enumFromInt(0),
    _track_uuid: u64 = 0,
    _extra_counter_track_uuids_offset: ?usize = null,
    _extra_counter_track_uuids_last_offset: ?usize = null,
    _extra_counter_track_uuids_packed: bool = false,
    _extra_counter_values_offset: ?usize = null,
    _extra_counter_values_last_offset: ?usize = null,
    _extra_counter_values_packed: bool = false,
    _extra_double_counter_track_uuids_offset: ?usize = null,
    _extra_double_counter_track_uuids_last_offset: ?usize = null,
    _extra_double_counter_track_uuids_packed: bool = false,
    _extra_double_counter_values_offset: ?usize = null,
    _extra_double_counter_values_last_offset: ?usize = null,
    _extra_double_counter_values_packed: bool = false,
    _flow_ids_old_offset: ?usize = null,
    _flow_ids_old_last_offset: ?usize = null,
    _flow_ids_old_packed: bool = false,
    _flow_ids_offset: ?usize = null,
    _flow_ids_last_offset: ?usize = null,
    _flow_ids_packed: bool = false,
    _terminating_flow_ids_old_offset: ?usize = null,
    _terminating_flow_ids_old_last_offset: ?usize = null,
    _terminating_flow_ids_old_packed: bool = false,
    _terminating_flow_ids_offset: ?usize = null,
    _terminating_flow_ids_last_offset: ?usize = null,
    _terminating_flow_ids_packed: bool = false,
    _debug_annotations_offset: ?usize = null,
    _debug_annotations_last_offset: ?usize = null,
    _debug_annotations_cnt: usize = 0,
    _task_execution_buf: ?[]const u8 = null,
    _log_message_buf: ?[]const u8 = null,
    _cc_scheduler_state_buf: ?[]const u8 = null,
    _chrome_user_event_buf: ?[]const u8 = null,
    _chrome_keyed_service_buf: ?[]const u8 = null,
    _chrome_legacy_ipc_buf: ?[]const u8 = null,
    _chrome_histogram_sample_buf: ?[]const u8 = null,
    _chrome_latency_info_buf: ?[]const u8 = null,
    _chrome_frame_reporter_buf: ?[]const u8 = null,
    _chrome_application_state_info_buf: ?[]const u8 = null,
    _chrome_renderer_scheduler_state_buf: ?[]const u8 = null,
    _chrome_window_handle_event_info_buf: ?[]const u8 = null,
    _chrome_content_settings_event_info_buf: ?[]const u8 = null,
    _chrome_active_processes_buf: ?[]const u8 = null,
    _screenshot_buf: ?[]const u8 = null,
    _chrome_message_pump_buf: ?[]const u8 = null,
    _chrome_mojo_event_info_buf: ?[]const u8 = null,
    _legacy_event_buf: ?[]const u8 = null,
    _name_iid: u64 = 0,
    _name: ?[]const u8 = null,
    _counter_value: i64 = 0,
    _double_counter_value: f64 = 0.0,
    _correlation_id: u64 = 0,
    _correlation_id_str: ?[]const u8 = null,
    _correlation_id_str_iid: u64 = 0,
    _callstack_buf: ?[]const u8 = null,
    _callstack_iid: u64 = 0,
    _source_location_buf: ?[]const u8 = null,
    _source_location_iid: u64 = 0,
    _timestamp_delta_us: i64 = 0,
    _timestamp_absolute_us: i64 = 0,
    _thread_time_delta_us: i64 = 0,
    _thread_time_absolute_us: i64 = 0,
    _thread_instruction_count_delta: i64 = 0,
    _thread_instruction_count_absolute: i64 = 0,
    pub fn init(src: []const u8) gremlin.Error!ChromeTrackEventReader {
        const buf = gremlin.Reader.init(src);
        var res = ChromeTrackEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ChromeTrackEventWire.CATEGORY_IIDS_WIRE => {
                    if (res._category_iids_offset == null) {
                        res._category_iids_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._category_iids_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._category_iids_offset = offset + length_result.size;
                        res._category_iids_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._category_iids_last_offset.?;
                    } else {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._category_iids_last_offset = offset;
                    }
                },
                ChromeTrackEventWire.CATEGORIES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._categories_offset == null) {
                        res._categories_offset = offset - result.size;
                    }
                    res._categories_last_offset = offset;
                    res._categories_cnt += 1;
                },
                ChromeTrackEventWire.TYPE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._type = @enumFromInt(result.value);
                },
                ChromeTrackEventWire.TRACK_UUID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._track_uuid = result.value;
                },
                ChromeTrackEventWire.EXTRA_COUNTER_TRACK_UUIDS_WIRE => {
                    if (res._extra_counter_track_uuids_offset == null) {
                        res._extra_counter_track_uuids_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._extra_counter_track_uuids_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._extra_counter_track_uuids_offset = offset + length_result.size;
                        res._extra_counter_track_uuids_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._extra_counter_track_uuids_last_offset.?;
                    } else {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._extra_counter_track_uuids_last_offset = offset;
                    }
                },
                ChromeTrackEventWire.EXTRA_COUNTER_VALUES_WIRE => {
                    if (res._extra_counter_values_offset == null) {
                        res._extra_counter_values_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._extra_counter_values_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._extra_counter_values_offset = offset + length_result.size;
                        res._extra_counter_values_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._extra_counter_values_last_offset.?;
                    } else {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._extra_counter_values_last_offset = offset;
                    }
                },
                ChromeTrackEventWire.EXTRA_DOUBLE_COUNTER_TRACK_UUIDS_WIRE => {
                    if (res._extra_double_counter_track_uuids_offset == null) {
                        res._extra_double_counter_track_uuids_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._extra_double_counter_track_uuids_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._extra_double_counter_track_uuids_offset = offset + length_result.size;
                        res._extra_double_counter_track_uuids_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._extra_double_counter_track_uuids_last_offset.?;
                    } else {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._extra_double_counter_track_uuids_last_offset = offset;
                    }
                },
                ChromeTrackEventWire.EXTRA_DOUBLE_COUNTER_VALUES_WIRE => {
                    if (res._extra_double_counter_values_offset == null) {
                        res._extra_double_counter_values_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._extra_double_counter_values_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._extra_double_counter_values_offset = offset + length_result.size;
                        res._extra_double_counter_values_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._extra_double_counter_values_last_offset.?;
                    } else {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._extra_double_counter_values_last_offset = offset;
                    }
                },
                ChromeTrackEventWire.FLOW_IDS_OLD_WIRE => {
                    if (res._flow_ids_old_offset == null) {
                        res._flow_ids_old_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._flow_ids_old_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._flow_ids_old_offset = offset + length_result.size;
                        res._flow_ids_old_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._flow_ids_old_last_offset.?;
                    } else {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._flow_ids_old_last_offset = offset;
                    }
                },
                ChromeTrackEventWire.FLOW_IDS_WIRE => {
                    if (res._flow_ids_offset == null) {
                        res._flow_ids_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._flow_ids_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._flow_ids_offset = offset + length_result.size;
                        res._flow_ids_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._flow_ids_last_offset.?;
                    } else {
                        const result = try buf.readFixed64(offset);
                        offset += result.size;
                        res._flow_ids_last_offset = offset;
                    }
                },
                ChromeTrackEventWire.TERMINATING_FLOW_IDS_OLD_WIRE => {
                    if (res._terminating_flow_ids_old_offset == null) {
                        res._terminating_flow_ids_old_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._terminating_flow_ids_old_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._terminating_flow_ids_old_offset = offset + length_result.size;
                        res._terminating_flow_ids_old_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._terminating_flow_ids_old_last_offset.?;
                    } else {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._terminating_flow_ids_old_last_offset = offset;
                    }
                },
                ChromeTrackEventWire.TERMINATING_FLOW_IDS_WIRE => {
                    if (res._terminating_flow_ids_offset == null) {
                        res._terminating_flow_ids_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._terminating_flow_ids_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._terminating_flow_ids_offset = offset + length_result.size;
                        res._terminating_flow_ids_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._terminating_flow_ids_last_offset.?;
                    } else {
                        const result = try buf.readFixed64(offset);
                        offset += result.size;
                        res._terminating_flow_ids_last_offset = offset;
                    }
                },
                ChromeTrackEventWire.DEBUG_ANNOTATIONS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._debug_annotations_offset == null) {
                        res._debug_annotations_offset = offset - result.size;
                    }
                    res._debug_annotations_last_offset = offset;
                    res._debug_annotations_cnt += 1;
                },
                ChromeTrackEventWire.TASK_EXECUTION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._task_execution_buf = result.value;
                },
                ChromeTrackEventWire.LOG_MESSAGE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._log_message_buf = result.value;
                },
                ChromeTrackEventWire.CC_SCHEDULER_STATE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cc_scheduler_state_buf = result.value;
                },
                ChromeTrackEventWire.CHROME_USER_EVENT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_user_event_buf = result.value;
                },
                ChromeTrackEventWire.CHROME_KEYED_SERVICE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_keyed_service_buf = result.value;
                },
                ChromeTrackEventWire.CHROME_LEGACY_IPC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_legacy_ipc_buf = result.value;
                },
                ChromeTrackEventWire.CHROME_HISTOGRAM_SAMPLE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_histogram_sample_buf = result.value;
                },
                ChromeTrackEventWire.CHROME_LATENCY_INFO_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_latency_info_buf = result.value;
                },
                ChromeTrackEventWire.CHROME_FRAME_REPORTER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_frame_reporter_buf = result.value;
                },
                ChromeTrackEventWire.CHROME_APPLICATION_STATE_INFO_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_application_state_info_buf = result.value;
                },
                ChromeTrackEventWire.CHROME_RENDERER_SCHEDULER_STATE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_renderer_scheduler_state_buf = result.value;
                },
                ChromeTrackEventWire.CHROME_WINDOW_HANDLE_EVENT_INFO_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_window_handle_event_info_buf = result.value;
                },
                ChromeTrackEventWire.CHROME_CONTENT_SETTINGS_EVENT_INFO_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_content_settings_event_info_buf = result.value;
                },
                ChromeTrackEventWire.CHROME_ACTIVE_PROCESSES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_active_processes_buf = result.value;
                },
                ChromeTrackEventWire.SCREENSHOT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._screenshot_buf = result.value;
                },
                ChromeTrackEventWire.CHROME_MESSAGE_PUMP_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_message_pump_buf = result.value;
                },
                ChromeTrackEventWire.CHROME_MOJO_EVENT_INFO_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_mojo_event_info_buf = result.value;
                },
                ChromeTrackEventWire.LEGACY_EVENT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._legacy_event_buf = result.value;
                },
                ChromeTrackEventWire.NAME_IID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._name_iid = result.value;
                },
                ChromeTrackEventWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                ChromeTrackEventWire.COUNTER_VALUE_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._counter_value = result.value;
                },
                ChromeTrackEventWire.DOUBLE_COUNTER_VALUE_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._double_counter_value = result.value;
                },
                ChromeTrackEventWire.CORRELATION_ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._correlation_id = result.value;
                },
                ChromeTrackEventWire.CORRELATION_ID_STR_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._correlation_id_str = result.value;
                },
                ChromeTrackEventWire.CORRELATION_ID_STR_IID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._correlation_id_str_iid = result.value;
                },
                ChromeTrackEventWire.CALLSTACK_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._callstack_buf = result.value;
                },
                ChromeTrackEventWire.CALLSTACK_IID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._callstack_iid = result.value;
                },
                ChromeTrackEventWire.SOURCE_LOCATION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._source_location_buf = result.value;
                },
                ChromeTrackEventWire.SOURCE_LOCATION_IID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._source_location_iid = result.value;
                },
                ChromeTrackEventWire.TIMESTAMP_DELTA_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._timestamp_delta_us = result.value;
                },
                ChromeTrackEventWire.TIMESTAMP_ABSOLUTE_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._timestamp_absolute_us = result.value;
                },
                ChromeTrackEventWire.THREAD_TIME_DELTA_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._thread_time_delta_us = result.value;
                },
                ChromeTrackEventWire.THREAD_TIME_ABSOLUTE_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._thread_time_absolute_us = result.value;
                },
                ChromeTrackEventWire.THREAD_INSTRUCTION_COUNT_DELTA_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._thread_instruction_count_delta = result.value;
                },
                ChromeTrackEventWire.THREAD_INSTRUCTION_COUNT_ABSOLUTE_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._thread_instruction_count_absolute = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn categoryIidsNext(self: *ChromeTrackEventReader) gremlin.Error!?u64 {
        if (self._category_iids_offset == null) return null;
        const current_offset = self._category_iids_offset.?;
        if (current_offset >= self._category_iids_last_offset.?) {
            self._category_iids_offset = null;
            return null;
        }
        if (self._category_iids_packed) {
            const value_result = try self.buf.readUInt64(current_offset);
            self._category_iids_offset = current_offset + value_result.size;
            if (self._category_iids_offset.? >= self._category_iids_last_offset.?) {
                self._category_iids_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._category_iids_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == ChromeTrackEventWire.CATEGORY_IIDS_WIRE) {
                    self._category_iids_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._category_iids_offset = null;
            return value_result.value;
        }
    }
    pub fn categoriesCount(self: *const ChromeTrackEventReader) usize {
        return self._categories_cnt;
    }
    pub fn categoriesNext(self: *ChromeTrackEventReader) ?[]const u8 {
        if (self._categories_offset == null) return null;
        const current_offset = self._categories_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._categories_last_offset != null and current_offset >= self._categories_last_offset.?) {
            self._categories_offset = null;
            return result.value;
        }
        if (self._categories_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._categories_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ChromeTrackEventWire.CATEGORIES_WIRE) {
                self._categories_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._categories_offset = null;
        return result.value;
    }
    pub inline fn getType(self: *const ChromeTrackEventReader) track_event.TrackEvent.Type {
        return self._type;
    }
    pub inline fn getTrackUuid(self: *const ChromeTrackEventReader) u64 {
        return self._track_uuid;
    }
    pub fn extraCounterTrackUuidsNext(self: *ChromeTrackEventReader) gremlin.Error!?u64 {
        if (self._extra_counter_track_uuids_offset == null) return null;
        const current_offset = self._extra_counter_track_uuids_offset.?;
        if (current_offset >= self._extra_counter_track_uuids_last_offset.?) {
            self._extra_counter_track_uuids_offset = null;
            return null;
        }
        if (self._extra_counter_track_uuids_packed) {
            const value_result = try self.buf.readUInt64(current_offset);
            self._extra_counter_track_uuids_offset = current_offset + value_result.size;
            if (self._extra_counter_track_uuids_offset.? >= self._extra_counter_track_uuids_last_offset.?) {
                self._extra_counter_track_uuids_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._extra_counter_track_uuids_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == ChromeTrackEventWire.EXTRA_COUNTER_TRACK_UUIDS_WIRE) {
                    self._extra_counter_track_uuids_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._extra_counter_track_uuids_offset = null;
            return value_result.value;
        }
    }
    pub fn extraCounterValuesNext(self: *ChromeTrackEventReader) gremlin.Error!?i64 {
        if (self._extra_counter_values_offset == null) return null;
        const current_offset = self._extra_counter_values_offset.?;
        if (current_offset >= self._extra_counter_values_last_offset.?) {
            self._extra_counter_values_offset = null;
            return null;
        }
        if (self._extra_counter_values_packed) {
            const value_result = try self.buf.readInt64(current_offset);
            self._extra_counter_values_offset = current_offset + value_result.size;
            if (self._extra_counter_values_offset.? >= self._extra_counter_values_last_offset.?) {
                self._extra_counter_values_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._extra_counter_values_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == ChromeTrackEventWire.EXTRA_COUNTER_VALUES_WIRE) {
                    self._extra_counter_values_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._extra_counter_values_offset = null;
            return value_result.value;
        }
    }
    pub fn extraDoubleCounterTrackUuidsNext(self: *ChromeTrackEventReader) gremlin.Error!?u64 {
        if (self._extra_double_counter_track_uuids_offset == null) return null;
        const current_offset = self._extra_double_counter_track_uuids_offset.?;
        if (current_offset >= self._extra_double_counter_track_uuids_last_offset.?) {
            self._extra_double_counter_track_uuids_offset = null;
            return null;
        }
        if (self._extra_double_counter_track_uuids_packed) {
            const value_result = try self.buf.readUInt64(current_offset);
            self._extra_double_counter_track_uuids_offset = current_offset + value_result.size;
            if (self._extra_double_counter_track_uuids_offset.? >= self._extra_double_counter_track_uuids_last_offset.?) {
                self._extra_double_counter_track_uuids_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._extra_double_counter_track_uuids_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == ChromeTrackEventWire.EXTRA_DOUBLE_COUNTER_TRACK_UUIDS_WIRE) {
                    self._extra_double_counter_track_uuids_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._extra_double_counter_track_uuids_offset = null;
            return value_result.value;
        }
    }
    pub fn extraDoubleCounterValuesNext(self: *ChromeTrackEventReader) gremlin.Error!?f64 {
        if (self._extra_double_counter_values_offset == null) return null;
        const current_offset = self._extra_double_counter_values_offset.?;
        if (current_offset >= self._extra_double_counter_values_last_offset.?) {
            self._extra_double_counter_values_offset = null;
            return null;
        }
        if (self._extra_double_counter_values_packed) {
            const value_result = try self.buf.readFloat64(current_offset);
            self._extra_double_counter_values_offset = current_offset + value_result.size;
            if (self._extra_double_counter_values_offset.? >= self._extra_double_counter_values_last_offset.?) {
                self._extra_double_counter_values_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readFloat64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._extra_double_counter_values_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == ChromeTrackEventWire.EXTRA_DOUBLE_COUNTER_VALUES_WIRE) {
                    self._extra_double_counter_values_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._extra_double_counter_values_offset = null;
            return value_result.value;
        }
    }
    pub fn flowIdsOldNext(self: *ChromeTrackEventReader) gremlin.Error!?u64 {
        if (self._flow_ids_old_offset == null) return null;
        const current_offset = self._flow_ids_old_offset.?;
        if (current_offset >= self._flow_ids_old_last_offset.?) {
            self._flow_ids_old_offset = null;
            return null;
        }
        if (self._flow_ids_old_packed) {
            const value_result = try self.buf.readUInt64(current_offset);
            self._flow_ids_old_offset = current_offset + value_result.size;
            if (self._flow_ids_old_offset.? >= self._flow_ids_old_last_offset.?) {
                self._flow_ids_old_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._flow_ids_old_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == ChromeTrackEventWire.FLOW_IDS_OLD_WIRE) {
                    self._flow_ids_old_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._flow_ids_old_offset = null;
            return value_result.value;
        }
    }
    pub fn flowIdsNext(self: *ChromeTrackEventReader) gremlin.Error!?u64 {
        if (self._flow_ids_offset == null) return null;
        const current_offset = self._flow_ids_offset.?;
        if (current_offset >= self._flow_ids_last_offset.?) {
            self._flow_ids_offset = null;
            return null;
        }
        if (self._flow_ids_packed) {
            const value_result = try self.buf.readFixed64(current_offset);
            self._flow_ids_offset = current_offset + value_result.size;
            if (self._flow_ids_offset.? >= self._flow_ids_last_offset.?) {
                self._flow_ids_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readFixed64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._flow_ids_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == ChromeTrackEventWire.FLOW_IDS_WIRE) {
                    self._flow_ids_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._flow_ids_offset = null;
            return value_result.value;
        }
    }
    pub fn terminatingFlowIdsOldNext(self: *ChromeTrackEventReader) gremlin.Error!?u64 {
        if (self._terminating_flow_ids_old_offset == null) return null;
        const current_offset = self._terminating_flow_ids_old_offset.?;
        if (current_offset >= self._terminating_flow_ids_old_last_offset.?) {
            self._terminating_flow_ids_old_offset = null;
            return null;
        }
        if (self._terminating_flow_ids_old_packed) {
            const value_result = try self.buf.readUInt64(current_offset);
            self._terminating_flow_ids_old_offset = current_offset + value_result.size;
            if (self._terminating_flow_ids_old_offset.? >= self._terminating_flow_ids_old_last_offset.?) {
                self._terminating_flow_ids_old_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._terminating_flow_ids_old_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == ChromeTrackEventWire.TERMINATING_FLOW_IDS_OLD_WIRE) {
                    self._terminating_flow_ids_old_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._terminating_flow_ids_old_offset = null;
            return value_result.value;
        }
    }
    pub fn terminatingFlowIdsNext(self: *ChromeTrackEventReader) gremlin.Error!?u64 {
        if (self._terminating_flow_ids_offset == null) return null;
        const current_offset = self._terminating_flow_ids_offset.?;
        if (current_offset >= self._terminating_flow_ids_last_offset.?) {
            self._terminating_flow_ids_offset = null;
            return null;
        }
        if (self._terminating_flow_ids_packed) {
            const value_result = try self.buf.readFixed64(current_offset);
            self._terminating_flow_ids_offset = current_offset + value_result.size;
            if (self._terminating_flow_ids_offset.? >= self._terminating_flow_ids_last_offset.?) {
                self._terminating_flow_ids_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readFixed64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._terminating_flow_ids_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == ChromeTrackEventWire.TERMINATING_FLOW_IDS_WIRE) {
                    self._terminating_flow_ids_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._terminating_flow_ids_offset = null;
            return value_result.value;
        }
    }
    pub fn debugAnnotationsCount(self: *const ChromeTrackEventReader) usize {
        return self._debug_annotations_cnt;
    }
    pub fn debugAnnotationsNext(self: *ChromeTrackEventReader) ?debug_annotation.DebugAnnotationReader {
        if (self._debug_annotations_offset == null) return null;
        const current_offset = self._debug_annotations_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = debug_annotation.DebugAnnotationReader.init(result.value) catch return null;
        if (self._debug_annotations_last_offset != null and current_offset >= self._debug_annotations_last_offset.?) {
            self._debug_annotations_offset = null;
            return msg;
        }
        if (self._debug_annotations_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._debug_annotations_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ChromeTrackEventWire.DEBUG_ANNOTATIONS_WIRE) {
                self._debug_annotations_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._debug_annotations_offset = null;
        return msg;
    }
    pub fn getTaskExecution(self: *const ChromeTrackEventReader) gremlin.Error!task_execution.TaskExecutionReader {
        if (self._task_execution_buf) |buf| {
            return try task_execution.TaskExecutionReader.init(buf);
        }
        return try task_execution.TaskExecutionReader.init(&[_]u8{});
    }
    pub fn getLogMessage(self: *const ChromeTrackEventReader) gremlin.Error!log_message.LogMessageReader {
        if (self._log_message_buf) |buf| {
            return try log_message.LogMessageReader.init(buf);
        }
        return try log_message.LogMessageReader.init(&[_]u8{});
    }
    pub fn getCcSchedulerState(self: *const ChromeTrackEventReader) gremlin.Error!chrome_compositor_scheduler_state.ChromeCompositorSchedulerStateReader {
        if (self._cc_scheduler_state_buf) |buf| {
            return try chrome_compositor_scheduler_state.ChromeCompositorSchedulerStateReader.init(buf);
        }
        return try chrome_compositor_scheduler_state.ChromeCompositorSchedulerStateReader.init(&[_]u8{});
    }
    pub fn getChromeUserEvent(self: *const ChromeTrackEventReader) gremlin.Error!chrome_user_event.ChromeUserEventReader {
        if (self._chrome_user_event_buf) |buf| {
            return try chrome_user_event.ChromeUserEventReader.init(buf);
        }
        return try chrome_user_event.ChromeUserEventReader.init(&[_]u8{});
    }
    pub fn getChromeKeyedService(self: *const ChromeTrackEventReader) gremlin.Error!chrome_keyed_service.ChromeKeyedServiceReader {
        if (self._chrome_keyed_service_buf) |buf| {
            return try chrome_keyed_service.ChromeKeyedServiceReader.init(buf);
        }
        return try chrome_keyed_service.ChromeKeyedServiceReader.init(&[_]u8{});
    }
    pub fn getChromeLegacyIpc(self: *const ChromeTrackEventReader) gremlin.Error!chrome_legacy_ipc.ChromeLegacyIpcReader {
        if (self._chrome_legacy_ipc_buf) |buf| {
            return try chrome_legacy_ipc.ChromeLegacyIpcReader.init(buf);
        }
        return try chrome_legacy_ipc.ChromeLegacyIpcReader.init(&[_]u8{});
    }
    pub fn getChromeHistogramSample(self: *const ChromeTrackEventReader) gremlin.Error!chrome_histogram_sample.ChromeHistogramSampleReader {
        if (self._chrome_histogram_sample_buf) |buf| {
            return try chrome_histogram_sample.ChromeHistogramSampleReader.init(buf);
        }
        return try chrome_histogram_sample.ChromeHistogramSampleReader.init(&[_]u8{});
    }
    pub fn getChromeLatencyInfo(self: *const ChromeTrackEventReader) gremlin.Error!chrome_latency_info.ChromeLatencyInfoReader {
        if (self._chrome_latency_info_buf) |buf| {
            return try chrome_latency_info.ChromeLatencyInfoReader.init(buf);
        }
        return try chrome_latency_info.ChromeLatencyInfoReader.init(&[_]u8{});
    }
    pub fn getChromeFrameReporter(self: *const ChromeTrackEventReader) gremlin.Error!chrome_frame_reporter.ChromeFrameReporterReader {
        if (self._chrome_frame_reporter_buf) |buf| {
            return try chrome_frame_reporter.ChromeFrameReporterReader.init(buf);
        }
        return try chrome_frame_reporter.ChromeFrameReporterReader.init(&[_]u8{});
    }
    pub fn getChromeApplicationStateInfo(self: *const ChromeTrackEventReader) gremlin.Error!chrome_application_state_info.ChromeApplicationStateInfoReader {
        if (self._chrome_application_state_info_buf) |buf| {
            return try chrome_application_state_info.ChromeApplicationStateInfoReader.init(buf);
        }
        return try chrome_application_state_info.ChromeApplicationStateInfoReader.init(&[_]u8{});
    }
    pub fn getChromeRendererSchedulerState(self: *const ChromeTrackEventReader) gremlin.Error!chrome_renderer_scheduler_state.ChromeRendererSchedulerStateReader {
        if (self._chrome_renderer_scheduler_state_buf) |buf| {
            return try chrome_renderer_scheduler_state.ChromeRendererSchedulerStateReader.init(buf);
        }
        return try chrome_renderer_scheduler_state.ChromeRendererSchedulerStateReader.init(&[_]u8{});
    }
    pub fn getChromeWindowHandleEventInfo(self: *const ChromeTrackEventReader) gremlin.Error!chrome_window_handle_event_info.ChromeWindowHandleEventInfoReader {
        if (self._chrome_window_handle_event_info_buf) |buf| {
            return try chrome_window_handle_event_info.ChromeWindowHandleEventInfoReader.init(buf);
        }
        return try chrome_window_handle_event_info.ChromeWindowHandleEventInfoReader.init(&[_]u8{});
    }
    pub fn getChromeContentSettingsEventInfo(self: *const ChromeTrackEventReader) gremlin.Error!chrome_content_settings_event_info.ChromeContentSettingsEventInfoReader {
        if (self._chrome_content_settings_event_info_buf) |buf| {
            return try chrome_content_settings_event_info.ChromeContentSettingsEventInfoReader.init(buf);
        }
        return try chrome_content_settings_event_info.ChromeContentSettingsEventInfoReader.init(&[_]u8{});
    }
    pub fn getChromeActiveProcesses(self: *const ChromeTrackEventReader) gremlin.Error!chrome_active_processes.ChromeActiveProcessesReader {
        if (self._chrome_active_processes_buf) |buf| {
            return try chrome_active_processes.ChromeActiveProcessesReader.init(buf);
        }
        return try chrome_active_processes.ChromeActiveProcessesReader.init(&[_]u8{});
    }
    pub fn getScreenshot(self: *const ChromeTrackEventReader) gremlin.Error!screenshot.ScreenshotReader {
        if (self._screenshot_buf) |buf| {
            return try screenshot.ScreenshotReader.init(buf);
        }
        return try screenshot.ScreenshotReader.init(&[_]u8{});
    }
    pub fn getChromeMessagePump(self: *const ChromeTrackEventReader) gremlin.Error!chrome_message_pump.ChromeMessagePumpReader {
        if (self._chrome_message_pump_buf) |buf| {
            return try chrome_message_pump.ChromeMessagePumpReader.init(buf);
        }
        return try chrome_message_pump.ChromeMessagePumpReader.init(&[_]u8{});
    }
    pub fn getChromeMojoEventInfo(self: *const ChromeTrackEventReader) gremlin.Error!chrome_mojo_event_info.ChromeMojoEventInfoReader {
        if (self._chrome_mojo_event_info_buf) |buf| {
            return try chrome_mojo_event_info.ChromeMojoEventInfoReader.init(buf);
        }
        return try chrome_mojo_event_info.ChromeMojoEventInfoReader.init(&[_]u8{});
    }
    pub fn getLegacyEvent(self: *const ChromeTrackEventReader) gremlin.Error!track_event.TrackEvent.LegacyEventReader {
        if (self._legacy_event_buf) |buf| {
            return try track_event.TrackEvent.LegacyEventReader.init(buf);
        }
        return try track_event.TrackEvent.LegacyEventReader.init(&[_]u8{});
    }
    pub inline fn getNameIid(self: *const ChromeTrackEventReader) u64 {
        return self._name_iid;
    }
    pub inline fn getName(self: *const ChromeTrackEventReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub inline fn getCounterValue(self: *const ChromeTrackEventReader) i64 {
        return self._counter_value;
    }
    pub inline fn getDoubleCounterValue(self: *const ChromeTrackEventReader) f64 {
        return self._double_counter_value;
    }
    pub inline fn getCorrelationId(self: *const ChromeTrackEventReader) u64 {
        return self._correlation_id;
    }
    pub inline fn getCorrelationIdStr(self: *const ChromeTrackEventReader) []const u8 {
        return self._correlation_id_str orelse &[_]u8{};
    }
    pub inline fn getCorrelationIdStrIid(self: *const ChromeTrackEventReader) u64 {
        return self._correlation_id_str_iid;
    }
    pub fn getCallstack(self: *const ChromeTrackEventReader) gremlin.Error!track_event.TrackEvent.CallstackReader {
        if (self._callstack_buf) |buf| {
            return try track_event.TrackEvent.CallstackReader.init(buf);
        }
        return try track_event.TrackEvent.CallstackReader.init(&[_]u8{});
    }
    pub inline fn getCallstackIid(self: *const ChromeTrackEventReader) u64 {
        return self._callstack_iid;
    }
    pub fn getSourceLocation(self: *const ChromeTrackEventReader) gremlin.Error!source_location.SourceLocationReader {
        if (self._source_location_buf) |buf| {
            return try source_location.SourceLocationReader.init(buf);
        }
        return try source_location.SourceLocationReader.init(&[_]u8{});
    }
    pub inline fn getSourceLocationIid(self: *const ChromeTrackEventReader) u64 {
        return self._source_location_iid;
    }
    pub inline fn getTimestampDeltaUs(self: *const ChromeTrackEventReader) i64 {
        return self._timestamp_delta_us;
    }
    pub inline fn getTimestampAbsoluteUs(self: *const ChromeTrackEventReader) i64 {
        return self._timestamp_absolute_us;
    }
    pub inline fn getThreadTimeDeltaUs(self: *const ChromeTrackEventReader) i64 {
        return self._thread_time_delta_us;
    }
    pub inline fn getThreadTimeAbsoluteUs(self: *const ChromeTrackEventReader) i64 {
        return self._thread_time_absolute_us;
    }
    pub inline fn getThreadInstructionCountDelta(self: *const ChromeTrackEventReader) i64 {
        return self._thread_instruction_count_delta;
    }
    pub inline fn getThreadInstructionCountAbsolute(self: *const ChromeTrackEventReader) i64 {
        return self._thread_instruction_count_absolute;
    }
};
