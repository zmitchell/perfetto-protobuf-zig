// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const ProfileWire = struct {
    const SAMPLE_TYPE_WIRE: gremlin.ProtoWireNumber = 1;
    const SAMPLE_WIRE: gremlin.ProtoWireNumber = 2;
    const MAPPING_WIRE: gremlin.ProtoWireNumber = 3;
    const LOCATION_WIRE: gremlin.ProtoWireNumber = 4;
    const FUNCTION_WIRE: gremlin.ProtoWireNumber = 5;
    const STRING_TABLE_WIRE: gremlin.ProtoWireNumber = 6;
    const DROP_FRAMES_WIRE: gremlin.ProtoWireNumber = 7;
    const KEEP_FRAMES_WIRE: gremlin.ProtoWireNumber = 8;
    const TIME_NANOS_WIRE: gremlin.ProtoWireNumber = 9;
    const DURATION_NANOS_WIRE: gremlin.ProtoWireNumber = 10;
    const PERIOD_TYPE_WIRE: gremlin.ProtoWireNumber = 11;
    const PERIOD_WIRE: gremlin.ProtoWireNumber = 12;
    const COMMENT_WIRE: gremlin.ProtoWireNumber = 13;
    const DEFAULT_SAMPLE_TYPE_WIRE: gremlin.ProtoWireNumber = 14;
};
pub const Profile = struct {
    // fields
    sample_type: ?[]const ?ValueType = null,
    sample: ?[]const ?Sample = null,
    mapping: ?[]const ?Mapping = null,
    location: ?[]const ?Location = null,
    function: ?[]const ?Function = null,
    string_table: ?[]const ?[]const u8 = null,
    drop_frames: i64 = 0,
    keep_frames: i64 = 0,
    time_nanos: i64 = 0,
    duration_nanos: i64 = 0,
    period_type: ?ValueType = null,
    period: i64 = 0,
    comment: ?[]const i64 = null,
    default_sample_type: i64 = 0,
    pub fn calcProtobufSize(self: *const Profile) usize {
        var res: usize = 0;
        if (self.sample_type) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ProfileWire.SAMPLE_TYPE_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.sample) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ProfileWire.SAMPLE_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.mapping) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ProfileWire.MAPPING_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.location) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ProfileWire.LOCATION_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.function) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ProfileWire.FUNCTION_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.string_table) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ProfileWire.STRING_TABLE_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.drop_frames != 0) {
            res += gremlin.sizes.sizeWireNumber(ProfileWire.DROP_FRAMES_WIRE) + gremlin.sizes.sizeI64(self.drop_frames);
        }
        if (self.keep_frames != 0) {
            res += gremlin.sizes.sizeWireNumber(ProfileWire.KEEP_FRAMES_WIRE) + gremlin.sizes.sizeI64(self.keep_frames);
        }
        if (self.time_nanos != 0) {
            res += gremlin.sizes.sizeWireNumber(ProfileWire.TIME_NANOS_WIRE) + gremlin.sizes.sizeI64(self.time_nanos);
        }
        if (self.duration_nanos != 0) {
            res += gremlin.sizes.sizeWireNumber(ProfileWire.DURATION_NANOS_WIRE) + gremlin.sizes.sizeI64(self.duration_nanos);
        }
        if (self.period_type) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ProfileWire.PERIOD_TYPE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.period != 0) {
            res += gremlin.sizes.sizeWireNumber(ProfileWire.PERIOD_WIRE) + gremlin.sizes.sizeI64(self.period);
        }
        if (self.comment) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(ProfileWire.COMMENT_WIRE) + gremlin.sizes.sizeI64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI64(v);
                }
                res += gremlin.sizes.sizeWireNumber(ProfileWire.COMMENT_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.default_sample_type != 0) {
            res += gremlin.sizes.sizeWireNumber(ProfileWire.DEFAULT_SAMPLE_TYPE_WIRE) + gremlin.sizes.sizeI64(self.default_sample_type);
        }
        return res;
    }
    pub fn encode(self: *const Profile, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Profile, target: *gremlin.Writer) void {
        if (self.sample_type) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(ProfileWire.SAMPLE_TYPE_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(ProfileWire.SAMPLE_TYPE_WIRE, 0);
                }
            }
        }
        if (self.sample) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(ProfileWire.SAMPLE_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(ProfileWire.SAMPLE_WIRE, 0);
                }
            }
        }
        if (self.mapping) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(ProfileWire.MAPPING_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(ProfileWire.MAPPING_WIRE, 0);
                }
            }
        }
        if (self.location) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(ProfileWire.LOCATION_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(ProfileWire.LOCATION_WIRE, 0);
                }
            }
        }
        if (self.function) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(ProfileWire.FUNCTION_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(ProfileWire.FUNCTION_WIRE, 0);
                }
            }
        }
        if (self.string_table) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(ProfileWire.STRING_TABLE_WIRE, v);
                } else {
                    target.appendBytesTag(ProfileWire.STRING_TABLE_WIRE, 0);
                }
            }
        }
        if (self.drop_frames != 0) {
            target.appendInt64(ProfileWire.DROP_FRAMES_WIRE, self.drop_frames);
        }
        if (self.keep_frames != 0) {
            target.appendInt64(ProfileWire.KEEP_FRAMES_WIRE, self.keep_frames);
        }
        if (self.time_nanos != 0) {
            target.appendInt64(ProfileWire.TIME_NANOS_WIRE, self.time_nanos);
        }
        if (self.duration_nanos != 0) {
            target.appendInt64(ProfileWire.DURATION_NANOS_WIRE, self.duration_nanos);
        }
        if (self.period_type) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ProfileWire.PERIOD_TYPE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.period != 0) {
            target.appendInt64(ProfileWire.PERIOD_WIRE, self.period);
        }
        if (self.comment) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt64(ProfileWire.COMMENT_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI64(v);
                }
                target.appendBytesTag(ProfileWire.COMMENT_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt64WithoutTag(v);
                }
            }
        }
        if (self.default_sample_type != 0) {
            target.appendInt64(ProfileWire.DEFAULT_SAMPLE_TYPE_WIRE, self.default_sample_type);
        }
    }
};
pub const ProfileReader = struct {
    buf: gremlin.Reader,
    _sample_type_offset: ?usize = null,
    _sample_type_last_offset: ?usize = null,
    _sample_type_cnt: usize = 0,
    _sample_offset: ?usize = null,
    _sample_last_offset: ?usize = null,
    _sample_cnt: usize = 0,
    _mapping_offset: ?usize = null,
    _mapping_last_offset: ?usize = null,
    _mapping_cnt: usize = 0,
    _location_offset: ?usize = null,
    _location_last_offset: ?usize = null,
    _location_cnt: usize = 0,
    _function_offset: ?usize = null,
    _function_last_offset: ?usize = null,
    _function_cnt: usize = 0,
    _string_table_offset: ?usize = null,
    _string_table_last_offset: ?usize = null,
    _string_table_cnt: usize = 0,
    _drop_frames: i64 = 0,
    _keep_frames: i64 = 0,
    _time_nanos: i64 = 0,
    _duration_nanos: i64 = 0,
    _period_type_buf: ?[]const u8 = null,
    _period: i64 = 0,
    _comment_offset: ?usize = null,
    _comment_last_offset: ?usize = null,
    _comment_packed: bool = false,
    _default_sample_type: i64 = 0,
    pub fn init(src: []const u8) gremlin.Error!ProfileReader {
        const buf = gremlin.Reader.init(src);
        var res = ProfileReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ProfileWire.SAMPLE_TYPE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._sample_type_offset == null) {
                        res._sample_type_offset = offset - result.size;
                    }
                    res._sample_type_last_offset = offset;
                    res._sample_type_cnt += 1;
                },
                ProfileWire.SAMPLE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._sample_offset == null) {
                        res._sample_offset = offset - result.size;
                    }
                    res._sample_last_offset = offset;
                    res._sample_cnt += 1;
                },
                ProfileWire.MAPPING_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._mapping_offset == null) {
                        res._mapping_offset = offset - result.size;
                    }
                    res._mapping_last_offset = offset;
                    res._mapping_cnt += 1;
                },
                ProfileWire.LOCATION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._location_offset == null) {
                        res._location_offset = offset - result.size;
                    }
                    res._location_last_offset = offset;
                    res._location_cnt += 1;
                },
                ProfileWire.FUNCTION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._function_offset == null) {
                        res._function_offset = offset - result.size;
                    }
                    res._function_last_offset = offset;
                    res._function_cnt += 1;
                },
                ProfileWire.STRING_TABLE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._string_table_offset == null) {
                        res._string_table_offset = offset - result.size;
                    }
                    res._string_table_last_offset = offset;
                    res._string_table_cnt += 1;
                },
                ProfileWire.DROP_FRAMES_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._drop_frames = result.value;
                },
                ProfileWire.KEEP_FRAMES_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._keep_frames = result.value;
                },
                ProfileWire.TIME_NANOS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._time_nanos = result.value;
                },
                ProfileWire.DURATION_NANOS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._duration_nanos = result.value;
                },
                ProfileWire.PERIOD_TYPE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._period_type_buf = result.value;
                },
                ProfileWire.PERIOD_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._period = result.value;
                },
                ProfileWire.COMMENT_WIRE => {
                    if (res._comment_offset == null) {
                        res._comment_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._comment_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._comment_offset = offset + length_result.size;
                        res._comment_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._comment_last_offset.?;
                    } else {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._comment_last_offset = offset;
                    }
                },
                ProfileWire.DEFAULT_SAMPLE_TYPE_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._default_sample_type = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn sampleTypeCount(self: *const ProfileReader) usize {
        return self._sample_type_cnt;
    }
    pub fn sampleTypeNext(self: *ProfileReader) ?ValueTypeReader {
        if (self._sample_type_offset == null) return null;
        const current_offset = self._sample_type_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = ValueTypeReader.init(result.value) catch return null;
        if (self._sample_type_last_offset != null and current_offset >= self._sample_type_last_offset.?) {
            self._sample_type_offset = null;
            return msg;
        }
        if (self._sample_type_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._sample_type_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ProfileWire.SAMPLE_TYPE_WIRE) {
                self._sample_type_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._sample_type_offset = null;
        return msg;
    }
    pub fn sampleCount(self: *const ProfileReader) usize {
        return self._sample_cnt;
    }
    pub fn sampleNext(self: *ProfileReader) ?SampleReader {
        if (self._sample_offset == null) return null;
        const current_offset = self._sample_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = SampleReader.init(result.value) catch return null;
        if (self._sample_last_offset != null and current_offset >= self._sample_last_offset.?) {
            self._sample_offset = null;
            return msg;
        }
        if (self._sample_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._sample_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ProfileWire.SAMPLE_WIRE) {
                self._sample_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._sample_offset = null;
        return msg;
    }
    pub fn mappingCount(self: *const ProfileReader) usize {
        return self._mapping_cnt;
    }
    pub fn mappingNext(self: *ProfileReader) ?MappingReader {
        if (self._mapping_offset == null) return null;
        const current_offset = self._mapping_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = MappingReader.init(result.value) catch return null;
        if (self._mapping_last_offset != null and current_offset >= self._mapping_last_offset.?) {
            self._mapping_offset = null;
            return msg;
        }
        if (self._mapping_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._mapping_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ProfileWire.MAPPING_WIRE) {
                self._mapping_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._mapping_offset = null;
        return msg;
    }
    pub fn locationCount(self: *const ProfileReader) usize {
        return self._location_cnt;
    }
    pub fn locationNext(self: *ProfileReader) ?LocationReader {
        if (self._location_offset == null) return null;
        const current_offset = self._location_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = LocationReader.init(result.value) catch return null;
        if (self._location_last_offset != null and current_offset >= self._location_last_offset.?) {
            self._location_offset = null;
            return msg;
        }
        if (self._location_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._location_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ProfileWire.LOCATION_WIRE) {
                self._location_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._location_offset = null;
        return msg;
    }
    pub fn functionCount(self: *const ProfileReader) usize {
        return self._function_cnt;
    }
    pub fn functionNext(self: *ProfileReader) ?FunctionReader {
        if (self._function_offset == null) return null;
        const current_offset = self._function_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = FunctionReader.init(result.value) catch return null;
        if (self._function_last_offset != null and current_offset >= self._function_last_offset.?) {
            self._function_offset = null;
            return msg;
        }
        if (self._function_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._function_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ProfileWire.FUNCTION_WIRE) {
                self._function_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._function_offset = null;
        return msg;
    }
    pub fn stringTableCount(self: *const ProfileReader) usize {
        return self._string_table_cnt;
    }
    pub fn stringTableNext(self: *ProfileReader) ?[]const u8 {
        if (self._string_table_offset == null) return null;
        const current_offset = self._string_table_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._string_table_last_offset != null and current_offset >= self._string_table_last_offset.?) {
            self._string_table_offset = null;
            return result.value;
        }
        if (self._string_table_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._string_table_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ProfileWire.STRING_TABLE_WIRE) {
                self._string_table_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._string_table_offset = null;
        return result.value;
    }
    pub inline fn getDropFrames(self: *const ProfileReader) i64 {
        return self._drop_frames;
    }
    pub inline fn getKeepFrames(self: *const ProfileReader) i64 {
        return self._keep_frames;
    }
    pub inline fn getTimeNanos(self: *const ProfileReader) i64 {
        return self._time_nanos;
    }
    pub inline fn getDurationNanos(self: *const ProfileReader) i64 {
        return self._duration_nanos;
    }
    pub fn getPeriodType(self: *const ProfileReader) gremlin.Error!ValueTypeReader {
        if (self._period_type_buf) |buf| {
            return try ValueTypeReader.init(buf);
        }
        return try ValueTypeReader.init(&[_]u8{});
    }
    pub inline fn getPeriod(self: *const ProfileReader) i64 {
        return self._period;
    }
    pub fn commentNext(self: *ProfileReader) gremlin.Error!?i64 {
        if (self._comment_offset == null) return null;
        const current_offset = self._comment_offset.?;
        if (current_offset >= self._comment_last_offset.?) {
            self._comment_offset = null;
            return null;
        }
        if (self._comment_packed) {
            const value_result = try self.buf.readInt64(current_offset);
            self._comment_offset = current_offset + value_result.size;
            if (self._comment_offset.? >= self._comment_last_offset.?) {
                self._comment_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._comment_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == ProfileWire.COMMENT_WIRE) {
                    self._comment_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._comment_offset = null;
            return value_result.value;
        }
    }
    pub inline fn getDefaultSampleType(self: *const ProfileReader) i64 {
        return self._default_sample_type;
    }
};
const ValueTypeWire = struct {
    const TYPE_WIRE: gremlin.ProtoWireNumber = 1;
    const UNIT_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const ValueType = struct {
    // fields
    type: i64 = 0,
    unit: i64 = 0,
    pub fn calcProtobufSize(self: *const ValueType) usize {
        var res: usize = 0;
        if (self.type != 0) {
            res += gremlin.sizes.sizeWireNumber(ValueTypeWire.TYPE_WIRE) + gremlin.sizes.sizeI64(self.type);
        }
        if (self.unit != 0) {
            res += gremlin.sizes.sizeWireNumber(ValueTypeWire.UNIT_WIRE) + gremlin.sizes.sizeI64(self.unit);
        }
        return res;
    }
    pub fn encode(self: *const ValueType, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ValueType, target: *gremlin.Writer) void {
        if (self.type != 0) {
            target.appendInt64(ValueTypeWire.TYPE_WIRE, self.type);
        }
        if (self.unit != 0) {
            target.appendInt64(ValueTypeWire.UNIT_WIRE, self.unit);
        }
    }
};
pub const ValueTypeReader = struct {
    buf: gremlin.Reader,
    _type: i64 = 0,
    _unit: i64 = 0,
    pub fn init(src: []const u8) gremlin.Error!ValueTypeReader {
        const buf = gremlin.Reader.init(src);
        var res = ValueTypeReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ValueTypeWire.TYPE_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._type = result.value;
                },
                ValueTypeWire.UNIT_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._unit = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getType(self: *const ValueTypeReader) i64 {
        return self._type;
    }
    pub inline fn getUnit(self: *const ValueTypeReader) i64 {
        return self._unit;
    }
};
const SampleWire = struct {
    const LOCATION_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const VALUE_WIRE: gremlin.ProtoWireNumber = 2;
    const LABEL_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const Sample = struct {
    // fields
    location_id: ?[]const u64 = null,
    value: ?[]const i64 = null,
    label: ?[]const ?Label = null,
    pub fn calcProtobufSize(self: *const Sample) usize {
        var res: usize = 0;
        if (self.location_id) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(SampleWire.LOCATION_ID_WIRE) + gremlin.sizes.sizeU64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                res += gremlin.sizes.sizeWireNumber(SampleWire.LOCATION_ID_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.value) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(SampleWire.VALUE_WIRE) + gremlin.sizes.sizeI64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI64(v);
                }
                res += gremlin.sizes.sizeWireNumber(SampleWire.VALUE_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.label) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(SampleWire.LABEL_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const Sample, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Sample, target: *gremlin.Writer) void {
        if (self.location_id) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint64(SampleWire.LOCATION_ID_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                target.appendBytesTag(SampleWire.LOCATION_ID_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint64WithoutTag(v);
                }
            }
        }
        if (self.value) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt64(SampleWire.VALUE_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI64(v);
                }
                target.appendBytesTag(SampleWire.VALUE_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt64WithoutTag(v);
                }
            }
        }
        if (self.label) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(SampleWire.LABEL_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(SampleWire.LABEL_WIRE, 0);
                }
            }
        }
    }
};
pub const SampleReader = struct {
    buf: gremlin.Reader,
    _location_id_offset: ?usize = null,
    _location_id_last_offset: ?usize = null,
    _location_id_packed: bool = false,
    _value_offset: ?usize = null,
    _value_last_offset: ?usize = null,
    _value_packed: bool = false,
    _label_offset: ?usize = null,
    _label_last_offset: ?usize = null,
    _label_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!SampleReader {
        const buf = gremlin.Reader.init(src);
        var res = SampleReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SampleWire.LOCATION_ID_WIRE => {
                    if (res._location_id_offset == null) {
                        res._location_id_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._location_id_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._location_id_offset = offset + length_result.size;
                        res._location_id_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._location_id_last_offset.?;
                    } else {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._location_id_last_offset = offset;
                    }
                },
                SampleWire.VALUE_WIRE => {
                    if (res._value_offset == null) {
                        res._value_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._value_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._value_offset = offset + length_result.size;
                        res._value_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._value_last_offset.?;
                    } else {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._value_last_offset = offset;
                    }
                },
                SampleWire.LABEL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._label_offset == null) {
                        res._label_offset = offset - result.size;
                    }
                    res._label_last_offset = offset;
                    res._label_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn locationIdNext(self: *SampleReader) gremlin.Error!?u64 {
        if (self._location_id_offset == null) return null;
        const current_offset = self._location_id_offset.?;
        if (current_offset >= self._location_id_last_offset.?) {
            self._location_id_offset = null;
            return null;
        }
        if (self._location_id_packed) {
            const value_result = try self.buf.readUInt64(current_offset);
            self._location_id_offset = current_offset + value_result.size;
            if (self._location_id_offset.? >= self._location_id_last_offset.?) {
                self._location_id_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._location_id_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == SampleWire.LOCATION_ID_WIRE) {
                    self._location_id_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._location_id_offset = null;
            return value_result.value;
        }
    }
    pub fn valueNext(self: *SampleReader) gremlin.Error!?i64 {
        if (self._value_offset == null) return null;
        const current_offset = self._value_offset.?;
        if (current_offset >= self._value_last_offset.?) {
            self._value_offset = null;
            return null;
        }
        if (self._value_packed) {
            const value_result = try self.buf.readInt64(current_offset);
            self._value_offset = current_offset + value_result.size;
            if (self._value_offset.? >= self._value_last_offset.?) {
                self._value_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._value_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == SampleWire.VALUE_WIRE) {
                    self._value_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._value_offset = null;
            return value_result.value;
        }
    }
    pub fn labelCount(self: *const SampleReader) usize {
        return self._label_cnt;
    }
    pub fn labelNext(self: *SampleReader) ?LabelReader {
        if (self._label_offset == null) return null;
        const current_offset = self._label_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = LabelReader.init(result.value) catch return null;
        if (self._label_last_offset != null and current_offset >= self._label_last_offset.?) {
            self._label_offset = null;
            return msg;
        }
        if (self._label_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._label_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == SampleWire.LABEL_WIRE) {
                self._label_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._label_offset = null;
        return msg;
    }
};
const LabelWire = struct {
    const KEY_WIRE: gremlin.ProtoWireNumber = 1;
    const STR_WIRE: gremlin.ProtoWireNumber = 2;
    const NUM_WIRE: gremlin.ProtoWireNumber = 3;
    const NUM_UNIT_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const Label = struct {
    // fields
    key: i64 = 0,
    str: i64 = 0,
    num: i64 = 0,
    num_unit: i64 = 0,
    pub fn calcProtobufSize(self: *const Label) usize {
        var res: usize = 0;
        if (self.key != 0) {
            res += gremlin.sizes.sizeWireNumber(LabelWire.KEY_WIRE) + gremlin.sizes.sizeI64(self.key);
        }
        if (self.str != 0) {
            res += gremlin.sizes.sizeWireNumber(LabelWire.STR_WIRE) + gremlin.sizes.sizeI64(self.str);
        }
        if (self.num != 0) {
            res += gremlin.sizes.sizeWireNumber(LabelWire.NUM_WIRE) + gremlin.sizes.sizeI64(self.num);
        }
        if (self.num_unit != 0) {
            res += gremlin.sizes.sizeWireNumber(LabelWire.NUM_UNIT_WIRE) + gremlin.sizes.sizeI64(self.num_unit);
        }
        return res;
    }
    pub fn encode(self: *const Label, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Label, target: *gremlin.Writer) void {
        if (self.key != 0) {
            target.appendInt64(LabelWire.KEY_WIRE, self.key);
        }
        if (self.str != 0) {
            target.appendInt64(LabelWire.STR_WIRE, self.str);
        }
        if (self.num != 0) {
            target.appendInt64(LabelWire.NUM_WIRE, self.num);
        }
        if (self.num_unit != 0) {
            target.appendInt64(LabelWire.NUM_UNIT_WIRE, self.num_unit);
        }
    }
};
pub const LabelReader = struct {
    buf: gremlin.Reader,
    _key: i64 = 0,
    _str: i64 = 0,
    _num: i64 = 0,
    _num_unit: i64 = 0,
    pub fn init(src: []const u8) gremlin.Error!LabelReader {
        const buf = gremlin.Reader.init(src);
        var res = LabelReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                LabelWire.KEY_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._key = result.value;
                },
                LabelWire.STR_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._str = result.value;
                },
                LabelWire.NUM_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._num = result.value;
                },
                LabelWire.NUM_UNIT_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._num_unit = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getKey(self: *const LabelReader) i64 {
        return self._key;
    }
    pub inline fn getStr(self: *const LabelReader) i64 {
        return self._str;
    }
    pub inline fn getNum(self: *const LabelReader) i64 {
        return self._num;
    }
    pub inline fn getNumUnit(self: *const LabelReader) i64 {
        return self._num_unit;
    }
};
const MappingWire = struct {
    const ID_WIRE: gremlin.ProtoWireNumber = 1;
    const MEMORY_START_WIRE: gremlin.ProtoWireNumber = 2;
    const MEMORY_LIMIT_WIRE: gremlin.ProtoWireNumber = 3;
    const FILE_OFFSET_WIRE: gremlin.ProtoWireNumber = 4;
    const FILENAME_WIRE: gremlin.ProtoWireNumber = 5;
    const BUILD_ID_WIRE: gremlin.ProtoWireNumber = 6;
    const HAS_FUNCTIONS_WIRE: gremlin.ProtoWireNumber = 7;
    const HAS_FILENAMES_WIRE: gremlin.ProtoWireNumber = 8;
    const HAS_LINE_NUMBERS_WIRE: gremlin.ProtoWireNumber = 9;
    const HAS_INLINE_FRAMES_WIRE: gremlin.ProtoWireNumber = 10;
};
pub const Mapping = struct {
    // fields
    id: u64 = 0,
    memory_start: u64 = 0,
    memory_limit: u64 = 0,
    file_offset: u64 = 0,
    filename: i64 = 0,
    build_id: i64 = 0,
    has_functions: bool = false,
    has_filenames: bool = false,
    has_line_numbers: bool = false,
    has_inline_frames: bool = false,
    pub fn calcProtobufSize(self: *const Mapping) usize {
        var res: usize = 0;
        if (self.id != 0) {
            res += gremlin.sizes.sizeWireNumber(MappingWire.ID_WIRE) + gremlin.sizes.sizeU64(self.id);
        }
        if (self.memory_start != 0) {
            res += gremlin.sizes.sizeWireNumber(MappingWire.MEMORY_START_WIRE) + gremlin.sizes.sizeU64(self.memory_start);
        }
        if (self.memory_limit != 0) {
            res += gremlin.sizes.sizeWireNumber(MappingWire.MEMORY_LIMIT_WIRE) + gremlin.sizes.sizeU64(self.memory_limit);
        }
        if (self.file_offset != 0) {
            res += gremlin.sizes.sizeWireNumber(MappingWire.FILE_OFFSET_WIRE) + gremlin.sizes.sizeU64(self.file_offset);
        }
        if (self.filename != 0) {
            res += gremlin.sizes.sizeWireNumber(MappingWire.FILENAME_WIRE) + gremlin.sizes.sizeI64(self.filename);
        }
        if (self.build_id != 0) {
            res += gremlin.sizes.sizeWireNumber(MappingWire.BUILD_ID_WIRE) + gremlin.sizes.sizeI64(self.build_id);
        }
        if (self.has_functions != false) {
            res += gremlin.sizes.sizeWireNumber(MappingWire.HAS_FUNCTIONS_WIRE) + gremlin.sizes.sizeBool(self.has_functions);
        }
        if (self.has_filenames != false) {
            res += gremlin.sizes.sizeWireNumber(MappingWire.HAS_FILENAMES_WIRE) + gremlin.sizes.sizeBool(self.has_filenames);
        }
        if (self.has_line_numbers != false) {
            res += gremlin.sizes.sizeWireNumber(MappingWire.HAS_LINE_NUMBERS_WIRE) + gremlin.sizes.sizeBool(self.has_line_numbers);
        }
        if (self.has_inline_frames != false) {
            res += gremlin.sizes.sizeWireNumber(MappingWire.HAS_INLINE_FRAMES_WIRE) + gremlin.sizes.sizeBool(self.has_inline_frames);
        }
        return res;
    }
    pub fn encode(self: *const Mapping, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Mapping, target: *gremlin.Writer) void {
        if (self.id != 0) {
            target.appendUint64(MappingWire.ID_WIRE, self.id);
        }
        if (self.memory_start != 0) {
            target.appendUint64(MappingWire.MEMORY_START_WIRE, self.memory_start);
        }
        if (self.memory_limit != 0) {
            target.appendUint64(MappingWire.MEMORY_LIMIT_WIRE, self.memory_limit);
        }
        if (self.file_offset != 0) {
            target.appendUint64(MappingWire.FILE_OFFSET_WIRE, self.file_offset);
        }
        if (self.filename != 0) {
            target.appendInt64(MappingWire.FILENAME_WIRE, self.filename);
        }
        if (self.build_id != 0) {
            target.appendInt64(MappingWire.BUILD_ID_WIRE, self.build_id);
        }
        if (self.has_functions != false) {
            target.appendBool(MappingWire.HAS_FUNCTIONS_WIRE, self.has_functions);
        }
        if (self.has_filenames != false) {
            target.appendBool(MappingWire.HAS_FILENAMES_WIRE, self.has_filenames);
        }
        if (self.has_line_numbers != false) {
            target.appendBool(MappingWire.HAS_LINE_NUMBERS_WIRE, self.has_line_numbers);
        }
        if (self.has_inline_frames != false) {
            target.appendBool(MappingWire.HAS_INLINE_FRAMES_WIRE, self.has_inline_frames);
        }
    }
};
pub const MappingReader = struct {
    buf: gremlin.Reader,
    _id: u64 = 0,
    _memory_start: u64 = 0,
    _memory_limit: u64 = 0,
    _file_offset: u64 = 0,
    _filename: i64 = 0,
    _build_id: i64 = 0,
    _has_functions: bool = false,
    _has_filenames: bool = false,
    _has_line_numbers: bool = false,
    _has_inline_frames: bool = false,
    pub fn init(src: []const u8) gremlin.Error!MappingReader {
        const buf = gremlin.Reader.init(src);
        var res = MappingReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MappingWire.ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._id = result.value;
                },
                MappingWire.MEMORY_START_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._memory_start = result.value;
                },
                MappingWire.MEMORY_LIMIT_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._memory_limit = result.value;
                },
                MappingWire.FILE_OFFSET_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._file_offset = result.value;
                },
                MappingWire.FILENAME_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._filename = result.value;
                },
                MappingWire.BUILD_ID_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._build_id = result.value;
                },
                MappingWire.HAS_FUNCTIONS_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._has_functions = result.value;
                },
                MappingWire.HAS_FILENAMES_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._has_filenames = result.value;
                },
                MappingWire.HAS_LINE_NUMBERS_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._has_line_numbers = result.value;
                },
                MappingWire.HAS_INLINE_FRAMES_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._has_inline_frames = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getId(self: *const MappingReader) u64 {
        return self._id;
    }
    pub inline fn getMemoryStart(self: *const MappingReader) u64 {
        return self._memory_start;
    }
    pub inline fn getMemoryLimit(self: *const MappingReader) u64 {
        return self._memory_limit;
    }
    pub inline fn getFileOffset(self: *const MappingReader) u64 {
        return self._file_offset;
    }
    pub inline fn getFilename(self: *const MappingReader) i64 {
        return self._filename;
    }
    pub inline fn getBuildId(self: *const MappingReader) i64 {
        return self._build_id;
    }
    pub inline fn getHasFunctions(self: *const MappingReader) bool {
        return self._has_functions;
    }
    pub inline fn getHasFilenames(self: *const MappingReader) bool {
        return self._has_filenames;
    }
    pub inline fn getHasLineNumbers(self: *const MappingReader) bool {
        return self._has_line_numbers;
    }
    pub inline fn getHasInlineFrames(self: *const MappingReader) bool {
        return self._has_inline_frames;
    }
};
const LocationWire = struct {
    const ID_WIRE: gremlin.ProtoWireNumber = 1;
    const MAPPING_ID_WIRE: gremlin.ProtoWireNumber = 2;
    const ADDRESS_WIRE: gremlin.ProtoWireNumber = 3;
    const LINE_WIRE: gremlin.ProtoWireNumber = 4;
    const IS_FOLDED_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const Location = struct {
    // fields
    id: u64 = 0,
    mapping_id: u64 = 0,
    address: u64 = 0,
    line: ?[]const ?Line = null,
    is_folded: bool = false,
    pub fn calcProtobufSize(self: *const Location) usize {
        var res: usize = 0;
        if (self.id != 0) {
            res += gremlin.sizes.sizeWireNumber(LocationWire.ID_WIRE) + gremlin.sizes.sizeU64(self.id);
        }
        if (self.mapping_id != 0) {
            res += gremlin.sizes.sizeWireNumber(LocationWire.MAPPING_ID_WIRE) + gremlin.sizes.sizeU64(self.mapping_id);
        }
        if (self.address != 0) {
            res += gremlin.sizes.sizeWireNumber(LocationWire.ADDRESS_WIRE) + gremlin.sizes.sizeU64(self.address);
        }
        if (self.line) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(LocationWire.LINE_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.is_folded != false) {
            res += gremlin.sizes.sizeWireNumber(LocationWire.IS_FOLDED_WIRE) + gremlin.sizes.sizeBool(self.is_folded);
        }
        return res;
    }
    pub fn encode(self: *const Location, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Location, target: *gremlin.Writer) void {
        if (self.id != 0) {
            target.appendUint64(LocationWire.ID_WIRE, self.id);
        }
        if (self.mapping_id != 0) {
            target.appendUint64(LocationWire.MAPPING_ID_WIRE, self.mapping_id);
        }
        if (self.address != 0) {
            target.appendUint64(LocationWire.ADDRESS_WIRE, self.address);
        }
        if (self.line) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(LocationWire.LINE_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(LocationWire.LINE_WIRE, 0);
                }
            }
        }
        if (self.is_folded != false) {
            target.appendBool(LocationWire.IS_FOLDED_WIRE, self.is_folded);
        }
    }
};
pub const LocationReader = struct {
    buf: gremlin.Reader,
    _id: u64 = 0,
    _mapping_id: u64 = 0,
    _address: u64 = 0,
    _line_offset: ?usize = null,
    _line_last_offset: ?usize = null,
    _line_cnt: usize = 0,
    _is_folded: bool = false,
    pub fn init(src: []const u8) gremlin.Error!LocationReader {
        const buf = gremlin.Reader.init(src);
        var res = LocationReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                LocationWire.ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._id = result.value;
                },
                LocationWire.MAPPING_ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._mapping_id = result.value;
                },
                LocationWire.ADDRESS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._address = result.value;
                },
                LocationWire.LINE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._line_offset == null) {
                        res._line_offset = offset - result.size;
                    }
                    res._line_last_offset = offset;
                    res._line_cnt += 1;
                },
                LocationWire.IS_FOLDED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_folded = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getId(self: *const LocationReader) u64 {
        return self._id;
    }
    pub inline fn getMappingId(self: *const LocationReader) u64 {
        return self._mapping_id;
    }
    pub inline fn getAddress(self: *const LocationReader) u64 {
        return self._address;
    }
    pub fn lineCount(self: *const LocationReader) usize {
        return self._line_cnt;
    }
    pub fn lineNext(self: *LocationReader) ?LineReader {
        if (self._line_offset == null) return null;
        const current_offset = self._line_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = LineReader.init(result.value) catch return null;
        if (self._line_last_offset != null and current_offset >= self._line_last_offset.?) {
            self._line_offset = null;
            return msg;
        }
        if (self._line_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._line_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == LocationWire.LINE_WIRE) {
                self._line_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._line_offset = null;
        return msg;
    }
    pub inline fn getIsFolded(self: *const LocationReader) bool {
        return self._is_folded;
    }
};
const LineWire = struct {
    const FUNCTION_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const LINE_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const Line = struct {
    // fields
    function_id: u64 = 0,
    line: i64 = 0,
    pub fn calcProtobufSize(self: *const Line) usize {
        var res: usize = 0;
        if (self.function_id != 0) {
            res += gremlin.sizes.sizeWireNumber(LineWire.FUNCTION_ID_WIRE) + gremlin.sizes.sizeU64(self.function_id);
        }
        if (self.line != 0) {
            res += gremlin.sizes.sizeWireNumber(LineWire.LINE_WIRE) + gremlin.sizes.sizeI64(self.line);
        }
        return res;
    }
    pub fn encode(self: *const Line, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Line, target: *gremlin.Writer) void {
        if (self.function_id != 0) {
            target.appendUint64(LineWire.FUNCTION_ID_WIRE, self.function_id);
        }
        if (self.line != 0) {
            target.appendInt64(LineWire.LINE_WIRE, self.line);
        }
    }
};
pub const LineReader = struct {
    buf: gremlin.Reader,
    _function_id: u64 = 0,
    _line: i64 = 0,
    pub fn init(src: []const u8) gremlin.Error!LineReader {
        const buf = gremlin.Reader.init(src);
        var res = LineReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                LineWire.FUNCTION_ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._function_id = result.value;
                },
                LineWire.LINE_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._line = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getFunctionId(self: *const LineReader) u64 {
        return self._function_id;
    }
    pub inline fn getLine(self: *const LineReader) i64 {
        return self._line;
    }
};
const FunctionWire = struct {
    const ID_WIRE: gremlin.ProtoWireNumber = 1;
    const NAME_WIRE: gremlin.ProtoWireNumber = 2;
    const SYSTEM_NAME_WIRE: gremlin.ProtoWireNumber = 3;
    const FILENAME_WIRE: gremlin.ProtoWireNumber = 4;
    const START_LINE_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const Function = struct {
    // fields
    id: u64 = 0,
    name: i64 = 0,
    system_name: i64 = 0,
    filename: i64 = 0,
    start_line: i64 = 0,
    pub fn calcProtobufSize(self: *const Function) usize {
        var res: usize = 0;
        if (self.id != 0) {
            res += gremlin.sizes.sizeWireNumber(FunctionWire.ID_WIRE) + gremlin.sizes.sizeU64(self.id);
        }
        if (self.name != 0) {
            res += gremlin.sizes.sizeWireNumber(FunctionWire.NAME_WIRE) + gremlin.sizes.sizeI64(self.name);
        }
        if (self.system_name != 0) {
            res += gremlin.sizes.sizeWireNumber(FunctionWire.SYSTEM_NAME_WIRE) + gremlin.sizes.sizeI64(self.system_name);
        }
        if (self.filename != 0) {
            res += gremlin.sizes.sizeWireNumber(FunctionWire.FILENAME_WIRE) + gremlin.sizes.sizeI64(self.filename);
        }
        if (self.start_line != 0) {
            res += gremlin.sizes.sizeWireNumber(FunctionWire.START_LINE_WIRE) + gremlin.sizes.sizeI64(self.start_line);
        }
        return res;
    }
    pub fn encode(self: *const Function, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Function, target: *gremlin.Writer) void {
        if (self.id != 0) {
            target.appendUint64(FunctionWire.ID_WIRE, self.id);
        }
        if (self.name != 0) {
            target.appendInt64(FunctionWire.NAME_WIRE, self.name);
        }
        if (self.system_name != 0) {
            target.appendInt64(FunctionWire.SYSTEM_NAME_WIRE, self.system_name);
        }
        if (self.filename != 0) {
            target.appendInt64(FunctionWire.FILENAME_WIRE, self.filename);
        }
        if (self.start_line != 0) {
            target.appendInt64(FunctionWire.START_LINE_WIRE, self.start_line);
        }
    }
};
pub const FunctionReader = struct {
    buf: gremlin.Reader,
    _id: u64 = 0,
    _name: i64 = 0,
    _system_name: i64 = 0,
    _filename: i64 = 0,
    _start_line: i64 = 0,
    pub fn init(src: []const u8) gremlin.Error!FunctionReader {
        const buf = gremlin.Reader.init(src);
        var res = FunctionReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                FunctionWire.ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._id = result.value;
                },
                FunctionWire.NAME_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                FunctionWire.SYSTEM_NAME_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._system_name = result.value;
                },
                FunctionWire.FILENAME_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._filename = result.value;
                },
                FunctionWire.START_LINE_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._start_line = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getId(self: *const FunctionReader) u64 {
        return self._id;
    }
    pub inline fn getName(self: *const FunctionReader) i64 {
        return self._name;
    }
    pub inline fn getSystemName(self: *const FunctionReader) i64 {
        return self._system_name;
    }
    pub inline fn getFilename(self: *const FunctionReader) i64 {
        return self._filename;
    }
    pub inline fn getStartLine(self: *const FunctionReader) i64 {
        return self._start_line;
    }
};
