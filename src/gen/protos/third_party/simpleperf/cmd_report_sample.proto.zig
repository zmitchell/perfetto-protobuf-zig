// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const SampleWire = struct {
    const TIME_WIRE: gremlin.ProtoWireNumber = 1;
    const THREAD_ID_WIRE: gremlin.ProtoWireNumber = 2;
    const CALLCHAIN_WIRE: gremlin.ProtoWireNumber = 3;
    const EVENT_COUNT_WIRE: gremlin.ProtoWireNumber = 4;
    const EVENT_TYPE_ID_WIRE: gremlin.ProtoWireNumber = 5;
    const UNWINDING_RESULT_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const Sample = struct {
    // nested structs
    const CallChainEntryWire = struct {
        const VADDR_IN_FILE_WIRE: gremlin.ProtoWireNumber = 1;
        const FILE_ID_WIRE: gremlin.ProtoWireNumber = 2;
        const SYMBOL_ID_WIRE: gremlin.ProtoWireNumber = 3;
        const EXECUTION_TYPE_WIRE: gremlin.ProtoWireNumber = 4;
    };
    pub const CallChainEntry = struct {
        // nested enums
        pub const ExecutionType = enum(i32) {
            NATIVE_METHOD = 0,
            INTERPRETED_JVM_METHOD = 1,
            JIT_JVM_METHOD = 2,
            ART_METHOD = 3,
        };
        // fields
        vaddr_in_file: u64 = 0,
        file_id: u32 = 0,
        symbol_id: i32 = 0,
        execution_type: Sample.CallChainEntry.ExecutionType = @enumFromInt(0),
        pub fn calcProtobufSize(self: *const Sample.CallChainEntry) usize {
            var res: usize = 0;
            if (self.vaddr_in_file != 0) {
                res += gremlin.sizes.sizeWireNumber(Sample.CallChainEntryWire.VADDR_IN_FILE_WIRE) + gremlin.sizes.sizeU64(self.vaddr_in_file);
            }
            if (self.file_id != 0) {
                res += gremlin.sizes.sizeWireNumber(Sample.CallChainEntryWire.FILE_ID_WIRE) + gremlin.sizes.sizeU32(self.file_id);
            }
            if (self.symbol_id != 0) {
                res += gremlin.sizes.sizeWireNumber(Sample.CallChainEntryWire.SYMBOL_ID_WIRE) + gremlin.sizes.sizeI32(self.symbol_id);
            }
            if (@intFromEnum(self.execution_type) != 0) {
                res += gremlin.sizes.sizeWireNumber(Sample.CallChainEntryWire.EXECUTION_TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.execution_type));
            }
            return res;
        }
        pub fn encode(self: *const Sample.CallChainEntry, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const Sample.CallChainEntry, target: *gremlin.Writer) void {
            if (self.vaddr_in_file != 0) {
                target.appendUint64(Sample.CallChainEntryWire.VADDR_IN_FILE_WIRE, self.vaddr_in_file);
            }
            if (self.file_id != 0) {
                target.appendUint32(Sample.CallChainEntryWire.FILE_ID_WIRE, self.file_id);
            }
            if (self.symbol_id != 0) {
                target.appendInt32(Sample.CallChainEntryWire.SYMBOL_ID_WIRE, self.symbol_id);
            }
            if (@intFromEnum(self.execution_type) != 0) {
                target.appendInt32(Sample.CallChainEntryWire.EXECUTION_TYPE_WIRE, @intFromEnum(self.execution_type));
            }
        }
    };
    pub const CallChainEntryReader = struct {
        buf: gremlin.Reader,
        _vaddr_in_file: u64 = 0,
        _file_id: u32 = 0,
        _symbol_id: i32 = 0,
        _execution_type: Sample.CallChainEntry.ExecutionType = @enumFromInt(0),
        pub fn init(src: []const u8) gremlin.Error!Sample.CallChainEntryReader {
            const buf = gremlin.Reader.init(src);
            var res = Sample.CallChainEntryReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    Sample.CallChainEntryWire.VADDR_IN_FILE_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._vaddr_in_file = result.value;
                    },
                    Sample.CallChainEntryWire.FILE_ID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._file_id = result.value;
                    },
                    Sample.CallChainEntryWire.SYMBOL_ID_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._symbol_id = result.value;
                    },
                    Sample.CallChainEntryWire.EXECUTION_TYPE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._execution_type = @enumFromInt(result.value);
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getVaddrInFile(self: *const Sample.CallChainEntryReader) u64 {
            return self._vaddr_in_file;
        }
        pub inline fn getFileId(self: *const Sample.CallChainEntryReader) u32 {
            return self._file_id;
        }
        pub inline fn getSymbolId(self: *const Sample.CallChainEntryReader) i32 {
            return self._symbol_id;
        }
        pub inline fn getExecutionType(self: *const Sample.CallChainEntryReader) Sample.CallChainEntry.ExecutionType {
            return self._execution_type;
        }
    };
    const UnwindingResultWire = struct {
        const RAW_ERROR_CODE_WIRE: gremlin.ProtoWireNumber = 1;
        const ERROR_ADDR_WIRE: gremlin.ProtoWireNumber = 2;
        const ERROR_CODE_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const UnwindingResult = struct {
        // nested enums
        pub const ErrorCode = enum(i32) {
            ERROR_NONE = 0,
            ERROR_UNKNOWN = 1,
            ERROR_NOT_ENOUGH_STACK = 2,
            ERROR_MEMORY_INVALID = 3,
            ERROR_UNWIND_INFO = 4,
            ERROR_INVALID_MAP = 5,
            ERROR_MAX_FRAME_EXCEEDED = 6,
            ERROR_REPEATED_FRAME = 7,
            ERROR_INVALID_ELF = 8,
        };
        // fields
        raw_error_code: u32 = 0,
        error_addr: u64 = 0,
        error_code: Sample.UnwindingResult.ErrorCode = @enumFromInt(0),
        pub fn calcProtobufSize(self: *const Sample.UnwindingResult) usize {
            var res: usize = 0;
            if (self.raw_error_code != 0) {
                res += gremlin.sizes.sizeWireNumber(Sample.UnwindingResultWire.RAW_ERROR_CODE_WIRE) + gremlin.sizes.sizeU32(self.raw_error_code);
            }
            if (self.error_addr != 0) {
                res += gremlin.sizes.sizeWireNumber(Sample.UnwindingResultWire.ERROR_ADDR_WIRE) + gremlin.sizes.sizeU64(self.error_addr);
            }
            if (@intFromEnum(self.error_code) != 0) {
                res += gremlin.sizes.sizeWireNumber(Sample.UnwindingResultWire.ERROR_CODE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.error_code));
            }
            return res;
        }
        pub fn encode(self: *const Sample.UnwindingResult, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const Sample.UnwindingResult, target: *gremlin.Writer) void {
            if (self.raw_error_code != 0) {
                target.appendUint32(Sample.UnwindingResultWire.RAW_ERROR_CODE_WIRE, self.raw_error_code);
            }
            if (self.error_addr != 0) {
                target.appendUint64(Sample.UnwindingResultWire.ERROR_ADDR_WIRE, self.error_addr);
            }
            if (@intFromEnum(self.error_code) != 0) {
                target.appendInt32(Sample.UnwindingResultWire.ERROR_CODE_WIRE, @intFromEnum(self.error_code));
            }
        }
    };
    pub const UnwindingResultReader = struct {
        buf: gremlin.Reader,
        _raw_error_code: u32 = 0,
        _error_addr: u64 = 0,
        _error_code: Sample.UnwindingResult.ErrorCode = @enumFromInt(0),
        pub fn init(src: []const u8) gremlin.Error!Sample.UnwindingResultReader {
            const buf = gremlin.Reader.init(src);
            var res = Sample.UnwindingResultReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    Sample.UnwindingResultWire.RAW_ERROR_CODE_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._raw_error_code = result.value;
                    },
                    Sample.UnwindingResultWire.ERROR_ADDR_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._error_addr = result.value;
                    },
                    Sample.UnwindingResultWire.ERROR_CODE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._error_code = @enumFromInt(result.value);
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getRawErrorCode(self: *const Sample.UnwindingResultReader) u32 {
            return self._raw_error_code;
        }
        pub inline fn getErrorAddr(self: *const Sample.UnwindingResultReader) u64 {
            return self._error_addr;
        }
        pub inline fn getErrorCode(self: *const Sample.UnwindingResultReader) Sample.UnwindingResult.ErrorCode {
            return self._error_code;
        }
    };
    // fields
    time: u64 = 0,
    thread_id: i32 = 0,
    callchain: ?[]const ?Sample.CallChainEntry = null,
    event_count: u64 = 0,
    event_type_id: u32 = 0,
    unwinding_result: ?Sample.UnwindingResult = null,
    pub fn calcProtobufSize(self: *const Sample) usize {
        var res: usize = 0;
        if (self.time != 0) {
            res += gremlin.sizes.sizeWireNumber(SampleWire.TIME_WIRE) + gremlin.sizes.sizeU64(self.time);
        }
        if (self.thread_id != 0) {
            res += gremlin.sizes.sizeWireNumber(SampleWire.THREAD_ID_WIRE) + gremlin.sizes.sizeI32(self.thread_id);
        }
        if (self.callchain) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(SampleWire.CALLCHAIN_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.event_count != 0) {
            res += gremlin.sizes.sizeWireNumber(SampleWire.EVENT_COUNT_WIRE) + gremlin.sizes.sizeU64(self.event_count);
        }
        if (self.event_type_id != 0) {
            res += gremlin.sizes.sizeWireNumber(SampleWire.EVENT_TYPE_ID_WIRE) + gremlin.sizes.sizeU32(self.event_type_id);
        }
        if (self.unwinding_result) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(SampleWire.UNWINDING_RESULT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const Sample, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Sample, target: *gremlin.Writer) void {
        if (self.time != 0) {
            target.appendUint64(SampleWire.TIME_WIRE, self.time);
        }
        if (self.thread_id != 0) {
            target.appendInt32(SampleWire.THREAD_ID_WIRE, self.thread_id);
        }
        if (self.callchain) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(SampleWire.CALLCHAIN_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(SampleWire.CALLCHAIN_WIRE, 0);
                }
            }
        }
        if (self.event_count != 0) {
            target.appendUint64(SampleWire.EVENT_COUNT_WIRE, self.event_count);
        }
        if (self.event_type_id != 0) {
            target.appendUint32(SampleWire.EVENT_TYPE_ID_WIRE, self.event_type_id);
        }
        if (self.unwinding_result) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(SampleWire.UNWINDING_RESULT_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const SampleReader = struct {
    buf: gremlin.Reader,
    _time: u64 = 0,
    _thread_id: i32 = 0,
    _callchain_offset: ?usize = null,
    _callchain_last_offset: ?usize = null,
    _callchain_cnt: usize = 0,
    _event_count: u64 = 0,
    _event_type_id: u32 = 0,
    _unwinding_result_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!SampleReader {
        const buf = gremlin.Reader.init(src);
        var res = SampleReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SampleWire.TIME_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._time = result.value;
                },
                SampleWire.THREAD_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._thread_id = result.value;
                },
                SampleWire.CALLCHAIN_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._callchain_offset == null) {
                        res._callchain_offset = offset - result.size;
                    }
                    res._callchain_last_offset = offset;
                    res._callchain_cnt += 1;
                },
                SampleWire.EVENT_COUNT_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._event_count = result.value;
                },
                SampleWire.EVENT_TYPE_ID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._event_type_id = result.value;
                },
                SampleWire.UNWINDING_RESULT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._unwinding_result_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getTime(self: *const SampleReader) u64 {
        return self._time;
    }
    pub inline fn getThreadId(self: *const SampleReader) i32 {
        return self._thread_id;
    }
    pub fn callchainCount(self: *const SampleReader) usize {
        return self._callchain_cnt;
    }
    pub fn callchainNext(self: *SampleReader) ?Sample.CallChainEntryReader {
        if (self._callchain_offset == null) return null;
        const current_offset = self._callchain_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = Sample.CallChainEntryReader.init(result.value) catch return null;
        if (self._callchain_last_offset != null and current_offset >= self._callchain_last_offset.?) {
            self._callchain_offset = null;
            return msg;
        }
        if (self._callchain_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._callchain_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == SampleWire.CALLCHAIN_WIRE) {
                self._callchain_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._callchain_offset = null;
        return msg;
    }
    pub inline fn getEventCount(self: *const SampleReader) u64 {
        return self._event_count;
    }
    pub inline fn getEventTypeId(self: *const SampleReader) u32 {
        return self._event_type_id;
    }
    pub fn getUnwindingResult(self: *const SampleReader) gremlin.Error!Sample.UnwindingResultReader {
        if (self._unwinding_result_buf) |buf| {
            return try Sample.UnwindingResultReader.init(buf);
        }
        return try Sample.UnwindingResultReader.init(&[_]u8{});
    }
};
const LostSituationWire = struct {
    const SAMPLE_COUNT_WIRE: gremlin.ProtoWireNumber = 1;
    const LOST_COUNT_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const LostSituation = struct {
    // fields
    sample_count: u64 = 0,
    lost_count: u64 = 0,
    pub fn calcProtobufSize(self: *const LostSituation) usize {
        var res: usize = 0;
        if (self.sample_count != 0) {
            res += gremlin.sizes.sizeWireNumber(LostSituationWire.SAMPLE_COUNT_WIRE) + gremlin.sizes.sizeU64(self.sample_count);
        }
        if (self.lost_count != 0) {
            res += gremlin.sizes.sizeWireNumber(LostSituationWire.LOST_COUNT_WIRE) + gremlin.sizes.sizeU64(self.lost_count);
        }
        return res;
    }
    pub fn encode(self: *const LostSituation, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const LostSituation, target: *gremlin.Writer) void {
        if (self.sample_count != 0) {
            target.appendUint64(LostSituationWire.SAMPLE_COUNT_WIRE, self.sample_count);
        }
        if (self.lost_count != 0) {
            target.appendUint64(LostSituationWire.LOST_COUNT_WIRE, self.lost_count);
        }
    }
};
pub const LostSituationReader = struct {
    buf: gremlin.Reader,
    _sample_count: u64 = 0,
    _lost_count: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!LostSituationReader {
        const buf = gremlin.Reader.init(src);
        var res = LostSituationReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                LostSituationWire.SAMPLE_COUNT_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._sample_count = result.value;
                },
                LostSituationWire.LOST_COUNT_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._lost_count = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getSampleCount(self: *const LostSituationReader) u64 {
        return self._sample_count;
    }
    pub inline fn getLostCount(self: *const LostSituationReader) u64 {
        return self._lost_count;
    }
};
const FileWire = struct {
    const ID_WIRE: gremlin.ProtoWireNumber = 1;
    const PATH_WIRE: gremlin.ProtoWireNumber = 2;
    const SYMBOL_WIRE: gremlin.ProtoWireNumber = 3;
    const MANGLED_SYMBOL_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const File = struct {
    // fields
    id: u32 = 0,
    path: ?[]const u8 = null,
    symbol: ?[]const ?[]const u8 = null,
    mangled_symbol: ?[]const ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const File) usize {
        var res: usize = 0;
        if (self.id != 0) {
            res += gremlin.sizes.sizeWireNumber(FileWire.ID_WIRE) + gremlin.sizes.sizeU32(self.id);
        }
        if (self.path) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(FileWire.PATH_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.symbol) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(FileWire.SYMBOL_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.mangled_symbol) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(FileWire.MANGLED_SYMBOL_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const File, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const File, target: *gremlin.Writer) void {
        if (self.id != 0) {
            target.appendUint32(FileWire.ID_WIRE, self.id);
        }
        if (self.path) |v| {
            if (v.len > 0) {
                target.appendBytes(FileWire.PATH_WIRE, v);
            }
        }
        if (self.symbol) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(FileWire.SYMBOL_WIRE, v);
                } else {
                    target.appendBytesTag(FileWire.SYMBOL_WIRE, 0);
                }
            }
        }
        if (self.mangled_symbol) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(FileWire.MANGLED_SYMBOL_WIRE, v);
                } else {
                    target.appendBytesTag(FileWire.MANGLED_SYMBOL_WIRE, 0);
                }
            }
        }
    }
};
pub const FileReader = struct {
    buf: gremlin.Reader,
    _id: u32 = 0,
    _path: ?[]const u8 = null,
    _symbol_offset: ?usize = null,
    _symbol_last_offset: ?usize = null,
    _symbol_cnt: usize = 0,
    _mangled_symbol_offset: ?usize = null,
    _mangled_symbol_last_offset: ?usize = null,
    _mangled_symbol_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!FileReader {
        const buf = gremlin.Reader.init(src);
        var res = FileReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                FileWire.ID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._id = result.value;
                },
                FileWire.PATH_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._path = result.value;
                },
                FileWire.SYMBOL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._symbol_offset == null) {
                        res._symbol_offset = offset - result.size;
                    }
                    res._symbol_last_offset = offset;
                    res._symbol_cnt += 1;
                },
                FileWire.MANGLED_SYMBOL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._mangled_symbol_offset == null) {
                        res._mangled_symbol_offset = offset - result.size;
                    }
                    res._mangled_symbol_last_offset = offset;
                    res._mangled_symbol_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getId(self: *const FileReader) u32 {
        return self._id;
    }
    pub inline fn getPath(self: *const FileReader) []const u8 {
        return self._path orelse &[_]u8{};
    }
    pub fn symbolCount(self: *const FileReader) usize {
        return self._symbol_cnt;
    }
    pub fn symbolNext(self: *FileReader) ?[]const u8 {
        if (self._symbol_offset == null) return null;
        const current_offset = self._symbol_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._symbol_last_offset != null and current_offset >= self._symbol_last_offset.?) {
            self._symbol_offset = null;
            return result.value;
        }
        if (self._symbol_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._symbol_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == FileWire.SYMBOL_WIRE) {
                self._symbol_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._symbol_offset = null;
        return result.value;
    }
    pub fn mangledSymbolCount(self: *const FileReader) usize {
        return self._mangled_symbol_cnt;
    }
    pub fn mangledSymbolNext(self: *FileReader) ?[]const u8 {
        if (self._mangled_symbol_offset == null) return null;
        const current_offset = self._mangled_symbol_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._mangled_symbol_last_offset != null and current_offset >= self._mangled_symbol_last_offset.?) {
            self._mangled_symbol_offset = null;
            return result.value;
        }
        if (self._mangled_symbol_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._mangled_symbol_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == FileWire.MANGLED_SYMBOL_WIRE) {
                self._mangled_symbol_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._mangled_symbol_offset = null;
        return result.value;
    }
};
const ThreadWire = struct {
    const THREAD_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const PROCESS_ID_WIRE: gremlin.ProtoWireNumber = 2;
    const THREAD_NAME_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const Thread = struct {
    // fields
    thread_id: u32 = 0,
    process_id: u32 = 0,
    thread_name: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const Thread) usize {
        var res: usize = 0;
        if (self.thread_id != 0) {
            res += gremlin.sizes.sizeWireNumber(ThreadWire.THREAD_ID_WIRE) + gremlin.sizes.sizeU32(self.thread_id);
        }
        if (self.process_id != 0) {
            res += gremlin.sizes.sizeWireNumber(ThreadWire.PROCESS_ID_WIRE) + gremlin.sizes.sizeU32(self.process_id);
        }
        if (self.thread_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(ThreadWire.THREAD_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const Thread, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Thread, target: *gremlin.Writer) void {
        if (self.thread_id != 0) {
            target.appendUint32(ThreadWire.THREAD_ID_WIRE, self.thread_id);
        }
        if (self.process_id != 0) {
            target.appendUint32(ThreadWire.PROCESS_ID_WIRE, self.process_id);
        }
        if (self.thread_name) |v| {
            if (v.len > 0) {
                target.appendBytes(ThreadWire.THREAD_NAME_WIRE, v);
            }
        }
    }
};
pub const ThreadReader = struct {
    buf: gremlin.Reader,
    _thread_id: u32 = 0,
    _process_id: u32 = 0,
    _thread_name: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!ThreadReader {
        const buf = gremlin.Reader.init(src);
        var res = ThreadReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ThreadWire.THREAD_ID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._thread_id = result.value;
                },
                ThreadWire.PROCESS_ID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._process_id = result.value;
                },
                ThreadWire.THREAD_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._thread_name = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getThreadId(self: *const ThreadReader) u32 {
        return self._thread_id;
    }
    pub inline fn getProcessId(self: *const ThreadReader) u32 {
        return self._process_id;
    }
    pub inline fn getThreadName(self: *const ThreadReader) []const u8 {
        return self._thread_name orelse &[_]u8{};
    }
};
const MetaInfoWire = struct {
    const EVENT_TYPE_WIRE: gremlin.ProtoWireNumber = 1;
    const APP_PACKAGE_NAME_WIRE: gremlin.ProtoWireNumber = 2;
    const APP_TYPE_WIRE: gremlin.ProtoWireNumber = 3;
    const ANDROID_SDK_VERSION_WIRE: gremlin.ProtoWireNumber = 4;
    const ANDROID_BUILD_TYPE_WIRE: gremlin.ProtoWireNumber = 5;
    const TRACE_OFFCPU_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const MetaInfo = struct {
    // fields
    event_type: ?[]const ?[]const u8 = null,
    app_package_name: ?[]const u8 = null,
    app_type: ?[]const u8 = null,
    android_sdk_version: ?[]const u8 = null,
    android_build_type: ?[]const u8 = null,
    trace_offcpu: bool = false,
    pub fn calcProtobufSize(self: *const MetaInfo) usize {
        var res: usize = 0;
        if (self.event_type) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(MetaInfoWire.EVENT_TYPE_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.app_package_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(MetaInfoWire.APP_PACKAGE_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.app_type) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(MetaInfoWire.APP_TYPE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.android_sdk_version) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(MetaInfoWire.ANDROID_SDK_VERSION_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.android_build_type) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(MetaInfoWire.ANDROID_BUILD_TYPE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.trace_offcpu != false) {
            res += gremlin.sizes.sizeWireNumber(MetaInfoWire.TRACE_OFFCPU_WIRE) + gremlin.sizes.sizeBool(self.trace_offcpu);
        }
        return res;
    }
    pub fn encode(self: *const MetaInfo, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const MetaInfo, target: *gremlin.Writer) void {
        if (self.event_type) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(MetaInfoWire.EVENT_TYPE_WIRE, v);
                } else {
                    target.appendBytesTag(MetaInfoWire.EVENT_TYPE_WIRE, 0);
                }
            }
        }
        if (self.app_package_name) |v| {
            if (v.len > 0) {
                target.appendBytes(MetaInfoWire.APP_PACKAGE_NAME_WIRE, v);
            }
        }
        if (self.app_type) |v| {
            if (v.len > 0) {
                target.appendBytes(MetaInfoWire.APP_TYPE_WIRE, v);
            }
        }
        if (self.android_sdk_version) |v| {
            if (v.len > 0) {
                target.appendBytes(MetaInfoWire.ANDROID_SDK_VERSION_WIRE, v);
            }
        }
        if (self.android_build_type) |v| {
            if (v.len > 0) {
                target.appendBytes(MetaInfoWire.ANDROID_BUILD_TYPE_WIRE, v);
            }
        }
        if (self.trace_offcpu != false) {
            target.appendBool(MetaInfoWire.TRACE_OFFCPU_WIRE, self.trace_offcpu);
        }
    }
};
pub const MetaInfoReader = struct {
    buf: gremlin.Reader,
    _event_type_offset: ?usize = null,
    _event_type_last_offset: ?usize = null,
    _event_type_cnt: usize = 0,
    _app_package_name: ?[]const u8 = null,
    _app_type: ?[]const u8 = null,
    _android_sdk_version: ?[]const u8 = null,
    _android_build_type: ?[]const u8 = null,
    _trace_offcpu: bool = false,
    pub fn init(src: []const u8) gremlin.Error!MetaInfoReader {
        const buf = gremlin.Reader.init(src);
        var res = MetaInfoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MetaInfoWire.EVENT_TYPE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._event_type_offset == null) {
                        res._event_type_offset = offset - result.size;
                    }
                    res._event_type_last_offset = offset;
                    res._event_type_cnt += 1;
                },
                MetaInfoWire.APP_PACKAGE_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._app_package_name = result.value;
                },
                MetaInfoWire.APP_TYPE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._app_type = result.value;
                },
                MetaInfoWire.ANDROID_SDK_VERSION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_sdk_version = result.value;
                },
                MetaInfoWire.ANDROID_BUILD_TYPE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_build_type = result.value;
                },
                MetaInfoWire.TRACE_OFFCPU_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._trace_offcpu = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn eventTypeCount(self: *const MetaInfoReader) usize {
        return self._event_type_cnt;
    }
    pub fn eventTypeNext(self: *MetaInfoReader) ?[]const u8 {
        if (self._event_type_offset == null) return null;
        const current_offset = self._event_type_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._event_type_last_offset != null and current_offset >= self._event_type_last_offset.?) {
            self._event_type_offset = null;
            return result.value;
        }
        if (self._event_type_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._event_type_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == MetaInfoWire.EVENT_TYPE_WIRE) {
                self._event_type_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._event_type_offset = null;
        return result.value;
    }
    pub inline fn getAppPackageName(self: *const MetaInfoReader) []const u8 {
        return self._app_package_name orelse &[_]u8{};
    }
    pub inline fn getAppType(self: *const MetaInfoReader) []const u8 {
        return self._app_type orelse &[_]u8{};
    }
    pub inline fn getAndroidSdkVersion(self: *const MetaInfoReader) []const u8 {
        return self._android_sdk_version orelse &[_]u8{};
    }
    pub inline fn getAndroidBuildType(self: *const MetaInfoReader) []const u8 {
        return self._android_build_type orelse &[_]u8{};
    }
    pub inline fn getTraceOffcpu(self: *const MetaInfoReader) bool {
        return self._trace_offcpu;
    }
};
const ContextSwitchWire = struct {
    const SWITCH_ON_WIRE: gremlin.ProtoWireNumber = 1;
    const TIME_WIRE: gremlin.ProtoWireNumber = 2;
    const THREAD_ID_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const ContextSwitch = struct {
    // fields
    switch_on: bool = false,
    time: u64 = 0,
    thread_id: u32 = 0,
    pub fn calcProtobufSize(self: *const ContextSwitch) usize {
        var res: usize = 0;
        if (self.switch_on != false) {
            res += gremlin.sizes.sizeWireNumber(ContextSwitchWire.SWITCH_ON_WIRE) + gremlin.sizes.sizeBool(self.switch_on);
        }
        if (self.time != 0) {
            res += gremlin.sizes.sizeWireNumber(ContextSwitchWire.TIME_WIRE) + gremlin.sizes.sizeU64(self.time);
        }
        if (self.thread_id != 0) {
            res += gremlin.sizes.sizeWireNumber(ContextSwitchWire.THREAD_ID_WIRE) + gremlin.sizes.sizeU32(self.thread_id);
        }
        return res;
    }
    pub fn encode(self: *const ContextSwitch, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ContextSwitch, target: *gremlin.Writer) void {
        if (self.switch_on != false) {
            target.appendBool(ContextSwitchWire.SWITCH_ON_WIRE, self.switch_on);
        }
        if (self.time != 0) {
            target.appendUint64(ContextSwitchWire.TIME_WIRE, self.time);
        }
        if (self.thread_id != 0) {
            target.appendUint32(ContextSwitchWire.THREAD_ID_WIRE, self.thread_id);
        }
    }
};
pub const ContextSwitchReader = struct {
    buf: gremlin.Reader,
    _switch_on: bool = false,
    _time: u64 = 0,
    _thread_id: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!ContextSwitchReader {
        const buf = gremlin.Reader.init(src);
        var res = ContextSwitchReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ContextSwitchWire.SWITCH_ON_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._switch_on = result.value;
                },
                ContextSwitchWire.TIME_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._time = result.value;
                },
                ContextSwitchWire.THREAD_ID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._thread_id = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getSwitchOn(self: *const ContextSwitchReader) bool {
        return self._switch_on;
    }
    pub inline fn getTime(self: *const ContextSwitchReader) u64 {
        return self._time;
    }
    pub inline fn getThreadId(self: *const ContextSwitchReader) u32 {
        return self._thread_id;
    }
};
const RecordWire = struct {
    const SAMPLE_WIRE: gremlin.ProtoWireNumber = 1;
    const LOST_WIRE: gremlin.ProtoWireNumber = 2;
    const FILE_WIRE: gremlin.ProtoWireNumber = 3;
    const THREAD_WIRE: gremlin.ProtoWireNumber = 4;
    const META_INFO_WIRE: gremlin.ProtoWireNumber = 5;
    const CONTEXT_SWITCH_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const Record = struct {
    // fields
    sample: ?Sample = null,
    lost: ?LostSituation = null,
    file: ?File = null,
    thread: ?Thread = null,
    meta_info: ?MetaInfo = null,
    context_switch: ?ContextSwitch = null,
    pub fn calcProtobufSize(self: *const Record) usize {
        var res: usize = 0;
        if (self.sample) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(RecordWire.SAMPLE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.lost) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(RecordWire.LOST_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.file) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(RecordWire.FILE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.thread) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(RecordWire.THREAD_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.meta_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(RecordWire.META_INFO_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.context_switch) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(RecordWire.CONTEXT_SWITCH_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const Record, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Record, target: *gremlin.Writer) void {
        if (self.sample) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(RecordWire.SAMPLE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.lost) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(RecordWire.LOST_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.file) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(RecordWire.FILE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.thread) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(RecordWire.THREAD_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.meta_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(RecordWire.META_INFO_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.context_switch) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(RecordWire.CONTEXT_SWITCH_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const RecordReader = struct {
    buf: gremlin.Reader,
    _sample_buf: ?[]const u8 = null,
    _lost_buf: ?[]const u8 = null,
    _file_buf: ?[]const u8 = null,
    _thread_buf: ?[]const u8 = null,
    _meta_info_buf: ?[]const u8 = null,
    _context_switch_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!RecordReader {
        const buf = gremlin.Reader.init(src);
        var res = RecordReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                RecordWire.SAMPLE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._sample_buf = result.value;
                },
                RecordWire.LOST_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._lost_buf = result.value;
                },
                RecordWire.FILE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._file_buf = result.value;
                },
                RecordWire.THREAD_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._thread_buf = result.value;
                },
                RecordWire.META_INFO_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._meta_info_buf = result.value;
                },
                RecordWire.CONTEXT_SWITCH_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._context_switch_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getSample(self: *const RecordReader) gremlin.Error!SampleReader {
        if (self._sample_buf) |buf| {
            return try SampleReader.init(buf);
        }
        return try SampleReader.init(&[_]u8{});
    }
    pub fn getLost(self: *const RecordReader) gremlin.Error!LostSituationReader {
        if (self._lost_buf) |buf| {
            return try LostSituationReader.init(buf);
        }
        return try LostSituationReader.init(&[_]u8{});
    }
    pub fn getFile(self: *const RecordReader) gremlin.Error!FileReader {
        if (self._file_buf) |buf| {
            return try FileReader.init(buf);
        }
        return try FileReader.init(&[_]u8{});
    }
    pub fn getThread(self: *const RecordReader) gremlin.Error!ThreadReader {
        if (self._thread_buf) |buf| {
            return try ThreadReader.init(buf);
        }
        return try ThreadReader.init(&[_]u8{});
    }
    pub fn getMetaInfo(self: *const RecordReader) gremlin.Error!MetaInfoReader {
        if (self._meta_info_buf) |buf| {
            return try MetaInfoReader.init(buf);
        }
        return try MetaInfoReader.init(&[_]u8{});
    }
    pub fn getContextSwitch(self: *const RecordReader) gremlin.Error!ContextSwitchReader {
        if (self._context_switch_buf) |buf| {
            return try ContextSwitchReader.init(buf);
        }
        return try ContextSwitchReader.init(&[_]u8{});
    }
};
