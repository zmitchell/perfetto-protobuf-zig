// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const DebugUnwindFeatureWire = struct {
    const FILE_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const DebugUnwindFeature = struct {
    // nested structs
    const FileWire = struct {
        const PATH_WIRE: gremlin.ProtoWireNumber = 1;
        const SIZE_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const File = struct {
        // fields
        path: ?[]const u8 = null,
        size: u64 = 0,
        pub fn calcProtobufSize(self: *const DebugUnwindFeature.File) usize {
            var res: usize = 0;
            if (self.path) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(DebugUnwindFeature.FileWire.PATH_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.size != 0) {
                res += gremlin.sizes.sizeWireNumber(DebugUnwindFeature.FileWire.SIZE_WIRE) + gremlin.sizes.sizeU64(self.size);
            }
            return res;
        }
        pub fn encode(self: *const DebugUnwindFeature.File, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const DebugUnwindFeature.File, target: *gremlin.Writer) void {
            if (self.path) |v| {
                if (v.len > 0) {
                    target.appendBytes(DebugUnwindFeature.FileWire.PATH_WIRE, v);
                }
            }
            if (self.size != 0) {
                target.appendUint64(DebugUnwindFeature.FileWire.SIZE_WIRE, self.size);
            }
        }
    };
    pub const FileReader = struct {
        buf: gremlin.Reader,
        _path: ?[]const u8 = null,
        _size: u64 = 0,
        pub fn init(src: []const u8) gremlin.Error!DebugUnwindFeature.FileReader {
            const buf = gremlin.Reader.init(src);
            var res = DebugUnwindFeature.FileReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    DebugUnwindFeature.FileWire.PATH_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._path = result.value;
                    },
                    DebugUnwindFeature.FileWire.SIZE_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._size = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getPath(self: *const DebugUnwindFeature.FileReader) []const u8 {
            return self._path orelse &[_]u8{};
        }
        pub inline fn getSize(self: *const DebugUnwindFeature.FileReader) u64 {
            return self._size;
        }
    };
    // fields
    file: ?[]const ?DebugUnwindFeature.File = null,
    pub fn calcProtobufSize(self: *const DebugUnwindFeature) usize {
        var res: usize = 0;
        if (self.file) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(DebugUnwindFeatureWire.FILE_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const DebugUnwindFeature, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const DebugUnwindFeature, target: *gremlin.Writer) void {
        if (self.file) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(DebugUnwindFeatureWire.FILE_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(DebugUnwindFeatureWire.FILE_WIRE, 0);
                }
            }
        }
    }
};
pub const DebugUnwindFeatureReader = struct {
    buf: gremlin.Reader,
    _file_offset: ?usize = null,
    _file_last_offset: ?usize = null,
    _file_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!DebugUnwindFeatureReader {
        const buf = gremlin.Reader.init(src);
        var res = DebugUnwindFeatureReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                DebugUnwindFeatureWire.FILE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._file_offset == null) {
                        res._file_offset = offset - result.size;
                    }
                    res._file_last_offset = offset;
                    res._file_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn fileCount(self: *const DebugUnwindFeatureReader) usize {
        return self._file_cnt;
    }
    pub fn fileNext(self: *DebugUnwindFeatureReader) ?DebugUnwindFeature.FileReader {
        if (self._file_offset == null) return null;
        const current_offset = self._file_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = DebugUnwindFeature.FileReader.init(result.value) catch return null;
        if (self._file_last_offset != null and current_offset >= self._file_last_offset.?) {
            self._file_offset = null;
            return msg;
        }
        if (self._file_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._file_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == DebugUnwindFeatureWire.FILE_WIRE) {
                self._file_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._file_offset = null;
        return msg;
    }
};
const FileFeatureWire = struct {
    const PATH_WIRE: gremlin.ProtoWireNumber = 1;
    const TYPE_WIRE: gremlin.ProtoWireNumber = 2;
    const MIN_VADDR_WIRE: gremlin.ProtoWireNumber = 3;
    const SYMBOL_WIRE: gremlin.ProtoWireNumber = 4;
    const DEX_FILE_WIRE: gremlin.ProtoWireNumber = 5;
    const ELF_FILE_WIRE: gremlin.ProtoWireNumber = 6;
    const KERNEL_MODULE_WIRE: gremlin.ProtoWireNumber = 7;
};
pub const FileFeature = struct {
    // nested enums
    pub const DsoType = enum(i32) {
        DSO_KERNEL = 0,
        DSO_KERNEL_MODULE = 1,
        DSO_ELF_FILE = 2,
        DSO_DEX_FILE = 3,
        DSO_SYMBOL_MAP_FILE = 4,
        DSO_UNKNOWN_FILE = 5,
    };
    // nested structs
    const SymbolWire = struct {
        const VADDR_WIRE: gremlin.ProtoWireNumber = 1;
        const LEN_WIRE: gremlin.ProtoWireNumber = 2;
        const NAME_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const Symbol = struct {
        // fields
        vaddr: u64 = 0,
        len: u32 = 0,
        name: ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const FileFeature.Symbol) usize {
            var res: usize = 0;
            if (self.vaddr != 0) {
                res += gremlin.sizes.sizeWireNumber(FileFeature.SymbolWire.VADDR_WIRE) + gremlin.sizes.sizeU64(self.vaddr);
            }
            if (self.len != 0) {
                res += gremlin.sizes.sizeWireNumber(FileFeature.SymbolWire.LEN_WIRE) + gremlin.sizes.sizeU32(self.len);
            }
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(FileFeature.SymbolWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            return res;
        }
        pub fn encode(self: *const FileFeature.Symbol, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const FileFeature.Symbol, target: *gremlin.Writer) void {
            if (self.vaddr != 0) {
                target.appendUint64(FileFeature.SymbolWire.VADDR_WIRE, self.vaddr);
            }
            if (self.len != 0) {
                target.appendUint32(FileFeature.SymbolWire.LEN_WIRE, self.len);
            }
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(FileFeature.SymbolWire.NAME_WIRE, v);
                }
            }
        }
    };
    pub const SymbolReader = struct {
        buf: gremlin.Reader,
        _vaddr: u64 = 0,
        _len: u32 = 0,
        _name: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!FileFeature.SymbolReader {
            const buf = gremlin.Reader.init(src);
            var res = FileFeature.SymbolReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    FileFeature.SymbolWire.VADDR_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._vaddr = result.value;
                    },
                    FileFeature.SymbolWire.LEN_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._len = result.value;
                    },
                    FileFeature.SymbolWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getVaddr(self: *const FileFeature.SymbolReader) u64 {
            return self._vaddr;
        }
        pub inline fn getLen(self: *const FileFeature.SymbolReader) u32 {
            return self._len;
        }
        pub inline fn getName(self: *const FileFeature.SymbolReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
    };
    const DexFileWire = struct {
        const DEX_FILE_OFFSET_WIRE: gremlin.ProtoWireNumber = 1;
    };
    pub const DexFile = struct {
        // fields
        dex_file_offset: ?[]const u64 = null,
        pub fn calcProtobufSize(self: *const FileFeature.DexFile) usize {
            var res: usize = 0;
            if (self.dex_file_offset) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    res += gremlin.sizes.sizeWireNumber(FileFeature.DexFileWire.DEX_FILE_OFFSET_WIRE) + gremlin.sizes.sizeU64(arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeU64(v);
                    }
                    res += gremlin.sizes.sizeWireNumber(FileFeature.DexFileWire.DEX_FILE_OFFSET_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
                }
            }
            return res;
        }
        pub fn encode(self: *const FileFeature.DexFile, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const FileFeature.DexFile, target: *gremlin.Writer) void {
            if (self.dex_file_offset) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    target.appendUint64(FileFeature.DexFileWire.DEX_FILE_OFFSET_WIRE, arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeU64(v);
                    }
                    target.appendBytesTag(FileFeature.DexFileWire.DEX_FILE_OFFSET_WIRE, packed_size);
                    for (arr) |v| {
                        target.appendUint64WithoutTag(v);
                    }
                }
            }
        }
    };
    pub const DexFileReader = struct {
        buf: gremlin.Reader,
        _dex_file_offset_offset: ?usize = null,
        _dex_file_offset_last_offset: ?usize = null,
        _dex_file_offset_packed: bool = false,
        pub fn init(src: []const u8) gremlin.Error!FileFeature.DexFileReader {
            const buf = gremlin.Reader.init(src);
            var res = FileFeature.DexFileReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    FileFeature.DexFileWire.DEX_FILE_OFFSET_WIRE => {
                        if (res._dex_file_offset_offset == null) {
                            res._dex_file_offset_offset = offset;
                        }
                        if (tag.wire == gremlin.ProtoWireType.bytes) {
                            res._dex_file_offset_packed = true;
                            const length_result = try buf.readVarInt(offset);
                            res._dex_file_offset_offset = offset + length_result.size;
                            res._dex_file_offset_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                            offset = res._dex_file_offset_last_offset.?;
                        } else {
                            const result = try buf.readUInt64(offset);
                            offset += result.size;
                            res._dex_file_offset_last_offset = offset;
                        }
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn dexFileOffsetNext(self: *FileFeature.DexFileReader) gremlin.Error!?u64 {
            if (self._dex_file_offset_offset == null) return null;
            const current_offset = self._dex_file_offset_offset.?;
            if (current_offset >= self._dex_file_offset_last_offset.?) {
                self._dex_file_offset_offset = null;
                return null;
            }
            if (self._dex_file_offset_packed) {
                const value_result = try self.buf.readUInt64(current_offset);
                self._dex_file_offset_offset = current_offset + value_result.size;
                if (self._dex_file_offset_offset.? >= self._dex_file_offset_last_offset.?) {
                    self._dex_file_offset_offset = null;
                }
                return value_result.value;
            } else {
                const value_result = try self.buf.readUInt64(current_offset);
                var next_offset = current_offset + value_result.size;
                const max_offset = self._dex_file_offset_last_offset.?;
                // Search for the next occurrence of this field
                while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                    const next_tag = try self.buf.readTagAt(next_offset);
                    next_offset += next_tag.size;
                    if (next_tag.number == FileFeature.DexFileWire.DEX_FILE_OFFSET_WIRE) {
                        self._dex_file_offset_offset = next_offset;
                        return value_result.value;
                    } else {
                        next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                    }
                }
                self._dex_file_offset_offset = null;
                return value_result.value;
            }
        }
    };
    const ElfFileWire = struct {
        const FILE_OFFSET_OF_MIN_VADDR_WIRE: gremlin.ProtoWireNumber = 1;
    };
    pub const ElfFile = struct {
        // fields
        file_offset_of_min_vaddr: u64 = 0,
        pub fn calcProtobufSize(self: *const FileFeature.ElfFile) usize {
            var res: usize = 0;
            if (self.file_offset_of_min_vaddr != 0) {
                res += gremlin.sizes.sizeWireNumber(FileFeature.ElfFileWire.FILE_OFFSET_OF_MIN_VADDR_WIRE) + gremlin.sizes.sizeU64(self.file_offset_of_min_vaddr);
            }
            return res;
        }
        pub fn encode(self: *const FileFeature.ElfFile, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const FileFeature.ElfFile, target: *gremlin.Writer) void {
            if (self.file_offset_of_min_vaddr != 0) {
                target.appendUint64(FileFeature.ElfFileWire.FILE_OFFSET_OF_MIN_VADDR_WIRE, self.file_offset_of_min_vaddr);
            }
        }
    };
    pub const ElfFileReader = struct {
        buf: gremlin.Reader,
        _file_offset_of_min_vaddr: u64 = 0,
        pub fn init(src: []const u8) gremlin.Error!FileFeature.ElfFileReader {
            const buf = gremlin.Reader.init(src);
            var res = FileFeature.ElfFileReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    FileFeature.ElfFileWire.FILE_OFFSET_OF_MIN_VADDR_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._file_offset_of_min_vaddr = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getFileOffsetOfMinVaddr(self: *const FileFeature.ElfFileReader) u64 {
            return self._file_offset_of_min_vaddr;
        }
    };
    const KernelModuleWire = struct {
        const MEMORY_OFFSET_OF_MIN_VADDR_WIRE: gremlin.ProtoWireNumber = 1;
    };
    pub const KernelModule = struct {
        // fields
        memory_offset_of_min_vaddr: u64 = 0,
        pub fn calcProtobufSize(self: *const FileFeature.KernelModule) usize {
            var res: usize = 0;
            if (self.memory_offset_of_min_vaddr != 0) {
                res += gremlin.sizes.sizeWireNumber(FileFeature.KernelModuleWire.MEMORY_OFFSET_OF_MIN_VADDR_WIRE) + gremlin.sizes.sizeU64(self.memory_offset_of_min_vaddr);
            }
            return res;
        }
        pub fn encode(self: *const FileFeature.KernelModule, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const FileFeature.KernelModule, target: *gremlin.Writer) void {
            if (self.memory_offset_of_min_vaddr != 0) {
                target.appendUint64(FileFeature.KernelModuleWire.MEMORY_OFFSET_OF_MIN_VADDR_WIRE, self.memory_offset_of_min_vaddr);
            }
        }
    };
    pub const KernelModuleReader = struct {
        buf: gremlin.Reader,
        _memory_offset_of_min_vaddr: u64 = 0,
        pub fn init(src: []const u8) gremlin.Error!FileFeature.KernelModuleReader {
            const buf = gremlin.Reader.init(src);
            var res = FileFeature.KernelModuleReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    FileFeature.KernelModuleWire.MEMORY_OFFSET_OF_MIN_VADDR_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._memory_offset_of_min_vaddr = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getMemoryOffsetOfMinVaddr(self: *const FileFeature.KernelModuleReader) u64 {
            return self._memory_offset_of_min_vaddr;
        }
    };
    // fields
    path: ?[]const u8 = null,
    type: FileFeature.DsoType = @enumFromInt(0),
    min_vaddr: u64 = 0,
    symbol: ?[]const ?FileFeature.Symbol = null,
    dex_file: ?FileFeature.DexFile = null,
    elf_file: ?FileFeature.ElfFile = null,
    kernel_module: ?FileFeature.KernelModule = null,
    pub fn calcProtobufSize(self: *const FileFeature) usize {
        var res: usize = 0;
        if (self.path) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(FileFeatureWire.PATH_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (@intFromEnum(self.type) != 0) {
            res += gremlin.sizes.sizeWireNumber(FileFeatureWire.TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.type));
        }
        if (self.min_vaddr != 0) {
            res += gremlin.sizes.sizeWireNumber(FileFeatureWire.MIN_VADDR_WIRE) + gremlin.sizes.sizeU64(self.min_vaddr);
        }
        if (self.symbol) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(FileFeatureWire.SYMBOL_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.dex_file) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FileFeatureWire.DEX_FILE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.elf_file) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FileFeatureWire.ELF_FILE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kernel_module) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FileFeatureWire.KERNEL_MODULE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const FileFeature, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const FileFeature, target: *gremlin.Writer) void {
        if (self.path) |v| {
            if (v.len > 0) {
                target.appendBytes(FileFeatureWire.PATH_WIRE, v);
            }
        }
        if (@intFromEnum(self.type) != 0) {
            target.appendInt32(FileFeatureWire.TYPE_WIRE, @intFromEnum(self.type));
        }
        if (self.min_vaddr != 0) {
            target.appendUint64(FileFeatureWire.MIN_VADDR_WIRE, self.min_vaddr);
        }
        if (self.symbol) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(FileFeatureWire.SYMBOL_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(FileFeatureWire.SYMBOL_WIRE, 0);
                }
            }
        }
        if (self.dex_file) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FileFeatureWire.DEX_FILE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.elf_file) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FileFeatureWire.ELF_FILE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kernel_module) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FileFeatureWire.KERNEL_MODULE_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const FileFeatureReader = struct {
    buf: gremlin.Reader,
    _path: ?[]const u8 = null,
    _type: FileFeature.DsoType = @enumFromInt(0),
    _min_vaddr: u64 = 0,
    _symbol_offset: ?usize = null,
    _symbol_last_offset: ?usize = null,
    _symbol_cnt: usize = 0,
    _dex_file_buf: ?[]const u8 = null,
    _elf_file_buf: ?[]const u8 = null,
    _kernel_module_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!FileFeatureReader {
        const buf = gremlin.Reader.init(src);
        var res = FileFeatureReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                FileFeatureWire.PATH_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._path = result.value;
                },
                FileFeatureWire.TYPE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._type = @enumFromInt(result.value);
                },
                FileFeatureWire.MIN_VADDR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._min_vaddr = result.value;
                },
                FileFeatureWire.SYMBOL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._symbol_offset == null) {
                        res._symbol_offset = offset - result.size;
                    }
                    res._symbol_last_offset = offset;
                    res._symbol_cnt += 1;
                },
                FileFeatureWire.DEX_FILE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dex_file_buf = result.value;
                },
                FileFeatureWire.ELF_FILE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._elf_file_buf = result.value;
                },
                FileFeatureWire.KERNEL_MODULE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kernel_module_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getPath(self: *const FileFeatureReader) []const u8 {
        return self._path orelse &[_]u8{};
    }
    pub inline fn getType(self: *const FileFeatureReader) FileFeature.DsoType {
        return self._type;
    }
    pub inline fn getMinVaddr(self: *const FileFeatureReader) u64 {
        return self._min_vaddr;
    }
    pub fn symbolCount(self: *const FileFeatureReader) usize {
        return self._symbol_cnt;
    }
    pub fn symbolNext(self: *FileFeatureReader) ?FileFeature.SymbolReader {
        if (self._symbol_offset == null) return null;
        const current_offset = self._symbol_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = FileFeature.SymbolReader.init(result.value) catch return null;
        if (self._symbol_last_offset != null and current_offset >= self._symbol_last_offset.?) {
            self._symbol_offset = null;
            return msg;
        }
        if (self._symbol_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._symbol_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == FileFeatureWire.SYMBOL_WIRE) {
                self._symbol_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._symbol_offset = null;
        return msg;
    }
    pub fn getDexFile(self: *const FileFeatureReader) gremlin.Error!FileFeature.DexFileReader {
        if (self._dex_file_buf) |buf| {
            return try FileFeature.DexFileReader.init(buf);
        }
        return try FileFeature.DexFileReader.init(&[_]u8{});
    }
    pub fn getElfFile(self: *const FileFeatureReader) gremlin.Error!FileFeature.ElfFileReader {
        if (self._elf_file_buf) |buf| {
            return try FileFeature.ElfFileReader.init(buf);
        }
        return try FileFeature.ElfFileReader.init(&[_]u8{});
    }
    pub fn getKernelModule(self: *const FileFeatureReader) gremlin.Error!FileFeature.KernelModuleReader {
        if (self._kernel_module_buf) |buf| {
            return try FileFeature.KernelModuleReader.init(buf);
        }
        return try FileFeature.KernelModuleReader.init(&[_]u8{});
    }
};
