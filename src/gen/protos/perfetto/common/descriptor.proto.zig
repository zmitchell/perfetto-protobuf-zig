// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const FileDescriptorSetWire = struct {
    const FILE_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const FileDescriptorSet = struct {
    // fields
    file: ?[]const ?FileDescriptorProto = null,
    pub fn calcProtobufSize(self: *const FileDescriptorSet) usize {
        var res: usize = 0;
        if (self.file) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(FileDescriptorSetWire.FILE_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const FileDescriptorSet, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const FileDescriptorSet, target: *gremlin.Writer) void {
        if (self.file) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(FileDescriptorSetWire.FILE_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(FileDescriptorSetWire.FILE_WIRE, 0);
                }
            }
        }
    }
};
pub const FileDescriptorSetReader = struct {
    buf: gremlin.Reader,
    _file_offset: ?usize = null,
    _file_last_offset: ?usize = null,
    _file_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!FileDescriptorSetReader {
        const buf = gremlin.Reader.init(src);
        var res = FileDescriptorSetReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                FileDescriptorSetWire.FILE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._file_offset == null) {
                        res._file_offset = offset - result.size;
                    }
                    res._file_last_offset = offset;
                    res._file_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn fileCount(self: *const FileDescriptorSetReader) usize {
        return self._file_cnt;
    }
    pub fn fileNext(self: *FileDescriptorSetReader) ?FileDescriptorProtoReader {
        if (self._file_offset == null) return null;
        const current_offset = self._file_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = FileDescriptorProtoReader.init(result.value) catch return null;
        if (self._file_last_offset != null and current_offset >= self._file_last_offset.?) {
            self._file_offset = null;
            return msg;
        }
        if (self._file_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._file_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == FileDescriptorSetWire.FILE_WIRE) {
                self._file_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._file_offset = null;
        return msg;
    }
};
const FileDescriptorProtoWire = struct {
    const NAME_WIRE: gremlin.ProtoWireNumber = 1;
    const PACKAGE_WIRE: gremlin.ProtoWireNumber = 2;
    const DEPENDENCY_WIRE: gremlin.ProtoWireNumber = 3;
    const PUBLIC_DEPENDENCY_WIRE: gremlin.ProtoWireNumber = 10;
    const WEAK_DEPENDENCY_WIRE: gremlin.ProtoWireNumber = 11;
    const MESSAGE_TYPE_WIRE: gremlin.ProtoWireNumber = 4;
    const ENUM_TYPE_WIRE: gremlin.ProtoWireNumber = 5;
    const EXTENSION_WIRE: gremlin.ProtoWireNumber = 7;
};
pub const FileDescriptorProto = struct {
    // fields
    name: ?[]const u8 = null,
    package: ?[]const u8 = null,
    dependency: ?[]const ?[]const u8 = null,
    public_dependency: ?[]const i32 = null,
    weak_dependency: ?[]const i32 = null,
    message_type: ?[]const ?DescriptorProto = null,
    enum_type: ?[]const ?EnumDescriptorProto = null,
    extension: ?[]const ?FieldDescriptorProto = null,
    pub fn calcProtobufSize(self: *const FileDescriptorProto) usize {
        var res: usize = 0;
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(FileDescriptorProtoWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.package) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(FileDescriptorProtoWire.PACKAGE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.dependency) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(FileDescriptorProtoWire.DEPENDENCY_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.public_dependency) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(FileDescriptorProtoWire.PUBLIC_DEPENDENCY_WIRE) + gremlin.sizes.sizeI32(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(v);
                }
                res += gremlin.sizes.sizeWireNumber(FileDescriptorProtoWire.PUBLIC_DEPENDENCY_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.weak_dependency) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(FileDescriptorProtoWire.WEAK_DEPENDENCY_WIRE) + gremlin.sizes.sizeI32(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(v);
                }
                res += gremlin.sizes.sizeWireNumber(FileDescriptorProtoWire.WEAK_DEPENDENCY_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.message_type) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(FileDescriptorProtoWire.MESSAGE_TYPE_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.enum_type) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(FileDescriptorProtoWire.ENUM_TYPE_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.extension) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(FileDescriptorProtoWire.EXTENSION_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const FileDescriptorProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const FileDescriptorProto, target: *gremlin.Writer) void {
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(FileDescriptorProtoWire.NAME_WIRE, v);
            }
        }
        if (self.package) |v| {
            if (v.len > 0) {
                target.appendBytes(FileDescriptorProtoWire.PACKAGE_WIRE, v);
            }
        }
        if (self.dependency) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(FileDescriptorProtoWire.DEPENDENCY_WIRE, v);
                } else {
                    target.appendBytesTag(FileDescriptorProtoWire.DEPENDENCY_WIRE, 0);
                }
            }
        }
        if (self.public_dependency) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt32(FileDescriptorProtoWire.PUBLIC_DEPENDENCY_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(v);
                }
                target.appendBytesTag(FileDescriptorProtoWire.PUBLIC_DEPENDENCY_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt32WithoutTag(v);
                }
            }
        }
        if (self.weak_dependency) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt32(FileDescriptorProtoWire.WEAK_DEPENDENCY_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(v);
                }
                target.appendBytesTag(FileDescriptorProtoWire.WEAK_DEPENDENCY_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt32WithoutTag(v);
                }
            }
        }
        if (self.message_type) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(FileDescriptorProtoWire.MESSAGE_TYPE_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(FileDescriptorProtoWire.MESSAGE_TYPE_WIRE, 0);
                }
            }
        }
        if (self.enum_type) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(FileDescriptorProtoWire.ENUM_TYPE_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(FileDescriptorProtoWire.ENUM_TYPE_WIRE, 0);
                }
            }
        }
        if (self.extension) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(FileDescriptorProtoWire.EXTENSION_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(FileDescriptorProtoWire.EXTENSION_WIRE, 0);
                }
            }
        }
    }
};
pub const FileDescriptorProtoReader = struct {
    buf: gremlin.Reader,
    _name: ?[]const u8 = null,
    _package: ?[]const u8 = null,
    _dependency_offset: ?usize = null,
    _dependency_last_offset: ?usize = null,
    _dependency_cnt: usize = 0,
    _public_dependency_offset: ?usize = null,
    _public_dependency_last_offset: ?usize = null,
    _public_dependency_packed: bool = false,
    _weak_dependency_offset: ?usize = null,
    _weak_dependency_last_offset: ?usize = null,
    _weak_dependency_packed: bool = false,
    _message_type_offset: ?usize = null,
    _message_type_last_offset: ?usize = null,
    _message_type_cnt: usize = 0,
    _enum_type_offset: ?usize = null,
    _enum_type_last_offset: ?usize = null,
    _enum_type_cnt: usize = 0,
    _extension_offset: ?usize = null,
    _extension_last_offset: ?usize = null,
    _extension_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!FileDescriptorProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = FileDescriptorProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                FileDescriptorProtoWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                FileDescriptorProtoWire.PACKAGE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._package = result.value;
                },
                FileDescriptorProtoWire.DEPENDENCY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._dependency_offset == null) {
                        res._dependency_offset = offset - result.size;
                    }
                    res._dependency_last_offset = offset;
                    res._dependency_cnt += 1;
                },
                FileDescriptorProtoWire.PUBLIC_DEPENDENCY_WIRE => {
                    if (res._public_dependency_offset == null) {
                        res._public_dependency_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._public_dependency_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._public_dependency_offset = offset + length_result.size;
                        res._public_dependency_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._public_dependency_last_offset.?;
                    } else {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._public_dependency_last_offset = offset;
                    }
                },
                FileDescriptorProtoWire.WEAK_DEPENDENCY_WIRE => {
                    if (res._weak_dependency_offset == null) {
                        res._weak_dependency_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._weak_dependency_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._weak_dependency_offset = offset + length_result.size;
                        res._weak_dependency_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._weak_dependency_last_offset.?;
                    } else {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._weak_dependency_last_offset = offset;
                    }
                },
                FileDescriptorProtoWire.MESSAGE_TYPE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._message_type_offset == null) {
                        res._message_type_offset = offset - result.size;
                    }
                    res._message_type_last_offset = offset;
                    res._message_type_cnt += 1;
                },
                FileDescriptorProtoWire.ENUM_TYPE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._enum_type_offset == null) {
                        res._enum_type_offset = offset - result.size;
                    }
                    res._enum_type_last_offset = offset;
                    res._enum_type_cnt += 1;
                },
                FileDescriptorProtoWire.EXTENSION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._extension_offset == null) {
                        res._extension_offset = offset - result.size;
                    }
                    res._extension_last_offset = offset;
                    res._extension_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getName(self: *const FileDescriptorProtoReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub inline fn getPackage(self: *const FileDescriptorProtoReader) []const u8 {
        return self._package orelse &[_]u8{};
    }
    pub fn dependencyCount(self: *const FileDescriptorProtoReader) usize {
        return self._dependency_cnt;
    }
    pub fn dependencyNext(self: *FileDescriptorProtoReader) ?[]const u8 {
        if (self._dependency_offset == null) return null;
        const current_offset = self._dependency_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._dependency_last_offset != null and current_offset >= self._dependency_last_offset.?) {
            self._dependency_offset = null;
            return result.value;
        }
        if (self._dependency_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._dependency_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == FileDescriptorProtoWire.DEPENDENCY_WIRE) {
                self._dependency_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._dependency_offset = null;
        return result.value;
    }
    pub fn publicDependencyNext(self: *FileDescriptorProtoReader) gremlin.Error!?i32 {
        if (self._public_dependency_offset == null) return null;
        const current_offset = self._public_dependency_offset.?;
        if (current_offset >= self._public_dependency_last_offset.?) {
            self._public_dependency_offset = null;
            return null;
        }
        if (self._public_dependency_packed) {
            const value_result = try self.buf.readInt32(current_offset);
            self._public_dependency_offset = current_offset + value_result.size;
            if (self._public_dependency_offset.? >= self._public_dependency_last_offset.?) {
                self._public_dependency_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._public_dependency_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == FileDescriptorProtoWire.PUBLIC_DEPENDENCY_WIRE) {
                    self._public_dependency_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._public_dependency_offset = null;
            return value_result.value;
        }
    }
    pub fn weakDependencyNext(self: *FileDescriptorProtoReader) gremlin.Error!?i32 {
        if (self._weak_dependency_offset == null) return null;
        const current_offset = self._weak_dependency_offset.?;
        if (current_offset >= self._weak_dependency_last_offset.?) {
            self._weak_dependency_offset = null;
            return null;
        }
        if (self._weak_dependency_packed) {
            const value_result = try self.buf.readInt32(current_offset);
            self._weak_dependency_offset = current_offset + value_result.size;
            if (self._weak_dependency_offset.? >= self._weak_dependency_last_offset.?) {
                self._weak_dependency_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._weak_dependency_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == FileDescriptorProtoWire.WEAK_DEPENDENCY_WIRE) {
                    self._weak_dependency_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._weak_dependency_offset = null;
            return value_result.value;
        }
    }
    pub fn messageTypeCount(self: *const FileDescriptorProtoReader) usize {
        return self._message_type_cnt;
    }
    pub fn messageTypeNext(self: *FileDescriptorProtoReader) ?DescriptorProtoReader {
        if (self._message_type_offset == null) return null;
        const current_offset = self._message_type_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = DescriptorProtoReader.init(result.value) catch return null;
        if (self._message_type_last_offset != null and current_offset >= self._message_type_last_offset.?) {
            self._message_type_offset = null;
            return msg;
        }
        if (self._message_type_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._message_type_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == FileDescriptorProtoWire.MESSAGE_TYPE_WIRE) {
                self._message_type_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._message_type_offset = null;
        return msg;
    }
    pub fn enumTypeCount(self: *const FileDescriptorProtoReader) usize {
        return self._enum_type_cnt;
    }
    pub fn enumTypeNext(self: *FileDescriptorProtoReader) ?EnumDescriptorProtoReader {
        if (self._enum_type_offset == null) return null;
        const current_offset = self._enum_type_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = EnumDescriptorProtoReader.init(result.value) catch return null;
        if (self._enum_type_last_offset != null and current_offset >= self._enum_type_last_offset.?) {
            self._enum_type_offset = null;
            return msg;
        }
        if (self._enum_type_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._enum_type_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == FileDescriptorProtoWire.ENUM_TYPE_WIRE) {
                self._enum_type_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._enum_type_offset = null;
        return msg;
    }
    pub fn extensionCount(self: *const FileDescriptorProtoReader) usize {
        return self._extension_cnt;
    }
    pub fn extensionNext(self: *FileDescriptorProtoReader) ?FieldDescriptorProtoReader {
        if (self._extension_offset == null) return null;
        const current_offset = self._extension_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = FieldDescriptorProtoReader.init(result.value) catch return null;
        if (self._extension_last_offset != null and current_offset >= self._extension_last_offset.?) {
            self._extension_offset = null;
            return msg;
        }
        if (self._extension_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._extension_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == FileDescriptorProtoWire.EXTENSION_WIRE) {
                self._extension_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._extension_offset = null;
        return msg;
    }
};
const DescriptorProtoWire = struct {
    const NAME_WIRE: gremlin.ProtoWireNumber = 1;
    const FIELD_WIRE: gremlin.ProtoWireNumber = 2;
    const EXTENSION_WIRE: gremlin.ProtoWireNumber = 6;
    const NESTED_TYPE_WIRE: gremlin.ProtoWireNumber = 3;
    const ENUM_TYPE_WIRE: gremlin.ProtoWireNumber = 4;
    const ONEOF_DECL_WIRE: gremlin.ProtoWireNumber = 8;
    const RESERVED_RANGE_WIRE: gremlin.ProtoWireNumber = 9;
    const RESERVED_NAME_WIRE: gremlin.ProtoWireNumber = 10;
};
pub const DescriptorProto = struct {
    // nested structs
    const ReservedRangeWire = struct {
        const START_WIRE: gremlin.ProtoWireNumber = 1;
        const END_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const ReservedRange = struct {
        // fields
        start: i32 = 0,
        end: i32 = 0,
        pub fn calcProtobufSize(self: *const DescriptorProto.ReservedRange) usize {
            var res: usize = 0;
            if (self.start != 0) {
                res += gremlin.sizes.sizeWireNumber(DescriptorProto.ReservedRangeWire.START_WIRE) + gremlin.sizes.sizeI32(self.start);
            }
            if (self.end != 0) {
                res += gremlin.sizes.sizeWireNumber(DescriptorProto.ReservedRangeWire.END_WIRE) + gremlin.sizes.sizeI32(self.end);
            }
            return res;
        }
        pub fn encode(self: *const DescriptorProto.ReservedRange, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const DescriptorProto.ReservedRange, target: *gremlin.Writer) void {
            if (self.start != 0) {
                target.appendInt32(DescriptorProto.ReservedRangeWire.START_WIRE, self.start);
            }
            if (self.end != 0) {
                target.appendInt32(DescriptorProto.ReservedRangeWire.END_WIRE, self.end);
            }
        }
    };
    pub const ReservedRangeReader = struct {
        buf: gremlin.Reader,
        _start: i32 = 0,
        _end: i32 = 0,
        pub fn init(src: []const u8) gremlin.Error!DescriptorProto.ReservedRangeReader {
            const buf = gremlin.Reader.init(src);
            var res = DescriptorProto.ReservedRangeReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    DescriptorProto.ReservedRangeWire.START_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._start = result.value;
                    },
                    DescriptorProto.ReservedRangeWire.END_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._end = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getStart(self: *const DescriptorProto.ReservedRangeReader) i32 {
            return self._start;
        }
        pub inline fn getEnd(self: *const DescriptorProto.ReservedRangeReader) i32 {
            return self._end;
        }
    };
    // fields
    name: ?[]const u8 = null,
    field: ?[]const ?FieldDescriptorProto = null,
    extension: ?[]const ?FieldDescriptorProto = null,
    nested_type: ?[]const ?DescriptorProto = null,
    enum_type: ?[]const ?EnumDescriptorProto = null,
    oneof_decl: ?[]const ?OneofDescriptorProto = null,
    reserved_range: ?[]const ?DescriptorProto.ReservedRange = null,
    reserved_name: ?[]const ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const DescriptorProto) usize {
        var res: usize = 0;
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(DescriptorProtoWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.field) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(DescriptorProtoWire.FIELD_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.extension) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(DescriptorProtoWire.EXTENSION_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.nested_type) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(DescriptorProtoWire.NESTED_TYPE_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.enum_type) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(DescriptorProtoWire.ENUM_TYPE_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.oneof_decl) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(DescriptorProtoWire.ONEOF_DECL_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.reserved_range) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(DescriptorProtoWire.RESERVED_RANGE_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.reserved_name) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(DescriptorProtoWire.RESERVED_NAME_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const DescriptorProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const DescriptorProto, target: *gremlin.Writer) void {
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(DescriptorProtoWire.NAME_WIRE, v);
            }
        }
        if (self.field) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(DescriptorProtoWire.FIELD_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(DescriptorProtoWire.FIELD_WIRE, 0);
                }
            }
        }
        if (self.extension) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(DescriptorProtoWire.EXTENSION_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(DescriptorProtoWire.EXTENSION_WIRE, 0);
                }
            }
        }
        if (self.nested_type) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(DescriptorProtoWire.NESTED_TYPE_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(DescriptorProtoWire.NESTED_TYPE_WIRE, 0);
                }
            }
        }
        if (self.enum_type) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(DescriptorProtoWire.ENUM_TYPE_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(DescriptorProtoWire.ENUM_TYPE_WIRE, 0);
                }
            }
        }
        if (self.oneof_decl) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(DescriptorProtoWire.ONEOF_DECL_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(DescriptorProtoWire.ONEOF_DECL_WIRE, 0);
                }
            }
        }
        if (self.reserved_range) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(DescriptorProtoWire.RESERVED_RANGE_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(DescriptorProtoWire.RESERVED_RANGE_WIRE, 0);
                }
            }
        }
        if (self.reserved_name) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(DescriptorProtoWire.RESERVED_NAME_WIRE, v);
                } else {
                    target.appendBytesTag(DescriptorProtoWire.RESERVED_NAME_WIRE, 0);
                }
            }
        }
    }
};
pub const DescriptorProtoReader = struct {
    buf: gremlin.Reader,
    _name: ?[]const u8 = null,
    _field_offset: ?usize = null,
    _field_last_offset: ?usize = null,
    _field_cnt: usize = 0,
    _extension_offset: ?usize = null,
    _extension_last_offset: ?usize = null,
    _extension_cnt: usize = 0,
    _nested_type_offset: ?usize = null,
    _nested_type_last_offset: ?usize = null,
    _nested_type_cnt: usize = 0,
    _enum_type_offset: ?usize = null,
    _enum_type_last_offset: ?usize = null,
    _enum_type_cnt: usize = 0,
    _oneof_decl_offset: ?usize = null,
    _oneof_decl_last_offset: ?usize = null,
    _oneof_decl_cnt: usize = 0,
    _reserved_range_offset: ?usize = null,
    _reserved_range_last_offset: ?usize = null,
    _reserved_range_cnt: usize = 0,
    _reserved_name_offset: ?usize = null,
    _reserved_name_last_offset: ?usize = null,
    _reserved_name_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!DescriptorProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = DescriptorProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                DescriptorProtoWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                DescriptorProtoWire.FIELD_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._field_offset == null) {
                        res._field_offset = offset - result.size;
                    }
                    res._field_last_offset = offset;
                    res._field_cnt += 1;
                },
                DescriptorProtoWire.EXTENSION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._extension_offset == null) {
                        res._extension_offset = offset - result.size;
                    }
                    res._extension_last_offset = offset;
                    res._extension_cnt += 1;
                },
                DescriptorProtoWire.NESTED_TYPE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._nested_type_offset == null) {
                        res._nested_type_offset = offset - result.size;
                    }
                    res._nested_type_last_offset = offset;
                    res._nested_type_cnt += 1;
                },
                DescriptorProtoWire.ENUM_TYPE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._enum_type_offset == null) {
                        res._enum_type_offset = offset - result.size;
                    }
                    res._enum_type_last_offset = offset;
                    res._enum_type_cnt += 1;
                },
                DescriptorProtoWire.ONEOF_DECL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._oneof_decl_offset == null) {
                        res._oneof_decl_offset = offset - result.size;
                    }
                    res._oneof_decl_last_offset = offset;
                    res._oneof_decl_cnt += 1;
                },
                DescriptorProtoWire.RESERVED_RANGE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._reserved_range_offset == null) {
                        res._reserved_range_offset = offset - result.size;
                    }
                    res._reserved_range_last_offset = offset;
                    res._reserved_range_cnt += 1;
                },
                DescriptorProtoWire.RESERVED_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._reserved_name_offset == null) {
                        res._reserved_name_offset = offset - result.size;
                    }
                    res._reserved_name_last_offset = offset;
                    res._reserved_name_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getName(self: *const DescriptorProtoReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub fn fieldCount(self: *const DescriptorProtoReader) usize {
        return self._field_cnt;
    }
    pub fn fieldNext(self: *DescriptorProtoReader) ?FieldDescriptorProtoReader {
        if (self._field_offset == null) return null;
        const current_offset = self._field_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = FieldDescriptorProtoReader.init(result.value) catch return null;
        if (self._field_last_offset != null and current_offset >= self._field_last_offset.?) {
            self._field_offset = null;
            return msg;
        }
        if (self._field_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._field_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == DescriptorProtoWire.FIELD_WIRE) {
                self._field_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._field_offset = null;
        return msg;
    }
    pub fn extensionCount(self: *const DescriptorProtoReader) usize {
        return self._extension_cnt;
    }
    pub fn extensionNext(self: *DescriptorProtoReader) ?FieldDescriptorProtoReader {
        if (self._extension_offset == null) return null;
        const current_offset = self._extension_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = FieldDescriptorProtoReader.init(result.value) catch return null;
        if (self._extension_last_offset != null and current_offset >= self._extension_last_offset.?) {
            self._extension_offset = null;
            return msg;
        }
        if (self._extension_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._extension_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == DescriptorProtoWire.EXTENSION_WIRE) {
                self._extension_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._extension_offset = null;
        return msg;
    }
    pub fn nestedTypeCount(self: *const DescriptorProtoReader) usize {
        return self._nested_type_cnt;
    }
    pub fn nestedTypeNext(self: *DescriptorProtoReader) ?DescriptorProtoReader {
        if (self._nested_type_offset == null) return null;
        const current_offset = self._nested_type_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = DescriptorProtoReader.init(result.value) catch return null;
        if (self._nested_type_last_offset != null and current_offset >= self._nested_type_last_offset.?) {
            self._nested_type_offset = null;
            return msg;
        }
        if (self._nested_type_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._nested_type_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == DescriptorProtoWire.NESTED_TYPE_WIRE) {
                self._nested_type_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._nested_type_offset = null;
        return msg;
    }
    pub fn enumTypeCount(self: *const DescriptorProtoReader) usize {
        return self._enum_type_cnt;
    }
    pub fn enumTypeNext(self: *DescriptorProtoReader) ?EnumDescriptorProtoReader {
        if (self._enum_type_offset == null) return null;
        const current_offset = self._enum_type_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = EnumDescriptorProtoReader.init(result.value) catch return null;
        if (self._enum_type_last_offset != null and current_offset >= self._enum_type_last_offset.?) {
            self._enum_type_offset = null;
            return msg;
        }
        if (self._enum_type_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._enum_type_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == DescriptorProtoWire.ENUM_TYPE_WIRE) {
                self._enum_type_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._enum_type_offset = null;
        return msg;
    }
    pub fn oneofDeclCount(self: *const DescriptorProtoReader) usize {
        return self._oneof_decl_cnt;
    }
    pub fn oneofDeclNext(self: *DescriptorProtoReader) ?OneofDescriptorProtoReader {
        if (self._oneof_decl_offset == null) return null;
        const current_offset = self._oneof_decl_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = OneofDescriptorProtoReader.init(result.value) catch return null;
        if (self._oneof_decl_last_offset != null and current_offset >= self._oneof_decl_last_offset.?) {
            self._oneof_decl_offset = null;
            return msg;
        }
        if (self._oneof_decl_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._oneof_decl_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == DescriptorProtoWire.ONEOF_DECL_WIRE) {
                self._oneof_decl_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._oneof_decl_offset = null;
        return msg;
    }
    pub fn reservedRangeCount(self: *const DescriptorProtoReader) usize {
        return self._reserved_range_cnt;
    }
    pub fn reservedRangeNext(self: *DescriptorProtoReader) ?DescriptorProto.ReservedRangeReader {
        if (self._reserved_range_offset == null) return null;
        const current_offset = self._reserved_range_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = DescriptorProto.ReservedRangeReader.init(result.value) catch return null;
        if (self._reserved_range_last_offset != null and current_offset >= self._reserved_range_last_offset.?) {
            self._reserved_range_offset = null;
            return msg;
        }
        if (self._reserved_range_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._reserved_range_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == DescriptorProtoWire.RESERVED_RANGE_WIRE) {
                self._reserved_range_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._reserved_range_offset = null;
        return msg;
    }
    pub fn reservedNameCount(self: *const DescriptorProtoReader) usize {
        return self._reserved_name_cnt;
    }
    pub fn reservedNameNext(self: *DescriptorProtoReader) ?[]const u8 {
        if (self._reserved_name_offset == null) return null;
        const current_offset = self._reserved_name_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._reserved_name_last_offset != null and current_offset >= self._reserved_name_last_offset.?) {
            self._reserved_name_offset = null;
            return result.value;
        }
        if (self._reserved_name_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._reserved_name_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == DescriptorProtoWire.RESERVED_NAME_WIRE) {
                self._reserved_name_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._reserved_name_offset = null;
        return result.value;
    }
};
const UninterpretedOptionWire = struct {
    const NAME_WIRE: gremlin.ProtoWireNumber = 2;
    const IDENTIFIER_VALUE_WIRE: gremlin.ProtoWireNumber = 3;
    const POSITIVE_INT_VALUE_WIRE: gremlin.ProtoWireNumber = 4;
    const NEGATIVE_INT_VALUE_WIRE: gremlin.ProtoWireNumber = 5;
    const DOUBLE_VALUE_WIRE: gremlin.ProtoWireNumber = 6;
    const STRING_VALUE_WIRE: gremlin.ProtoWireNumber = 7;
    const AGGREGATE_VALUE_WIRE: gremlin.ProtoWireNumber = 8;
};
pub const UninterpretedOption = struct {
    // nested structs
    const NamePartWire = struct {
        const NAME_PART_WIRE: gremlin.ProtoWireNumber = 1;
        const IS_EXTENSION_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const NamePart = struct {
        // fields
        name_part: ?[]const u8 = null,
        is_extension: bool = false,
        pub fn calcProtobufSize(self: *const UninterpretedOption.NamePart) usize {
            var res: usize = 0;
            if (self.name_part) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(UninterpretedOption.NamePartWire.NAME_PART_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.is_extension != false) {
                res += gremlin.sizes.sizeWireNumber(UninterpretedOption.NamePartWire.IS_EXTENSION_WIRE) + gremlin.sizes.sizeBool(self.is_extension);
            }
            return res;
        }
        pub fn encode(self: *const UninterpretedOption.NamePart, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const UninterpretedOption.NamePart, target: *gremlin.Writer) void {
            if (self.name_part) |v| {
                if (v.len > 0) {
                    target.appendBytes(UninterpretedOption.NamePartWire.NAME_PART_WIRE, v);
                }
            }
            if (self.is_extension != false) {
                target.appendBool(UninterpretedOption.NamePartWire.IS_EXTENSION_WIRE, self.is_extension);
            }
        }
    };
    pub const NamePartReader = struct {
        buf: gremlin.Reader,
        _name_part: ?[]const u8 = null,
        _is_extension: bool = false,
        pub fn init(src: []const u8) gremlin.Error!UninterpretedOption.NamePartReader {
            const buf = gremlin.Reader.init(src);
            var res = UninterpretedOption.NamePartReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    UninterpretedOption.NamePartWire.NAME_PART_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name_part = result.value;
                    },
                    UninterpretedOption.NamePartWire.IS_EXTENSION_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._is_extension = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getNamePart(self: *const UninterpretedOption.NamePartReader) []const u8 {
            return self._name_part orelse &[_]u8{};
        }
        pub inline fn getIsExtension(self: *const UninterpretedOption.NamePartReader) bool {
            return self._is_extension;
        }
    };
    // fields
    name: ?[]const ?UninterpretedOption.NamePart = null,
    identifier_value: ?[]const u8 = null,
    positive_int_value: u64 = 0,
    negative_int_value: i64 = 0,
    double_value: f64 = 0.0,
    string_value: ?[]const u8 = null,
    aggregate_value: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const UninterpretedOption) usize {
        var res: usize = 0;
        if (self.name) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(UninterpretedOptionWire.NAME_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.identifier_value) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(UninterpretedOptionWire.IDENTIFIER_VALUE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.positive_int_value != 0) {
            res += gremlin.sizes.sizeWireNumber(UninterpretedOptionWire.POSITIVE_INT_VALUE_WIRE) + gremlin.sizes.sizeU64(self.positive_int_value);
        }
        if (self.negative_int_value != 0) {
            res += gremlin.sizes.sizeWireNumber(UninterpretedOptionWire.NEGATIVE_INT_VALUE_WIRE) + gremlin.sizes.sizeI64(self.negative_int_value);
        }
        if (self.double_value != 0.0) {
            res += gremlin.sizes.sizeWireNumber(UninterpretedOptionWire.DOUBLE_VALUE_WIRE) + gremlin.sizes.sizeDouble(self.double_value);
        }
        if (self.string_value) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(UninterpretedOptionWire.STRING_VALUE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.aggregate_value) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(UninterpretedOptionWire.AGGREGATE_VALUE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const UninterpretedOption, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const UninterpretedOption, target: *gremlin.Writer) void {
        if (self.name) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(UninterpretedOptionWire.NAME_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(UninterpretedOptionWire.NAME_WIRE, 0);
                }
            }
        }
        if (self.identifier_value) |v| {
            if (v.len > 0) {
                target.appendBytes(UninterpretedOptionWire.IDENTIFIER_VALUE_WIRE, v);
            }
        }
        if (self.positive_int_value != 0) {
            target.appendUint64(UninterpretedOptionWire.POSITIVE_INT_VALUE_WIRE, self.positive_int_value);
        }
        if (self.negative_int_value != 0) {
            target.appendInt64(UninterpretedOptionWire.NEGATIVE_INT_VALUE_WIRE, self.negative_int_value);
        }
        if (self.double_value != 0.0) {
            target.appendFloat64(UninterpretedOptionWire.DOUBLE_VALUE_WIRE, self.double_value);
        }
        if (self.string_value) |v| {
            if (v.len > 0) {
                target.appendBytes(UninterpretedOptionWire.STRING_VALUE_WIRE, v);
            }
        }
        if (self.aggregate_value) |v| {
            if (v.len > 0) {
                target.appendBytes(UninterpretedOptionWire.AGGREGATE_VALUE_WIRE, v);
            }
        }
    }
};
pub const UninterpretedOptionReader = struct {
    buf: gremlin.Reader,
    _name_offset: ?usize = null,
    _name_last_offset: ?usize = null,
    _name_cnt: usize = 0,
    _identifier_value: ?[]const u8 = null,
    _positive_int_value: u64 = 0,
    _negative_int_value: i64 = 0,
    _double_value: f64 = 0.0,
    _string_value: ?[]const u8 = null,
    _aggregate_value: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!UninterpretedOptionReader {
        const buf = gremlin.Reader.init(src);
        var res = UninterpretedOptionReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                UninterpretedOptionWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._name_offset == null) {
                        res._name_offset = offset - result.size;
                    }
                    res._name_last_offset = offset;
                    res._name_cnt += 1;
                },
                UninterpretedOptionWire.IDENTIFIER_VALUE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._identifier_value = result.value;
                },
                UninterpretedOptionWire.POSITIVE_INT_VALUE_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._positive_int_value = result.value;
                },
                UninterpretedOptionWire.NEGATIVE_INT_VALUE_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._negative_int_value = result.value;
                },
                UninterpretedOptionWire.DOUBLE_VALUE_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._double_value = result.value;
                },
                UninterpretedOptionWire.STRING_VALUE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._string_value = result.value;
                },
                UninterpretedOptionWire.AGGREGATE_VALUE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._aggregate_value = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn nameCount(self: *const UninterpretedOptionReader) usize {
        return self._name_cnt;
    }
    pub fn nameNext(self: *UninterpretedOptionReader) ?UninterpretedOption.NamePartReader {
        if (self._name_offset == null) return null;
        const current_offset = self._name_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = UninterpretedOption.NamePartReader.init(result.value) catch return null;
        if (self._name_last_offset != null and current_offset >= self._name_last_offset.?) {
            self._name_offset = null;
            return msg;
        }
        if (self._name_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._name_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == UninterpretedOptionWire.NAME_WIRE) {
                self._name_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._name_offset = null;
        return msg;
    }
    pub inline fn getIdentifierValue(self: *const UninterpretedOptionReader) []const u8 {
        return self._identifier_value orelse &[_]u8{};
    }
    pub inline fn getPositiveIntValue(self: *const UninterpretedOptionReader) u64 {
        return self._positive_int_value;
    }
    pub inline fn getNegativeIntValue(self: *const UninterpretedOptionReader) i64 {
        return self._negative_int_value;
    }
    pub inline fn getDoubleValue(self: *const UninterpretedOptionReader) f64 {
        return self._double_value;
    }
    pub inline fn getStringValue(self: *const UninterpretedOptionReader) []const u8 {
        return self._string_value orelse &[_]u8{};
    }
    pub inline fn getAggregateValue(self: *const UninterpretedOptionReader) []const u8 {
        return self._aggregate_value orelse &[_]u8{};
    }
};
const FieldOptionsWire = struct {
    const PACKED_WIRE: gremlin.ProtoWireNumber = 2;
    const UNINTERPRETED_OPTION_WIRE: gremlin.ProtoWireNumber = 999;
};
pub const FieldOptions = struct {
    // fields
    packed_: bool = false,
    uninterpreted_option: ?[]const ?UninterpretedOption = null,
    pub fn calcProtobufSize(self: *const FieldOptions) usize {
        var res: usize = 0;
        if (self.packed_ != false) {
            res += gremlin.sizes.sizeWireNumber(FieldOptionsWire.PACKED_WIRE) + gremlin.sizes.sizeBool(self.packed_);
        }
        if (self.uninterpreted_option) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(FieldOptionsWire.UNINTERPRETED_OPTION_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const FieldOptions, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const FieldOptions, target: *gremlin.Writer) void {
        if (self.packed_ != false) {
            target.appendBool(FieldOptionsWire.PACKED_WIRE, self.packed_);
        }
        if (self.uninterpreted_option) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(FieldOptionsWire.UNINTERPRETED_OPTION_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(FieldOptionsWire.UNINTERPRETED_OPTION_WIRE, 0);
                }
            }
        }
    }
};
pub const FieldOptionsReader = struct {
    buf: gremlin.Reader,
    _packed_: bool = false,
    _uninterpreted_option_offset: ?usize = null,
    _uninterpreted_option_last_offset: ?usize = null,
    _uninterpreted_option_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!FieldOptionsReader {
        const buf = gremlin.Reader.init(src);
        var res = FieldOptionsReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                FieldOptionsWire.PACKED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._packed_ = result.value;
                },
                FieldOptionsWire.UNINTERPRETED_OPTION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._uninterpreted_option_offset == null) {
                        res._uninterpreted_option_offset = offset - result.size;
                    }
                    res._uninterpreted_option_last_offset = offset;
                    res._uninterpreted_option_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getPacked(self: *const FieldOptionsReader) bool {
        return self._packed_;
    }
    pub fn uninterpretedOptionCount(self: *const FieldOptionsReader) usize {
        return self._uninterpreted_option_cnt;
    }
    pub fn uninterpretedOptionNext(self: *FieldOptionsReader) ?UninterpretedOptionReader {
        if (self._uninterpreted_option_offset == null) return null;
        const current_offset = self._uninterpreted_option_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = UninterpretedOptionReader.init(result.value) catch return null;
        if (self._uninterpreted_option_last_offset != null and current_offset >= self._uninterpreted_option_last_offset.?) {
            self._uninterpreted_option_offset = null;
            return msg;
        }
        if (self._uninterpreted_option_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._uninterpreted_option_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == FieldOptionsWire.UNINTERPRETED_OPTION_WIRE) {
                self._uninterpreted_option_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._uninterpreted_option_offset = null;
        return msg;
    }
};
const FieldDescriptorProtoWire = struct {
    const NAME_WIRE: gremlin.ProtoWireNumber = 1;
    const NUMBER_WIRE: gremlin.ProtoWireNumber = 3;
    const LABEL_WIRE: gremlin.ProtoWireNumber = 4;
    const TYPE_WIRE: gremlin.ProtoWireNumber = 5;
    const TYPE_NAME_WIRE: gremlin.ProtoWireNumber = 6;
    const EXTENDEE_WIRE: gremlin.ProtoWireNumber = 2;
    const DEFAULT_VALUE_WIRE: gremlin.ProtoWireNumber = 7;
    const OPTIONS_WIRE: gremlin.ProtoWireNumber = 8;
    const ONEOF_INDEX_WIRE: gremlin.ProtoWireNumber = 9;
};
pub const FieldDescriptorProto = struct {
    // nested enums
    pub const Type = enum(i32) {
        TYPE_DOUBLE = 1,
        TYPE_FLOAT = 2,
        TYPE_INT64 = 3,
        TYPE_UINT64 = 4,
        TYPE_INT32 = 5,
        TYPE_FIXED64 = 6,
        TYPE_FIXED32 = 7,
        TYPE_BOOL = 8,
        TYPE_STRING = 9,
        TYPE_GROUP = 10,
        TYPE_MESSAGE = 11,
        TYPE_BYTES = 12,
        TYPE_UINT32 = 13,
        TYPE_ENUM = 14,
        TYPE_SFIXED32 = 15,
        TYPE_SFIXED64 = 16,
        TYPE_SINT32 = 17,
        TYPE_SINT64 = 18,
        _PROTOBUF_UNKNOWN = 0,
    };
    pub const Label = enum(i32) {
        LABEL_OPTIONAL = 1,
        LABEL_REQUIRED = 2,
        LABEL_REPEATED = 3,
        _PROTOBUF_UNKNOWN = 0,
    };
    // fields
    name: ?[]const u8 = null,
    number: i32 = 0,
    label: FieldDescriptorProto.Label = @enumFromInt(0),
    type: FieldDescriptorProto.Type = @enumFromInt(0),
    type_name: ?[]const u8 = null,
    extendee: ?[]const u8 = null,
    default_value: ?[]const u8 = null,
    options: ?FieldOptions = null,
    oneof_index: i32 = 0,
    pub fn calcProtobufSize(self: *const FieldDescriptorProto) usize {
        var res: usize = 0;
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(FieldDescriptorProtoWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.number != 0) {
            res += gremlin.sizes.sizeWireNumber(FieldDescriptorProtoWire.NUMBER_WIRE) + gremlin.sizes.sizeI32(self.number);
        }
        if (@intFromEnum(self.label) != 0) {
            res += gremlin.sizes.sizeWireNumber(FieldDescriptorProtoWire.LABEL_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.label));
        }
        if (@intFromEnum(self.type) != 0) {
            res += gremlin.sizes.sizeWireNumber(FieldDescriptorProtoWire.TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.type));
        }
        if (self.type_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(FieldDescriptorProtoWire.TYPE_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.extendee) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(FieldDescriptorProtoWire.EXTENDEE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.default_value) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(FieldDescriptorProtoWire.DEFAULT_VALUE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.options) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FieldDescriptorProtoWire.OPTIONS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.oneof_index != 0) {
            res += gremlin.sizes.sizeWireNumber(FieldDescriptorProtoWire.ONEOF_INDEX_WIRE) + gremlin.sizes.sizeI32(self.oneof_index);
        }
        return res;
    }
    pub fn encode(self: *const FieldDescriptorProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const FieldDescriptorProto, target: *gremlin.Writer) void {
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(FieldDescriptorProtoWire.NAME_WIRE, v);
            }
        }
        if (self.number != 0) {
            target.appendInt32(FieldDescriptorProtoWire.NUMBER_WIRE, self.number);
        }
        if (@intFromEnum(self.label) != 0) {
            target.appendInt32(FieldDescriptorProtoWire.LABEL_WIRE, @intFromEnum(self.label));
        }
        if (@intFromEnum(self.type) != 0) {
            target.appendInt32(FieldDescriptorProtoWire.TYPE_WIRE, @intFromEnum(self.type));
        }
        if (self.type_name) |v| {
            if (v.len > 0) {
                target.appendBytes(FieldDescriptorProtoWire.TYPE_NAME_WIRE, v);
            }
        }
        if (self.extendee) |v| {
            if (v.len > 0) {
                target.appendBytes(FieldDescriptorProtoWire.EXTENDEE_WIRE, v);
            }
        }
        if (self.default_value) |v| {
            if (v.len > 0) {
                target.appendBytes(FieldDescriptorProtoWire.DEFAULT_VALUE_WIRE, v);
            }
        }
        if (self.options) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FieldDescriptorProtoWire.OPTIONS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.oneof_index != 0) {
            target.appendInt32(FieldDescriptorProtoWire.ONEOF_INDEX_WIRE, self.oneof_index);
        }
    }
};
pub const FieldDescriptorProtoReader = struct {
    buf: gremlin.Reader,
    _name: ?[]const u8 = null,
    _number: i32 = 0,
    _label: FieldDescriptorProto.Label = @enumFromInt(0),
    _type: FieldDescriptorProto.Type = @enumFromInt(0),
    _type_name: ?[]const u8 = null,
    _extendee: ?[]const u8 = null,
    _default_value: ?[]const u8 = null,
    _options_buf: ?[]const u8 = null,
    _oneof_index: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!FieldDescriptorProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = FieldDescriptorProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                FieldDescriptorProtoWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                FieldDescriptorProtoWire.NUMBER_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._number = result.value;
                },
                FieldDescriptorProtoWire.LABEL_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._label = @enumFromInt(result.value);
                },
                FieldDescriptorProtoWire.TYPE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._type = @enumFromInt(result.value);
                },
                FieldDescriptorProtoWire.TYPE_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._type_name = result.value;
                },
                FieldDescriptorProtoWire.EXTENDEE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._extendee = result.value;
                },
                FieldDescriptorProtoWire.DEFAULT_VALUE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._default_value = result.value;
                },
                FieldDescriptorProtoWire.OPTIONS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._options_buf = result.value;
                },
                FieldDescriptorProtoWire.ONEOF_INDEX_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._oneof_index = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getName(self: *const FieldDescriptorProtoReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub inline fn getNumber(self: *const FieldDescriptorProtoReader) i32 {
        return self._number;
    }
    pub inline fn getLabel(self: *const FieldDescriptorProtoReader) FieldDescriptorProto.Label {
        return self._label;
    }
    pub inline fn getType(self: *const FieldDescriptorProtoReader) FieldDescriptorProto.Type {
        return self._type;
    }
    pub inline fn getTypeName(self: *const FieldDescriptorProtoReader) []const u8 {
        return self._type_name orelse &[_]u8{};
    }
    pub inline fn getExtendee(self: *const FieldDescriptorProtoReader) []const u8 {
        return self._extendee orelse &[_]u8{};
    }
    pub inline fn getDefaultValue(self: *const FieldDescriptorProtoReader) []const u8 {
        return self._default_value orelse &[_]u8{};
    }
    pub fn getOptions(self: *const FieldDescriptorProtoReader) gremlin.Error!FieldOptionsReader {
        if (self._options_buf) |buf| {
            return try FieldOptionsReader.init(buf);
        }
        return try FieldOptionsReader.init(&[_]u8{});
    }
    pub inline fn getOneofIndex(self: *const FieldDescriptorProtoReader) i32 {
        return self._oneof_index;
    }
};
const OneofDescriptorProtoWire = struct {
    const NAME_WIRE: gremlin.ProtoWireNumber = 1;
    const OPTIONS_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const OneofDescriptorProto = struct {
    // fields
    name: ?[]const u8 = null,
    options: ?OneofOptions = null,
    pub fn calcProtobufSize(self: *const OneofDescriptorProto) usize {
        var res: usize = 0;
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(OneofDescriptorProtoWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.options) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(OneofDescriptorProtoWire.OPTIONS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const OneofDescriptorProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const OneofDescriptorProto, target: *gremlin.Writer) void {
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(OneofDescriptorProtoWire.NAME_WIRE, v);
            }
        }
        if (self.options) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(OneofDescriptorProtoWire.OPTIONS_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const OneofDescriptorProtoReader = struct {
    buf: gremlin.Reader,
    _name: ?[]const u8 = null,
    _options_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!OneofDescriptorProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = OneofDescriptorProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                OneofDescriptorProtoWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                OneofDescriptorProtoWire.OPTIONS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._options_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getName(self: *const OneofDescriptorProtoReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub fn getOptions(self: *const OneofDescriptorProtoReader) gremlin.Error!OneofOptionsReader {
        if (self._options_buf) |buf| {
            return try OneofOptionsReader.init(buf);
        }
        return try OneofOptionsReader.init(&[_]u8{});
    }
};
const EnumDescriptorProtoWire = struct {
    const NAME_WIRE: gremlin.ProtoWireNumber = 1;
    const VALUE_WIRE: gremlin.ProtoWireNumber = 2;
    const RESERVED_NAME_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const EnumDescriptorProto = struct {
    // fields
    name: ?[]const u8 = null,
    value: ?[]const ?EnumValueDescriptorProto = null,
    reserved_name: ?[]const ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const EnumDescriptorProto) usize {
        var res: usize = 0;
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(EnumDescriptorProtoWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.value) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(EnumDescriptorProtoWire.VALUE_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.reserved_name) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(EnumDescriptorProtoWire.RESERVED_NAME_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const EnumDescriptorProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const EnumDescriptorProto, target: *gremlin.Writer) void {
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(EnumDescriptorProtoWire.NAME_WIRE, v);
            }
        }
        if (self.value) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(EnumDescriptorProtoWire.VALUE_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(EnumDescriptorProtoWire.VALUE_WIRE, 0);
                }
            }
        }
        if (self.reserved_name) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(EnumDescriptorProtoWire.RESERVED_NAME_WIRE, v);
                } else {
                    target.appendBytesTag(EnumDescriptorProtoWire.RESERVED_NAME_WIRE, 0);
                }
            }
        }
    }
};
pub const EnumDescriptorProtoReader = struct {
    buf: gremlin.Reader,
    _name: ?[]const u8 = null,
    _value_offset: ?usize = null,
    _value_last_offset: ?usize = null,
    _value_cnt: usize = 0,
    _reserved_name_offset: ?usize = null,
    _reserved_name_last_offset: ?usize = null,
    _reserved_name_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!EnumDescriptorProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = EnumDescriptorProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                EnumDescriptorProtoWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                EnumDescriptorProtoWire.VALUE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._value_offset == null) {
                        res._value_offset = offset - result.size;
                    }
                    res._value_last_offset = offset;
                    res._value_cnt += 1;
                },
                EnumDescriptorProtoWire.RESERVED_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._reserved_name_offset == null) {
                        res._reserved_name_offset = offset - result.size;
                    }
                    res._reserved_name_last_offset = offset;
                    res._reserved_name_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getName(self: *const EnumDescriptorProtoReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub fn valueCount(self: *const EnumDescriptorProtoReader) usize {
        return self._value_cnt;
    }
    pub fn valueNext(self: *EnumDescriptorProtoReader) ?EnumValueDescriptorProtoReader {
        if (self._value_offset == null) return null;
        const current_offset = self._value_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = EnumValueDescriptorProtoReader.init(result.value) catch return null;
        if (self._value_last_offset != null and current_offset >= self._value_last_offset.?) {
            self._value_offset = null;
            return msg;
        }
        if (self._value_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._value_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == EnumDescriptorProtoWire.VALUE_WIRE) {
                self._value_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._value_offset = null;
        return msg;
    }
    pub fn reservedNameCount(self: *const EnumDescriptorProtoReader) usize {
        return self._reserved_name_cnt;
    }
    pub fn reservedNameNext(self: *EnumDescriptorProtoReader) ?[]const u8 {
        if (self._reserved_name_offset == null) return null;
        const current_offset = self._reserved_name_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._reserved_name_last_offset != null and current_offset >= self._reserved_name_last_offset.?) {
            self._reserved_name_offset = null;
            return result.value;
        }
        if (self._reserved_name_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._reserved_name_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == EnumDescriptorProtoWire.RESERVED_NAME_WIRE) {
                self._reserved_name_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._reserved_name_offset = null;
        return result.value;
    }
};
const EnumValueDescriptorProtoWire = struct {
    const NAME_WIRE: gremlin.ProtoWireNumber = 1;
    const NUMBER_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const EnumValueDescriptorProto = struct {
    // fields
    name: ?[]const u8 = null,
    number: i32 = 0,
    pub fn calcProtobufSize(self: *const EnumValueDescriptorProto) usize {
        var res: usize = 0;
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(EnumValueDescriptorProtoWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.number != 0) {
            res += gremlin.sizes.sizeWireNumber(EnumValueDescriptorProtoWire.NUMBER_WIRE) + gremlin.sizes.sizeI32(self.number);
        }
        return res;
    }
    pub fn encode(self: *const EnumValueDescriptorProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const EnumValueDescriptorProto, target: *gremlin.Writer) void {
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(EnumValueDescriptorProtoWire.NAME_WIRE, v);
            }
        }
        if (self.number != 0) {
            target.appendInt32(EnumValueDescriptorProtoWire.NUMBER_WIRE, self.number);
        }
    }
};
pub const EnumValueDescriptorProtoReader = struct {
    buf: gremlin.Reader,
    _name: ?[]const u8 = null,
    _number: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!EnumValueDescriptorProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = EnumValueDescriptorProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                EnumValueDescriptorProtoWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                EnumValueDescriptorProtoWire.NUMBER_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._number = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getName(self: *const EnumValueDescriptorProtoReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub inline fn getNumber(self: *const EnumValueDescriptorProtoReader) i32 {
        return self._number;
    }
};
pub const OneofOptions = struct {
    pub fn calcProtobufSize(_: *const OneofOptions) usize {
        return 0;
    }
    pub fn encode(self: *const OneofOptions, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(_: *const OneofOptions, _: *gremlin.Writer) void {}
};
pub const OneofOptionsReader = struct {
    buf: gremlin.Reader,
    pub fn init(src: []const u8) gremlin.Error!OneofOptionsReader {
        const buf = gremlin.Reader.init(src);
        return OneofOptionsReader{ .buf = buf };
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
};
