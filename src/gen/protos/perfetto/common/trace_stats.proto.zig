// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const TraceStatsWire = struct {
    const BUFFER_STATS_WIRE: gremlin.ProtoWireNumber = 1;
    const CHUNK_PAYLOAD_HISTOGRAM_DEF_WIRE: gremlin.ProtoWireNumber = 17;
    const WRITER_STATS_WIRE: gremlin.ProtoWireNumber = 18;
    const PRODUCERS_CONNECTED_WIRE: gremlin.ProtoWireNumber = 2;
    const PRODUCERS_SEEN_WIRE: gremlin.ProtoWireNumber = 3;
    const DATA_SOURCES_REGISTERED_WIRE: gremlin.ProtoWireNumber = 4;
    const DATA_SOURCES_SEEN_WIRE: gremlin.ProtoWireNumber = 5;
    const TRACING_SESSIONS_WIRE: gremlin.ProtoWireNumber = 6;
    const TOTAL_BUFFERS_WIRE: gremlin.ProtoWireNumber = 7;
    const CHUNKS_DISCARDED_WIRE: gremlin.ProtoWireNumber = 8;
    const PATCHES_DISCARDED_WIRE: gremlin.ProtoWireNumber = 9;
    const INVALID_PACKETS_WIRE: gremlin.ProtoWireNumber = 10;
    const FILTER_STATS_WIRE: gremlin.ProtoWireNumber = 11;
    const FLUSHES_REQUESTED_WIRE: gremlin.ProtoWireNumber = 12;
    const FLUSHES_SUCCEEDED_WIRE: gremlin.ProtoWireNumber = 13;
    const FLUSHES_FAILED_WIRE: gremlin.ProtoWireNumber = 14;
    const FINAL_FLUSH_OUTCOME_WIRE: gremlin.ProtoWireNumber = 15;
};
pub const TraceStats = struct {
    // nested enums
    pub const FinalFlushOutcome = enum(i32) {
        FINAL_FLUSH_UNSPECIFIED = 0,
        FINAL_FLUSH_SUCCEEDED = 1,
        FINAL_FLUSH_FAILED = 2,
    };
    // nested structs
    const BufferStatsWire = struct {
        const BUFFER_SIZE_WIRE: gremlin.ProtoWireNumber = 12;
        const BYTES_WRITTEN_WIRE: gremlin.ProtoWireNumber = 1;
        const BYTES_OVERWRITTEN_WIRE: gremlin.ProtoWireNumber = 13;
        const BYTES_READ_WIRE: gremlin.ProtoWireNumber = 14;
        const PADDING_BYTES_WRITTEN_WIRE: gremlin.ProtoWireNumber = 15;
        const PADDING_BYTES_CLEARED_WIRE: gremlin.ProtoWireNumber = 16;
        const CHUNKS_WRITTEN_WIRE: gremlin.ProtoWireNumber = 2;
        const CHUNKS_REWRITTEN_WIRE: gremlin.ProtoWireNumber = 10;
        const CHUNKS_OVERWRITTEN_WIRE: gremlin.ProtoWireNumber = 3;
        const CHUNKS_DISCARDED_WIRE: gremlin.ProtoWireNumber = 18;
        const CHUNKS_READ_WIRE: gremlin.ProtoWireNumber = 17;
        const CHUNKS_COMMITTED_OUT_OF_ORDER_WIRE: gremlin.ProtoWireNumber = 11;
        const WRITE_WRAP_COUNT_WIRE: gremlin.ProtoWireNumber = 4;
        const PATCHES_SUCCEEDED_WIRE: gremlin.ProtoWireNumber = 5;
        const PATCHES_FAILED_WIRE: gremlin.ProtoWireNumber = 6;
        const READAHEADS_SUCCEEDED_WIRE: gremlin.ProtoWireNumber = 7;
        const READAHEADS_FAILED_WIRE: gremlin.ProtoWireNumber = 8;
        const ABI_VIOLATIONS_WIRE: gremlin.ProtoWireNumber = 9;
        const TRACE_WRITER_PACKET_LOSS_WIRE: gremlin.ProtoWireNumber = 19;
    };
    pub const BufferStats = struct {
        // fields
        buffer_size: u64 = 0,
        bytes_written: u64 = 0,
        bytes_overwritten: u64 = 0,
        bytes_read: u64 = 0,
        padding_bytes_written: u64 = 0,
        padding_bytes_cleared: u64 = 0,
        chunks_written: u64 = 0,
        chunks_rewritten: u64 = 0,
        chunks_overwritten: u64 = 0,
        chunks_discarded: u64 = 0,
        chunks_read: u64 = 0,
        chunks_committed_out_of_order: u64 = 0,
        write_wrap_count: u64 = 0,
        patches_succeeded: u64 = 0,
        patches_failed: u64 = 0,
        readaheads_succeeded: u64 = 0,
        readaheads_failed: u64 = 0,
        abi_violations: u64 = 0,
        trace_writer_packet_loss: u64 = 0,
        pub fn calcProtobufSize(self: *const TraceStats.BufferStats) usize {
            var res: usize = 0;
            if (self.buffer_size != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceStats.BufferStatsWire.BUFFER_SIZE_WIRE) + gremlin.sizes.sizeU64(self.buffer_size);
            }
            if (self.bytes_written != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceStats.BufferStatsWire.BYTES_WRITTEN_WIRE) + gremlin.sizes.sizeU64(self.bytes_written);
            }
            if (self.bytes_overwritten != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceStats.BufferStatsWire.BYTES_OVERWRITTEN_WIRE) + gremlin.sizes.sizeU64(self.bytes_overwritten);
            }
            if (self.bytes_read != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceStats.BufferStatsWire.BYTES_READ_WIRE) + gremlin.sizes.sizeU64(self.bytes_read);
            }
            if (self.padding_bytes_written != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceStats.BufferStatsWire.PADDING_BYTES_WRITTEN_WIRE) + gremlin.sizes.sizeU64(self.padding_bytes_written);
            }
            if (self.padding_bytes_cleared != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceStats.BufferStatsWire.PADDING_BYTES_CLEARED_WIRE) + gremlin.sizes.sizeU64(self.padding_bytes_cleared);
            }
            if (self.chunks_written != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceStats.BufferStatsWire.CHUNKS_WRITTEN_WIRE) + gremlin.sizes.sizeU64(self.chunks_written);
            }
            if (self.chunks_rewritten != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceStats.BufferStatsWire.CHUNKS_REWRITTEN_WIRE) + gremlin.sizes.sizeU64(self.chunks_rewritten);
            }
            if (self.chunks_overwritten != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceStats.BufferStatsWire.CHUNKS_OVERWRITTEN_WIRE) + gremlin.sizes.sizeU64(self.chunks_overwritten);
            }
            if (self.chunks_discarded != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceStats.BufferStatsWire.CHUNKS_DISCARDED_WIRE) + gremlin.sizes.sizeU64(self.chunks_discarded);
            }
            if (self.chunks_read != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceStats.BufferStatsWire.CHUNKS_READ_WIRE) + gremlin.sizes.sizeU64(self.chunks_read);
            }
            if (self.chunks_committed_out_of_order != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceStats.BufferStatsWire.CHUNKS_COMMITTED_OUT_OF_ORDER_WIRE) + gremlin.sizes.sizeU64(self.chunks_committed_out_of_order);
            }
            if (self.write_wrap_count != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceStats.BufferStatsWire.WRITE_WRAP_COUNT_WIRE) + gremlin.sizes.sizeU64(self.write_wrap_count);
            }
            if (self.patches_succeeded != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceStats.BufferStatsWire.PATCHES_SUCCEEDED_WIRE) + gremlin.sizes.sizeU64(self.patches_succeeded);
            }
            if (self.patches_failed != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceStats.BufferStatsWire.PATCHES_FAILED_WIRE) + gremlin.sizes.sizeU64(self.patches_failed);
            }
            if (self.readaheads_succeeded != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceStats.BufferStatsWire.READAHEADS_SUCCEEDED_WIRE) + gremlin.sizes.sizeU64(self.readaheads_succeeded);
            }
            if (self.readaheads_failed != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceStats.BufferStatsWire.READAHEADS_FAILED_WIRE) + gremlin.sizes.sizeU64(self.readaheads_failed);
            }
            if (self.abi_violations != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceStats.BufferStatsWire.ABI_VIOLATIONS_WIRE) + gremlin.sizes.sizeU64(self.abi_violations);
            }
            if (self.trace_writer_packet_loss != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceStats.BufferStatsWire.TRACE_WRITER_PACKET_LOSS_WIRE) + gremlin.sizes.sizeU64(self.trace_writer_packet_loss);
            }
            return res;
        }
        pub fn encode(self: *const TraceStats.BufferStats, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const TraceStats.BufferStats, target: *gremlin.Writer) void {
            if (self.buffer_size != 0) {
                target.appendUint64(TraceStats.BufferStatsWire.BUFFER_SIZE_WIRE, self.buffer_size);
            }
            if (self.bytes_written != 0) {
                target.appendUint64(TraceStats.BufferStatsWire.BYTES_WRITTEN_WIRE, self.bytes_written);
            }
            if (self.bytes_overwritten != 0) {
                target.appendUint64(TraceStats.BufferStatsWire.BYTES_OVERWRITTEN_WIRE, self.bytes_overwritten);
            }
            if (self.bytes_read != 0) {
                target.appendUint64(TraceStats.BufferStatsWire.BYTES_READ_WIRE, self.bytes_read);
            }
            if (self.padding_bytes_written != 0) {
                target.appendUint64(TraceStats.BufferStatsWire.PADDING_BYTES_WRITTEN_WIRE, self.padding_bytes_written);
            }
            if (self.padding_bytes_cleared != 0) {
                target.appendUint64(TraceStats.BufferStatsWire.PADDING_BYTES_CLEARED_WIRE, self.padding_bytes_cleared);
            }
            if (self.chunks_written != 0) {
                target.appendUint64(TraceStats.BufferStatsWire.CHUNKS_WRITTEN_WIRE, self.chunks_written);
            }
            if (self.chunks_rewritten != 0) {
                target.appendUint64(TraceStats.BufferStatsWire.CHUNKS_REWRITTEN_WIRE, self.chunks_rewritten);
            }
            if (self.chunks_overwritten != 0) {
                target.appendUint64(TraceStats.BufferStatsWire.CHUNKS_OVERWRITTEN_WIRE, self.chunks_overwritten);
            }
            if (self.chunks_discarded != 0) {
                target.appendUint64(TraceStats.BufferStatsWire.CHUNKS_DISCARDED_WIRE, self.chunks_discarded);
            }
            if (self.chunks_read != 0) {
                target.appendUint64(TraceStats.BufferStatsWire.CHUNKS_READ_WIRE, self.chunks_read);
            }
            if (self.chunks_committed_out_of_order != 0) {
                target.appendUint64(TraceStats.BufferStatsWire.CHUNKS_COMMITTED_OUT_OF_ORDER_WIRE, self.chunks_committed_out_of_order);
            }
            if (self.write_wrap_count != 0) {
                target.appendUint64(TraceStats.BufferStatsWire.WRITE_WRAP_COUNT_WIRE, self.write_wrap_count);
            }
            if (self.patches_succeeded != 0) {
                target.appendUint64(TraceStats.BufferStatsWire.PATCHES_SUCCEEDED_WIRE, self.patches_succeeded);
            }
            if (self.patches_failed != 0) {
                target.appendUint64(TraceStats.BufferStatsWire.PATCHES_FAILED_WIRE, self.patches_failed);
            }
            if (self.readaheads_succeeded != 0) {
                target.appendUint64(TraceStats.BufferStatsWire.READAHEADS_SUCCEEDED_WIRE, self.readaheads_succeeded);
            }
            if (self.readaheads_failed != 0) {
                target.appendUint64(TraceStats.BufferStatsWire.READAHEADS_FAILED_WIRE, self.readaheads_failed);
            }
            if (self.abi_violations != 0) {
                target.appendUint64(TraceStats.BufferStatsWire.ABI_VIOLATIONS_WIRE, self.abi_violations);
            }
            if (self.trace_writer_packet_loss != 0) {
                target.appendUint64(TraceStats.BufferStatsWire.TRACE_WRITER_PACKET_LOSS_WIRE, self.trace_writer_packet_loss);
            }
        }
    };
    pub const BufferStatsReader = struct {
        buf: gremlin.Reader,
        _buffer_size: u64 = 0,
        _bytes_written: u64 = 0,
        _bytes_overwritten: u64 = 0,
        _bytes_read: u64 = 0,
        _padding_bytes_written: u64 = 0,
        _padding_bytes_cleared: u64 = 0,
        _chunks_written: u64 = 0,
        _chunks_rewritten: u64 = 0,
        _chunks_overwritten: u64 = 0,
        _chunks_discarded: u64 = 0,
        _chunks_read: u64 = 0,
        _chunks_committed_out_of_order: u64 = 0,
        _write_wrap_count: u64 = 0,
        _patches_succeeded: u64 = 0,
        _patches_failed: u64 = 0,
        _readaheads_succeeded: u64 = 0,
        _readaheads_failed: u64 = 0,
        _abi_violations: u64 = 0,
        _trace_writer_packet_loss: u64 = 0,
        pub fn init(src: []const u8) gremlin.Error!TraceStats.BufferStatsReader {
            const buf = gremlin.Reader.init(src);
            var res = TraceStats.BufferStatsReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    TraceStats.BufferStatsWire.BUFFER_SIZE_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._buffer_size = result.value;
                    },
                    TraceStats.BufferStatsWire.BYTES_WRITTEN_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._bytes_written = result.value;
                    },
                    TraceStats.BufferStatsWire.BYTES_OVERWRITTEN_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._bytes_overwritten = result.value;
                    },
                    TraceStats.BufferStatsWire.BYTES_READ_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._bytes_read = result.value;
                    },
                    TraceStats.BufferStatsWire.PADDING_BYTES_WRITTEN_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._padding_bytes_written = result.value;
                    },
                    TraceStats.BufferStatsWire.PADDING_BYTES_CLEARED_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._padding_bytes_cleared = result.value;
                    },
                    TraceStats.BufferStatsWire.CHUNKS_WRITTEN_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._chunks_written = result.value;
                    },
                    TraceStats.BufferStatsWire.CHUNKS_REWRITTEN_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._chunks_rewritten = result.value;
                    },
                    TraceStats.BufferStatsWire.CHUNKS_OVERWRITTEN_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._chunks_overwritten = result.value;
                    },
                    TraceStats.BufferStatsWire.CHUNKS_DISCARDED_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._chunks_discarded = result.value;
                    },
                    TraceStats.BufferStatsWire.CHUNKS_READ_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._chunks_read = result.value;
                    },
                    TraceStats.BufferStatsWire.CHUNKS_COMMITTED_OUT_OF_ORDER_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._chunks_committed_out_of_order = result.value;
                    },
                    TraceStats.BufferStatsWire.WRITE_WRAP_COUNT_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._write_wrap_count = result.value;
                    },
                    TraceStats.BufferStatsWire.PATCHES_SUCCEEDED_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._patches_succeeded = result.value;
                    },
                    TraceStats.BufferStatsWire.PATCHES_FAILED_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._patches_failed = result.value;
                    },
                    TraceStats.BufferStatsWire.READAHEADS_SUCCEEDED_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._readaheads_succeeded = result.value;
                    },
                    TraceStats.BufferStatsWire.READAHEADS_FAILED_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._readaheads_failed = result.value;
                    },
                    TraceStats.BufferStatsWire.ABI_VIOLATIONS_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._abi_violations = result.value;
                    },
                    TraceStats.BufferStatsWire.TRACE_WRITER_PACKET_LOSS_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._trace_writer_packet_loss = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getBufferSize(self: *const TraceStats.BufferStatsReader) u64 {
            return self._buffer_size;
        }
        pub inline fn getBytesWritten(self: *const TraceStats.BufferStatsReader) u64 {
            return self._bytes_written;
        }
        pub inline fn getBytesOverwritten(self: *const TraceStats.BufferStatsReader) u64 {
            return self._bytes_overwritten;
        }
        pub inline fn getBytesRead(self: *const TraceStats.BufferStatsReader) u64 {
            return self._bytes_read;
        }
        pub inline fn getPaddingBytesWritten(self: *const TraceStats.BufferStatsReader) u64 {
            return self._padding_bytes_written;
        }
        pub inline fn getPaddingBytesCleared(self: *const TraceStats.BufferStatsReader) u64 {
            return self._padding_bytes_cleared;
        }
        pub inline fn getChunksWritten(self: *const TraceStats.BufferStatsReader) u64 {
            return self._chunks_written;
        }
        pub inline fn getChunksRewritten(self: *const TraceStats.BufferStatsReader) u64 {
            return self._chunks_rewritten;
        }
        pub inline fn getChunksOverwritten(self: *const TraceStats.BufferStatsReader) u64 {
            return self._chunks_overwritten;
        }
        pub inline fn getChunksDiscarded(self: *const TraceStats.BufferStatsReader) u64 {
            return self._chunks_discarded;
        }
        pub inline fn getChunksRead(self: *const TraceStats.BufferStatsReader) u64 {
            return self._chunks_read;
        }
        pub inline fn getChunksCommittedOutOfOrder(self: *const TraceStats.BufferStatsReader) u64 {
            return self._chunks_committed_out_of_order;
        }
        pub inline fn getWriteWrapCount(self: *const TraceStats.BufferStatsReader) u64 {
            return self._write_wrap_count;
        }
        pub inline fn getPatchesSucceeded(self: *const TraceStats.BufferStatsReader) u64 {
            return self._patches_succeeded;
        }
        pub inline fn getPatchesFailed(self: *const TraceStats.BufferStatsReader) u64 {
            return self._patches_failed;
        }
        pub inline fn getReadaheadsSucceeded(self: *const TraceStats.BufferStatsReader) u64 {
            return self._readaheads_succeeded;
        }
        pub inline fn getReadaheadsFailed(self: *const TraceStats.BufferStatsReader) u64 {
            return self._readaheads_failed;
        }
        pub inline fn getAbiViolations(self: *const TraceStats.BufferStatsReader) u64 {
            return self._abi_violations;
        }
        pub inline fn getTraceWriterPacketLoss(self: *const TraceStats.BufferStatsReader) u64 {
            return self._trace_writer_packet_loss;
        }
    };
    const WriterStatsWire = struct {
        const SEQUENCE_ID_WIRE: gremlin.ProtoWireNumber = 1;
        const BUFFER_WIRE: gremlin.ProtoWireNumber = 4;
        const CHUNK_PAYLOAD_HISTOGRAM_COUNTS_WIRE: gremlin.ProtoWireNumber = 2;
        const CHUNK_PAYLOAD_HISTOGRAM_SUM_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const WriterStats = struct {
        // fields
        sequence_id: u64 = 0,
        buffer: u32 = 0,
        chunk_payload_histogram_counts: ?[]const u64 = null,
        chunk_payload_histogram_sum: ?[]const i64 = null,
        pub fn calcProtobufSize(self: *const TraceStats.WriterStats) usize {
            var res: usize = 0;
            if (self.sequence_id != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceStats.WriterStatsWire.SEQUENCE_ID_WIRE) + gremlin.sizes.sizeU64(self.sequence_id);
            }
            if (self.buffer != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceStats.WriterStatsWire.BUFFER_WIRE) + gremlin.sizes.sizeU32(self.buffer);
            }
            if (self.chunk_payload_histogram_counts) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    res += gremlin.sizes.sizeWireNumber(TraceStats.WriterStatsWire.CHUNK_PAYLOAD_HISTOGRAM_COUNTS_WIRE) + gremlin.sizes.sizeU64(arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeU64(v);
                    }
                    res += gremlin.sizes.sizeWireNumber(TraceStats.WriterStatsWire.CHUNK_PAYLOAD_HISTOGRAM_COUNTS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
                }
            }
            if (self.chunk_payload_histogram_sum) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    res += gremlin.sizes.sizeWireNumber(TraceStats.WriterStatsWire.CHUNK_PAYLOAD_HISTOGRAM_SUM_WIRE) + gremlin.sizes.sizeI64(arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeI64(v);
                    }
                    res += gremlin.sizes.sizeWireNumber(TraceStats.WriterStatsWire.CHUNK_PAYLOAD_HISTOGRAM_SUM_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
                }
            }
            return res;
        }
        pub fn encode(self: *const TraceStats.WriterStats, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const TraceStats.WriterStats, target: *gremlin.Writer) void {
            if (self.sequence_id != 0) {
                target.appendUint64(TraceStats.WriterStatsWire.SEQUENCE_ID_WIRE, self.sequence_id);
            }
            if (self.buffer != 0) {
                target.appendUint32(TraceStats.WriterStatsWire.BUFFER_WIRE, self.buffer);
            }
            if (self.chunk_payload_histogram_counts) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    target.appendUint64(TraceStats.WriterStatsWire.CHUNK_PAYLOAD_HISTOGRAM_COUNTS_WIRE, arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeU64(v);
                    }
                    target.appendBytesTag(TraceStats.WriterStatsWire.CHUNK_PAYLOAD_HISTOGRAM_COUNTS_WIRE, packed_size);
                    for (arr) |v| {
                        target.appendUint64WithoutTag(v);
                    }
                }
            }
            if (self.chunk_payload_histogram_sum) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    target.appendInt64(TraceStats.WriterStatsWire.CHUNK_PAYLOAD_HISTOGRAM_SUM_WIRE, arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeI64(v);
                    }
                    target.appendBytesTag(TraceStats.WriterStatsWire.CHUNK_PAYLOAD_HISTOGRAM_SUM_WIRE, packed_size);
                    for (arr) |v| {
                        target.appendInt64WithoutTag(v);
                    }
                }
            }
        }
    };
    pub const WriterStatsReader = struct {
        buf: gremlin.Reader,
        _sequence_id: u64 = 0,
        _buffer: u32 = 0,
        _chunk_payload_histogram_counts_offset: ?usize = null,
        _chunk_payload_histogram_counts_last_offset: ?usize = null,
        _chunk_payload_histogram_counts_packed: bool = false,
        _chunk_payload_histogram_sum_offset: ?usize = null,
        _chunk_payload_histogram_sum_last_offset: ?usize = null,
        _chunk_payload_histogram_sum_packed: bool = false,
        pub fn init(src: []const u8) gremlin.Error!TraceStats.WriterStatsReader {
            const buf = gremlin.Reader.init(src);
            var res = TraceStats.WriterStatsReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    TraceStats.WriterStatsWire.SEQUENCE_ID_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._sequence_id = result.value;
                    },
                    TraceStats.WriterStatsWire.BUFFER_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._buffer = result.value;
                    },
                    TraceStats.WriterStatsWire.CHUNK_PAYLOAD_HISTOGRAM_COUNTS_WIRE => {
                        if (res._chunk_payload_histogram_counts_offset == null) {
                            res._chunk_payload_histogram_counts_offset = offset;
                        }
                        if (tag.wire == gremlin.ProtoWireType.bytes) {
                            res._chunk_payload_histogram_counts_packed = true;
                            const length_result = try buf.readVarInt(offset);
                            res._chunk_payload_histogram_counts_offset = offset + length_result.size;
                            res._chunk_payload_histogram_counts_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                            offset = res._chunk_payload_histogram_counts_last_offset.?;
                        } else {
                            const result = try buf.readUInt64(offset);
                            offset += result.size;
                            res._chunk_payload_histogram_counts_last_offset = offset;
                        }
                    },
                    TraceStats.WriterStatsWire.CHUNK_PAYLOAD_HISTOGRAM_SUM_WIRE => {
                        if (res._chunk_payload_histogram_sum_offset == null) {
                            res._chunk_payload_histogram_sum_offset = offset;
                        }
                        if (tag.wire == gremlin.ProtoWireType.bytes) {
                            res._chunk_payload_histogram_sum_packed = true;
                            const length_result = try buf.readVarInt(offset);
                            res._chunk_payload_histogram_sum_offset = offset + length_result.size;
                            res._chunk_payload_histogram_sum_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                            offset = res._chunk_payload_histogram_sum_last_offset.?;
                        } else {
                            const result = try buf.readInt64(offset);
                            offset += result.size;
                            res._chunk_payload_histogram_sum_last_offset = offset;
                        }
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getSequenceId(self: *const TraceStats.WriterStatsReader) u64 {
            return self._sequence_id;
        }
        pub inline fn getBuffer(self: *const TraceStats.WriterStatsReader) u32 {
            return self._buffer;
        }
        pub fn chunkPayloadHistogramCountsNext(self: *TraceStats.WriterStatsReader) gremlin.Error!?u64 {
            if (self._chunk_payload_histogram_counts_offset == null) return null;
            const current_offset = self._chunk_payload_histogram_counts_offset.?;
            if (current_offset >= self._chunk_payload_histogram_counts_last_offset.?) {
                self._chunk_payload_histogram_counts_offset = null;
                return null;
            }
            if (self._chunk_payload_histogram_counts_packed) {
                const value_result = try self.buf.readUInt64(current_offset);
                self._chunk_payload_histogram_counts_offset = current_offset + value_result.size;
                if (self._chunk_payload_histogram_counts_offset.? >= self._chunk_payload_histogram_counts_last_offset.?) {
                    self._chunk_payload_histogram_counts_offset = null;
                }
                return value_result.value;
            } else {
                const value_result = try self.buf.readUInt64(current_offset);
                var next_offset = current_offset + value_result.size;
                const max_offset = self._chunk_payload_histogram_counts_last_offset.?;
                // Search for the next occurrence of this field
                while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                    const next_tag = try self.buf.readTagAt(next_offset);
                    next_offset += next_tag.size;
                    if (next_tag.number == TraceStats.WriterStatsWire.CHUNK_PAYLOAD_HISTOGRAM_COUNTS_WIRE) {
                        self._chunk_payload_histogram_counts_offset = next_offset;
                        return value_result.value;
                    } else {
                        next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                    }
                }
                self._chunk_payload_histogram_counts_offset = null;
                return value_result.value;
            }
        }
        pub fn chunkPayloadHistogramSumNext(self: *TraceStats.WriterStatsReader) gremlin.Error!?i64 {
            if (self._chunk_payload_histogram_sum_offset == null) return null;
            const current_offset = self._chunk_payload_histogram_sum_offset.?;
            if (current_offset >= self._chunk_payload_histogram_sum_last_offset.?) {
                self._chunk_payload_histogram_sum_offset = null;
                return null;
            }
            if (self._chunk_payload_histogram_sum_packed) {
                const value_result = try self.buf.readInt64(current_offset);
                self._chunk_payload_histogram_sum_offset = current_offset + value_result.size;
                if (self._chunk_payload_histogram_sum_offset.? >= self._chunk_payload_histogram_sum_last_offset.?) {
                    self._chunk_payload_histogram_sum_offset = null;
                }
                return value_result.value;
            } else {
                const value_result = try self.buf.readInt64(current_offset);
                var next_offset = current_offset + value_result.size;
                const max_offset = self._chunk_payload_histogram_sum_last_offset.?;
                // Search for the next occurrence of this field
                while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                    const next_tag = try self.buf.readTagAt(next_offset);
                    next_offset += next_tag.size;
                    if (next_tag.number == TraceStats.WriterStatsWire.CHUNK_PAYLOAD_HISTOGRAM_SUM_WIRE) {
                        self._chunk_payload_histogram_sum_offset = next_offset;
                        return value_result.value;
                    } else {
                        next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                    }
                }
                self._chunk_payload_histogram_sum_offset = null;
                return value_result.value;
            }
        }
    };
    const FilterStatsWire = struct {
        const INPUT_PACKETS_WIRE: gremlin.ProtoWireNumber = 1;
        const INPUT_BYTES_WIRE: gremlin.ProtoWireNumber = 2;
        const OUTPUT_BYTES_WIRE: gremlin.ProtoWireNumber = 3;
        const ERRORS_WIRE: gremlin.ProtoWireNumber = 4;
        const TIME_TAKEN_NS_WIRE: gremlin.ProtoWireNumber = 5;
        const BYTES_DISCARDED_PER_BUFFER_WIRE: gremlin.ProtoWireNumber = 20;
    };
    pub const FilterStats = struct {
        // fields
        input_packets: u64 = 0,
        input_bytes: u64 = 0,
        output_bytes: u64 = 0,
        errors: u64 = 0,
        time_taken_ns: u64 = 0,
        bytes_discarded_per_buffer: ?[]const u64 = null,
        pub fn calcProtobufSize(self: *const TraceStats.FilterStats) usize {
            var res: usize = 0;
            if (self.input_packets != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceStats.FilterStatsWire.INPUT_PACKETS_WIRE) + gremlin.sizes.sizeU64(self.input_packets);
            }
            if (self.input_bytes != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceStats.FilterStatsWire.INPUT_BYTES_WIRE) + gremlin.sizes.sizeU64(self.input_bytes);
            }
            if (self.output_bytes != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceStats.FilterStatsWire.OUTPUT_BYTES_WIRE) + gremlin.sizes.sizeU64(self.output_bytes);
            }
            if (self.errors != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceStats.FilterStatsWire.ERRORS_WIRE) + gremlin.sizes.sizeU64(self.errors);
            }
            if (self.time_taken_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceStats.FilterStatsWire.TIME_TAKEN_NS_WIRE) + gremlin.sizes.sizeU64(self.time_taken_ns);
            }
            if (self.bytes_discarded_per_buffer) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    res += gremlin.sizes.sizeWireNumber(TraceStats.FilterStatsWire.BYTES_DISCARDED_PER_BUFFER_WIRE) + gremlin.sizes.sizeU64(arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeU64(v);
                    }
                    res += gremlin.sizes.sizeWireNumber(TraceStats.FilterStatsWire.BYTES_DISCARDED_PER_BUFFER_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
                }
            }
            return res;
        }
        pub fn encode(self: *const TraceStats.FilterStats, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const TraceStats.FilterStats, target: *gremlin.Writer) void {
            if (self.input_packets != 0) {
                target.appendUint64(TraceStats.FilterStatsWire.INPUT_PACKETS_WIRE, self.input_packets);
            }
            if (self.input_bytes != 0) {
                target.appendUint64(TraceStats.FilterStatsWire.INPUT_BYTES_WIRE, self.input_bytes);
            }
            if (self.output_bytes != 0) {
                target.appendUint64(TraceStats.FilterStatsWire.OUTPUT_BYTES_WIRE, self.output_bytes);
            }
            if (self.errors != 0) {
                target.appendUint64(TraceStats.FilterStatsWire.ERRORS_WIRE, self.errors);
            }
            if (self.time_taken_ns != 0) {
                target.appendUint64(TraceStats.FilterStatsWire.TIME_TAKEN_NS_WIRE, self.time_taken_ns);
            }
            if (self.bytes_discarded_per_buffer) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    target.appendUint64(TraceStats.FilterStatsWire.BYTES_DISCARDED_PER_BUFFER_WIRE, arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeU64(v);
                    }
                    target.appendBytesTag(TraceStats.FilterStatsWire.BYTES_DISCARDED_PER_BUFFER_WIRE, packed_size);
                    for (arr) |v| {
                        target.appendUint64WithoutTag(v);
                    }
                }
            }
        }
    };
    pub const FilterStatsReader = struct {
        buf: gremlin.Reader,
        _input_packets: u64 = 0,
        _input_bytes: u64 = 0,
        _output_bytes: u64 = 0,
        _errors: u64 = 0,
        _time_taken_ns: u64 = 0,
        _bytes_discarded_per_buffer_offset: ?usize = null,
        _bytes_discarded_per_buffer_last_offset: ?usize = null,
        _bytes_discarded_per_buffer_packed: bool = false,
        pub fn init(src: []const u8) gremlin.Error!TraceStats.FilterStatsReader {
            const buf = gremlin.Reader.init(src);
            var res = TraceStats.FilterStatsReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    TraceStats.FilterStatsWire.INPUT_PACKETS_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._input_packets = result.value;
                    },
                    TraceStats.FilterStatsWire.INPUT_BYTES_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._input_bytes = result.value;
                    },
                    TraceStats.FilterStatsWire.OUTPUT_BYTES_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._output_bytes = result.value;
                    },
                    TraceStats.FilterStatsWire.ERRORS_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._errors = result.value;
                    },
                    TraceStats.FilterStatsWire.TIME_TAKEN_NS_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._time_taken_ns = result.value;
                    },
                    TraceStats.FilterStatsWire.BYTES_DISCARDED_PER_BUFFER_WIRE => {
                        if (res._bytes_discarded_per_buffer_offset == null) {
                            res._bytes_discarded_per_buffer_offset = offset;
                        }
                        if (tag.wire == gremlin.ProtoWireType.bytes) {
                            res._bytes_discarded_per_buffer_packed = true;
                            const length_result = try buf.readVarInt(offset);
                            res._bytes_discarded_per_buffer_offset = offset + length_result.size;
                            res._bytes_discarded_per_buffer_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                            offset = res._bytes_discarded_per_buffer_last_offset.?;
                        } else {
                            const result = try buf.readUInt64(offset);
                            offset += result.size;
                            res._bytes_discarded_per_buffer_last_offset = offset;
                        }
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getInputPackets(self: *const TraceStats.FilterStatsReader) u64 {
            return self._input_packets;
        }
        pub inline fn getInputBytes(self: *const TraceStats.FilterStatsReader) u64 {
            return self._input_bytes;
        }
        pub inline fn getOutputBytes(self: *const TraceStats.FilterStatsReader) u64 {
            return self._output_bytes;
        }
        pub inline fn getErrors(self: *const TraceStats.FilterStatsReader) u64 {
            return self._errors;
        }
        pub inline fn getTimeTakenNs(self: *const TraceStats.FilterStatsReader) u64 {
            return self._time_taken_ns;
        }
        pub fn bytesDiscardedPerBufferNext(self: *TraceStats.FilterStatsReader) gremlin.Error!?u64 {
            if (self._bytes_discarded_per_buffer_offset == null) return null;
            const current_offset = self._bytes_discarded_per_buffer_offset.?;
            if (current_offset >= self._bytes_discarded_per_buffer_last_offset.?) {
                self._bytes_discarded_per_buffer_offset = null;
                return null;
            }
            if (self._bytes_discarded_per_buffer_packed) {
                const value_result = try self.buf.readUInt64(current_offset);
                self._bytes_discarded_per_buffer_offset = current_offset + value_result.size;
                if (self._bytes_discarded_per_buffer_offset.? >= self._bytes_discarded_per_buffer_last_offset.?) {
                    self._bytes_discarded_per_buffer_offset = null;
                }
                return value_result.value;
            } else {
                const value_result = try self.buf.readUInt64(current_offset);
                var next_offset = current_offset + value_result.size;
                const max_offset = self._bytes_discarded_per_buffer_last_offset.?;
                // Search for the next occurrence of this field
                while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                    const next_tag = try self.buf.readTagAt(next_offset);
                    next_offset += next_tag.size;
                    if (next_tag.number == TraceStats.FilterStatsWire.BYTES_DISCARDED_PER_BUFFER_WIRE) {
                        self._bytes_discarded_per_buffer_offset = next_offset;
                        return value_result.value;
                    } else {
                        next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                    }
                }
                self._bytes_discarded_per_buffer_offset = null;
                return value_result.value;
            }
        }
    };
    // fields
    buffer_stats: ?[]const ?TraceStats.BufferStats = null,
    chunk_payload_histogram_def: ?[]const i64 = null,
    writer_stats: ?[]const ?TraceStats.WriterStats = null,
    producers_connected: u32 = 0,
    producers_seen: u64 = 0,
    data_sources_registered: u32 = 0,
    data_sources_seen: u64 = 0,
    tracing_sessions: u32 = 0,
    total_buffers: u32 = 0,
    chunks_discarded: u64 = 0,
    patches_discarded: u64 = 0,
    invalid_packets: u64 = 0,
    filter_stats: ?TraceStats.FilterStats = null,
    flushes_requested: u64 = 0,
    flushes_succeeded: u64 = 0,
    flushes_failed: u64 = 0,
    final_flush_outcome: TraceStats.FinalFlushOutcome = @enumFromInt(0),
    pub fn calcProtobufSize(self: *const TraceStats) usize {
        var res: usize = 0;
        if (self.buffer_stats) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TraceStatsWire.BUFFER_STATS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.chunk_payload_histogram_def) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(TraceStatsWire.CHUNK_PAYLOAD_HISTOGRAM_DEF_WIRE) + gremlin.sizes.sizeI64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI64(v);
                }
                res += gremlin.sizes.sizeWireNumber(TraceStatsWire.CHUNK_PAYLOAD_HISTOGRAM_DEF_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.writer_stats) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TraceStatsWire.WRITER_STATS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.producers_connected != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceStatsWire.PRODUCERS_CONNECTED_WIRE) + gremlin.sizes.sizeU32(self.producers_connected);
        }
        if (self.producers_seen != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceStatsWire.PRODUCERS_SEEN_WIRE) + gremlin.sizes.sizeU64(self.producers_seen);
        }
        if (self.data_sources_registered != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceStatsWire.DATA_SOURCES_REGISTERED_WIRE) + gremlin.sizes.sizeU32(self.data_sources_registered);
        }
        if (self.data_sources_seen != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceStatsWire.DATA_SOURCES_SEEN_WIRE) + gremlin.sizes.sizeU64(self.data_sources_seen);
        }
        if (self.tracing_sessions != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceStatsWire.TRACING_SESSIONS_WIRE) + gremlin.sizes.sizeU32(self.tracing_sessions);
        }
        if (self.total_buffers != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceStatsWire.TOTAL_BUFFERS_WIRE) + gremlin.sizes.sizeU32(self.total_buffers);
        }
        if (self.chunks_discarded != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceStatsWire.CHUNKS_DISCARDED_WIRE) + gremlin.sizes.sizeU64(self.chunks_discarded);
        }
        if (self.patches_discarded != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceStatsWire.PATCHES_DISCARDED_WIRE) + gremlin.sizes.sizeU64(self.patches_discarded);
        }
        if (self.invalid_packets != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceStatsWire.INVALID_PACKETS_WIRE) + gremlin.sizes.sizeU64(self.invalid_packets);
        }
        if (self.filter_stats) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceStatsWire.FILTER_STATS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.flushes_requested != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceStatsWire.FLUSHES_REQUESTED_WIRE) + gremlin.sizes.sizeU64(self.flushes_requested);
        }
        if (self.flushes_succeeded != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceStatsWire.FLUSHES_SUCCEEDED_WIRE) + gremlin.sizes.sizeU64(self.flushes_succeeded);
        }
        if (self.flushes_failed != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceStatsWire.FLUSHES_FAILED_WIRE) + gremlin.sizes.sizeU64(self.flushes_failed);
        }
        if (@intFromEnum(self.final_flush_outcome) != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceStatsWire.FINAL_FLUSH_OUTCOME_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.final_flush_outcome));
        }
        return res;
    }
    pub fn encode(self: *const TraceStats, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TraceStats, target: *gremlin.Writer) void {
        if (self.buffer_stats) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(TraceStatsWire.BUFFER_STATS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(TraceStatsWire.BUFFER_STATS_WIRE, 0);
                }
            }
        }
        if (self.chunk_payload_histogram_def) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt64(TraceStatsWire.CHUNK_PAYLOAD_HISTOGRAM_DEF_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI64(v);
                }
                target.appendBytesTag(TraceStatsWire.CHUNK_PAYLOAD_HISTOGRAM_DEF_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt64WithoutTag(v);
                }
            }
        }
        if (self.writer_stats) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(TraceStatsWire.WRITER_STATS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(TraceStatsWire.WRITER_STATS_WIRE, 0);
                }
            }
        }
        if (self.producers_connected != 0) {
            target.appendUint32(TraceStatsWire.PRODUCERS_CONNECTED_WIRE, self.producers_connected);
        }
        if (self.producers_seen != 0) {
            target.appendUint64(TraceStatsWire.PRODUCERS_SEEN_WIRE, self.producers_seen);
        }
        if (self.data_sources_registered != 0) {
            target.appendUint32(TraceStatsWire.DATA_SOURCES_REGISTERED_WIRE, self.data_sources_registered);
        }
        if (self.data_sources_seen != 0) {
            target.appendUint64(TraceStatsWire.DATA_SOURCES_SEEN_WIRE, self.data_sources_seen);
        }
        if (self.tracing_sessions != 0) {
            target.appendUint32(TraceStatsWire.TRACING_SESSIONS_WIRE, self.tracing_sessions);
        }
        if (self.total_buffers != 0) {
            target.appendUint32(TraceStatsWire.TOTAL_BUFFERS_WIRE, self.total_buffers);
        }
        if (self.chunks_discarded != 0) {
            target.appendUint64(TraceStatsWire.CHUNKS_DISCARDED_WIRE, self.chunks_discarded);
        }
        if (self.patches_discarded != 0) {
            target.appendUint64(TraceStatsWire.PATCHES_DISCARDED_WIRE, self.patches_discarded);
        }
        if (self.invalid_packets != 0) {
            target.appendUint64(TraceStatsWire.INVALID_PACKETS_WIRE, self.invalid_packets);
        }
        if (self.filter_stats) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceStatsWire.FILTER_STATS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.flushes_requested != 0) {
            target.appendUint64(TraceStatsWire.FLUSHES_REQUESTED_WIRE, self.flushes_requested);
        }
        if (self.flushes_succeeded != 0) {
            target.appendUint64(TraceStatsWire.FLUSHES_SUCCEEDED_WIRE, self.flushes_succeeded);
        }
        if (self.flushes_failed != 0) {
            target.appendUint64(TraceStatsWire.FLUSHES_FAILED_WIRE, self.flushes_failed);
        }
        if (@intFromEnum(self.final_flush_outcome) != 0) {
            target.appendInt32(TraceStatsWire.FINAL_FLUSH_OUTCOME_WIRE, @intFromEnum(self.final_flush_outcome));
        }
    }
};
pub const TraceStatsReader = struct {
    buf: gremlin.Reader,
    _buffer_stats_offset: ?usize = null,
    _buffer_stats_last_offset: ?usize = null,
    _buffer_stats_cnt: usize = 0,
    _chunk_payload_histogram_def_offset: ?usize = null,
    _chunk_payload_histogram_def_last_offset: ?usize = null,
    _chunk_payload_histogram_def_packed: bool = false,
    _writer_stats_offset: ?usize = null,
    _writer_stats_last_offset: ?usize = null,
    _writer_stats_cnt: usize = 0,
    _producers_connected: u32 = 0,
    _producers_seen: u64 = 0,
    _data_sources_registered: u32 = 0,
    _data_sources_seen: u64 = 0,
    _tracing_sessions: u32 = 0,
    _total_buffers: u32 = 0,
    _chunks_discarded: u64 = 0,
    _patches_discarded: u64 = 0,
    _invalid_packets: u64 = 0,
    _filter_stats_buf: ?[]const u8 = null,
    _flushes_requested: u64 = 0,
    _flushes_succeeded: u64 = 0,
    _flushes_failed: u64 = 0,
    _final_flush_outcome: TraceStats.FinalFlushOutcome = @enumFromInt(0),
    pub fn init(src: []const u8) gremlin.Error!TraceStatsReader {
        const buf = gremlin.Reader.init(src);
        var res = TraceStatsReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TraceStatsWire.BUFFER_STATS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._buffer_stats_offset == null) {
                        res._buffer_stats_offset = offset - result.size;
                    }
                    res._buffer_stats_last_offset = offset;
                    res._buffer_stats_cnt += 1;
                },
                TraceStatsWire.CHUNK_PAYLOAD_HISTOGRAM_DEF_WIRE => {
                    if (res._chunk_payload_histogram_def_offset == null) {
                        res._chunk_payload_histogram_def_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._chunk_payload_histogram_def_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._chunk_payload_histogram_def_offset = offset + length_result.size;
                        res._chunk_payload_histogram_def_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._chunk_payload_histogram_def_last_offset.?;
                    } else {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._chunk_payload_histogram_def_last_offset = offset;
                    }
                },
                TraceStatsWire.WRITER_STATS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._writer_stats_offset == null) {
                        res._writer_stats_offset = offset - result.size;
                    }
                    res._writer_stats_last_offset = offset;
                    res._writer_stats_cnt += 1;
                },
                TraceStatsWire.PRODUCERS_CONNECTED_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._producers_connected = result.value;
                },
                TraceStatsWire.PRODUCERS_SEEN_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._producers_seen = result.value;
                },
                TraceStatsWire.DATA_SOURCES_REGISTERED_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._data_sources_registered = result.value;
                },
                TraceStatsWire.DATA_SOURCES_SEEN_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._data_sources_seen = result.value;
                },
                TraceStatsWire.TRACING_SESSIONS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._tracing_sessions = result.value;
                },
                TraceStatsWire.TOTAL_BUFFERS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._total_buffers = result.value;
                },
                TraceStatsWire.CHUNKS_DISCARDED_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._chunks_discarded = result.value;
                },
                TraceStatsWire.PATCHES_DISCARDED_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._patches_discarded = result.value;
                },
                TraceStatsWire.INVALID_PACKETS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._invalid_packets = result.value;
                },
                TraceStatsWire.FILTER_STATS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._filter_stats_buf = result.value;
                },
                TraceStatsWire.FLUSHES_REQUESTED_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._flushes_requested = result.value;
                },
                TraceStatsWire.FLUSHES_SUCCEEDED_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._flushes_succeeded = result.value;
                },
                TraceStatsWire.FLUSHES_FAILED_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._flushes_failed = result.value;
                },
                TraceStatsWire.FINAL_FLUSH_OUTCOME_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._final_flush_outcome = @enumFromInt(result.value);
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn bufferStatsCount(self: *const TraceStatsReader) usize {
        return self._buffer_stats_cnt;
    }
    pub fn bufferStatsNext(self: *TraceStatsReader) ?TraceStats.BufferStatsReader {
        if (self._buffer_stats_offset == null) return null;
        const current_offset = self._buffer_stats_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = TraceStats.BufferStatsReader.init(result.value) catch return null;
        if (self._buffer_stats_last_offset != null and current_offset >= self._buffer_stats_last_offset.?) {
            self._buffer_stats_offset = null;
            return msg;
        }
        if (self._buffer_stats_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._buffer_stats_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TraceStatsWire.BUFFER_STATS_WIRE) {
                self._buffer_stats_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._buffer_stats_offset = null;
        return msg;
    }
    pub fn chunkPayloadHistogramDefNext(self: *TraceStatsReader) gremlin.Error!?i64 {
        if (self._chunk_payload_histogram_def_offset == null) return null;
        const current_offset = self._chunk_payload_histogram_def_offset.?;
        if (current_offset >= self._chunk_payload_histogram_def_last_offset.?) {
            self._chunk_payload_histogram_def_offset = null;
            return null;
        }
        if (self._chunk_payload_histogram_def_packed) {
            const value_result = try self.buf.readInt64(current_offset);
            self._chunk_payload_histogram_def_offset = current_offset + value_result.size;
            if (self._chunk_payload_histogram_def_offset.? >= self._chunk_payload_histogram_def_last_offset.?) {
                self._chunk_payload_histogram_def_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._chunk_payload_histogram_def_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == TraceStatsWire.CHUNK_PAYLOAD_HISTOGRAM_DEF_WIRE) {
                    self._chunk_payload_histogram_def_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._chunk_payload_histogram_def_offset = null;
            return value_result.value;
        }
    }
    pub fn writerStatsCount(self: *const TraceStatsReader) usize {
        return self._writer_stats_cnt;
    }
    pub fn writerStatsNext(self: *TraceStatsReader) ?TraceStats.WriterStatsReader {
        if (self._writer_stats_offset == null) return null;
        const current_offset = self._writer_stats_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = TraceStats.WriterStatsReader.init(result.value) catch return null;
        if (self._writer_stats_last_offset != null and current_offset >= self._writer_stats_last_offset.?) {
            self._writer_stats_offset = null;
            return msg;
        }
        if (self._writer_stats_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._writer_stats_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TraceStatsWire.WRITER_STATS_WIRE) {
                self._writer_stats_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._writer_stats_offset = null;
        return msg;
    }
    pub inline fn getProducersConnected(self: *const TraceStatsReader) u32 {
        return self._producers_connected;
    }
    pub inline fn getProducersSeen(self: *const TraceStatsReader) u64 {
        return self._producers_seen;
    }
    pub inline fn getDataSourcesRegistered(self: *const TraceStatsReader) u32 {
        return self._data_sources_registered;
    }
    pub inline fn getDataSourcesSeen(self: *const TraceStatsReader) u64 {
        return self._data_sources_seen;
    }
    pub inline fn getTracingSessions(self: *const TraceStatsReader) u32 {
        return self._tracing_sessions;
    }
    pub inline fn getTotalBuffers(self: *const TraceStatsReader) u32 {
        return self._total_buffers;
    }
    pub inline fn getChunksDiscarded(self: *const TraceStatsReader) u64 {
        return self._chunks_discarded;
    }
    pub inline fn getPatchesDiscarded(self: *const TraceStatsReader) u64 {
        return self._patches_discarded;
    }
    pub inline fn getInvalidPackets(self: *const TraceStatsReader) u64 {
        return self._invalid_packets;
    }
    pub fn getFilterStats(self: *const TraceStatsReader) gremlin.Error!TraceStats.FilterStatsReader {
        if (self._filter_stats_buf) |buf| {
            return try TraceStats.FilterStatsReader.init(buf);
        }
        return try TraceStats.FilterStatsReader.init(&[_]u8{});
    }
    pub inline fn getFlushesRequested(self: *const TraceStatsReader) u64 {
        return self._flushes_requested;
    }
    pub inline fn getFlushesSucceeded(self: *const TraceStatsReader) u64 {
        return self._flushes_succeeded;
    }
    pub inline fn getFlushesFailed(self: *const TraceStatsReader) u64 {
        return self._flushes_failed;
    }
    pub inline fn getFinalFlushOutcome(self: *const TraceStatsReader) TraceStats.FinalFlushOutcome {
        return self._final_flush_outcome;
    }
};
