// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const UtsnameWire = struct {
    const SYSNAME_WIRE: gremlin.ProtoWireNumber = 1;
    const VERSION_WIRE: gremlin.ProtoWireNumber = 2;
    const RELEASE_WIRE: gremlin.ProtoWireNumber = 3;
    const MACHINE_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const Utsname = struct {
    // fields
    sysname: ?[]const u8 = null,
    version: ?[]const u8 = null,
    release: ?[]const u8 = null,
    machine: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const Utsname) usize {
        var res: usize = 0;
        if (self.sysname) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(UtsnameWire.SYSNAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.version) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(UtsnameWire.VERSION_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.release) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(UtsnameWire.RELEASE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.machine) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(UtsnameWire.MACHINE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const Utsname, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Utsname, target: *gremlin.Writer) void {
        if (self.sysname) |v| {
            if (v.len > 0) {
                target.appendBytes(UtsnameWire.SYSNAME_WIRE, v);
            }
        }
        if (self.version) |v| {
            if (v.len > 0) {
                target.appendBytes(UtsnameWire.VERSION_WIRE, v);
            }
        }
        if (self.release) |v| {
            if (v.len > 0) {
                target.appendBytes(UtsnameWire.RELEASE_WIRE, v);
            }
        }
        if (self.machine) |v| {
            if (v.len > 0) {
                target.appendBytes(UtsnameWire.MACHINE_WIRE, v);
            }
        }
    }
};
pub const UtsnameReader = struct {
    buf: gremlin.Reader,
    _sysname: ?[]const u8 = null,
    _version: ?[]const u8 = null,
    _release: ?[]const u8 = null,
    _machine: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!UtsnameReader {
        const buf = gremlin.Reader.init(src);
        var res = UtsnameReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                UtsnameWire.SYSNAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._sysname = result.value;
                },
                UtsnameWire.VERSION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._version = result.value;
                },
                UtsnameWire.RELEASE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._release = result.value;
                },
                UtsnameWire.MACHINE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._machine = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getSysname(self: *const UtsnameReader) []const u8 {
        return self._sysname orelse &[_]u8{};
    }
    pub inline fn getVersion(self: *const UtsnameReader) []const u8 {
        return self._version orelse &[_]u8{};
    }
    pub inline fn getRelease(self: *const UtsnameReader) []const u8 {
        return self._release orelse &[_]u8{};
    }
    pub inline fn getMachine(self: *const UtsnameReader) []const u8 {
        return self._machine orelse &[_]u8{};
    }
};
const SystemInfoWire = struct {
    const UTSNAME_WIRE: gremlin.ProtoWireNumber = 1;
    const ANDROID_BUILD_FINGERPRINT_WIRE: gremlin.ProtoWireNumber = 2;
    const ANDROID_DEVICE_MANUFACTURER_WIRE: gremlin.ProtoWireNumber = 14;
    const ANDROID_SOC_MODEL_WIRE: gremlin.ProtoWireNumber = 9;
    const ANDROID_GUEST_SOC_MODEL_WIRE: gremlin.ProtoWireNumber = 13;
    const ANDROID_HARDWARE_REVISION_WIRE: gremlin.ProtoWireNumber = 10;
    const ANDROID_STORAGE_MODEL_WIRE: gremlin.ProtoWireNumber = 11;
    const ANDROID_RAM_MODEL_WIRE: gremlin.ProtoWireNumber = 12;
    const ANDROID_SERIAL_CONSOLE_WIRE: gremlin.ProtoWireNumber = 15;
    const TRACING_SERVICE_VERSION_WIRE: gremlin.ProtoWireNumber = 4;
    const ANDROID_SDK_VERSION_WIRE: gremlin.ProtoWireNumber = 5;
    const PAGE_SIZE_WIRE: gremlin.ProtoWireNumber = 6;
    const NUM_CPUS_WIRE: gremlin.ProtoWireNumber = 8;
    const TIMEZONE_OFF_MINS_WIRE: gremlin.ProtoWireNumber = 7;
    const HZ_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const SystemInfo = struct {
    // fields
    utsname: ?Utsname = null,
    android_build_fingerprint: ?[]const u8 = null,
    android_device_manufacturer: ?[]const u8 = null,
    android_soc_model: ?[]const u8 = null,
    android_guest_soc_model: ?[]const u8 = null,
    android_hardware_revision: ?[]const u8 = null,
    android_storage_model: ?[]const u8 = null,
    android_ram_model: ?[]const u8 = null,
    android_serial_console: ?[]const u8 = null,
    tracing_service_version: ?[]const u8 = null,
    android_sdk_version: u64 = 0,
    page_size: u32 = 0,
    num_cpus: u32 = 0,
    timezone_off_mins: i32 = 0,
    hz: i64 = 0,
    pub fn calcProtobufSize(self: *const SystemInfo) usize {
        var res: usize = 0;
        if (self.utsname) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(SystemInfoWire.UTSNAME_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_build_fingerprint) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(SystemInfoWire.ANDROID_BUILD_FINGERPRINT_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.android_device_manufacturer) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(SystemInfoWire.ANDROID_DEVICE_MANUFACTURER_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.android_soc_model) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(SystemInfoWire.ANDROID_SOC_MODEL_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.android_guest_soc_model) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(SystemInfoWire.ANDROID_GUEST_SOC_MODEL_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.android_hardware_revision) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(SystemInfoWire.ANDROID_HARDWARE_REVISION_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.android_storage_model) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(SystemInfoWire.ANDROID_STORAGE_MODEL_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.android_ram_model) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(SystemInfoWire.ANDROID_RAM_MODEL_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.android_serial_console) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(SystemInfoWire.ANDROID_SERIAL_CONSOLE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.tracing_service_version) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(SystemInfoWire.TRACING_SERVICE_VERSION_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.android_sdk_version != 0) {
            res += gremlin.sizes.sizeWireNumber(SystemInfoWire.ANDROID_SDK_VERSION_WIRE) + gremlin.sizes.sizeU64(self.android_sdk_version);
        }
        if (self.page_size != 0) {
            res += gremlin.sizes.sizeWireNumber(SystemInfoWire.PAGE_SIZE_WIRE) + gremlin.sizes.sizeU32(self.page_size);
        }
        if (self.num_cpus != 0) {
            res += gremlin.sizes.sizeWireNumber(SystemInfoWire.NUM_CPUS_WIRE) + gremlin.sizes.sizeU32(self.num_cpus);
        }
        if (self.timezone_off_mins != 0) {
            res += gremlin.sizes.sizeWireNumber(SystemInfoWire.TIMEZONE_OFF_MINS_WIRE) + gremlin.sizes.sizeI32(self.timezone_off_mins);
        }
        if (self.hz != 0) {
            res += gremlin.sizes.sizeWireNumber(SystemInfoWire.HZ_WIRE) + gremlin.sizes.sizeI64(self.hz);
        }
        return res;
    }
    pub fn encode(self: *const SystemInfo, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SystemInfo, target: *gremlin.Writer) void {
        if (self.utsname) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(SystemInfoWire.UTSNAME_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_build_fingerprint) |v| {
            if (v.len > 0) {
                target.appendBytes(SystemInfoWire.ANDROID_BUILD_FINGERPRINT_WIRE, v);
            }
        }
        if (self.android_device_manufacturer) |v| {
            if (v.len > 0) {
                target.appendBytes(SystemInfoWire.ANDROID_DEVICE_MANUFACTURER_WIRE, v);
            }
        }
        if (self.android_soc_model) |v| {
            if (v.len > 0) {
                target.appendBytes(SystemInfoWire.ANDROID_SOC_MODEL_WIRE, v);
            }
        }
        if (self.android_guest_soc_model) |v| {
            if (v.len > 0) {
                target.appendBytes(SystemInfoWire.ANDROID_GUEST_SOC_MODEL_WIRE, v);
            }
        }
        if (self.android_hardware_revision) |v| {
            if (v.len > 0) {
                target.appendBytes(SystemInfoWire.ANDROID_HARDWARE_REVISION_WIRE, v);
            }
        }
        if (self.android_storage_model) |v| {
            if (v.len > 0) {
                target.appendBytes(SystemInfoWire.ANDROID_STORAGE_MODEL_WIRE, v);
            }
        }
        if (self.android_ram_model) |v| {
            if (v.len > 0) {
                target.appendBytes(SystemInfoWire.ANDROID_RAM_MODEL_WIRE, v);
            }
        }
        if (self.android_serial_console) |v| {
            if (v.len > 0) {
                target.appendBytes(SystemInfoWire.ANDROID_SERIAL_CONSOLE_WIRE, v);
            }
        }
        if (self.tracing_service_version) |v| {
            if (v.len > 0) {
                target.appendBytes(SystemInfoWire.TRACING_SERVICE_VERSION_WIRE, v);
            }
        }
        if (self.android_sdk_version != 0) {
            target.appendUint64(SystemInfoWire.ANDROID_SDK_VERSION_WIRE, self.android_sdk_version);
        }
        if (self.page_size != 0) {
            target.appendUint32(SystemInfoWire.PAGE_SIZE_WIRE, self.page_size);
        }
        if (self.num_cpus != 0) {
            target.appendUint32(SystemInfoWire.NUM_CPUS_WIRE, self.num_cpus);
        }
        if (self.timezone_off_mins != 0) {
            target.appendInt32(SystemInfoWire.TIMEZONE_OFF_MINS_WIRE, self.timezone_off_mins);
        }
        if (self.hz != 0) {
            target.appendInt64(SystemInfoWire.HZ_WIRE, self.hz);
        }
    }
};
pub const SystemInfoReader = struct {
    buf: gremlin.Reader,
    _utsname_buf: ?[]const u8 = null,
    _android_build_fingerprint: ?[]const u8 = null,
    _android_device_manufacturer: ?[]const u8 = null,
    _android_soc_model: ?[]const u8 = null,
    _android_guest_soc_model: ?[]const u8 = null,
    _android_hardware_revision: ?[]const u8 = null,
    _android_storage_model: ?[]const u8 = null,
    _android_ram_model: ?[]const u8 = null,
    _android_serial_console: ?[]const u8 = null,
    _tracing_service_version: ?[]const u8 = null,
    _android_sdk_version: u64 = 0,
    _page_size: u32 = 0,
    _num_cpus: u32 = 0,
    _timezone_off_mins: i32 = 0,
    _hz: i64 = 0,
    pub fn init(src: []const u8) gremlin.Error!SystemInfoReader {
        const buf = gremlin.Reader.init(src);
        var res = SystemInfoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SystemInfoWire.UTSNAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._utsname_buf = result.value;
                },
                SystemInfoWire.ANDROID_BUILD_FINGERPRINT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_build_fingerprint = result.value;
                },
                SystemInfoWire.ANDROID_DEVICE_MANUFACTURER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_device_manufacturer = result.value;
                },
                SystemInfoWire.ANDROID_SOC_MODEL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_soc_model = result.value;
                },
                SystemInfoWire.ANDROID_GUEST_SOC_MODEL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_guest_soc_model = result.value;
                },
                SystemInfoWire.ANDROID_HARDWARE_REVISION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_hardware_revision = result.value;
                },
                SystemInfoWire.ANDROID_STORAGE_MODEL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_storage_model = result.value;
                },
                SystemInfoWire.ANDROID_RAM_MODEL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_ram_model = result.value;
                },
                SystemInfoWire.ANDROID_SERIAL_CONSOLE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_serial_console = result.value;
                },
                SystemInfoWire.TRACING_SERVICE_VERSION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._tracing_service_version = result.value;
                },
                SystemInfoWire.ANDROID_SDK_VERSION_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._android_sdk_version = result.value;
                },
                SystemInfoWire.PAGE_SIZE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._page_size = result.value;
                },
                SystemInfoWire.NUM_CPUS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._num_cpus = result.value;
                },
                SystemInfoWire.TIMEZONE_OFF_MINS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._timezone_off_mins = result.value;
                },
                SystemInfoWire.HZ_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._hz = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getUtsname(self: *const SystemInfoReader) gremlin.Error!UtsnameReader {
        if (self._utsname_buf) |buf| {
            return try UtsnameReader.init(buf);
        }
        return try UtsnameReader.init(&[_]u8{});
    }
    pub inline fn getAndroidBuildFingerprint(self: *const SystemInfoReader) []const u8 {
        return self._android_build_fingerprint orelse &[_]u8{};
    }
    pub inline fn getAndroidDeviceManufacturer(self: *const SystemInfoReader) []const u8 {
        return self._android_device_manufacturer orelse &[_]u8{};
    }
    pub inline fn getAndroidSocModel(self: *const SystemInfoReader) []const u8 {
        return self._android_soc_model orelse &[_]u8{};
    }
    pub inline fn getAndroidGuestSocModel(self: *const SystemInfoReader) []const u8 {
        return self._android_guest_soc_model orelse &[_]u8{};
    }
    pub inline fn getAndroidHardwareRevision(self: *const SystemInfoReader) []const u8 {
        return self._android_hardware_revision orelse &[_]u8{};
    }
    pub inline fn getAndroidStorageModel(self: *const SystemInfoReader) []const u8 {
        return self._android_storage_model orelse &[_]u8{};
    }
    pub inline fn getAndroidRamModel(self: *const SystemInfoReader) []const u8 {
        return self._android_ram_model orelse &[_]u8{};
    }
    pub inline fn getAndroidSerialConsole(self: *const SystemInfoReader) []const u8 {
        return self._android_serial_console orelse &[_]u8{};
    }
    pub inline fn getTracingServiceVersion(self: *const SystemInfoReader) []const u8 {
        return self._tracing_service_version orelse &[_]u8{};
    }
    pub inline fn getAndroidSdkVersion(self: *const SystemInfoReader) u64 {
        return self._android_sdk_version;
    }
    pub inline fn getPageSize(self: *const SystemInfoReader) u32 {
        return self._page_size;
    }
    pub inline fn getNumCpus(self: *const SystemInfoReader) u32 {
        return self._num_cpus;
    }
    pub inline fn getTimezoneOffMins(self: *const SystemInfoReader) i32 {
        return self._timezone_off_mins;
    }
    pub inline fn getHz(self: *const SystemInfoReader) i64 {
        return self._hz;
    }
};
