// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const PerfettoSqlStructuredQueryWire = struct {
    const ID_WIRE: gremlin.ProtoWireNumber = 1;
    const REFERENCED_MODULES_WIRE: gremlin.ProtoWireNumber = 11;
    const FILTERS_WIRE: gremlin.ProtoWireNumber = 8;
    const GROUP_BY_WIRE: gremlin.ProtoWireNumber = 9;
    const SELECT_COLUMNS_WIRE: gremlin.ProtoWireNumber = 10;
    const ORDER_BY_WIRE: gremlin.ProtoWireNumber = 14;
    const LIMIT_WIRE: gremlin.ProtoWireNumber = 12;
    const OFFSET_WIRE: gremlin.ProtoWireNumber = 13;
    const EXPERIMENTAL_FILTER_GROUP_WIRE: gremlin.ProtoWireNumber = 103;
    const TABLE_WIRE: gremlin.ProtoWireNumber = 2;
    const SQL_WIRE: gremlin.ProtoWireNumber = 3;
    const SIMPLE_SLICES_WIRE: gremlin.ProtoWireNumber = 4;
    const INNER_QUERY_WIRE: gremlin.ProtoWireNumber = 5;
    const INNER_QUERY_ID_WIRE: gremlin.ProtoWireNumber = 6;
    const INTERVAL_INTERSECT_WIRE: gremlin.ProtoWireNumber = 7;
    const EXPERIMENTAL_JOIN_WIRE: gremlin.ProtoWireNumber = 100;
    const EXPERIMENTAL_UNION_WIRE: gremlin.ProtoWireNumber = 101;
    const EXPERIMENTAL_ADD_COLUMNS_WIRE: gremlin.ProtoWireNumber = 102;
};
pub const PerfettoSqlStructuredQuery = struct {
    // nested structs
    const TableWire = struct {
        const TABLE_NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const COLUMN_NAMES_WIRE: gremlin.ProtoWireNumber = 3;
        const MODULE_NAME_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const Table = struct {
        // fields
        table_name: ?[]const u8 = null,
        column_names: ?[]const ?[]const u8 = null,
        module_name: ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const PerfettoSqlStructuredQuery.Table) usize {
            var res: usize = 0;
            if (self.table_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.TableWire.TABLE_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.column_names) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.TableWire.COLUMN_NAMES_WIRE);
                    if (maybe_v) |v| {
                        res += gremlin.sizes.sizeUsize(v.len) + v.len;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.module_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.TableWire.MODULE_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            return res;
        }
        pub fn encode(self: *const PerfettoSqlStructuredQuery.Table, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const PerfettoSqlStructuredQuery.Table, target: *gremlin.Writer) void {
            if (self.table_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(PerfettoSqlStructuredQuery.TableWire.TABLE_NAME_WIRE, v);
                }
            }
            if (self.column_names) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        target.appendBytes(PerfettoSqlStructuredQuery.TableWire.COLUMN_NAMES_WIRE, v);
                    } else {
                        target.appendBytesTag(PerfettoSqlStructuredQuery.TableWire.COLUMN_NAMES_WIRE, 0);
                    }
                }
            }
            if (self.module_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(PerfettoSqlStructuredQuery.TableWire.MODULE_NAME_WIRE, v);
                }
            }
        }
    };
    pub const TableReader = struct {
        buf: gremlin.Reader,
        _table_name: ?[]const u8 = null,
        _column_names_offset: ?usize = null,
        _column_names_last_offset: ?usize = null,
        _column_names_cnt: usize = 0,
        _module_name: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!PerfettoSqlStructuredQuery.TableReader {
            const buf = gremlin.Reader.init(src);
            var res = PerfettoSqlStructuredQuery.TableReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    PerfettoSqlStructuredQuery.TableWire.TABLE_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._table_name = result.value;
                    },
                    PerfettoSqlStructuredQuery.TableWire.COLUMN_NAMES_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._column_names_offset == null) {
                            res._column_names_offset = offset - result.size;
                        }
                        res._column_names_last_offset = offset;
                        res._column_names_cnt += 1;
                    },
                    PerfettoSqlStructuredQuery.TableWire.MODULE_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._module_name = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getTableName(self: *const PerfettoSqlStructuredQuery.TableReader) []const u8 {
            return self._table_name orelse &[_]u8{};
        }
        pub fn columnNamesCount(self: *const PerfettoSqlStructuredQuery.TableReader) usize {
            return self._column_names_cnt;
        }
        pub fn columnNamesNext(self: *PerfettoSqlStructuredQuery.TableReader) ?[]const u8 {
            if (self._column_names_offset == null) return null;
            const current_offset = self._column_names_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            if (self._column_names_last_offset != null and current_offset >= self._column_names_last_offset.?) {
                self._column_names_offset = null;
                return result.value;
            }
            if (self._column_names_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._column_names_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == PerfettoSqlStructuredQuery.TableWire.COLUMN_NAMES_WIRE) {
                    self._column_names_offset = next_offset;
                    return result.value;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._column_names_offset = null;
            return result.value;
        }
        pub inline fn getModuleName(self: *const PerfettoSqlStructuredQuery.TableReader) []const u8 {
            return self._module_name orelse &[_]u8{};
        }
    };
    const SimpleSlicesWire = struct {
        const SLICE_NAME_GLOB_WIRE: gremlin.ProtoWireNumber = 1;
        const THREAD_NAME_GLOB_WIRE: gremlin.ProtoWireNumber = 2;
        const PROCESS_NAME_GLOB_WIRE: gremlin.ProtoWireNumber = 3;
        const TRACK_NAME_GLOB_WIRE: gremlin.ProtoWireNumber = 4;
    };
    pub const SimpleSlices = struct {
        // fields
        slice_name_glob: ?[]const u8 = null,
        thread_name_glob: ?[]const u8 = null,
        process_name_glob: ?[]const u8 = null,
        track_name_glob: ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const PerfettoSqlStructuredQuery.SimpleSlices) usize {
            var res: usize = 0;
            if (self.slice_name_glob) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.SimpleSlicesWire.SLICE_NAME_GLOB_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.thread_name_glob) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.SimpleSlicesWire.THREAD_NAME_GLOB_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.process_name_glob) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.SimpleSlicesWire.PROCESS_NAME_GLOB_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.track_name_glob) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.SimpleSlicesWire.TRACK_NAME_GLOB_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            return res;
        }
        pub fn encode(self: *const PerfettoSqlStructuredQuery.SimpleSlices, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const PerfettoSqlStructuredQuery.SimpleSlices, target: *gremlin.Writer) void {
            if (self.slice_name_glob) |v| {
                if (v.len > 0) {
                    target.appendBytes(PerfettoSqlStructuredQuery.SimpleSlicesWire.SLICE_NAME_GLOB_WIRE, v);
                }
            }
            if (self.thread_name_glob) |v| {
                if (v.len > 0) {
                    target.appendBytes(PerfettoSqlStructuredQuery.SimpleSlicesWire.THREAD_NAME_GLOB_WIRE, v);
                }
            }
            if (self.process_name_glob) |v| {
                if (v.len > 0) {
                    target.appendBytes(PerfettoSqlStructuredQuery.SimpleSlicesWire.PROCESS_NAME_GLOB_WIRE, v);
                }
            }
            if (self.track_name_glob) |v| {
                if (v.len > 0) {
                    target.appendBytes(PerfettoSqlStructuredQuery.SimpleSlicesWire.TRACK_NAME_GLOB_WIRE, v);
                }
            }
        }
    };
    pub const SimpleSlicesReader = struct {
        buf: gremlin.Reader,
        _slice_name_glob: ?[]const u8 = null,
        _thread_name_glob: ?[]const u8 = null,
        _process_name_glob: ?[]const u8 = null,
        _track_name_glob: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!PerfettoSqlStructuredQuery.SimpleSlicesReader {
            const buf = gremlin.Reader.init(src);
            var res = PerfettoSqlStructuredQuery.SimpleSlicesReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    PerfettoSqlStructuredQuery.SimpleSlicesWire.SLICE_NAME_GLOB_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._slice_name_glob = result.value;
                    },
                    PerfettoSqlStructuredQuery.SimpleSlicesWire.THREAD_NAME_GLOB_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._thread_name_glob = result.value;
                    },
                    PerfettoSqlStructuredQuery.SimpleSlicesWire.PROCESS_NAME_GLOB_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._process_name_glob = result.value;
                    },
                    PerfettoSqlStructuredQuery.SimpleSlicesWire.TRACK_NAME_GLOB_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._track_name_glob = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getSliceNameGlob(self: *const PerfettoSqlStructuredQuery.SimpleSlicesReader) []const u8 {
            return self._slice_name_glob orelse &[_]u8{};
        }
        pub inline fn getThreadNameGlob(self: *const PerfettoSqlStructuredQuery.SimpleSlicesReader) []const u8 {
            return self._thread_name_glob orelse &[_]u8{};
        }
        pub inline fn getProcessNameGlob(self: *const PerfettoSqlStructuredQuery.SimpleSlicesReader) []const u8 {
            return self._process_name_glob orelse &[_]u8{};
        }
        pub inline fn getTrackNameGlob(self: *const PerfettoSqlStructuredQuery.SimpleSlicesReader) []const u8 {
            return self._track_name_glob orelse &[_]u8{};
        }
    };
    const SqlWire = struct {
        const SQL_WIRE: gremlin.ProtoWireNumber = 1;
        const COLUMN_NAMES_WIRE: gremlin.ProtoWireNumber = 2;
        const DEPENDENCIES_WIRE: gremlin.ProtoWireNumber = 4;
        const PREAMBLE_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const Sql = struct {
        // nested structs
        const DependencyWire = struct {
            const ALIAS_WIRE: gremlin.ProtoWireNumber = 1;
            const QUERY_WIRE: gremlin.ProtoWireNumber = 2;
        };
        pub const Dependency = struct {
            // fields
            alias: ?[]const u8 = null,
            query: ?PerfettoSqlStructuredQuery = null,
            pub fn calcProtobufSize(self: *const PerfettoSqlStructuredQuery.Sql.Dependency) usize {
                var res: usize = 0;
                if (self.alias) |v| {
                    if (v.len > 0) {
                        res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.Sql.DependencyWire.ALIAS_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                    }
                }
                if (self.query) |v| {
                    const size = v.calcProtobufSize();
                    if (size > 0) {
                        res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.Sql.DependencyWire.QUERY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                    }
                }
                return res;
            }
            pub fn encode(self: *const PerfettoSqlStructuredQuery.Sql.Dependency, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const PerfettoSqlStructuredQuery.Sql.Dependency, target: *gremlin.Writer) void {
                if (self.alias) |v| {
                    if (v.len > 0) {
                        target.appendBytes(PerfettoSqlStructuredQuery.Sql.DependencyWire.ALIAS_WIRE, v);
                    }
                }
                if (self.query) |v| {
                    const size = v.calcProtobufSize();
                    if (size > 0) {
                        target.appendBytesTag(PerfettoSqlStructuredQuery.Sql.DependencyWire.QUERY_WIRE, size);
                        v.encodeTo(target);
                    }
                }
            }
        };
        pub const DependencyReader = struct {
            buf: gremlin.Reader,
            _alias: ?[]const u8 = null,
            _query_buf: ?[]const u8 = null,
            pub fn init(src: []const u8) gremlin.Error!PerfettoSqlStructuredQuery.Sql.DependencyReader {
                const buf = gremlin.Reader.init(src);
                var res = PerfettoSqlStructuredQuery.Sql.DependencyReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        PerfettoSqlStructuredQuery.Sql.DependencyWire.ALIAS_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._alias = result.value;
                        },
                        PerfettoSqlStructuredQuery.Sql.DependencyWire.QUERY_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._query_buf = result.value;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub inline fn getAlias(self: *const PerfettoSqlStructuredQuery.Sql.DependencyReader) []const u8 {
                return self._alias orelse &[_]u8{};
            }
            pub fn getQuery(self: *const PerfettoSqlStructuredQuery.Sql.DependencyReader) gremlin.Error!PerfettoSqlStructuredQueryReader {
                if (self._query_buf) |buf| {
                    return try PerfettoSqlStructuredQueryReader.init(buf);
                }
                return try PerfettoSqlStructuredQueryReader.init(&[_]u8{});
            }
        };
        // fields
        sql: ?[]const u8 = null,
        column_names: ?[]const ?[]const u8 = null,
        dependencies: ?[]const ?PerfettoSqlStructuredQuery.Sql.Dependency = null,
        preamble: ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const PerfettoSqlStructuredQuery.Sql) usize {
            var res: usize = 0;
            if (self.sql) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.SqlWire.SQL_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.column_names) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.SqlWire.COLUMN_NAMES_WIRE);
                    if (maybe_v) |v| {
                        res += gremlin.sizes.sizeUsize(v.len) + v.len;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.dependencies) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.SqlWire.DEPENDENCIES_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.preamble) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.SqlWire.PREAMBLE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            return res;
        }
        pub fn encode(self: *const PerfettoSqlStructuredQuery.Sql, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const PerfettoSqlStructuredQuery.Sql, target: *gremlin.Writer) void {
            if (self.sql) |v| {
                if (v.len > 0) {
                    target.appendBytes(PerfettoSqlStructuredQuery.SqlWire.SQL_WIRE, v);
                }
            }
            if (self.column_names) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        target.appendBytes(PerfettoSqlStructuredQuery.SqlWire.COLUMN_NAMES_WIRE, v);
                    } else {
                        target.appendBytesTag(PerfettoSqlStructuredQuery.SqlWire.COLUMN_NAMES_WIRE, 0);
                    }
                }
            }
            if (self.dependencies) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(PerfettoSqlStructuredQuery.SqlWire.DEPENDENCIES_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(PerfettoSqlStructuredQuery.SqlWire.DEPENDENCIES_WIRE, 0);
                    }
                }
            }
            if (self.preamble) |v| {
                if (v.len > 0) {
                    target.appendBytes(PerfettoSqlStructuredQuery.SqlWire.PREAMBLE_WIRE, v);
                }
            }
        }
    };
    pub const SqlReader = struct {
        buf: gremlin.Reader,
        _sql: ?[]const u8 = null,
        _column_names_offset: ?usize = null,
        _column_names_last_offset: ?usize = null,
        _column_names_cnt: usize = 0,
        _dependencies_offset: ?usize = null,
        _dependencies_last_offset: ?usize = null,
        _dependencies_cnt: usize = 0,
        _preamble: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!PerfettoSqlStructuredQuery.SqlReader {
            const buf = gremlin.Reader.init(src);
            var res = PerfettoSqlStructuredQuery.SqlReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    PerfettoSqlStructuredQuery.SqlWire.SQL_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._sql = result.value;
                    },
                    PerfettoSqlStructuredQuery.SqlWire.COLUMN_NAMES_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._column_names_offset == null) {
                            res._column_names_offset = offset - result.size;
                        }
                        res._column_names_last_offset = offset;
                        res._column_names_cnt += 1;
                    },
                    PerfettoSqlStructuredQuery.SqlWire.DEPENDENCIES_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._dependencies_offset == null) {
                            res._dependencies_offset = offset - result.size;
                        }
                        res._dependencies_last_offset = offset;
                        res._dependencies_cnt += 1;
                    },
                    PerfettoSqlStructuredQuery.SqlWire.PREAMBLE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._preamble = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getSql(self: *const PerfettoSqlStructuredQuery.SqlReader) []const u8 {
            return self._sql orelse &[_]u8{};
        }
        pub fn columnNamesCount(self: *const PerfettoSqlStructuredQuery.SqlReader) usize {
            return self._column_names_cnt;
        }
        pub fn columnNamesNext(self: *PerfettoSqlStructuredQuery.SqlReader) ?[]const u8 {
            if (self._column_names_offset == null) return null;
            const current_offset = self._column_names_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            if (self._column_names_last_offset != null and current_offset >= self._column_names_last_offset.?) {
                self._column_names_offset = null;
                return result.value;
            }
            if (self._column_names_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._column_names_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == PerfettoSqlStructuredQuery.SqlWire.COLUMN_NAMES_WIRE) {
                    self._column_names_offset = next_offset;
                    return result.value;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._column_names_offset = null;
            return result.value;
        }
        pub fn dependenciesCount(self: *const PerfettoSqlStructuredQuery.SqlReader) usize {
            return self._dependencies_cnt;
        }
        pub fn dependenciesNext(self: *PerfettoSqlStructuredQuery.SqlReader) ?PerfettoSqlStructuredQuery.Sql.DependencyReader {
            if (self._dependencies_offset == null) return null;
            const current_offset = self._dependencies_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = PerfettoSqlStructuredQuery.Sql.DependencyReader.init(result.value) catch return null;
            if (self._dependencies_last_offset != null and current_offset >= self._dependencies_last_offset.?) {
                self._dependencies_offset = null;
                return msg;
            }
            if (self._dependencies_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._dependencies_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == PerfettoSqlStructuredQuery.SqlWire.DEPENDENCIES_WIRE) {
                    self._dependencies_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._dependencies_offset = null;
            return msg;
        }
        pub inline fn getPreamble(self: *const PerfettoSqlStructuredQuery.SqlReader) []const u8 {
            return self._preamble orelse &[_]u8{};
        }
    };
    const IntervalIntersectWire = struct {
        const BASE_WIRE: gremlin.ProtoWireNumber = 1;
        const INTERVAL_INTERSECT_WIRE: gremlin.ProtoWireNumber = 2;
        const PARTITION_COLUMNS_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const IntervalIntersect = struct {
        // fields
        base: ?PerfettoSqlStructuredQuery = null,
        interval_intersect: ?[]const ?PerfettoSqlStructuredQuery = null,
        partition_columns: ?[]const ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const PerfettoSqlStructuredQuery.IntervalIntersect) usize {
            var res: usize = 0;
            if (self.base) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.IntervalIntersectWire.BASE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.interval_intersect) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.IntervalIntersectWire.INTERVAL_INTERSECT_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.partition_columns) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.IntervalIntersectWire.PARTITION_COLUMNS_WIRE);
                    if (maybe_v) |v| {
                        res += gremlin.sizes.sizeUsize(v.len) + v.len;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const PerfettoSqlStructuredQuery.IntervalIntersect, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const PerfettoSqlStructuredQuery.IntervalIntersect, target: *gremlin.Writer) void {
            if (self.base) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(PerfettoSqlStructuredQuery.IntervalIntersectWire.BASE_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.interval_intersect) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(PerfettoSqlStructuredQuery.IntervalIntersectWire.INTERVAL_INTERSECT_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(PerfettoSqlStructuredQuery.IntervalIntersectWire.INTERVAL_INTERSECT_WIRE, 0);
                    }
                }
            }
            if (self.partition_columns) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        target.appendBytes(PerfettoSqlStructuredQuery.IntervalIntersectWire.PARTITION_COLUMNS_WIRE, v);
                    } else {
                        target.appendBytesTag(PerfettoSqlStructuredQuery.IntervalIntersectWire.PARTITION_COLUMNS_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const IntervalIntersectReader = struct {
        buf: gremlin.Reader,
        _base_buf: ?[]const u8 = null,
        _interval_intersect_offset: ?usize = null,
        _interval_intersect_last_offset: ?usize = null,
        _interval_intersect_cnt: usize = 0,
        _partition_columns_offset: ?usize = null,
        _partition_columns_last_offset: ?usize = null,
        _partition_columns_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!PerfettoSqlStructuredQuery.IntervalIntersectReader {
            const buf = gremlin.Reader.init(src);
            var res = PerfettoSqlStructuredQuery.IntervalIntersectReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    PerfettoSqlStructuredQuery.IntervalIntersectWire.BASE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._base_buf = result.value;
                    },
                    PerfettoSqlStructuredQuery.IntervalIntersectWire.INTERVAL_INTERSECT_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._interval_intersect_offset == null) {
                            res._interval_intersect_offset = offset - result.size;
                        }
                        res._interval_intersect_last_offset = offset;
                        res._interval_intersect_cnt += 1;
                    },
                    PerfettoSqlStructuredQuery.IntervalIntersectWire.PARTITION_COLUMNS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._partition_columns_offset == null) {
                            res._partition_columns_offset = offset - result.size;
                        }
                        res._partition_columns_last_offset = offset;
                        res._partition_columns_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn getBase(self: *const PerfettoSqlStructuredQuery.IntervalIntersectReader) gremlin.Error!PerfettoSqlStructuredQueryReader {
            if (self._base_buf) |buf| {
                return try PerfettoSqlStructuredQueryReader.init(buf);
            }
            return try PerfettoSqlStructuredQueryReader.init(&[_]u8{});
        }
        pub fn intervalIntersectCount(self: *const PerfettoSqlStructuredQuery.IntervalIntersectReader) usize {
            return self._interval_intersect_cnt;
        }
        pub fn intervalIntersectNext(self: *PerfettoSqlStructuredQuery.IntervalIntersectReader) ?PerfettoSqlStructuredQueryReader {
            if (self._interval_intersect_offset == null) return null;
            const current_offset = self._interval_intersect_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = PerfettoSqlStructuredQueryReader.init(result.value) catch return null;
            if (self._interval_intersect_last_offset != null and current_offset >= self._interval_intersect_last_offset.?) {
                self._interval_intersect_offset = null;
                return msg;
            }
            if (self._interval_intersect_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._interval_intersect_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == PerfettoSqlStructuredQuery.IntervalIntersectWire.INTERVAL_INTERSECT_WIRE) {
                    self._interval_intersect_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._interval_intersect_offset = null;
            return msg;
        }
        pub fn partitionColumnsCount(self: *const PerfettoSqlStructuredQuery.IntervalIntersectReader) usize {
            return self._partition_columns_cnt;
        }
        pub fn partitionColumnsNext(self: *PerfettoSqlStructuredQuery.IntervalIntersectReader) ?[]const u8 {
            if (self._partition_columns_offset == null) return null;
            const current_offset = self._partition_columns_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            if (self._partition_columns_last_offset != null and current_offset >= self._partition_columns_last_offset.?) {
                self._partition_columns_offset = null;
                return result.value;
            }
            if (self._partition_columns_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._partition_columns_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == PerfettoSqlStructuredQuery.IntervalIntersectWire.PARTITION_COLUMNS_WIRE) {
                    self._partition_columns_offset = next_offset;
                    return result.value;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._partition_columns_offset = null;
            return result.value;
        }
    };
    const ExperimentalJoinWire = struct {
        const TYPE_WIRE: gremlin.ProtoWireNumber = 1;
        const LEFT_QUERY_WIRE: gremlin.ProtoWireNumber = 2;
        const RIGHT_QUERY_WIRE: gremlin.ProtoWireNumber = 3;
        const EQUALITY_COLUMNS_WIRE: gremlin.ProtoWireNumber = 4;
        const FREEFORM_CONDITION_WIRE: gremlin.ProtoWireNumber = 5;
    };
    pub const ExperimentalJoin = struct {
        // nested enums
        pub const Type = enum(i32) {
            INNER = 0,
            LEFT = 1,
        };
        // nested structs
        const EqualityColumnsWire = struct {
            const LEFT_COLUMN_WIRE: gremlin.ProtoWireNumber = 1;
            const RIGHT_COLUMN_WIRE: gremlin.ProtoWireNumber = 2;
        };
        pub const EqualityColumns = struct {
            // fields
            left_column: ?[]const u8 = null,
            right_column: ?[]const u8 = null,
            pub fn calcProtobufSize(self: *const PerfettoSqlStructuredQuery.ExperimentalJoin.EqualityColumns) usize {
                var res: usize = 0;
                if (self.left_column) |v| {
                    if (v.len > 0) {
                        res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.ExperimentalJoin.EqualityColumnsWire.LEFT_COLUMN_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                    }
                }
                if (self.right_column) |v| {
                    if (v.len > 0) {
                        res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.ExperimentalJoin.EqualityColumnsWire.RIGHT_COLUMN_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                    }
                }
                return res;
            }
            pub fn encode(self: *const PerfettoSqlStructuredQuery.ExperimentalJoin.EqualityColumns, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const PerfettoSqlStructuredQuery.ExperimentalJoin.EqualityColumns, target: *gremlin.Writer) void {
                if (self.left_column) |v| {
                    if (v.len > 0) {
                        target.appendBytes(PerfettoSqlStructuredQuery.ExperimentalJoin.EqualityColumnsWire.LEFT_COLUMN_WIRE, v);
                    }
                }
                if (self.right_column) |v| {
                    if (v.len > 0) {
                        target.appendBytes(PerfettoSqlStructuredQuery.ExperimentalJoin.EqualityColumnsWire.RIGHT_COLUMN_WIRE, v);
                    }
                }
            }
        };
        pub const EqualityColumnsReader = struct {
            buf: gremlin.Reader,
            _left_column: ?[]const u8 = null,
            _right_column: ?[]const u8 = null,
            pub fn init(src: []const u8) gremlin.Error!PerfettoSqlStructuredQuery.ExperimentalJoin.EqualityColumnsReader {
                const buf = gremlin.Reader.init(src);
                var res = PerfettoSqlStructuredQuery.ExperimentalJoin.EqualityColumnsReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        PerfettoSqlStructuredQuery.ExperimentalJoin.EqualityColumnsWire.LEFT_COLUMN_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._left_column = result.value;
                        },
                        PerfettoSqlStructuredQuery.ExperimentalJoin.EqualityColumnsWire.RIGHT_COLUMN_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._right_column = result.value;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub inline fn getLeftColumn(self: *const PerfettoSqlStructuredQuery.ExperimentalJoin.EqualityColumnsReader) []const u8 {
                return self._left_column orelse &[_]u8{};
            }
            pub inline fn getRightColumn(self: *const PerfettoSqlStructuredQuery.ExperimentalJoin.EqualityColumnsReader) []const u8 {
                return self._right_column orelse &[_]u8{};
            }
        };
        const FreeformConditionWire = struct {
            const LEFT_QUERY_ALIAS_WIRE: gremlin.ProtoWireNumber = 1;
            const RIGHT_QUERY_ALIAS_WIRE: gremlin.ProtoWireNumber = 2;
            const SQL_EXPRESSION_WIRE: gremlin.ProtoWireNumber = 3;
        };
        pub const FreeformCondition = struct {
            // fields
            left_query_alias: ?[]const u8 = null,
            right_query_alias: ?[]const u8 = null,
            sql_expression: ?[]const u8 = null,
            pub fn calcProtobufSize(self: *const PerfettoSqlStructuredQuery.ExperimentalJoin.FreeformCondition) usize {
                var res: usize = 0;
                if (self.left_query_alias) |v| {
                    if (v.len > 0) {
                        res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.ExperimentalJoin.FreeformConditionWire.LEFT_QUERY_ALIAS_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                    }
                }
                if (self.right_query_alias) |v| {
                    if (v.len > 0) {
                        res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.ExperimentalJoin.FreeformConditionWire.RIGHT_QUERY_ALIAS_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                    }
                }
                if (self.sql_expression) |v| {
                    if (v.len > 0) {
                        res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.ExperimentalJoin.FreeformConditionWire.SQL_EXPRESSION_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                    }
                }
                return res;
            }
            pub fn encode(self: *const PerfettoSqlStructuredQuery.ExperimentalJoin.FreeformCondition, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const PerfettoSqlStructuredQuery.ExperimentalJoin.FreeformCondition, target: *gremlin.Writer) void {
                if (self.left_query_alias) |v| {
                    if (v.len > 0) {
                        target.appendBytes(PerfettoSqlStructuredQuery.ExperimentalJoin.FreeformConditionWire.LEFT_QUERY_ALIAS_WIRE, v);
                    }
                }
                if (self.right_query_alias) |v| {
                    if (v.len > 0) {
                        target.appendBytes(PerfettoSqlStructuredQuery.ExperimentalJoin.FreeformConditionWire.RIGHT_QUERY_ALIAS_WIRE, v);
                    }
                }
                if (self.sql_expression) |v| {
                    if (v.len > 0) {
                        target.appendBytes(PerfettoSqlStructuredQuery.ExperimentalJoin.FreeformConditionWire.SQL_EXPRESSION_WIRE, v);
                    }
                }
            }
        };
        pub const FreeformConditionReader = struct {
            buf: gremlin.Reader,
            _left_query_alias: ?[]const u8 = null,
            _right_query_alias: ?[]const u8 = null,
            _sql_expression: ?[]const u8 = null,
            pub fn init(src: []const u8) gremlin.Error!PerfettoSqlStructuredQuery.ExperimentalJoin.FreeformConditionReader {
                const buf = gremlin.Reader.init(src);
                var res = PerfettoSqlStructuredQuery.ExperimentalJoin.FreeformConditionReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        PerfettoSqlStructuredQuery.ExperimentalJoin.FreeformConditionWire.LEFT_QUERY_ALIAS_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._left_query_alias = result.value;
                        },
                        PerfettoSqlStructuredQuery.ExperimentalJoin.FreeformConditionWire.RIGHT_QUERY_ALIAS_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._right_query_alias = result.value;
                        },
                        PerfettoSqlStructuredQuery.ExperimentalJoin.FreeformConditionWire.SQL_EXPRESSION_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._sql_expression = result.value;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub inline fn getLeftQueryAlias(self: *const PerfettoSqlStructuredQuery.ExperimentalJoin.FreeformConditionReader) []const u8 {
                return self._left_query_alias orelse &[_]u8{};
            }
            pub inline fn getRightQueryAlias(self: *const PerfettoSqlStructuredQuery.ExperimentalJoin.FreeformConditionReader) []const u8 {
                return self._right_query_alias orelse &[_]u8{};
            }
            pub inline fn getSqlExpression(self: *const PerfettoSqlStructuredQuery.ExperimentalJoin.FreeformConditionReader) []const u8 {
                return self._sql_expression orelse &[_]u8{};
            }
        };
        // fields
        type: PerfettoSqlStructuredQuery.ExperimentalJoin.Type = @enumFromInt(0),
        left_query: ?PerfettoSqlStructuredQuery = null,
        right_query: ?PerfettoSqlStructuredQuery = null,
        equality_columns: ?PerfettoSqlStructuredQuery.ExperimentalJoin.EqualityColumns = null,
        freeform_condition: ?PerfettoSqlStructuredQuery.ExperimentalJoin.FreeformCondition = null,
        pub fn calcProtobufSize(self: *const PerfettoSqlStructuredQuery.ExperimentalJoin) usize {
            var res: usize = 0;
            if (@intFromEnum(self.type) != 0) {
                res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.ExperimentalJoinWire.TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.type));
            }
            if (self.left_query) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.ExperimentalJoinWire.LEFT_QUERY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.right_query) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.ExperimentalJoinWire.RIGHT_QUERY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.equality_columns) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.ExperimentalJoinWire.EQUALITY_COLUMNS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.freeform_condition) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.ExperimentalJoinWire.FREEFORM_CONDITION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            return res;
        }
        pub fn encode(self: *const PerfettoSqlStructuredQuery.ExperimentalJoin, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const PerfettoSqlStructuredQuery.ExperimentalJoin, target: *gremlin.Writer) void {
            if (@intFromEnum(self.type) != 0) {
                target.appendInt32(PerfettoSqlStructuredQuery.ExperimentalJoinWire.TYPE_WIRE, @intFromEnum(self.type));
            }
            if (self.left_query) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(PerfettoSqlStructuredQuery.ExperimentalJoinWire.LEFT_QUERY_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.right_query) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(PerfettoSqlStructuredQuery.ExperimentalJoinWire.RIGHT_QUERY_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.equality_columns) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(PerfettoSqlStructuredQuery.ExperimentalJoinWire.EQUALITY_COLUMNS_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.freeform_condition) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(PerfettoSqlStructuredQuery.ExperimentalJoinWire.FREEFORM_CONDITION_WIRE, size);
                    v.encodeTo(target);
                }
            }
        }
    };
    pub const ExperimentalJoinReader = struct {
        buf: gremlin.Reader,
        _type: PerfettoSqlStructuredQuery.ExperimentalJoin.Type = @enumFromInt(0),
        _left_query_buf: ?[]const u8 = null,
        _right_query_buf: ?[]const u8 = null,
        _equality_columns_buf: ?[]const u8 = null,
        _freeform_condition_buf: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!PerfettoSqlStructuredQuery.ExperimentalJoinReader {
            const buf = gremlin.Reader.init(src);
            var res = PerfettoSqlStructuredQuery.ExperimentalJoinReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    PerfettoSqlStructuredQuery.ExperimentalJoinWire.TYPE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._type = @enumFromInt(result.value);
                    },
                    PerfettoSqlStructuredQuery.ExperimentalJoinWire.LEFT_QUERY_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._left_query_buf = result.value;
                    },
                    PerfettoSqlStructuredQuery.ExperimentalJoinWire.RIGHT_QUERY_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._right_query_buf = result.value;
                    },
                    PerfettoSqlStructuredQuery.ExperimentalJoinWire.EQUALITY_COLUMNS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._equality_columns_buf = result.value;
                    },
                    PerfettoSqlStructuredQuery.ExperimentalJoinWire.FREEFORM_CONDITION_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._freeform_condition_buf = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getType(self: *const PerfettoSqlStructuredQuery.ExperimentalJoinReader) PerfettoSqlStructuredQuery.ExperimentalJoin.Type {
            return self._type;
        }
        pub fn getLeftQuery(self: *const PerfettoSqlStructuredQuery.ExperimentalJoinReader) gremlin.Error!PerfettoSqlStructuredQueryReader {
            if (self._left_query_buf) |buf| {
                return try PerfettoSqlStructuredQueryReader.init(buf);
            }
            return try PerfettoSqlStructuredQueryReader.init(&[_]u8{});
        }
        pub fn getRightQuery(self: *const PerfettoSqlStructuredQuery.ExperimentalJoinReader) gremlin.Error!PerfettoSqlStructuredQueryReader {
            if (self._right_query_buf) |buf| {
                return try PerfettoSqlStructuredQueryReader.init(buf);
            }
            return try PerfettoSqlStructuredQueryReader.init(&[_]u8{});
        }
        pub fn getEqualityColumns(self: *const PerfettoSqlStructuredQuery.ExperimentalJoinReader) gremlin.Error!PerfettoSqlStructuredQuery.ExperimentalJoin.EqualityColumnsReader {
            if (self._equality_columns_buf) |buf| {
                return try PerfettoSqlStructuredQuery.ExperimentalJoin.EqualityColumnsReader.init(buf);
            }
            return try PerfettoSqlStructuredQuery.ExperimentalJoin.EqualityColumnsReader.init(&[_]u8{});
        }
        pub fn getFreeformCondition(self: *const PerfettoSqlStructuredQuery.ExperimentalJoinReader) gremlin.Error!PerfettoSqlStructuredQuery.ExperimentalJoin.FreeformConditionReader {
            if (self._freeform_condition_buf) |buf| {
                return try PerfettoSqlStructuredQuery.ExperimentalJoin.FreeformConditionReader.init(buf);
            }
            return try PerfettoSqlStructuredQuery.ExperimentalJoin.FreeformConditionReader.init(&[_]u8{});
        }
    };
    const ExperimentalUnionWire = struct {
        const QUERIES_WIRE: gremlin.ProtoWireNumber = 1;
        const USE_UNION_ALL_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const ExperimentalUnion = struct {
        // fields
        queries: ?[]const ?PerfettoSqlStructuredQuery = null,
        use_union_all: bool = false,
        pub fn calcProtobufSize(self: *const PerfettoSqlStructuredQuery.ExperimentalUnion) usize {
            var res: usize = 0;
            if (self.queries) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.ExperimentalUnionWire.QUERIES_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.use_union_all != false) {
                res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.ExperimentalUnionWire.USE_UNION_ALL_WIRE) + gremlin.sizes.sizeBool(self.use_union_all);
            }
            return res;
        }
        pub fn encode(self: *const PerfettoSqlStructuredQuery.ExperimentalUnion, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const PerfettoSqlStructuredQuery.ExperimentalUnion, target: *gremlin.Writer) void {
            if (self.queries) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(PerfettoSqlStructuredQuery.ExperimentalUnionWire.QUERIES_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(PerfettoSqlStructuredQuery.ExperimentalUnionWire.QUERIES_WIRE, 0);
                    }
                }
            }
            if (self.use_union_all != false) {
                target.appendBool(PerfettoSqlStructuredQuery.ExperimentalUnionWire.USE_UNION_ALL_WIRE, self.use_union_all);
            }
        }
    };
    pub const ExperimentalUnionReader = struct {
        buf: gremlin.Reader,
        _queries_offset: ?usize = null,
        _queries_last_offset: ?usize = null,
        _queries_cnt: usize = 0,
        _use_union_all: bool = false,
        pub fn init(src: []const u8) gremlin.Error!PerfettoSqlStructuredQuery.ExperimentalUnionReader {
            const buf = gremlin.Reader.init(src);
            var res = PerfettoSqlStructuredQuery.ExperimentalUnionReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    PerfettoSqlStructuredQuery.ExperimentalUnionWire.QUERIES_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._queries_offset == null) {
                            res._queries_offset = offset - result.size;
                        }
                        res._queries_last_offset = offset;
                        res._queries_cnt += 1;
                    },
                    PerfettoSqlStructuredQuery.ExperimentalUnionWire.USE_UNION_ALL_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._use_union_all = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn queriesCount(self: *const PerfettoSqlStructuredQuery.ExperimentalUnionReader) usize {
            return self._queries_cnt;
        }
        pub fn queriesNext(self: *PerfettoSqlStructuredQuery.ExperimentalUnionReader) ?PerfettoSqlStructuredQueryReader {
            if (self._queries_offset == null) return null;
            const current_offset = self._queries_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = PerfettoSqlStructuredQueryReader.init(result.value) catch return null;
            if (self._queries_last_offset != null and current_offset >= self._queries_last_offset.?) {
                self._queries_offset = null;
                return msg;
            }
            if (self._queries_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._queries_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == PerfettoSqlStructuredQuery.ExperimentalUnionWire.QUERIES_WIRE) {
                    self._queries_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._queries_offset = null;
            return msg;
        }
        pub inline fn getUseUnionAll(self: *const PerfettoSqlStructuredQuery.ExperimentalUnionReader) bool {
            return self._use_union_all;
        }
    };
    const ExperimentalAddColumnsWire = struct {
        const CORE_QUERY_WIRE: gremlin.ProtoWireNumber = 1;
        const INPUT_QUERY_WIRE: gremlin.ProtoWireNumber = 2;
        const INPUT_COLUMNS_WIRE: gremlin.ProtoWireNumber = 3;
        const EQUALITY_COLUMNS_WIRE: gremlin.ProtoWireNumber = 4;
        const FREEFORM_CONDITION_WIRE: gremlin.ProtoWireNumber = 5;
    };
    pub const ExperimentalAddColumns = struct {
        // fields
        core_query: ?PerfettoSqlStructuredQuery = null,
        input_query: ?PerfettoSqlStructuredQuery = null,
        input_columns: ?[]const ?PerfettoSqlStructuredQuery.SelectColumn = null,
        equality_columns: ?PerfettoSqlStructuredQuery.ExperimentalJoin.EqualityColumns = null,
        freeform_condition: ?PerfettoSqlStructuredQuery.ExperimentalJoin.FreeformCondition = null,
        pub fn calcProtobufSize(self: *const PerfettoSqlStructuredQuery.ExperimentalAddColumns) usize {
            var res: usize = 0;
            if (self.core_query) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.ExperimentalAddColumnsWire.CORE_QUERY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.input_query) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.ExperimentalAddColumnsWire.INPUT_QUERY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.input_columns) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.ExperimentalAddColumnsWire.INPUT_COLUMNS_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.equality_columns) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.ExperimentalAddColumnsWire.EQUALITY_COLUMNS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.freeform_condition) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.ExperimentalAddColumnsWire.FREEFORM_CONDITION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            return res;
        }
        pub fn encode(self: *const PerfettoSqlStructuredQuery.ExperimentalAddColumns, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const PerfettoSqlStructuredQuery.ExperimentalAddColumns, target: *gremlin.Writer) void {
            if (self.core_query) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(PerfettoSqlStructuredQuery.ExperimentalAddColumnsWire.CORE_QUERY_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.input_query) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(PerfettoSqlStructuredQuery.ExperimentalAddColumnsWire.INPUT_QUERY_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.input_columns) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(PerfettoSqlStructuredQuery.ExperimentalAddColumnsWire.INPUT_COLUMNS_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(PerfettoSqlStructuredQuery.ExperimentalAddColumnsWire.INPUT_COLUMNS_WIRE, 0);
                    }
                }
            }
            if (self.equality_columns) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(PerfettoSqlStructuredQuery.ExperimentalAddColumnsWire.EQUALITY_COLUMNS_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.freeform_condition) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(PerfettoSqlStructuredQuery.ExperimentalAddColumnsWire.FREEFORM_CONDITION_WIRE, size);
                    v.encodeTo(target);
                }
            }
        }
    };
    pub const ExperimentalAddColumnsReader = struct {
        buf: gremlin.Reader,
        _core_query_buf: ?[]const u8 = null,
        _input_query_buf: ?[]const u8 = null,
        _input_columns_offset: ?usize = null,
        _input_columns_last_offset: ?usize = null,
        _input_columns_cnt: usize = 0,
        _equality_columns_buf: ?[]const u8 = null,
        _freeform_condition_buf: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!PerfettoSqlStructuredQuery.ExperimentalAddColumnsReader {
            const buf = gremlin.Reader.init(src);
            var res = PerfettoSqlStructuredQuery.ExperimentalAddColumnsReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    PerfettoSqlStructuredQuery.ExperimentalAddColumnsWire.CORE_QUERY_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._core_query_buf = result.value;
                    },
                    PerfettoSqlStructuredQuery.ExperimentalAddColumnsWire.INPUT_QUERY_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._input_query_buf = result.value;
                    },
                    PerfettoSqlStructuredQuery.ExperimentalAddColumnsWire.INPUT_COLUMNS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._input_columns_offset == null) {
                            res._input_columns_offset = offset - result.size;
                        }
                        res._input_columns_last_offset = offset;
                        res._input_columns_cnt += 1;
                    },
                    PerfettoSqlStructuredQuery.ExperimentalAddColumnsWire.EQUALITY_COLUMNS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._equality_columns_buf = result.value;
                    },
                    PerfettoSqlStructuredQuery.ExperimentalAddColumnsWire.FREEFORM_CONDITION_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._freeform_condition_buf = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn getCoreQuery(self: *const PerfettoSqlStructuredQuery.ExperimentalAddColumnsReader) gremlin.Error!PerfettoSqlStructuredQueryReader {
            if (self._core_query_buf) |buf| {
                return try PerfettoSqlStructuredQueryReader.init(buf);
            }
            return try PerfettoSqlStructuredQueryReader.init(&[_]u8{});
        }
        pub fn getInputQuery(self: *const PerfettoSqlStructuredQuery.ExperimentalAddColumnsReader) gremlin.Error!PerfettoSqlStructuredQueryReader {
            if (self._input_query_buf) |buf| {
                return try PerfettoSqlStructuredQueryReader.init(buf);
            }
            return try PerfettoSqlStructuredQueryReader.init(&[_]u8{});
        }
        pub fn inputColumnsCount(self: *const PerfettoSqlStructuredQuery.ExperimentalAddColumnsReader) usize {
            return self._input_columns_cnt;
        }
        pub fn inputColumnsNext(self: *PerfettoSqlStructuredQuery.ExperimentalAddColumnsReader) ?PerfettoSqlStructuredQuery.SelectColumnReader {
            if (self._input_columns_offset == null) return null;
            const current_offset = self._input_columns_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = PerfettoSqlStructuredQuery.SelectColumnReader.init(result.value) catch return null;
            if (self._input_columns_last_offset != null and current_offset >= self._input_columns_last_offset.?) {
                self._input_columns_offset = null;
                return msg;
            }
            if (self._input_columns_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._input_columns_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == PerfettoSqlStructuredQuery.ExperimentalAddColumnsWire.INPUT_COLUMNS_WIRE) {
                    self._input_columns_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._input_columns_offset = null;
            return msg;
        }
        pub fn getEqualityColumns(self: *const PerfettoSqlStructuredQuery.ExperimentalAddColumnsReader) gremlin.Error!PerfettoSqlStructuredQuery.ExperimentalJoin.EqualityColumnsReader {
            if (self._equality_columns_buf) |buf| {
                return try PerfettoSqlStructuredQuery.ExperimentalJoin.EqualityColumnsReader.init(buf);
            }
            return try PerfettoSqlStructuredQuery.ExperimentalJoin.EqualityColumnsReader.init(&[_]u8{});
        }
        pub fn getFreeformCondition(self: *const PerfettoSqlStructuredQuery.ExperimentalAddColumnsReader) gremlin.Error!PerfettoSqlStructuredQuery.ExperimentalJoin.FreeformConditionReader {
            if (self._freeform_condition_buf) |buf| {
                return try PerfettoSqlStructuredQuery.ExperimentalJoin.FreeformConditionReader.init(buf);
            }
            return try PerfettoSqlStructuredQuery.ExperimentalJoin.FreeformConditionReader.init(&[_]u8{});
        }
    };
    const FilterWire = struct {
        const COLUMN_NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const OP_WIRE: gremlin.ProtoWireNumber = 2;
        const STRING_RHS_WIRE: gremlin.ProtoWireNumber = 3;
        const DOUBLE_RHS_WIRE: gremlin.ProtoWireNumber = 4;
        const INT64_RHS_WIRE: gremlin.ProtoWireNumber = 5;
    };
    pub const Filter = struct {
        // nested enums
        pub const Operator = enum(i32) {
            UNKNOWN = 0,
            EQUAL = 1,
            NOT_EQUAL = 2,
            LESS_THAN = 3,
            LESS_THAN_EQUAL = 4,
            GREATER_THAN = 5,
            GREATER_THAN_EQUAL = 6,
            IS_NULL = 8,
            IS_NOT_NULL = 9,
            GLOB = 7,
        };
        // fields
        column_name: ?[]const u8 = null,
        op: PerfettoSqlStructuredQuery.Filter.Operator = @enumFromInt(0),
        string_rhs: ?[]const ?[]const u8 = null,
        double_rhs: ?[]const f64 = null,
        int64_rhs: ?[]const i64 = null,
        pub fn calcProtobufSize(self: *const PerfettoSqlStructuredQuery.Filter) usize {
            var res: usize = 0;
            if (self.column_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.FilterWire.COLUMN_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (@intFromEnum(self.op) != 0) {
                res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.FilterWire.OP_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.op));
            }
            if (self.string_rhs) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.FilterWire.STRING_RHS_WIRE);
                    if (maybe_v) |v| {
                        res += gremlin.sizes.sizeUsize(v.len) + v.len;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.double_rhs) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.FilterWire.DOUBLE_RHS_WIRE) + gremlin.sizes.sizeDouble(arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeDouble(v);
                    }
                    res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.FilterWire.DOUBLE_RHS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
                }
            }
            if (self.int64_rhs) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.FilterWire.INT64_RHS_WIRE) + gremlin.sizes.sizeI64(arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeI64(v);
                    }
                    res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.FilterWire.INT64_RHS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
                }
            }
            return res;
        }
        pub fn encode(self: *const PerfettoSqlStructuredQuery.Filter, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const PerfettoSqlStructuredQuery.Filter, target: *gremlin.Writer) void {
            if (self.column_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(PerfettoSqlStructuredQuery.FilterWire.COLUMN_NAME_WIRE, v);
                }
            }
            if (@intFromEnum(self.op) != 0) {
                target.appendInt32(PerfettoSqlStructuredQuery.FilterWire.OP_WIRE, @intFromEnum(self.op));
            }
            if (self.string_rhs) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        target.appendBytes(PerfettoSqlStructuredQuery.FilterWire.STRING_RHS_WIRE, v);
                    } else {
                        target.appendBytesTag(PerfettoSqlStructuredQuery.FilterWire.STRING_RHS_WIRE, 0);
                    }
                }
            }
            if (self.double_rhs) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    target.appendFloat64(PerfettoSqlStructuredQuery.FilterWire.DOUBLE_RHS_WIRE, arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeDouble(v);
                    }
                    target.appendBytesTag(PerfettoSqlStructuredQuery.FilterWire.DOUBLE_RHS_WIRE, packed_size);
                    for (arr) |v| {
                        target.appendFloat64WithoutTag(v);
                    }
                }
            }
            if (self.int64_rhs) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    target.appendInt64(PerfettoSqlStructuredQuery.FilterWire.INT64_RHS_WIRE, arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeI64(v);
                    }
                    target.appendBytesTag(PerfettoSqlStructuredQuery.FilterWire.INT64_RHS_WIRE, packed_size);
                    for (arr) |v| {
                        target.appendInt64WithoutTag(v);
                    }
                }
            }
        }
    };
    pub const FilterReader = struct {
        buf: gremlin.Reader,
        _column_name: ?[]const u8 = null,
        _op: PerfettoSqlStructuredQuery.Filter.Operator = @enumFromInt(0),
        _string_rhs_offset: ?usize = null,
        _string_rhs_last_offset: ?usize = null,
        _string_rhs_cnt: usize = 0,
        _double_rhs_offset: ?usize = null,
        _double_rhs_last_offset: ?usize = null,
        _double_rhs_packed: bool = false,
        _int64_rhs_offset: ?usize = null,
        _int64_rhs_last_offset: ?usize = null,
        _int64_rhs_packed: bool = false,
        pub fn init(src: []const u8) gremlin.Error!PerfettoSqlStructuredQuery.FilterReader {
            const buf = gremlin.Reader.init(src);
            var res = PerfettoSqlStructuredQuery.FilterReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    PerfettoSqlStructuredQuery.FilterWire.COLUMN_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._column_name = result.value;
                    },
                    PerfettoSqlStructuredQuery.FilterWire.OP_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._op = @enumFromInt(result.value);
                    },
                    PerfettoSqlStructuredQuery.FilterWire.STRING_RHS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._string_rhs_offset == null) {
                            res._string_rhs_offset = offset - result.size;
                        }
                        res._string_rhs_last_offset = offset;
                        res._string_rhs_cnt += 1;
                    },
                    PerfettoSqlStructuredQuery.FilterWire.DOUBLE_RHS_WIRE => {
                        if (res._double_rhs_offset == null) {
                            res._double_rhs_offset = offset;
                        }
                        if (tag.wire == gremlin.ProtoWireType.bytes) {
                            res._double_rhs_packed = true;
                            const length_result = try buf.readVarInt(offset);
                            res._double_rhs_offset = offset + length_result.size;
                            res._double_rhs_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                            offset = res._double_rhs_last_offset.?;
                        } else {
                            const result = try buf.readFloat64(offset);
                            offset += result.size;
                            res._double_rhs_last_offset = offset;
                        }
                    },
                    PerfettoSqlStructuredQuery.FilterWire.INT64_RHS_WIRE => {
                        if (res._int64_rhs_offset == null) {
                            res._int64_rhs_offset = offset;
                        }
                        if (tag.wire == gremlin.ProtoWireType.bytes) {
                            res._int64_rhs_packed = true;
                            const length_result = try buf.readVarInt(offset);
                            res._int64_rhs_offset = offset + length_result.size;
                            res._int64_rhs_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                            offset = res._int64_rhs_last_offset.?;
                        } else {
                            const result = try buf.readInt64(offset);
                            offset += result.size;
                            res._int64_rhs_last_offset = offset;
                        }
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getColumnName(self: *const PerfettoSqlStructuredQuery.FilterReader) []const u8 {
            return self._column_name orelse &[_]u8{};
        }
        pub inline fn getOp(self: *const PerfettoSqlStructuredQuery.FilterReader) PerfettoSqlStructuredQuery.Filter.Operator {
            return self._op;
        }
        pub fn stringRhsCount(self: *const PerfettoSqlStructuredQuery.FilterReader) usize {
            return self._string_rhs_cnt;
        }
        pub fn stringRhsNext(self: *PerfettoSqlStructuredQuery.FilterReader) ?[]const u8 {
            if (self._string_rhs_offset == null) return null;
            const current_offset = self._string_rhs_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            if (self._string_rhs_last_offset != null and current_offset >= self._string_rhs_last_offset.?) {
                self._string_rhs_offset = null;
                return result.value;
            }
            if (self._string_rhs_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._string_rhs_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == PerfettoSqlStructuredQuery.FilterWire.STRING_RHS_WIRE) {
                    self._string_rhs_offset = next_offset;
                    return result.value;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._string_rhs_offset = null;
            return result.value;
        }
        pub fn doubleRhsNext(self: *PerfettoSqlStructuredQuery.FilterReader) gremlin.Error!?f64 {
            if (self._double_rhs_offset == null) return null;
            const current_offset = self._double_rhs_offset.?;
            if (current_offset >= self._double_rhs_last_offset.?) {
                self._double_rhs_offset = null;
                return null;
            }
            if (self._double_rhs_packed) {
                const value_result = try self.buf.readFloat64(current_offset);
                self._double_rhs_offset = current_offset + value_result.size;
                if (self._double_rhs_offset.? >= self._double_rhs_last_offset.?) {
                    self._double_rhs_offset = null;
                }
                return value_result.value;
            } else {
                const value_result = try self.buf.readFloat64(current_offset);
                var next_offset = current_offset + value_result.size;
                const max_offset = self._double_rhs_last_offset.?;
                // Search for the next occurrence of this field
                while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                    const next_tag = try self.buf.readTagAt(next_offset);
                    next_offset += next_tag.size;
                    if (next_tag.number == PerfettoSqlStructuredQuery.FilterWire.DOUBLE_RHS_WIRE) {
                        self._double_rhs_offset = next_offset;
                        return value_result.value;
                    } else {
                        next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                    }
                }
                self._double_rhs_offset = null;
                return value_result.value;
            }
        }
        pub fn int64RhsNext(self: *PerfettoSqlStructuredQuery.FilterReader) gremlin.Error!?i64 {
            if (self._int64_rhs_offset == null) return null;
            const current_offset = self._int64_rhs_offset.?;
            if (current_offset >= self._int64_rhs_last_offset.?) {
                self._int64_rhs_offset = null;
                return null;
            }
            if (self._int64_rhs_packed) {
                const value_result = try self.buf.readInt64(current_offset);
                self._int64_rhs_offset = current_offset + value_result.size;
                if (self._int64_rhs_offset.? >= self._int64_rhs_last_offset.?) {
                    self._int64_rhs_offset = null;
                }
                return value_result.value;
            } else {
                const value_result = try self.buf.readInt64(current_offset);
                var next_offset = current_offset + value_result.size;
                const max_offset = self._int64_rhs_last_offset.?;
                // Search for the next occurrence of this field
                while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                    const next_tag = try self.buf.readTagAt(next_offset);
                    next_offset += next_tag.size;
                    if (next_tag.number == PerfettoSqlStructuredQuery.FilterWire.INT64_RHS_WIRE) {
                        self._int64_rhs_offset = next_offset;
                        return value_result.value;
                    } else {
                        next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                    }
                }
                self._int64_rhs_offset = null;
                return value_result.value;
            }
        }
    };
    const GroupByWire = struct {
        const COLUMN_NAMES_WIRE: gremlin.ProtoWireNumber = 1;
        const AGGREGATES_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const GroupBy = struct {
        // nested structs
        const AggregateWire = struct {
            const COLUMN_NAME_WIRE: gremlin.ProtoWireNumber = 1;
            const OP_WIRE: gremlin.ProtoWireNumber = 2;
            const RESULT_COLUMN_NAME_WIRE: gremlin.ProtoWireNumber = 3;
            const PERCENTILE_WIRE: gremlin.ProtoWireNumber = 4;
        };
        pub const Aggregate = struct {
            // nested enums
            pub const Op = enum(i32) {
                UNSPECIFIED = 0,
                COUNT = 1,
                SUM = 2,
                MIN = 3,
                MAX = 4,
                MEAN = 5,
                MEDIAN = 6,
                DURATION_WEIGHTED_MEAN = 7,
                PERCENTILE = 8,
            };
            // fields
            column_name: ?[]const u8 = null,
            op: PerfettoSqlStructuredQuery.GroupBy.Aggregate.Op = @enumFromInt(0),
            result_column_name: ?[]const u8 = null,
            percentile: f64 = 0.0,
            pub fn calcProtobufSize(self: *const PerfettoSqlStructuredQuery.GroupBy.Aggregate) usize {
                var res: usize = 0;
                if (self.column_name) |v| {
                    if (v.len > 0) {
                        res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.GroupBy.AggregateWire.COLUMN_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                    }
                }
                if (@intFromEnum(self.op) != 0) {
                    res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.GroupBy.AggregateWire.OP_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.op));
                }
                if (self.result_column_name) |v| {
                    if (v.len > 0) {
                        res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.GroupBy.AggregateWire.RESULT_COLUMN_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                    }
                }
                if (self.percentile != 0.0) {
                    res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.GroupBy.AggregateWire.PERCENTILE_WIRE) + gremlin.sizes.sizeDouble(self.percentile);
                }
                return res;
            }
            pub fn encode(self: *const PerfettoSqlStructuredQuery.GroupBy.Aggregate, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const PerfettoSqlStructuredQuery.GroupBy.Aggregate, target: *gremlin.Writer) void {
                if (self.column_name) |v| {
                    if (v.len > 0) {
                        target.appendBytes(PerfettoSqlStructuredQuery.GroupBy.AggregateWire.COLUMN_NAME_WIRE, v);
                    }
                }
                if (@intFromEnum(self.op) != 0) {
                    target.appendInt32(PerfettoSqlStructuredQuery.GroupBy.AggregateWire.OP_WIRE, @intFromEnum(self.op));
                }
                if (self.result_column_name) |v| {
                    if (v.len > 0) {
                        target.appendBytes(PerfettoSqlStructuredQuery.GroupBy.AggregateWire.RESULT_COLUMN_NAME_WIRE, v);
                    }
                }
                if (self.percentile != 0.0) {
                    target.appendFloat64(PerfettoSqlStructuredQuery.GroupBy.AggregateWire.PERCENTILE_WIRE, self.percentile);
                }
            }
        };
        pub const AggregateReader = struct {
            buf: gremlin.Reader,
            _column_name: ?[]const u8 = null,
            _op: PerfettoSqlStructuredQuery.GroupBy.Aggregate.Op = @enumFromInt(0),
            _result_column_name: ?[]const u8 = null,
            _percentile: f64 = 0.0,
            pub fn init(src: []const u8) gremlin.Error!PerfettoSqlStructuredQuery.GroupBy.AggregateReader {
                const buf = gremlin.Reader.init(src);
                var res = PerfettoSqlStructuredQuery.GroupBy.AggregateReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        PerfettoSqlStructuredQuery.GroupBy.AggregateWire.COLUMN_NAME_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._column_name = result.value;
                        },
                        PerfettoSqlStructuredQuery.GroupBy.AggregateWire.OP_WIRE => {
                            const result = try buf.readInt32(offset);
                            offset += result.size;
                            res._op = @enumFromInt(result.value);
                        },
                        PerfettoSqlStructuredQuery.GroupBy.AggregateWire.RESULT_COLUMN_NAME_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._result_column_name = result.value;
                        },
                        PerfettoSqlStructuredQuery.GroupBy.AggregateWire.PERCENTILE_WIRE => {
                            const result = try buf.readFloat64(offset);
                            offset += result.size;
                            res._percentile = result.value;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub inline fn getColumnName(self: *const PerfettoSqlStructuredQuery.GroupBy.AggregateReader) []const u8 {
                return self._column_name orelse &[_]u8{};
            }
            pub inline fn getOp(self: *const PerfettoSqlStructuredQuery.GroupBy.AggregateReader) PerfettoSqlStructuredQuery.GroupBy.Aggregate.Op {
                return self._op;
            }
            pub inline fn getResultColumnName(self: *const PerfettoSqlStructuredQuery.GroupBy.AggregateReader) []const u8 {
                return self._result_column_name orelse &[_]u8{};
            }
            pub inline fn getPercentile(self: *const PerfettoSqlStructuredQuery.GroupBy.AggregateReader) f64 {
                return self._percentile;
            }
        };
        // fields
        column_names: ?[]const ?[]const u8 = null,
        aggregates: ?[]const ?PerfettoSqlStructuredQuery.GroupBy.Aggregate = null,
        pub fn calcProtobufSize(self: *const PerfettoSqlStructuredQuery.GroupBy) usize {
            var res: usize = 0;
            if (self.column_names) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.GroupByWire.COLUMN_NAMES_WIRE);
                    if (maybe_v) |v| {
                        res += gremlin.sizes.sizeUsize(v.len) + v.len;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.aggregates) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.GroupByWire.AGGREGATES_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const PerfettoSqlStructuredQuery.GroupBy, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const PerfettoSqlStructuredQuery.GroupBy, target: *gremlin.Writer) void {
            if (self.column_names) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        target.appendBytes(PerfettoSqlStructuredQuery.GroupByWire.COLUMN_NAMES_WIRE, v);
                    } else {
                        target.appendBytesTag(PerfettoSqlStructuredQuery.GroupByWire.COLUMN_NAMES_WIRE, 0);
                    }
                }
            }
            if (self.aggregates) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(PerfettoSqlStructuredQuery.GroupByWire.AGGREGATES_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(PerfettoSqlStructuredQuery.GroupByWire.AGGREGATES_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const GroupByReader = struct {
        buf: gremlin.Reader,
        _column_names_offset: ?usize = null,
        _column_names_last_offset: ?usize = null,
        _column_names_cnt: usize = 0,
        _aggregates_offset: ?usize = null,
        _aggregates_last_offset: ?usize = null,
        _aggregates_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!PerfettoSqlStructuredQuery.GroupByReader {
            const buf = gremlin.Reader.init(src);
            var res = PerfettoSqlStructuredQuery.GroupByReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    PerfettoSqlStructuredQuery.GroupByWire.COLUMN_NAMES_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._column_names_offset == null) {
                            res._column_names_offset = offset - result.size;
                        }
                        res._column_names_last_offset = offset;
                        res._column_names_cnt += 1;
                    },
                    PerfettoSqlStructuredQuery.GroupByWire.AGGREGATES_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._aggregates_offset == null) {
                            res._aggregates_offset = offset - result.size;
                        }
                        res._aggregates_last_offset = offset;
                        res._aggregates_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn columnNamesCount(self: *const PerfettoSqlStructuredQuery.GroupByReader) usize {
            return self._column_names_cnt;
        }
        pub fn columnNamesNext(self: *PerfettoSqlStructuredQuery.GroupByReader) ?[]const u8 {
            if (self._column_names_offset == null) return null;
            const current_offset = self._column_names_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            if (self._column_names_last_offset != null and current_offset >= self._column_names_last_offset.?) {
                self._column_names_offset = null;
                return result.value;
            }
            if (self._column_names_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._column_names_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == PerfettoSqlStructuredQuery.GroupByWire.COLUMN_NAMES_WIRE) {
                    self._column_names_offset = next_offset;
                    return result.value;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._column_names_offset = null;
            return result.value;
        }
        pub fn aggregatesCount(self: *const PerfettoSqlStructuredQuery.GroupByReader) usize {
            return self._aggregates_cnt;
        }
        pub fn aggregatesNext(self: *PerfettoSqlStructuredQuery.GroupByReader) ?PerfettoSqlStructuredQuery.GroupBy.AggregateReader {
            if (self._aggregates_offset == null) return null;
            const current_offset = self._aggregates_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = PerfettoSqlStructuredQuery.GroupBy.AggregateReader.init(result.value) catch return null;
            if (self._aggregates_last_offset != null and current_offset >= self._aggregates_last_offset.?) {
                self._aggregates_offset = null;
                return msg;
            }
            if (self._aggregates_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._aggregates_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == PerfettoSqlStructuredQuery.GroupByWire.AGGREGATES_WIRE) {
                    self._aggregates_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._aggregates_offset = null;
            return msg;
        }
    };
    const SelectColumnWire = struct {
        const COLUMN_NAME_OR_EXPRESSION_WIRE: gremlin.ProtoWireNumber = 3;
        const ALIAS_WIRE: gremlin.ProtoWireNumber = 2;
        const COLUMN_NAME_WIRE: gremlin.ProtoWireNumber = 1;
    };
    pub const SelectColumn = struct {
        // fields
        column_name_or_expression: ?[]const u8 = null,
        alias: ?[]const u8 = null,
        column_name: ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const PerfettoSqlStructuredQuery.SelectColumn) usize {
            var res: usize = 0;
            if (self.column_name_or_expression) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.SelectColumnWire.COLUMN_NAME_OR_EXPRESSION_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.alias) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.SelectColumnWire.ALIAS_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.column_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.SelectColumnWire.COLUMN_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            return res;
        }
        pub fn encode(self: *const PerfettoSqlStructuredQuery.SelectColumn, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const PerfettoSqlStructuredQuery.SelectColumn, target: *gremlin.Writer) void {
            if (self.column_name_or_expression) |v| {
                if (v.len > 0) {
                    target.appendBytes(PerfettoSqlStructuredQuery.SelectColumnWire.COLUMN_NAME_OR_EXPRESSION_WIRE, v);
                }
            }
            if (self.alias) |v| {
                if (v.len > 0) {
                    target.appendBytes(PerfettoSqlStructuredQuery.SelectColumnWire.ALIAS_WIRE, v);
                }
            }
            if (self.column_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(PerfettoSqlStructuredQuery.SelectColumnWire.COLUMN_NAME_WIRE, v);
                }
            }
        }
    };
    pub const SelectColumnReader = struct {
        buf: gremlin.Reader,
        _column_name_or_expression: ?[]const u8 = null,
        _alias: ?[]const u8 = null,
        _column_name: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!PerfettoSqlStructuredQuery.SelectColumnReader {
            const buf = gremlin.Reader.init(src);
            var res = PerfettoSqlStructuredQuery.SelectColumnReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    PerfettoSqlStructuredQuery.SelectColumnWire.COLUMN_NAME_OR_EXPRESSION_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._column_name_or_expression = result.value;
                    },
                    PerfettoSqlStructuredQuery.SelectColumnWire.ALIAS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._alias = result.value;
                    },
                    PerfettoSqlStructuredQuery.SelectColumnWire.COLUMN_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._column_name = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getColumnNameOrExpression(self: *const PerfettoSqlStructuredQuery.SelectColumnReader) []const u8 {
            return self._column_name_or_expression orelse &[_]u8{};
        }
        pub inline fn getAlias(self: *const PerfettoSqlStructuredQuery.SelectColumnReader) []const u8 {
            return self._alias orelse &[_]u8{};
        }
        pub inline fn getColumnName(self: *const PerfettoSqlStructuredQuery.SelectColumnReader) []const u8 {
            return self._column_name orelse &[_]u8{};
        }
    };
    const OrderByWire = struct {
        const ORDERING_SPECS_WIRE: gremlin.ProtoWireNumber = 1;
    };
    pub const OrderBy = struct {
        // nested enums
        pub const Direction = enum(i32) {
            UNSPECIFIED = 0,
            ASC = 1,
            DESC = 2,
        };
        // nested structs
        const OrderingSpecWire = struct {
            const COLUMN_NAME_WIRE: gremlin.ProtoWireNumber = 1;
            const DIRECTION_WIRE: gremlin.ProtoWireNumber = 2;
        };
        pub const OrderingSpec = struct {
            // fields
            column_name: ?[]const u8 = null,
            direction: PerfettoSqlStructuredQuery.OrderBy.Direction = @enumFromInt(0),
            pub fn calcProtobufSize(self: *const PerfettoSqlStructuredQuery.OrderBy.OrderingSpec) usize {
                var res: usize = 0;
                if (self.column_name) |v| {
                    if (v.len > 0) {
                        res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.OrderBy.OrderingSpecWire.COLUMN_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                    }
                }
                if (@intFromEnum(self.direction) != 0) {
                    res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.OrderBy.OrderingSpecWire.DIRECTION_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.direction));
                }
                return res;
            }
            pub fn encode(self: *const PerfettoSqlStructuredQuery.OrderBy.OrderingSpec, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const PerfettoSqlStructuredQuery.OrderBy.OrderingSpec, target: *gremlin.Writer) void {
                if (self.column_name) |v| {
                    if (v.len > 0) {
                        target.appendBytes(PerfettoSqlStructuredQuery.OrderBy.OrderingSpecWire.COLUMN_NAME_WIRE, v);
                    }
                }
                if (@intFromEnum(self.direction) != 0) {
                    target.appendInt32(PerfettoSqlStructuredQuery.OrderBy.OrderingSpecWire.DIRECTION_WIRE, @intFromEnum(self.direction));
                }
            }
        };
        pub const OrderingSpecReader = struct {
            buf: gremlin.Reader,
            _column_name: ?[]const u8 = null,
            _direction: PerfettoSqlStructuredQuery.OrderBy.Direction = @enumFromInt(0),
            pub fn init(src: []const u8) gremlin.Error!PerfettoSqlStructuredQuery.OrderBy.OrderingSpecReader {
                const buf = gremlin.Reader.init(src);
                var res = PerfettoSqlStructuredQuery.OrderBy.OrderingSpecReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        PerfettoSqlStructuredQuery.OrderBy.OrderingSpecWire.COLUMN_NAME_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._column_name = result.value;
                        },
                        PerfettoSqlStructuredQuery.OrderBy.OrderingSpecWire.DIRECTION_WIRE => {
                            const result = try buf.readInt32(offset);
                            offset += result.size;
                            res._direction = @enumFromInt(result.value);
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub inline fn getColumnName(self: *const PerfettoSqlStructuredQuery.OrderBy.OrderingSpecReader) []const u8 {
                return self._column_name orelse &[_]u8{};
            }
            pub inline fn getDirection(self: *const PerfettoSqlStructuredQuery.OrderBy.OrderingSpecReader) PerfettoSqlStructuredQuery.OrderBy.Direction {
                return self._direction;
            }
        };
        // fields
        ordering_specs: ?[]const ?PerfettoSqlStructuredQuery.OrderBy.OrderingSpec = null,
        pub fn calcProtobufSize(self: *const PerfettoSqlStructuredQuery.OrderBy) usize {
            var res: usize = 0;
            if (self.ordering_specs) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.OrderByWire.ORDERING_SPECS_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const PerfettoSqlStructuredQuery.OrderBy, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const PerfettoSqlStructuredQuery.OrderBy, target: *gremlin.Writer) void {
            if (self.ordering_specs) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(PerfettoSqlStructuredQuery.OrderByWire.ORDERING_SPECS_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(PerfettoSqlStructuredQuery.OrderByWire.ORDERING_SPECS_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const OrderByReader = struct {
        buf: gremlin.Reader,
        _ordering_specs_offset: ?usize = null,
        _ordering_specs_last_offset: ?usize = null,
        _ordering_specs_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!PerfettoSqlStructuredQuery.OrderByReader {
            const buf = gremlin.Reader.init(src);
            var res = PerfettoSqlStructuredQuery.OrderByReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    PerfettoSqlStructuredQuery.OrderByWire.ORDERING_SPECS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._ordering_specs_offset == null) {
                            res._ordering_specs_offset = offset - result.size;
                        }
                        res._ordering_specs_last_offset = offset;
                        res._ordering_specs_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn orderingSpecsCount(self: *const PerfettoSqlStructuredQuery.OrderByReader) usize {
            return self._ordering_specs_cnt;
        }
        pub fn orderingSpecsNext(self: *PerfettoSqlStructuredQuery.OrderByReader) ?PerfettoSqlStructuredQuery.OrderBy.OrderingSpecReader {
            if (self._ordering_specs_offset == null) return null;
            const current_offset = self._ordering_specs_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = PerfettoSqlStructuredQuery.OrderBy.OrderingSpecReader.init(result.value) catch return null;
            if (self._ordering_specs_last_offset != null and current_offset >= self._ordering_specs_last_offset.?) {
                self._ordering_specs_offset = null;
                return msg;
            }
            if (self._ordering_specs_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._ordering_specs_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == PerfettoSqlStructuredQuery.OrderByWire.ORDERING_SPECS_WIRE) {
                    self._ordering_specs_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._ordering_specs_offset = null;
            return msg;
        }
    };
    const ExperimentalFilterGroupWire = struct {
        const OP_WIRE: gremlin.ProtoWireNumber = 1;
        const FILTERS_WIRE: gremlin.ProtoWireNumber = 2;
        const GROUPS_WIRE: gremlin.ProtoWireNumber = 3;
        const SQL_EXPRESSIONS_WIRE: gremlin.ProtoWireNumber = 4;
    };
    pub const ExperimentalFilterGroup = struct {
        // nested enums
        pub const Operator = enum(i32) {
            UNSPECIFIED = 0,
            AND = 1,
            OR = 2,
        };
        // fields
        op: PerfettoSqlStructuredQuery.ExperimentalFilterGroup.Operator = @enumFromInt(0),
        filters: ?[]const ?PerfettoSqlStructuredQuery.Filter = null,
        groups: ?[]const ?PerfettoSqlStructuredQuery.ExperimentalFilterGroup = null,
        sql_expressions: ?[]const ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const PerfettoSqlStructuredQuery.ExperimentalFilterGroup) usize {
            var res: usize = 0;
            if (@intFromEnum(self.op) != 0) {
                res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.ExperimentalFilterGroupWire.OP_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.op));
            }
            if (self.filters) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.ExperimentalFilterGroupWire.FILTERS_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.groups) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.ExperimentalFilterGroupWire.GROUPS_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.sql_expressions) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQuery.ExperimentalFilterGroupWire.SQL_EXPRESSIONS_WIRE);
                    if (maybe_v) |v| {
                        res += gremlin.sizes.sizeUsize(v.len) + v.len;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const PerfettoSqlStructuredQuery.ExperimentalFilterGroup, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const PerfettoSqlStructuredQuery.ExperimentalFilterGroup, target: *gremlin.Writer) void {
            if (@intFromEnum(self.op) != 0) {
                target.appendInt32(PerfettoSqlStructuredQuery.ExperimentalFilterGroupWire.OP_WIRE, @intFromEnum(self.op));
            }
            if (self.filters) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(PerfettoSqlStructuredQuery.ExperimentalFilterGroupWire.FILTERS_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(PerfettoSqlStructuredQuery.ExperimentalFilterGroupWire.FILTERS_WIRE, 0);
                    }
                }
            }
            if (self.groups) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(PerfettoSqlStructuredQuery.ExperimentalFilterGroupWire.GROUPS_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(PerfettoSqlStructuredQuery.ExperimentalFilterGroupWire.GROUPS_WIRE, 0);
                    }
                }
            }
            if (self.sql_expressions) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        target.appendBytes(PerfettoSqlStructuredQuery.ExperimentalFilterGroupWire.SQL_EXPRESSIONS_WIRE, v);
                    } else {
                        target.appendBytesTag(PerfettoSqlStructuredQuery.ExperimentalFilterGroupWire.SQL_EXPRESSIONS_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const ExperimentalFilterGroupReader = struct {
        buf: gremlin.Reader,
        _op: PerfettoSqlStructuredQuery.ExperimentalFilterGroup.Operator = @enumFromInt(0),
        _filters_offset: ?usize = null,
        _filters_last_offset: ?usize = null,
        _filters_cnt: usize = 0,
        _groups_offset: ?usize = null,
        _groups_last_offset: ?usize = null,
        _groups_cnt: usize = 0,
        _sql_expressions_offset: ?usize = null,
        _sql_expressions_last_offset: ?usize = null,
        _sql_expressions_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!PerfettoSqlStructuredQuery.ExperimentalFilterGroupReader {
            const buf = gremlin.Reader.init(src);
            var res = PerfettoSqlStructuredQuery.ExperimentalFilterGroupReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    PerfettoSqlStructuredQuery.ExperimentalFilterGroupWire.OP_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._op = @enumFromInt(result.value);
                    },
                    PerfettoSqlStructuredQuery.ExperimentalFilterGroupWire.FILTERS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._filters_offset == null) {
                            res._filters_offset = offset - result.size;
                        }
                        res._filters_last_offset = offset;
                        res._filters_cnt += 1;
                    },
                    PerfettoSqlStructuredQuery.ExperimentalFilterGroupWire.GROUPS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._groups_offset == null) {
                            res._groups_offset = offset - result.size;
                        }
                        res._groups_last_offset = offset;
                        res._groups_cnt += 1;
                    },
                    PerfettoSqlStructuredQuery.ExperimentalFilterGroupWire.SQL_EXPRESSIONS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._sql_expressions_offset == null) {
                            res._sql_expressions_offset = offset - result.size;
                        }
                        res._sql_expressions_last_offset = offset;
                        res._sql_expressions_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getOp(self: *const PerfettoSqlStructuredQuery.ExperimentalFilterGroupReader) PerfettoSqlStructuredQuery.ExperimentalFilterGroup.Operator {
            return self._op;
        }
        pub fn filtersCount(self: *const PerfettoSqlStructuredQuery.ExperimentalFilterGroupReader) usize {
            return self._filters_cnt;
        }
        pub fn filtersNext(self: *PerfettoSqlStructuredQuery.ExperimentalFilterGroupReader) ?PerfettoSqlStructuredQuery.FilterReader {
            if (self._filters_offset == null) return null;
            const current_offset = self._filters_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = PerfettoSqlStructuredQuery.FilterReader.init(result.value) catch return null;
            if (self._filters_last_offset != null and current_offset >= self._filters_last_offset.?) {
                self._filters_offset = null;
                return msg;
            }
            if (self._filters_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._filters_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == PerfettoSqlStructuredQuery.ExperimentalFilterGroupWire.FILTERS_WIRE) {
                    self._filters_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._filters_offset = null;
            return msg;
        }
        pub fn groupsCount(self: *const PerfettoSqlStructuredQuery.ExperimentalFilterGroupReader) usize {
            return self._groups_cnt;
        }
        pub fn groupsNext(self: *PerfettoSqlStructuredQuery.ExperimentalFilterGroupReader) ?PerfettoSqlStructuredQuery.ExperimentalFilterGroupReader {
            if (self._groups_offset == null) return null;
            const current_offset = self._groups_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = PerfettoSqlStructuredQuery.ExperimentalFilterGroupReader.init(result.value) catch return null;
            if (self._groups_last_offset != null and current_offset >= self._groups_last_offset.?) {
                self._groups_offset = null;
                return msg;
            }
            if (self._groups_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._groups_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == PerfettoSqlStructuredQuery.ExperimentalFilterGroupWire.GROUPS_WIRE) {
                    self._groups_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._groups_offset = null;
            return msg;
        }
        pub fn sqlExpressionsCount(self: *const PerfettoSqlStructuredQuery.ExperimentalFilterGroupReader) usize {
            return self._sql_expressions_cnt;
        }
        pub fn sqlExpressionsNext(self: *PerfettoSqlStructuredQuery.ExperimentalFilterGroupReader) ?[]const u8 {
            if (self._sql_expressions_offset == null) return null;
            const current_offset = self._sql_expressions_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            if (self._sql_expressions_last_offset != null and current_offset >= self._sql_expressions_last_offset.?) {
                self._sql_expressions_offset = null;
                return result.value;
            }
            if (self._sql_expressions_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._sql_expressions_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == PerfettoSqlStructuredQuery.ExperimentalFilterGroupWire.SQL_EXPRESSIONS_WIRE) {
                    self._sql_expressions_offset = next_offset;
                    return result.value;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._sql_expressions_offset = null;
            return result.value;
        }
    };
    // fields
    id: ?[]const u8 = null,
    referenced_modules: ?[]const ?[]const u8 = null,
    filters: ?[]const ?PerfettoSqlStructuredQuery.Filter = null,
    group_by: ?PerfettoSqlStructuredQuery.GroupBy = null,
    select_columns: ?[]const ?PerfettoSqlStructuredQuery.SelectColumn = null,
    order_by: ?PerfettoSqlStructuredQuery.OrderBy = null,
    limit: i64 = 0,
    offset: i64 = 0,
    experimental_filter_group: ?PerfettoSqlStructuredQuery.ExperimentalFilterGroup = null,
    table: ?PerfettoSqlStructuredQuery.Table = null,
    sql: ?PerfettoSqlStructuredQuery.Sql = null,
    simple_slices: ?PerfettoSqlStructuredQuery.SimpleSlices = null,
    inner_query: ?PerfettoSqlStructuredQuery = null,
    inner_query_id: ?[]const u8 = null,
    interval_intersect: ?PerfettoSqlStructuredQuery.IntervalIntersect = null,
    experimental_join: ?PerfettoSqlStructuredQuery.ExperimentalJoin = null,
    experimental_union: ?PerfettoSqlStructuredQuery.ExperimentalUnion = null,
    experimental_add_columns: ?PerfettoSqlStructuredQuery.ExperimentalAddColumns = null,
    pub fn calcProtobufSize(self: *const PerfettoSqlStructuredQuery) usize {
        var res: usize = 0;
        if (self.id) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQueryWire.ID_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.referenced_modules) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQueryWire.REFERENCED_MODULES_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.filters) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQueryWire.FILTERS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.group_by) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQueryWire.GROUP_BY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.select_columns) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQueryWire.SELECT_COLUMNS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.order_by) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQueryWire.ORDER_BY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.limit != 0) {
            res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQueryWire.LIMIT_WIRE) + gremlin.sizes.sizeI64(self.limit);
        }
        if (self.offset != 0) {
            res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQueryWire.OFFSET_WIRE) + gremlin.sizes.sizeI64(self.offset);
        }
        if (self.experimental_filter_group) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQueryWire.EXPERIMENTAL_FILTER_GROUP_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.table) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQueryWire.TABLE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.sql) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQueryWire.SQL_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.simple_slices) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQueryWire.SIMPLE_SLICES_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.inner_query) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQueryWire.INNER_QUERY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.inner_query_id) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQueryWire.INNER_QUERY_ID_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.interval_intersect) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQueryWire.INTERVAL_INTERSECT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.experimental_join) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQueryWire.EXPERIMENTAL_JOIN_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.experimental_union) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQueryWire.EXPERIMENTAL_UNION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.experimental_add_columns) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(PerfettoSqlStructuredQueryWire.EXPERIMENTAL_ADD_COLUMNS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const PerfettoSqlStructuredQuery, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const PerfettoSqlStructuredQuery, target: *gremlin.Writer) void {
        if (self.id) |v| {
            if (v.len > 0) {
                target.appendBytes(PerfettoSqlStructuredQueryWire.ID_WIRE, v);
            }
        }
        if (self.referenced_modules) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(PerfettoSqlStructuredQueryWire.REFERENCED_MODULES_WIRE, v);
                } else {
                    target.appendBytesTag(PerfettoSqlStructuredQueryWire.REFERENCED_MODULES_WIRE, 0);
                }
            }
        }
        if (self.filters) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(PerfettoSqlStructuredQueryWire.FILTERS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(PerfettoSqlStructuredQueryWire.FILTERS_WIRE, 0);
                }
            }
        }
        if (self.group_by) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(PerfettoSqlStructuredQueryWire.GROUP_BY_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.select_columns) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(PerfettoSqlStructuredQueryWire.SELECT_COLUMNS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(PerfettoSqlStructuredQueryWire.SELECT_COLUMNS_WIRE, 0);
                }
            }
        }
        if (self.order_by) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(PerfettoSqlStructuredQueryWire.ORDER_BY_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.limit != 0) {
            target.appendInt64(PerfettoSqlStructuredQueryWire.LIMIT_WIRE, self.limit);
        }
        if (self.offset != 0) {
            target.appendInt64(PerfettoSqlStructuredQueryWire.OFFSET_WIRE, self.offset);
        }
        if (self.experimental_filter_group) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(PerfettoSqlStructuredQueryWire.EXPERIMENTAL_FILTER_GROUP_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.table) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(PerfettoSqlStructuredQueryWire.TABLE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.sql) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(PerfettoSqlStructuredQueryWire.SQL_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.simple_slices) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(PerfettoSqlStructuredQueryWire.SIMPLE_SLICES_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.inner_query) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(PerfettoSqlStructuredQueryWire.INNER_QUERY_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.inner_query_id) |v| {
            if (v.len > 0) {
                target.appendBytes(PerfettoSqlStructuredQueryWire.INNER_QUERY_ID_WIRE, v);
            }
        }
        if (self.interval_intersect) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(PerfettoSqlStructuredQueryWire.INTERVAL_INTERSECT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.experimental_join) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(PerfettoSqlStructuredQueryWire.EXPERIMENTAL_JOIN_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.experimental_union) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(PerfettoSqlStructuredQueryWire.EXPERIMENTAL_UNION_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.experimental_add_columns) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(PerfettoSqlStructuredQueryWire.EXPERIMENTAL_ADD_COLUMNS_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const PerfettoSqlStructuredQueryReader = struct {
    buf: gremlin.Reader,
    _id: ?[]const u8 = null,
    _referenced_modules_offset: ?usize = null,
    _referenced_modules_last_offset: ?usize = null,
    _referenced_modules_cnt: usize = 0,
    _filters_offset: ?usize = null,
    _filters_last_offset: ?usize = null,
    _filters_cnt: usize = 0,
    _group_by_buf: ?[]const u8 = null,
    _select_columns_offset: ?usize = null,
    _select_columns_last_offset: ?usize = null,
    _select_columns_cnt: usize = 0,
    _order_by_buf: ?[]const u8 = null,
    _limit: i64 = 0,
    _offset: i64 = 0,
    _experimental_filter_group_buf: ?[]const u8 = null,
    _table_buf: ?[]const u8 = null,
    _sql_buf: ?[]const u8 = null,
    _simple_slices_buf: ?[]const u8 = null,
    _inner_query_buf: ?[]const u8 = null,
    _inner_query_id: ?[]const u8 = null,
    _interval_intersect_buf: ?[]const u8 = null,
    _experimental_join_buf: ?[]const u8 = null,
    _experimental_union_buf: ?[]const u8 = null,
    _experimental_add_columns_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!PerfettoSqlStructuredQueryReader {
        const buf = gremlin.Reader.init(src);
        var res = PerfettoSqlStructuredQueryReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                PerfettoSqlStructuredQueryWire.ID_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._id = result.value;
                },
                PerfettoSqlStructuredQueryWire.REFERENCED_MODULES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._referenced_modules_offset == null) {
                        res._referenced_modules_offset = offset - result.size;
                    }
                    res._referenced_modules_last_offset = offset;
                    res._referenced_modules_cnt += 1;
                },
                PerfettoSqlStructuredQueryWire.FILTERS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._filters_offset == null) {
                        res._filters_offset = offset - result.size;
                    }
                    res._filters_last_offset = offset;
                    res._filters_cnt += 1;
                },
                PerfettoSqlStructuredQueryWire.GROUP_BY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._group_by_buf = result.value;
                },
                PerfettoSqlStructuredQueryWire.SELECT_COLUMNS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._select_columns_offset == null) {
                        res._select_columns_offset = offset - result.size;
                    }
                    res._select_columns_last_offset = offset;
                    res._select_columns_cnt += 1;
                },
                PerfettoSqlStructuredQueryWire.ORDER_BY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._order_by_buf = result.value;
                },
                PerfettoSqlStructuredQueryWire.LIMIT_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._limit = result.value;
                },
                PerfettoSqlStructuredQueryWire.OFFSET_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._offset = result.value;
                },
                PerfettoSqlStructuredQueryWire.EXPERIMENTAL_FILTER_GROUP_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._experimental_filter_group_buf = result.value;
                },
                PerfettoSqlStructuredQueryWire.TABLE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._table_buf = result.value;
                },
                PerfettoSqlStructuredQueryWire.SQL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._sql_buf = result.value;
                },
                PerfettoSqlStructuredQueryWire.SIMPLE_SLICES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._simple_slices_buf = result.value;
                },
                PerfettoSqlStructuredQueryWire.INNER_QUERY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._inner_query_buf = result.value;
                },
                PerfettoSqlStructuredQueryWire.INNER_QUERY_ID_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._inner_query_id = result.value;
                },
                PerfettoSqlStructuredQueryWire.INTERVAL_INTERSECT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._interval_intersect_buf = result.value;
                },
                PerfettoSqlStructuredQueryWire.EXPERIMENTAL_JOIN_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._experimental_join_buf = result.value;
                },
                PerfettoSqlStructuredQueryWire.EXPERIMENTAL_UNION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._experimental_union_buf = result.value;
                },
                PerfettoSqlStructuredQueryWire.EXPERIMENTAL_ADD_COLUMNS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._experimental_add_columns_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getId(self: *const PerfettoSqlStructuredQueryReader) []const u8 {
        return self._id orelse &[_]u8{};
    }
    pub fn referencedModulesCount(self: *const PerfettoSqlStructuredQueryReader) usize {
        return self._referenced_modules_cnt;
    }
    pub fn referencedModulesNext(self: *PerfettoSqlStructuredQueryReader) ?[]const u8 {
        if (self._referenced_modules_offset == null) return null;
        const current_offset = self._referenced_modules_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._referenced_modules_last_offset != null and current_offset >= self._referenced_modules_last_offset.?) {
            self._referenced_modules_offset = null;
            return result.value;
        }
        if (self._referenced_modules_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._referenced_modules_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == PerfettoSqlStructuredQueryWire.REFERENCED_MODULES_WIRE) {
                self._referenced_modules_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._referenced_modules_offset = null;
        return result.value;
    }
    pub fn filtersCount(self: *const PerfettoSqlStructuredQueryReader) usize {
        return self._filters_cnt;
    }
    pub fn filtersNext(self: *PerfettoSqlStructuredQueryReader) ?PerfettoSqlStructuredQuery.FilterReader {
        if (self._filters_offset == null) return null;
        const current_offset = self._filters_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = PerfettoSqlStructuredQuery.FilterReader.init(result.value) catch return null;
        if (self._filters_last_offset != null and current_offset >= self._filters_last_offset.?) {
            self._filters_offset = null;
            return msg;
        }
        if (self._filters_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._filters_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == PerfettoSqlStructuredQueryWire.FILTERS_WIRE) {
                self._filters_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._filters_offset = null;
        return msg;
    }
    pub fn getGroupBy(self: *const PerfettoSqlStructuredQueryReader) gremlin.Error!PerfettoSqlStructuredQuery.GroupByReader {
        if (self._group_by_buf) |buf| {
            return try PerfettoSqlStructuredQuery.GroupByReader.init(buf);
        }
        return try PerfettoSqlStructuredQuery.GroupByReader.init(&[_]u8{});
    }
    pub fn selectColumnsCount(self: *const PerfettoSqlStructuredQueryReader) usize {
        return self._select_columns_cnt;
    }
    pub fn selectColumnsNext(self: *PerfettoSqlStructuredQueryReader) ?PerfettoSqlStructuredQuery.SelectColumnReader {
        if (self._select_columns_offset == null) return null;
        const current_offset = self._select_columns_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = PerfettoSqlStructuredQuery.SelectColumnReader.init(result.value) catch return null;
        if (self._select_columns_last_offset != null and current_offset >= self._select_columns_last_offset.?) {
            self._select_columns_offset = null;
            return msg;
        }
        if (self._select_columns_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._select_columns_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == PerfettoSqlStructuredQueryWire.SELECT_COLUMNS_WIRE) {
                self._select_columns_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._select_columns_offset = null;
        return msg;
    }
    pub fn getOrderBy(self: *const PerfettoSqlStructuredQueryReader) gremlin.Error!PerfettoSqlStructuredQuery.OrderByReader {
        if (self._order_by_buf) |buf| {
            return try PerfettoSqlStructuredQuery.OrderByReader.init(buf);
        }
        return try PerfettoSqlStructuredQuery.OrderByReader.init(&[_]u8{});
    }
    pub inline fn getLimit(self: *const PerfettoSqlStructuredQueryReader) i64 {
        return self._limit;
    }
    pub inline fn getOffset(self: *const PerfettoSqlStructuredQueryReader) i64 {
        return self._offset;
    }
    pub fn getExperimentalFilterGroup(self: *const PerfettoSqlStructuredQueryReader) gremlin.Error!PerfettoSqlStructuredQuery.ExperimentalFilterGroupReader {
        if (self._experimental_filter_group_buf) |buf| {
            return try PerfettoSqlStructuredQuery.ExperimentalFilterGroupReader.init(buf);
        }
        return try PerfettoSqlStructuredQuery.ExperimentalFilterGroupReader.init(&[_]u8{});
    }
    pub fn getTable(self: *const PerfettoSqlStructuredQueryReader) gremlin.Error!PerfettoSqlStructuredQuery.TableReader {
        if (self._table_buf) |buf| {
            return try PerfettoSqlStructuredQuery.TableReader.init(buf);
        }
        return try PerfettoSqlStructuredQuery.TableReader.init(&[_]u8{});
    }
    pub fn getSql(self: *const PerfettoSqlStructuredQueryReader) gremlin.Error!PerfettoSqlStructuredQuery.SqlReader {
        if (self._sql_buf) |buf| {
            return try PerfettoSqlStructuredQuery.SqlReader.init(buf);
        }
        return try PerfettoSqlStructuredQuery.SqlReader.init(&[_]u8{});
    }
    pub fn getSimpleSlices(self: *const PerfettoSqlStructuredQueryReader) gremlin.Error!PerfettoSqlStructuredQuery.SimpleSlicesReader {
        if (self._simple_slices_buf) |buf| {
            return try PerfettoSqlStructuredQuery.SimpleSlicesReader.init(buf);
        }
        return try PerfettoSqlStructuredQuery.SimpleSlicesReader.init(&[_]u8{});
    }
    pub fn getInnerQuery(self: *const PerfettoSqlStructuredQueryReader) gremlin.Error!PerfettoSqlStructuredQueryReader {
        if (self._inner_query_buf) |buf| {
            return try PerfettoSqlStructuredQueryReader.init(buf);
        }
        return try PerfettoSqlStructuredQueryReader.init(&[_]u8{});
    }
    pub inline fn getInnerQueryId(self: *const PerfettoSqlStructuredQueryReader) []const u8 {
        return self._inner_query_id orelse &[_]u8{};
    }
    pub fn getIntervalIntersect(self: *const PerfettoSqlStructuredQueryReader) gremlin.Error!PerfettoSqlStructuredQuery.IntervalIntersectReader {
        if (self._interval_intersect_buf) |buf| {
            return try PerfettoSqlStructuredQuery.IntervalIntersectReader.init(buf);
        }
        return try PerfettoSqlStructuredQuery.IntervalIntersectReader.init(&[_]u8{});
    }
    pub fn getExperimentalJoin(self: *const PerfettoSqlStructuredQueryReader) gremlin.Error!PerfettoSqlStructuredQuery.ExperimentalJoinReader {
        if (self._experimental_join_buf) |buf| {
            return try PerfettoSqlStructuredQuery.ExperimentalJoinReader.init(buf);
        }
        return try PerfettoSqlStructuredQuery.ExperimentalJoinReader.init(&[_]u8{});
    }
    pub fn getExperimentalUnion(self: *const PerfettoSqlStructuredQueryReader) gremlin.Error!PerfettoSqlStructuredQuery.ExperimentalUnionReader {
        if (self._experimental_union_buf) |buf| {
            return try PerfettoSqlStructuredQuery.ExperimentalUnionReader.init(buf);
        }
        return try PerfettoSqlStructuredQuery.ExperimentalUnionReader.init(&[_]u8{});
    }
    pub fn getExperimentalAddColumns(self: *const PerfettoSqlStructuredQueryReader) gremlin.Error!PerfettoSqlStructuredQuery.ExperimentalAddColumnsReader {
        if (self._experimental_add_columns_buf) |buf| {
            return try PerfettoSqlStructuredQuery.ExperimentalAddColumnsReader.init(buf);
        }
        return try PerfettoSqlStructuredQuery.ExperimentalAddColumnsReader.init(&[_]u8{});
    }
};
