// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
const profile_common = @import("profile_common.proto.zig");
const perf_events = @import("src/gen/protos/perfetto/common/perf_events.proto.zig");
// structs
const ProfilePacketWire = struct {
    const STRINGS_WIRE: gremlin.ProtoWireNumber = 1;
    const MAPPINGS_WIRE: gremlin.ProtoWireNumber = 4;
    const FRAMES_WIRE: gremlin.ProtoWireNumber = 2;
    const CALLSTACKS_WIRE: gremlin.ProtoWireNumber = 3;
    const PROCESS_DUMPS_WIRE: gremlin.ProtoWireNumber = 5;
    const CONTINUED_WIRE: gremlin.ProtoWireNumber = 6;
    const INDEX_WIRE: gremlin.ProtoWireNumber = 7;
};
pub const ProfilePacket = struct {
    // nested structs
    const HeapSampleWire = struct {
        const CALLSTACK_ID_WIRE: gremlin.ProtoWireNumber = 1;
        const SELF_ALLOCATED_WIRE: gremlin.ProtoWireNumber = 2;
        const SELF_FREED_WIRE: gremlin.ProtoWireNumber = 3;
        const SELF_MAX_WIRE: gremlin.ProtoWireNumber = 8;
        const SELF_MAX_COUNT_WIRE: gremlin.ProtoWireNumber = 9;
        const TIMESTAMP_WIRE: gremlin.ProtoWireNumber = 4;
        const ALLOC_COUNT_WIRE: gremlin.ProtoWireNumber = 5;
        const FREE_COUNT_WIRE: gremlin.ProtoWireNumber = 6;
    };
    pub const HeapSample = struct {
        // fields
        callstack_id: u64 = 0,
        self_allocated: u64 = 0,
        self_freed: u64 = 0,
        self_max: u64 = 0,
        self_max_count: u64 = 0,
        timestamp: u64 = 0,
        alloc_count: u64 = 0,
        free_count: u64 = 0,
        pub fn calcProtobufSize(self: *const ProfilePacket.HeapSample) usize {
            var res: usize = 0;
            if (self.callstack_id != 0) {
                res += gremlin.sizes.sizeWireNumber(ProfilePacket.HeapSampleWire.CALLSTACK_ID_WIRE) + gremlin.sizes.sizeU64(self.callstack_id);
            }
            if (self.self_allocated != 0) {
                res += gremlin.sizes.sizeWireNumber(ProfilePacket.HeapSampleWire.SELF_ALLOCATED_WIRE) + gremlin.sizes.sizeU64(self.self_allocated);
            }
            if (self.self_freed != 0) {
                res += gremlin.sizes.sizeWireNumber(ProfilePacket.HeapSampleWire.SELF_FREED_WIRE) + gremlin.sizes.sizeU64(self.self_freed);
            }
            if (self.self_max != 0) {
                res += gremlin.sizes.sizeWireNumber(ProfilePacket.HeapSampleWire.SELF_MAX_WIRE) + gremlin.sizes.sizeU64(self.self_max);
            }
            if (self.self_max_count != 0) {
                res += gremlin.sizes.sizeWireNumber(ProfilePacket.HeapSampleWire.SELF_MAX_COUNT_WIRE) + gremlin.sizes.sizeU64(self.self_max_count);
            }
            if (self.timestamp != 0) {
                res += gremlin.sizes.sizeWireNumber(ProfilePacket.HeapSampleWire.TIMESTAMP_WIRE) + gremlin.sizes.sizeU64(self.timestamp);
            }
            if (self.alloc_count != 0) {
                res += gremlin.sizes.sizeWireNumber(ProfilePacket.HeapSampleWire.ALLOC_COUNT_WIRE) + gremlin.sizes.sizeU64(self.alloc_count);
            }
            if (self.free_count != 0) {
                res += gremlin.sizes.sizeWireNumber(ProfilePacket.HeapSampleWire.FREE_COUNT_WIRE) + gremlin.sizes.sizeU64(self.free_count);
            }
            return res;
        }
        pub fn encode(self: *const ProfilePacket.HeapSample, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const ProfilePacket.HeapSample, target: *gremlin.Writer) void {
            if (self.callstack_id != 0) {
                target.appendUint64(ProfilePacket.HeapSampleWire.CALLSTACK_ID_WIRE, self.callstack_id);
            }
            if (self.self_allocated != 0) {
                target.appendUint64(ProfilePacket.HeapSampleWire.SELF_ALLOCATED_WIRE, self.self_allocated);
            }
            if (self.self_freed != 0) {
                target.appendUint64(ProfilePacket.HeapSampleWire.SELF_FREED_WIRE, self.self_freed);
            }
            if (self.self_max != 0) {
                target.appendUint64(ProfilePacket.HeapSampleWire.SELF_MAX_WIRE, self.self_max);
            }
            if (self.self_max_count != 0) {
                target.appendUint64(ProfilePacket.HeapSampleWire.SELF_MAX_COUNT_WIRE, self.self_max_count);
            }
            if (self.timestamp != 0) {
                target.appendUint64(ProfilePacket.HeapSampleWire.TIMESTAMP_WIRE, self.timestamp);
            }
            if (self.alloc_count != 0) {
                target.appendUint64(ProfilePacket.HeapSampleWire.ALLOC_COUNT_WIRE, self.alloc_count);
            }
            if (self.free_count != 0) {
                target.appendUint64(ProfilePacket.HeapSampleWire.FREE_COUNT_WIRE, self.free_count);
            }
        }
    };
    pub const HeapSampleReader = struct {
        buf: gremlin.Reader,
        _callstack_id: u64 = 0,
        _self_allocated: u64 = 0,
        _self_freed: u64 = 0,
        _self_max: u64 = 0,
        _self_max_count: u64 = 0,
        _timestamp: u64 = 0,
        _alloc_count: u64 = 0,
        _free_count: u64 = 0,
        pub fn init(src: []const u8) gremlin.Error!ProfilePacket.HeapSampleReader {
            const buf = gremlin.Reader.init(src);
            var res = ProfilePacket.HeapSampleReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    ProfilePacket.HeapSampleWire.CALLSTACK_ID_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._callstack_id = result.value;
                    },
                    ProfilePacket.HeapSampleWire.SELF_ALLOCATED_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._self_allocated = result.value;
                    },
                    ProfilePacket.HeapSampleWire.SELF_FREED_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._self_freed = result.value;
                    },
                    ProfilePacket.HeapSampleWire.SELF_MAX_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._self_max = result.value;
                    },
                    ProfilePacket.HeapSampleWire.SELF_MAX_COUNT_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._self_max_count = result.value;
                    },
                    ProfilePacket.HeapSampleWire.TIMESTAMP_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._timestamp = result.value;
                    },
                    ProfilePacket.HeapSampleWire.ALLOC_COUNT_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._alloc_count = result.value;
                    },
                    ProfilePacket.HeapSampleWire.FREE_COUNT_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._free_count = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getCallstackId(self: *const ProfilePacket.HeapSampleReader) u64 {
            return self._callstack_id;
        }
        pub inline fn getSelfAllocated(self: *const ProfilePacket.HeapSampleReader) u64 {
            return self._self_allocated;
        }
        pub inline fn getSelfFreed(self: *const ProfilePacket.HeapSampleReader) u64 {
            return self._self_freed;
        }
        pub inline fn getSelfMax(self: *const ProfilePacket.HeapSampleReader) u64 {
            return self._self_max;
        }
        pub inline fn getSelfMaxCount(self: *const ProfilePacket.HeapSampleReader) u64 {
            return self._self_max_count;
        }
        pub inline fn getTimestamp(self: *const ProfilePacket.HeapSampleReader) u64 {
            return self._timestamp;
        }
        pub inline fn getAllocCount(self: *const ProfilePacket.HeapSampleReader) u64 {
            return self._alloc_count;
        }
        pub inline fn getFreeCount(self: *const ProfilePacket.HeapSampleReader) u64 {
            return self._free_count;
        }
    };
    const HistogramWire = struct {
        const BUCKETS_WIRE: gremlin.ProtoWireNumber = 1;
    };
    pub const Histogram = struct {
        // nested structs
        const BucketWire = struct {
            const UPPER_LIMIT_WIRE: gremlin.ProtoWireNumber = 1;
            const MAX_BUCKET_WIRE: gremlin.ProtoWireNumber = 2;
            const COUNT_WIRE: gremlin.ProtoWireNumber = 3;
        };
        pub const Bucket = struct {
            // fields
            upper_limit: u64 = 0,
            max_bucket: bool = false,
            count: u64 = 0,
            pub fn calcProtobufSize(self: *const ProfilePacket.Histogram.Bucket) usize {
                var res: usize = 0;
                if (self.upper_limit != 0) {
                    res += gremlin.sizes.sizeWireNumber(ProfilePacket.Histogram.BucketWire.UPPER_LIMIT_WIRE) + gremlin.sizes.sizeU64(self.upper_limit);
                }
                if (self.max_bucket != false) {
                    res += gremlin.sizes.sizeWireNumber(ProfilePacket.Histogram.BucketWire.MAX_BUCKET_WIRE) + gremlin.sizes.sizeBool(self.max_bucket);
                }
                if (self.count != 0) {
                    res += gremlin.sizes.sizeWireNumber(ProfilePacket.Histogram.BucketWire.COUNT_WIRE) + gremlin.sizes.sizeU64(self.count);
                }
                return res;
            }
            pub fn encode(self: *const ProfilePacket.Histogram.Bucket, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const ProfilePacket.Histogram.Bucket, target: *gremlin.Writer) void {
                if (self.upper_limit != 0) {
                    target.appendUint64(ProfilePacket.Histogram.BucketWire.UPPER_LIMIT_WIRE, self.upper_limit);
                }
                if (self.max_bucket != false) {
                    target.appendBool(ProfilePacket.Histogram.BucketWire.MAX_BUCKET_WIRE, self.max_bucket);
                }
                if (self.count != 0) {
                    target.appendUint64(ProfilePacket.Histogram.BucketWire.COUNT_WIRE, self.count);
                }
            }
        };
        pub const BucketReader = struct {
            buf: gremlin.Reader,
            _upper_limit: u64 = 0,
            _max_bucket: bool = false,
            _count: u64 = 0,
            pub fn init(src: []const u8) gremlin.Error!ProfilePacket.Histogram.BucketReader {
                const buf = gremlin.Reader.init(src);
                var res = ProfilePacket.Histogram.BucketReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        ProfilePacket.Histogram.BucketWire.UPPER_LIMIT_WIRE => {
                            const result = try buf.readUInt64(offset);
                            offset += result.size;
                            res._upper_limit = result.value;
                        },
                        ProfilePacket.Histogram.BucketWire.MAX_BUCKET_WIRE => {
                            const result = try buf.readBool(offset);
                            offset += result.size;
                            res._max_bucket = result.value;
                        },
                        ProfilePacket.Histogram.BucketWire.COUNT_WIRE => {
                            const result = try buf.readUInt64(offset);
                            offset += result.size;
                            res._count = result.value;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub inline fn getUpperLimit(self: *const ProfilePacket.Histogram.BucketReader) u64 {
                return self._upper_limit;
            }
            pub inline fn getMaxBucket(self: *const ProfilePacket.Histogram.BucketReader) bool {
                return self._max_bucket;
            }
            pub inline fn getCount(self: *const ProfilePacket.Histogram.BucketReader) u64 {
                return self._count;
            }
        };
        // fields
        buckets: ?[]const ?ProfilePacket.Histogram.Bucket = null,
        pub fn calcProtobufSize(self: *const ProfilePacket.Histogram) usize {
            var res: usize = 0;
            if (self.buckets) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(ProfilePacket.HistogramWire.BUCKETS_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const ProfilePacket.Histogram, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const ProfilePacket.Histogram, target: *gremlin.Writer) void {
            if (self.buckets) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(ProfilePacket.HistogramWire.BUCKETS_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(ProfilePacket.HistogramWire.BUCKETS_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const HistogramReader = struct {
        buf: gremlin.Reader,
        _buckets_offset: ?usize = null,
        _buckets_last_offset: ?usize = null,
        _buckets_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!ProfilePacket.HistogramReader {
            const buf = gremlin.Reader.init(src);
            var res = ProfilePacket.HistogramReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    ProfilePacket.HistogramWire.BUCKETS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._buckets_offset == null) {
                            res._buckets_offset = offset - result.size;
                        }
                        res._buckets_last_offset = offset;
                        res._buckets_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn bucketsCount(self: *const ProfilePacket.HistogramReader) usize {
            return self._buckets_cnt;
        }
        pub fn bucketsNext(self: *ProfilePacket.HistogramReader) ?ProfilePacket.Histogram.BucketReader {
            if (self._buckets_offset == null) return null;
            const current_offset = self._buckets_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = ProfilePacket.Histogram.BucketReader.init(result.value) catch return null;
            if (self._buckets_last_offset != null and current_offset >= self._buckets_last_offset.?) {
                self._buckets_offset = null;
                return msg;
            }
            if (self._buckets_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._buckets_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == ProfilePacket.HistogramWire.BUCKETS_WIRE) {
                    self._buckets_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._buckets_offset = null;
            return msg;
        }
    };
    const ProcessStatsWire = struct {
        const UNWINDING_ERRORS_WIRE: gremlin.ProtoWireNumber = 1;
        const HEAP_SAMPLES_WIRE: gremlin.ProtoWireNumber = 2;
        const MAP_REPARSES_WIRE: gremlin.ProtoWireNumber = 3;
        const UNWINDING_TIME_US_WIRE: gremlin.ProtoWireNumber = 4;
        const TOTAL_UNWINDING_TIME_US_WIRE: gremlin.ProtoWireNumber = 5;
        const CLIENT_SPINLOCK_BLOCKED_US_WIRE: gremlin.ProtoWireNumber = 6;
    };
    pub const ProcessStats = struct {
        // fields
        unwinding_errors: u64 = 0,
        heap_samples: u64 = 0,
        map_reparses: u64 = 0,
        unwinding_time_us: ?ProfilePacket.Histogram = null,
        total_unwinding_time_us: u64 = 0,
        client_spinlock_blocked_us: u64 = 0,
        pub fn calcProtobufSize(self: *const ProfilePacket.ProcessStats) usize {
            var res: usize = 0;
            if (self.unwinding_errors != 0) {
                res += gremlin.sizes.sizeWireNumber(ProfilePacket.ProcessStatsWire.UNWINDING_ERRORS_WIRE) + gremlin.sizes.sizeU64(self.unwinding_errors);
            }
            if (self.heap_samples != 0) {
                res += gremlin.sizes.sizeWireNumber(ProfilePacket.ProcessStatsWire.HEAP_SAMPLES_WIRE) + gremlin.sizes.sizeU64(self.heap_samples);
            }
            if (self.map_reparses != 0) {
                res += gremlin.sizes.sizeWireNumber(ProfilePacket.ProcessStatsWire.MAP_REPARSES_WIRE) + gremlin.sizes.sizeU64(self.map_reparses);
            }
            if (self.unwinding_time_us) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(ProfilePacket.ProcessStatsWire.UNWINDING_TIME_US_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.total_unwinding_time_us != 0) {
                res += gremlin.sizes.sizeWireNumber(ProfilePacket.ProcessStatsWire.TOTAL_UNWINDING_TIME_US_WIRE) + gremlin.sizes.sizeU64(self.total_unwinding_time_us);
            }
            if (self.client_spinlock_blocked_us != 0) {
                res += gremlin.sizes.sizeWireNumber(ProfilePacket.ProcessStatsWire.CLIENT_SPINLOCK_BLOCKED_US_WIRE) + gremlin.sizes.sizeU64(self.client_spinlock_blocked_us);
            }
            return res;
        }
        pub fn encode(self: *const ProfilePacket.ProcessStats, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const ProfilePacket.ProcessStats, target: *gremlin.Writer) void {
            if (self.unwinding_errors != 0) {
                target.appendUint64(ProfilePacket.ProcessStatsWire.UNWINDING_ERRORS_WIRE, self.unwinding_errors);
            }
            if (self.heap_samples != 0) {
                target.appendUint64(ProfilePacket.ProcessStatsWire.HEAP_SAMPLES_WIRE, self.heap_samples);
            }
            if (self.map_reparses != 0) {
                target.appendUint64(ProfilePacket.ProcessStatsWire.MAP_REPARSES_WIRE, self.map_reparses);
            }
            if (self.unwinding_time_us) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(ProfilePacket.ProcessStatsWire.UNWINDING_TIME_US_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.total_unwinding_time_us != 0) {
                target.appendUint64(ProfilePacket.ProcessStatsWire.TOTAL_UNWINDING_TIME_US_WIRE, self.total_unwinding_time_us);
            }
            if (self.client_spinlock_blocked_us != 0) {
                target.appendUint64(ProfilePacket.ProcessStatsWire.CLIENT_SPINLOCK_BLOCKED_US_WIRE, self.client_spinlock_blocked_us);
            }
        }
    };
    pub const ProcessStatsReader = struct {
        buf: gremlin.Reader,
        _unwinding_errors: u64 = 0,
        _heap_samples: u64 = 0,
        _map_reparses: u64 = 0,
        _unwinding_time_us_buf: ?[]const u8 = null,
        _total_unwinding_time_us: u64 = 0,
        _client_spinlock_blocked_us: u64 = 0,
        pub fn init(src: []const u8) gremlin.Error!ProfilePacket.ProcessStatsReader {
            const buf = gremlin.Reader.init(src);
            var res = ProfilePacket.ProcessStatsReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    ProfilePacket.ProcessStatsWire.UNWINDING_ERRORS_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._unwinding_errors = result.value;
                    },
                    ProfilePacket.ProcessStatsWire.HEAP_SAMPLES_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._heap_samples = result.value;
                    },
                    ProfilePacket.ProcessStatsWire.MAP_REPARSES_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._map_reparses = result.value;
                    },
                    ProfilePacket.ProcessStatsWire.UNWINDING_TIME_US_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._unwinding_time_us_buf = result.value;
                    },
                    ProfilePacket.ProcessStatsWire.TOTAL_UNWINDING_TIME_US_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._total_unwinding_time_us = result.value;
                    },
                    ProfilePacket.ProcessStatsWire.CLIENT_SPINLOCK_BLOCKED_US_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._client_spinlock_blocked_us = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getUnwindingErrors(self: *const ProfilePacket.ProcessStatsReader) u64 {
            return self._unwinding_errors;
        }
        pub inline fn getHeapSamples(self: *const ProfilePacket.ProcessStatsReader) u64 {
            return self._heap_samples;
        }
        pub inline fn getMapReparses(self: *const ProfilePacket.ProcessStatsReader) u64 {
            return self._map_reparses;
        }
        pub fn getUnwindingTimeUs(self: *const ProfilePacket.ProcessStatsReader) gremlin.Error!ProfilePacket.HistogramReader {
            if (self._unwinding_time_us_buf) |buf| {
                return try ProfilePacket.HistogramReader.init(buf);
            }
            return try ProfilePacket.HistogramReader.init(&[_]u8{});
        }
        pub inline fn getTotalUnwindingTimeUs(self: *const ProfilePacket.ProcessStatsReader) u64 {
            return self._total_unwinding_time_us;
        }
        pub inline fn getClientSpinlockBlockedUs(self: *const ProfilePacket.ProcessStatsReader) u64 {
            return self._client_spinlock_blocked_us;
        }
    };
    const ProcessHeapSamplesWire = struct {
        const PID_WIRE: gremlin.ProtoWireNumber = 1;
        const FROM_STARTUP_WIRE: gremlin.ProtoWireNumber = 3;
        const REJECTED_CONCURRENT_WIRE: gremlin.ProtoWireNumber = 4;
        const DISCONNECTED_WIRE: gremlin.ProtoWireNumber = 6;
        const BUFFER_OVERRAN_WIRE: gremlin.ProtoWireNumber = 7;
        const CLIENT_ERROR_WIRE: gremlin.ProtoWireNumber = 14;
        const BUFFER_CORRUPTED_WIRE: gremlin.ProtoWireNumber = 8;
        const HIT_GUARDRAIL_WIRE: gremlin.ProtoWireNumber = 10;
        const HEAP_NAME_WIRE: gremlin.ProtoWireNumber = 11;
        const SAMPLING_INTERVAL_BYTES_WIRE: gremlin.ProtoWireNumber = 12;
        const ORIG_SAMPLING_INTERVAL_BYTES_WIRE: gremlin.ProtoWireNumber = 13;
        const TIMESTAMP_WIRE: gremlin.ProtoWireNumber = 9;
        const STATS_WIRE: gremlin.ProtoWireNumber = 5;
        const SAMPLES_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const ProcessHeapSamples = struct {
        // nested enums
        pub const ClientError = enum(i32) {
            CLIENT_ERROR_NONE = 0,
            CLIENT_ERROR_HIT_TIMEOUT = 1,
            CLIENT_ERROR_INVALID_STACK_BOUNDS = 2,
        };
        // fields
        pid: u64 = 0,
        from_startup: bool = false,
        rejected_concurrent: bool = false,
        disconnected: bool = false,
        buffer_overran: bool = false,
        client_error: ProfilePacket.ProcessHeapSamples.ClientError = @enumFromInt(0),
        buffer_corrupted: bool = false,
        hit_guardrail: bool = false,
        heap_name: ?[]const u8 = null,
        sampling_interval_bytes: u64 = 0,
        orig_sampling_interval_bytes: u64 = 0,
        timestamp: u64 = 0,
        stats: ?ProfilePacket.ProcessStats = null,
        samples: ?[]const ?ProfilePacket.HeapSample = null,
        pub fn calcProtobufSize(self: *const ProfilePacket.ProcessHeapSamples) usize {
            var res: usize = 0;
            if (self.pid != 0) {
                res += gremlin.sizes.sizeWireNumber(ProfilePacket.ProcessHeapSamplesWire.PID_WIRE) + gremlin.sizes.sizeU64(self.pid);
            }
            if (self.from_startup != false) {
                res += gremlin.sizes.sizeWireNumber(ProfilePacket.ProcessHeapSamplesWire.FROM_STARTUP_WIRE) + gremlin.sizes.sizeBool(self.from_startup);
            }
            if (self.rejected_concurrent != false) {
                res += gremlin.sizes.sizeWireNumber(ProfilePacket.ProcessHeapSamplesWire.REJECTED_CONCURRENT_WIRE) + gremlin.sizes.sizeBool(self.rejected_concurrent);
            }
            if (self.disconnected != false) {
                res += gremlin.sizes.sizeWireNumber(ProfilePacket.ProcessHeapSamplesWire.DISCONNECTED_WIRE) + gremlin.sizes.sizeBool(self.disconnected);
            }
            if (self.buffer_overran != false) {
                res += gremlin.sizes.sizeWireNumber(ProfilePacket.ProcessHeapSamplesWire.BUFFER_OVERRAN_WIRE) + gremlin.sizes.sizeBool(self.buffer_overran);
            }
            if (@intFromEnum(self.client_error) != 0) {
                res += gremlin.sizes.sizeWireNumber(ProfilePacket.ProcessHeapSamplesWire.CLIENT_ERROR_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.client_error));
            }
            if (self.buffer_corrupted != false) {
                res += gremlin.sizes.sizeWireNumber(ProfilePacket.ProcessHeapSamplesWire.BUFFER_CORRUPTED_WIRE) + gremlin.sizes.sizeBool(self.buffer_corrupted);
            }
            if (self.hit_guardrail != false) {
                res += gremlin.sizes.sizeWireNumber(ProfilePacket.ProcessHeapSamplesWire.HIT_GUARDRAIL_WIRE) + gremlin.sizes.sizeBool(self.hit_guardrail);
            }
            if (self.heap_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(ProfilePacket.ProcessHeapSamplesWire.HEAP_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.sampling_interval_bytes != 0) {
                res += gremlin.sizes.sizeWireNumber(ProfilePacket.ProcessHeapSamplesWire.SAMPLING_INTERVAL_BYTES_WIRE) + gremlin.sizes.sizeU64(self.sampling_interval_bytes);
            }
            if (self.orig_sampling_interval_bytes != 0) {
                res += gremlin.sizes.sizeWireNumber(ProfilePacket.ProcessHeapSamplesWire.ORIG_SAMPLING_INTERVAL_BYTES_WIRE) + gremlin.sizes.sizeU64(self.orig_sampling_interval_bytes);
            }
            if (self.timestamp != 0) {
                res += gremlin.sizes.sizeWireNumber(ProfilePacket.ProcessHeapSamplesWire.TIMESTAMP_WIRE) + gremlin.sizes.sizeU64(self.timestamp);
            }
            if (self.stats) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(ProfilePacket.ProcessHeapSamplesWire.STATS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.samples) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(ProfilePacket.ProcessHeapSamplesWire.SAMPLES_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const ProfilePacket.ProcessHeapSamples, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const ProfilePacket.ProcessHeapSamples, target: *gremlin.Writer) void {
            if (self.pid != 0) {
                target.appendUint64(ProfilePacket.ProcessHeapSamplesWire.PID_WIRE, self.pid);
            }
            if (self.from_startup != false) {
                target.appendBool(ProfilePacket.ProcessHeapSamplesWire.FROM_STARTUP_WIRE, self.from_startup);
            }
            if (self.rejected_concurrent != false) {
                target.appendBool(ProfilePacket.ProcessHeapSamplesWire.REJECTED_CONCURRENT_WIRE, self.rejected_concurrent);
            }
            if (self.disconnected != false) {
                target.appendBool(ProfilePacket.ProcessHeapSamplesWire.DISCONNECTED_WIRE, self.disconnected);
            }
            if (self.buffer_overran != false) {
                target.appendBool(ProfilePacket.ProcessHeapSamplesWire.BUFFER_OVERRAN_WIRE, self.buffer_overran);
            }
            if (@intFromEnum(self.client_error) != 0) {
                target.appendInt32(ProfilePacket.ProcessHeapSamplesWire.CLIENT_ERROR_WIRE, @intFromEnum(self.client_error));
            }
            if (self.buffer_corrupted != false) {
                target.appendBool(ProfilePacket.ProcessHeapSamplesWire.BUFFER_CORRUPTED_WIRE, self.buffer_corrupted);
            }
            if (self.hit_guardrail != false) {
                target.appendBool(ProfilePacket.ProcessHeapSamplesWire.HIT_GUARDRAIL_WIRE, self.hit_guardrail);
            }
            if (self.heap_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(ProfilePacket.ProcessHeapSamplesWire.HEAP_NAME_WIRE, v);
                }
            }
            if (self.sampling_interval_bytes != 0) {
                target.appendUint64(ProfilePacket.ProcessHeapSamplesWire.SAMPLING_INTERVAL_BYTES_WIRE, self.sampling_interval_bytes);
            }
            if (self.orig_sampling_interval_bytes != 0) {
                target.appendUint64(ProfilePacket.ProcessHeapSamplesWire.ORIG_SAMPLING_INTERVAL_BYTES_WIRE, self.orig_sampling_interval_bytes);
            }
            if (self.timestamp != 0) {
                target.appendUint64(ProfilePacket.ProcessHeapSamplesWire.TIMESTAMP_WIRE, self.timestamp);
            }
            if (self.stats) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(ProfilePacket.ProcessHeapSamplesWire.STATS_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.samples) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(ProfilePacket.ProcessHeapSamplesWire.SAMPLES_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(ProfilePacket.ProcessHeapSamplesWire.SAMPLES_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const ProcessHeapSamplesReader = struct {
        buf: gremlin.Reader,
        _pid: u64 = 0,
        _from_startup: bool = false,
        _rejected_concurrent: bool = false,
        _disconnected: bool = false,
        _buffer_overran: bool = false,
        _client_error: ProfilePacket.ProcessHeapSamples.ClientError = @enumFromInt(0),
        _buffer_corrupted: bool = false,
        _hit_guardrail: bool = false,
        _heap_name: ?[]const u8 = null,
        _sampling_interval_bytes: u64 = 0,
        _orig_sampling_interval_bytes: u64 = 0,
        _timestamp: u64 = 0,
        _stats_buf: ?[]const u8 = null,
        _samples_offset: ?usize = null,
        _samples_last_offset: ?usize = null,
        _samples_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!ProfilePacket.ProcessHeapSamplesReader {
            const buf = gremlin.Reader.init(src);
            var res = ProfilePacket.ProcessHeapSamplesReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    ProfilePacket.ProcessHeapSamplesWire.PID_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._pid = result.value;
                    },
                    ProfilePacket.ProcessHeapSamplesWire.FROM_STARTUP_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._from_startup = result.value;
                    },
                    ProfilePacket.ProcessHeapSamplesWire.REJECTED_CONCURRENT_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._rejected_concurrent = result.value;
                    },
                    ProfilePacket.ProcessHeapSamplesWire.DISCONNECTED_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._disconnected = result.value;
                    },
                    ProfilePacket.ProcessHeapSamplesWire.BUFFER_OVERRAN_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._buffer_overran = result.value;
                    },
                    ProfilePacket.ProcessHeapSamplesWire.CLIENT_ERROR_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._client_error = @enumFromInt(result.value);
                    },
                    ProfilePacket.ProcessHeapSamplesWire.BUFFER_CORRUPTED_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._buffer_corrupted = result.value;
                    },
                    ProfilePacket.ProcessHeapSamplesWire.HIT_GUARDRAIL_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._hit_guardrail = result.value;
                    },
                    ProfilePacket.ProcessHeapSamplesWire.HEAP_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._heap_name = result.value;
                    },
                    ProfilePacket.ProcessHeapSamplesWire.SAMPLING_INTERVAL_BYTES_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._sampling_interval_bytes = result.value;
                    },
                    ProfilePacket.ProcessHeapSamplesWire.ORIG_SAMPLING_INTERVAL_BYTES_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._orig_sampling_interval_bytes = result.value;
                    },
                    ProfilePacket.ProcessHeapSamplesWire.TIMESTAMP_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._timestamp = result.value;
                    },
                    ProfilePacket.ProcessHeapSamplesWire.STATS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._stats_buf = result.value;
                    },
                    ProfilePacket.ProcessHeapSamplesWire.SAMPLES_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._samples_offset == null) {
                            res._samples_offset = offset - result.size;
                        }
                        res._samples_last_offset = offset;
                        res._samples_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getPid(self: *const ProfilePacket.ProcessHeapSamplesReader) u64 {
            return self._pid;
        }
        pub inline fn getFromStartup(self: *const ProfilePacket.ProcessHeapSamplesReader) bool {
            return self._from_startup;
        }
        pub inline fn getRejectedConcurrent(self: *const ProfilePacket.ProcessHeapSamplesReader) bool {
            return self._rejected_concurrent;
        }
        pub inline fn getDisconnected(self: *const ProfilePacket.ProcessHeapSamplesReader) bool {
            return self._disconnected;
        }
        pub inline fn getBufferOverran(self: *const ProfilePacket.ProcessHeapSamplesReader) bool {
            return self._buffer_overran;
        }
        pub inline fn getClientError(self: *const ProfilePacket.ProcessHeapSamplesReader) ProfilePacket.ProcessHeapSamples.ClientError {
            return self._client_error;
        }
        pub inline fn getBufferCorrupted(self: *const ProfilePacket.ProcessHeapSamplesReader) bool {
            return self._buffer_corrupted;
        }
        pub inline fn getHitGuardrail(self: *const ProfilePacket.ProcessHeapSamplesReader) bool {
            return self._hit_guardrail;
        }
        pub inline fn getHeapName(self: *const ProfilePacket.ProcessHeapSamplesReader) []const u8 {
            return self._heap_name orelse &[_]u8{};
        }
        pub inline fn getSamplingIntervalBytes(self: *const ProfilePacket.ProcessHeapSamplesReader) u64 {
            return self._sampling_interval_bytes;
        }
        pub inline fn getOrigSamplingIntervalBytes(self: *const ProfilePacket.ProcessHeapSamplesReader) u64 {
            return self._orig_sampling_interval_bytes;
        }
        pub inline fn getTimestamp(self: *const ProfilePacket.ProcessHeapSamplesReader) u64 {
            return self._timestamp;
        }
        pub fn getStats(self: *const ProfilePacket.ProcessHeapSamplesReader) gremlin.Error!ProfilePacket.ProcessStatsReader {
            if (self._stats_buf) |buf| {
                return try ProfilePacket.ProcessStatsReader.init(buf);
            }
            return try ProfilePacket.ProcessStatsReader.init(&[_]u8{});
        }
        pub fn samplesCount(self: *const ProfilePacket.ProcessHeapSamplesReader) usize {
            return self._samples_cnt;
        }
        pub fn samplesNext(self: *ProfilePacket.ProcessHeapSamplesReader) ?ProfilePacket.HeapSampleReader {
            if (self._samples_offset == null) return null;
            const current_offset = self._samples_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = ProfilePacket.HeapSampleReader.init(result.value) catch return null;
            if (self._samples_last_offset != null and current_offset >= self._samples_last_offset.?) {
                self._samples_offset = null;
                return msg;
            }
            if (self._samples_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._samples_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == ProfilePacket.ProcessHeapSamplesWire.SAMPLES_WIRE) {
                    self._samples_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._samples_offset = null;
            return msg;
        }
    };
    // fields
    strings: ?[]const ?profile_common.InternedString = null,
    mappings: ?[]const ?profile_common.Mapping = null,
    frames: ?[]const ?profile_common.Frame = null,
    callstacks: ?[]const ?profile_common.Callstack = null,
    process_dumps: ?[]const ?ProfilePacket.ProcessHeapSamples = null,
    continued: bool = false,
    index: u64 = 0,
    pub fn calcProtobufSize(self: *const ProfilePacket) usize {
        var res: usize = 0;
        if (self.strings) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ProfilePacketWire.STRINGS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.mappings) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ProfilePacketWire.MAPPINGS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.frames) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ProfilePacketWire.FRAMES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.callstacks) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ProfilePacketWire.CALLSTACKS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.process_dumps) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ProfilePacketWire.PROCESS_DUMPS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.continued != false) {
            res += gremlin.sizes.sizeWireNumber(ProfilePacketWire.CONTINUED_WIRE) + gremlin.sizes.sizeBool(self.continued);
        }
        if (self.index != 0) {
            res += gremlin.sizes.sizeWireNumber(ProfilePacketWire.INDEX_WIRE) + gremlin.sizes.sizeU64(self.index);
        }
        return res;
    }
    pub fn encode(self: *const ProfilePacket, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ProfilePacket, target: *gremlin.Writer) void {
        if (self.strings) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(ProfilePacketWire.STRINGS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(ProfilePacketWire.STRINGS_WIRE, 0);
                }
            }
        }
        if (self.mappings) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(ProfilePacketWire.MAPPINGS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(ProfilePacketWire.MAPPINGS_WIRE, 0);
                }
            }
        }
        if (self.frames) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(ProfilePacketWire.FRAMES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(ProfilePacketWire.FRAMES_WIRE, 0);
                }
            }
        }
        if (self.callstacks) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(ProfilePacketWire.CALLSTACKS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(ProfilePacketWire.CALLSTACKS_WIRE, 0);
                }
            }
        }
        if (self.process_dumps) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(ProfilePacketWire.PROCESS_DUMPS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(ProfilePacketWire.PROCESS_DUMPS_WIRE, 0);
                }
            }
        }
        if (self.continued != false) {
            target.appendBool(ProfilePacketWire.CONTINUED_WIRE, self.continued);
        }
        if (self.index != 0) {
            target.appendUint64(ProfilePacketWire.INDEX_WIRE, self.index);
        }
    }
};
pub const ProfilePacketReader = struct {
    buf: gremlin.Reader,
    _strings_offset: ?usize = null,
    _strings_last_offset: ?usize = null,
    _strings_cnt: usize = 0,
    _mappings_offset: ?usize = null,
    _mappings_last_offset: ?usize = null,
    _mappings_cnt: usize = 0,
    _frames_offset: ?usize = null,
    _frames_last_offset: ?usize = null,
    _frames_cnt: usize = 0,
    _callstacks_offset: ?usize = null,
    _callstacks_last_offset: ?usize = null,
    _callstacks_cnt: usize = 0,
    _process_dumps_offset: ?usize = null,
    _process_dumps_last_offset: ?usize = null,
    _process_dumps_cnt: usize = 0,
    _continued: bool = false,
    _index: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!ProfilePacketReader {
        const buf = gremlin.Reader.init(src);
        var res = ProfilePacketReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ProfilePacketWire.STRINGS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._strings_offset == null) {
                        res._strings_offset = offset - result.size;
                    }
                    res._strings_last_offset = offset;
                    res._strings_cnt += 1;
                },
                ProfilePacketWire.MAPPINGS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._mappings_offset == null) {
                        res._mappings_offset = offset - result.size;
                    }
                    res._mappings_last_offset = offset;
                    res._mappings_cnt += 1;
                },
                ProfilePacketWire.FRAMES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._frames_offset == null) {
                        res._frames_offset = offset - result.size;
                    }
                    res._frames_last_offset = offset;
                    res._frames_cnt += 1;
                },
                ProfilePacketWire.CALLSTACKS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._callstacks_offset == null) {
                        res._callstacks_offset = offset - result.size;
                    }
                    res._callstacks_last_offset = offset;
                    res._callstacks_cnt += 1;
                },
                ProfilePacketWire.PROCESS_DUMPS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._process_dumps_offset == null) {
                        res._process_dumps_offset = offset - result.size;
                    }
                    res._process_dumps_last_offset = offset;
                    res._process_dumps_cnt += 1;
                },
                ProfilePacketWire.CONTINUED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._continued = result.value;
                },
                ProfilePacketWire.INDEX_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._index = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn stringsCount(self: *const ProfilePacketReader) usize {
        return self._strings_cnt;
    }
    pub fn stringsNext(self: *ProfilePacketReader) ?profile_common.InternedStringReader {
        if (self._strings_offset == null) return null;
        const current_offset = self._strings_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = profile_common.InternedStringReader.init(result.value) catch return null;
        if (self._strings_last_offset != null and current_offset >= self._strings_last_offset.?) {
            self._strings_offset = null;
            return msg;
        }
        if (self._strings_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._strings_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ProfilePacketWire.STRINGS_WIRE) {
                self._strings_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._strings_offset = null;
        return msg;
    }
    pub fn mappingsCount(self: *const ProfilePacketReader) usize {
        return self._mappings_cnt;
    }
    pub fn mappingsNext(self: *ProfilePacketReader) ?profile_common.MappingReader {
        if (self._mappings_offset == null) return null;
        const current_offset = self._mappings_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = profile_common.MappingReader.init(result.value) catch return null;
        if (self._mappings_last_offset != null and current_offset >= self._mappings_last_offset.?) {
            self._mappings_offset = null;
            return msg;
        }
        if (self._mappings_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._mappings_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ProfilePacketWire.MAPPINGS_WIRE) {
                self._mappings_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._mappings_offset = null;
        return msg;
    }
    pub fn framesCount(self: *const ProfilePacketReader) usize {
        return self._frames_cnt;
    }
    pub fn framesNext(self: *ProfilePacketReader) ?profile_common.FrameReader {
        if (self._frames_offset == null) return null;
        const current_offset = self._frames_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = profile_common.FrameReader.init(result.value) catch return null;
        if (self._frames_last_offset != null and current_offset >= self._frames_last_offset.?) {
            self._frames_offset = null;
            return msg;
        }
        if (self._frames_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._frames_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ProfilePacketWire.FRAMES_WIRE) {
                self._frames_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._frames_offset = null;
        return msg;
    }
    pub fn callstacksCount(self: *const ProfilePacketReader) usize {
        return self._callstacks_cnt;
    }
    pub fn callstacksNext(self: *ProfilePacketReader) ?profile_common.CallstackReader {
        if (self._callstacks_offset == null) return null;
        const current_offset = self._callstacks_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = profile_common.CallstackReader.init(result.value) catch return null;
        if (self._callstacks_last_offset != null and current_offset >= self._callstacks_last_offset.?) {
            self._callstacks_offset = null;
            return msg;
        }
        if (self._callstacks_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._callstacks_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ProfilePacketWire.CALLSTACKS_WIRE) {
                self._callstacks_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._callstacks_offset = null;
        return msg;
    }
    pub fn processDumpsCount(self: *const ProfilePacketReader) usize {
        return self._process_dumps_cnt;
    }
    pub fn processDumpsNext(self: *ProfilePacketReader) ?ProfilePacket.ProcessHeapSamplesReader {
        if (self._process_dumps_offset == null) return null;
        const current_offset = self._process_dumps_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = ProfilePacket.ProcessHeapSamplesReader.init(result.value) catch return null;
        if (self._process_dumps_last_offset != null and current_offset >= self._process_dumps_last_offset.?) {
            self._process_dumps_offset = null;
            return msg;
        }
        if (self._process_dumps_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._process_dumps_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ProfilePacketWire.PROCESS_DUMPS_WIRE) {
                self._process_dumps_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._process_dumps_offset = null;
        return msg;
    }
    pub inline fn getContinued(self: *const ProfilePacketReader) bool {
        return self._continued;
    }
    pub inline fn getIndex(self: *const ProfilePacketReader) u64 {
        return self._index;
    }
};
const StreamingAllocationWire = struct {
    const ADDRESS_WIRE: gremlin.ProtoWireNumber = 1;
    const SIZE_WIRE: gremlin.ProtoWireNumber = 2;
    const SAMPLE_SIZE_WIRE: gremlin.ProtoWireNumber = 3;
    const CLOCK_MONOTONIC_COARSE_TIMESTAMP_WIRE: gremlin.ProtoWireNumber = 4;
    const HEAP_ID_WIRE: gremlin.ProtoWireNumber = 5;
    const SEQUENCE_NUMBER_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const StreamingAllocation = struct {
    // fields
    address: ?[]const u64 = null,
    size: ?[]const u64 = null,
    sample_size: ?[]const u64 = null,
    clock_monotonic_coarse_timestamp: ?[]const u64 = null,
    heap_id: ?[]const u32 = null,
    sequence_number: ?[]const u64 = null,
    pub fn calcProtobufSize(self: *const StreamingAllocation) usize {
        var res: usize = 0;
        if (self.address) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(StreamingAllocationWire.ADDRESS_WIRE) + gremlin.sizes.sizeU64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                res += gremlin.sizes.sizeWireNumber(StreamingAllocationWire.ADDRESS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.size) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(StreamingAllocationWire.SIZE_WIRE) + gremlin.sizes.sizeU64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                res += gremlin.sizes.sizeWireNumber(StreamingAllocationWire.SIZE_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.sample_size) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(StreamingAllocationWire.SAMPLE_SIZE_WIRE) + gremlin.sizes.sizeU64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                res += gremlin.sizes.sizeWireNumber(StreamingAllocationWire.SAMPLE_SIZE_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.clock_monotonic_coarse_timestamp) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(StreamingAllocationWire.CLOCK_MONOTONIC_COARSE_TIMESTAMP_WIRE) + gremlin.sizes.sizeU64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                res += gremlin.sizes.sizeWireNumber(StreamingAllocationWire.CLOCK_MONOTONIC_COARSE_TIMESTAMP_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.heap_id) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(StreamingAllocationWire.HEAP_ID_WIRE) + gremlin.sizes.sizeU32(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU32(v);
                }
                res += gremlin.sizes.sizeWireNumber(StreamingAllocationWire.HEAP_ID_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.sequence_number) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(StreamingAllocationWire.SEQUENCE_NUMBER_WIRE) + gremlin.sizes.sizeU64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                res += gremlin.sizes.sizeWireNumber(StreamingAllocationWire.SEQUENCE_NUMBER_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        return res;
    }
    pub fn encode(self: *const StreamingAllocation, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const StreamingAllocation, target: *gremlin.Writer) void {
        if (self.address) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint64(StreamingAllocationWire.ADDRESS_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                target.appendBytesTag(StreamingAllocationWire.ADDRESS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint64WithoutTag(v);
                }
            }
        }
        if (self.size) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint64(StreamingAllocationWire.SIZE_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                target.appendBytesTag(StreamingAllocationWire.SIZE_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint64WithoutTag(v);
                }
            }
        }
        if (self.sample_size) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint64(StreamingAllocationWire.SAMPLE_SIZE_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                target.appendBytesTag(StreamingAllocationWire.SAMPLE_SIZE_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint64WithoutTag(v);
                }
            }
        }
        if (self.clock_monotonic_coarse_timestamp) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint64(StreamingAllocationWire.CLOCK_MONOTONIC_COARSE_TIMESTAMP_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                target.appendBytesTag(StreamingAllocationWire.CLOCK_MONOTONIC_COARSE_TIMESTAMP_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint64WithoutTag(v);
                }
            }
        }
        if (self.heap_id) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint32(StreamingAllocationWire.HEAP_ID_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU32(v);
                }
                target.appendBytesTag(StreamingAllocationWire.HEAP_ID_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint32WithoutTag(v);
                }
            }
        }
        if (self.sequence_number) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint64(StreamingAllocationWire.SEQUENCE_NUMBER_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                target.appendBytesTag(StreamingAllocationWire.SEQUENCE_NUMBER_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint64WithoutTag(v);
                }
            }
        }
    }
};
pub const StreamingAllocationReader = struct {
    buf: gremlin.Reader,
    _address_offset: ?usize = null,
    _address_last_offset: ?usize = null,
    _address_packed: bool = false,
    _size_offset: ?usize = null,
    _size_last_offset: ?usize = null,
    _size_packed: bool = false,
    _sample_size_offset: ?usize = null,
    _sample_size_last_offset: ?usize = null,
    _sample_size_packed: bool = false,
    _clock_monotonic_coarse_timestamp_offset: ?usize = null,
    _clock_monotonic_coarse_timestamp_last_offset: ?usize = null,
    _clock_monotonic_coarse_timestamp_packed: bool = false,
    _heap_id_offset: ?usize = null,
    _heap_id_last_offset: ?usize = null,
    _heap_id_packed: bool = false,
    _sequence_number_offset: ?usize = null,
    _sequence_number_last_offset: ?usize = null,
    _sequence_number_packed: bool = false,
    pub fn init(src: []const u8) gremlin.Error!StreamingAllocationReader {
        const buf = gremlin.Reader.init(src);
        var res = StreamingAllocationReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                StreamingAllocationWire.ADDRESS_WIRE => {
                    if (res._address_offset == null) {
                        res._address_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._address_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._address_offset = offset + length_result.size;
                        res._address_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._address_last_offset.?;
                    } else {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._address_last_offset = offset;
                    }
                },
                StreamingAllocationWire.SIZE_WIRE => {
                    if (res._size_offset == null) {
                        res._size_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._size_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._size_offset = offset + length_result.size;
                        res._size_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._size_last_offset.?;
                    } else {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._size_last_offset = offset;
                    }
                },
                StreamingAllocationWire.SAMPLE_SIZE_WIRE => {
                    if (res._sample_size_offset == null) {
                        res._sample_size_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._sample_size_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._sample_size_offset = offset + length_result.size;
                        res._sample_size_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._sample_size_last_offset.?;
                    } else {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._sample_size_last_offset = offset;
                    }
                },
                StreamingAllocationWire.CLOCK_MONOTONIC_COARSE_TIMESTAMP_WIRE => {
                    if (res._clock_monotonic_coarse_timestamp_offset == null) {
                        res._clock_monotonic_coarse_timestamp_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._clock_monotonic_coarse_timestamp_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._clock_monotonic_coarse_timestamp_offset = offset + length_result.size;
                        res._clock_monotonic_coarse_timestamp_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._clock_monotonic_coarse_timestamp_last_offset.?;
                    } else {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._clock_monotonic_coarse_timestamp_last_offset = offset;
                    }
                },
                StreamingAllocationWire.HEAP_ID_WIRE => {
                    if (res._heap_id_offset == null) {
                        res._heap_id_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._heap_id_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._heap_id_offset = offset + length_result.size;
                        res._heap_id_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._heap_id_last_offset.?;
                    } else {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._heap_id_last_offset = offset;
                    }
                },
                StreamingAllocationWire.SEQUENCE_NUMBER_WIRE => {
                    if (res._sequence_number_offset == null) {
                        res._sequence_number_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._sequence_number_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._sequence_number_offset = offset + length_result.size;
                        res._sequence_number_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._sequence_number_last_offset.?;
                    } else {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._sequence_number_last_offset = offset;
                    }
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn addressNext(self: *StreamingAllocationReader) gremlin.Error!?u64 {
        if (self._address_offset == null) return null;
        const current_offset = self._address_offset.?;
        if (current_offset >= self._address_last_offset.?) {
            self._address_offset = null;
            return null;
        }
        if (self._address_packed) {
            const value_result = try self.buf.readUInt64(current_offset);
            self._address_offset = current_offset + value_result.size;
            if (self._address_offset.? >= self._address_last_offset.?) {
                self._address_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._address_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == StreamingAllocationWire.ADDRESS_WIRE) {
                    self._address_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._address_offset = null;
            return value_result.value;
        }
    }
    pub fn sizeNext(self: *StreamingAllocationReader) gremlin.Error!?u64 {
        if (self._size_offset == null) return null;
        const current_offset = self._size_offset.?;
        if (current_offset >= self._size_last_offset.?) {
            self._size_offset = null;
            return null;
        }
        if (self._size_packed) {
            const value_result = try self.buf.readUInt64(current_offset);
            self._size_offset = current_offset + value_result.size;
            if (self._size_offset.? >= self._size_last_offset.?) {
                self._size_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._size_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == StreamingAllocationWire.SIZE_WIRE) {
                    self._size_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._size_offset = null;
            return value_result.value;
        }
    }
    pub fn sampleSizeNext(self: *StreamingAllocationReader) gremlin.Error!?u64 {
        if (self._sample_size_offset == null) return null;
        const current_offset = self._sample_size_offset.?;
        if (current_offset >= self._sample_size_last_offset.?) {
            self._sample_size_offset = null;
            return null;
        }
        if (self._sample_size_packed) {
            const value_result = try self.buf.readUInt64(current_offset);
            self._sample_size_offset = current_offset + value_result.size;
            if (self._sample_size_offset.? >= self._sample_size_last_offset.?) {
                self._sample_size_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._sample_size_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == StreamingAllocationWire.SAMPLE_SIZE_WIRE) {
                    self._sample_size_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._sample_size_offset = null;
            return value_result.value;
        }
    }
    pub fn clockMonotonicCoarseTimestampNext(self: *StreamingAllocationReader) gremlin.Error!?u64 {
        if (self._clock_monotonic_coarse_timestamp_offset == null) return null;
        const current_offset = self._clock_monotonic_coarse_timestamp_offset.?;
        if (current_offset >= self._clock_monotonic_coarse_timestamp_last_offset.?) {
            self._clock_monotonic_coarse_timestamp_offset = null;
            return null;
        }
        if (self._clock_monotonic_coarse_timestamp_packed) {
            const value_result = try self.buf.readUInt64(current_offset);
            self._clock_monotonic_coarse_timestamp_offset = current_offset + value_result.size;
            if (self._clock_monotonic_coarse_timestamp_offset.? >= self._clock_monotonic_coarse_timestamp_last_offset.?) {
                self._clock_monotonic_coarse_timestamp_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._clock_monotonic_coarse_timestamp_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == StreamingAllocationWire.CLOCK_MONOTONIC_COARSE_TIMESTAMP_WIRE) {
                    self._clock_monotonic_coarse_timestamp_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._clock_monotonic_coarse_timestamp_offset = null;
            return value_result.value;
        }
    }
    pub fn heapIdNext(self: *StreamingAllocationReader) gremlin.Error!?u32 {
        if (self._heap_id_offset == null) return null;
        const current_offset = self._heap_id_offset.?;
        if (current_offset >= self._heap_id_last_offset.?) {
            self._heap_id_offset = null;
            return null;
        }
        if (self._heap_id_packed) {
            const value_result = try self.buf.readUInt32(current_offset);
            self._heap_id_offset = current_offset + value_result.size;
            if (self._heap_id_offset.? >= self._heap_id_last_offset.?) {
                self._heap_id_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._heap_id_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == StreamingAllocationWire.HEAP_ID_WIRE) {
                    self._heap_id_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._heap_id_offset = null;
            return value_result.value;
        }
    }
    pub fn sequenceNumberNext(self: *StreamingAllocationReader) gremlin.Error!?u64 {
        if (self._sequence_number_offset == null) return null;
        const current_offset = self._sequence_number_offset.?;
        if (current_offset >= self._sequence_number_last_offset.?) {
            self._sequence_number_offset = null;
            return null;
        }
        if (self._sequence_number_packed) {
            const value_result = try self.buf.readUInt64(current_offset);
            self._sequence_number_offset = current_offset + value_result.size;
            if (self._sequence_number_offset.? >= self._sequence_number_last_offset.?) {
                self._sequence_number_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._sequence_number_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == StreamingAllocationWire.SEQUENCE_NUMBER_WIRE) {
                    self._sequence_number_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._sequence_number_offset = null;
            return value_result.value;
        }
    }
};
const StreamingFreeWire = struct {
    const ADDRESS_WIRE: gremlin.ProtoWireNumber = 1;
    const HEAP_ID_WIRE: gremlin.ProtoWireNumber = 2;
    const SEQUENCE_NUMBER_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const StreamingFree = struct {
    // fields
    address: ?[]const u64 = null,
    heap_id: ?[]const u32 = null,
    sequence_number: ?[]const u64 = null,
    pub fn calcProtobufSize(self: *const StreamingFree) usize {
        var res: usize = 0;
        if (self.address) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(StreamingFreeWire.ADDRESS_WIRE) + gremlin.sizes.sizeU64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                res += gremlin.sizes.sizeWireNumber(StreamingFreeWire.ADDRESS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.heap_id) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(StreamingFreeWire.HEAP_ID_WIRE) + gremlin.sizes.sizeU32(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU32(v);
                }
                res += gremlin.sizes.sizeWireNumber(StreamingFreeWire.HEAP_ID_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.sequence_number) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(StreamingFreeWire.SEQUENCE_NUMBER_WIRE) + gremlin.sizes.sizeU64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                res += gremlin.sizes.sizeWireNumber(StreamingFreeWire.SEQUENCE_NUMBER_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        return res;
    }
    pub fn encode(self: *const StreamingFree, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const StreamingFree, target: *gremlin.Writer) void {
        if (self.address) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint64(StreamingFreeWire.ADDRESS_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                target.appendBytesTag(StreamingFreeWire.ADDRESS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint64WithoutTag(v);
                }
            }
        }
        if (self.heap_id) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint32(StreamingFreeWire.HEAP_ID_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU32(v);
                }
                target.appendBytesTag(StreamingFreeWire.HEAP_ID_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint32WithoutTag(v);
                }
            }
        }
        if (self.sequence_number) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint64(StreamingFreeWire.SEQUENCE_NUMBER_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                target.appendBytesTag(StreamingFreeWire.SEQUENCE_NUMBER_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint64WithoutTag(v);
                }
            }
        }
    }
};
pub const StreamingFreeReader = struct {
    buf: gremlin.Reader,
    _address_offset: ?usize = null,
    _address_last_offset: ?usize = null,
    _address_packed: bool = false,
    _heap_id_offset: ?usize = null,
    _heap_id_last_offset: ?usize = null,
    _heap_id_packed: bool = false,
    _sequence_number_offset: ?usize = null,
    _sequence_number_last_offset: ?usize = null,
    _sequence_number_packed: bool = false,
    pub fn init(src: []const u8) gremlin.Error!StreamingFreeReader {
        const buf = gremlin.Reader.init(src);
        var res = StreamingFreeReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                StreamingFreeWire.ADDRESS_WIRE => {
                    if (res._address_offset == null) {
                        res._address_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._address_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._address_offset = offset + length_result.size;
                        res._address_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._address_last_offset.?;
                    } else {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._address_last_offset = offset;
                    }
                },
                StreamingFreeWire.HEAP_ID_WIRE => {
                    if (res._heap_id_offset == null) {
                        res._heap_id_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._heap_id_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._heap_id_offset = offset + length_result.size;
                        res._heap_id_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._heap_id_last_offset.?;
                    } else {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._heap_id_last_offset = offset;
                    }
                },
                StreamingFreeWire.SEQUENCE_NUMBER_WIRE => {
                    if (res._sequence_number_offset == null) {
                        res._sequence_number_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._sequence_number_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._sequence_number_offset = offset + length_result.size;
                        res._sequence_number_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._sequence_number_last_offset.?;
                    } else {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._sequence_number_last_offset = offset;
                    }
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn addressNext(self: *StreamingFreeReader) gremlin.Error!?u64 {
        if (self._address_offset == null) return null;
        const current_offset = self._address_offset.?;
        if (current_offset >= self._address_last_offset.?) {
            self._address_offset = null;
            return null;
        }
        if (self._address_packed) {
            const value_result = try self.buf.readUInt64(current_offset);
            self._address_offset = current_offset + value_result.size;
            if (self._address_offset.? >= self._address_last_offset.?) {
                self._address_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._address_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == StreamingFreeWire.ADDRESS_WIRE) {
                    self._address_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._address_offset = null;
            return value_result.value;
        }
    }
    pub fn heapIdNext(self: *StreamingFreeReader) gremlin.Error!?u32 {
        if (self._heap_id_offset == null) return null;
        const current_offset = self._heap_id_offset.?;
        if (current_offset >= self._heap_id_last_offset.?) {
            self._heap_id_offset = null;
            return null;
        }
        if (self._heap_id_packed) {
            const value_result = try self.buf.readUInt32(current_offset);
            self._heap_id_offset = current_offset + value_result.size;
            if (self._heap_id_offset.? >= self._heap_id_last_offset.?) {
                self._heap_id_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._heap_id_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == StreamingFreeWire.HEAP_ID_WIRE) {
                    self._heap_id_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._heap_id_offset = null;
            return value_result.value;
        }
    }
    pub fn sequenceNumberNext(self: *StreamingFreeReader) gremlin.Error!?u64 {
        if (self._sequence_number_offset == null) return null;
        const current_offset = self._sequence_number_offset.?;
        if (current_offset >= self._sequence_number_last_offset.?) {
            self._sequence_number_offset = null;
            return null;
        }
        if (self._sequence_number_packed) {
            const value_result = try self.buf.readUInt64(current_offset);
            self._sequence_number_offset = current_offset + value_result.size;
            if (self._sequence_number_offset.? >= self._sequence_number_last_offset.?) {
                self._sequence_number_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._sequence_number_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == StreamingFreeWire.SEQUENCE_NUMBER_WIRE) {
                    self._sequence_number_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._sequence_number_offset = null;
            return value_result.value;
        }
    }
};
const StreamingProfilePacketWire = struct {
    const CALLSTACK_IID_WIRE: gremlin.ProtoWireNumber = 1;
    const TIMESTAMP_DELTA_US_WIRE: gremlin.ProtoWireNumber = 2;
    const PROCESS_PRIORITY_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const StreamingProfilePacket = struct {
    // fields
    callstack_iid: ?[]const u64 = null,
    timestamp_delta_us: ?[]const i64 = null,
    process_priority: i32 = 0,
    pub fn calcProtobufSize(self: *const StreamingProfilePacket) usize {
        var res: usize = 0;
        if (self.callstack_iid) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(StreamingProfilePacketWire.CALLSTACK_IID_WIRE) + gremlin.sizes.sizeU64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                res += gremlin.sizes.sizeWireNumber(StreamingProfilePacketWire.CALLSTACK_IID_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.timestamp_delta_us) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(StreamingProfilePacketWire.TIMESTAMP_DELTA_US_WIRE) + gremlin.sizes.sizeI64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI64(v);
                }
                res += gremlin.sizes.sizeWireNumber(StreamingProfilePacketWire.TIMESTAMP_DELTA_US_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.process_priority != 0) {
            res += gremlin.sizes.sizeWireNumber(StreamingProfilePacketWire.PROCESS_PRIORITY_WIRE) + gremlin.sizes.sizeI32(self.process_priority);
        }
        return res;
    }
    pub fn encode(self: *const StreamingProfilePacket, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const StreamingProfilePacket, target: *gremlin.Writer) void {
        if (self.callstack_iid) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint64(StreamingProfilePacketWire.CALLSTACK_IID_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                target.appendBytesTag(StreamingProfilePacketWire.CALLSTACK_IID_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint64WithoutTag(v);
                }
            }
        }
        if (self.timestamp_delta_us) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt64(StreamingProfilePacketWire.TIMESTAMP_DELTA_US_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI64(v);
                }
                target.appendBytesTag(StreamingProfilePacketWire.TIMESTAMP_DELTA_US_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt64WithoutTag(v);
                }
            }
        }
        if (self.process_priority != 0) {
            target.appendInt32(StreamingProfilePacketWire.PROCESS_PRIORITY_WIRE, self.process_priority);
        }
    }
};
pub const StreamingProfilePacketReader = struct {
    buf: gremlin.Reader,
    _callstack_iid_offset: ?usize = null,
    _callstack_iid_last_offset: ?usize = null,
    _callstack_iid_packed: bool = false,
    _timestamp_delta_us_offset: ?usize = null,
    _timestamp_delta_us_last_offset: ?usize = null,
    _timestamp_delta_us_packed: bool = false,
    _process_priority: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!StreamingProfilePacketReader {
        const buf = gremlin.Reader.init(src);
        var res = StreamingProfilePacketReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                StreamingProfilePacketWire.CALLSTACK_IID_WIRE => {
                    if (res._callstack_iid_offset == null) {
                        res._callstack_iid_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._callstack_iid_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._callstack_iid_offset = offset + length_result.size;
                        res._callstack_iid_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._callstack_iid_last_offset.?;
                    } else {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._callstack_iid_last_offset = offset;
                    }
                },
                StreamingProfilePacketWire.TIMESTAMP_DELTA_US_WIRE => {
                    if (res._timestamp_delta_us_offset == null) {
                        res._timestamp_delta_us_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._timestamp_delta_us_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._timestamp_delta_us_offset = offset + length_result.size;
                        res._timestamp_delta_us_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._timestamp_delta_us_last_offset.?;
                    } else {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._timestamp_delta_us_last_offset = offset;
                    }
                },
                StreamingProfilePacketWire.PROCESS_PRIORITY_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._process_priority = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn callstackIidNext(self: *StreamingProfilePacketReader) gremlin.Error!?u64 {
        if (self._callstack_iid_offset == null) return null;
        const current_offset = self._callstack_iid_offset.?;
        if (current_offset >= self._callstack_iid_last_offset.?) {
            self._callstack_iid_offset = null;
            return null;
        }
        if (self._callstack_iid_packed) {
            const value_result = try self.buf.readUInt64(current_offset);
            self._callstack_iid_offset = current_offset + value_result.size;
            if (self._callstack_iid_offset.? >= self._callstack_iid_last_offset.?) {
                self._callstack_iid_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._callstack_iid_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == StreamingProfilePacketWire.CALLSTACK_IID_WIRE) {
                    self._callstack_iid_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._callstack_iid_offset = null;
            return value_result.value;
        }
    }
    pub fn timestampDeltaUsNext(self: *StreamingProfilePacketReader) gremlin.Error!?i64 {
        if (self._timestamp_delta_us_offset == null) return null;
        const current_offset = self._timestamp_delta_us_offset.?;
        if (current_offset >= self._timestamp_delta_us_last_offset.?) {
            self._timestamp_delta_us_offset = null;
            return null;
        }
        if (self._timestamp_delta_us_packed) {
            const value_result = try self.buf.readInt64(current_offset);
            self._timestamp_delta_us_offset = current_offset + value_result.size;
            if (self._timestamp_delta_us_offset.? >= self._timestamp_delta_us_last_offset.?) {
                self._timestamp_delta_us_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._timestamp_delta_us_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == StreamingProfilePacketWire.TIMESTAMP_DELTA_US_WIRE) {
                    self._timestamp_delta_us_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._timestamp_delta_us_offset = null;
            return value_result.value;
        }
    }
    pub inline fn getProcessPriority(self: *const StreamingProfilePacketReader) i32 {
        return self._process_priority;
    }
};
pub const Profiling = struct {
    // nested enums
    pub const CpuMode = enum(i32) {
        MODE_UNKNOWN = 0,
        MODE_KERNEL = 1,
        MODE_USER = 2,
        MODE_HYPERVISOR = 3,
        MODE_GUEST_KERNEL = 4,
        MODE_GUEST_USER = 5,
    };
    pub const StackUnwindError = enum(i32) {
        UNWIND_ERROR_UNKNOWN = 0,
        UNWIND_ERROR_NONE = 1,
        UNWIND_ERROR_MEMORY_INVALID = 2,
        UNWIND_ERROR_UNWIND_INFO = 3,
        UNWIND_ERROR_UNSUPPORTED = 4,
        UNWIND_ERROR_INVALID_MAP = 5,
        UNWIND_ERROR_MAX_FRAMES_EXCEEDED = 6,
        UNWIND_ERROR_REPEATED_FRAME = 7,
        UNWIND_ERROR_INVALID_ELF = 8,
        UNWIND_ERROR_SYSTEM_CALL = 9,
        UNWIND_ERROR_THREAD_TIMEOUT = 10,
        UNWIND_ERROR_THREAD_DOES_NOT_EXIST = 11,
        UNWIND_ERROR_BAD_ARCH = 12,
        UNWIND_ERROR_MAPS_PARSE = 13,
        UNWIND_ERROR_INVALID_PARAMETER = 14,
        UNWIND_ERROR_PTRACE_CALL = 15,
    };
    pub fn calcProtobufSize(_: *const Profiling) usize {
        return 0;
    }
    pub fn encode(self: *const Profiling, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(_: *const Profiling, _: *gremlin.Writer) void {}
};
pub const ProfilingReader = struct {
    buf: gremlin.Reader,
    pub fn init(src: []const u8) gremlin.Error!ProfilingReader {
        const buf = gremlin.Reader.init(src);
        return ProfilingReader{ .buf = buf };
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
};
const PerfSampleWire = struct {
    const CPU_WIRE: gremlin.ProtoWireNumber = 1;
    const PID_WIRE: gremlin.ProtoWireNumber = 2;
    const TID_WIRE: gremlin.ProtoWireNumber = 3;
    const CPU_MODE_WIRE: gremlin.ProtoWireNumber = 5;
    const TIMEBASE_COUNT_WIRE: gremlin.ProtoWireNumber = 6;
    const FOLLOWER_COUNTS_WIRE: gremlin.ProtoWireNumber = 7;
    const CALLSTACK_IID_WIRE: gremlin.ProtoWireNumber = 4;
    const KERNEL_RECORDS_LOST_WIRE: gremlin.ProtoWireNumber = 17;
    const PRODUCER_EVENT_WIRE: gremlin.ProtoWireNumber = 19;
    const UNWIND_ERROR_WIRE: gremlin.ProtoWireNumber = 16;
    const SAMPLE_SKIPPED_REASON_WIRE: gremlin.ProtoWireNumber = 18;
};
pub const PerfSample = struct {
    // nested enums
    pub const SampleSkipReason = enum(i32) {
        PROFILER_SKIP_UNKNOWN = 0,
        PROFILER_SKIP_READ_STAGE = 1,
        PROFILER_SKIP_UNWIND_STAGE = 2,
        PROFILER_SKIP_UNWIND_ENQUEUE = 3,
        PROFILER_SKIP_NOT_IN_SCOPE = 4,
    };
    // nested structs
    const ProducerEventWire = struct {
        const SOURCE_STOP_REASON_WIRE: gremlin.ProtoWireNumber = 1;
    };
    pub const ProducerEvent = struct {
        // nested enums
        pub const DataSourceStopReason = enum(i32) {
            PROFILER_STOP_UNKNOWN = 0,
            PROFILER_STOP_GUARDRAIL = 1,
        };
        // fields
        source_stop_reason: PerfSample.ProducerEvent.DataSourceStopReason = @enumFromInt(0),
        pub fn calcProtobufSize(self: *const PerfSample.ProducerEvent) usize {
            var res: usize = 0;
            if (@intFromEnum(self.source_stop_reason) != 0) {
                res += gremlin.sizes.sizeWireNumber(PerfSample.ProducerEventWire.SOURCE_STOP_REASON_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.source_stop_reason));
            }
            return res;
        }
        pub fn encode(self: *const PerfSample.ProducerEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const PerfSample.ProducerEvent, target: *gremlin.Writer) void {
            if (@intFromEnum(self.source_stop_reason) != 0) {
                target.appendInt32(PerfSample.ProducerEventWire.SOURCE_STOP_REASON_WIRE, @intFromEnum(self.source_stop_reason));
            }
        }
    };
    pub const ProducerEventReader = struct {
        buf: gremlin.Reader,
        _source_stop_reason: PerfSample.ProducerEvent.DataSourceStopReason = @enumFromInt(0),
        pub fn init(src: []const u8) gremlin.Error!PerfSample.ProducerEventReader {
            const buf = gremlin.Reader.init(src);
            var res = PerfSample.ProducerEventReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    PerfSample.ProducerEventWire.SOURCE_STOP_REASON_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._source_stop_reason = @enumFromInt(result.value);
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getSourceStopReason(self: *const PerfSample.ProducerEventReader) PerfSample.ProducerEvent.DataSourceStopReason {
            return self._source_stop_reason;
        }
    };
    // fields
    cpu: u32 = 0,
    pid: u32 = 0,
    tid: u32 = 0,
    cpu_mode: Profiling.CpuMode = @enumFromInt(0),
    timebase_count: u64 = 0,
    follower_counts: ?[]const u64 = null,
    callstack_iid: u64 = 0,
    kernel_records_lost: u64 = 0,
    producer_event: ?PerfSample.ProducerEvent = null,
    unwind_error: Profiling.StackUnwindError = @enumFromInt(0),
    sample_skipped_reason: PerfSample.SampleSkipReason = @enumFromInt(0),
    pub fn calcProtobufSize(self: *const PerfSample) usize {
        var res: usize = 0;
        if (self.cpu != 0) {
            res += gremlin.sizes.sizeWireNumber(PerfSampleWire.CPU_WIRE) + gremlin.sizes.sizeU32(self.cpu);
        }
        if (self.pid != 0) {
            res += gremlin.sizes.sizeWireNumber(PerfSampleWire.PID_WIRE) + gremlin.sizes.sizeU32(self.pid);
        }
        if (self.tid != 0) {
            res += gremlin.sizes.sizeWireNumber(PerfSampleWire.TID_WIRE) + gremlin.sizes.sizeU32(self.tid);
        }
        if (@intFromEnum(self.cpu_mode) != 0) {
            res += gremlin.sizes.sizeWireNumber(PerfSampleWire.CPU_MODE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.cpu_mode));
        }
        if (self.timebase_count != 0) {
            res += gremlin.sizes.sizeWireNumber(PerfSampleWire.TIMEBASE_COUNT_WIRE) + gremlin.sizes.sizeU64(self.timebase_count);
        }
        if (self.follower_counts) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(PerfSampleWire.FOLLOWER_COUNTS_WIRE) + gremlin.sizes.sizeU64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                res += gremlin.sizes.sizeWireNumber(PerfSampleWire.FOLLOWER_COUNTS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.callstack_iid != 0) {
            res += gremlin.sizes.sizeWireNumber(PerfSampleWire.CALLSTACK_IID_WIRE) + gremlin.sizes.sizeU64(self.callstack_iid);
        }
        if (self.kernel_records_lost != 0) {
            res += gremlin.sizes.sizeWireNumber(PerfSampleWire.KERNEL_RECORDS_LOST_WIRE) + gremlin.sizes.sizeU64(self.kernel_records_lost);
        }
        if (self.producer_event) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(PerfSampleWire.PRODUCER_EVENT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (@intFromEnum(self.unwind_error) != 0) {
            res += gremlin.sizes.sizeWireNumber(PerfSampleWire.UNWIND_ERROR_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.unwind_error));
        }
        if (@intFromEnum(self.sample_skipped_reason) != 0) {
            res += gremlin.sizes.sizeWireNumber(PerfSampleWire.SAMPLE_SKIPPED_REASON_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.sample_skipped_reason));
        }
        return res;
    }
    pub fn encode(self: *const PerfSample, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const PerfSample, target: *gremlin.Writer) void {
        if (self.cpu != 0) {
            target.appendUint32(PerfSampleWire.CPU_WIRE, self.cpu);
        }
        if (self.pid != 0) {
            target.appendUint32(PerfSampleWire.PID_WIRE, self.pid);
        }
        if (self.tid != 0) {
            target.appendUint32(PerfSampleWire.TID_WIRE, self.tid);
        }
        if (@intFromEnum(self.cpu_mode) != 0) {
            target.appendInt32(PerfSampleWire.CPU_MODE_WIRE, @intFromEnum(self.cpu_mode));
        }
        if (self.timebase_count != 0) {
            target.appendUint64(PerfSampleWire.TIMEBASE_COUNT_WIRE, self.timebase_count);
        }
        if (self.follower_counts) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint64(PerfSampleWire.FOLLOWER_COUNTS_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                target.appendBytesTag(PerfSampleWire.FOLLOWER_COUNTS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint64WithoutTag(v);
                }
            }
        }
        if (self.callstack_iid != 0) {
            target.appendUint64(PerfSampleWire.CALLSTACK_IID_WIRE, self.callstack_iid);
        }
        if (self.kernel_records_lost != 0) {
            target.appendUint64(PerfSampleWire.KERNEL_RECORDS_LOST_WIRE, self.kernel_records_lost);
        }
        if (self.producer_event) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(PerfSampleWire.PRODUCER_EVENT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (@intFromEnum(self.unwind_error) != 0) {
            target.appendInt32(PerfSampleWire.UNWIND_ERROR_WIRE, @intFromEnum(self.unwind_error));
        }
        if (@intFromEnum(self.sample_skipped_reason) != 0) {
            target.appendInt32(PerfSampleWire.SAMPLE_SKIPPED_REASON_WIRE, @intFromEnum(self.sample_skipped_reason));
        }
    }
};
pub const PerfSampleReader = struct {
    buf: gremlin.Reader,
    _cpu: u32 = 0,
    _pid: u32 = 0,
    _tid: u32 = 0,
    _cpu_mode: Profiling.CpuMode = @enumFromInt(0),
    _timebase_count: u64 = 0,
    _follower_counts_offset: ?usize = null,
    _follower_counts_last_offset: ?usize = null,
    _follower_counts_packed: bool = false,
    _callstack_iid: u64 = 0,
    _kernel_records_lost: u64 = 0,
    _producer_event_buf: ?[]const u8 = null,
    _unwind_error: Profiling.StackUnwindError = @enumFromInt(0),
    _sample_skipped_reason: PerfSample.SampleSkipReason = @enumFromInt(0),
    pub fn init(src: []const u8) gremlin.Error!PerfSampleReader {
        const buf = gremlin.Reader.init(src);
        var res = PerfSampleReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                PerfSampleWire.CPU_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._cpu = result.value;
                },
                PerfSampleWire.PID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._pid = result.value;
                },
                PerfSampleWire.TID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._tid = result.value;
                },
                PerfSampleWire.CPU_MODE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._cpu_mode = @enumFromInt(result.value);
                },
                PerfSampleWire.TIMEBASE_COUNT_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._timebase_count = result.value;
                },
                PerfSampleWire.FOLLOWER_COUNTS_WIRE => {
                    if (res._follower_counts_offset == null) {
                        res._follower_counts_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._follower_counts_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._follower_counts_offset = offset + length_result.size;
                        res._follower_counts_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._follower_counts_last_offset.?;
                    } else {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._follower_counts_last_offset = offset;
                    }
                },
                PerfSampleWire.CALLSTACK_IID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._callstack_iid = result.value;
                },
                PerfSampleWire.KERNEL_RECORDS_LOST_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._kernel_records_lost = result.value;
                },
                PerfSampleWire.PRODUCER_EVENT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._producer_event_buf = result.value;
                },
                PerfSampleWire.UNWIND_ERROR_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._unwind_error = @enumFromInt(result.value);
                },
                PerfSampleWire.SAMPLE_SKIPPED_REASON_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._sample_skipped_reason = @enumFromInt(result.value);
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getCpu(self: *const PerfSampleReader) u32 {
        return self._cpu;
    }
    pub inline fn getPid(self: *const PerfSampleReader) u32 {
        return self._pid;
    }
    pub inline fn getTid(self: *const PerfSampleReader) u32 {
        return self._tid;
    }
    pub inline fn getCpuMode(self: *const PerfSampleReader) Profiling.CpuMode {
        return self._cpu_mode;
    }
    pub inline fn getTimebaseCount(self: *const PerfSampleReader) u64 {
        return self._timebase_count;
    }
    pub fn followerCountsNext(self: *PerfSampleReader) gremlin.Error!?u64 {
        if (self._follower_counts_offset == null) return null;
        const current_offset = self._follower_counts_offset.?;
        if (current_offset >= self._follower_counts_last_offset.?) {
            self._follower_counts_offset = null;
            return null;
        }
        if (self._follower_counts_packed) {
            const value_result = try self.buf.readUInt64(current_offset);
            self._follower_counts_offset = current_offset + value_result.size;
            if (self._follower_counts_offset.? >= self._follower_counts_last_offset.?) {
                self._follower_counts_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._follower_counts_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == PerfSampleWire.FOLLOWER_COUNTS_WIRE) {
                    self._follower_counts_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._follower_counts_offset = null;
            return value_result.value;
        }
    }
    pub inline fn getCallstackIid(self: *const PerfSampleReader) u64 {
        return self._callstack_iid;
    }
    pub inline fn getKernelRecordsLost(self: *const PerfSampleReader) u64 {
        return self._kernel_records_lost;
    }
    pub fn getProducerEvent(self: *const PerfSampleReader) gremlin.Error!PerfSample.ProducerEventReader {
        if (self._producer_event_buf) |buf| {
            return try PerfSample.ProducerEventReader.init(buf);
        }
        return try PerfSample.ProducerEventReader.init(&[_]u8{});
    }
    pub inline fn getUnwindError(self: *const PerfSampleReader) Profiling.StackUnwindError {
        return self._unwind_error;
    }
    pub inline fn getSampleSkippedReason(self: *const PerfSampleReader) PerfSample.SampleSkipReason {
        return self._sample_skipped_reason;
    }
};
const PerfSampleDefaultsWire = struct {
    const TIMEBASE_WIRE: gremlin.ProtoWireNumber = 1;
    const FOLLOWERS_WIRE: gremlin.ProtoWireNumber = 4;
    const PROCESS_SHARD_COUNT_WIRE: gremlin.ProtoWireNumber = 2;
    const CHOSEN_PROCESS_SHARD_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const PerfSampleDefaults = struct {
    // fields
    timebase: ?perf_events.PerfEvents.Timebase = null,
    followers: ?[]const ?perf_events.FollowerEvent = null,
    process_shard_count: u32 = 0,
    chosen_process_shard: u32 = 0,
    pub fn calcProtobufSize(self: *const PerfSampleDefaults) usize {
        var res: usize = 0;
        if (self.timebase) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(PerfSampleDefaultsWire.TIMEBASE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.followers) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(PerfSampleDefaultsWire.FOLLOWERS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.process_shard_count != 0) {
            res += gremlin.sizes.sizeWireNumber(PerfSampleDefaultsWire.PROCESS_SHARD_COUNT_WIRE) + gremlin.sizes.sizeU32(self.process_shard_count);
        }
        if (self.chosen_process_shard != 0) {
            res += gremlin.sizes.sizeWireNumber(PerfSampleDefaultsWire.CHOSEN_PROCESS_SHARD_WIRE) + gremlin.sizes.sizeU32(self.chosen_process_shard);
        }
        return res;
    }
    pub fn encode(self: *const PerfSampleDefaults, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const PerfSampleDefaults, target: *gremlin.Writer) void {
        if (self.timebase) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(PerfSampleDefaultsWire.TIMEBASE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.followers) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(PerfSampleDefaultsWire.FOLLOWERS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(PerfSampleDefaultsWire.FOLLOWERS_WIRE, 0);
                }
            }
        }
        if (self.process_shard_count != 0) {
            target.appendUint32(PerfSampleDefaultsWire.PROCESS_SHARD_COUNT_WIRE, self.process_shard_count);
        }
        if (self.chosen_process_shard != 0) {
            target.appendUint32(PerfSampleDefaultsWire.CHOSEN_PROCESS_SHARD_WIRE, self.chosen_process_shard);
        }
    }
};
pub const PerfSampleDefaultsReader = struct {
    buf: gremlin.Reader,
    _timebase_buf: ?[]const u8 = null,
    _followers_offset: ?usize = null,
    _followers_last_offset: ?usize = null,
    _followers_cnt: usize = 0,
    _process_shard_count: u32 = 0,
    _chosen_process_shard: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!PerfSampleDefaultsReader {
        const buf = gremlin.Reader.init(src);
        var res = PerfSampleDefaultsReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                PerfSampleDefaultsWire.TIMEBASE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._timebase_buf = result.value;
                },
                PerfSampleDefaultsWire.FOLLOWERS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._followers_offset == null) {
                        res._followers_offset = offset - result.size;
                    }
                    res._followers_last_offset = offset;
                    res._followers_cnt += 1;
                },
                PerfSampleDefaultsWire.PROCESS_SHARD_COUNT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._process_shard_count = result.value;
                },
                PerfSampleDefaultsWire.CHOSEN_PROCESS_SHARD_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._chosen_process_shard = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getTimebase(self: *const PerfSampleDefaultsReader) gremlin.Error!perf_events.PerfEvents.TimebaseReader {
        if (self._timebase_buf) |buf| {
            return try perf_events.PerfEvents.TimebaseReader.init(buf);
        }
        return try perf_events.PerfEvents.TimebaseReader.init(&[_]u8{});
    }
    pub fn followersCount(self: *const PerfSampleDefaultsReader) usize {
        return self._followers_cnt;
    }
    pub fn followersNext(self: *PerfSampleDefaultsReader) ?perf_events.FollowerEventReader {
        if (self._followers_offset == null) return null;
        const current_offset = self._followers_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = perf_events.FollowerEventReader.init(result.value) catch return null;
        if (self._followers_last_offset != null and current_offset >= self._followers_last_offset.?) {
            self._followers_offset = null;
            return msg;
        }
        if (self._followers_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._followers_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == PerfSampleDefaultsWire.FOLLOWERS_WIRE) {
                self._followers_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._followers_offset = null;
        return msg;
    }
    pub inline fn getProcessShardCount(self: *const PerfSampleDefaultsReader) u32 {
        return self._process_shard_count;
    }
    pub inline fn getChosenProcessShard(self: *const PerfSampleDefaultsReader) u32 {
        return self._chosen_process_shard;
    }
};
