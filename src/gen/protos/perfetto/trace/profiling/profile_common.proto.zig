// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const InternedStringWire = struct {
    const IID_WIRE: gremlin.ProtoWireNumber = 1;
    const STR_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const InternedString = struct {
    // fields
    iid: u64 = 0,
    str: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const InternedString) usize {
        var res: usize = 0;
        if (self.iid != 0) {
            res += gremlin.sizes.sizeWireNumber(InternedStringWire.IID_WIRE) + gremlin.sizes.sizeU64(self.iid);
        }
        if (self.str) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(InternedStringWire.STR_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const InternedString, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const InternedString, target: *gremlin.Writer) void {
        if (self.iid != 0) {
            target.appendUint64(InternedStringWire.IID_WIRE, self.iid);
        }
        if (self.str) |v| {
            if (v.len > 0) {
                target.appendBytes(InternedStringWire.STR_WIRE, v);
            }
        }
    }
};
pub const InternedStringReader = struct {
    buf: gremlin.Reader,
    _iid: u64 = 0,
    _str: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!InternedStringReader {
        const buf = gremlin.Reader.init(src);
        var res = InternedStringReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                InternedStringWire.IID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._iid = result.value;
                },
                InternedStringWire.STR_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._str = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getIid(self: *const InternedStringReader) u64 {
        return self._iid;
    }
    pub inline fn getStr(self: *const InternedStringReader) []const u8 {
        return self._str orelse &[_]u8{};
    }
};
const LineWire = struct {
    const FUNCTION_NAME_WIRE: gremlin.ProtoWireNumber = 1;
    const SOURCE_FILE_NAME_WIRE: gremlin.ProtoWireNumber = 2;
    const LINE_NUMBER_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const Line = struct {
    // fields
    function_name: ?[]const u8 = null,
    source_file_name: ?[]const u8 = null,
    line_number: u32 = 0,
    pub fn calcProtobufSize(self: *const Line) usize {
        var res: usize = 0;
        if (self.function_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(LineWire.FUNCTION_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.source_file_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(LineWire.SOURCE_FILE_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.line_number != 0) {
            res += gremlin.sizes.sizeWireNumber(LineWire.LINE_NUMBER_WIRE) + gremlin.sizes.sizeU32(self.line_number);
        }
        return res;
    }
    pub fn encode(self: *const Line, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Line, target: *gremlin.Writer) void {
        if (self.function_name) |v| {
            if (v.len > 0) {
                target.appendBytes(LineWire.FUNCTION_NAME_WIRE, v);
            }
        }
        if (self.source_file_name) |v| {
            if (v.len > 0) {
                target.appendBytes(LineWire.SOURCE_FILE_NAME_WIRE, v);
            }
        }
        if (self.line_number != 0) {
            target.appendUint32(LineWire.LINE_NUMBER_WIRE, self.line_number);
        }
    }
};
pub const LineReader = struct {
    buf: gremlin.Reader,
    _function_name: ?[]const u8 = null,
    _source_file_name: ?[]const u8 = null,
    _line_number: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!LineReader {
        const buf = gremlin.Reader.init(src);
        var res = LineReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                LineWire.FUNCTION_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._function_name = result.value;
                },
                LineWire.SOURCE_FILE_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._source_file_name = result.value;
                },
                LineWire.LINE_NUMBER_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._line_number = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getFunctionName(self: *const LineReader) []const u8 {
        return self._function_name orelse &[_]u8{};
    }
    pub inline fn getSourceFileName(self: *const LineReader) []const u8 {
        return self._source_file_name orelse &[_]u8{};
    }
    pub inline fn getLineNumber(self: *const LineReader) u32 {
        return self._line_number;
    }
};
const AddressSymbolsWire = struct {
    const ADDRESS_WIRE: gremlin.ProtoWireNumber = 1;
    const LINES_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const AddressSymbols = struct {
    // fields
    address: u64 = 0,
    lines: ?[]const ?Line = null,
    pub fn calcProtobufSize(self: *const AddressSymbols) usize {
        var res: usize = 0;
        if (self.address != 0) {
            res += gremlin.sizes.sizeWireNumber(AddressSymbolsWire.ADDRESS_WIRE) + gremlin.sizes.sizeU64(self.address);
        }
        if (self.lines) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AddressSymbolsWire.LINES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AddressSymbols, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AddressSymbols, target: *gremlin.Writer) void {
        if (self.address != 0) {
            target.appendUint64(AddressSymbolsWire.ADDRESS_WIRE, self.address);
        }
        if (self.lines) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AddressSymbolsWire.LINES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AddressSymbolsWire.LINES_WIRE, 0);
                }
            }
        }
    }
};
pub const AddressSymbolsReader = struct {
    buf: gremlin.Reader,
    _address: u64 = 0,
    _lines_offset: ?usize = null,
    _lines_last_offset: ?usize = null,
    _lines_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AddressSymbolsReader {
        const buf = gremlin.Reader.init(src);
        var res = AddressSymbolsReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AddressSymbolsWire.ADDRESS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._address = result.value;
                },
                AddressSymbolsWire.LINES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._lines_offset == null) {
                        res._lines_offset = offset - result.size;
                    }
                    res._lines_last_offset = offset;
                    res._lines_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getAddress(self: *const AddressSymbolsReader) u64 {
        return self._address;
    }
    pub fn linesCount(self: *const AddressSymbolsReader) usize {
        return self._lines_cnt;
    }
    pub fn linesNext(self: *AddressSymbolsReader) ?LineReader {
        if (self._lines_offset == null) return null;
        const current_offset = self._lines_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = LineReader.init(result.value) catch return null;
        if (self._lines_last_offset != null and current_offset >= self._lines_last_offset.?) {
            self._lines_offset = null;
            return msg;
        }
        if (self._lines_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._lines_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AddressSymbolsWire.LINES_WIRE) {
                self._lines_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._lines_offset = null;
        return msg;
    }
};
const ModuleSymbolsWire = struct {
    const PATH_WIRE: gremlin.ProtoWireNumber = 1;
    const BUILD_ID_WIRE: gremlin.ProtoWireNumber = 2;
    const ADDRESS_SYMBOLS_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const ModuleSymbols = struct {
    // fields
    path: ?[]const u8 = null,
    build_id: ?[]const u8 = null,
    address_symbols: ?[]const ?AddressSymbols = null,
    pub fn calcProtobufSize(self: *const ModuleSymbols) usize {
        var res: usize = 0;
        if (self.path) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(ModuleSymbolsWire.PATH_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.build_id) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(ModuleSymbolsWire.BUILD_ID_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.address_symbols) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ModuleSymbolsWire.ADDRESS_SYMBOLS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const ModuleSymbols, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ModuleSymbols, target: *gremlin.Writer) void {
        if (self.path) |v| {
            if (v.len > 0) {
                target.appendBytes(ModuleSymbolsWire.PATH_WIRE, v);
            }
        }
        if (self.build_id) |v| {
            if (v.len > 0) {
                target.appendBytes(ModuleSymbolsWire.BUILD_ID_WIRE, v);
            }
        }
        if (self.address_symbols) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(ModuleSymbolsWire.ADDRESS_SYMBOLS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(ModuleSymbolsWire.ADDRESS_SYMBOLS_WIRE, 0);
                }
            }
        }
    }
};
pub const ModuleSymbolsReader = struct {
    buf: gremlin.Reader,
    _path: ?[]const u8 = null,
    _build_id: ?[]const u8 = null,
    _address_symbols_offset: ?usize = null,
    _address_symbols_last_offset: ?usize = null,
    _address_symbols_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!ModuleSymbolsReader {
        const buf = gremlin.Reader.init(src);
        var res = ModuleSymbolsReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ModuleSymbolsWire.PATH_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._path = result.value;
                },
                ModuleSymbolsWire.BUILD_ID_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._build_id = result.value;
                },
                ModuleSymbolsWire.ADDRESS_SYMBOLS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._address_symbols_offset == null) {
                        res._address_symbols_offset = offset - result.size;
                    }
                    res._address_symbols_last_offset = offset;
                    res._address_symbols_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getPath(self: *const ModuleSymbolsReader) []const u8 {
        return self._path orelse &[_]u8{};
    }
    pub inline fn getBuildId(self: *const ModuleSymbolsReader) []const u8 {
        return self._build_id orelse &[_]u8{};
    }
    pub fn addressSymbolsCount(self: *const ModuleSymbolsReader) usize {
        return self._address_symbols_cnt;
    }
    pub fn addressSymbolsNext(self: *ModuleSymbolsReader) ?AddressSymbolsReader {
        if (self._address_symbols_offset == null) return null;
        const current_offset = self._address_symbols_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AddressSymbolsReader.init(result.value) catch return null;
        if (self._address_symbols_last_offset != null and current_offset >= self._address_symbols_last_offset.?) {
            self._address_symbols_offset = null;
            return msg;
        }
        if (self._address_symbols_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._address_symbols_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ModuleSymbolsWire.ADDRESS_SYMBOLS_WIRE) {
                self._address_symbols_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._address_symbols_offset = null;
        return msg;
    }
};
const MappingWire = struct {
    const IID_WIRE: gremlin.ProtoWireNumber = 1;
    const BUILD_ID_WIRE: gremlin.ProtoWireNumber = 2;
    const EXACT_OFFSET_WIRE: gremlin.ProtoWireNumber = 8;
    const START_OFFSET_WIRE: gremlin.ProtoWireNumber = 3;
    const START_WIRE: gremlin.ProtoWireNumber = 4;
    const END_WIRE: gremlin.ProtoWireNumber = 5;
    const LOAD_BIAS_WIRE: gremlin.ProtoWireNumber = 6;
    const PATH_STRING_IDS_WIRE: gremlin.ProtoWireNumber = 7;
};
pub const Mapping = struct {
    // fields
    iid: u64 = 0,
    build_id: u64 = 0,
    exact_offset: u64 = 0,
    start_offset: u64 = 0,
    start: u64 = 0,
    end: u64 = 0,
    load_bias: u64 = 0,
    path_string_ids: ?[]const u64 = null,
    pub fn calcProtobufSize(self: *const Mapping) usize {
        var res: usize = 0;
        if (self.iid != 0) {
            res += gremlin.sizes.sizeWireNumber(MappingWire.IID_WIRE) + gremlin.sizes.sizeU64(self.iid);
        }
        if (self.build_id != 0) {
            res += gremlin.sizes.sizeWireNumber(MappingWire.BUILD_ID_WIRE) + gremlin.sizes.sizeU64(self.build_id);
        }
        if (self.exact_offset != 0) {
            res += gremlin.sizes.sizeWireNumber(MappingWire.EXACT_OFFSET_WIRE) + gremlin.sizes.sizeU64(self.exact_offset);
        }
        if (self.start_offset != 0) {
            res += gremlin.sizes.sizeWireNumber(MappingWire.START_OFFSET_WIRE) + gremlin.sizes.sizeU64(self.start_offset);
        }
        if (self.start != 0) {
            res += gremlin.sizes.sizeWireNumber(MappingWire.START_WIRE) + gremlin.sizes.sizeU64(self.start);
        }
        if (self.end != 0) {
            res += gremlin.sizes.sizeWireNumber(MappingWire.END_WIRE) + gremlin.sizes.sizeU64(self.end);
        }
        if (self.load_bias != 0) {
            res += gremlin.sizes.sizeWireNumber(MappingWire.LOAD_BIAS_WIRE) + gremlin.sizes.sizeU64(self.load_bias);
        }
        if (self.path_string_ids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(MappingWire.PATH_STRING_IDS_WIRE) + gremlin.sizes.sizeU64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                res += gremlin.sizes.sizeWireNumber(MappingWire.PATH_STRING_IDS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        return res;
    }
    pub fn encode(self: *const Mapping, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Mapping, target: *gremlin.Writer) void {
        if (self.iid != 0) {
            target.appendUint64(MappingWire.IID_WIRE, self.iid);
        }
        if (self.build_id != 0) {
            target.appendUint64(MappingWire.BUILD_ID_WIRE, self.build_id);
        }
        if (self.exact_offset != 0) {
            target.appendUint64(MappingWire.EXACT_OFFSET_WIRE, self.exact_offset);
        }
        if (self.start_offset != 0) {
            target.appendUint64(MappingWire.START_OFFSET_WIRE, self.start_offset);
        }
        if (self.start != 0) {
            target.appendUint64(MappingWire.START_WIRE, self.start);
        }
        if (self.end != 0) {
            target.appendUint64(MappingWire.END_WIRE, self.end);
        }
        if (self.load_bias != 0) {
            target.appendUint64(MappingWire.LOAD_BIAS_WIRE, self.load_bias);
        }
        if (self.path_string_ids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint64(MappingWire.PATH_STRING_IDS_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                target.appendBytesTag(MappingWire.PATH_STRING_IDS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint64WithoutTag(v);
                }
            }
        }
    }
};
pub const MappingReader = struct {
    buf: gremlin.Reader,
    _iid: u64 = 0,
    _build_id: u64 = 0,
    _exact_offset: u64 = 0,
    _start_offset: u64 = 0,
    _start: u64 = 0,
    _end: u64 = 0,
    _load_bias: u64 = 0,
    _path_string_ids_offset: ?usize = null,
    _path_string_ids_last_offset: ?usize = null,
    _path_string_ids_packed: bool = false,
    pub fn init(src: []const u8) gremlin.Error!MappingReader {
        const buf = gremlin.Reader.init(src);
        var res = MappingReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MappingWire.IID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._iid = result.value;
                },
                MappingWire.BUILD_ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._build_id = result.value;
                },
                MappingWire.EXACT_OFFSET_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._exact_offset = result.value;
                },
                MappingWire.START_OFFSET_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._start_offset = result.value;
                },
                MappingWire.START_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._start = result.value;
                },
                MappingWire.END_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._end = result.value;
                },
                MappingWire.LOAD_BIAS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._load_bias = result.value;
                },
                MappingWire.PATH_STRING_IDS_WIRE => {
                    if (res._path_string_ids_offset == null) {
                        res._path_string_ids_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._path_string_ids_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._path_string_ids_offset = offset + length_result.size;
                        res._path_string_ids_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._path_string_ids_last_offset.?;
                    } else {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._path_string_ids_last_offset = offset;
                    }
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getIid(self: *const MappingReader) u64 {
        return self._iid;
    }
    pub inline fn getBuildId(self: *const MappingReader) u64 {
        return self._build_id;
    }
    pub inline fn getExactOffset(self: *const MappingReader) u64 {
        return self._exact_offset;
    }
    pub inline fn getStartOffset(self: *const MappingReader) u64 {
        return self._start_offset;
    }
    pub inline fn getStart(self: *const MappingReader) u64 {
        return self._start;
    }
    pub inline fn getEnd(self: *const MappingReader) u64 {
        return self._end;
    }
    pub inline fn getLoadBias(self: *const MappingReader) u64 {
        return self._load_bias;
    }
    pub fn pathStringIdsNext(self: *MappingReader) gremlin.Error!?u64 {
        if (self._path_string_ids_offset == null) return null;
        const current_offset = self._path_string_ids_offset.?;
        if (current_offset >= self._path_string_ids_last_offset.?) {
            self._path_string_ids_offset = null;
            return null;
        }
        if (self._path_string_ids_packed) {
            const value_result = try self.buf.readUInt64(current_offset);
            self._path_string_ids_offset = current_offset + value_result.size;
            if (self._path_string_ids_offset.? >= self._path_string_ids_last_offset.?) {
                self._path_string_ids_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._path_string_ids_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == MappingWire.PATH_STRING_IDS_WIRE) {
                    self._path_string_ids_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._path_string_ids_offset = null;
            return value_result.value;
        }
    }
};
const FrameWire = struct {
    const IID_WIRE: gremlin.ProtoWireNumber = 1;
    const FUNCTION_NAME_ID_WIRE: gremlin.ProtoWireNumber = 2;
    const MAPPING_ID_WIRE: gremlin.ProtoWireNumber = 3;
    const REL_PC_WIRE: gremlin.ProtoWireNumber = 4;
    const SOURCE_PATH_IID_WIRE: gremlin.ProtoWireNumber = 5;
    const LINE_NUMBER_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const Frame = struct {
    // fields
    iid: u64 = 0,
    function_name_id: u64 = 0,
    mapping_id: u64 = 0,
    rel_pc: u64 = 0,
    source_path_iid: u64 = 0,
    line_number: u32 = 0,
    pub fn calcProtobufSize(self: *const Frame) usize {
        var res: usize = 0;
        if (self.iid != 0) {
            res += gremlin.sizes.sizeWireNumber(FrameWire.IID_WIRE) + gremlin.sizes.sizeU64(self.iid);
        }
        if (self.function_name_id != 0) {
            res += gremlin.sizes.sizeWireNumber(FrameWire.FUNCTION_NAME_ID_WIRE) + gremlin.sizes.sizeU64(self.function_name_id);
        }
        if (self.mapping_id != 0) {
            res += gremlin.sizes.sizeWireNumber(FrameWire.MAPPING_ID_WIRE) + gremlin.sizes.sizeU64(self.mapping_id);
        }
        if (self.rel_pc != 0) {
            res += gremlin.sizes.sizeWireNumber(FrameWire.REL_PC_WIRE) + gremlin.sizes.sizeU64(self.rel_pc);
        }
        if (self.source_path_iid != 0) {
            res += gremlin.sizes.sizeWireNumber(FrameWire.SOURCE_PATH_IID_WIRE) + gremlin.sizes.sizeU64(self.source_path_iid);
        }
        if (self.line_number != 0) {
            res += gremlin.sizes.sizeWireNumber(FrameWire.LINE_NUMBER_WIRE) + gremlin.sizes.sizeU32(self.line_number);
        }
        return res;
    }
    pub fn encode(self: *const Frame, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Frame, target: *gremlin.Writer) void {
        if (self.iid != 0) {
            target.appendUint64(FrameWire.IID_WIRE, self.iid);
        }
        if (self.function_name_id != 0) {
            target.appendUint64(FrameWire.FUNCTION_NAME_ID_WIRE, self.function_name_id);
        }
        if (self.mapping_id != 0) {
            target.appendUint64(FrameWire.MAPPING_ID_WIRE, self.mapping_id);
        }
        if (self.rel_pc != 0) {
            target.appendUint64(FrameWire.REL_PC_WIRE, self.rel_pc);
        }
        if (self.source_path_iid != 0) {
            target.appendUint64(FrameWire.SOURCE_PATH_IID_WIRE, self.source_path_iid);
        }
        if (self.line_number != 0) {
            target.appendUint32(FrameWire.LINE_NUMBER_WIRE, self.line_number);
        }
    }
};
pub const FrameReader = struct {
    buf: gremlin.Reader,
    _iid: u64 = 0,
    _function_name_id: u64 = 0,
    _mapping_id: u64 = 0,
    _rel_pc: u64 = 0,
    _source_path_iid: u64 = 0,
    _line_number: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!FrameReader {
        const buf = gremlin.Reader.init(src);
        var res = FrameReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                FrameWire.IID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._iid = result.value;
                },
                FrameWire.FUNCTION_NAME_ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._function_name_id = result.value;
                },
                FrameWire.MAPPING_ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._mapping_id = result.value;
                },
                FrameWire.REL_PC_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._rel_pc = result.value;
                },
                FrameWire.SOURCE_PATH_IID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._source_path_iid = result.value;
                },
                FrameWire.LINE_NUMBER_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._line_number = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getIid(self: *const FrameReader) u64 {
        return self._iid;
    }
    pub inline fn getFunctionNameId(self: *const FrameReader) u64 {
        return self._function_name_id;
    }
    pub inline fn getMappingId(self: *const FrameReader) u64 {
        return self._mapping_id;
    }
    pub inline fn getRelPc(self: *const FrameReader) u64 {
        return self._rel_pc;
    }
    pub inline fn getSourcePathIid(self: *const FrameReader) u64 {
        return self._source_path_iid;
    }
    pub inline fn getLineNumber(self: *const FrameReader) u32 {
        return self._line_number;
    }
};
const CallstackWire = struct {
    const IID_WIRE: gremlin.ProtoWireNumber = 1;
    const FRAME_IDS_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const Callstack = struct {
    // fields
    iid: u64 = 0,
    frame_ids: ?[]const u64 = null,
    pub fn calcProtobufSize(self: *const Callstack) usize {
        var res: usize = 0;
        if (self.iid != 0) {
            res += gremlin.sizes.sizeWireNumber(CallstackWire.IID_WIRE) + gremlin.sizes.sizeU64(self.iid);
        }
        if (self.frame_ids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(CallstackWire.FRAME_IDS_WIRE) + gremlin.sizes.sizeU64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                res += gremlin.sizes.sizeWireNumber(CallstackWire.FRAME_IDS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        return res;
    }
    pub fn encode(self: *const Callstack, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Callstack, target: *gremlin.Writer) void {
        if (self.iid != 0) {
            target.appendUint64(CallstackWire.IID_WIRE, self.iid);
        }
        if (self.frame_ids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint64(CallstackWire.FRAME_IDS_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                target.appendBytesTag(CallstackWire.FRAME_IDS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint64WithoutTag(v);
                }
            }
        }
    }
};
pub const CallstackReader = struct {
    buf: gremlin.Reader,
    _iid: u64 = 0,
    _frame_ids_offset: ?usize = null,
    _frame_ids_last_offset: ?usize = null,
    _frame_ids_packed: bool = false,
    pub fn init(src: []const u8) gremlin.Error!CallstackReader {
        const buf = gremlin.Reader.init(src);
        var res = CallstackReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                CallstackWire.IID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._iid = result.value;
                },
                CallstackWire.FRAME_IDS_WIRE => {
                    if (res._frame_ids_offset == null) {
                        res._frame_ids_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._frame_ids_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._frame_ids_offset = offset + length_result.size;
                        res._frame_ids_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._frame_ids_last_offset.?;
                    } else {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._frame_ids_last_offset = offset;
                    }
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getIid(self: *const CallstackReader) u64 {
        return self._iid;
    }
    pub fn frameIdsNext(self: *CallstackReader) gremlin.Error!?u64 {
        if (self._frame_ids_offset == null) return null;
        const current_offset = self._frame_ids_offset.?;
        if (current_offset >= self._frame_ids_last_offset.?) {
            self._frame_ids_offset = null;
            return null;
        }
        if (self._frame_ids_packed) {
            const value_result = try self.buf.readUInt64(current_offset);
            self._frame_ids_offset = current_offset + value_result.size;
            if (self._frame_ids_offset.? >= self._frame_ids_last_offset.?) {
                self._frame_ids_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._frame_ids_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == CallstackWire.FRAME_IDS_WIRE) {
                    self._frame_ids_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._frame_ids_offset = null;
            return value_result.value;
        }
    }
};
