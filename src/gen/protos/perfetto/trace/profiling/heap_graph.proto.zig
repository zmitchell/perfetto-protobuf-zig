// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
const profile_common = @import("profile_common.proto.zig");
// structs
const HeapGraphRootWire = struct {
    const OBJECT_IDS_WIRE: gremlin.ProtoWireNumber = 1;
    const ROOT_TYPE_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const HeapGraphRoot = struct {
    // nested enums
    pub const Type = enum(i32) {
        ROOT_UNKNOWN = 0,
        ROOT_JNI_GLOBAL = 1,
        ROOT_JNI_LOCAL = 2,
        ROOT_JAVA_FRAME = 3,
        ROOT_NATIVE_STACK = 4,
        ROOT_STICKY_CLASS = 5,
        ROOT_THREAD_BLOCK = 6,
        ROOT_MONITOR_USED = 7,
        ROOT_THREAD_OBJECT = 8,
        ROOT_INTERNED_STRING = 9,
        ROOT_FINALIZING = 10,
        ROOT_DEBUGGER = 11,
        ROOT_REFERENCE_CLEANUP = 12,
        ROOT_VM_INTERNAL = 13,
        ROOT_JNI_MONITOR = 14,
    };
    // fields
    object_ids: ?[]const u64 = null,
    root_type: HeapGraphRoot.Type = @enumFromInt(0),
    pub fn calcProtobufSize(self: *const HeapGraphRoot) usize {
        var res: usize = 0;
        if (self.object_ids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(HeapGraphRootWire.OBJECT_IDS_WIRE) + gremlin.sizes.sizeU64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                res += gremlin.sizes.sizeWireNumber(HeapGraphRootWire.OBJECT_IDS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (@intFromEnum(self.root_type) != 0) {
            res += gremlin.sizes.sizeWireNumber(HeapGraphRootWire.ROOT_TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.root_type));
        }
        return res;
    }
    pub fn encode(self: *const HeapGraphRoot, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const HeapGraphRoot, target: *gremlin.Writer) void {
        if (self.object_ids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint64(HeapGraphRootWire.OBJECT_IDS_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                target.appendBytesTag(HeapGraphRootWire.OBJECT_IDS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint64WithoutTag(v);
                }
            }
        }
        if (@intFromEnum(self.root_type) != 0) {
            target.appendInt32(HeapGraphRootWire.ROOT_TYPE_WIRE, @intFromEnum(self.root_type));
        }
    }
};
pub const HeapGraphRootReader = struct {
    buf: gremlin.Reader,
    _object_ids_offset: ?usize = null,
    _object_ids_last_offset: ?usize = null,
    _object_ids_packed: bool = false,
    _root_type: HeapGraphRoot.Type = @enumFromInt(0),
    pub fn init(src: []const u8) gremlin.Error!HeapGraphRootReader {
        const buf = gremlin.Reader.init(src);
        var res = HeapGraphRootReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                HeapGraphRootWire.OBJECT_IDS_WIRE => {
                    if (res._object_ids_offset == null) {
                        res._object_ids_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._object_ids_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._object_ids_offset = offset + length_result.size;
                        res._object_ids_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._object_ids_last_offset.?;
                    } else {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._object_ids_last_offset = offset;
                    }
                },
                HeapGraphRootWire.ROOT_TYPE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._root_type = @enumFromInt(result.value);
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn objectIdsNext(self: *HeapGraphRootReader) gremlin.Error!?u64 {
        if (self._object_ids_offset == null) return null;
        const current_offset = self._object_ids_offset.?;
        if (current_offset >= self._object_ids_last_offset.?) {
            self._object_ids_offset = null;
            return null;
        }
        if (self._object_ids_packed) {
            const value_result = try self.buf.readUInt64(current_offset);
            self._object_ids_offset = current_offset + value_result.size;
            if (self._object_ids_offset.? >= self._object_ids_last_offset.?) {
                self._object_ids_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._object_ids_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == HeapGraphRootWire.OBJECT_IDS_WIRE) {
                    self._object_ids_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._object_ids_offset = null;
            return value_result.value;
        }
    }
    pub inline fn getRootType(self: *const HeapGraphRootReader) HeapGraphRoot.Type {
        return self._root_type;
    }
};
const HeapGraphTypeWire = struct {
    const ID_WIRE: gremlin.ProtoWireNumber = 1;
    const LOCATION_ID_WIRE: gremlin.ProtoWireNumber = 2;
    const CLASS_NAME_WIRE: gremlin.ProtoWireNumber = 3;
    const OBJECT_SIZE_WIRE: gremlin.ProtoWireNumber = 4;
    const SUPERCLASS_ID_WIRE: gremlin.ProtoWireNumber = 5;
    const REFERENCE_FIELD_ID_WIRE: gremlin.ProtoWireNumber = 6;
    const KIND_WIRE: gremlin.ProtoWireNumber = 7;
    const CLASSLOADER_ID_WIRE: gremlin.ProtoWireNumber = 8;
};
pub const HeapGraphType = struct {
    // nested enums
    pub const Kind = enum(i32) {
        KIND_UNKNOWN = 0,
        KIND_NORMAL = 1,
        KIND_NOREFERENCES = 2,
        KIND_STRING = 3,
        KIND_ARRAY = 4,
        KIND_CLASS = 5,
        KIND_CLASSLOADER = 6,
        KIND_DEXCACHE = 7,
        KIND_SOFT_REFERENCE = 8,
        KIND_WEAK_REFERENCE = 9,
        KIND_FINALIZER_REFERENCE = 10,
        KIND_PHANTOM_REFERENCE = 11,
    };
    // fields
    id: u64 = 0,
    location_id: u64 = 0,
    class_name: ?[]const u8 = null,
    object_size: u64 = 0,
    superclass_id: u64 = 0,
    reference_field_id: ?[]const u64 = null,
    kind: HeapGraphType.Kind = @enumFromInt(0),
    classloader_id: u64 = 0,
    pub fn calcProtobufSize(self: *const HeapGraphType) usize {
        var res: usize = 0;
        if (self.id != 0) {
            res += gremlin.sizes.sizeWireNumber(HeapGraphTypeWire.ID_WIRE) + gremlin.sizes.sizeU64(self.id);
        }
        if (self.location_id != 0) {
            res += gremlin.sizes.sizeWireNumber(HeapGraphTypeWire.LOCATION_ID_WIRE) + gremlin.sizes.sizeU64(self.location_id);
        }
        if (self.class_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(HeapGraphTypeWire.CLASS_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.object_size != 0) {
            res += gremlin.sizes.sizeWireNumber(HeapGraphTypeWire.OBJECT_SIZE_WIRE) + gremlin.sizes.sizeU64(self.object_size);
        }
        if (self.superclass_id != 0) {
            res += gremlin.sizes.sizeWireNumber(HeapGraphTypeWire.SUPERCLASS_ID_WIRE) + gremlin.sizes.sizeU64(self.superclass_id);
        }
        if (self.reference_field_id) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(HeapGraphTypeWire.REFERENCE_FIELD_ID_WIRE) + gremlin.sizes.sizeU64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                res += gremlin.sizes.sizeWireNumber(HeapGraphTypeWire.REFERENCE_FIELD_ID_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (@intFromEnum(self.kind) != 0) {
            res += gremlin.sizes.sizeWireNumber(HeapGraphTypeWire.KIND_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.kind));
        }
        if (self.classloader_id != 0) {
            res += gremlin.sizes.sizeWireNumber(HeapGraphTypeWire.CLASSLOADER_ID_WIRE) + gremlin.sizes.sizeU64(self.classloader_id);
        }
        return res;
    }
    pub fn encode(self: *const HeapGraphType, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const HeapGraphType, target: *gremlin.Writer) void {
        if (self.id != 0) {
            target.appendUint64(HeapGraphTypeWire.ID_WIRE, self.id);
        }
        if (self.location_id != 0) {
            target.appendUint64(HeapGraphTypeWire.LOCATION_ID_WIRE, self.location_id);
        }
        if (self.class_name) |v| {
            if (v.len > 0) {
                target.appendBytes(HeapGraphTypeWire.CLASS_NAME_WIRE, v);
            }
        }
        if (self.object_size != 0) {
            target.appendUint64(HeapGraphTypeWire.OBJECT_SIZE_WIRE, self.object_size);
        }
        if (self.superclass_id != 0) {
            target.appendUint64(HeapGraphTypeWire.SUPERCLASS_ID_WIRE, self.superclass_id);
        }
        if (self.reference_field_id) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint64(HeapGraphTypeWire.REFERENCE_FIELD_ID_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                target.appendBytesTag(HeapGraphTypeWire.REFERENCE_FIELD_ID_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint64WithoutTag(v);
                }
            }
        }
        if (@intFromEnum(self.kind) != 0) {
            target.appendInt32(HeapGraphTypeWire.KIND_WIRE, @intFromEnum(self.kind));
        }
        if (self.classloader_id != 0) {
            target.appendUint64(HeapGraphTypeWire.CLASSLOADER_ID_WIRE, self.classloader_id);
        }
    }
};
pub const HeapGraphTypeReader = struct {
    buf: gremlin.Reader,
    _id: u64 = 0,
    _location_id: u64 = 0,
    _class_name: ?[]const u8 = null,
    _object_size: u64 = 0,
    _superclass_id: u64 = 0,
    _reference_field_id_offset: ?usize = null,
    _reference_field_id_last_offset: ?usize = null,
    _reference_field_id_packed: bool = false,
    _kind: HeapGraphType.Kind = @enumFromInt(0),
    _classloader_id: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!HeapGraphTypeReader {
        const buf = gremlin.Reader.init(src);
        var res = HeapGraphTypeReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                HeapGraphTypeWire.ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._id = result.value;
                },
                HeapGraphTypeWire.LOCATION_ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._location_id = result.value;
                },
                HeapGraphTypeWire.CLASS_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._class_name = result.value;
                },
                HeapGraphTypeWire.OBJECT_SIZE_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._object_size = result.value;
                },
                HeapGraphTypeWire.SUPERCLASS_ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._superclass_id = result.value;
                },
                HeapGraphTypeWire.REFERENCE_FIELD_ID_WIRE => {
                    if (res._reference_field_id_offset == null) {
                        res._reference_field_id_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._reference_field_id_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._reference_field_id_offset = offset + length_result.size;
                        res._reference_field_id_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._reference_field_id_last_offset.?;
                    } else {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._reference_field_id_last_offset = offset;
                    }
                },
                HeapGraphTypeWire.KIND_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._kind = @enumFromInt(result.value);
                },
                HeapGraphTypeWire.CLASSLOADER_ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._classloader_id = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getId(self: *const HeapGraphTypeReader) u64 {
        return self._id;
    }
    pub inline fn getLocationId(self: *const HeapGraphTypeReader) u64 {
        return self._location_id;
    }
    pub inline fn getClassName(self: *const HeapGraphTypeReader) []const u8 {
        return self._class_name orelse &[_]u8{};
    }
    pub inline fn getObjectSize(self: *const HeapGraphTypeReader) u64 {
        return self._object_size;
    }
    pub inline fn getSuperclassId(self: *const HeapGraphTypeReader) u64 {
        return self._superclass_id;
    }
    pub fn referenceFieldIdNext(self: *HeapGraphTypeReader) gremlin.Error!?u64 {
        if (self._reference_field_id_offset == null) return null;
        const current_offset = self._reference_field_id_offset.?;
        if (current_offset >= self._reference_field_id_last_offset.?) {
            self._reference_field_id_offset = null;
            return null;
        }
        if (self._reference_field_id_packed) {
            const value_result = try self.buf.readUInt64(current_offset);
            self._reference_field_id_offset = current_offset + value_result.size;
            if (self._reference_field_id_offset.? >= self._reference_field_id_last_offset.?) {
                self._reference_field_id_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._reference_field_id_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == HeapGraphTypeWire.REFERENCE_FIELD_ID_WIRE) {
                    self._reference_field_id_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._reference_field_id_offset = null;
            return value_result.value;
        }
    }
    pub inline fn getKind(self: *const HeapGraphTypeReader) HeapGraphType.Kind {
        return self._kind;
    }
    pub inline fn getClassloaderId(self: *const HeapGraphTypeReader) u64 {
        return self._classloader_id;
    }
};
const HeapGraphObjectWire = struct {
    const TYPE_ID_WIRE: gremlin.ProtoWireNumber = 2;
    const SELF_SIZE_WIRE: gremlin.ProtoWireNumber = 3;
    const REFERENCE_FIELD_ID_BASE_WIRE: gremlin.ProtoWireNumber = 6;
    const REFERENCE_FIELD_ID_WIRE: gremlin.ProtoWireNumber = 4;
    const REFERENCE_OBJECT_ID_WIRE: gremlin.ProtoWireNumber = 5;
    const NATIVE_ALLOCATION_REGISTRY_SIZE_FIELD_WIRE: gremlin.ProtoWireNumber = 8;
    const HEAP_TYPE_DELTA_WIRE: gremlin.ProtoWireNumber = 9;
    const RUNTIME_INTERNAL_OBJECT_ID_WIRE: gremlin.ProtoWireNumber = 10;
    const ID_WIRE: gremlin.ProtoWireNumber = 1;
    const ID_DELTA_WIRE: gremlin.ProtoWireNumber = 7;
};
pub const HeapGraphObject = struct {
    // nested enums
    pub const HeapType = enum(i32) {
        HEAP_TYPE_UNKNOWN = 0,
        HEAP_TYPE_APP = 1,
        HEAP_TYPE_ZYGOTE = 2,
        HEAP_TYPE_BOOT_IMAGE = 3,
    };
    // fields
    type_id: u64 = 0,
    self_size: u64 = 0,
    reference_field_id_base: u64 = 0,
    reference_field_id: ?[]const u64 = null,
    reference_object_id: ?[]const u64 = null,
    native_allocation_registry_size_field: i64 = 0,
    heap_type_delta: HeapGraphObject.HeapType = @enumFromInt(0),
    runtime_internal_object_id: ?[]const u64 = null,
    id: u64 = 0,
    id_delta: u64 = 0,
    pub fn calcProtobufSize(self: *const HeapGraphObject) usize {
        var res: usize = 0;
        if (self.type_id != 0) {
            res += gremlin.sizes.sizeWireNumber(HeapGraphObjectWire.TYPE_ID_WIRE) + gremlin.sizes.sizeU64(self.type_id);
        }
        if (self.self_size != 0) {
            res += gremlin.sizes.sizeWireNumber(HeapGraphObjectWire.SELF_SIZE_WIRE) + gremlin.sizes.sizeU64(self.self_size);
        }
        if (self.reference_field_id_base != 0) {
            res += gremlin.sizes.sizeWireNumber(HeapGraphObjectWire.REFERENCE_FIELD_ID_BASE_WIRE) + gremlin.sizes.sizeU64(self.reference_field_id_base);
        }
        if (self.reference_field_id) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(HeapGraphObjectWire.REFERENCE_FIELD_ID_WIRE) + gremlin.sizes.sizeU64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                res += gremlin.sizes.sizeWireNumber(HeapGraphObjectWire.REFERENCE_FIELD_ID_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.reference_object_id) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(HeapGraphObjectWire.REFERENCE_OBJECT_ID_WIRE) + gremlin.sizes.sizeU64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                res += gremlin.sizes.sizeWireNumber(HeapGraphObjectWire.REFERENCE_OBJECT_ID_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.native_allocation_registry_size_field != 0) {
            res += gremlin.sizes.sizeWireNumber(HeapGraphObjectWire.NATIVE_ALLOCATION_REGISTRY_SIZE_FIELD_WIRE) + gremlin.sizes.sizeI64(self.native_allocation_registry_size_field);
        }
        if (@intFromEnum(self.heap_type_delta) != 0) {
            res += gremlin.sizes.sizeWireNumber(HeapGraphObjectWire.HEAP_TYPE_DELTA_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.heap_type_delta));
        }
        if (self.runtime_internal_object_id) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(HeapGraphObjectWire.RUNTIME_INTERNAL_OBJECT_ID_WIRE) + gremlin.sizes.sizeU64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                res += gremlin.sizes.sizeWireNumber(HeapGraphObjectWire.RUNTIME_INTERNAL_OBJECT_ID_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.id != 0) {
            res += gremlin.sizes.sizeWireNumber(HeapGraphObjectWire.ID_WIRE) + gremlin.sizes.sizeU64(self.id);
        }
        if (self.id_delta != 0) {
            res += gremlin.sizes.sizeWireNumber(HeapGraphObjectWire.ID_DELTA_WIRE) + gremlin.sizes.sizeU64(self.id_delta);
        }
        return res;
    }
    pub fn encode(self: *const HeapGraphObject, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const HeapGraphObject, target: *gremlin.Writer) void {
        if (self.type_id != 0) {
            target.appendUint64(HeapGraphObjectWire.TYPE_ID_WIRE, self.type_id);
        }
        if (self.self_size != 0) {
            target.appendUint64(HeapGraphObjectWire.SELF_SIZE_WIRE, self.self_size);
        }
        if (self.reference_field_id_base != 0) {
            target.appendUint64(HeapGraphObjectWire.REFERENCE_FIELD_ID_BASE_WIRE, self.reference_field_id_base);
        }
        if (self.reference_field_id) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint64(HeapGraphObjectWire.REFERENCE_FIELD_ID_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                target.appendBytesTag(HeapGraphObjectWire.REFERENCE_FIELD_ID_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint64WithoutTag(v);
                }
            }
        }
        if (self.reference_object_id) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint64(HeapGraphObjectWire.REFERENCE_OBJECT_ID_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                target.appendBytesTag(HeapGraphObjectWire.REFERENCE_OBJECT_ID_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint64WithoutTag(v);
                }
            }
        }
        if (self.native_allocation_registry_size_field != 0) {
            target.appendInt64(HeapGraphObjectWire.NATIVE_ALLOCATION_REGISTRY_SIZE_FIELD_WIRE, self.native_allocation_registry_size_field);
        }
        if (@intFromEnum(self.heap_type_delta) != 0) {
            target.appendInt32(HeapGraphObjectWire.HEAP_TYPE_DELTA_WIRE, @intFromEnum(self.heap_type_delta));
        }
        if (self.runtime_internal_object_id) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint64(HeapGraphObjectWire.RUNTIME_INTERNAL_OBJECT_ID_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                target.appendBytesTag(HeapGraphObjectWire.RUNTIME_INTERNAL_OBJECT_ID_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint64WithoutTag(v);
                }
            }
        }
        if (self.id != 0) {
            target.appendUint64(HeapGraphObjectWire.ID_WIRE, self.id);
        }
        if (self.id_delta != 0) {
            target.appendUint64(HeapGraphObjectWire.ID_DELTA_WIRE, self.id_delta);
        }
    }
};
pub const HeapGraphObjectReader = struct {
    buf: gremlin.Reader,
    _type_id: u64 = 0,
    _self_size: u64 = 0,
    _reference_field_id_base: u64 = 0,
    _reference_field_id_offset: ?usize = null,
    _reference_field_id_last_offset: ?usize = null,
    _reference_field_id_packed: bool = false,
    _reference_object_id_offset: ?usize = null,
    _reference_object_id_last_offset: ?usize = null,
    _reference_object_id_packed: bool = false,
    _native_allocation_registry_size_field: i64 = 0,
    _heap_type_delta: HeapGraphObject.HeapType = @enumFromInt(0),
    _runtime_internal_object_id_offset: ?usize = null,
    _runtime_internal_object_id_last_offset: ?usize = null,
    _runtime_internal_object_id_packed: bool = false,
    _id: u64 = 0,
    _id_delta: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!HeapGraphObjectReader {
        const buf = gremlin.Reader.init(src);
        var res = HeapGraphObjectReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                HeapGraphObjectWire.TYPE_ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._type_id = result.value;
                },
                HeapGraphObjectWire.SELF_SIZE_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._self_size = result.value;
                },
                HeapGraphObjectWire.REFERENCE_FIELD_ID_BASE_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._reference_field_id_base = result.value;
                },
                HeapGraphObjectWire.REFERENCE_FIELD_ID_WIRE => {
                    if (res._reference_field_id_offset == null) {
                        res._reference_field_id_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._reference_field_id_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._reference_field_id_offset = offset + length_result.size;
                        res._reference_field_id_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._reference_field_id_last_offset.?;
                    } else {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._reference_field_id_last_offset = offset;
                    }
                },
                HeapGraphObjectWire.REFERENCE_OBJECT_ID_WIRE => {
                    if (res._reference_object_id_offset == null) {
                        res._reference_object_id_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._reference_object_id_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._reference_object_id_offset = offset + length_result.size;
                        res._reference_object_id_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._reference_object_id_last_offset.?;
                    } else {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._reference_object_id_last_offset = offset;
                    }
                },
                HeapGraphObjectWire.NATIVE_ALLOCATION_REGISTRY_SIZE_FIELD_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._native_allocation_registry_size_field = result.value;
                },
                HeapGraphObjectWire.HEAP_TYPE_DELTA_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._heap_type_delta = @enumFromInt(result.value);
                },
                HeapGraphObjectWire.RUNTIME_INTERNAL_OBJECT_ID_WIRE => {
                    if (res._runtime_internal_object_id_offset == null) {
                        res._runtime_internal_object_id_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._runtime_internal_object_id_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._runtime_internal_object_id_offset = offset + length_result.size;
                        res._runtime_internal_object_id_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._runtime_internal_object_id_last_offset.?;
                    } else {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._runtime_internal_object_id_last_offset = offset;
                    }
                },
                HeapGraphObjectWire.ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._id = result.value;
                },
                HeapGraphObjectWire.ID_DELTA_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._id_delta = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getTypeId(self: *const HeapGraphObjectReader) u64 {
        return self._type_id;
    }
    pub inline fn getSelfSize(self: *const HeapGraphObjectReader) u64 {
        return self._self_size;
    }
    pub inline fn getReferenceFieldIdBase(self: *const HeapGraphObjectReader) u64 {
        return self._reference_field_id_base;
    }
    pub fn referenceFieldIdNext(self: *HeapGraphObjectReader) gremlin.Error!?u64 {
        if (self._reference_field_id_offset == null) return null;
        const current_offset = self._reference_field_id_offset.?;
        if (current_offset >= self._reference_field_id_last_offset.?) {
            self._reference_field_id_offset = null;
            return null;
        }
        if (self._reference_field_id_packed) {
            const value_result = try self.buf.readUInt64(current_offset);
            self._reference_field_id_offset = current_offset + value_result.size;
            if (self._reference_field_id_offset.? >= self._reference_field_id_last_offset.?) {
                self._reference_field_id_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._reference_field_id_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == HeapGraphObjectWire.REFERENCE_FIELD_ID_WIRE) {
                    self._reference_field_id_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._reference_field_id_offset = null;
            return value_result.value;
        }
    }
    pub fn referenceObjectIdNext(self: *HeapGraphObjectReader) gremlin.Error!?u64 {
        if (self._reference_object_id_offset == null) return null;
        const current_offset = self._reference_object_id_offset.?;
        if (current_offset >= self._reference_object_id_last_offset.?) {
            self._reference_object_id_offset = null;
            return null;
        }
        if (self._reference_object_id_packed) {
            const value_result = try self.buf.readUInt64(current_offset);
            self._reference_object_id_offset = current_offset + value_result.size;
            if (self._reference_object_id_offset.? >= self._reference_object_id_last_offset.?) {
                self._reference_object_id_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._reference_object_id_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == HeapGraphObjectWire.REFERENCE_OBJECT_ID_WIRE) {
                    self._reference_object_id_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._reference_object_id_offset = null;
            return value_result.value;
        }
    }
    pub inline fn getNativeAllocationRegistrySizeField(self: *const HeapGraphObjectReader) i64 {
        return self._native_allocation_registry_size_field;
    }
    pub inline fn getHeapTypeDelta(self: *const HeapGraphObjectReader) HeapGraphObject.HeapType {
        return self._heap_type_delta;
    }
    pub fn runtimeInternalObjectIdNext(self: *HeapGraphObjectReader) gremlin.Error!?u64 {
        if (self._runtime_internal_object_id_offset == null) return null;
        const current_offset = self._runtime_internal_object_id_offset.?;
        if (current_offset >= self._runtime_internal_object_id_last_offset.?) {
            self._runtime_internal_object_id_offset = null;
            return null;
        }
        if (self._runtime_internal_object_id_packed) {
            const value_result = try self.buf.readUInt64(current_offset);
            self._runtime_internal_object_id_offset = current_offset + value_result.size;
            if (self._runtime_internal_object_id_offset.? >= self._runtime_internal_object_id_last_offset.?) {
                self._runtime_internal_object_id_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._runtime_internal_object_id_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == HeapGraphObjectWire.RUNTIME_INTERNAL_OBJECT_ID_WIRE) {
                    self._runtime_internal_object_id_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._runtime_internal_object_id_offset = null;
            return value_result.value;
        }
    }
    pub inline fn getId(self: *const HeapGraphObjectReader) u64 {
        return self._id;
    }
    pub inline fn getIdDelta(self: *const HeapGraphObjectReader) u64 {
        return self._id_delta;
    }
};
const HeapGraphWire = struct {
    const PID_WIRE: gremlin.ProtoWireNumber = 1;
    const OBJECTS_WIRE: gremlin.ProtoWireNumber = 2;
    const ROOTS_WIRE: gremlin.ProtoWireNumber = 7;
    const TYPES_WIRE: gremlin.ProtoWireNumber = 9;
    const FIELD_NAMES_WIRE: gremlin.ProtoWireNumber = 4;
    const LOCATION_NAMES_WIRE: gremlin.ProtoWireNumber = 8;
    const CONTINUED_WIRE: gremlin.ProtoWireNumber = 5;
    const INDEX_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const HeapGraph = struct {
    // fields
    pid: i32 = 0,
    objects: ?[]const ?HeapGraphObject = null,
    roots: ?[]const ?HeapGraphRoot = null,
    types: ?[]const ?HeapGraphType = null,
    field_names: ?[]const ?profile_common.InternedString = null,
    location_names: ?[]const ?profile_common.InternedString = null,
    continued: bool = false,
    index: u64 = 0,
    pub fn calcProtobufSize(self: *const HeapGraph) usize {
        var res: usize = 0;
        if (self.pid != 0) {
            res += gremlin.sizes.sizeWireNumber(HeapGraphWire.PID_WIRE) + gremlin.sizes.sizeI32(self.pid);
        }
        if (self.objects) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(HeapGraphWire.OBJECTS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.roots) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(HeapGraphWire.ROOTS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.types) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(HeapGraphWire.TYPES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.field_names) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(HeapGraphWire.FIELD_NAMES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.location_names) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(HeapGraphWire.LOCATION_NAMES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.continued != false) {
            res += gremlin.sizes.sizeWireNumber(HeapGraphWire.CONTINUED_WIRE) + gremlin.sizes.sizeBool(self.continued);
        }
        if (self.index != 0) {
            res += gremlin.sizes.sizeWireNumber(HeapGraphWire.INDEX_WIRE) + gremlin.sizes.sizeU64(self.index);
        }
        return res;
    }
    pub fn encode(self: *const HeapGraph, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const HeapGraph, target: *gremlin.Writer) void {
        if (self.pid != 0) {
            target.appendInt32(HeapGraphWire.PID_WIRE, self.pid);
        }
        if (self.objects) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(HeapGraphWire.OBJECTS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(HeapGraphWire.OBJECTS_WIRE, 0);
                }
            }
        }
        if (self.roots) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(HeapGraphWire.ROOTS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(HeapGraphWire.ROOTS_WIRE, 0);
                }
            }
        }
        if (self.types) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(HeapGraphWire.TYPES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(HeapGraphWire.TYPES_WIRE, 0);
                }
            }
        }
        if (self.field_names) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(HeapGraphWire.FIELD_NAMES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(HeapGraphWire.FIELD_NAMES_WIRE, 0);
                }
            }
        }
        if (self.location_names) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(HeapGraphWire.LOCATION_NAMES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(HeapGraphWire.LOCATION_NAMES_WIRE, 0);
                }
            }
        }
        if (self.continued != false) {
            target.appendBool(HeapGraphWire.CONTINUED_WIRE, self.continued);
        }
        if (self.index != 0) {
            target.appendUint64(HeapGraphWire.INDEX_WIRE, self.index);
        }
    }
};
pub const HeapGraphReader = struct {
    buf: gremlin.Reader,
    _pid: i32 = 0,
    _objects_offset: ?usize = null,
    _objects_last_offset: ?usize = null,
    _objects_cnt: usize = 0,
    _roots_offset: ?usize = null,
    _roots_last_offset: ?usize = null,
    _roots_cnt: usize = 0,
    _types_offset: ?usize = null,
    _types_last_offset: ?usize = null,
    _types_cnt: usize = 0,
    _field_names_offset: ?usize = null,
    _field_names_last_offset: ?usize = null,
    _field_names_cnt: usize = 0,
    _location_names_offset: ?usize = null,
    _location_names_last_offset: ?usize = null,
    _location_names_cnt: usize = 0,
    _continued: bool = false,
    _index: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!HeapGraphReader {
        const buf = gremlin.Reader.init(src);
        var res = HeapGraphReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                HeapGraphWire.PID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._pid = result.value;
                },
                HeapGraphWire.OBJECTS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._objects_offset == null) {
                        res._objects_offset = offset - result.size;
                    }
                    res._objects_last_offset = offset;
                    res._objects_cnt += 1;
                },
                HeapGraphWire.ROOTS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._roots_offset == null) {
                        res._roots_offset = offset - result.size;
                    }
                    res._roots_last_offset = offset;
                    res._roots_cnt += 1;
                },
                HeapGraphWire.TYPES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._types_offset == null) {
                        res._types_offset = offset - result.size;
                    }
                    res._types_last_offset = offset;
                    res._types_cnt += 1;
                },
                HeapGraphWire.FIELD_NAMES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._field_names_offset == null) {
                        res._field_names_offset = offset - result.size;
                    }
                    res._field_names_last_offset = offset;
                    res._field_names_cnt += 1;
                },
                HeapGraphWire.LOCATION_NAMES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._location_names_offset == null) {
                        res._location_names_offset = offset - result.size;
                    }
                    res._location_names_last_offset = offset;
                    res._location_names_cnt += 1;
                },
                HeapGraphWire.CONTINUED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._continued = result.value;
                },
                HeapGraphWire.INDEX_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._index = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getPid(self: *const HeapGraphReader) i32 {
        return self._pid;
    }
    pub fn objectsCount(self: *const HeapGraphReader) usize {
        return self._objects_cnt;
    }
    pub fn objectsNext(self: *HeapGraphReader) ?HeapGraphObjectReader {
        if (self._objects_offset == null) return null;
        const current_offset = self._objects_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = HeapGraphObjectReader.init(result.value) catch return null;
        if (self._objects_last_offset != null and current_offset >= self._objects_last_offset.?) {
            self._objects_offset = null;
            return msg;
        }
        if (self._objects_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._objects_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == HeapGraphWire.OBJECTS_WIRE) {
                self._objects_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._objects_offset = null;
        return msg;
    }
    pub fn rootsCount(self: *const HeapGraphReader) usize {
        return self._roots_cnt;
    }
    pub fn rootsNext(self: *HeapGraphReader) ?HeapGraphRootReader {
        if (self._roots_offset == null) return null;
        const current_offset = self._roots_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = HeapGraphRootReader.init(result.value) catch return null;
        if (self._roots_last_offset != null and current_offset >= self._roots_last_offset.?) {
            self._roots_offset = null;
            return msg;
        }
        if (self._roots_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._roots_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == HeapGraphWire.ROOTS_WIRE) {
                self._roots_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._roots_offset = null;
        return msg;
    }
    pub fn typesCount(self: *const HeapGraphReader) usize {
        return self._types_cnt;
    }
    pub fn typesNext(self: *HeapGraphReader) ?HeapGraphTypeReader {
        if (self._types_offset == null) return null;
        const current_offset = self._types_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = HeapGraphTypeReader.init(result.value) catch return null;
        if (self._types_last_offset != null and current_offset >= self._types_last_offset.?) {
            self._types_offset = null;
            return msg;
        }
        if (self._types_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._types_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == HeapGraphWire.TYPES_WIRE) {
                self._types_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._types_offset = null;
        return msg;
    }
    pub fn fieldNamesCount(self: *const HeapGraphReader) usize {
        return self._field_names_cnt;
    }
    pub fn fieldNamesNext(self: *HeapGraphReader) ?profile_common.InternedStringReader {
        if (self._field_names_offset == null) return null;
        const current_offset = self._field_names_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = profile_common.InternedStringReader.init(result.value) catch return null;
        if (self._field_names_last_offset != null and current_offset >= self._field_names_last_offset.?) {
            self._field_names_offset = null;
            return msg;
        }
        if (self._field_names_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._field_names_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == HeapGraphWire.FIELD_NAMES_WIRE) {
                self._field_names_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._field_names_offset = null;
        return msg;
    }
    pub fn locationNamesCount(self: *const HeapGraphReader) usize {
        return self._location_names_cnt;
    }
    pub fn locationNamesNext(self: *HeapGraphReader) ?profile_common.InternedStringReader {
        if (self._location_names_offset == null) return null;
        const current_offset = self._location_names_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = profile_common.InternedStringReader.init(result.value) catch return null;
        if (self._location_names_last_offset != null and current_offset >= self._location_names_last_offset.?) {
            self._location_names_offset = null;
            return msg;
        }
        if (self._location_names_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._location_names_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == HeapGraphWire.LOCATION_NAMES_WIRE) {
                self._location_names_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._location_names_offset = null;
        return msg;
    }
    pub inline fn getContinued(self: *const HeapGraphReader) bool {
        return self._continued;
    }
    pub inline fn getIndex(self: *const HeapGraphReader) u64 {
        return self._index;
    }
};
