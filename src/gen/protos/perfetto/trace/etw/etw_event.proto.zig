// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
const etw = @import("etw.proto.zig");
// structs
const EtwTraceEventWire = struct {
    const TIMESTAMP_WIRE: gremlin.ProtoWireNumber = 1;
    const CPU_WIRE: gremlin.ProtoWireNumber = 4;
    const THREAD_ID_WIRE: gremlin.ProtoWireNumber = 5;
    const C_SWITCH_WIRE: gremlin.ProtoWireNumber = 2;
    const READY_THREAD_WIRE: gremlin.ProtoWireNumber = 3;
    const MEM_INFO_WIRE: gremlin.ProtoWireNumber = 6;
    const FILE_IO_CREATE_WIRE: gremlin.ProtoWireNumber = 7;
    const FILE_IO_DIR_ENUM_WIRE: gremlin.ProtoWireNumber = 8;
    const FILE_IO_INFO_WIRE: gremlin.ProtoWireNumber = 9;
    const FILE_IO_READ_WRITE_WIRE: gremlin.ProtoWireNumber = 10;
    const FILE_IO_SIMPLE_OP_WIRE: gremlin.ProtoWireNumber = 11;
    const FILE_IO_OP_END_WIRE: gremlin.ProtoWireNumber = 12;
};
pub const EtwTraceEvent = struct {
    // fields
    timestamp: u64 = 0,
    cpu: u32 = 0,
    thread_id: u32 = 0,
    c_switch: ?etw.CSwitchEtwEvent = null,
    ready_thread: ?etw.ReadyThreadEtwEvent = null,
    mem_info: ?etw.MemInfoEtwEvent = null,
    file_io_create: ?etw.FileIoCreateEtwEvent = null,
    file_io_dir_enum: ?etw.FileIoDirEnumEtwEvent = null,
    file_io_info: ?etw.FileIoInfoEtwEvent = null,
    file_io_read_write: ?etw.FileIoReadWriteEtwEvent = null,
    file_io_simple_op: ?etw.FileIoSimpleOpEtwEvent = null,
    file_io_op_end: ?etw.FileIoOpEndEtwEvent = null,
    pub fn calcProtobufSize(self: *const EtwTraceEvent) usize {
        var res: usize = 0;
        if (self.timestamp != 0) {
            res += gremlin.sizes.sizeWireNumber(EtwTraceEventWire.TIMESTAMP_WIRE) + gremlin.sizes.sizeU64(self.timestamp);
        }
        if (self.cpu != 0) {
            res += gremlin.sizes.sizeWireNumber(EtwTraceEventWire.CPU_WIRE) + gremlin.sizes.sizeU32(self.cpu);
        }
        if (self.thread_id != 0) {
            res += gremlin.sizes.sizeWireNumber(EtwTraceEventWire.THREAD_ID_WIRE) + gremlin.sizes.sizeU32(self.thread_id);
        }
        if (self.c_switch) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(EtwTraceEventWire.C_SWITCH_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ready_thread) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(EtwTraceEventWire.READY_THREAD_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mem_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(EtwTraceEventWire.MEM_INFO_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.file_io_create) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(EtwTraceEventWire.FILE_IO_CREATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.file_io_dir_enum) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(EtwTraceEventWire.FILE_IO_DIR_ENUM_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.file_io_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(EtwTraceEventWire.FILE_IO_INFO_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.file_io_read_write) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(EtwTraceEventWire.FILE_IO_READ_WRITE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.file_io_simple_op) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(EtwTraceEventWire.FILE_IO_SIMPLE_OP_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.file_io_op_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(EtwTraceEventWire.FILE_IO_OP_END_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const EtwTraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const EtwTraceEvent, target: *gremlin.Writer) void {
        if (self.timestamp != 0) {
            target.appendUint64(EtwTraceEventWire.TIMESTAMP_WIRE, self.timestamp);
        }
        if (self.cpu != 0) {
            target.appendUint32(EtwTraceEventWire.CPU_WIRE, self.cpu);
        }
        if (self.thread_id != 0) {
            target.appendUint32(EtwTraceEventWire.THREAD_ID_WIRE, self.thread_id);
        }
        if (self.c_switch) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(EtwTraceEventWire.C_SWITCH_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ready_thread) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(EtwTraceEventWire.READY_THREAD_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mem_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(EtwTraceEventWire.MEM_INFO_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.file_io_create) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(EtwTraceEventWire.FILE_IO_CREATE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.file_io_dir_enum) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(EtwTraceEventWire.FILE_IO_DIR_ENUM_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.file_io_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(EtwTraceEventWire.FILE_IO_INFO_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.file_io_read_write) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(EtwTraceEventWire.FILE_IO_READ_WRITE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.file_io_simple_op) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(EtwTraceEventWire.FILE_IO_SIMPLE_OP_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.file_io_op_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(EtwTraceEventWire.FILE_IO_OP_END_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const EtwTraceEventReader = struct {
    buf: gremlin.Reader,
    _timestamp: u64 = 0,
    _cpu: u32 = 0,
    _thread_id: u32 = 0,
    _c_switch_buf: ?[]const u8 = null,
    _ready_thread_buf: ?[]const u8 = null,
    _mem_info_buf: ?[]const u8 = null,
    _file_io_create_buf: ?[]const u8 = null,
    _file_io_dir_enum_buf: ?[]const u8 = null,
    _file_io_info_buf: ?[]const u8 = null,
    _file_io_read_write_buf: ?[]const u8 = null,
    _file_io_simple_op_buf: ?[]const u8 = null,
    _file_io_op_end_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!EtwTraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = EtwTraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                EtwTraceEventWire.TIMESTAMP_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._timestamp = result.value;
                },
                EtwTraceEventWire.CPU_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._cpu = result.value;
                },
                EtwTraceEventWire.THREAD_ID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._thread_id = result.value;
                },
                EtwTraceEventWire.C_SWITCH_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._c_switch_buf = result.value;
                },
                EtwTraceEventWire.READY_THREAD_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ready_thread_buf = result.value;
                },
                EtwTraceEventWire.MEM_INFO_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mem_info_buf = result.value;
                },
                EtwTraceEventWire.FILE_IO_CREATE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._file_io_create_buf = result.value;
                },
                EtwTraceEventWire.FILE_IO_DIR_ENUM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._file_io_dir_enum_buf = result.value;
                },
                EtwTraceEventWire.FILE_IO_INFO_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._file_io_info_buf = result.value;
                },
                EtwTraceEventWire.FILE_IO_READ_WRITE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._file_io_read_write_buf = result.value;
                },
                EtwTraceEventWire.FILE_IO_SIMPLE_OP_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._file_io_simple_op_buf = result.value;
                },
                EtwTraceEventWire.FILE_IO_OP_END_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._file_io_op_end_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getTimestamp(self: *const EtwTraceEventReader) u64 {
        return self._timestamp;
    }
    pub inline fn getCpu(self: *const EtwTraceEventReader) u32 {
        return self._cpu;
    }
    pub inline fn getThreadId(self: *const EtwTraceEventReader) u32 {
        return self._thread_id;
    }
    pub fn getCSwitch(self: *const EtwTraceEventReader) gremlin.Error!etw.CSwitchEtwEventReader {
        if (self._c_switch_buf) |buf| {
            return try etw.CSwitchEtwEventReader.init(buf);
        }
        return try etw.CSwitchEtwEventReader.init(&[_]u8{});
    }
    pub fn getReadyThread(self: *const EtwTraceEventReader) gremlin.Error!etw.ReadyThreadEtwEventReader {
        if (self._ready_thread_buf) |buf| {
            return try etw.ReadyThreadEtwEventReader.init(buf);
        }
        return try etw.ReadyThreadEtwEventReader.init(&[_]u8{});
    }
    pub fn getMemInfo(self: *const EtwTraceEventReader) gremlin.Error!etw.MemInfoEtwEventReader {
        if (self._mem_info_buf) |buf| {
            return try etw.MemInfoEtwEventReader.init(buf);
        }
        return try etw.MemInfoEtwEventReader.init(&[_]u8{});
    }
    pub fn getFileIoCreate(self: *const EtwTraceEventReader) gremlin.Error!etw.FileIoCreateEtwEventReader {
        if (self._file_io_create_buf) |buf| {
            return try etw.FileIoCreateEtwEventReader.init(buf);
        }
        return try etw.FileIoCreateEtwEventReader.init(&[_]u8{});
    }
    pub fn getFileIoDirEnum(self: *const EtwTraceEventReader) gremlin.Error!etw.FileIoDirEnumEtwEventReader {
        if (self._file_io_dir_enum_buf) |buf| {
            return try etw.FileIoDirEnumEtwEventReader.init(buf);
        }
        return try etw.FileIoDirEnumEtwEventReader.init(&[_]u8{});
    }
    pub fn getFileIoInfo(self: *const EtwTraceEventReader) gremlin.Error!etw.FileIoInfoEtwEventReader {
        if (self._file_io_info_buf) |buf| {
            return try etw.FileIoInfoEtwEventReader.init(buf);
        }
        return try etw.FileIoInfoEtwEventReader.init(&[_]u8{});
    }
    pub fn getFileIoReadWrite(self: *const EtwTraceEventReader) gremlin.Error!etw.FileIoReadWriteEtwEventReader {
        if (self._file_io_read_write_buf) |buf| {
            return try etw.FileIoReadWriteEtwEventReader.init(buf);
        }
        return try etw.FileIoReadWriteEtwEventReader.init(&[_]u8{});
    }
    pub fn getFileIoSimpleOp(self: *const EtwTraceEventReader) gremlin.Error!etw.FileIoSimpleOpEtwEventReader {
        if (self._file_io_simple_op_buf) |buf| {
            return try etw.FileIoSimpleOpEtwEventReader.init(buf);
        }
        return try etw.FileIoSimpleOpEtwEventReader.init(&[_]u8{});
    }
    pub fn getFileIoOpEnd(self: *const EtwTraceEventReader) gremlin.Error!etw.FileIoOpEndEtwEventReader {
        if (self._file_io_op_end_buf) |buf| {
            return try etw.FileIoOpEndEtwEventReader.init(buf);
        }
        return try etw.FileIoOpEndEtwEventReader.init(&[_]u8{});
    }
};
