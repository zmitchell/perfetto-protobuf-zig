// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const CSwitchEtwEventWire = struct {
    const NEW_THREAD_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const OLD_THREAD_ID_WIRE: gremlin.ProtoWireNumber = 2;
    const NEW_THREAD_PRIORITY_WIRE: gremlin.ProtoWireNumber = 3;
    const OLD_THREAD_PRIORITY_WIRE: gremlin.ProtoWireNumber = 4;
    const PREVIOUS_C_STATE_WIRE: gremlin.ProtoWireNumber = 5;
    const OLD_THREAD_WAIT_IDEAL_PROCESSOR_WIRE: gremlin.ProtoWireNumber = 9;
    const NEW_THREAD_WAIT_TIME_WIRE: gremlin.ProtoWireNumber = 10;
    const OLD_THREAD_WAIT_REASON_WIRE: gremlin.ProtoWireNumber = 6;
    const OLD_THREAD_WAIT_REASON_INT_WIRE: gremlin.ProtoWireNumber = 11;
    const OLD_THREAD_WAIT_MODE_WIRE: gremlin.ProtoWireNumber = 7;
    const OLD_THREAD_WAIT_MODE_INT_WIRE: gremlin.ProtoWireNumber = 12;
    const OLD_THREAD_STATE_WIRE: gremlin.ProtoWireNumber = 8;
    const OLD_THREAD_STATE_INT_WIRE: gremlin.ProtoWireNumber = 13;
};
pub const CSwitchEtwEvent = struct {
    // nested enums
    pub const OldThreadWaitReason = enum(i32) {
        EXECUTIVE = 0,
        FREE_PAGE = 1,
        PAGE_IN = 2,
        POOL_ALLOCATION = 3,
        DELAY_EXECUTION = 4,
        SUSPEND = 5,
        USER_REQUEST = 6,
        WR_EXECUTIVE = 7,
        WR_FREE_PAGE = 8,
        WR_PAGE_IN = 9,
        WR_POOL_ALLOCATION = 10,
        WR_DELAY_EXECUTION = 11,
        WR_SUSPENDED = 12,
        WR_USER_REQUEST = 13,
        WR_EVENT_PAIR = 14,
        WR_QUEUE = 15,
        WR_LPC_RECEIVER = 16,
        WR_LPC_REPLY = 17,
        WR_VIRTUAL_MEMORY = 18,
        WR_PAGE_OUT = 19,
        WR_RENDEZ_VOUS = 20,
        WR_KEYED_EVENT = 21,
        WR_TERMINATED = 22,
        WR_PROCESS_IN_SWAP = 23,
        WR_CPU_RATE_CONTROL = 24,
        WR_CALLOUT_STACK = 25,
        WR_KERNEL = 26,
        WR_RESOURCE = 27,
        WR_PUSH_LOCK = 28,
        WR_MUTEX = 29,
        WR_QUANTUM_END = 30,
        WR_DISPATCH_INT = 31,
        WR_PREEMPTED = 32,
        WR_YIELD_EXECUTION = 33,
        WR_FAST_MUTEX = 34,
        WR_GUARD_MUTEX = 35,
        WR_RUNDOWN = 36,
        MAXIMUM_WAIT_REASON = 37,
    };
    pub const OldThreadWaitMode = enum(i32) {
        KERNEL_MODE = 0,
        USER_MODE = 1,
    };
    pub const OldThreadState = enum(i32) {
        INITIALIZED = 0,
        READY = 1,
        RUNNING = 2,
        STANDBY = 3,
        TERMINATED = 4,
        WAITING = 5,
        TRANSITION = 6,
        DEFERRED_READY = 7,
    };
    // fields
    new_thread_id: u32 = 0,
    old_thread_id: u32 = 0,
    new_thread_priority: i32 = 0,
    old_thread_priority: i32 = 0,
    previous_c_state: u32 = 0,
    old_thread_wait_ideal_processor: i32 = 0,
    new_thread_wait_time: u32 = 0,
    old_thread_wait_reason: CSwitchEtwEvent.OldThreadWaitReason = @enumFromInt(0),
    old_thread_wait_reason_int: i32 = 0,
    old_thread_wait_mode: CSwitchEtwEvent.OldThreadWaitMode = @enumFromInt(0),
    old_thread_wait_mode_int: i32 = 0,
    old_thread_state: CSwitchEtwEvent.OldThreadState = @enumFromInt(0),
    old_thread_state_int: i32 = 0,
    pub fn calcProtobufSize(self: *const CSwitchEtwEvent) usize {
        var res: usize = 0;
        if (self.new_thread_id != 0) {
            res += gremlin.sizes.sizeWireNumber(CSwitchEtwEventWire.NEW_THREAD_ID_WIRE) + gremlin.sizes.sizeU32(self.new_thread_id);
        }
        if (self.old_thread_id != 0) {
            res += gremlin.sizes.sizeWireNumber(CSwitchEtwEventWire.OLD_THREAD_ID_WIRE) + gremlin.sizes.sizeU32(self.old_thread_id);
        }
        if (self.new_thread_priority != 0) {
            res += gremlin.sizes.sizeWireNumber(CSwitchEtwEventWire.NEW_THREAD_PRIORITY_WIRE) + gremlin.sizes.sizeSI32(self.new_thread_priority);
        }
        if (self.old_thread_priority != 0) {
            res += gremlin.sizes.sizeWireNumber(CSwitchEtwEventWire.OLD_THREAD_PRIORITY_WIRE) + gremlin.sizes.sizeSI32(self.old_thread_priority);
        }
        if (self.previous_c_state != 0) {
            res += gremlin.sizes.sizeWireNumber(CSwitchEtwEventWire.PREVIOUS_C_STATE_WIRE) + gremlin.sizes.sizeU32(self.previous_c_state);
        }
        if (self.old_thread_wait_ideal_processor != 0) {
            res += gremlin.sizes.sizeWireNumber(CSwitchEtwEventWire.OLD_THREAD_WAIT_IDEAL_PROCESSOR_WIRE) + gremlin.sizes.sizeSI32(self.old_thread_wait_ideal_processor);
        }
        if (self.new_thread_wait_time != 0) {
            res += gremlin.sizes.sizeWireNumber(CSwitchEtwEventWire.NEW_THREAD_WAIT_TIME_WIRE) + gremlin.sizes.sizeU32(self.new_thread_wait_time);
        }
        if (@intFromEnum(self.old_thread_wait_reason) != 0) {
            res += gremlin.sizes.sizeWireNumber(CSwitchEtwEventWire.OLD_THREAD_WAIT_REASON_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.old_thread_wait_reason));
        }
        if (self.old_thread_wait_reason_int != 0) {
            res += gremlin.sizes.sizeWireNumber(CSwitchEtwEventWire.OLD_THREAD_WAIT_REASON_INT_WIRE) + gremlin.sizes.sizeI32(self.old_thread_wait_reason_int);
        }
        if (@intFromEnum(self.old_thread_wait_mode) != 0) {
            res += gremlin.sizes.sizeWireNumber(CSwitchEtwEventWire.OLD_THREAD_WAIT_MODE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.old_thread_wait_mode));
        }
        if (self.old_thread_wait_mode_int != 0) {
            res += gremlin.sizes.sizeWireNumber(CSwitchEtwEventWire.OLD_THREAD_WAIT_MODE_INT_WIRE) + gremlin.sizes.sizeI32(self.old_thread_wait_mode_int);
        }
        if (@intFromEnum(self.old_thread_state) != 0) {
            res += gremlin.sizes.sizeWireNumber(CSwitchEtwEventWire.OLD_THREAD_STATE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.old_thread_state));
        }
        if (self.old_thread_state_int != 0) {
            res += gremlin.sizes.sizeWireNumber(CSwitchEtwEventWire.OLD_THREAD_STATE_INT_WIRE) + gremlin.sizes.sizeSI32(self.old_thread_state_int);
        }
        return res;
    }
    pub fn encode(self: *const CSwitchEtwEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const CSwitchEtwEvent, target: *gremlin.Writer) void {
        if (self.new_thread_id != 0) {
            target.appendUint32(CSwitchEtwEventWire.NEW_THREAD_ID_WIRE, self.new_thread_id);
        }
        if (self.old_thread_id != 0) {
            target.appendUint32(CSwitchEtwEventWire.OLD_THREAD_ID_WIRE, self.old_thread_id);
        }
        if (self.new_thread_priority != 0) {
            target.appendSint32(CSwitchEtwEventWire.NEW_THREAD_PRIORITY_WIRE, self.new_thread_priority);
        }
        if (self.old_thread_priority != 0) {
            target.appendSint32(CSwitchEtwEventWire.OLD_THREAD_PRIORITY_WIRE, self.old_thread_priority);
        }
        if (self.previous_c_state != 0) {
            target.appendUint32(CSwitchEtwEventWire.PREVIOUS_C_STATE_WIRE, self.previous_c_state);
        }
        if (self.old_thread_wait_ideal_processor != 0) {
            target.appendSint32(CSwitchEtwEventWire.OLD_THREAD_WAIT_IDEAL_PROCESSOR_WIRE, self.old_thread_wait_ideal_processor);
        }
        if (self.new_thread_wait_time != 0) {
            target.appendUint32(CSwitchEtwEventWire.NEW_THREAD_WAIT_TIME_WIRE, self.new_thread_wait_time);
        }
        if (@intFromEnum(self.old_thread_wait_reason) != 0) {
            target.appendInt32(CSwitchEtwEventWire.OLD_THREAD_WAIT_REASON_WIRE, @intFromEnum(self.old_thread_wait_reason));
        }
        if (self.old_thread_wait_reason_int != 0) {
            target.appendInt32(CSwitchEtwEventWire.OLD_THREAD_WAIT_REASON_INT_WIRE, self.old_thread_wait_reason_int);
        }
        if (@intFromEnum(self.old_thread_wait_mode) != 0) {
            target.appendInt32(CSwitchEtwEventWire.OLD_THREAD_WAIT_MODE_WIRE, @intFromEnum(self.old_thread_wait_mode));
        }
        if (self.old_thread_wait_mode_int != 0) {
            target.appendInt32(CSwitchEtwEventWire.OLD_THREAD_WAIT_MODE_INT_WIRE, self.old_thread_wait_mode_int);
        }
        if (@intFromEnum(self.old_thread_state) != 0) {
            target.appendInt32(CSwitchEtwEventWire.OLD_THREAD_STATE_WIRE, @intFromEnum(self.old_thread_state));
        }
        if (self.old_thread_state_int != 0) {
            target.appendSint32(CSwitchEtwEventWire.OLD_THREAD_STATE_INT_WIRE, self.old_thread_state_int);
        }
    }
};
pub const CSwitchEtwEventReader = struct {
    buf: gremlin.Reader,
    _new_thread_id: u32 = 0,
    _old_thread_id: u32 = 0,
    _new_thread_priority: i32 = 0,
    _old_thread_priority: i32 = 0,
    _previous_c_state: u32 = 0,
    _old_thread_wait_ideal_processor: i32 = 0,
    _new_thread_wait_time: u32 = 0,
    _old_thread_wait_reason: CSwitchEtwEvent.OldThreadWaitReason = @enumFromInt(0),
    _old_thread_wait_reason_int: i32 = 0,
    _old_thread_wait_mode: CSwitchEtwEvent.OldThreadWaitMode = @enumFromInt(0),
    _old_thread_wait_mode_int: i32 = 0,
    _old_thread_state: CSwitchEtwEvent.OldThreadState = @enumFromInt(0),
    _old_thread_state_int: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!CSwitchEtwEventReader {
        const buf = gremlin.Reader.init(src);
        var res = CSwitchEtwEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                CSwitchEtwEventWire.NEW_THREAD_ID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._new_thread_id = result.value;
                },
                CSwitchEtwEventWire.OLD_THREAD_ID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._old_thread_id = result.value;
                },
                CSwitchEtwEventWire.NEW_THREAD_PRIORITY_WIRE => {
                    const result = try buf.readSInt32(offset);
                    offset += result.size;
                    res._new_thread_priority = result.value;
                },
                CSwitchEtwEventWire.OLD_THREAD_PRIORITY_WIRE => {
                    const result = try buf.readSInt32(offset);
                    offset += result.size;
                    res._old_thread_priority = result.value;
                },
                CSwitchEtwEventWire.PREVIOUS_C_STATE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._previous_c_state = result.value;
                },
                CSwitchEtwEventWire.OLD_THREAD_WAIT_IDEAL_PROCESSOR_WIRE => {
                    const result = try buf.readSInt32(offset);
                    offset += result.size;
                    res._old_thread_wait_ideal_processor = result.value;
                },
                CSwitchEtwEventWire.NEW_THREAD_WAIT_TIME_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._new_thread_wait_time = result.value;
                },
                CSwitchEtwEventWire.OLD_THREAD_WAIT_REASON_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._old_thread_wait_reason = @enumFromInt(result.value);
                },
                CSwitchEtwEventWire.OLD_THREAD_WAIT_REASON_INT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._old_thread_wait_reason_int = result.value;
                },
                CSwitchEtwEventWire.OLD_THREAD_WAIT_MODE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._old_thread_wait_mode = @enumFromInt(result.value);
                },
                CSwitchEtwEventWire.OLD_THREAD_WAIT_MODE_INT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._old_thread_wait_mode_int = result.value;
                },
                CSwitchEtwEventWire.OLD_THREAD_STATE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._old_thread_state = @enumFromInt(result.value);
                },
                CSwitchEtwEventWire.OLD_THREAD_STATE_INT_WIRE => {
                    const result = try buf.readSInt32(offset);
                    offset += result.size;
                    res._old_thread_state_int = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getNewThreadId(self: *const CSwitchEtwEventReader) u32 {
        return self._new_thread_id;
    }
    pub inline fn getOldThreadId(self: *const CSwitchEtwEventReader) u32 {
        return self._old_thread_id;
    }
    pub inline fn getNewThreadPriority(self: *const CSwitchEtwEventReader) i32 {
        return self._new_thread_priority;
    }
    pub inline fn getOldThreadPriority(self: *const CSwitchEtwEventReader) i32 {
        return self._old_thread_priority;
    }
    pub inline fn getPreviousCState(self: *const CSwitchEtwEventReader) u32 {
        return self._previous_c_state;
    }
    pub inline fn getOldThreadWaitIdealProcessor(self: *const CSwitchEtwEventReader) i32 {
        return self._old_thread_wait_ideal_processor;
    }
    pub inline fn getNewThreadWaitTime(self: *const CSwitchEtwEventReader) u32 {
        return self._new_thread_wait_time;
    }
    pub inline fn getOldThreadWaitReason(self: *const CSwitchEtwEventReader) CSwitchEtwEvent.OldThreadWaitReason {
        return self._old_thread_wait_reason;
    }
    pub inline fn getOldThreadWaitReasonInt(self: *const CSwitchEtwEventReader) i32 {
        return self._old_thread_wait_reason_int;
    }
    pub inline fn getOldThreadWaitMode(self: *const CSwitchEtwEventReader) CSwitchEtwEvent.OldThreadWaitMode {
        return self._old_thread_wait_mode;
    }
    pub inline fn getOldThreadWaitModeInt(self: *const CSwitchEtwEventReader) i32 {
        return self._old_thread_wait_mode_int;
    }
    pub inline fn getOldThreadState(self: *const CSwitchEtwEventReader) CSwitchEtwEvent.OldThreadState {
        return self._old_thread_state;
    }
    pub inline fn getOldThreadStateInt(self: *const CSwitchEtwEventReader) i32 {
        return self._old_thread_state_int;
    }
};
const ReadyThreadEtwEventWire = struct {
    const T_THREAD_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const ADJUST_INCREMENT_WIRE: gremlin.ProtoWireNumber = 3;
    const ADJUST_REASON_WIRE: gremlin.ProtoWireNumber = 2;
    const ADJUST_REASON_INT_WIRE: gremlin.ProtoWireNumber = 5;
    const FLAG_WIRE: gremlin.ProtoWireNumber = 4;
    const FLAG_INT_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const ReadyThreadEtwEvent = struct {
    // nested enums
    pub const AdjustReason = enum(i32) {
        IGNORE_THE_INCREMENT = 0,
        APPLY_INCREMENT = 1,
        APPLY_INCREMENT_BOOST = 2,
    };
    pub const TraceFlag = enum(i32) {
        TRACE_FLAG_UNSPECIFIED = 0,
        THREAD_READIED = 1,
        KERNEL_STACK_SWAPPED_OUT = 2,
        PROCESS_ADDRESS_SWAPPED_OUT = 4,
    };
    // fields
    t_thread_id: u32 = 0,
    adjust_increment: i32 = 0,
    adjust_reason: ReadyThreadEtwEvent.AdjustReason = @enumFromInt(0),
    adjust_reason_int: i32 = 0,
    flag: ReadyThreadEtwEvent.TraceFlag = @enumFromInt(0),
    flag_int: i32 = 0,
    pub fn calcProtobufSize(self: *const ReadyThreadEtwEvent) usize {
        var res: usize = 0;
        if (self.t_thread_id != 0) {
            res += gremlin.sizes.sizeWireNumber(ReadyThreadEtwEventWire.T_THREAD_ID_WIRE) + gremlin.sizes.sizeU32(self.t_thread_id);
        }
        if (self.adjust_increment != 0) {
            res += gremlin.sizes.sizeWireNumber(ReadyThreadEtwEventWire.ADJUST_INCREMENT_WIRE) + gremlin.sizes.sizeSI32(self.adjust_increment);
        }
        if (@intFromEnum(self.adjust_reason) != 0) {
            res += gremlin.sizes.sizeWireNumber(ReadyThreadEtwEventWire.ADJUST_REASON_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.adjust_reason));
        }
        if (self.adjust_reason_int != 0) {
            res += gremlin.sizes.sizeWireNumber(ReadyThreadEtwEventWire.ADJUST_REASON_INT_WIRE) + gremlin.sizes.sizeI32(self.adjust_reason_int);
        }
        if (@intFromEnum(self.flag) != 0) {
            res += gremlin.sizes.sizeWireNumber(ReadyThreadEtwEventWire.FLAG_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.flag));
        }
        if (self.flag_int != 0) {
            res += gremlin.sizes.sizeWireNumber(ReadyThreadEtwEventWire.FLAG_INT_WIRE) + gremlin.sizes.sizeI32(self.flag_int);
        }
        return res;
    }
    pub fn encode(self: *const ReadyThreadEtwEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ReadyThreadEtwEvent, target: *gremlin.Writer) void {
        if (self.t_thread_id != 0) {
            target.appendUint32(ReadyThreadEtwEventWire.T_THREAD_ID_WIRE, self.t_thread_id);
        }
        if (self.adjust_increment != 0) {
            target.appendSint32(ReadyThreadEtwEventWire.ADJUST_INCREMENT_WIRE, self.adjust_increment);
        }
        if (@intFromEnum(self.adjust_reason) != 0) {
            target.appendInt32(ReadyThreadEtwEventWire.ADJUST_REASON_WIRE, @intFromEnum(self.adjust_reason));
        }
        if (self.adjust_reason_int != 0) {
            target.appendInt32(ReadyThreadEtwEventWire.ADJUST_REASON_INT_WIRE, self.adjust_reason_int);
        }
        if (@intFromEnum(self.flag) != 0) {
            target.appendInt32(ReadyThreadEtwEventWire.FLAG_WIRE, @intFromEnum(self.flag));
        }
        if (self.flag_int != 0) {
            target.appendInt32(ReadyThreadEtwEventWire.FLAG_INT_WIRE, self.flag_int);
        }
    }
};
pub const ReadyThreadEtwEventReader = struct {
    buf: gremlin.Reader,
    _t_thread_id: u32 = 0,
    _adjust_increment: i32 = 0,
    _adjust_reason: ReadyThreadEtwEvent.AdjustReason = @enumFromInt(0),
    _adjust_reason_int: i32 = 0,
    _flag: ReadyThreadEtwEvent.TraceFlag = @enumFromInt(0),
    _flag_int: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!ReadyThreadEtwEventReader {
        const buf = gremlin.Reader.init(src);
        var res = ReadyThreadEtwEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ReadyThreadEtwEventWire.T_THREAD_ID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._t_thread_id = result.value;
                },
                ReadyThreadEtwEventWire.ADJUST_INCREMENT_WIRE => {
                    const result = try buf.readSInt32(offset);
                    offset += result.size;
                    res._adjust_increment = result.value;
                },
                ReadyThreadEtwEventWire.ADJUST_REASON_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._adjust_reason = @enumFromInt(result.value);
                },
                ReadyThreadEtwEventWire.ADJUST_REASON_INT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._adjust_reason_int = result.value;
                },
                ReadyThreadEtwEventWire.FLAG_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._flag = @enumFromInt(result.value);
                },
                ReadyThreadEtwEventWire.FLAG_INT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._flag_int = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getTThreadId(self: *const ReadyThreadEtwEventReader) u32 {
        return self._t_thread_id;
    }
    pub inline fn getAdjustIncrement(self: *const ReadyThreadEtwEventReader) i32 {
        return self._adjust_increment;
    }
    pub inline fn getAdjustReason(self: *const ReadyThreadEtwEventReader) ReadyThreadEtwEvent.AdjustReason {
        return self._adjust_reason;
    }
    pub inline fn getAdjustReasonInt(self: *const ReadyThreadEtwEventReader) i32 {
        return self._adjust_reason_int;
    }
    pub inline fn getFlag(self: *const ReadyThreadEtwEventReader) ReadyThreadEtwEvent.TraceFlag {
        return self._flag;
    }
    pub inline fn getFlagInt(self: *const ReadyThreadEtwEventReader) i32 {
        return self._flag_int;
    }
};
const MemInfoEtwEventWire = struct {
    const PRIORITY_LEVELS_WIRE: gremlin.ProtoWireNumber = 1;
    const ZERO_PAGE_COUNT_WIRE: gremlin.ProtoWireNumber = 2;
    const FREE_PAGE_COUNT_WIRE: gremlin.ProtoWireNumber = 3;
    const MODIFIED_PAGE_COUNT_WIRE: gremlin.ProtoWireNumber = 4;
    const MODIFIED_NO_WRITE_PAGE_COUNT_WIRE: gremlin.ProtoWireNumber = 5;
    const BAD_PAGE_COUNT_WIRE: gremlin.ProtoWireNumber = 6;
    const STANDBY_PAGE_COUNTS_WIRE: gremlin.ProtoWireNumber = 7;
    const REPURPOSED_PAGE_COUNTS_WIRE: gremlin.ProtoWireNumber = 8;
    const MODIFIED_PAGE_COUNT_PAGE_FILE_WIRE: gremlin.ProtoWireNumber = 9;
    const PAGED_POOL_PAGE_COUNT_WIRE: gremlin.ProtoWireNumber = 10;
    const NON_PAGED_POOL_PAGE_COUNT_WIRE: gremlin.ProtoWireNumber = 11;
    const MDL_PAGE_COUNT_WIRE: gremlin.ProtoWireNumber = 12;
    const COMMIT_PAGE_COUNT_WIRE: gremlin.ProtoWireNumber = 13;
};
pub const MemInfoEtwEvent = struct {
    // fields
    priority_levels: u32 = 0,
    zero_page_count: u64 = 0,
    free_page_count: u64 = 0,
    modified_page_count: u64 = 0,
    modified_no_write_page_count: u64 = 0,
    bad_page_count: u64 = 0,
    standby_page_counts: ?[]const u64 = null,
    repurposed_page_counts: ?[]const u64 = null,
    modified_page_count_page_file: u64 = 0,
    paged_pool_page_count: u64 = 0,
    non_paged_pool_page_count: u64 = 0,
    mdl_page_count: u64 = 0,
    commit_page_count: u64 = 0,
    pub fn calcProtobufSize(self: *const MemInfoEtwEvent) usize {
        var res: usize = 0;
        if (self.priority_levels != 0) {
            res += gremlin.sizes.sizeWireNumber(MemInfoEtwEventWire.PRIORITY_LEVELS_WIRE) + gremlin.sizes.sizeU32(self.priority_levels);
        }
        if (self.zero_page_count != 0) {
            res += gremlin.sizes.sizeWireNumber(MemInfoEtwEventWire.ZERO_PAGE_COUNT_WIRE) + gremlin.sizes.sizeU64(self.zero_page_count);
        }
        if (self.free_page_count != 0) {
            res += gremlin.sizes.sizeWireNumber(MemInfoEtwEventWire.FREE_PAGE_COUNT_WIRE) + gremlin.sizes.sizeU64(self.free_page_count);
        }
        if (self.modified_page_count != 0) {
            res += gremlin.sizes.sizeWireNumber(MemInfoEtwEventWire.MODIFIED_PAGE_COUNT_WIRE) + gremlin.sizes.sizeU64(self.modified_page_count);
        }
        if (self.modified_no_write_page_count != 0) {
            res += gremlin.sizes.sizeWireNumber(MemInfoEtwEventWire.MODIFIED_NO_WRITE_PAGE_COUNT_WIRE) + gremlin.sizes.sizeU64(self.modified_no_write_page_count);
        }
        if (self.bad_page_count != 0) {
            res += gremlin.sizes.sizeWireNumber(MemInfoEtwEventWire.BAD_PAGE_COUNT_WIRE) + gremlin.sizes.sizeU64(self.bad_page_count);
        }
        if (self.standby_page_counts) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(MemInfoEtwEventWire.STANDBY_PAGE_COUNTS_WIRE) + gremlin.sizes.sizeU64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                res += gremlin.sizes.sizeWireNumber(MemInfoEtwEventWire.STANDBY_PAGE_COUNTS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.repurposed_page_counts) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(MemInfoEtwEventWire.REPURPOSED_PAGE_COUNTS_WIRE) + gremlin.sizes.sizeU64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                res += gremlin.sizes.sizeWireNumber(MemInfoEtwEventWire.REPURPOSED_PAGE_COUNTS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.modified_page_count_page_file != 0) {
            res += gremlin.sizes.sizeWireNumber(MemInfoEtwEventWire.MODIFIED_PAGE_COUNT_PAGE_FILE_WIRE) + gremlin.sizes.sizeU64(self.modified_page_count_page_file);
        }
        if (self.paged_pool_page_count != 0) {
            res += gremlin.sizes.sizeWireNumber(MemInfoEtwEventWire.PAGED_POOL_PAGE_COUNT_WIRE) + gremlin.sizes.sizeU64(self.paged_pool_page_count);
        }
        if (self.non_paged_pool_page_count != 0) {
            res += gremlin.sizes.sizeWireNumber(MemInfoEtwEventWire.NON_PAGED_POOL_PAGE_COUNT_WIRE) + gremlin.sizes.sizeU64(self.non_paged_pool_page_count);
        }
        if (self.mdl_page_count != 0) {
            res += gremlin.sizes.sizeWireNumber(MemInfoEtwEventWire.MDL_PAGE_COUNT_WIRE) + gremlin.sizes.sizeU64(self.mdl_page_count);
        }
        if (self.commit_page_count != 0) {
            res += gremlin.sizes.sizeWireNumber(MemInfoEtwEventWire.COMMIT_PAGE_COUNT_WIRE) + gremlin.sizes.sizeU64(self.commit_page_count);
        }
        return res;
    }
    pub fn encode(self: *const MemInfoEtwEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const MemInfoEtwEvent, target: *gremlin.Writer) void {
        if (self.priority_levels != 0) {
            target.appendUint32(MemInfoEtwEventWire.PRIORITY_LEVELS_WIRE, self.priority_levels);
        }
        if (self.zero_page_count != 0) {
            target.appendUint64(MemInfoEtwEventWire.ZERO_PAGE_COUNT_WIRE, self.zero_page_count);
        }
        if (self.free_page_count != 0) {
            target.appendUint64(MemInfoEtwEventWire.FREE_PAGE_COUNT_WIRE, self.free_page_count);
        }
        if (self.modified_page_count != 0) {
            target.appendUint64(MemInfoEtwEventWire.MODIFIED_PAGE_COUNT_WIRE, self.modified_page_count);
        }
        if (self.modified_no_write_page_count != 0) {
            target.appendUint64(MemInfoEtwEventWire.MODIFIED_NO_WRITE_PAGE_COUNT_WIRE, self.modified_no_write_page_count);
        }
        if (self.bad_page_count != 0) {
            target.appendUint64(MemInfoEtwEventWire.BAD_PAGE_COUNT_WIRE, self.bad_page_count);
        }
        if (self.standby_page_counts) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint64(MemInfoEtwEventWire.STANDBY_PAGE_COUNTS_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                target.appendBytesTag(MemInfoEtwEventWire.STANDBY_PAGE_COUNTS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint64WithoutTag(v);
                }
            }
        }
        if (self.repurposed_page_counts) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint64(MemInfoEtwEventWire.REPURPOSED_PAGE_COUNTS_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                target.appendBytesTag(MemInfoEtwEventWire.REPURPOSED_PAGE_COUNTS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint64WithoutTag(v);
                }
            }
        }
        if (self.modified_page_count_page_file != 0) {
            target.appendUint64(MemInfoEtwEventWire.MODIFIED_PAGE_COUNT_PAGE_FILE_WIRE, self.modified_page_count_page_file);
        }
        if (self.paged_pool_page_count != 0) {
            target.appendUint64(MemInfoEtwEventWire.PAGED_POOL_PAGE_COUNT_WIRE, self.paged_pool_page_count);
        }
        if (self.non_paged_pool_page_count != 0) {
            target.appendUint64(MemInfoEtwEventWire.NON_PAGED_POOL_PAGE_COUNT_WIRE, self.non_paged_pool_page_count);
        }
        if (self.mdl_page_count != 0) {
            target.appendUint64(MemInfoEtwEventWire.MDL_PAGE_COUNT_WIRE, self.mdl_page_count);
        }
        if (self.commit_page_count != 0) {
            target.appendUint64(MemInfoEtwEventWire.COMMIT_PAGE_COUNT_WIRE, self.commit_page_count);
        }
    }
};
pub const MemInfoEtwEventReader = struct {
    buf: gremlin.Reader,
    _priority_levels: u32 = 0,
    _zero_page_count: u64 = 0,
    _free_page_count: u64 = 0,
    _modified_page_count: u64 = 0,
    _modified_no_write_page_count: u64 = 0,
    _bad_page_count: u64 = 0,
    _standby_page_counts_offset: ?usize = null,
    _standby_page_counts_last_offset: ?usize = null,
    _standby_page_counts_packed: bool = false,
    _repurposed_page_counts_offset: ?usize = null,
    _repurposed_page_counts_last_offset: ?usize = null,
    _repurposed_page_counts_packed: bool = false,
    _modified_page_count_page_file: u64 = 0,
    _paged_pool_page_count: u64 = 0,
    _non_paged_pool_page_count: u64 = 0,
    _mdl_page_count: u64 = 0,
    _commit_page_count: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!MemInfoEtwEventReader {
        const buf = gremlin.Reader.init(src);
        var res = MemInfoEtwEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MemInfoEtwEventWire.PRIORITY_LEVELS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._priority_levels = result.value;
                },
                MemInfoEtwEventWire.ZERO_PAGE_COUNT_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._zero_page_count = result.value;
                },
                MemInfoEtwEventWire.FREE_PAGE_COUNT_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._free_page_count = result.value;
                },
                MemInfoEtwEventWire.MODIFIED_PAGE_COUNT_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._modified_page_count = result.value;
                },
                MemInfoEtwEventWire.MODIFIED_NO_WRITE_PAGE_COUNT_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._modified_no_write_page_count = result.value;
                },
                MemInfoEtwEventWire.BAD_PAGE_COUNT_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._bad_page_count = result.value;
                },
                MemInfoEtwEventWire.STANDBY_PAGE_COUNTS_WIRE => {
                    if (res._standby_page_counts_offset == null) {
                        res._standby_page_counts_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._standby_page_counts_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._standby_page_counts_offset = offset + length_result.size;
                        res._standby_page_counts_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._standby_page_counts_last_offset.?;
                    } else {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._standby_page_counts_last_offset = offset;
                    }
                },
                MemInfoEtwEventWire.REPURPOSED_PAGE_COUNTS_WIRE => {
                    if (res._repurposed_page_counts_offset == null) {
                        res._repurposed_page_counts_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._repurposed_page_counts_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._repurposed_page_counts_offset = offset + length_result.size;
                        res._repurposed_page_counts_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._repurposed_page_counts_last_offset.?;
                    } else {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._repurposed_page_counts_last_offset = offset;
                    }
                },
                MemInfoEtwEventWire.MODIFIED_PAGE_COUNT_PAGE_FILE_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._modified_page_count_page_file = result.value;
                },
                MemInfoEtwEventWire.PAGED_POOL_PAGE_COUNT_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._paged_pool_page_count = result.value;
                },
                MemInfoEtwEventWire.NON_PAGED_POOL_PAGE_COUNT_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._non_paged_pool_page_count = result.value;
                },
                MemInfoEtwEventWire.MDL_PAGE_COUNT_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._mdl_page_count = result.value;
                },
                MemInfoEtwEventWire.COMMIT_PAGE_COUNT_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._commit_page_count = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getPriorityLevels(self: *const MemInfoEtwEventReader) u32 {
        return self._priority_levels;
    }
    pub inline fn getZeroPageCount(self: *const MemInfoEtwEventReader) u64 {
        return self._zero_page_count;
    }
    pub inline fn getFreePageCount(self: *const MemInfoEtwEventReader) u64 {
        return self._free_page_count;
    }
    pub inline fn getModifiedPageCount(self: *const MemInfoEtwEventReader) u64 {
        return self._modified_page_count;
    }
    pub inline fn getModifiedNoWritePageCount(self: *const MemInfoEtwEventReader) u64 {
        return self._modified_no_write_page_count;
    }
    pub inline fn getBadPageCount(self: *const MemInfoEtwEventReader) u64 {
        return self._bad_page_count;
    }
    pub fn standbyPageCountsNext(self: *MemInfoEtwEventReader) gremlin.Error!?u64 {
        if (self._standby_page_counts_offset == null) return null;
        const current_offset = self._standby_page_counts_offset.?;
        if (current_offset >= self._standby_page_counts_last_offset.?) {
            self._standby_page_counts_offset = null;
            return null;
        }
        if (self._standby_page_counts_packed) {
            const value_result = try self.buf.readUInt64(current_offset);
            self._standby_page_counts_offset = current_offset + value_result.size;
            if (self._standby_page_counts_offset.? >= self._standby_page_counts_last_offset.?) {
                self._standby_page_counts_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._standby_page_counts_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == MemInfoEtwEventWire.STANDBY_PAGE_COUNTS_WIRE) {
                    self._standby_page_counts_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._standby_page_counts_offset = null;
            return value_result.value;
        }
    }
    pub fn repurposedPageCountsNext(self: *MemInfoEtwEventReader) gremlin.Error!?u64 {
        if (self._repurposed_page_counts_offset == null) return null;
        const current_offset = self._repurposed_page_counts_offset.?;
        if (current_offset >= self._repurposed_page_counts_last_offset.?) {
            self._repurposed_page_counts_offset = null;
            return null;
        }
        if (self._repurposed_page_counts_packed) {
            const value_result = try self.buf.readUInt64(current_offset);
            self._repurposed_page_counts_offset = current_offset + value_result.size;
            if (self._repurposed_page_counts_offset.? >= self._repurposed_page_counts_last_offset.?) {
                self._repurposed_page_counts_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._repurposed_page_counts_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == MemInfoEtwEventWire.REPURPOSED_PAGE_COUNTS_WIRE) {
                    self._repurposed_page_counts_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._repurposed_page_counts_offset = null;
            return value_result.value;
        }
    }
    pub inline fn getModifiedPageCountPageFile(self: *const MemInfoEtwEventReader) u64 {
        return self._modified_page_count_page_file;
    }
    pub inline fn getPagedPoolPageCount(self: *const MemInfoEtwEventReader) u64 {
        return self._paged_pool_page_count;
    }
    pub inline fn getNonPagedPoolPageCount(self: *const MemInfoEtwEventReader) u64 {
        return self._non_paged_pool_page_count;
    }
    pub inline fn getMdlPageCount(self: *const MemInfoEtwEventReader) u64 {
        return self._mdl_page_count;
    }
    pub inline fn getCommitPageCount(self: *const MemInfoEtwEventReader) u64 {
        return self._commit_page_count;
    }
};
const FileIoCreateEtwEventWire = struct {
    const IRP_PTR_WIRE: gremlin.ProtoWireNumber = 1;
    const FILE_OBJECT_WIRE: gremlin.ProtoWireNumber = 2;
    const TTID_WIRE: gremlin.ProtoWireNumber = 3;
    const CREATE_OPTIONS_WIRE: gremlin.ProtoWireNumber = 4;
    const FILE_ATTRIBUTES_WIRE: gremlin.ProtoWireNumber = 5;
    const SHARE_ACCESS_WIRE: gremlin.ProtoWireNumber = 6;
    const OPEN_PATH_WIRE: gremlin.ProtoWireNumber = 7;
};
pub const FileIoCreateEtwEvent = struct {
    // fields
    irp_ptr: u64 = 0,
    file_object: u64 = 0,
    ttid: u32 = 0,
    create_options: u32 = 0,
    file_attributes: u32 = 0,
    share_access: u32 = 0,
    open_path: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const FileIoCreateEtwEvent) usize {
        var res: usize = 0;
        if (self.irp_ptr != 0) {
            res += gremlin.sizes.sizeWireNumber(FileIoCreateEtwEventWire.IRP_PTR_WIRE) + gremlin.sizes.sizeU64(self.irp_ptr);
        }
        if (self.file_object != 0) {
            res += gremlin.sizes.sizeWireNumber(FileIoCreateEtwEventWire.FILE_OBJECT_WIRE) + gremlin.sizes.sizeU64(self.file_object);
        }
        if (self.ttid != 0) {
            res += gremlin.sizes.sizeWireNumber(FileIoCreateEtwEventWire.TTID_WIRE) + gremlin.sizes.sizeU32(self.ttid);
        }
        if (self.create_options != 0) {
            res += gremlin.sizes.sizeWireNumber(FileIoCreateEtwEventWire.CREATE_OPTIONS_WIRE) + gremlin.sizes.sizeU32(self.create_options);
        }
        if (self.file_attributes != 0) {
            res += gremlin.sizes.sizeWireNumber(FileIoCreateEtwEventWire.FILE_ATTRIBUTES_WIRE) + gremlin.sizes.sizeU32(self.file_attributes);
        }
        if (self.share_access != 0) {
            res += gremlin.sizes.sizeWireNumber(FileIoCreateEtwEventWire.SHARE_ACCESS_WIRE) + gremlin.sizes.sizeU32(self.share_access);
        }
        if (self.open_path) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(FileIoCreateEtwEventWire.OPEN_PATH_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const FileIoCreateEtwEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const FileIoCreateEtwEvent, target: *gremlin.Writer) void {
        if (self.irp_ptr != 0) {
            target.appendUint64(FileIoCreateEtwEventWire.IRP_PTR_WIRE, self.irp_ptr);
        }
        if (self.file_object != 0) {
            target.appendUint64(FileIoCreateEtwEventWire.FILE_OBJECT_WIRE, self.file_object);
        }
        if (self.ttid != 0) {
            target.appendUint32(FileIoCreateEtwEventWire.TTID_WIRE, self.ttid);
        }
        if (self.create_options != 0) {
            target.appendUint32(FileIoCreateEtwEventWire.CREATE_OPTIONS_WIRE, self.create_options);
        }
        if (self.file_attributes != 0) {
            target.appendUint32(FileIoCreateEtwEventWire.FILE_ATTRIBUTES_WIRE, self.file_attributes);
        }
        if (self.share_access != 0) {
            target.appendUint32(FileIoCreateEtwEventWire.SHARE_ACCESS_WIRE, self.share_access);
        }
        if (self.open_path) |v| {
            if (v.len > 0) {
                target.appendBytes(FileIoCreateEtwEventWire.OPEN_PATH_WIRE, v);
            }
        }
    }
};
pub const FileIoCreateEtwEventReader = struct {
    buf: gremlin.Reader,
    _irp_ptr: u64 = 0,
    _file_object: u64 = 0,
    _ttid: u32 = 0,
    _create_options: u32 = 0,
    _file_attributes: u32 = 0,
    _share_access: u32 = 0,
    _open_path: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!FileIoCreateEtwEventReader {
        const buf = gremlin.Reader.init(src);
        var res = FileIoCreateEtwEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                FileIoCreateEtwEventWire.IRP_PTR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._irp_ptr = result.value;
                },
                FileIoCreateEtwEventWire.FILE_OBJECT_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._file_object = result.value;
                },
                FileIoCreateEtwEventWire.TTID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._ttid = result.value;
                },
                FileIoCreateEtwEventWire.CREATE_OPTIONS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._create_options = result.value;
                },
                FileIoCreateEtwEventWire.FILE_ATTRIBUTES_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._file_attributes = result.value;
                },
                FileIoCreateEtwEventWire.SHARE_ACCESS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._share_access = result.value;
                },
                FileIoCreateEtwEventWire.OPEN_PATH_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._open_path = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getIrpPtr(self: *const FileIoCreateEtwEventReader) u64 {
        return self._irp_ptr;
    }
    pub inline fn getFileObject(self: *const FileIoCreateEtwEventReader) u64 {
        return self._file_object;
    }
    pub inline fn getTtid(self: *const FileIoCreateEtwEventReader) u32 {
        return self._ttid;
    }
    pub inline fn getCreateOptions(self: *const FileIoCreateEtwEventReader) u32 {
        return self._create_options;
    }
    pub inline fn getFileAttributes(self: *const FileIoCreateEtwEventReader) u32 {
        return self._file_attributes;
    }
    pub inline fn getShareAccess(self: *const FileIoCreateEtwEventReader) u32 {
        return self._share_access;
    }
    pub inline fn getOpenPath(self: *const FileIoCreateEtwEventReader) []const u8 {
        return self._open_path orelse &[_]u8{};
    }
};
const FileIoDirEnumEtwEventWire = struct {
    const IRP_PTR_WIRE: gremlin.ProtoWireNumber = 1;
    const FILE_OBJECT_WIRE: gremlin.ProtoWireNumber = 2;
    const FILE_KEY_WIRE: gremlin.ProtoWireNumber = 3;
    const TTID_WIRE: gremlin.ProtoWireNumber = 4;
    const LENGTH_WIRE: gremlin.ProtoWireNumber = 5;
    const INFO_CLASS_WIRE: gremlin.ProtoWireNumber = 6;
    const FILE_INDEX_WIRE: gremlin.ProtoWireNumber = 7;
    const FILE_NAME_WIRE: gremlin.ProtoWireNumber = 8;
};
pub const FileIoDirEnumEtwEvent = struct {
    // fields
    irp_ptr: u64 = 0,
    file_object: u64 = 0,
    file_key: u64 = 0,
    ttid: u32 = 0,
    length: u32 = 0,
    info_class: u32 = 0,
    file_index: u32 = 0,
    file_name: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const FileIoDirEnumEtwEvent) usize {
        var res: usize = 0;
        if (self.irp_ptr != 0) {
            res += gremlin.sizes.sizeWireNumber(FileIoDirEnumEtwEventWire.IRP_PTR_WIRE) + gremlin.sizes.sizeU64(self.irp_ptr);
        }
        if (self.file_object != 0) {
            res += gremlin.sizes.sizeWireNumber(FileIoDirEnumEtwEventWire.FILE_OBJECT_WIRE) + gremlin.sizes.sizeU64(self.file_object);
        }
        if (self.file_key != 0) {
            res += gremlin.sizes.sizeWireNumber(FileIoDirEnumEtwEventWire.FILE_KEY_WIRE) + gremlin.sizes.sizeU64(self.file_key);
        }
        if (self.ttid != 0) {
            res += gremlin.sizes.sizeWireNumber(FileIoDirEnumEtwEventWire.TTID_WIRE) + gremlin.sizes.sizeU32(self.ttid);
        }
        if (self.length != 0) {
            res += gremlin.sizes.sizeWireNumber(FileIoDirEnumEtwEventWire.LENGTH_WIRE) + gremlin.sizes.sizeU32(self.length);
        }
        if (self.info_class != 0) {
            res += gremlin.sizes.sizeWireNumber(FileIoDirEnumEtwEventWire.INFO_CLASS_WIRE) + gremlin.sizes.sizeU32(self.info_class);
        }
        if (self.file_index != 0) {
            res += gremlin.sizes.sizeWireNumber(FileIoDirEnumEtwEventWire.FILE_INDEX_WIRE) + gremlin.sizes.sizeU32(self.file_index);
        }
        if (self.file_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(FileIoDirEnumEtwEventWire.FILE_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const FileIoDirEnumEtwEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const FileIoDirEnumEtwEvent, target: *gremlin.Writer) void {
        if (self.irp_ptr != 0) {
            target.appendUint64(FileIoDirEnumEtwEventWire.IRP_PTR_WIRE, self.irp_ptr);
        }
        if (self.file_object != 0) {
            target.appendUint64(FileIoDirEnumEtwEventWire.FILE_OBJECT_WIRE, self.file_object);
        }
        if (self.file_key != 0) {
            target.appendUint64(FileIoDirEnumEtwEventWire.FILE_KEY_WIRE, self.file_key);
        }
        if (self.ttid != 0) {
            target.appendUint32(FileIoDirEnumEtwEventWire.TTID_WIRE, self.ttid);
        }
        if (self.length != 0) {
            target.appendUint32(FileIoDirEnumEtwEventWire.LENGTH_WIRE, self.length);
        }
        if (self.info_class != 0) {
            target.appendUint32(FileIoDirEnumEtwEventWire.INFO_CLASS_WIRE, self.info_class);
        }
        if (self.file_index != 0) {
            target.appendUint32(FileIoDirEnumEtwEventWire.FILE_INDEX_WIRE, self.file_index);
        }
        if (self.file_name) |v| {
            if (v.len > 0) {
                target.appendBytes(FileIoDirEnumEtwEventWire.FILE_NAME_WIRE, v);
            }
        }
    }
};
pub const FileIoDirEnumEtwEventReader = struct {
    buf: gremlin.Reader,
    _irp_ptr: u64 = 0,
    _file_object: u64 = 0,
    _file_key: u64 = 0,
    _ttid: u32 = 0,
    _length: u32 = 0,
    _info_class: u32 = 0,
    _file_index: u32 = 0,
    _file_name: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!FileIoDirEnumEtwEventReader {
        const buf = gremlin.Reader.init(src);
        var res = FileIoDirEnumEtwEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                FileIoDirEnumEtwEventWire.IRP_PTR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._irp_ptr = result.value;
                },
                FileIoDirEnumEtwEventWire.FILE_OBJECT_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._file_object = result.value;
                },
                FileIoDirEnumEtwEventWire.FILE_KEY_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._file_key = result.value;
                },
                FileIoDirEnumEtwEventWire.TTID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._ttid = result.value;
                },
                FileIoDirEnumEtwEventWire.LENGTH_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._length = result.value;
                },
                FileIoDirEnumEtwEventWire.INFO_CLASS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._info_class = result.value;
                },
                FileIoDirEnumEtwEventWire.FILE_INDEX_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._file_index = result.value;
                },
                FileIoDirEnumEtwEventWire.FILE_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._file_name = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getIrpPtr(self: *const FileIoDirEnumEtwEventReader) u64 {
        return self._irp_ptr;
    }
    pub inline fn getFileObject(self: *const FileIoDirEnumEtwEventReader) u64 {
        return self._file_object;
    }
    pub inline fn getFileKey(self: *const FileIoDirEnumEtwEventReader) u64 {
        return self._file_key;
    }
    pub inline fn getTtid(self: *const FileIoDirEnumEtwEventReader) u32 {
        return self._ttid;
    }
    pub inline fn getLength(self: *const FileIoDirEnumEtwEventReader) u32 {
        return self._length;
    }
    pub inline fn getInfoClass(self: *const FileIoDirEnumEtwEventReader) u32 {
        return self._info_class;
    }
    pub inline fn getFileIndex(self: *const FileIoDirEnumEtwEventReader) u32 {
        return self._file_index;
    }
    pub inline fn getFileName(self: *const FileIoDirEnumEtwEventReader) []const u8 {
        return self._file_name orelse &[_]u8{};
    }
};
const FileIoInfoEtwEventWire = struct {
    const IRP_PTR_WIRE: gremlin.ProtoWireNumber = 1;
    const FILE_OBJECT_WIRE: gremlin.ProtoWireNumber = 2;
    const FILE_KEY_WIRE: gremlin.ProtoWireNumber = 3;
    const EXTRA_INFO_WIRE: gremlin.ProtoWireNumber = 4;
    const TTID_WIRE: gremlin.ProtoWireNumber = 5;
    const INFO_CLASS_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const FileIoInfoEtwEvent = struct {
    // fields
    irp_ptr: u64 = 0,
    file_object: u64 = 0,
    file_key: u64 = 0,
    extra_info: u64 = 0,
    ttid: u32 = 0,
    info_class: u32 = 0,
    pub fn calcProtobufSize(self: *const FileIoInfoEtwEvent) usize {
        var res: usize = 0;
        if (self.irp_ptr != 0) {
            res += gremlin.sizes.sizeWireNumber(FileIoInfoEtwEventWire.IRP_PTR_WIRE) + gremlin.sizes.sizeU64(self.irp_ptr);
        }
        if (self.file_object != 0) {
            res += gremlin.sizes.sizeWireNumber(FileIoInfoEtwEventWire.FILE_OBJECT_WIRE) + gremlin.sizes.sizeU64(self.file_object);
        }
        if (self.file_key != 0) {
            res += gremlin.sizes.sizeWireNumber(FileIoInfoEtwEventWire.FILE_KEY_WIRE) + gremlin.sizes.sizeU64(self.file_key);
        }
        if (self.extra_info != 0) {
            res += gremlin.sizes.sizeWireNumber(FileIoInfoEtwEventWire.EXTRA_INFO_WIRE) + gremlin.sizes.sizeU64(self.extra_info);
        }
        if (self.ttid != 0) {
            res += gremlin.sizes.sizeWireNumber(FileIoInfoEtwEventWire.TTID_WIRE) + gremlin.sizes.sizeU32(self.ttid);
        }
        if (self.info_class != 0) {
            res += gremlin.sizes.sizeWireNumber(FileIoInfoEtwEventWire.INFO_CLASS_WIRE) + gremlin.sizes.sizeU32(self.info_class);
        }
        return res;
    }
    pub fn encode(self: *const FileIoInfoEtwEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const FileIoInfoEtwEvent, target: *gremlin.Writer) void {
        if (self.irp_ptr != 0) {
            target.appendUint64(FileIoInfoEtwEventWire.IRP_PTR_WIRE, self.irp_ptr);
        }
        if (self.file_object != 0) {
            target.appendUint64(FileIoInfoEtwEventWire.FILE_OBJECT_WIRE, self.file_object);
        }
        if (self.file_key != 0) {
            target.appendUint64(FileIoInfoEtwEventWire.FILE_KEY_WIRE, self.file_key);
        }
        if (self.extra_info != 0) {
            target.appendUint64(FileIoInfoEtwEventWire.EXTRA_INFO_WIRE, self.extra_info);
        }
        if (self.ttid != 0) {
            target.appendUint32(FileIoInfoEtwEventWire.TTID_WIRE, self.ttid);
        }
        if (self.info_class != 0) {
            target.appendUint32(FileIoInfoEtwEventWire.INFO_CLASS_WIRE, self.info_class);
        }
    }
};
pub const FileIoInfoEtwEventReader = struct {
    buf: gremlin.Reader,
    _irp_ptr: u64 = 0,
    _file_object: u64 = 0,
    _file_key: u64 = 0,
    _extra_info: u64 = 0,
    _ttid: u32 = 0,
    _info_class: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!FileIoInfoEtwEventReader {
        const buf = gremlin.Reader.init(src);
        var res = FileIoInfoEtwEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                FileIoInfoEtwEventWire.IRP_PTR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._irp_ptr = result.value;
                },
                FileIoInfoEtwEventWire.FILE_OBJECT_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._file_object = result.value;
                },
                FileIoInfoEtwEventWire.FILE_KEY_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._file_key = result.value;
                },
                FileIoInfoEtwEventWire.EXTRA_INFO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._extra_info = result.value;
                },
                FileIoInfoEtwEventWire.TTID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._ttid = result.value;
                },
                FileIoInfoEtwEventWire.INFO_CLASS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._info_class = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getIrpPtr(self: *const FileIoInfoEtwEventReader) u64 {
        return self._irp_ptr;
    }
    pub inline fn getFileObject(self: *const FileIoInfoEtwEventReader) u64 {
        return self._file_object;
    }
    pub inline fn getFileKey(self: *const FileIoInfoEtwEventReader) u64 {
        return self._file_key;
    }
    pub inline fn getExtraInfo(self: *const FileIoInfoEtwEventReader) u64 {
        return self._extra_info;
    }
    pub inline fn getTtid(self: *const FileIoInfoEtwEventReader) u32 {
        return self._ttid;
    }
    pub inline fn getInfoClass(self: *const FileIoInfoEtwEventReader) u32 {
        return self._info_class;
    }
};
const FileIoReadWriteEtwEventWire = struct {
    const OFFSET_WIRE: gremlin.ProtoWireNumber = 1;
    const IRP_PTR_WIRE: gremlin.ProtoWireNumber = 2;
    const FILE_OBJECT_WIRE: gremlin.ProtoWireNumber = 3;
    const FILE_KEY_WIRE: gremlin.ProtoWireNumber = 4;
    const TTID_WIRE: gremlin.ProtoWireNumber = 5;
    const IO_SIZE_WIRE: gremlin.ProtoWireNumber = 6;
    const IO_FLAGS_WIRE: gremlin.ProtoWireNumber = 7;
};
pub const FileIoReadWriteEtwEvent = struct {
    // fields
    offset: u64 = 0,
    irp_ptr: u64 = 0,
    file_object: u64 = 0,
    file_key: u64 = 0,
    ttid: u32 = 0,
    io_size: u32 = 0,
    io_flags: u32 = 0,
    pub fn calcProtobufSize(self: *const FileIoReadWriteEtwEvent) usize {
        var res: usize = 0;
        if (self.offset != 0) {
            res += gremlin.sizes.sizeWireNumber(FileIoReadWriteEtwEventWire.OFFSET_WIRE) + gremlin.sizes.sizeU64(self.offset);
        }
        if (self.irp_ptr != 0) {
            res += gremlin.sizes.sizeWireNumber(FileIoReadWriteEtwEventWire.IRP_PTR_WIRE) + gremlin.sizes.sizeU64(self.irp_ptr);
        }
        if (self.file_object != 0) {
            res += gremlin.sizes.sizeWireNumber(FileIoReadWriteEtwEventWire.FILE_OBJECT_WIRE) + gremlin.sizes.sizeU64(self.file_object);
        }
        if (self.file_key != 0) {
            res += gremlin.sizes.sizeWireNumber(FileIoReadWriteEtwEventWire.FILE_KEY_WIRE) + gremlin.sizes.sizeU64(self.file_key);
        }
        if (self.ttid != 0) {
            res += gremlin.sizes.sizeWireNumber(FileIoReadWriteEtwEventWire.TTID_WIRE) + gremlin.sizes.sizeU32(self.ttid);
        }
        if (self.io_size != 0) {
            res += gremlin.sizes.sizeWireNumber(FileIoReadWriteEtwEventWire.IO_SIZE_WIRE) + gremlin.sizes.sizeU32(self.io_size);
        }
        if (self.io_flags != 0) {
            res += gremlin.sizes.sizeWireNumber(FileIoReadWriteEtwEventWire.IO_FLAGS_WIRE) + gremlin.sizes.sizeU32(self.io_flags);
        }
        return res;
    }
    pub fn encode(self: *const FileIoReadWriteEtwEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const FileIoReadWriteEtwEvent, target: *gremlin.Writer) void {
        if (self.offset != 0) {
            target.appendUint64(FileIoReadWriteEtwEventWire.OFFSET_WIRE, self.offset);
        }
        if (self.irp_ptr != 0) {
            target.appendUint64(FileIoReadWriteEtwEventWire.IRP_PTR_WIRE, self.irp_ptr);
        }
        if (self.file_object != 0) {
            target.appendUint64(FileIoReadWriteEtwEventWire.FILE_OBJECT_WIRE, self.file_object);
        }
        if (self.file_key != 0) {
            target.appendUint64(FileIoReadWriteEtwEventWire.FILE_KEY_WIRE, self.file_key);
        }
        if (self.ttid != 0) {
            target.appendUint32(FileIoReadWriteEtwEventWire.TTID_WIRE, self.ttid);
        }
        if (self.io_size != 0) {
            target.appendUint32(FileIoReadWriteEtwEventWire.IO_SIZE_WIRE, self.io_size);
        }
        if (self.io_flags != 0) {
            target.appendUint32(FileIoReadWriteEtwEventWire.IO_FLAGS_WIRE, self.io_flags);
        }
    }
};
pub const FileIoReadWriteEtwEventReader = struct {
    buf: gremlin.Reader,
    _offset: u64 = 0,
    _irp_ptr: u64 = 0,
    _file_object: u64 = 0,
    _file_key: u64 = 0,
    _ttid: u32 = 0,
    _io_size: u32 = 0,
    _io_flags: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!FileIoReadWriteEtwEventReader {
        const buf = gremlin.Reader.init(src);
        var res = FileIoReadWriteEtwEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                FileIoReadWriteEtwEventWire.OFFSET_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._offset = result.value;
                },
                FileIoReadWriteEtwEventWire.IRP_PTR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._irp_ptr = result.value;
                },
                FileIoReadWriteEtwEventWire.FILE_OBJECT_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._file_object = result.value;
                },
                FileIoReadWriteEtwEventWire.FILE_KEY_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._file_key = result.value;
                },
                FileIoReadWriteEtwEventWire.TTID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._ttid = result.value;
                },
                FileIoReadWriteEtwEventWire.IO_SIZE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._io_size = result.value;
                },
                FileIoReadWriteEtwEventWire.IO_FLAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._io_flags = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getOffset(self: *const FileIoReadWriteEtwEventReader) u64 {
        return self._offset;
    }
    pub inline fn getIrpPtr(self: *const FileIoReadWriteEtwEventReader) u64 {
        return self._irp_ptr;
    }
    pub inline fn getFileObject(self: *const FileIoReadWriteEtwEventReader) u64 {
        return self._file_object;
    }
    pub inline fn getFileKey(self: *const FileIoReadWriteEtwEventReader) u64 {
        return self._file_key;
    }
    pub inline fn getTtid(self: *const FileIoReadWriteEtwEventReader) u32 {
        return self._ttid;
    }
    pub inline fn getIoSize(self: *const FileIoReadWriteEtwEventReader) u32 {
        return self._io_size;
    }
    pub inline fn getIoFlags(self: *const FileIoReadWriteEtwEventReader) u32 {
        return self._io_flags;
    }
};
const FileIoSimpleOpEtwEventWire = struct {
    const IRP_PTR_WIRE: gremlin.ProtoWireNumber = 1;
    const FILE_OBJECT_WIRE: gremlin.ProtoWireNumber = 2;
    const FILE_KEY_WIRE: gremlin.ProtoWireNumber = 3;
    const TTID_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const FileIoSimpleOpEtwEvent = struct {
    // fields
    irp_ptr: u64 = 0,
    file_object: u64 = 0,
    file_key: u64 = 0,
    ttid: u32 = 0,
    pub fn calcProtobufSize(self: *const FileIoSimpleOpEtwEvent) usize {
        var res: usize = 0;
        if (self.irp_ptr != 0) {
            res += gremlin.sizes.sizeWireNumber(FileIoSimpleOpEtwEventWire.IRP_PTR_WIRE) + gremlin.sizes.sizeU64(self.irp_ptr);
        }
        if (self.file_object != 0) {
            res += gremlin.sizes.sizeWireNumber(FileIoSimpleOpEtwEventWire.FILE_OBJECT_WIRE) + gremlin.sizes.sizeU64(self.file_object);
        }
        if (self.file_key != 0) {
            res += gremlin.sizes.sizeWireNumber(FileIoSimpleOpEtwEventWire.FILE_KEY_WIRE) + gremlin.sizes.sizeU64(self.file_key);
        }
        if (self.ttid != 0) {
            res += gremlin.sizes.sizeWireNumber(FileIoSimpleOpEtwEventWire.TTID_WIRE) + gremlin.sizes.sizeU32(self.ttid);
        }
        return res;
    }
    pub fn encode(self: *const FileIoSimpleOpEtwEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const FileIoSimpleOpEtwEvent, target: *gremlin.Writer) void {
        if (self.irp_ptr != 0) {
            target.appendUint64(FileIoSimpleOpEtwEventWire.IRP_PTR_WIRE, self.irp_ptr);
        }
        if (self.file_object != 0) {
            target.appendUint64(FileIoSimpleOpEtwEventWire.FILE_OBJECT_WIRE, self.file_object);
        }
        if (self.file_key != 0) {
            target.appendUint64(FileIoSimpleOpEtwEventWire.FILE_KEY_WIRE, self.file_key);
        }
        if (self.ttid != 0) {
            target.appendUint32(FileIoSimpleOpEtwEventWire.TTID_WIRE, self.ttid);
        }
    }
};
pub const FileIoSimpleOpEtwEventReader = struct {
    buf: gremlin.Reader,
    _irp_ptr: u64 = 0,
    _file_object: u64 = 0,
    _file_key: u64 = 0,
    _ttid: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!FileIoSimpleOpEtwEventReader {
        const buf = gremlin.Reader.init(src);
        var res = FileIoSimpleOpEtwEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                FileIoSimpleOpEtwEventWire.IRP_PTR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._irp_ptr = result.value;
                },
                FileIoSimpleOpEtwEventWire.FILE_OBJECT_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._file_object = result.value;
                },
                FileIoSimpleOpEtwEventWire.FILE_KEY_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._file_key = result.value;
                },
                FileIoSimpleOpEtwEventWire.TTID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._ttid = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getIrpPtr(self: *const FileIoSimpleOpEtwEventReader) u64 {
        return self._irp_ptr;
    }
    pub inline fn getFileObject(self: *const FileIoSimpleOpEtwEventReader) u64 {
        return self._file_object;
    }
    pub inline fn getFileKey(self: *const FileIoSimpleOpEtwEventReader) u64 {
        return self._file_key;
    }
    pub inline fn getTtid(self: *const FileIoSimpleOpEtwEventReader) u32 {
        return self._ttid;
    }
};
const FileIoOpEndEtwEventWire = struct {
    const IRP_PTR_WIRE: gremlin.ProtoWireNumber = 1;
    const EXTRA_INFO_WIRE: gremlin.ProtoWireNumber = 2;
    const NT_STATUS_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const FileIoOpEndEtwEvent = struct {
    // fields
    irp_ptr: u64 = 0,
    extra_info: u64 = 0,
    nt_status: u32 = 0,
    pub fn calcProtobufSize(self: *const FileIoOpEndEtwEvent) usize {
        var res: usize = 0;
        if (self.irp_ptr != 0) {
            res += gremlin.sizes.sizeWireNumber(FileIoOpEndEtwEventWire.IRP_PTR_WIRE) + gremlin.sizes.sizeU64(self.irp_ptr);
        }
        if (self.extra_info != 0) {
            res += gremlin.sizes.sizeWireNumber(FileIoOpEndEtwEventWire.EXTRA_INFO_WIRE) + gremlin.sizes.sizeU64(self.extra_info);
        }
        if (self.nt_status != 0) {
            res += gremlin.sizes.sizeWireNumber(FileIoOpEndEtwEventWire.NT_STATUS_WIRE) + gremlin.sizes.sizeU32(self.nt_status);
        }
        return res;
    }
    pub fn encode(self: *const FileIoOpEndEtwEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const FileIoOpEndEtwEvent, target: *gremlin.Writer) void {
        if (self.irp_ptr != 0) {
            target.appendUint64(FileIoOpEndEtwEventWire.IRP_PTR_WIRE, self.irp_ptr);
        }
        if (self.extra_info != 0) {
            target.appendUint64(FileIoOpEndEtwEventWire.EXTRA_INFO_WIRE, self.extra_info);
        }
        if (self.nt_status != 0) {
            target.appendUint32(FileIoOpEndEtwEventWire.NT_STATUS_WIRE, self.nt_status);
        }
    }
};
pub const FileIoOpEndEtwEventReader = struct {
    buf: gremlin.Reader,
    _irp_ptr: u64 = 0,
    _extra_info: u64 = 0,
    _nt_status: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!FileIoOpEndEtwEventReader {
        const buf = gremlin.Reader.init(src);
        var res = FileIoOpEndEtwEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                FileIoOpEndEtwEventWire.IRP_PTR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._irp_ptr = result.value;
                },
                FileIoOpEndEtwEventWire.EXTRA_INFO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._extra_info = result.value;
                },
                FileIoOpEndEtwEventWire.NT_STATUS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._nt_status = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getIrpPtr(self: *const FileIoOpEndEtwEventReader) u64 {
        return self._irp_ptr;
    }
    pub inline fn getExtraInfo(self: *const FileIoOpEndEtwEventReader) u64 {
        return self._extra_info;
    }
    pub inline fn getNtStatus(self: *const FileIoOpEndEtwEventReader) u32 {
        return self._nt_status;
    }
};
