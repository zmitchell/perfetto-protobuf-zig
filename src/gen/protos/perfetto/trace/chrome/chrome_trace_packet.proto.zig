// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
const chrome_trace_event = @import("chrome_trace_event.proto.zig");
const clock_snapshot = @import("src/gen/protos/perfetto/trace/clock_snapshot.proto.zig");
const track_event = @import("src/gen/protos/perfetto/trace/track_event/track_event.proto.zig");
const process_descriptor = @import("src/gen/protos/perfetto/trace/track_event/process_descriptor.proto.zig");
const thread_descriptor = @import("src/gen/protos/perfetto/trace/track_event/thread_descriptor.proto.zig");
const profile_packet = @import("src/gen/protos/perfetto/trace/profiling/profile_packet.proto.zig");
const chrome_trigger = @import("chrome_trigger.proto.zig");
const trace_config = @import("src/gen/protos/perfetto/config/trace_config.proto.zig");
const trace_stats = @import("src/gen/protos/perfetto/common/trace_stats.proto.zig");
const interned_data = @import("src/gen/protos/perfetto/trace/interned_data/interned_data.proto.zig");
// structs
const ChromeTracePacketWire = struct {
    const CHROME_EVENTS_WIRE: gremlin.ProtoWireNumber = 5;
    const CLOCK_SNAPSHOT_WIRE: gremlin.ProtoWireNumber = 6;
    const TRACK_EVENT_WIRE: gremlin.ProtoWireNumber = 11;
    const PROCESS_DESCRIPTOR_WIRE: gremlin.ProtoWireNumber = 43;
    const THREAD_DESCRIPTOR_WIRE: gremlin.ProtoWireNumber = 44;
    const STREAMING_PROFILE_PACKET_WIRE: gremlin.ProtoWireNumber = 54;
    const CHROME_TRIGGER_WIRE: gremlin.ProtoWireNumber = 109;
    const TRACE_CONFIG_WIRE: gremlin.ProtoWireNumber = 33;
    const TRACE_STATS_WIRE: gremlin.ProtoWireNumber = 35;
    const TRUSTED_PACKET_SEQUENCE_ID_WIRE: gremlin.ProtoWireNumber = 10;
    const INTERNED_DATA_WIRE: gremlin.ProtoWireNumber = 12;
    const INCREMENTAL_STATE_CLEARED_WIRE: gremlin.ProtoWireNumber = 41;
    const PREVIOUS_PACKET_DROPPED_WIRE: gremlin.ProtoWireNumber = 42;
};
pub const ChromeTracePacket = struct {
    // fields
    chrome_events: ?chrome_trace_event.ChromeEventBundle = null,
    clock_snapshot: ?clock_snapshot.ClockSnapshot = null,
    track_event: ?track_event.TrackEvent = null,
    process_descriptor: ?process_descriptor.ProcessDescriptor = null,
    thread_descriptor: ?thread_descriptor.ThreadDescriptor = null,
    streaming_profile_packet: ?profile_packet.StreamingProfilePacket = null,
    chrome_trigger: ?chrome_trigger.ChromeTrigger = null,
    trace_config: ?trace_config.TraceConfig = null,
    trace_stats: ?trace_stats.TraceStats = null,
    trusted_packet_sequence_id: u32 = 0,
    interned_data: ?interned_data.InternedData = null,
    incremental_state_cleared: bool = false,
    previous_packet_dropped: bool = false,
    pub fn calcProtobufSize(self: *const ChromeTracePacket) usize {
        var res: usize = 0;
        if (self.chrome_events) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeTracePacketWire.CHROME_EVENTS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.clock_snapshot) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeTracePacketWire.CLOCK_SNAPSHOT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.track_event) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeTracePacketWire.TRACK_EVENT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.process_descriptor) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeTracePacketWire.PROCESS_DESCRIPTOR_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.thread_descriptor) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeTracePacketWire.THREAD_DESCRIPTOR_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.streaming_profile_packet) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeTracePacketWire.STREAMING_PROFILE_PACKET_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_trigger) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeTracePacketWire.CHROME_TRIGGER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.trace_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeTracePacketWire.TRACE_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.trace_stats) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeTracePacketWire.TRACE_STATS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.trusted_packet_sequence_id != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeTracePacketWire.TRUSTED_PACKET_SEQUENCE_ID_WIRE) + gremlin.sizes.sizeU32(self.trusted_packet_sequence_id);
        }
        if (self.interned_data) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeTracePacketWire.INTERNED_DATA_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.incremental_state_cleared != false) {
            res += gremlin.sizes.sizeWireNumber(ChromeTracePacketWire.INCREMENTAL_STATE_CLEARED_WIRE) + gremlin.sizes.sizeBool(self.incremental_state_cleared);
        }
        if (self.previous_packet_dropped != false) {
            res += gremlin.sizes.sizeWireNumber(ChromeTracePacketWire.PREVIOUS_PACKET_DROPPED_WIRE) + gremlin.sizes.sizeBool(self.previous_packet_dropped);
        }
        return res;
    }
    pub fn encode(self: *const ChromeTracePacket, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ChromeTracePacket, target: *gremlin.Writer) void {
        if (self.chrome_events) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeTracePacketWire.CHROME_EVENTS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.clock_snapshot) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeTracePacketWire.CLOCK_SNAPSHOT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.track_event) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeTracePacketWire.TRACK_EVENT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.process_descriptor) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeTracePacketWire.PROCESS_DESCRIPTOR_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.thread_descriptor) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeTracePacketWire.THREAD_DESCRIPTOR_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.streaming_profile_packet) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeTracePacketWire.STREAMING_PROFILE_PACKET_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_trigger) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeTracePacketWire.CHROME_TRIGGER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.trace_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeTracePacketWire.TRACE_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.trace_stats) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeTracePacketWire.TRACE_STATS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.trusted_packet_sequence_id != 0) {
            target.appendUint32(ChromeTracePacketWire.TRUSTED_PACKET_SEQUENCE_ID_WIRE, self.trusted_packet_sequence_id);
        }
        if (self.interned_data) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeTracePacketWire.INTERNED_DATA_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.incremental_state_cleared != false) {
            target.appendBool(ChromeTracePacketWire.INCREMENTAL_STATE_CLEARED_WIRE, self.incremental_state_cleared);
        }
        if (self.previous_packet_dropped != false) {
            target.appendBool(ChromeTracePacketWire.PREVIOUS_PACKET_DROPPED_WIRE, self.previous_packet_dropped);
        }
    }
};
pub const ChromeTracePacketReader = struct {
    buf: gremlin.Reader,
    _chrome_events_buf: ?[]const u8 = null,
    _clock_snapshot_buf: ?[]const u8 = null,
    _track_event_buf: ?[]const u8 = null,
    _process_descriptor_buf: ?[]const u8 = null,
    _thread_descriptor_buf: ?[]const u8 = null,
    _streaming_profile_packet_buf: ?[]const u8 = null,
    _chrome_trigger_buf: ?[]const u8 = null,
    _trace_config_buf: ?[]const u8 = null,
    _trace_stats_buf: ?[]const u8 = null,
    _trusted_packet_sequence_id: u32 = 0,
    _interned_data_buf: ?[]const u8 = null,
    _incremental_state_cleared: bool = false,
    _previous_packet_dropped: bool = false,
    pub fn init(src: []const u8) gremlin.Error!ChromeTracePacketReader {
        const buf = gremlin.Reader.init(src);
        var res = ChromeTracePacketReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ChromeTracePacketWire.CHROME_EVENTS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_events_buf = result.value;
                },
                ChromeTracePacketWire.CLOCK_SNAPSHOT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._clock_snapshot_buf = result.value;
                },
                ChromeTracePacketWire.TRACK_EVENT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._track_event_buf = result.value;
                },
                ChromeTracePacketWire.PROCESS_DESCRIPTOR_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._process_descriptor_buf = result.value;
                },
                ChromeTracePacketWire.THREAD_DESCRIPTOR_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._thread_descriptor_buf = result.value;
                },
                ChromeTracePacketWire.STREAMING_PROFILE_PACKET_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._streaming_profile_packet_buf = result.value;
                },
                ChromeTracePacketWire.CHROME_TRIGGER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_trigger_buf = result.value;
                },
                ChromeTracePacketWire.TRACE_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._trace_config_buf = result.value;
                },
                ChromeTracePacketWire.TRACE_STATS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._trace_stats_buf = result.value;
                },
                ChromeTracePacketWire.TRUSTED_PACKET_SEQUENCE_ID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._trusted_packet_sequence_id = result.value;
                },
                ChromeTracePacketWire.INTERNED_DATA_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._interned_data_buf = result.value;
                },
                ChromeTracePacketWire.INCREMENTAL_STATE_CLEARED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._incremental_state_cleared = result.value;
                },
                ChromeTracePacketWire.PREVIOUS_PACKET_DROPPED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._previous_packet_dropped = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getChromeEvents(self: *const ChromeTracePacketReader) gremlin.Error!chrome_trace_event.ChromeEventBundleReader {
        if (self._chrome_events_buf) |buf| {
            return try chrome_trace_event.ChromeEventBundleReader.init(buf);
        }
        return try chrome_trace_event.ChromeEventBundleReader.init(&[_]u8{});
    }
    pub fn getClockSnapshot(self: *const ChromeTracePacketReader) gremlin.Error!clock_snapshot.ClockSnapshotReader {
        if (self._clock_snapshot_buf) |buf| {
            return try clock_snapshot.ClockSnapshotReader.init(buf);
        }
        return try clock_snapshot.ClockSnapshotReader.init(&[_]u8{});
    }
    pub fn getTrackEvent(self: *const ChromeTracePacketReader) gremlin.Error!track_event.TrackEventReader {
        if (self._track_event_buf) |buf| {
            return try track_event.TrackEventReader.init(buf);
        }
        return try track_event.TrackEventReader.init(&[_]u8{});
    }
    pub fn getProcessDescriptor(self: *const ChromeTracePacketReader) gremlin.Error!process_descriptor.ProcessDescriptorReader {
        if (self._process_descriptor_buf) |buf| {
            return try process_descriptor.ProcessDescriptorReader.init(buf);
        }
        return try process_descriptor.ProcessDescriptorReader.init(&[_]u8{});
    }
    pub fn getThreadDescriptor(self: *const ChromeTracePacketReader) gremlin.Error!thread_descriptor.ThreadDescriptorReader {
        if (self._thread_descriptor_buf) |buf| {
            return try thread_descriptor.ThreadDescriptorReader.init(buf);
        }
        return try thread_descriptor.ThreadDescriptorReader.init(&[_]u8{});
    }
    pub fn getStreamingProfilePacket(self: *const ChromeTracePacketReader) gremlin.Error!profile_packet.StreamingProfilePacketReader {
        if (self._streaming_profile_packet_buf) |buf| {
            return try profile_packet.StreamingProfilePacketReader.init(buf);
        }
        return try profile_packet.StreamingProfilePacketReader.init(&[_]u8{});
    }
    pub fn getChromeTrigger(self: *const ChromeTracePacketReader) gremlin.Error!chrome_trigger.ChromeTriggerReader {
        if (self._chrome_trigger_buf) |buf| {
            return try chrome_trigger.ChromeTriggerReader.init(buf);
        }
        return try chrome_trigger.ChromeTriggerReader.init(&[_]u8{});
    }
    pub fn getTraceConfig(self: *const ChromeTracePacketReader) gremlin.Error!trace_config.TraceConfigReader {
        if (self._trace_config_buf) |buf| {
            return try trace_config.TraceConfigReader.init(buf);
        }
        return try trace_config.TraceConfigReader.init(&[_]u8{});
    }
    pub fn getTraceStats(self: *const ChromeTracePacketReader) gremlin.Error!trace_stats.TraceStatsReader {
        if (self._trace_stats_buf) |buf| {
            return try trace_stats.TraceStatsReader.init(buf);
        }
        return try trace_stats.TraceStatsReader.init(&[_]u8{});
    }
    pub inline fn getTrustedPacketSequenceId(self: *const ChromeTracePacketReader) u32 {
        return self._trusted_packet_sequence_id;
    }
    pub fn getInternedData(self: *const ChromeTracePacketReader) gremlin.Error!interned_data.InternedDataReader {
        if (self._interned_data_buf) |buf| {
            return try interned_data.InternedDataReader.init(buf);
        }
        return try interned_data.InternedDataReader.init(&[_]u8{});
    }
    pub inline fn getIncrementalStateCleared(self: *const ChromeTracePacketReader) bool {
        return self._incremental_state_cleared;
    }
    pub inline fn getPreviousPacketDropped(self: *const ChromeTracePacketReader) bool {
        return self._previous_packet_dropped;
    }
};
