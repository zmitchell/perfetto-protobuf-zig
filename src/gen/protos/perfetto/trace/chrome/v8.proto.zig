// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const V8StringWire = struct {
    const LATIN1_WIRE: gremlin.ProtoWireNumber = 1;
    const UTF16_LE_WIRE: gremlin.ProtoWireNumber = 2;
    const UTF16_BE_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const V8String = struct {
    // fields
    latin1: ?[]const u8 = null,
    utf16_le: ?[]const u8 = null,
    utf16_be: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const V8String) usize {
        var res: usize = 0;
        if (self.latin1) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(V8StringWire.LATIN1_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.utf16_le) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(V8StringWire.UTF16_LE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.utf16_be) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(V8StringWire.UTF16_BE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const V8String, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const V8String, target: *gremlin.Writer) void {
        if (self.latin1) |v| {
            if (v.len > 0) {
                target.appendBytes(V8StringWire.LATIN1_WIRE, v);
            }
        }
        if (self.utf16_le) |v| {
            if (v.len > 0) {
                target.appendBytes(V8StringWire.UTF16_LE_WIRE, v);
            }
        }
        if (self.utf16_be) |v| {
            if (v.len > 0) {
                target.appendBytes(V8StringWire.UTF16_BE_WIRE, v);
            }
        }
    }
};
pub const V8StringReader = struct {
    buf: gremlin.Reader,
    _latin1: ?[]const u8 = null,
    _utf16_le: ?[]const u8 = null,
    _utf16_be: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!V8StringReader {
        const buf = gremlin.Reader.init(src);
        var res = V8StringReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                V8StringWire.LATIN1_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._latin1 = result.value;
                },
                V8StringWire.UTF16_LE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._utf16_le = result.value;
                },
                V8StringWire.UTF16_BE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._utf16_be = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getLatin1(self: *const V8StringReader) []const u8 {
        return self._latin1 orelse &[_]u8{};
    }
    pub inline fn getUtf16Le(self: *const V8StringReader) []const u8 {
        return self._utf16_le orelse &[_]u8{};
    }
    pub inline fn getUtf16Be(self: *const V8StringReader) []const u8 {
        return self._utf16_be orelse &[_]u8{};
    }
};
const InternedV8StringWire = struct {
    const IID_WIRE: gremlin.ProtoWireNumber = 1;
    const LATIN1_WIRE: gremlin.ProtoWireNumber = 2;
    const UTF16_LE_WIRE: gremlin.ProtoWireNumber = 3;
    const UTF16_BE_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const InternedV8String = struct {
    // fields
    iid: u64 = 0,
    latin1: ?[]const u8 = null,
    utf16_le: ?[]const u8 = null,
    utf16_be: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const InternedV8String) usize {
        var res: usize = 0;
        if (self.iid != 0) {
            res += gremlin.sizes.sizeWireNumber(InternedV8StringWire.IID_WIRE) + gremlin.sizes.sizeU64(self.iid);
        }
        if (self.latin1) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(InternedV8StringWire.LATIN1_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.utf16_le) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(InternedV8StringWire.UTF16_LE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.utf16_be) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(InternedV8StringWire.UTF16_BE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const InternedV8String, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const InternedV8String, target: *gremlin.Writer) void {
        if (self.iid != 0) {
            target.appendUint64(InternedV8StringWire.IID_WIRE, self.iid);
        }
        if (self.latin1) |v| {
            if (v.len > 0) {
                target.appendBytes(InternedV8StringWire.LATIN1_WIRE, v);
            }
        }
        if (self.utf16_le) |v| {
            if (v.len > 0) {
                target.appendBytes(InternedV8StringWire.UTF16_LE_WIRE, v);
            }
        }
        if (self.utf16_be) |v| {
            if (v.len > 0) {
                target.appendBytes(InternedV8StringWire.UTF16_BE_WIRE, v);
            }
        }
    }
};
pub const InternedV8StringReader = struct {
    buf: gremlin.Reader,
    _iid: u64 = 0,
    _latin1: ?[]const u8 = null,
    _utf16_le: ?[]const u8 = null,
    _utf16_be: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!InternedV8StringReader {
        const buf = gremlin.Reader.init(src);
        var res = InternedV8StringReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                InternedV8StringWire.IID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._iid = result.value;
                },
                InternedV8StringWire.LATIN1_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._latin1 = result.value;
                },
                InternedV8StringWire.UTF16_LE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._utf16_le = result.value;
                },
                InternedV8StringWire.UTF16_BE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._utf16_be = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getIid(self: *const InternedV8StringReader) u64 {
        return self._iid;
    }
    pub inline fn getLatin1(self: *const InternedV8StringReader) []const u8 {
        return self._latin1 orelse &[_]u8{};
    }
    pub inline fn getUtf16Le(self: *const InternedV8StringReader) []const u8 {
        return self._utf16_le orelse &[_]u8{};
    }
    pub inline fn getUtf16Be(self: *const InternedV8StringReader) []const u8 {
        return self._utf16_be orelse &[_]u8{};
    }
};
const InternedV8JsScriptWire = struct {
    const IID_WIRE: gremlin.ProtoWireNumber = 1;
    const SCRIPT_ID_WIRE: gremlin.ProtoWireNumber = 2;
    const TYPE_WIRE: gremlin.ProtoWireNumber = 3;
    const NAME_WIRE: gremlin.ProtoWireNumber = 4;
    const SOURCE_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const InternedV8JsScript = struct {
    // nested enums
    pub const Type = enum(i32) {
        TYPE_UNKNOWN = 0,
        TYPE_NORMAL = 1,
        TYPE_EVAL = 2,
        TYPE_MODULE = 3,
        TYPE_NATIVE = 4,
        TYPE_EXTENSION = 5,
        TYPE_INSPECTOR = 6,
    };
    // fields
    iid: u64 = 0,
    script_id: i32 = 0,
    type: InternedV8JsScript.Type = @enumFromInt(0),
    name: ?V8String = null,
    source: ?V8String = null,
    pub fn calcProtobufSize(self: *const InternedV8JsScript) usize {
        var res: usize = 0;
        if (self.iid != 0) {
            res += gremlin.sizes.sizeWireNumber(InternedV8JsScriptWire.IID_WIRE) + gremlin.sizes.sizeU64(self.iid);
        }
        if (self.script_id != 0) {
            res += gremlin.sizes.sizeWireNumber(InternedV8JsScriptWire.SCRIPT_ID_WIRE) + gremlin.sizes.sizeI32(self.script_id);
        }
        if (@intFromEnum(self.type) != 0) {
            res += gremlin.sizes.sizeWireNumber(InternedV8JsScriptWire.TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.type));
        }
        if (self.name) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(InternedV8JsScriptWire.NAME_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.source) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(InternedV8JsScriptWire.SOURCE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const InternedV8JsScript, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const InternedV8JsScript, target: *gremlin.Writer) void {
        if (self.iid != 0) {
            target.appendUint64(InternedV8JsScriptWire.IID_WIRE, self.iid);
        }
        if (self.script_id != 0) {
            target.appendInt32(InternedV8JsScriptWire.SCRIPT_ID_WIRE, self.script_id);
        }
        if (@intFromEnum(self.type) != 0) {
            target.appendInt32(InternedV8JsScriptWire.TYPE_WIRE, @intFromEnum(self.type));
        }
        if (self.name) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(InternedV8JsScriptWire.NAME_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.source) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(InternedV8JsScriptWire.SOURCE_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const InternedV8JsScriptReader = struct {
    buf: gremlin.Reader,
    _iid: u64 = 0,
    _script_id: i32 = 0,
    _type: InternedV8JsScript.Type = @enumFromInt(0),
    _name_buf: ?[]const u8 = null,
    _source_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!InternedV8JsScriptReader {
        const buf = gremlin.Reader.init(src);
        var res = InternedV8JsScriptReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                InternedV8JsScriptWire.IID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._iid = result.value;
                },
                InternedV8JsScriptWire.SCRIPT_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._script_id = result.value;
                },
                InternedV8JsScriptWire.TYPE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._type = @enumFromInt(result.value);
                },
                InternedV8JsScriptWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name_buf = result.value;
                },
                InternedV8JsScriptWire.SOURCE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._source_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getIid(self: *const InternedV8JsScriptReader) u64 {
        return self._iid;
    }
    pub inline fn getScriptId(self: *const InternedV8JsScriptReader) i32 {
        return self._script_id;
    }
    pub inline fn getType(self: *const InternedV8JsScriptReader) InternedV8JsScript.Type {
        return self._type;
    }
    pub fn getName(self: *const InternedV8JsScriptReader) gremlin.Error!V8StringReader {
        if (self._name_buf) |buf| {
            return try V8StringReader.init(buf);
        }
        return try V8StringReader.init(&[_]u8{});
    }
    pub fn getSource(self: *const InternedV8JsScriptReader) gremlin.Error!V8StringReader {
        if (self._source_buf) |buf| {
            return try V8StringReader.init(buf);
        }
        return try V8StringReader.init(&[_]u8{});
    }
};
const InternedV8WasmScriptWire = struct {
    const IID_WIRE: gremlin.ProtoWireNumber = 1;
    const SCRIPT_ID_WIRE: gremlin.ProtoWireNumber = 2;
    const URL_WIRE: gremlin.ProtoWireNumber = 3;
    const WIRE_BYTES_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const InternedV8WasmScript = struct {
    // fields
    iid: u64 = 0,
    script_id: i32 = 0,
    url: ?[]const u8 = null,
    wire_bytes: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const InternedV8WasmScript) usize {
        var res: usize = 0;
        if (self.iid != 0) {
            res += gremlin.sizes.sizeWireNumber(InternedV8WasmScriptWire.IID_WIRE) + gremlin.sizes.sizeU64(self.iid);
        }
        if (self.script_id != 0) {
            res += gremlin.sizes.sizeWireNumber(InternedV8WasmScriptWire.SCRIPT_ID_WIRE) + gremlin.sizes.sizeI32(self.script_id);
        }
        if (self.url) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(InternedV8WasmScriptWire.URL_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.wire_bytes) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(InternedV8WasmScriptWire.WIRE_BYTES_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const InternedV8WasmScript, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const InternedV8WasmScript, target: *gremlin.Writer) void {
        if (self.iid != 0) {
            target.appendUint64(InternedV8WasmScriptWire.IID_WIRE, self.iid);
        }
        if (self.script_id != 0) {
            target.appendInt32(InternedV8WasmScriptWire.SCRIPT_ID_WIRE, self.script_id);
        }
        if (self.url) |v| {
            if (v.len > 0) {
                target.appendBytes(InternedV8WasmScriptWire.URL_WIRE, v);
            }
        }
        if (self.wire_bytes) |v| {
            if (v.len > 0) {
                target.appendBytes(InternedV8WasmScriptWire.WIRE_BYTES_WIRE, v);
            }
        }
    }
};
pub const InternedV8WasmScriptReader = struct {
    buf: gremlin.Reader,
    _iid: u64 = 0,
    _script_id: i32 = 0,
    _url: ?[]const u8 = null,
    _wire_bytes: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!InternedV8WasmScriptReader {
        const buf = gremlin.Reader.init(src);
        var res = InternedV8WasmScriptReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                InternedV8WasmScriptWire.IID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._iid = result.value;
                },
                InternedV8WasmScriptWire.SCRIPT_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._script_id = result.value;
                },
                InternedV8WasmScriptWire.URL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._url = result.value;
                },
                InternedV8WasmScriptWire.WIRE_BYTES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._wire_bytes = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getIid(self: *const InternedV8WasmScriptReader) u64 {
        return self._iid;
    }
    pub inline fn getScriptId(self: *const InternedV8WasmScriptReader) i32 {
        return self._script_id;
    }
    pub inline fn getUrl(self: *const InternedV8WasmScriptReader) []const u8 {
        return self._url orelse &[_]u8{};
    }
    pub inline fn getWireBytes(self: *const InternedV8WasmScriptReader) []const u8 {
        return self._wire_bytes orelse &[_]u8{};
    }
};
const InternedV8JsFunctionWire = struct {
    const IID_WIRE: gremlin.ProtoWireNumber = 1;
    const V8_JS_FUNCTION_NAME_IID_WIRE: gremlin.ProtoWireNumber = 2;
    const V8_JS_SCRIPT_IID_WIRE: gremlin.ProtoWireNumber = 3;
    const IS_TOPLEVEL_WIRE: gremlin.ProtoWireNumber = 4;
    const KIND_WIRE: gremlin.ProtoWireNumber = 5;
    const BYTE_OFFSET_WIRE: gremlin.ProtoWireNumber = 6;
    const LINE_WIRE: gremlin.ProtoWireNumber = 7;
    const COLUMN_WIRE: gremlin.ProtoWireNumber = 8;
};
pub const InternedV8JsFunction = struct {
    // nested enums
    pub const Kind = enum(i32) {
        KIND_UNKNOWN = 0,
        KIND_NORMAL_FUNCTION = 1,
        KIND_MODULE = 2,
        KIND_ASYNC_MODULE = 3,
        KIND_BASE_CONSTRUCTOR = 4,
        KIND_DEFAULT_BASE_CONSTRUCTOR = 5,
        KIND_DEFAULT_DERIVED_CONSTRUCTOR = 6,
        KIND_DERIVED_CONSTRUCTOR = 7,
        KIND_GETTER_FUNCTION = 8,
        KIND_STATIC_GETTER_FUNCTION = 9,
        KIND_SETTER_FUNCTION = 10,
        KIND_STATIC_SETTER_FUNCTION = 11,
        KIND_ARROW_FUNCTION = 12,
        KIND_ASYNC_ARROW_FUNCTION = 13,
        KIND_ASYNC_FUNCTION = 14,
        KIND_ASYNC_CONCISE_METHOD = 15,
        KIND_STATIC_ASYNC_CONCISE_METHOD = 16,
        KIND_ASYNC_CONCISE_GENERATOR_METHOD = 17,
        KIND_STATIC_ASYNC_CONCISE_GENERATOR_METHOD = 18,
        KIND_ASYNC_GENERATOR_FUNCTION = 19,
        KIND_GENERATOR_FUNCTION = 20,
        KIND_CONCISE_GENERATOR_METHOD = 21,
        KIND_STATIC_CONCISE_GENERATOR_METHOD = 22,
        KIND_CONCISE_METHOD = 23,
        KIND_STATIC_CONCISE_METHOD = 24,
        KIND_CLASS_MEMBERS_INITIALIZER_FUNCTION = 25,
        KIND_CLASS_STATIC_INITIALIZER_FUNCTION = 26,
        KIND_INVALID = 27,
    };
    // fields
    iid: u64 = 0,
    v8_js_function_name_iid: u64 = 0,
    v8_js_script_iid: u64 = 0,
    is_toplevel: bool = false,
    kind: InternedV8JsFunction.Kind = @enumFromInt(0),
    byte_offset: u32 = 0,
    line: u32 = 0,
    column: u32 = 0,
    pub fn calcProtobufSize(self: *const InternedV8JsFunction) usize {
        var res: usize = 0;
        if (self.iid != 0) {
            res += gremlin.sizes.sizeWireNumber(InternedV8JsFunctionWire.IID_WIRE) + gremlin.sizes.sizeU64(self.iid);
        }
        if (self.v8_js_function_name_iid != 0) {
            res += gremlin.sizes.sizeWireNumber(InternedV8JsFunctionWire.V8_JS_FUNCTION_NAME_IID_WIRE) + gremlin.sizes.sizeU64(self.v8_js_function_name_iid);
        }
        if (self.v8_js_script_iid != 0) {
            res += gremlin.sizes.sizeWireNumber(InternedV8JsFunctionWire.V8_JS_SCRIPT_IID_WIRE) + gremlin.sizes.sizeU64(self.v8_js_script_iid);
        }
        if (self.is_toplevel != false) {
            res += gremlin.sizes.sizeWireNumber(InternedV8JsFunctionWire.IS_TOPLEVEL_WIRE) + gremlin.sizes.sizeBool(self.is_toplevel);
        }
        if (@intFromEnum(self.kind) != 0) {
            res += gremlin.sizes.sizeWireNumber(InternedV8JsFunctionWire.KIND_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.kind));
        }
        if (self.byte_offset != 0) {
            res += gremlin.sizes.sizeWireNumber(InternedV8JsFunctionWire.BYTE_OFFSET_WIRE) + gremlin.sizes.sizeU32(self.byte_offset);
        }
        if (self.line != 0) {
            res += gremlin.sizes.sizeWireNumber(InternedV8JsFunctionWire.LINE_WIRE) + gremlin.sizes.sizeU32(self.line);
        }
        if (self.column != 0) {
            res += gremlin.sizes.sizeWireNumber(InternedV8JsFunctionWire.COLUMN_WIRE) + gremlin.sizes.sizeU32(self.column);
        }
        return res;
    }
    pub fn encode(self: *const InternedV8JsFunction, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const InternedV8JsFunction, target: *gremlin.Writer) void {
        if (self.iid != 0) {
            target.appendUint64(InternedV8JsFunctionWire.IID_WIRE, self.iid);
        }
        if (self.v8_js_function_name_iid != 0) {
            target.appendUint64(InternedV8JsFunctionWire.V8_JS_FUNCTION_NAME_IID_WIRE, self.v8_js_function_name_iid);
        }
        if (self.v8_js_script_iid != 0) {
            target.appendUint64(InternedV8JsFunctionWire.V8_JS_SCRIPT_IID_WIRE, self.v8_js_script_iid);
        }
        if (self.is_toplevel != false) {
            target.appendBool(InternedV8JsFunctionWire.IS_TOPLEVEL_WIRE, self.is_toplevel);
        }
        if (@intFromEnum(self.kind) != 0) {
            target.appendInt32(InternedV8JsFunctionWire.KIND_WIRE, @intFromEnum(self.kind));
        }
        if (self.byte_offset != 0) {
            target.appendUint32(InternedV8JsFunctionWire.BYTE_OFFSET_WIRE, self.byte_offset);
        }
        if (self.line != 0) {
            target.appendUint32(InternedV8JsFunctionWire.LINE_WIRE, self.line);
        }
        if (self.column != 0) {
            target.appendUint32(InternedV8JsFunctionWire.COLUMN_WIRE, self.column);
        }
    }
};
pub const InternedV8JsFunctionReader = struct {
    buf: gremlin.Reader,
    _iid: u64 = 0,
    _v8_js_function_name_iid: u64 = 0,
    _v8_js_script_iid: u64 = 0,
    _is_toplevel: bool = false,
    _kind: InternedV8JsFunction.Kind = @enumFromInt(0),
    _byte_offset: u32 = 0,
    _line: u32 = 0,
    _column: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!InternedV8JsFunctionReader {
        const buf = gremlin.Reader.init(src);
        var res = InternedV8JsFunctionReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                InternedV8JsFunctionWire.IID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._iid = result.value;
                },
                InternedV8JsFunctionWire.V8_JS_FUNCTION_NAME_IID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._v8_js_function_name_iid = result.value;
                },
                InternedV8JsFunctionWire.V8_JS_SCRIPT_IID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._v8_js_script_iid = result.value;
                },
                InternedV8JsFunctionWire.IS_TOPLEVEL_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_toplevel = result.value;
                },
                InternedV8JsFunctionWire.KIND_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._kind = @enumFromInt(result.value);
                },
                InternedV8JsFunctionWire.BYTE_OFFSET_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._byte_offset = result.value;
                },
                InternedV8JsFunctionWire.LINE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._line = result.value;
                },
                InternedV8JsFunctionWire.COLUMN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._column = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getIid(self: *const InternedV8JsFunctionReader) u64 {
        return self._iid;
    }
    pub inline fn getV8JsFunctionNameIid(self: *const InternedV8JsFunctionReader) u64 {
        return self._v8_js_function_name_iid;
    }
    pub inline fn getV8JsScriptIid(self: *const InternedV8JsFunctionReader) u64 {
        return self._v8_js_script_iid;
    }
    pub inline fn getIsToplevel(self: *const InternedV8JsFunctionReader) bool {
        return self._is_toplevel;
    }
    pub inline fn getKind(self: *const InternedV8JsFunctionReader) InternedV8JsFunction.Kind {
        return self._kind;
    }
    pub inline fn getByteOffset(self: *const InternedV8JsFunctionReader) u32 {
        return self._byte_offset;
    }
    pub inline fn getLine(self: *const InternedV8JsFunctionReader) u32 {
        return self._line;
    }
    pub inline fn getColumn(self: *const InternedV8JsFunctionReader) u32 {
        return self._column;
    }
};
const InternedV8IsolateWire = struct {
    const IID_WIRE: gremlin.ProtoWireNumber = 1;
    const PID_WIRE: gremlin.ProtoWireNumber = 2;
    const ISOLATE_ID_WIRE: gremlin.ProtoWireNumber = 3;
    const CODE_RANGE_WIRE: gremlin.ProtoWireNumber = 4;
    const EMBEDDED_BLOB_CODE_START_ADDRESS_WIRE: gremlin.ProtoWireNumber = 5;
    const EMBEDDED_BLOB_CODE_SIZE_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const InternedV8Isolate = struct {
    // nested structs
    const CodeRangeWire = struct {
        const BASE_ADDRESS_WIRE: gremlin.ProtoWireNumber = 1;
        const SIZE_WIRE: gremlin.ProtoWireNumber = 2;
        const EMBEDDED_BLOB_CODE_COPY_START_ADDRESS_WIRE: gremlin.ProtoWireNumber = 3;
        const IS_PROCESS_WIDE_WIRE: gremlin.ProtoWireNumber = 4;
    };
    pub const CodeRange = struct {
        // fields
        base_address: u64 = 0,
        size: u64 = 0,
        embedded_blob_code_copy_start_address: u64 = 0,
        is_process_wide: bool = false,
        pub fn calcProtobufSize(self: *const InternedV8Isolate.CodeRange) usize {
            var res: usize = 0;
            if (self.base_address != 0) {
                res += gremlin.sizes.sizeWireNumber(InternedV8Isolate.CodeRangeWire.BASE_ADDRESS_WIRE) + gremlin.sizes.sizeU64(self.base_address);
            }
            if (self.size != 0) {
                res += gremlin.sizes.sizeWireNumber(InternedV8Isolate.CodeRangeWire.SIZE_WIRE) + gremlin.sizes.sizeU64(self.size);
            }
            if (self.embedded_blob_code_copy_start_address != 0) {
                res += gremlin.sizes.sizeWireNumber(InternedV8Isolate.CodeRangeWire.EMBEDDED_BLOB_CODE_COPY_START_ADDRESS_WIRE) + gremlin.sizes.sizeU64(self.embedded_blob_code_copy_start_address);
            }
            if (self.is_process_wide != false) {
                res += gremlin.sizes.sizeWireNumber(InternedV8Isolate.CodeRangeWire.IS_PROCESS_WIDE_WIRE) + gremlin.sizes.sizeBool(self.is_process_wide);
            }
            return res;
        }
        pub fn encode(self: *const InternedV8Isolate.CodeRange, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const InternedV8Isolate.CodeRange, target: *gremlin.Writer) void {
            if (self.base_address != 0) {
                target.appendUint64(InternedV8Isolate.CodeRangeWire.BASE_ADDRESS_WIRE, self.base_address);
            }
            if (self.size != 0) {
                target.appendUint64(InternedV8Isolate.CodeRangeWire.SIZE_WIRE, self.size);
            }
            if (self.embedded_blob_code_copy_start_address != 0) {
                target.appendUint64(InternedV8Isolate.CodeRangeWire.EMBEDDED_BLOB_CODE_COPY_START_ADDRESS_WIRE, self.embedded_blob_code_copy_start_address);
            }
            if (self.is_process_wide != false) {
                target.appendBool(InternedV8Isolate.CodeRangeWire.IS_PROCESS_WIDE_WIRE, self.is_process_wide);
            }
        }
    };
    pub const CodeRangeReader = struct {
        buf: gremlin.Reader,
        _base_address: u64 = 0,
        _size: u64 = 0,
        _embedded_blob_code_copy_start_address: u64 = 0,
        _is_process_wide: bool = false,
        pub fn init(src: []const u8) gremlin.Error!InternedV8Isolate.CodeRangeReader {
            const buf = gremlin.Reader.init(src);
            var res = InternedV8Isolate.CodeRangeReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    InternedV8Isolate.CodeRangeWire.BASE_ADDRESS_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._base_address = result.value;
                    },
                    InternedV8Isolate.CodeRangeWire.SIZE_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._size = result.value;
                    },
                    InternedV8Isolate.CodeRangeWire.EMBEDDED_BLOB_CODE_COPY_START_ADDRESS_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._embedded_blob_code_copy_start_address = result.value;
                    },
                    InternedV8Isolate.CodeRangeWire.IS_PROCESS_WIDE_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._is_process_wide = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getBaseAddress(self: *const InternedV8Isolate.CodeRangeReader) u64 {
            return self._base_address;
        }
        pub inline fn getSize(self: *const InternedV8Isolate.CodeRangeReader) u64 {
            return self._size;
        }
        pub inline fn getEmbeddedBlobCodeCopyStartAddress(self: *const InternedV8Isolate.CodeRangeReader) u64 {
            return self._embedded_blob_code_copy_start_address;
        }
        pub inline fn getIsProcessWide(self: *const InternedV8Isolate.CodeRangeReader) bool {
            return self._is_process_wide;
        }
    };
    // fields
    iid: u64 = 0,
    pid: u32 = 0,
    isolate_id: i32 = 0,
    code_range: ?InternedV8Isolate.CodeRange = null,
    embedded_blob_code_start_address: u64 = 0,
    embedded_blob_code_size: u64 = 0,
    pub fn calcProtobufSize(self: *const InternedV8Isolate) usize {
        var res: usize = 0;
        if (self.iid != 0) {
            res += gremlin.sizes.sizeWireNumber(InternedV8IsolateWire.IID_WIRE) + gremlin.sizes.sizeU64(self.iid);
        }
        if (self.pid != 0) {
            res += gremlin.sizes.sizeWireNumber(InternedV8IsolateWire.PID_WIRE) + gremlin.sizes.sizeU32(self.pid);
        }
        if (self.isolate_id != 0) {
            res += gremlin.sizes.sizeWireNumber(InternedV8IsolateWire.ISOLATE_ID_WIRE) + gremlin.sizes.sizeI32(self.isolate_id);
        }
        if (self.code_range) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(InternedV8IsolateWire.CODE_RANGE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.embedded_blob_code_start_address != 0) {
            res += gremlin.sizes.sizeWireNumber(InternedV8IsolateWire.EMBEDDED_BLOB_CODE_START_ADDRESS_WIRE) + gremlin.sizes.sizeU64(self.embedded_blob_code_start_address);
        }
        if (self.embedded_blob_code_size != 0) {
            res += gremlin.sizes.sizeWireNumber(InternedV8IsolateWire.EMBEDDED_BLOB_CODE_SIZE_WIRE) + gremlin.sizes.sizeU64(self.embedded_blob_code_size);
        }
        return res;
    }
    pub fn encode(self: *const InternedV8Isolate, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const InternedV8Isolate, target: *gremlin.Writer) void {
        if (self.iid != 0) {
            target.appendUint64(InternedV8IsolateWire.IID_WIRE, self.iid);
        }
        if (self.pid != 0) {
            target.appendUint32(InternedV8IsolateWire.PID_WIRE, self.pid);
        }
        if (self.isolate_id != 0) {
            target.appendInt32(InternedV8IsolateWire.ISOLATE_ID_WIRE, self.isolate_id);
        }
        if (self.code_range) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(InternedV8IsolateWire.CODE_RANGE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.embedded_blob_code_start_address != 0) {
            target.appendUint64(InternedV8IsolateWire.EMBEDDED_BLOB_CODE_START_ADDRESS_WIRE, self.embedded_blob_code_start_address);
        }
        if (self.embedded_blob_code_size != 0) {
            target.appendUint64(InternedV8IsolateWire.EMBEDDED_BLOB_CODE_SIZE_WIRE, self.embedded_blob_code_size);
        }
    }
};
pub const InternedV8IsolateReader = struct {
    buf: gremlin.Reader,
    _iid: u64 = 0,
    _pid: u32 = 0,
    _isolate_id: i32 = 0,
    _code_range_buf: ?[]const u8 = null,
    _embedded_blob_code_start_address: u64 = 0,
    _embedded_blob_code_size: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!InternedV8IsolateReader {
        const buf = gremlin.Reader.init(src);
        var res = InternedV8IsolateReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                InternedV8IsolateWire.IID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._iid = result.value;
                },
                InternedV8IsolateWire.PID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._pid = result.value;
                },
                InternedV8IsolateWire.ISOLATE_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._isolate_id = result.value;
                },
                InternedV8IsolateWire.CODE_RANGE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._code_range_buf = result.value;
                },
                InternedV8IsolateWire.EMBEDDED_BLOB_CODE_START_ADDRESS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._embedded_blob_code_start_address = result.value;
                },
                InternedV8IsolateWire.EMBEDDED_BLOB_CODE_SIZE_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._embedded_blob_code_size = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getIid(self: *const InternedV8IsolateReader) u64 {
        return self._iid;
    }
    pub inline fn getPid(self: *const InternedV8IsolateReader) u32 {
        return self._pid;
    }
    pub inline fn getIsolateId(self: *const InternedV8IsolateReader) i32 {
        return self._isolate_id;
    }
    pub fn getCodeRange(self: *const InternedV8IsolateReader) gremlin.Error!InternedV8Isolate.CodeRangeReader {
        if (self._code_range_buf) |buf| {
            return try InternedV8Isolate.CodeRangeReader.init(buf);
        }
        return try InternedV8Isolate.CodeRangeReader.init(&[_]u8{});
    }
    pub inline fn getEmbeddedBlobCodeStartAddress(self: *const InternedV8IsolateReader) u64 {
        return self._embedded_blob_code_start_address;
    }
    pub inline fn getEmbeddedBlobCodeSize(self: *const InternedV8IsolateReader) u64 {
        return self._embedded_blob_code_size;
    }
};
const V8JsCodeWire = struct {
    const V8_ISOLATE_IID_WIRE: gremlin.ProtoWireNumber = 1;
    const TID_WIRE: gremlin.ProtoWireNumber = 2;
    const V8_JS_FUNCTION_IID_WIRE: gremlin.ProtoWireNumber = 3;
    const TIER_WIRE: gremlin.ProtoWireNumber = 4;
    const INSTRUCTION_START_WIRE: gremlin.ProtoWireNumber = 5;
    const INSTRUCTION_SIZE_BYTES_WIRE: gremlin.ProtoWireNumber = 6;
    const MACHINE_CODE_WIRE: gremlin.ProtoWireNumber = 7;
    const BYTECODE_WIRE: gremlin.ProtoWireNumber = 8;
};
pub const V8JsCode = struct {
    // nested enums
    pub const Tier = enum(i32) {
        TIER_UNKNOWN = 0,
        TIER_IGNITION = 1,
        TIER_SPARKPLUG = 2,
        TIER_MAGLEV = 3,
        TIER_TURBOSHAFT = 4,
        TIER_TURBOFAN = 5,
    };
    // fields
    v8_isolate_iid: u64 = 0,
    tid: u32 = 0,
    v8_js_function_iid: u64 = 0,
    tier: V8JsCode.Tier = @enumFromInt(0),
    instruction_start: u64 = 0,
    instruction_size_bytes: u64 = 0,
    machine_code: ?[]const u8 = null,
    bytecode: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const V8JsCode) usize {
        var res: usize = 0;
        if (self.v8_isolate_iid != 0) {
            res += gremlin.sizes.sizeWireNumber(V8JsCodeWire.V8_ISOLATE_IID_WIRE) + gremlin.sizes.sizeU64(self.v8_isolate_iid);
        }
        if (self.tid != 0) {
            res += gremlin.sizes.sizeWireNumber(V8JsCodeWire.TID_WIRE) + gremlin.sizes.sizeU32(self.tid);
        }
        if (self.v8_js_function_iid != 0) {
            res += gremlin.sizes.sizeWireNumber(V8JsCodeWire.V8_JS_FUNCTION_IID_WIRE) + gremlin.sizes.sizeU64(self.v8_js_function_iid);
        }
        if (@intFromEnum(self.tier) != 0) {
            res += gremlin.sizes.sizeWireNumber(V8JsCodeWire.TIER_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.tier));
        }
        if (self.instruction_start != 0) {
            res += gremlin.sizes.sizeWireNumber(V8JsCodeWire.INSTRUCTION_START_WIRE) + gremlin.sizes.sizeU64(self.instruction_start);
        }
        if (self.instruction_size_bytes != 0) {
            res += gremlin.sizes.sizeWireNumber(V8JsCodeWire.INSTRUCTION_SIZE_BYTES_WIRE) + gremlin.sizes.sizeU64(self.instruction_size_bytes);
        }
        if (self.machine_code) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(V8JsCodeWire.MACHINE_CODE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.bytecode) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(V8JsCodeWire.BYTECODE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const V8JsCode, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const V8JsCode, target: *gremlin.Writer) void {
        if (self.v8_isolate_iid != 0) {
            target.appendUint64(V8JsCodeWire.V8_ISOLATE_IID_WIRE, self.v8_isolate_iid);
        }
        if (self.tid != 0) {
            target.appendUint32(V8JsCodeWire.TID_WIRE, self.tid);
        }
        if (self.v8_js_function_iid != 0) {
            target.appendUint64(V8JsCodeWire.V8_JS_FUNCTION_IID_WIRE, self.v8_js_function_iid);
        }
        if (@intFromEnum(self.tier) != 0) {
            target.appendInt32(V8JsCodeWire.TIER_WIRE, @intFromEnum(self.tier));
        }
        if (self.instruction_start != 0) {
            target.appendUint64(V8JsCodeWire.INSTRUCTION_START_WIRE, self.instruction_start);
        }
        if (self.instruction_size_bytes != 0) {
            target.appendUint64(V8JsCodeWire.INSTRUCTION_SIZE_BYTES_WIRE, self.instruction_size_bytes);
        }
        if (self.machine_code) |v| {
            if (v.len > 0) {
                target.appendBytes(V8JsCodeWire.MACHINE_CODE_WIRE, v);
            }
        }
        if (self.bytecode) |v| {
            if (v.len > 0) {
                target.appendBytes(V8JsCodeWire.BYTECODE_WIRE, v);
            }
        }
    }
};
pub const V8JsCodeReader = struct {
    buf: gremlin.Reader,
    _v8_isolate_iid: u64 = 0,
    _tid: u32 = 0,
    _v8_js_function_iid: u64 = 0,
    _tier: V8JsCode.Tier = @enumFromInt(0),
    _instruction_start: u64 = 0,
    _instruction_size_bytes: u64 = 0,
    _machine_code: ?[]const u8 = null,
    _bytecode: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!V8JsCodeReader {
        const buf = gremlin.Reader.init(src);
        var res = V8JsCodeReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                V8JsCodeWire.V8_ISOLATE_IID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._v8_isolate_iid = result.value;
                },
                V8JsCodeWire.TID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._tid = result.value;
                },
                V8JsCodeWire.V8_JS_FUNCTION_IID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._v8_js_function_iid = result.value;
                },
                V8JsCodeWire.TIER_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._tier = @enumFromInt(result.value);
                },
                V8JsCodeWire.INSTRUCTION_START_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._instruction_start = result.value;
                },
                V8JsCodeWire.INSTRUCTION_SIZE_BYTES_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._instruction_size_bytes = result.value;
                },
                V8JsCodeWire.MACHINE_CODE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._machine_code = result.value;
                },
                V8JsCodeWire.BYTECODE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._bytecode = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getV8IsolateIid(self: *const V8JsCodeReader) u64 {
        return self._v8_isolate_iid;
    }
    pub inline fn getTid(self: *const V8JsCodeReader) u32 {
        return self._tid;
    }
    pub inline fn getV8JsFunctionIid(self: *const V8JsCodeReader) u64 {
        return self._v8_js_function_iid;
    }
    pub inline fn getTier(self: *const V8JsCodeReader) V8JsCode.Tier {
        return self._tier;
    }
    pub inline fn getInstructionStart(self: *const V8JsCodeReader) u64 {
        return self._instruction_start;
    }
    pub inline fn getInstructionSizeBytes(self: *const V8JsCodeReader) u64 {
        return self._instruction_size_bytes;
    }
    pub inline fn getMachineCode(self: *const V8JsCodeReader) []const u8 {
        return self._machine_code orelse &[_]u8{};
    }
    pub inline fn getBytecode(self: *const V8JsCodeReader) []const u8 {
        return self._bytecode orelse &[_]u8{};
    }
};
const V8InternalCodeWire = struct {
    const V8_ISOLATE_IID_WIRE: gremlin.ProtoWireNumber = 1;
    const TID_WIRE: gremlin.ProtoWireNumber = 2;
    const NAME_WIRE: gremlin.ProtoWireNumber = 3;
    const TYPE_WIRE: gremlin.ProtoWireNumber = 4;
    const BUILTIN_ID_WIRE: gremlin.ProtoWireNumber = 5;
    const INSTRUCTION_START_WIRE: gremlin.ProtoWireNumber = 6;
    const INSTRUCTION_SIZE_BYTES_WIRE: gremlin.ProtoWireNumber = 7;
    const MACHINE_CODE_WIRE: gremlin.ProtoWireNumber = 8;
};
pub const V8InternalCode = struct {
    // nested enums
    pub const Type = enum(i32) {
        TYPE_UNKNOWN = 0,
        TYPE_BYTECODE_HANDLER = 1,
        TYPE_FOR_TESTING = 2,
        TYPE_BUILTIN = 3,
        TYPE_WASM_FUNCTION = 4,
        TYPE_WASM_TO_CAPI_FUNCTION = 5,
        TYPE_WASM_TO_JS_FUNCTION = 6,
        TYPE_JS_TO_WASM_FUNCTION = 7,
        TYPE_JS_TO_JS_FUNCTION = 8,
        TYPE_C_WASM_ENTRY = 9,
    };
    // fields
    v8_isolate_iid: u64 = 0,
    tid: u32 = 0,
    name: ?[]const u8 = null,
    type: V8InternalCode.Type = @enumFromInt(0),
    builtin_id: i32 = 0,
    instruction_start: u64 = 0,
    instruction_size_bytes: u64 = 0,
    machine_code: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const V8InternalCode) usize {
        var res: usize = 0;
        if (self.v8_isolate_iid != 0) {
            res += gremlin.sizes.sizeWireNumber(V8InternalCodeWire.V8_ISOLATE_IID_WIRE) + gremlin.sizes.sizeU64(self.v8_isolate_iid);
        }
        if (self.tid != 0) {
            res += gremlin.sizes.sizeWireNumber(V8InternalCodeWire.TID_WIRE) + gremlin.sizes.sizeU32(self.tid);
        }
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(V8InternalCodeWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (@intFromEnum(self.type) != 0) {
            res += gremlin.sizes.sizeWireNumber(V8InternalCodeWire.TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.type));
        }
        if (self.builtin_id != 0) {
            res += gremlin.sizes.sizeWireNumber(V8InternalCodeWire.BUILTIN_ID_WIRE) + gremlin.sizes.sizeI32(self.builtin_id);
        }
        if (self.instruction_start != 0) {
            res += gremlin.sizes.sizeWireNumber(V8InternalCodeWire.INSTRUCTION_START_WIRE) + gremlin.sizes.sizeU64(self.instruction_start);
        }
        if (self.instruction_size_bytes != 0) {
            res += gremlin.sizes.sizeWireNumber(V8InternalCodeWire.INSTRUCTION_SIZE_BYTES_WIRE) + gremlin.sizes.sizeU64(self.instruction_size_bytes);
        }
        if (self.machine_code) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(V8InternalCodeWire.MACHINE_CODE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const V8InternalCode, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const V8InternalCode, target: *gremlin.Writer) void {
        if (self.v8_isolate_iid != 0) {
            target.appendUint64(V8InternalCodeWire.V8_ISOLATE_IID_WIRE, self.v8_isolate_iid);
        }
        if (self.tid != 0) {
            target.appendUint32(V8InternalCodeWire.TID_WIRE, self.tid);
        }
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(V8InternalCodeWire.NAME_WIRE, v);
            }
        }
        if (@intFromEnum(self.type) != 0) {
            target.appendInt32(V8InternalCodeWire.TYPE_WIRE, @intFromEnum(self.type));
        }
        if (self.builtin_id != 0) {
            target.appendInt32(V8InternalCodeWire.BUILTIN_ID_WIRE, self.builtin_id);
        }
        if (self.instruction_start != 0) {
            target.appendUint64(V8InternalCodeWire.INSTRUCTION_START_WIRE, self.instruction_start);
        }
        if (self.instruction_size_bytes != 0) {
            target.appendUint64(V8InternalCodeWire.INSTRUCTION_SIZE_BYTES_WIRE, self.instruction_size_bytes);
        }
        if (self.machine_code) |v| {
            if (v.len > 0) {
                target.appendBytes(V8InternalCodeWire.MACHINE_CODE_WIRE, v);
            }
        }
    }
};
pub const V8InternalCodeReader = struct {
    buf: gremlin.Reader,
    _v8_isolate_iid: u64 = 0,
    _tid: u32 = 0,
    _name: ?[]const u8 = null,
    _type: V8InternalCode.Type = @enumFromInt(0),
    _builtin_id: i32 = 0,
    _instruction_start: u64 = 0,
    _instruction_size_bytes: u64 = 0,
    _machine_code: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!V8InternalCodeReader {
        const buf = gremlin.Reader.init(src);
        var res = V8InternalCodeReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                V8InternalCodeWire.V8_ISOLATE_IID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._v8_isolate_iid = result.value;
                },
                V8InternalCodeWire.TID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._tid = result.value;
                },
                V8InternalCodeWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                V8InternalCodeWire.TYPE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._type = @enumFromInt(result.value);
                },
                V8InternalCodeWire.BUILTIN_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._builtin_id = result.value;
                },
                V8InternalCodeWire.INSTRUCTION_START_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._instruction_start = result.value;
                },
                V8InternalCodeWire.INSTRUCTION_SIZE_BYTES_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._instruction_size_bytes = result.value;
                },
                V8InternalCodeWire.MACHINE_CODE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._machine_code = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getV8IsolateIid(self: *const V8InternalCodeReader) u64 {
        return self._v8_isolate_iid;
    }
    pub inline fn getTid(self: *const V8InternalCodeReader) u32 {
        return self._tid;
    }
    pub inline fn getName(self: *const V8InternalCodeReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub inline fn getType(self: *const V8InternalCodeReader) V8InternalCode.Type {
        return self._type;
    }
    pub inline fn getBuiltinId(self: *const V8InternalCodeReader) i32 {
        return self._builtin_id;
    }
    pub inline fn getInstructionStart(self: *const V8InternalCodeReader) u64 {
        return self._instruction_start;
    }
    pub inline fn getInstructionSizeBytes(self: *const V8InternalCodeReader) u64 {
        return self._instruction_size_bytes;
    }
    pub inline fn getMachineCode(self: *const V8InternalCodeReader) []const u8 {
        return self._machine_code orelse &[_]u8{};
    }
};
const V8WasmCodeWire = struct {
    const V8_ISOLATE_IID_WIRE: gremlin.ProtoWireNumber = 1;
    const TID_WIRE: gremlin.ProtoWireNumber = 2;
    const V8_WASM_SCRIPT_IID_WIRE: gremlin.ProtoWireNumber = 3;
    const FUNCTION_NAME_WIRE: gremlin.ProtoWireNumber = 4;
    const TIER_WIRE: gremlin.ProtoWireNumber = 5;
    const CODE_OFFSET_IN_MODULE_WIRE: gremlin.ProtoWireNumber = 6;
    const INSTRUCTION_START_WIRE: gremlin.ProtoWireNumber = 7;
    const INSTRUCTION_SIZE_BYTES_WIRE: gremlin.ProtoWireNumber = 8;
    const MACHINE_CODE_WIRE: gremlin.ProtoWireNumber = 9;
};
pub const V8WasmCode = struct {
    // nested enums
    pub const Tier = enum(i32) {
        TIER_UNKNOWN = 0,
        TIER_LIFTOFF = 1,
        TIER_TURBOFAN = 2,
    };
    // fields
    v8_isolate_iid: u64 = 0,
    tid: u32 = 0,
    v8_wasm_script_iid: u64 = 0,
    function_name: ?[]const u8 = null,
    tier: V8WasmCode.Tier = @enumFromInt(0),
    code_offset_in_module: i32 = 0,
    instruction_start: u64 = 0,
    instruction_size_bytes: u64 = 0,
    machine_code: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const V8WasmCode) usize {
        var res: usize = 0;
        if (self.v8_isolate_iid != 0) {
            res += gremlin.sizes.sizeWireNumber(V8WasmCodeWire.V8_ISOLATE_IID_WIRE) + gremlin.sizes.sizeU64(self.v8_isolate_iid);
        }
        if (self.tid != 0) {
            res += gremlin.sizes.sizeWireNumber(V8WasmCodeWire.TID_WIRE) + gremlin.sizes.sizeU32(self.tid);
        }
        if (self.v8_wasm_script_iid != 0) {
            res += gremlin.sizes.sizeWireNumber(V8WasmCodeWire.V8_WASM_SCRIPT_IID_WIRE) + gremlin.sizes.sizeU64(self.v8_wasm_script_iid);
        }
        if (self.function_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(V8WasmCodeWire.FUNCTION_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (@intFromEnum(self.tier) != 0) {
            res += gremlin.sizes.sizeWireNumber(V8WasmCodeWire.TIER_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.tier));
        }
        if (self.code_offset_in_module != 0) {
            res += gremlin.sizes.sizeWireNumber(V8WasmCodeWire.CODE_OFFSET_IN_MODULE_WIRE) + gremlin.sizes.sizeI32(self.code_offset_in_module);
        }
        if (self.instruction_start != 0) {
            res += gremlin.sizes.sizeWireNumber(V8WasmCodeWire.INSTRUCTION_START_WIRE) + gremlin.sizes.sizeU64(self.instruction_start);
        }
        if (self.instruction_size_bytes != 0) {
            res += gremlin.sizes.sizeWireNumber(V8WasmCodeWire.INSTRUCTION_SIZE_BYTES_WIRE) + gremlin.sizes.sizeU64(self.instruction_size_bytes);
        }
        if (self.machine_code) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(V8WasmCodeWire.MACHINE_CODE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const V8WasmCode, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const V8WasmCode, target: *gremlin.Writer) void {
        if (self.v8_isolate_iid != 0) {
            target.appendUint64(V8WasmCodeWire.V8_ISOLATE_IID_WIRE, self.v8_isolate_iid);
        }
        if (self.tid != 0) {
            target.appendUint32(V8WasmCodeWire.TID_WIRE, self.tid);
        }
        if (self.v8_wasm_script_iid != 0) {
            target.appendUint64(V8WasmCodeWire.V8_WASM_SCRIPT_IID_WIRE, self.v8_wasm_script_iid);
        }
        if (self.function_name) |v| {
            if (v.len > 0) {
                target.appendBytes(V8WasmCodeWire.FUNCTION_NAME_WIRE, v);
            }
        }
        if (@intFromEnum(self.tier) != 0) {
            target.appendInt32(V8WasmCodeWire.TIER_WIRE, @intFromEnum(self.tier));
        }
        if (self.code_offset_in_module != 0) {
            target.appendInt32(V8WasmCodeWire.CODE_OFFSET_IN_MODULE_WIRE, self.code_offset_in_module);
        }
        if (self.instruction_start != 0) {
            target.appendUint64(V8WasmCodeWire.INSTRUCTION_START_WIRE, self.instruction_start);
        }
        if (self.instruction_size_bytes != 0) {
            target.appendUint64(V8WasmCodeWire.INSTRUCTION_SIZE_BYTES_WIRE, self.instruction_size_bytes);
        }
        if (self.machine_code) |v| {
            if (v.len > 0) {
                target.appendBytes(V8WasmCodeWire.MACHINE_CODE_WIRE, v);
            }
        }
    }
};
pub const V8WasmCodeReader = struct {
    buf: gremlin.Reader,
    _v8_isolate_iid: u64 = 0,
    _tid: u32 = 0,
    _v8_wasm_script_iid: u64 = 0,
    _function_name: ?[]const u8 = null,
    _tier: V8WasmCode.Tier = @enumFromInt(0),
    _code_offset_in_module: i32 = 0,
    _instruction_start: u64 = 0,
    _instruction_size_bytes: u64 = 0,
    _machine_code: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!V8WasmCodeReader {
        const buf = gremlin.Reader.init(src);
        var res = V8WasmCodeReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                V8WasmCodeWire.V8_ISOLATE_IID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._v8_isolate_iid = result.value;
                },
                V8WasmCodeWire.TID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._tid = result.value;
                },
                V8WasmCodeWire.V8_WASM_SCRIPT_IID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._v8_wasm_script_iid = result.value;
                },
                V8WasmCodeWire.FUNCTION_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._function_name = result.value;
                },
                V8WasmCodeWire.TIER_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._tier = @enumFromInt(result.value);
                },
                V8WasmCodeWire.CODE_OFFSET_IN_MODULE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._code_offset_in_module = result.value;
                },
                V8WasmCodeWire.INSTRUCTION_START_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._instruction_start = result.value;
                },
                V8WasmCodeWire.INSTRUCTION_SIZE_BYTES_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._instruction_size_bytes = result.value;
                },
                V8WasmCodeWire.MACHINE_CODE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._machine_code = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getV8IsolateIid(self: *const V8WasmCodeReader) u64 {
        return self._v8_isolate_iid;
    }
    pub inline fn getTid(self: *const V8WasmCodeReader) u32 {
        return self._tid;
    }
    pub inline fn getV8WasmScriptIid(self: *const V8WasmCodeReader) u64 {
        return self._v8_wasm_script_iid;
    }
    pub inline fn getFunctionName(self: *const V8WasmCodeReader) []const u8 {
        return self._function_name orelse &[_]u8{};
    }
    pub inline fn getTier(self: *const V8WasmCodeReader) V8WasmCode.Tier {
        return self._tier;
    }
    pub inline fn getCodeOffsetInModule(self: *const V8WasmCodeReader) i32 {
        return self._code_offset_in_module;
    }
    pub inline fn getInstructionStart(self: *const V8WasmCodeReader) u64 {
        return self._instruction_start;
    }
    pub inline fn getInstructionSizeBytes(self: *const V8WasmCodeReader) u64 {
        return self._instruction_size_bytes;
    }
    pub inline fn getMachineCode(self: *const V8WasmCodeReader) []const u8 {
        return self._machine_code orelse &[_]u8{};
    }
};
const V8RegExpCodeWire = struct {
    const V8_ISOLATE_IID_WIRE: gremlin.ProtoWireNumber = 1;
    const TID_WIRE: gremlin.ProtoWireNumber = 2;
    const PATTERN_WIRE: gremlin.ProtoWireNumber = 3;
    const INSTRUCTION_START_WIRE: gremlin.ProtoWireNumber = 4;
    const INSTRUCTION_SIZE_BYTES_WIRE: gremlin.ProtoWireNumber = 5;
    const MACHINE_CODE_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const V8RegExpCode = struct {
    // fields
    v8_isolate_iid: u64 = 0,
    tid: u32 = 0,
    pattern: ?V8String = null,
    instruction_start: u64 = 0,
    instruction_size_bytes: u64 = 0,
    machine_code: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const V8RegExpCode) usize {
        var res: usize = 0;
        if (self.v8_isolate_iid != 0) {
            res += gremlin.sizes.sizeWireNumber(V8RegExpCodeWire.V8_ISOLATE_IID_WIRE) + gremlin.sizes.sizeU64(self.v8_isolate_iid);
        }
        if (self.tid != 0) {
            res += gremlin.sizes.sizeWireNumber(V8RegExpCodeWire.TID_WIRE) + gremlin.sizes.sizeU32(self.tid);
        }
        if (self.pattern) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(V8RegExpCodeWire.PATTERN_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.instruction_start != 0) {
            res += gremlin.sizes.sizeWireNumber(V8RegExpCodeWire.INSTRUCTION_START_WIRE) + gremlin.sizes.sizeU64(self.instruction_start);
        }
        if (self.instruction_size_bytes != 0) {
            res += gremlin.sizes.sizeWireNumber(V8RegExpCodeWire.INSTRUCTION_SIZE_BYTES_WIRE) + gremlin.sizes.sizeU64(self.instruction_size_bytes);
        }
        if (self.machine_code) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(V8RegExpCodeWire.MACHINE_CODE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const V8RegExpCode, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const V8RegExpCode, target: *gremlin.Writer) void {
        if (self.v8_isolate_iid != 0) {
            target.appendUint64(V8RegExpCodeWire.V8_ISOLATE_IID_WIRE, self.v8_isolate_iid);
        }
        if (self.tid != 0) {
            target.appendUint32(V8RegExpCodeWire.TID_WIRE, self.tid);
        }
        if (self.pattern) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(V8RegExpCodeWire.PATTERN_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.instruction_start != 0) {
            target.appendUint64(V8RegExpCodeWire.INSTRUCTION_START_WIRE, self.instruction_start);
        }
        if (self.instruction_size_bytes != 0) {
            target.appendUint64(V8RegExpCodeWire.INSTRUCTION_SIZE_BYTES_WIRE, self.instruction_size_bytes);
        }
        if (self.machine_code) |v| {
            if (v.len > 0) {
                target.appendBytes(V8RegExpCodeWire.MACHINE_CODE_WIRE, v);
            }
        }
    }
};
pub const V8RegExpCodeReader = struct {
    buf: gremlin.Reader,
    _v8_isolate_iid: u64 = 0,
    _tid: u32 = 0,
    _pattern_buf: ?[]const u8 = null,
    _instruction_start: u64 = 0,
    _instruction_size_bytes: u64 = 0,
    _machine_code: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!V8RegExpCodeReader {
        const buf = gremlin.Reader.init(src);
        var res = V8RegExpCodeReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                V8RegExpCodeWire.V8_ISOLATE_IID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._v8_isolate_iid = result.value;
                },
                V8RegExpCodeWire.TID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._tid = result.value;
                },
                V8RegExpCodeWire.PATTERN_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._pattern_buf = result.value;
                },
                V8RegExpCodeWire.INSTRUCTION_START_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._instruction_start = result.value;
                },
                V8RegExpCodeWire.INSTRUCTION_SIZE_BYTES_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._instruction_size_bytes = result.value;
                },
                V8RegExpCodeWire.MACHINE_CODE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._machine_code = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getV8IsolateIid(self: *const V8RegExpCodeReader) u64 {
        return self._v8_isolate_iid;
    }
    pub inline fn getTid(self: *const V8RegExpCodeReader) u32 {
        return self._tid;
    }
    pub fn getPattern(self: *const V8RegExpCodeReader) gremlin.Error!V8StringReader {
        if (self._pattern_buf) |buf| {
            return try V8StringReader.init(buf);
        }
        return try V8StringReader.init(&[_]u8{});
    }
    pub inline fn getInstructionStart(self: *const V8RegExpCodeReader) u64 {
        return self._instruction_start;
    }
    pub inline fn getInstructionSizeBytes(self: *const V8RegExpCodeReader) u64 {
        return self._instruction_size_bytes;
    }
    pub inline fn getMachineCode(self: *const V8RegExpCodeReader) []const u8 {
        return self._machine_code orelse &[_]u8{};
    }
};
const V8CodeMoveWire = struct {
    const ISOLATE_IID_WIRE: gremlin.ProtoWireNumber = 1;
    const TID_WIRE: gremlin.ProtoWireNumber = 2;
    const FROM_INSTRUCTION_START_ADDRESS_WIRE: gremlin.ProtoWireNumber = 3;
    const TO_INSTRUCTION_START_ADDRESS_WIRE: gremlin.ProtoWireNumber = 4;
    const INSTRUCTION_SIZE_BYTES_WIRE: gremlin.ProtoWireNumber = 5;
    const TO_MACHINE_CODE_WIRE: gremlin.ProtoWireNumber = 6;
    const TO_BYTECODE_WIRE: gremlin.ProtoWireNumber = 7;
};
pub const V8CodeMove = struct {
    // fields
    isolate_iid: u64 = 0,
    tid: u32 = 0,
    from_instruction_start_address: u64 = 0,
    to_instruction_start_address: u64 = 0,
    instruction_size_bytes: u64 = 0,
    to_machine_code: ?[]const u8 = null,
    to_bytecode: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const V8CodeMove) usize {
        var res: usize = 0;
        if (self.isolate_iid != 0) {
            res += gremlin.sizes.sizeWireNumber(V8CodeMoveWire.ISOLATE_IID_WIRE) + gremlin.sizes.sizeU64(self.isolate_iid);
        }
        if (self.tid != 0) {
            res += gremlin.sizes.sizeWireNumber(V8CodeMoveWire.TID_WIRE) + gremlin.sizes.sizeU32(self.tid);
        }
        if (self.from_instruction_start_address != 0) {
            res += gremlin.sizes.sizeWireNumber(V8CodeMoveWire.FROM_INSTRUCTION_START_ADDRESS_WIRE) + gremlin.sizes.sizeU64(self.from_instruction_start_address);
        }
        if (self.to_instruction_start_address != 0) {
            res += gremlin.sizes.sizeWireNumber(V8CodeMoveWire.TO_INSTRUCTION_START_ADDRESS_WIRE) + gremlin.sizes.sizeU64(self.to_instruction_start_address);
        }
        if (self.instruction_size_bytes != 0) {
            res += gremlin.sizes.sizeWireNumber(V8CodeMoveWire.INSTRUCTION_SIZE_BYTES_WIRE) + gremlin.sizes.sizeU64(self.instruction_size_bytes);
        }
        if (self.to_machine_code) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(V8CodeMoveWire.TO_MACHINE_CODE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.to_bytecode) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(V8CodeMoveWire.TO_BYTECODE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const V8CodeMove, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const V8CodeMove, target: *gremlin.Writer) void {
        if (self.isolate_iid != 0) {
            target.appendUint64(V8CodeMoveWire.ISOLATE_IID_WIRE, self.isolate_iid);
        }
        if (self.tid != 0) {
            target.appendUint32(V8CodeMoveWire.TID_WIRE, self.tid);
        }
        if (self.from_instruction_start_address != 0) {
            target.appendUint64(V8CodeMoveWire.FROM_INSTRUCTION_START_ADDRESS_WIRE, self.from_instruction_start_address);
        }
        if (self.to_instruction_start_address != 0) {
            target.appendUint64(V8CodeMoveWire.TO_INSTRUCTION_START_ADDRESS_WIRE, self.to_instruction_start_address);
        }
        if (self.instruction_size_bytes != 0) {
            target.appendUint64(V8CodeMoveWire.INSTRUCTION_SIZE_BYTES_WIRE, self.instruction_size_bytes);
        }
        if (self.to_machine_code) |v| {
            if (v.len > 0) {
                target.appendBytes(V8CodeMoveWire.TO_MACHINE_CODE_WIRE, v);
            }
        }
        if (self.to_bytecode) |v| {
            if (v.len > 0) {
                target.appendBytes(V8CodeMoveWire.TO_BYTECODE_WIRE, v);
            }
        }
    }
};
pub const V8CodeMoveReader = struct {
    buf: gremlin.Reader,
    _isolate_iid: u64 = 0,
    _tid: u32 = 0,
    _from_instruction_start_address: u64 = 0,
    _to_instruction_start_address: u64 = 0,
    _instruction_size_bytes: u64 = 0,
    _to_machine_code: ?[]const u8 = null,
    _to_bytecode: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!V8CodeMoveReader {
        const buf = gremlin.Reader.init(src);
        var res = V8CodeMoveReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                V8CodeMoveWire.ISOLATE_IID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._isolate_iid = result.value;
                },
                V8CodeMoveWire.TID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._tid = result.value;
                },
                V8CodeMoveWire.FROM_INSTRUCTION_START_ADDRESS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._from_instruction_start_address = result.value;
                },
                V8CodeMoveWire.TO_INSTRUCTION_START_ADDRESS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._to_instruction_start_address = result.value;
                },
                V8CodeMoveWire.INSTRUCTION_SIZE_BYTES_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._instruction_size_bytes = result.value;
                },
                V8CodeMoveWire.TO_MACHINE_CODE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._to_machine_code = result.value;
                },
                V8CodeMoveWire.TO_BYTECODE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._to_bytecode = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getIsolateIid(self: *const V8CodeMoveReader) u64 {
        return self._isolate_iid;
    }
    pub inline fn getTid(self: *const V8CodeMoveReader) u32 {
        return self._tid;
    }
    pub inline fn getFromInstructionStartAddress(self: *const V8CodeMoveReader) u64 {
        return self._from_instruction_start_address;
    }
    pub inline fn getToInstructionStartAddress(self: *const V8CodeMoveReader) u64 {
        return self._to_instruction_start_address;
    }
    pub inline fn getInstructionSizeBytes(self: *const V8CodeMoveReader) u64 {
        return self._instruction_size_bytes;
    }
    pub inline fn getToMachineCode(self: *const V8CodeMoveReader) []const u8 {
        return self._to_machine_code orelse &[_]u8{};
    }
    pub inline fn getToBytecode(self: *const V8CodeMoveReader) []const u8 {
        return self._to_bytecode orelse &[_]u8{};
    }
};
const V8CodeDefaultsWire = struct {
    const TID_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const V8CodeDefaults = struct {
    // fields
    tid: u32 = 0,
    pub fn calcProtobufSize(self: *const V8CodeDefaults) usize {
        var res: usize = 0;
        if (self.tid != 0) {
            res += gremlin.sizes.sizeWireNumber(V8CodeDefaultsWire.TID_WIRE) + gremlin.sizes.sizeU32(self.tid);
        }
        return res;
    }
    pub fn encode(self: *const V8CodeDefaults, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const V8CodeDefaults, target: *gremlin.Writer) void {
        if (self.tid != 0) {
            target.appendUint32(V8CodeDefaultsWire.TID_WIRE, self.tid);
        }
    }
};
pub const V8CodeDefaultsReader = struct {
    buf: gremlin.Reader,
    _tid: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!V8CodeDefaultsReader {
        const buf = gremlin.Reader.init(src);
        var res = V8CodeDefaultsReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                V8CodeDefaultsWire.TID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._tid = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getTid(self: *const V8CodeDefaultsReader) u32 {
        return self._tid;
    }
};
