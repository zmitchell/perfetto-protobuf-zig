// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const ChromeMetadataPacketWire = struct {
    const BACKGROUND_TRACING_METADATA_WIRE: gremlin.ProtoWireNumber = 1;
    const CHROME_VERSION_CODE_WIRE: gremlin.ProtoWireNumber = 2;
    const ENABLED_CATEGORIES_WIRE: gremlin.ProtoWireNumber = 3;
    const FIELD_TRIAL_HASHES_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const ChromeMetadataPacket = struct {
    // nested structs
    const FinchHashWire = struct {
        const NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const GROUP_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const FinchHash = struct {
        // fields
        name: u32 = 0,
        group: u32 = 0,
        pub fn calcProtobufSize(self: *const ChromeMetadataPacket.FinchHash) usize {
            var res: usize = 0;
            if (self.name != 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeMetadataPacket.FinchHashWire.NAME_WIRE) + gremlin.sizes.sizeU32(self.name);
            }
            if (self.group != 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeMetadataPacket.FinchHashWire.GROUP_WIRE) + gremlin.sizes.sizeU32(self.group);
            }
            return res;
        }
        pub fn encode(self: *const ChromeMetadataPacket.FinchHash, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const ChromeMetadataPacket.FinchHash, target: *gremlin.Writer) void {
            if (self.name != 0) {
                target.appendUint32(ChromeMetadataPacket.FinchHashWire.NAME_WIRE, self.name);
            }
            if (self.group != 0) {
                target.appendUint32(ChromeMetadataPacket.FinchHashWire.GROUP_WIRE, self.group);
            }
        }
    };
    pub const FinchHashReader = struct {
        buf: gremlin.Reader,
        _name: u32 = 0,
        _group: u32 = 0,
        pub fn init(src: []const u8) gremlin.Error!ChromeMetadataPacket.FinchHashReader {
            const buf = gremlin.Reader.init(src);
            var res = ChromeMetadataPacket.FinchHashReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    ChromeMetadataPacket.FinchHashWire.NAME_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    ChromeMetadataPacket.FinchHashWire.GROUP_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._group = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getName(self: *const ChromeMetadataPacket.FinchHashReader) u32 {
            return self._name;
        }
        pub inline fn getGroup(self: *const ChromeMetadataPacket.FinchHashReader) u32 {
            return self._group;
        }
    };
    // fields
    background_tracing_metadata: ?BackgroundTracingMetadata = null,
    chrome_version_code: i32 = 0,
    enabled_categories: ?[]const u8 = null,
    field_trial_hashes: ?[]const ?ChromeMetadataPacket.FinchHash = null,
    pub fn calcProtobufSize(self: *const ChromeMetadataPacket) usize {
        var res: usize = 0;
        if (self.background_tracing_metadata) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeMetadataPacketWire.BACKGROUND_TRACING_METADATA_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_version_code != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeMetadataPacketWire.CHROME_VERSION_CODE_WIRE) + gremlin.sizes.sizeI32(self.chrome_version_code);
        }
        if (self.enabled_categories) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeMetadataPacketWire.ENABLED_CATEGORIES_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.field_trial_hashes) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ChromeMetadataPacketWire.FIELD_TRIAL_HASHES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const ChromeMetadataPacket, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ChromeMetadataPacket, target: *gremlin.Writer) void {
        if (self.background_tracing_metadata) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeMetadataPacketWire.BACKGROUND_TRACING_METADATA_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_version_code != 0) {
            target.appendInt32(ChromeMetadataPacketWire.CHROME_VERSION_CODE_WIRE, self.chrome_version_code);
        }
        if (self.enabled_categories) |v| {
            if (v.len > 0) {
                target.appendBytes(ChromeMetadataPacketWire.ENABLED_CATEGORIES_WIRE, v);
            }
        }
        if (self.field_trial_hashes) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(ChromeMetadataPacketWire.FIELD_TRIAL_HASHES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(ChromeMetadataPacketWire.FIELD_TRIAL_HASHES_WIRE, 0);
                }
            }
        }
    }
};
pub const ChromeMetadataPacketReader = struct {
    buf: gremlin.Reader,
    _background_tracing_metadata_buf: ?[]const u8 = null,
    _chrome_version_code: i32 = 0,
    _enabled_categories: ?[]const u8 = null,
    _field_trial_hashes_offset: ?usize = null,
    _field_trial_hashes_last_offset: ?usize = null,
    _field_trial_hashes_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!ChromeMetadataPacketReader {
        const buf = gremlin.Reader.init(src);
        var res = ChromeMetadataPacketReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ChromeMetadataPacketWire.BACKGROUND_TRACING_METADATA_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._background_tracing_metadata_buf = result.value;
                },
                ChromeMetadataPacketWire.CHROME_VERSION_CODE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._chrome_version_code = result.value;
                },
                ChromeMetadataPacketWire.ENABLED_CATEGORIES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._enabled_categories = result.value;
                },
                ChromeMetadataPacketWire.FIELD_TRIAL_HASHES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._field_trial_hashes_offset == null) {
                        res._field_trial_hashes_offset = offset - result.size;
                    }
                    res._field_trial_hashes_last_offset = offset;
                    res._field_trial_hashes_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getBackgroundTracingMetadata(self: *const ChromeMetadataPacketReader) gremlin.Error!BackgroundTracingMetadataReader {
        if (self._background_tracing_metadata_buf) |buf| {
            return try BackgroundTracingMetadataReader.init(buf);
        }
        return try BackgroundTracingMetadataReader.init(&[_]u8{});
    }
    pub inline fn getChromeVersionCode(self: *const ChromeMetadataPacketReader) i32 {
        return self._chrome_version_code;
    }
    pub inline fn getEnabledCategories(self: *const ChromeMetadataPacketReader) []const u8 {
        return self._enabled_categories orelse &[_]u8{};
    }
    pub fn fieldTrialHashesCount(self: *const ChromeMetadataPacketReader) usize {
        return self._field_trial_hashes_cnt;
    }
    pub fn fieldTrialHashesNext(self: *ChromeMetadataPacketReader) ?ChromeMetadataPacket.FinchHashReader {
        if (self._field_trial_hashes_offset == null) return null;
        const current_offset = self._field_trial_hashes_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = ChromeMetadataPacket.FinchHashReader.init(result.value) catch return null;
        if (self._field_trial_hashes_last_offset != null and current_offset >= self._field_trial_hashes_last_offset.?) {
            self._field_trial_hashes_offset = null;
            return msg;
        }
        if (self._field_trial_hashes_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._field_trial_hashes_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ChromeMetadataPacketWire.FIELD_TRIAL_HASHES_WIRE) {
                self._field_trial_hashes_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._field_trial_hashes_offset = null;
        return msg;
    }
};
const BackgroundTracingMetadataWire = struct {
    const TRIGGERED_RULE_WIRE: gremlin.ProtoWireNumber = 1;
    const ACTIVE_RULES_WIRE: gremlin.ProtoWireNumber = 2;
    const SCENARIO_NAME_HASH_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const BackgroundTracingMetadata = struct {
    // nested structs
    const TriggerRuleWire = struct {
        const TRIGGER_TYPE_WIRE: gremlin.ProtoWireNumber = 1;
        const HISTOGRAM_RULE_WIRE: gremlin.ProtoWireNumber = 2;
        const NAMED_RULE_WIRE: gremlin.ProtoWireNumber = 3;
        const NAME_HASH_WIRE: gremlin.ProtoWireNumber = 4;
    };
    pub const TriggerRule = struct {
        // nested enums
        pub const TriggerType = enum(i32) {
            TRIGGER_UNSPECIFIED = 0,
            MONITOR_AND_DUMP_WHEN_SPECIFIC_HISTOGRAM_AND_VALUE = 1,
            MONITOR_AND_DUMP_WHEN_TRIGGER_NAMED = 2,
        };
        // nested structs
        const HistogramRuleWire = struct {
            const HISTOGRAM_NAME_HASH_WIRE: gremlin.ProtoWireNumber = 1;
            const HISTOGRAM_MIN_TRIGGER_WIRE: gremlin.ProtoWireNumber = 2;
            const HISTOGRAM_MAX_TRIGGER_WIRE: gremlin.ProtoWireNumber = 3;
        };
        pub const HistogramRule = struct {
            // fields
            histogram_name_hash: u64 = 0,
            histogram_min_trigger: i64 = 0,
            histogram_max_trigger: i64 = 0,
            pub fn calcProtobufSize(self: *const BackgroundTracingMetadata.TriggerRule.HistogramRule) usize {
                var res: usize = 0;
                if (self.histogram_name_hash != 0) {
                    res += gremlin.sizes.sizeWireNumber(BackgroundTracingMetadata.TriggerRule.HistogramRuleWire.HISTOGRAM_NAME_HASH_WIRE) + gremlin.sizes.sizeFixed64(self.histogram_name_hash);
                }
                if (self.histogram_min_trigger != 0) {
                    res += gremlin.sizes.sizeWireNumber(BackgroundTracingMetadata.TriggerRule.HistogramRuleWire.HISTOGRAM_MIN_TRIGGER_WIRE) + gremlin.sizes.sizeI64(self.histogram_min_trigger);
                }
                if (self.histogram_max_trigger != 0) {
                    res += gremlin.sizes.sizeWireNumber(BackgroundTracingMetadata.TriggerRule.HistogramRuleWire.HISTOGRAM_MAX_TRIGGER_WIRE) + gremlin.sizes.sizeI64(self.histogram_max_trigger);
                }
                return res;
            }
            pub fn encode(self: *const BackgroundTracingMetadata.TriggerRule.HistogramRule, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const BackgroundTracingMetadata.TriggerRule.HistogramRule, target: *gremlin.Writer) void {
                if (self.histogram_name_hash != 0) {
                    target.appendFixed64(BackgroundTracingMetadata.TriggerRule.HistogramRuleWire.HISTOGRAM_NAME_HASH_WIRE, self.histogram_name_hash);
                }
                if (self.histogram_min_trigger != 0) {
                    target.appendInt64(BackgroundTracingMetadata.TriggerRule.HistogramRuleWire.HISTOGRAM_MIN_TRIGGER_WIRE, self.histogram_min_trigger);
                }
                if (self.histogram_max_trigger != 0) {
                    target.appendInt64(BackgroundTracingMetadata.TriggerRule.HistogramRuleWire.HISTOGRAM_MAX_TRIGGER_WIRE, self.histogram_max_trigger);
                }
            }
        };
        pub const HistogramRuleReader = struct {
            buf: gremlin.Reader,
            _histogram_name_hash: u64 = 0,
            _histogram_min_trigger: i64 = 0,
            _histogram_max_trigger: i64 = 0,
            pub fn init(src: []const u8) gremlin.Error!BackgroundTracingMetadata.TriggerRule.HistogramRuleReader {
                const buf = gremlin.Reader.init(src);
                var res = BackgroundTracingMetadata.TriggerRule.HistogramRuleReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        BackgroundTracingMetadata.TriggerRule.HistogramRuleWire.HISTOGRAM_NAME_HASH_WIRE => {
                            const result = try buf.readFixed64(offset);
                            offset += result.size;
                            res._histogram_name_hash = result.value;
                        },
                        BackgroundTracingMetadata.TriggerRule.HistogramRuleWire.HISTOGRAM_MIN_TRIGGER_WIRE => {
                            const result = try buf.readInt64(offset);
                            offset += result.size;
                            res._histogram_min_trigger = result.value;
                        },
                        BackgroundTracingMetadata.TriggerRule.HistogramRuleWire.HISTOGRAM_MAX_TRIGGER_WIRE => {
                            const result = try buf.readInt64(offset);
                            offset += result.size;
                            res._histogram_max_trigger = result.value;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub inline fn getHistogramNameHash(self: *const BackgroundTracingMetadata.TriggerRule.HistogramRuleReader) u64 {
                return self._histogram_name_hash;
            }
            pub inline fn getHistogramMinTrigger(self: *const BackgroundTracingMetadata.TriggerRule.HistogramRuleReader) i64 {
                return self._histogram_min_trigger;
            }
            pub inline fn getHistogramMaxTrigger(self: *const BackgroundTracingMetadata.TriggerRule.HistogramRuleReader) i64 {
                return self._histogram_max_trigger;
            }
        };
        const NamedRuleWire = struct {
            const EVENT_TYPE_WIRE: gremlin.ProtoWireNumber = 1;
            const CONTENT_TRIGGER_NAME_HASH_WIRE: gremlin.ProtoWireNumber = 2;
        };
        pub const NamedRule = struct {
            // nested enums
            pub const EventType = enum(i32) {
                UNSPECIFIED = 0,
                SESSION_RESTORE = 1,
                NAVIGATION = 2,
                STARTUP = 3,
                REACHED_CODE = 4,
                CONTENT_TRIGGER = 5,
                TEST_RULE = 1000,
            };
            // fields
            event_type: BackgroundTracingMetadata.TriggerRule.NamedRule.EventType = @enumFromInt(0),
            content_trigger_name_hash: u64 = 0,
            pub fn calcProtobufSize(self: *const BackgroundTracingMetadata.TriggerRule.NamedRule) usize {
                var res: usize = 0;
                if (@intFromEnum(self.event_type) != 0) {
                    res += gremlin.sizes.sizeWireNumber(BackgroundTracingMetadata.TriggerRule.NamedRuleWire.EVENT_TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.event_type));
                }
                if (self.content_trigger_name_hash != 0) {
                    res += gremlin.sizes.sizeWireNumber(BackgroundTracingMetadata.TriggerRule.NamedRuleWire.CONTENT_TRIGGER_NAME_HASH_WIRE) + gremlin.sizes.sizeFixed64(self.content_trigger_name_hash);
                }
                return res;
            }
            pub fn encode(self: *const BackgroundTracingMetadata.TriggerRule.NamedRule, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const BackgroundTracingMetadata.TriggerRule.NamedRule, target: *gremlin.Writer) void {
                if (@intFromEnum(self.event_type) != 0) {
                    target.appendInt32(BackgroundTracingMetadata.TriggerRule.NamedRuleWire.EVENT_TYPE_WIRE, @intFromEnum(self.event_type));
                }
                if (self.content_trigger_name_hash != 0) {
                    target.appendFixed64(BackgroundTracingMetadata.TriggerRule.NamedRuleWire.CONTENT_TRIGGER_NAME_HASH_WIRE, self.content_trigger_name_hash);
                }
            }
        };
        pub const NamedRuleReader = struct {
            buf: gremlin.Reader,
            _event_type: BackgroundTracingMetadata.TriggerRule.NamedRule.EventType = @enumFromInt(0),
            _content_trigger_name_hash: u64 = 0,
            pub fn init(src: []const u8) gremlin.Error!BackgroundTracingMetadata.TriggerRule.NamedRuleReader {
                const buf = gremlin.Reader.init(src);
                var res = BackgroundTracingMetadata.TriggerRule.NamedRuleReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        BackgroundTracingMetadata.TriggerRule.NamedRuleWire.EVENT_TYPE_WIRE => {
                            const result = try buf.readInt32(offset);
                            offset += result.size;
                            res._event_type = @enumFromInt(result.value);
                        },
                        BackgroundTracingMetadata.TriggerRule.NamedRuleWire.CONTENT_TRIGGER_NAME_HASH_WIRE => {
                            const result = try buf.readFixed64(offset);
                            offset += result.size;
                            res._content_trigger_name_hash = result.value;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub inline fn getEventType(self: *const BackgroundTracingMetadata.TriggerRule.NamedRuleReader) BackgroundTracingMetadata.TriggerRule.NamedRule.EventType {
                return self._event_type;
            }
            pub inline fn getContentTriggerNameHash(self: *const BackgroundTracingMetadata.TriggerRule.NamedRuleReader) u64 {
                return self._content_trigger_name_hash;
            }
        };
        // fields
        trigger_type: BackgroundTracingMetadata.TriggerRule.TriggerType = @enumFromInt(0),
        histogram_rule: ?BackgroundTracingMetadata.TriggerRule.HistogramRule = null,
        named_rule: ?BackgroundTracingMetadata.TriggerRule.NamedRule = null,
        name_hash: u32 = 0,
        pub fn calcProtobufSize(self: *const BackgroundTracingMetadata.TriggerRule) usize {
            var res: usize = 0;
            if (@intFromEnum(self.trigger_type) != 0) {
                res += gremlin.sizes.sizeWireNumber(BackgroundTracingMetadata.TriggerRuleWire.TRIGGER_TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.trigger_type));
            }
            if (self.histogram_rule) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(BackgroundTracingMetadata.TriggerRuleWire.HISTOGRAM_RULE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.named_rule) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(BackgroundTracingMetadata.TriggerRuleWire.NAMED_RULE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.name_hash != 0) {
                res += gremlin.sizes.sizeWireNumber(BackgroundTracingMetadata.TriggerRuleWire.NAME_HASH_WIRE) + gremlin.sizes.sizeFixed32(self.name_hash);
            }
            return res;
        }
        pub fn encode(self: *const BackgroundTracingMetadata.TriggerRule, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const BackgroundTracingMetadata.TriggerRule, target: *gremlin.Writer) void {
            if (@intFromEnum(self.trigger_type) != 0) {
                target.appendInt32(BackgroundTracingMetadata.TriggerRuleWire.TRIGGER_TYPE_WIRE, @intFromEnum(self.trigger_type));
            }
            if (self.histogram_rule) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(BackgroundTracingMetadata.TriggerRuleWire.HISTOGRAM_RULE_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.named_rule) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(BackgroundTracingMetadata.TriggerRuleWire.NAMED_RULE_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.name_hash != 0) {
                target.appendFixed32(BackgroundTracingMetadata.TriggerRuleWire.NAME_HASH_WIRE, self.name_hash);
            }
        }
    };
    pub const TriggerRuleReader = struct {
        buf: gremlin.Reader,
        _trigger_type: BackgroundTracingMetadata.TriggerRule.TriggerType = @enumFromInt(0),
        _histogram_rule_buf: ?[]const u8 = null,
        _named_rule_buf: ?[]const u8 = null,
        _name_hash: u32 = 0,
        pub fn init(src: []const u8) gremlin.Error!BackgroundTracingMetadata.TriggerRuleReader {
            const buf = gremlin.Reader.init(src);
            var res = BackgroundTracingMetadata.TriggerRuleReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    BackgroundTracingMetadata.TriggerRuleWire.TRIGGER_TYPE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._trigger_type = @enumFromInt(result.value);
                    },
                    BackgroundTracingMetadata.TriggerRuleWire.HISTOGRAM_RULE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._histogram_rule_buf = result.value;
                    },
                    BackgroundTracingMetadata.TriggerRuleWire.NAMED_RULE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._named_rule_buf = result.value;
                    },
                    BackgroundTracingMetadata.TriggerRuleWire.NAME_HASH_WIRE => {
                        const result = try buf.readFixed32(offset);
                        offset += result.size;
                        res._name_hash = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getTriggerType(self: *const BackgroundTracingMetadata.TriggerRuleReader) BackgroundTracingMetadata.TriggerRule.TriggerType {
            return self._trigger_type;
        }
        pub fn getHistogramRule(self: *const BackgroundTracingMetadata.TriggerRuleReader) gremlin.Error!BackgroundTracingMetadata.TriggerRule.HistogramRuleReader {
            if (self._histogram_rule_buf) |buf| {
                return try BackgroundTracingMetadata.TriggerRule.HistogramRuleReader.init(buf);
            }
            return try BackgroundTracingMetadata.TriggerRule.HistogramRuleReader.init(&[_]u8{});
        }
        pub fn getNamedRule(self: *const BackgroundTracingMetadata.TriggerRuleReader) gremlin.Error!BackgroundTracingMetadata.TriggerRule.NamedRuleReader {
            if (self._named_rule_buf) |buf| {
                return try BackgroundTracingMetadata.TriggerRule.NamedRuleReader.init(buf);
            }
            return try BackgroundTracingMetadata.TriggerRule.NamedRuleReader.init(&[_]u8{});
        }
        pub inline fn getNameHash(self: *const BackgroundTracingMetadata.TriggerRuleReader) u32 {
            return self._name_hash;
        }
    };
    // fields
    triggered_rule: ?BackgroundTracingMetadata.TriggerRule = null,
    active_rules: ?[]const ?BackgroundTracingMetadata.TriggerRule = null,
    scenario_name_hash: u32 = 0,
    pub fn calcProtobufSize(self: *const BackgroundTracingMetadata) usize {
        var res: usize = 0;
        if (self.triggered_rule) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(BackgroundTracingMetadataWire.TRIGGERED_RULE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.active_rules) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(BackgroundTracingMetadataWire.ACTIVE_RULES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.scenario_name_hash != 0) {
            res += gremlin.sizes.sizeWireNumber(BackgroundTracingMetadataWire.SCENARIO_NAME_HASH_WIRE) + gremlin.sizes.sizeFixed32(self.scenario_name_hash);
        }
        return res;
    }
    pub fn encode(self: *const BackgroundTracingMetadata, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const BackgroundTracingMetadata, target: *gremlin.Writer) void {
        if (self.triggered_rule) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(BackgroundTracingMetadataWire.TRIGGERED_RULE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.active_rules) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(BackgroundTracingMetadataWire.ACTIVE_RULES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(BackgroundTracingMetadataWire.ACTIVE_RULES_WIRE, 0);
                }
            }
        }
        if (self.scenario_name_hash != 0) {
            target.appendFixed32(BackgroundTracingMetadataWire.SCENARIO_NAME_HASH_WIRE, self.scenario_name_hash);
        }
    }
};
pub const BackgroundTracingMetadataReader = struct {
    buf: gremlin.Reader,
    _triggered_rule_buf: ?[]const u8 = null,
    _active_rules_offset: ?usize = null,
    _active_rules_last_offset: ?usize = null,
    _active_rules_cnt: usize = 0,
    _scenario_name_hash: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!BackgroundTracingMetadataReader {
        const buf = gremlin.Reader.init(src);
        var res = BackgroundTracingMetadataReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                BackgroundTracingMetadataWire.TRIGGERED_RULE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._triggered_rule_buf = result.value;
                },
                BackgroundTracingMetadataWire.ACTIVE_RULES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._active_rules_offset == null) {
                        res._active_rules_offset = offset - result.size;
                    }
                    res._active_rules_last_offset = offset;
                    res._active_rules_cnt += 1;
                },
                BackgroundTracingMetadataWire.SCENARIO_NAME_HASH_WIRE => {
                    const result = try buf.readFixed32(offset);
                    offset += result.size;
                    res._scenario_name_hash = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getTriggeredRule(self: *const BackgroundTracingMetadataReader) gremlin.Error!BackgroundTracingMetadata.TriggerRuleReader {
        if (self._triggered_rule_buf) |buf| {
            return try BackgroundTracingMetadata.TriggerRuleReader.init(buf);
        }
        return try BackgroundTracingMetadata.TriggerRuleReader.init(&[_]u8{});
    }
    pub fn activeRulesCount(self: *const BackgroundTracingMetadataReader) usize {
        return self._active_rules_cnt;
    }
    pub fn activeRulesNext(self: *BackgroundTracingMetadataReader) ?BackgroundTracingMetadata.TriggerRuleReader {
        if (self._active_rules_offset == null) return null;
        const current_offset = self._active_rules_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = BackgroundTracingMetadata.TriggerRuleReader.init(result.value) catch return null;
        if (self._active_rules_last_offset != null and current_offset >= self._active_rules_last_offset.?) {
            self._active_rules_offset = null;
            return msg;
        }
        if (self._active_rules_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._active_rules_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == BackgroundTracingMetadataWire.ACTIVE_RULES_WIRE) {
                self._active_rules_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._active_rules_offset = null;
        return msg;
    }
    pub inline fn getScenarioNameHash(self: *const BackgroundTracingMetadataReader) u32 {
        return self._scenario_name_hash;
    }
};
