// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const ChromeTracedValueWire = struct {
    const NESTED_TYPE_WIRE: gremlin.ProtoWireNumber = 1;
    const DICT_KEYS_WIRE: gremlin.ProtoWireNumber = 2;
    const DICT_VALUES_WIRE: gremlin.ProtoWireNumber = 3;
    const ARRAY_VALUES_WIRE: gremlin.ProtoWireNumber = 4;
    const INT_VALUE_WIRE: gremlin.ProtoWireNumber = 5;
    const DOUBLE_VALUE_WIRE: gremlin.ProtoWireNumber = 6;
    const BOOL_VALUE_WIRE: gremlin.ProtoWireNumber = 7;
    const STRING_VALUE_WIRE: gremlin.ProtoWireNumber = 8;
};
pub const ChromeTracedValue = struct {
    // nested enums
    pub const NestedType = enum(i32) {
        DICT = 0,
        ARRAY = 1,
    };
    // fields
    nested_type: ChromeTracedValue.NestedType = @enumFromInt(0),
    dict_keys: ?[]const ?[]const u8 = null,
    dict_values: ?[]const ?ChromeTracedValue = null,
    array_values: ?[]const ?ChromeTracedValue = null,
    int_value: i32 = 0,
    double_value: f64 = 0.0,
    bool_value: bool = false,
    string_value: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const ChromeTracedValue) usize {
        var res: usize = 0;
        if (@intFromEnum(self.nested_type) != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeTracedValueWire.NESTED_TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.nested_type));
        }
        if (self.dict_keys) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ChromeTracedValueWire.DICT_KEYS_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.dict_values) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ChromeTracedValueWire.DICT_VALUES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.array_values) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ChromeTracedValueWire.ARRAY_VALUES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.int_value != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeTracedValueWire.INT_VALUE_WIRE) + gremlin.sizes.sizeI32(self.int_value);
        }
        if (self.double_value != 0.0) {
            res += gremlin.sizes.sizeWireNumber(ChromeTracedValueWire.DOUBLE_VALUE_WIRE) + gremlin.sizes.sizeDouble(self.double_value);
        }
        if (self.bool_value != false) {
            res += gremlin.sizes.sizeWireNumber(ChromeTracedValueWire.BOOL_VALUE_WIRE) + gremlin.sizes.sizeBool(self.bool_value);
        }
        if (self.string_value) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeTracedValueWire.STRING_VALUE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const ChromeTracedValue, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ChromeTracedValue, target: *gremlin.Writer) void {
        if (@intFromEnum(self.nested_type) != 0) {
            target.appendInt32(ChromeTracedValueWire.NESTED_TYPE_WIRE, @intFromEnum(self.nested_type));
        }
        if (self.dict_keys) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(ChromeTracedValueWire.DICT_KEYS_WIRE, v);
                } else {
                    target.appendBytesTag(ChromeTracedValueWire.DICT_KEYS_WIRE, 0);
                }
            }
        }
        if (self.dict_values) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(ChromeTracedValueWire.DICT_VALUES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(ChromeTracedValueWire.DICT_VALUES_WIRE, 0);
                }
            }
        }
        if (self.array_values) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(ChromeTracedValueWire.ARRAY_VALUES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(ChromeTracedValueWire.ARRAY_VALUES_WIRE, 0);
                }
            }
        }
        if (self.int_value != 0) {
            target.appendInt32(ChromeTracedValueWire.INT_VALUE_WIRE, self.int_value);
        }
        if (self.double_value != 0.0) {
            target.appendFloat64(ChromeTracedValueWire.DOUBLE_VALUE_WIRE, self.double_value);
        }
        if (self.bool_value != false) {
            target.appendBool(ChromeTracedValueWire.BOOL_VALUE_WIRE, self.bool_value);
        }
        if (self.string_value) |v| {
            if (v.len > 0) {
                target.appendBytes(ChromeTracedValueWire.STRING_VALUE_WIRE, v);
            }
        }
    }
};
pub const ChromeTracedValueReader = struct {
    buf: gremlin.Reader,
    _nested_type: ChromeTracedValue.NestedType = @enumFromInt(0),
    _dict_keys_offset: ?usize = null,
    _dict_keys_last_offset: ?usize = null,
    _dict_keys_cnt: usize = 0,
    _dict_values_offset: ?usize = null,
    _dict_values_last_offset: ?usize = null,
    _dict_values_cnt: usize = 0,
    _array_values_offset: ?usize = null,
    _array_values_last_offset: ?usize = null,
    _array_values_cnt: usize = 0,
    _int_value: i32 = 0,
    _double_value: f64 = 0.0,
    _bool_value: bool = false,
    _string_value: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!ChromeTracedValueReader {
        const buf = gremlin.Reader.init(src);
        var res = ChromeTracedValueReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ChromeTracedValueWire.NESTED_TYPE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._nested_type = @enumFromInt(result.value);
                },
                ChromeTracedValueWire.DICT_KEYS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._dict_keys_offset == null) {
                        res._dict_keys_offset = offset - result.size;
                    }
                    res._dict_keys_last_offset = offset;
                    res._dict_keys_cnt += 1;
                },
                ChromeTracedValueWire.DICT_VALUES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._dict_values_offset == null) {
                        res._dict_values_offset = offset - result.size;
                    }
                    res._dict_values_last_offset = offset;
                    res._dict_values_cnt += 1;
                },
                ChromeTracedValueWire.ARRAY_VALUES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._array_values_offset == null) {
                        res._array_values_offset = offset - result.size;
                    }
                    res._array_values_last_offset = offset;
                    res._array_values_cnt += 1;
                },
                ChromeTracedValueWire.INT_VALUE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._int_value = result.value;
                },
                ChromeTracedValueWire.DOUBLE_VALUE_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._double_value = result.value;
                },
                ChromeTracedValueWire.BOOL_VALUE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._bool_value = result.value;
                },
                ChromeTracedValueWire.STRING_VALUE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._string_value = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getNestedType(self: *const ChromeTracedValueReader) ChromeTracedValue.NestedType {
        return self._nested_type;
    }
    pub fn dictKeysCount(self: *const ChromeTracedValueReader) usize {
        return self._dict_keys_cnt;
    }
    pub fn dictKeysNext(self: *ChromeTracedValueReader) ?[]const u8 {
        if (self._dict_keys_offset == null) return null;
        const current_offset = self._dict_keys_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._dict_keys_last_offset != null and current_offset >= self._dict_keys_last_offset.?) {
            self._dict_keys_offset = null;
            return result.value;
        }
        if (self._dict_keys_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._dict_keys_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ChromeTracedValueWire.DICT_KEYS_WIRE) {
                self._dict_keys_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._dict_keys_offset = null;
        return result.value;
    }
    pub fn dictValuesCount(self: *const ChromeTracedValueReader) usize {
        return self._dict_values_cnt;
    }
    pub fn dictValuesNext(self: *ChromeTracedValueReader) ?ChromeTracedValueReader {
        if (self._dict_values_offset == null) return null;
        const current_offset = self._dict_values_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = ChromeTracedValueReader.init(result.value) catch return null;
        if (self._dict_values_last_offset != null and current_offset >= self._dict_values_last_offset.?) {
            self._dict_values_offset = null;
            return msg;
        }
        if (self._dict_values_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._dict_values_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ChromeTracedValueWire.DICT_VALUES_WIRE) {
                self._dict_values_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._dict_values_offset = null;
        return msg;
    }
    pub fn arrayValuesCount(self: *const ChromeTracedValueReader) usize {
        return self._array_values_cnt;
    }
    pub fn arrayValuesNext(self: *ChromeTracedValueReader) ?ChromeTracedValueReader {
        if (self._array_values_offset == null) return null;
        const current_offset = self._array_values_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = ChromeTracedValueReader.init(result.value) catch return null;
        if (self._array_values_last_offset != null and current_offset >= self._array_values_last_offset.?) {
            self._array_values_offset = null;
            return msg;
        }
        if (self._array_values_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._array_values_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ChromeTracedValueWire.ARRAY_VALUES_WIRE) {
                self._array_values_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._array_values_offset = null;
        return msg;
    }
    pub inline fn getIntValue(self: *const ChromeTracedValueReader) i32 {
        return self._int_value;
    }
    pub inline fn getDoubleValue(self: *const ChromeTracedValueReader) f64 {
        return self._double_value;
    }
    pub inline fn getBoolValue(self: *const ChromeTracedValueReader) bool {
        return self._bool_value;
    }
    pub inline fn getStringValue(self: *const ChromeTracedValueReader) []const u8 {
        return self._string_value orelse &[_]u8{};
    }
};
const ChromeStringTableEntryWire = struct {
    const VALUE_WIRE: gremlin.ProtoWireNumber = 1;
    const INDEX_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const ChromeStringTableEntry = struct {
    // fields
    value: ?[]const u8 = null,
    index: i32 = 0,
    pub fn calcProtobufSize(self: *const ChromeStringTableEntry) usize {
        var res: usize = 0;
        if (self.value) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeStringTableEntryWire.VALUE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.index != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeStringTableEntryWire.INDEX_WIRE) + gremlin.sizes.sizeI32(self.index);
        }
        return res;
    }
    pub fn encode(self: *const ChromeStringTableEntry, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ChromeStringTableEntry, target: *gremlin.Writer) void {
        if (self.value) |v| {
            if (v.len > 0) {
                target.appendBytes(ChromeStringTableEntryWire.VALUE_WIRE, v);
            }
        }
        if (self.index != 0) {
            target.appendInt32(ChromeStringTableEntryWire.INDEX_WIRE, self.index);
        }
    }
};
pub const ChromeStringTableEntryReader = struct {
    buf: gremlin.Reader,
    _value: ?[]const u8 = null,
    _index: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!ChromeStringTableEntryReader {
        const buf = gremlin.Reader.init(src);
        var res = ChromeStringTableEntryReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ChromeStringTableEntryWire.VALUE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._value = result.value;
                },
                ChromeStringTableEntryWire.INDEX_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._index = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getValue(self: *const ChromeStringTableEntryReader) []const u8 {
        return self._value orelse &[_]u8{};
    }
    pub inline fn getIndex(self: *const ChromeStringTableEntryReader) i32 {
        return self._index;
    }
};
const ChromeTraceEventWire = struct {
    const NAME_WIRE: gremlin.ProtoWireNumber = 1;
    const TIMESTAMP_WIRE: gremlin.ProtoWireNumber = 2;
    const PHASE_WIRE: gremlin.ProtoWireNumber = 3;
    const THREAD_ID_WIRE: gremlin.ProtoWireNumber = 4;
    const DURATION_WIRE: gremlin.ProtoWireNumber = 5;
    const THREAD_DURATION_WIRE: gremlin.ProtoWireNumber = 6;
    const SCOPE_WIRE: gremlin.ProtoWireNumber = 7;
    const ID_WIRE: gremlin.ProtoWireNumber = 8;
    const FLAGS_WIRE: gremlin.ProtoWireNumber = 9;
    const CATEGORY_GROUP_NAME_WIRE: gremlin.ProtoWireNumber = 10;
    const PROCESS_ID_WIRE: gremlin.ProtoWireNumber = 11;
    const THREAD_TIMESTAMP_WIRE: gremlin.ProtoWireNumber = 12;
    const BIND_ID_WIRE: gremlin.ProtoWireNumber = 13;
    const ARGS_WIRE: gremlin.ProtoWireNumber = 14;
    const NAME_INDEX_WIRE: gremlin.ProtoWireNumber = 15;
    const CATEGORY_GROUP_NAME_INDEX_WIRE: gremlin.ProtoWireNumber = 16;
};
pub const ChromeTraceEvent = struct {
    // nested structs
    const ArgWire = struct {
        const NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const NAME_INDEX_WIRE: gremlin.ProtoWireNumber = 9;
        const BOOL_VALUE_WIRE: gremlin.ProtoWireNumber = 2;
        const UINT_VALUE_WIRE: gremlin.ProtoWireNumber = 3;
        const INT_VALUE_WIRE: gremlin.ProtoWireNumber = 4;
        const DOUBLE_VALUE_WIRE: gremlin.ProtoWireNumber = 5;
        const STRING_VALUE_WIRE: gremlin.ProtoWireNumber = 6;
        const POINTER_VALUE_WIRE: gremlin.ProtoWireNumber = 7;
        const JSON_VALUE_WIRE: gremlin.ProtoWireNumber = 8;
        const TRACED_VALUE_WIRE: gremlin.ProtoWireNumber = 10;
    };
    pub const Arg = struct {
        // fields
        name: ?[]const u8 = null,
        name_index: u32 = 0,
        bool_value: bool = false,
        uint_value: u64 = 0,
        int_value: i64 = 0,
        double_value: f64 = 0.0,
        string_value: ?[]const u8 = null,
        pointer_value: u64 = 0,
        json_value: ?[]const u8 = null,
        traced_value: ?ChromeTracedValue = null,
        pub fn calcProtobufSize(self: *const ChromeTraceEvent.Arg) usize {
            var res: usize = 0;
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(ChromeTraceEvent.ArgWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.name_index != 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeTraceEvent.ArgWire.NAME_INDEX_WIRE) + gremlin.sizes.sizeU32(self.name_index);
            }
            if (self.bool_value != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeTraceEvent.ArgWire.BOOL_VALUE_WIRE) + gremlin.sizes.sizeBool(self.bool_value);
            }
            if (self.uint_value != 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeTraceEvent.ArgWire.UINT_VALUE_WIRE) + gremlin.sizes.sizeU64(self.uint_value);
            }
            if (self.int_value != 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeTraceEvent.ArgWire.INT_VALUE_WIRE) + gremlin.sizes.sizeI64(self.int_value);
            }
            if (self.double_value != 0.0) {
                res += gremlin.sizes.sizeWireNumber(ChromeTraceEvent.ArgWire.DOUBLE_VALUE_WIRE) + gremlin.sizes.sizeDouble(self.double_value);
            }
            if (self.string_value) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(ChromeTraceEvent.ArgWire.STRING_VALUE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.pointer_value != 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeTraceEvent.ArgWire.POINTER_VALUE_WIRE) + gremlin.sizes.sizeU64(self.pointer_value);
            }
            if (self.json_value) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(ChromeTraceEvent.ArgWire.JSON_VALUE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.traced_value) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(ChromeTraceEvent.ArgWire.TRACED_VALUE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            return res;
        }
        pub fn encode(self: *const ChromeTraceEvent.Arg, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const ChromeTraceEvent.Arg, target: *gremlin.Writer) void {
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(ChromeTraceEvent.ArgWire.NAME_WIRE, v);
                }
            }
            if (self.name_index != 0) {
                target.appendUint32(ChromeTraceEvent.ArgWire.NAME_INDEX_WIRE, self.name_index);
            }
            if (self.bool_value != false) {
                target.appendBool(ChromeTraceEvent.ArgWire.BOOL_VALUE_WIRE, self.bool_value);
            }
            if (self.uint_value != 0) {
                target.appendUint64(ChromeTraceEvent.ArgWire.UINT_VALUE_WIRE, self.uint_value);
            }
            if (self.int_value != 0) {
                target.appendInt64(ChromeTraceEvent.ArgWire.INT_VALUE_WIRE, self.int_value);
            }
            if (self.double_value != 0.0) {
                target.appendFloat64(ChromeTraceEvent.ArgWire.DOUBLE_VALUE_WIRE, self.double_value);
            }
            if (self.string_value) |v| {
                if (v.len > 0) {
                    target.appendBytes(ChromeTraceEvent.ArgWire.STRING_VALUE_WIRE, v);
                }
            }
            if (self.pointer_value != 0) {
                target.appendUint64(ChromeTraceEvent.ArgWire.POINTER_VALUE_WIRE, self.pointer_value);
            }
            if (self.json_value) |v| {
                if (v.len > 0) {
                    target.appendBytes(ChromeTraceEvent.ArgWire.JSON_VALUE_WIRE, v);
                }
            }
            if (self.traced_value) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(ChromeTraceEvent.ArgWire.TRACED_VALUE_WIRE, size);
                    v.encodeTo(target);
                }
            }
        }
    };
    pub const ArgReader = struct {
        buf: gremlin.Reader,
        _name: ?[]const u8 = null,
        _name_index: u32 = 0,
        _bool_value: bool = false,
        _uint_value: u64 = 0,
        _int_value: i64 = 0,
        _double_value: f64 = 0.0,
        _string_value: ?[]const u8 = null,
        _pointer_value: u64 = 0,
        _json_value: ?[]const u8 = null,
        _traced_value_buf: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!ChromeTraceEvent.ArgReader {
            const buf = gremlin.Reader.init(src);
            var res = ChromeTraceEvent.ArgReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    ChromeTraceEvent.ArgWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    ChromeTraceEvent.ArgWire.NAME_INDEX_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._name_index = result.value;
                    },
                    ChromeTraceEvent.ArgWire.BOOL_VALUE_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._bool_value = result.value;
                    },
                    ChromeTraceEvent.ArgWire.UINT_VALUE_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._uint_value = result.value;
                    },
                    ChromeTraceEvent.ArgWire.INT_VALUE_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._int_value = result.value;
                    },
                    ChromeTraceEvent.ArgWire.DOUBLE_VALUE_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._double_value = result.value;
                    },
                    ChromeTraceEvent.ArgWire.STRING_VALUE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._string_value = result.value;
                    },
                    ChromeTraceEvent.ArgWire.POINTER_VALUE_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._pointer_value = result.value;
                    },
                    ChromeTraceEvent.ArgWire.JSON_VALUE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._json_value = result.value;
                    },
                    ChromeTraceEvent.ArgWire.TRACED_VALUE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._traced_value_buf = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getName(self: *const ChromeTraceEvent.ArgReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub inline fn getNameIndex(self: *const ChromeTraceEvent.ArgReader) u32 {
            return self._name_index;
        }
        pub inline fn getBoolValue(self: *const ChromeTraceEvent.ArgReader) bool {
            return self._bool_value;
        }
        pub inline fn getUintValue(self: *const ChromeTraceEvent.ArgReader) u64 {
            return self._uint_value;
        }
        pub inline fn getIntValue(self: *const ChromeTraceEvent.ArgReader) i64 {
            return self._int_value;
        }
        pub inline fn getDoubleValue(self: *const ChromeTraceEvent.ArgReader) f64 {
            return self._double_value;
        }
        pub inline fn getStringValue(self: *const ChromeTraceEvent.ArgReader) []const u8 {
            return self._string_value orelse &[_]u8{};
        }
        pub inline fn getPointerValue(self: *const ChromeTraceEvent.ArgReader) u64 {
            return self._pointer_value;
        }
        pub inline fn getJsonValue(self: *const ChromeTraceEvent.ArgReader) []const u8 {
            return self._json_value orelse &[_]u8{};
        }
        pub fn getTracedValue(self: *const ChromeTraceEvent.ArgReader) gremlin.Error!ChromeTracedValueReader {
            if (self._traced_value_buf) |buf| {
                return try ChromeTracedValueReader.init(buf);
            }
            return try ChromeTracedValueReader.init(&[_]u8{});
        }
    };
    // fields
    name: ?[]const u8 = null,
    timestamp: i64 = 0,
    phase: i32 = 0,
    thread_id: i32 = 0,
    duration: i64 = 0,
    thread_duration: i64 = 0,
    scope: ?[]const u8 = null,
    id: u64 = 0,
    flags: u32 = 0,
    category_group_name: ?[]const u8 = null,
    process_id: i32 = 0,
    thread_timestamp: i64 = 0,
    bind_id: u64 = 0,
    args: ?[]const ?ChromeTraceEvent.Arg = null,
    name_index: u32 = 0,
    category_group_name_index: u32 = 0,
    pub fn calcProtobufSize(self: *const ChromeTraceEvent) usize {
        var res: usize = 0;
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeTraceEventWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.timestamp != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeTraceEventWire.TIMESTAMP_WIRE) + gremlin.sizes.sizeI64(self.timestamp);
        }
        if (self.phase != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeTraceEventWire.PHASE_WIRE) + gremlin.sizes.sizeI32(self.phase);
        }
        if (self.thread_id != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeTraceEventWire.THREAD_ID_WIRE) + gremlin.sizes.sizeI32(self.thread_id);
        }
        if (self.duration != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeTraceEventWire.DURATION_WIRE) + gremlin.sizes.sizeI64(self.duration);
        }
        if (self.thread_duration != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeTraceEventWire.THREAD_DURATION_WIRE) + gremlin.sizes.sizeI64(self.thread_duration);
        }
        if (self.scope) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeTraceEventWire.SCOPE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.id != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeTraceEventWire.ID_WIRE) + gremlin.sizes.sizeU64(self.id);
        }
        if (self.flags != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeTraceEventWire.FLAGS_WIRE) + gremlin.sizes.sizeU32(self.flags);
        }
        if (self.category_group_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeTraceEventWire.CATEGORY_GROUP_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.process_id != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeTraceEventWire.PROCESS_ID_WIRE) + gremlin.sizes.sizeI32(self.process_id);
        }
        if (self.thread_timestamp != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeTraceEventWire.THREAD_TIMESTAMP_WIRE) + gremlin.sizes.sizeI64(self.thread_timestamp);
        }
        if (self.bind_id != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeTraceEventWire.BIND_ID_WIRE) + gremlin.sizes.sizeU64(self.bind_id);
        }
        if (self.args) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ChromeTraceEventWire.ARGS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.name_index != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeTraceEventWire.NAME_INDEX_WIRE) + gremlin.sizes.sizeU32(self.name_index);
        }
        if (self.category_group_name_index != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeTraceEventWire.CATEGORY_GROUP_NAME_INDEX_WIRE) + gremlin.sizes.sizeU32(self.category_group_name_index);
        }
        return res;
    }
    pub fn encode(self: *const ChromeTraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ChromeTraceEvent, target: *gremlin.Writer) void {
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(ChromeTraceEventWire.NAME_WIRE, v);
            }
        }
        if (self.timestamp != 0) {
            target.appendInt64(ChromeTraceEventWire.TIMESTAMP_WIRE, self.timestamp);
        }
        if (self.phase != 0) {
            target.appendInt32(ChromeTraceEventWire.PHASE_WIRE, self.phase);
        }
        if (self.thread_id != 0) {
            target.appendInt32(ChromeTraceEventWire.THREAD_ID_WIRE, self.thread_id);
        }
        if (self.duration != 0) {
            target.appendInt64(ChromeTraceEventWire.DURATION_WIRE, self.duration);
        }
        if (self.thread_duration != 0) {
            target.appendInt64(ChromeTraceEventWire.THREAD_DURATION_WIRE, self.thread_duration);
        }
        if (self.scope) |v| {
            if (v.len > 0) {
                target.appendBytes(ChromeTraceEventWire.SCOPE_WIRE, v);
            }
        }
        if (self.id != 0) {
            target.appendUint64(ChromeTraceEventWire.ID_WIRE, self.id);
        }
        if (self.flags != 0) {
            target.appendUint32(ChromeTraceEventWire.FLAGS_WIRE, self.flags);
        }
        if (self.category_group_name) |v| {
            if (v.len > 0) {
                target.appendBytes(ChromeTraceEventWire.CATEGORY_GROUP_NAME_WIRE, v);
            }
        }
        if (self.process_id != 0) {
            target.appendInt32(ChromeTraceEventWire.PROCESS_ID_WIRE, self.process_id);
        }
        if (self.thread_timestamp != 0) {
            target.appendInt64(ChromeTraceEventWire.THREAD_TIMESTAMP_WIRE, self.thread_timestamp);
        }
        if (self.bind_id != 0) {
            target.appendUint64(ChromeTraceEventWire.BIND_ID_WIRE, self.bind_id);
        }
        if (self.args) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(ChromeTraceEventWire.ARGS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(ChromeTraceEventWire.ARGS_WIRE, 0);
                }
            }
        }
        if (self.name_index != 0) {
            target.appendUint32(ChromeTraceEventWire.NAME_INDEX_WIRE, self.name_index);
        }
        if (self.category_group_name_index != 0) {
            target.appendUint32(ChromeTraceEventWire.CATEGORY_GROUP_NAME_INDEX_WIRE, self.category_group_name_index);
        }
    }
};
pub const ChromeTraceEventReader = struct {
    buf: gremlin.Reader,
    _name: ?[]const u8 = null,
    _timestamp: i64 = 0,
    _phase: i32 = 0,
    _thread_id: i32 = 0,
    _duration: i64 = 0,
    _thread_duration: i64 = 0,
    _scope: ?[]const u8 = null,
    _id: u64 = 0,
    _flags: u32 = 0,
    _category_group_name: ?[]const u8 = null,
    _process_id: i32 = 0,
    _thread_timestamp: i64 = 0,
    _bind_id: u64 = 0,
    _args_offset: ?usize = null,
    _args_last_offset: ?usize = null,
    _args_cnt: usize = 0,
    _name_index: u32 = 0,
    _category_group_name_index: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!ChromeTraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = ChromeTraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ChromeTraceEventWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                ChromeTraceEventWire.TIMESTAMP_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._timestamp = result.value;
                },
                ChromeTraceEventWire.PHASE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._phase = result.value;
                },
                ChromeTraceEventWire.THREAD_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._thread_id = result.value;
                },
                ChromeTraceEventWire.DURATION_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._duration = result.value;
                },
                ChromeTraceEventWire.THREAD_DURATION_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._thread_duration = result.value;
                },
                ChromeTraceEventWire.SCOPE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._scope = result.value;
                },
                ChromeTraceEventWire.ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._id = result.value;
                },
                ChromeTraceEventWire.FLAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._flags = result.value;
                },
                ChromeTraceEventWire.CATEGORY_GROUP_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._category_group_name = result.value;
                },
                ChromeTraceEventWire.PROCESS_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._process_id = result.value;
                },
                ChromeTraceEventWire.THREAD_TIMESTAMP_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._thread_timestamp = result.value;
                },
                ChromeTraceEventWire.BIND_ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._bind_id = result.value;
                },
                ChromeTraceEventWire.ARGS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._args_offset == null) {
                        res._args_offset = offset - result.size;
                    }
                    res._args_last_offset = offset;
                    res._args_cnt += 1;
                },
                ChromeTraceEventWire.NAME_INDEX_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._name_index = result.value;
                },
                ChromeTraceEventWire.CATEGORY_GROUP_NAME_INDEX_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._category_group_name_index = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getName(self: *const ChromeTraceEventReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub inline fn getTimestamp(self: *const ChromeTraceEventReader) i64 {
        return self._timestamp;
    }
    pub inline fn getPhase(self: *const ChromeTraceEventReader) i32 {
        return self._phase;
    }
    pub inline fn getThreadId(self: *const ChromeTraceEventReader) i32 {
        return self._thread_id;
    }
    pub inline fn getDuration(self: *const ChromeTraceEventReader) i64 {
        return self._duration;
    }
    pub inline fn getThreadDuration(self: *const ChromeTraceEventReader) i64 {
        return self._thread_duration;
    }
    pub inline fn getScope(self: *const ChromeTraceEventReader) []const u8 {
        return self._scope orelse &[_]u8{};
    }
    pub inline fn getId(self: *const ChromeTraceEventReader) u64 {
        return self._id;
    }
    pub inline fn getFlags(self: *const ChromeTraceEventReader) u32 {
        return self._flags;
    }
    pub inline fn getCategoryGroupName(self: *const ChromeTraceEventReader) []const u8 {
        return self._category_group_name orelse &[_]u8{};
    }
    pub inline fn getProcessId(self: *const ChromeTraceEventReader) i32 {
        return self._process_id;
    }
    pub inline fn getThreadTimestamp(self: *const ChromeTraceEventReader) i64 {
        return self._thread_timestamp;
    }
    pub inline fn getBindId(self: *const ChromeTraceEventReader) u64 {
        return self._bind_id;
    }
    pub fn argsCount(self: *const ChromeTraceEventReader) usize {
        return self._args_cnt;
    }
    pub fn argsNext(self: *ChromeTraceEventReader) ?ChromeTraceEvent.ArgReader {
        if (self._args_offset == null) return null;
        const current_offset = self._args_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = ChromeTraceEvent.ArgReader.init(result.value) catch return null;
        if (self._args_last_offset != null and current_offset >= self._args_last_offset.?) {
            self._args_offset = null;
            return msg;
        }
        if (self._args_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._args_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ChromeTraceEventWire.ARGS_WIRE) {
                self._args_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._args_offset = null;
        return msg;
    }
    pub inline fn getNameIndex(self: *const ChromeTraceEventReader) u32 {
        return self._name_index;
    }
    pub inline fn getCategoryGroupNameIndex(self: *const ChromeTraceEventReader) u32 {
        return self._category_group_name_index;
    }
};
const ChromeMetadataWire = struct {
    const NAME_WIRE: gremlin.ProtoWireNumber = 1;
    const STRING_VALUE_WIRE: gremlin.ProtoWireNumber = 2;
    const BOOL_VALUE_WIRE: gremlin.ProtoWireNumber = 3;
    const INT_VALUE_WIRE: gremlin.ProtoWireNumber = 4;
    const JSON_VALUE_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const ChromeMetadata = struct {
    // fields
    name: ?[]const u8 = null,
    string_value: ?[]const u8 = null,
    bool_value: bool = false,
    int_value: i64 = 0,
    json_value: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const ChromeMetadata) usize {
        var res: usize = 0;
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeMetadataWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.string_value) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeMetadataWire.STRING_VALUE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.bool_value != false) {
            res += gremlin.sizes.sizeWireNumber(ChromeMetadataWire.BOOL_VALUE_WIRE) + gremlin.sizes.sizeBool(self.bool_value);
        }
        if (self.int_value != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeMetadataWire.INT_VALUE_WIRE) + gremlin.sizes.sizeI64(self.int_value);
        }
        if (self.json_value) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeMetadataWire.JSON_VALUE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const ChromeMetadata, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ChromeMetadata, target: *gremlin.Writer) void {
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(ChromeMetadataWire.NAME_WIRE, v);
            }
        }
        if (self.string_value) |v| {
            if (v.len > 0) {
                target.appendBytes(ChromeMetadataWire.STRING_VALUE_WIRE, v);
            }
        }
        if (self.bool_value != false) {
            target.appendBool(ChromeMetadataWire.BOOL_VALUE_WIRE, self.bool_value);
        }
        if (self.int_value != 0) {
            target.appendInt64(ChromeMetadataWire.INT_VALUE_WIRE, self.int_value);
        }
        if (self.json_value) |v| {
            if (v.len > 0) {
                target.appendBytes(ChromeMetadataWire.JSON_VALUE_WIRE, v);
            }
        }
    }
};
pub const ChromeMetadataReader = struct {
    buf: gremlin.Reader,
    _name: ?[]const u8 = null,
    _string_value: ?[]const u8 = null,
    _bool_value: bool = false,
    _int_value: i64 = 0,
    _json_value: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!ChromeMetadataReader {
        const buf = gremlin.Reader.init(src);
        var res = ChromeMetadataReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ChromeMetadataWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                ChromeMetadataWire.STRING_VALUE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._string_value = result.value;
                },
                ChromeMetadataWire.BOOL_VALUE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._bool_value = result.value;
                },
                ChromeMetadataWire.INT_VALUE_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._int_value = result.value;
                },
                ChromeMetadataWire.JSON_VALUE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._json_value = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getName(self: *const ChromeMetadataReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub inline fn getStringValue(self: *const ChromeMetadataReader) []const u8 {
        return self._string_value orelse &[_]u8{};
    }
    pub inline fn getBoolValue(self: *const ChromeMetadataReader) bool {
        return self._bool_value;
    }
    pub inline fn getIntValue(self: *const ChromeMetadataReader) i64 {
        return self._int_value;
    }
    pub inline fn getJsonValue(self: *const ChromeMetadataReader) []const u8 {
        return self._json_value orelse &[_]u8{};
    }
};
const ChromeLegacyJsonTraceWire = struct {
    const TYPE_WIRE: gremlin.ProtoWireNumber = 1;
    const DATA_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const ChromeLegacyJsonTrace = struct {
    // nested enums
    pub const TraceType = enum(i32) {
        USER_TRACE = 0,
        SYSTEM_TRACE = 1,
    };
    // fields
    type: ChromeLegacyJsonTrace.TraceType = @enumFromInt(0),
    data: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const ChromeLegacyJsonTrace) usize {
        var res: usize = 0;
        if (@intFromEnum(self.type) != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeLegacyJsonTraceWire.TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.type));
        }
        if (self.data) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeLegacyJsonTraceWire.DATA_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const ChromeLegacyJsonTrace, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ChromeLegacyJsonTrace, target: *gremlin.Writer) void {
        if (@intFromEnum(self.type) != 0) {
            target.appendInt32(ChromeLegacyJsonTraceWire.TYPE_WIRE, @intFromEnum(self.type));
        }
        if (self.data) |v| {
            if (v.len > 0) {
                target.appendBytes(ChromeLegacyJsonTraceWire.DATA_WIRE, v);
            }
        }
    }
};
pub const ChromeLegacyJsonTraceReader = struct {
    buf: gremlin.Reader,
    _type: ChromeLegacyJsonTrace.TraceType = @enumFromInt(0),
    _data: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!ChromeLegacyJsonTraceReader {
        const buf = gremlin.Reader.init(src);
        var res = ChromeLegacyJsonTraceReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ChromeLegacyJsonTraceWire.TYPE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._type = @enumFromInt(result.value);
                },
                ChromeLegacyJsonTraceWire.DATA_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._data = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getType(self: *const ChromeLegacyJsonTraceReader) ChromeLegacyJsonTrace.TraceType {
        return self._type;
    }
    pub inline fn getData(self: *const ChromeLegacyJsonTraceReader) []const u8 {
        return self._data orelse &[_]u8{};
    }
};
const ChromeEventBundleWire = struct {
    const TRACE_EVENTS_WIRE: gremlin.ProtoWireNumber = 1;
    const METADATA_WIRE: gremlin.ProtoWireNumber = 2;
    const LEGACY_FTRACE_OUTPUT_WIRE: gremlin.ProtoWireNumber = 4;
    const LEGACY_JSON_TRACE_WIRE: gremlin.ProtoWireNumber = 5;
    const STRING_TABLE_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const ChromeEventBundle = struct {
    // fields
    trace_events: ?[]const ?ChromeTraceEvent = null,
    metadata: ?[]const ?ChromeMetadata = null,
    legacy_ftrace_output: ?[]const ?[]const u8 = null,
    legacy_json_trace: ?[]const ?ChromeLegacyJsonTrace = null,
    string_table: ?[]const ?ChromeStringTableEntry = null,
    pub fn calcProtobufSize(self: *const ChromeEventBundle) usize {
        var res: usize = 0;
        if (self.trace_events) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ChromeEventBundleWire.TRACE_EVENTS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.metadata) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ChromeEventBundleWire.METADATA_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.legacy_ftrace_output) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ChromeEventBundleWire.LEGACY_FTRACE_OUTPUT_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.legacy_json_trace) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ChromeEventBundleWire.LEGACY_JSON_TRACE_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.string_table) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ChromeEventBundleWire.STRING_TABLE_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const ChromeEventBundle, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ChromeEventBundle, target: *gremlin.Writer) void {
        if (self.trace_events) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(ChromeEventBundleWire.TRACE_EVENTS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(ChromeEventBundleWire.TRACE_EVENTS_WIRE, 0);
                }
            }
        }
        if (self.metadata) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(ChromeEventBundleWire.METADATA_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(ChromeEventBundleWire.METADATA_WIRE, 0);
                }
            }
        }
        if (self.legacy_ftrace_output) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(ChromeEventBundleWire.LEGACY_FTRACE_OUTPUT_WIRE, v);
                } else {
                    target.appendBytesTag(ChromeEventBundleWire.LEGACY_FTRACE_OUTPUT_WIRE, 0);
                }
            }
        }
        if (self.legacy_json_trace) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(ChromeEventBundleWire.LEGACY_JSON_TRACE_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(ChromeEventBundleWire.LEGACY_JSON_TRACE_WIRE, 0);
                }
            }
        }
        if (self.string_table) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(ChromeEventBundleWire.STRING_TABLE_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(ChromeEventBundleWire.STRING_TABLE_WIRE, 0);
                }
            }
        }
    }
};
pub const ChromeEventBundleReader = struct {
    buf: gremlin.Reader,
    _trace_events_offset: ?usize = null,
    _trace_events_last_offset: ?usize = null,
    _trace_events_cnt: usize = 0,
    _metadata_offset: ?usize = null,
    _metadata_last_offset: ?usize = null,
    _metadata_cnt: usize = 0,
    _legacy_ftrace_output_offset: ?usize = null,
    _legacy_ftrace_output_last_offset: ?usize = null,
    _legacy_ftrace_output_cnt: usize = 0,
    _legacy_json_trace_offset: ?usize = null,
    _legacy_json_trace_last_offset: ?usize = null,
    _legacy_json_trace_cnt: usize = 0,
    _string_table_offset: ?usize = null,
    _string_table_last_offset: ?usize = null,
    _string_table_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!ChromeEventBundleReader {
        const buf = gremlin.Reader.init(src);
        var res = ChromeEventBundleReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ChromeEventBundleWire.TRACE_EVENTS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._trace_events_offset == null) {
                        res._trace_events_offset = offset - result.size;
                    }
                    res._trace_events_last_offset = offset;
                    res._trace_events_cnt += 1;
                },
                ChromeEventBundleWire.METADATA_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._metadata_offset == null) {
                        res._metadata_offset = offset - result.size;
                    }
                    res._metadata_last_offset = offset;
                    res._metadata_cnt += 1;
                },
                ChromeEventBundleWire.LEGACY_FTRACE_OUTPUT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._legacy_ftrace_output_offset == null) {
                        res._legacy_ftrace_output_offset = offset - result.size;
                    }
                    res._legacy_ftrace_output_last_offset = offset;
                    res._legacy_ftrace_output_cnt += 1;
                },
                ChromeEventBundleWire.LEGACY_JSON_TRACE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._legacy_json_trace_offset == null) {
                        res._legacy_json_trace_offset = offset - result.size;
                    }
                    res._legacy_json_trace_last_offset = offset;
                    res._legacy_json_trace_cnt += 1;
                },
                ChromeEventBundleWire.STRING_TABLE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._string_table_offset == null) {
                        res._string_table_offset = offset - result.size;
                    }
                    res._string_table_last_offset = offset;
                    res._string_table_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn traceEventsCount(self: *const ChromeEventBundleReader) usize {
        return self._trace_events_cnt;
    }
    pub fn traceEventsNext(self: *ChromeEventBundleReader) ?ChromeTraceEventReader {
        if (self._trace_events_offset == null) return null;
        const current_offset = self._trace_events_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = ChromeTraceEventReader.init(result.value) catch return null;
        if (self._trace_events_last_offset != null and current_offset >= self._trace_events_last_offset.?) {
            self._trace_events_offset = null;
            return msg;
        }
        if (self._trace_events_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._trace_events_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ChromeEventBundleWire.TRACE_EVENTS_WIRE) {
                self._trace_events_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._trace_events_offset = null;
        return msg;
    }
    pub fn metadataCount(self: *const ChromeEventBundleReader) usize {
        return self._metadata_cnt;
    }
    pub fn metadataNext(self: *ChromeEventBundleReader) ?ChromeMetadataReader {
        if (self._metadata_offset == null) return null;
        const current_offset = self._metadata_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = ChromeMetadataReader.init(result.value) catch return null;
        if (self._metadata_last_offset != null and current_offset >= self._metadata_last_offset.?) {
            self._metadata_offset = null;
            return msg;
        }
        if (self._metadata_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._metadata_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ChromeEventBundleWire.METADATA_WIRE) {
                self._metadata_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._metadata_offset = null;
        return msg;
    }
    pub fn legacyFtraceOutputCount(self: *const ChromeEventBundleReader) usize {
        return self._legacy_ftrace_output_cnt;
    }
    pub fn legacyFtraceOutputNext(self: *ChromeEventBundleReader) ?[]const u8 {
        if (self._legacy_ftrace_output_offset == null) return null;
        const current_offset = self._legacy_ftrace_output_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._legacy_ftrace_output_last_offset != null and current_offset >= self._legacy_ftrace_output_last_offset.?) {
            self._legacy_ftrace_output_offset = null;
            return result.value;
        }
        if (self._legacy_ftrace_output_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._legacy_ftrace_output_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ChromeEventBundleWire.LEGACY_FTRACE_OUTPUT_WIRE) {
                self._legacy_ftrace_output_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._legacy_ftrace_output_offset = null;
        return result.value;
    }
    pub fn legacyJsonTraceCount(self: *const ChromeEventBundleReader) usize {
        return self._legacy_json_trace_cnt;
    }
    pub fn legacyJsonTraceNext(self: *ChromeEventBundleReader) ?ChromeLegacyJsonTraceReader {
        if (self._legacy_json_trace_offset == null) return null;
        const current_offset = self._legacy_json_trace_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = ChromeLegacyJsonTraceReader.init(result.value) catch return null;
        if (self._legacy_json_trace_last_offset != null and current_offset >= self._legacy_json_trace_last_offset.?) {
            self._legacy_json_trace_offset = null;
            return msg;
        }
        if (self._legacy_json_trace_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._legacy_json_trace_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ChromeEventBundleWire.LEGACY_JSON_TRACE_WIRE) {
                self._legacy_json_trace_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._legacy_json_trace_offset = null;
        return msg;
    }
    pub fn stringTableCount(self: *const ChromeEventBundleReader) usize {
        return self._string_table_cnt;
    }
    pub fn stringTableNext(self: *ChromeEventBundleReader) ?ChromeStringTableEntryReader {
        if (self._string_table_offset == null) return null;
        const current_offset = self._string_table_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = ChromeStringTableEntryReader.init(result.value) catch return null;
        if (self._string_table_last_offset != null and current_offset >= self._string_table_last_offset.?) {
            self._string_table_offset = null;
            return msg;
        }
        if (self._string_table_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._string_table_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ChromeEventBundleWire.STRING_TABLE_WIRE) {
                self._string_table_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._string_table_offset = null;
        return msg;
    }
};
