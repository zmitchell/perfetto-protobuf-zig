// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
const debug_annotation = @import("debug_annotation.proto.zig");
const task_execution = @import("task_execution.proto.zig");
const log_message = @import("log_message.proto.zig");
const chrome_compositor_scheduler_state = @import("chrome_compositor_scheduler_state.proto.zig");
const chrome_user_event = @import("chrome_user_event.proto.zig");
const chrome_keyed_service = @import("chrome_keyed_service.proto.zig");
const chrome_legacy_ipc = @import("chrome_legacy_ipc.proto.zig");
const chrome_histogram_sample = @import("chrome_histogram_sample.proto.zig");
const chrome_latency_info = @import("chrome_latency_info.proto.zig");
const chrome_frame_reporter = @import("chrome_frame_reporter.proto.zig");
const chrome_application_state_info = @import("chrome_application_state_info.proto.zig");
const chrome_renderer_scheduler_state = @import("chrome_renderer_scheduler_state.proto.zig");
const chrome_window_handle_event_info = @import("chrome_window_handle_event_info.proto.zig");
const chrome_content_settings_event_info = @import("chrome_content_settings_event_info.proto.zig");
const chrome_active_processes = @import("chrome_active_processes.proto.zig");
const screenshot = @import("screenshot.proto.zig");
const chrome_message_pump = @import("chrome_message_pump.proto.zig");
const chrome_mojo_event_info = @import("chrome_mojo_event_info.proto.zig");
const source_location = @import("source_location.proto.zig");
// structs
const TrackEventWire = struct {
    const CATEGORY_IIDS_WIRE: gremlin.ProtoWireNumber = 3;
    const CATEGORIES_WIRE: gremlin.ProtoWireNumber = 22;
    const TYPE_WIRE: gremlin.ProtoWireNumber = 9;
    const TRACK_UUID_WIRE: gremlin.ProtoWireNumber = 11;
    const EXTRA_COUNTER_TRACK_UUIDS_WIRE: gremlin.ProtoWireNumber = 31;
    const EXTRA_COUNTER_VALUES_WIRE: gremlin.ProtoWireNumber = 12;
    const EXTRA_DOUBLE_COUNTER_TRACK_UUIDS_WIRE: gremlin.ProtoWireNumber = 45;
    const EXTRA_DOUBLE_COUNTER_VALUES_WIRE: gremlin.ProtoWireNumber = 46;
    const FLOW_IDS_OLD_WIRE: gremlin.ProtoWireNumber = 36;
    const FLOW_IDS_WIRE: gremlin.ProtoWireNumber = 47;
    const TERMINATING_FLOW_IDS_OLD_WIRE: gremlin.ProtoWireNumber = 42;
    const TERMINATING_FLOW_IDS_WIRE: gremlin.ProtoWireNumber = 48;
    const DEBUG_ANNOTATIONS_WIRE: gremlin.ProtoWireNumber = 4;
    const TASK_EXECUTION_WIRE: gremlin.ProtoWireNumber = 5;
    const LOG_MESSAGE_WIRE: gremlin.ProtoWireNumber = 21;
    const CC_SCHEDULER_STATE_WIRE: gremlin.ProtoWireNumber = 24;
    const CHROME_USER_EVENT_WIRE: gremlin.ProtoWireNumber = 25;
    const CHROME_KEYED_SERVICE_WIRE: gremlin.ProtoWireNumber = 26;
    const CHROME_LEGACY_IPC_WIRE: gremlin.ProtoWireNumber = 27;
    const CHROME_HISTOGRAM_SAMPLE_WIRE: gremlin.ProtoWireNumber = 28;
    const CHROME_LATENCY_INFO_WIRE: gremlin.ProtoWireNumber = 29;
    const CHROME_FRAME_REPORTER_WIRE: gremlin.ProtoWireNumber = 32;
    const CHROME_APPLICATION_STATE_INFO_WIRE: gremlin.ProtoWireNumber = 39;
    const CHROME_RENDERER_SCHEDULER_STATE_WIRE: gremlin.ProtoWireNumber = 40;
    const CHROME_WINDOW_HANDLE_EVENT_INFO_WIRE: gremlin.ProtoWireNumber = 41;
    const CHROME_CONTENT_SETTINGS_EVENT_INFO_WIRE: gremlin.ProtoWireNumber = 43;
    const CHROME_ACTIVE_PROCESSES_WIRE: gremlin.ProtoWireNumber = 49;
    const SCREENSHOT_WIRE: gremlin.ProtoWireNumber = 50;
    const CHROME_MESSAGE_PUMP_WIRE: gremlin.ProtoWireNumber = 35;
    const CHROME_MOJO_EVENT_INFO_WIRE: gremlin.ProtoWireNumber = 38;
    const LEGACY_EVENT_WIRE: gremlin.ProtoWireNumber = 6;
    const NAME_IID_WIRE: gremlin.ProtoWireNumber = 10;
    const NAME_WIRE: gremlin.ProtoWireNumber = 23;
    const COUNTER_VALUE_WIRE: gremlin.ProtoWireNumber = 30;
    const DOUBLE_COUNTER_VALUE_WIRE: gremlin.ProtoWireNumber = 44;
    const CORRELATION_ID_WIRE: gremlin.ProtoWireNumber = 52;
    const CORRELATION_ID_STR_WIRE: gremlin.ProtoWireNumber = 53;
    const CORRELATION_ID_STR_IID_WIRE: gremlin.ProtoWireNumber = 54;
    const CALLSTACK_WIRE: gremlin.ProtoWireNumber = 55;
    const CALLSTACK_IID_WIRE: gremlin.ProtoWireNumber = 56;
    const SOURCE_LOCATION_WIRE: gremlin.ProtoWireNumber = 33;
    const SOURCE_LOCATION_IID_WIRE: gremlin.ProtoWireNumber = 34;
    const TIMESTAMP_DELTA_US_WIRE: gremlin.ProtoWireNumber = 1;
    const TIMESTAMP_ABSOLUTE_US_WIRE: gremlin.ProtoWireNumber = 16;
    const THREAD_TIME_DELTA_US_WIRE: gremlin.ProtoWireNumber = 2;
    const THREAD_TIME_ABSOLUTE_US_WIRE: gremlin.ProtoWireNumber = 17;
    const THREAD_INSTRUCTION_COUNT_DELTA_WIRE: gremlin.ProtoWireNumber = 8;
    const THREAD_INSTRUCTION_COUNT_ABSOLUTE_WIRE: gremlin.ProtoWireNumber = 20;
};
pub const TrackEvent = struct {
    // nested enums
    pub const Type = enum(i32) {
        TYPE_UNSPECIFIED = 0,
        TYPE_SLICE_BEGIN = 1,
        TYPE_SLICE_END = 2,
        TYPE_INSTANT = 3,
        TYPE_COUNTER = 4,
    };
    // nested structs
    const CallstackWire = struct {
        const FRAMES_WIRE: gremlin.ProtoWireNumber = 1;
    };
    pub const Callstack = struct {
        // nested structs
        const FrameWire = struct {
            const FUNCTION_NAME_WIRE: gremlin.ProtoWireNumber = 1;
            const SOURCE_FILE_WIRE: gremlin.ProtoWireNumber = 2;
            const LINE_NUMBER_WIRE: gremlin.ProtoWireNumber = 3;
        };
        pub const Frame = struct {
            // fields
            function_name: ?[]const u8 = null,
            source_file: ?[]const u8 = null,
            line_number: u32 = 0,
            pub fn calcProtobufSize(self: *const TrackEvent.Callstack.Frame) usize {
                var res: usize = 0;
                if (self.function_name) |v| {
                    if (v.len > 0) {
                        res += gremlin.sizes.sizeWireNumber(TrackEvent.Callstack.FrameWire.FUNCTION_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                    }
                }
                if (self.source_file) |v| {
                    if (v.len > 0) {
                        res += gremlin.sizes.sizeWireNumber(TrackEvent.Callstack.FrameWire.SOURCE_FILE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                    }
                }
                if (self.line_number != 0) {
                    res += gremlin.sizes.sizeWireNumber(TrackEvent.Callstack.FrameWire.LINE_NUMBER_WIRE) + gremlin.sizes.sizeU32(self.line_number);
                }
                return res;
            }
            pub fn encode(self: *const TrackEvent.Callstack.Frame, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const TrackEvent.Callstack.Frame, target: *gremlin.Writer) void {
                if (self.function_name) |v| {
                    if (v.len > 0) {
                        target.appendBytes(TrackEvent.Callstack.FrameWire.FUNCTION_NAME_WIRE, v);
                    }
                }
                if (self.source_file) |v| {
                    if (v.len > 0) {
                        target.appendBytes(TrackEvent.Callstack.FrameWire.SOURCE_FILE_WIRE, v);
                    }
                }
                if (self.line_number != 0) {
                    target.appendUint32(TrackEvent.Callstack.FrameWire.LINE_NUMBER_WIRE, self.line_number);
                }
            }
        };
        pub const FrameReader = struct {
            buf: gremlin.Reader,
            _function_name: ?[]const u8 = null,
            _source_file: ?[]const u8 = null,
            _line_number: u32 = 0,
            pub fn init(src: []const u8) gremlin.Error!TrackEvent.Callstack.FrameReader {
                const buf = gremlin.Reader.init(src);
                var res = TrackEvent.Callstack.FrameReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        TrackEvent.Callstack.FrameWire.FUNCTION_NAME_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._function_name = result.value;
                        },
                        TrackEvent.Callstack.FrameWire.SOURCE_FILE_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._source_file = result.value;
                        },
                        TrackEvent.Callstack.FrameWire.LINE_NUMBER_WIRE => {
                            const result = try buf.readUInt32(offset);
                            offset += result.size;
                            res._line_number = result.value;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub inline fn getFunctionName(self: *const TrackEvent.Callstack.FrameReader) []const u8 {
                return self._function_name orelse &[_]u8{};
            }
            pub inline fn getSourceFile(self: *const TrackEvent.Callstack.FrameReader) []const u8 {
                return self._source_file orelse &[_]u8{};
            }
            pub inline fn getLineNumber(self: *const TrackEvent.Callstack.FrameReader) u32 {
                return self._line_number;
            }
        };
        // fields
        frames: ?[]const ?TrackEvent.Callstack.Frame = null,
        pub fn calcProtobufSize(self: *const TrackEvent.Callstack) usize {
            var res: usize = 0;
            if (self.frames) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(TrackEvent.CallstackWire.FRAMES_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const TrackEvent.Callstack, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const TrackEvent.Callstack, target: *gremlin.Writer) void {
            if (self.frames) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(TrackEvent.CallstackWire.FRAMES_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(TrackEvent.CallstackWire.FRAMES_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const CallstackReader = struct {
        buf: gremlin.Reader,
        _frames_offset: ?usize = null,
        _frames_last_offset: ?usize = null,
        _frames_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!TrackEvent.CallstackReader {
            const buf = gremlin.Reader.init(src);
            var res = TrackEvent.CallstackReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    TrackEvent.CallstackWire.FRAMES_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._frames_offset == null) {
                            res._frames_offset = offset - result.size;
                        }
                        res._frames_last_offset = offset;
                        res._frames_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn framesCount(self: *const TrackEvent.CallstackReader) usize {
            return self._frames_cnt;
        }
        pub fn framesNext(self: *TrackEvent.CallstackReader) ?TrackEvent.Callstack.FrameReader {
            if (self._frames_offset == null) return null;
            const current_offset = self._frames_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = TrackEvent.Callstack.FrameReader.init(result.value) catch return null;
            if (self._frames_last_offset != null and current_offset >= self._frames_last_offset.?) {
                self._frames_offset = null;
                return msg;
            }
            if (self._frames_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._frames_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == TrackEvent.CallstackWire.FRAMES_WIRE) {
                    self._frames_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._frames_offset = null;
            return msg;
        }
    };
    const LegacyEventWire = struct {
        const NAME_IID_WIRE: gremlin.ProtoWireNumber = 1;
        const PHASE_WIRE: gremlin.ProtoWireNumber = 2;
        const DURATION_US_WIRE: gremlin.ProtoWireNumber = 3;
        const THREAD_DURATION_US_WIRE: gremlin.ProtoWireNumber = 4;
        const THREAD_INSTRUCTION_DELTA_WIRE: gremlin.ProtoWireNumber = 15;
        const ID_SCOPE_WIRE: gremlin.ProtoWireNumber = 7;
        const USE_ASYNC_TTS_WIRE: gremlin.ProtoWireNumber = 9;
        const BIND_ID_WIRE: gremlin.ProtoWireNumber = 8;
        const BIND_TO_ENCLOSING_WIRE: gremlin.ProtoWireNumber = 12;
        const FLOW_DIRECTION_WIRE: gremlin.ProtoWireNumber = 13;
        const INSTANT_EVENT_SCOPE_WIRE: gremlin.ProtoWireNumber = 14;
        const PID_OVERRIDE_WIRE: gremlin.ProtoWireNumber = 18;
        const TID_OVERRIDE_WIRE: gremlin.ProtoWireNumber = 19;
        const UNSCOPED_ID_WIRE: gremlin.ProtoWireNumber = 6;
        const LOCAL_ID_WIRE: gremlin.ProtoWireNumber = 10;
        const GLOBAL_ID_WIRE: gremlin.ProtoWireNumber = 11;
    };
    pub const LegacyEvent = struct {
        // nested enums
        pub const FlowDirection = enum(i32) {
            FLOW_UNSPECIFIED = 0,
            FLOW_IN = 1,
            FLOW_OUT = 2,
            FLOW_INOUT = 3,
        };
        pub const InstantEventScope = enum(i32) {
            SCOPE_UNSPECIFIED = 0,
            SCOPE_GLOBAL = 1,
            SCOPE_PROCESS = 2,
            SCOPE_THREAD = 3,
        };
        // fields
        name_iid: u64 = 0,
        phase: i32 = 0,
        duration_us: i64 = 0,
        thread_duration_us: i64 = 0,
        thread_instruction_delta: i64 = 0,
        id_scope: ?[]const u8 = null,
        use_async_tts: bool = false,
        bind_id: u64 = 0,
        bind_to_enclosing: bool = false,
        flow_direction: TrackEvent.LegacyEvent.FlowDirection = @enumFromInt(0),
        instant_event_scope: TrackEvent.LegacyEvent.InstantEventScope = @enumFromInt(0),
        pid_override: i32 = 0,
        tid_override: i32 = 0,
        unscoped_id: u64 = 0,
        local_id: u64 = 0,
        global_id: u64 = 0,
        pub fn calcProtobufSize(self: *const TrackEvent.LegacyEvent) usize {
            var res: usize = 0;
            if (self.name_iid != 0) {
                res += gremlin.sizes.sizeWireNumber(TrackEvent.LegacyEventWire.NAME_IID_WIRE) + gremlin.sizes.sizeU64(self.name_iid);
            }
            if (self.phase != 0) {
                res += gremlin.sizes.sizeWireNumber(TrackEvent.LegacyEventWire.PHASE_WIRE) + gremlin.sizes.sizeI32(self.phase);
            }
            if (self.duration_us != 0) {
                res += gremlin.sizes.sizeWireNumber(TrackEvent.LegacyEventWire.DURATION_US_WIRE) + gremlin.sizes.sizeI64(self.duration_us);
            }
            if (self.thread_duration_us != 0) {
                res += gremlin.sizes.sizeWireNumber(TrackEvent.LegacyEventWire.THREAD_DURATION_US_WIRE) + gremlin.sizes.sizeI64(self.thread_duration_us);
            }
            if (self.thread_instruction_delta != 0) {
                res += gremlin.sizes.sizeWireNumber(TrackEvent.LegacyEventWire.THREAD_INSTRUCTION_DELTA_WIRE) + gremlin.sizes.sizeI64(self.thread_instruction_delta);
            }
            if (self.id_scope) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(TrackEvent.LegacyEventWire.ID_SCOPE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.use_async_tts != false) {
                res += gremlin.sizes.sizeWireNumber(TrackEvent.LegacyEventWire.USE_ASYNC_TTS_WIRE) + gremlin.sizes.sizeBool(self.use_async_tts);
            }
            if (self.bind_id != 0) {
                res += gremlin.sizes.sizeWireNumber(TrackEvent.LegacyEventWire.BIND_ID_WIRE) + gremlin.sizes.sizeU64(self.bind_id);
            }
            if (self.bind_to_enclosing != false) {
                res += gremlin.sizes.sizeWireNumber(TrackEvent.LegacyEventWire.BIND_TO_ENCLOSING_WIRE) + gremlin.sizes.sizeBool(self.bind_to_enclosing);
            }
            if (@intFromEnum(self.flow_direction) != 0) {
                res += gremlin.sizes.sizeWireNumber(TrackEvent.LegacyEventWire.FLOW_DIRECTION_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.flow_direction));
            }
            if (@intFromEnum(self.instant_event_scope) != 0) {
                res += gremlin.sizes.sizeWireNumber(TrackEvent.LegacyEventWire.INSTANT_EVENT_SCOPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.instant_event_scope));
            }
            if (self.pid_override != 0) {
                res += gremlin.sizes.sizeWireNumber(TrackEvent.LegacyEventWire.PID_OVERRIDE_WIRE) + gremlin.sizes.sizeI32(self.pid_override);
            }
            if (self.tid_override != 0) {
                res += gremlin.sizes.sizeWireNumber(TrackEvent.LegacyEventWire.TID_OVERRIDE_WIRE) + gremlin.sizes.sizeI32(self.tid_override);
            }
            if (self.unscoped_id != 0) {
                res += gremlin.sizes.sizeWireNumber(TrackEvent.LegacyEventWire.UNSCOPED_ID_WIRE) + gremlin.sizes.sizeU64(self.unscoped_id);
            }
            if (self.local_id != 0) {
                res += gremlin.sizes.sizeWireNumber(TrackEvent.LegacyEventWire.LOCAL_ID_WIRE) + gremlin.sizes.sizeU64(self.local_id);
            }
            if (self.global_id != 0) {
                res += gremlin.sizes.sizeWireNumber(TrackEvent.LegacyEventWire.GLOBAL_ID_WIRE) + gremlin.sizes.sizeU64(self.global_id);
            }
            return res;
        }
        pub fn encode(self: *const TrackEvent.LegacyEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const TrackEvent.LegacyEvent, target: *gremlin.Writer) void {
            if (self.name_iid != 0) {
                target.appendUint64(TrackEvent.LegacyEventWire.NAME_IID_WIRE, self.name_iid);
            }
            if (self.phase != 0) {
                target.appendInt32(TrackEvent.LegacyEventWire.PHASE_WIRE, self.phase);
            }
            if (self.duration_us != 0) {
                target.appendInt64(TrackEvent.LegacyEventWire.DURATION_US_WIRE, self.duration_us);
            }
            if (self.thread_duration_us != 0) {
                target.appendInt64(TrackEvent.LegacyEventWire.THREAD_DURATION_US_WIRE, self.thread_duration_us);
            }
            if (self.thread_instruction_delta != 0) {
                target.appendInt64(TrackEvent.LegacyEventWire.THREAD_INSTRUCTION_DELTA_WIRE, self.thread_instruction_delta);
            }
            if (self.id_scope) |v| {
                if (v.len > 0) {
                    target.appendBytes(TrackEvent.LegacyEventWire.ID_SCOPE_WIRE, v);
                }
            }
            if (self.use_async_tts != false) {
                target.appendBool(TrackEvent.LegacyEventWire.USE_ASYNC_TTS_WIRE, self.use_async_tts);
            }
            if (self.bind_id != 0) {
                target.appendUint64(TrackEvent.LegacyEventWire.BIND_ID_WIRE, self.bind_id);
            }
            if (self.bind_to_enclosing != false) {
                target.appendBool(TrackEvent.LegacyEventWire.BIND_TO_ENCLOSING_WIRE, self.bind_to_enclosing);
            }
            if (@intFromEnum(self.flow_direction) != 0) {
                target.appendInt32(TrackEvent.LegacyEventWire.FLOW_DIRECTION_WIRE, @intFromEnum(self.flow_direction));
            }
            if (@intFromEnum(self.instant_event_scope) != 0) {
                target.appendInt32(TrackEvent.LegacyEventWire.INSTANT_EVENT_SCOPE_WIRE, @intFromEnum(self.instant_event_scope));
            }
            if (self.pid_override != 0) {
                target.appendInt32(TrackEvent.LegacyEventWire.PID_OVERRIDE_WIRE, self.pid_override);
            }
            if (self.tid_override != 0) {
                target.appendInt32(TrackEvent.LegacyEventWire.TID_OVERRIDE_WIRE, self.tid_override);
            }
            if (self.unscoped_id != 0) {
                target.appendUint64(TrackEvent.LegacyEventWire.UNSCOPED_ID_WIRE, self.unscoped_id);
            }
            if (self.local_id != 0) {
                target.appendUint64(TrackEvent.LegacyEventWire.LOCAL_ID_WIRE, self.local_id);
            }
            if (self.global_id != 0) {
                target.appendUint64(TrackEvent.LegacyEventWire.GLOBAL_ID_WIRE, self.global_id);
            }
        }
    };
    pub const LegacyEventReader = struct {
        buf: gremlin.Reader,
        _name_iid: u64 = 0,
        _phase: i32 = 0,
        _duration_us: i64 = 0,
        _thread_duration_us: i64 = 0,
        _thread_instruction_delta: i64 = 0,
        _id_scope: ?[]const u8 = null,
        _use_async_tts: bool = false,
        _bind_id: u64 = 0,
        _bind_to_enclosing: bool = false,
        _flow_direction: TrackEvent.LegacyEvent.FlowDirection = @enumFromInt(0),
        _instant_event_scope: TrackEvent.LegacyEvent.InstantEventScope = @enumFromInt(0),
        _pid_override: i32 = 0,
        _tid_override: i32 = 0,
        _unscoped_id: u64 = 0,
        _local_id: u64 = 0,
        _global_id: u64 = 0,
        pub fn init(src: []const u8) gremlin.Error!TrackEvent.LegacyEventReader {
            const buf = gremlin.Reader.init(src);
            var res = TrackEvent.LegacyEventReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    TrackEvent.LegacyEventWire.NAME_IID_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._name_iid = result.value;
                    },
                    TrackEvent.LegacyEventWire.PHASE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._phase = result.value;
                    },
                    TrackEvent.LegacyEventWire.DURATION_US_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._duration_us = result.value;
                    },
                    TrackEvent.LegacyEventWire.THREAD_DURATION_US_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._thread_duration_us = result.value;
                    },
                    TrackEvent.LegacyEventWire.THREAD_INSTRUCTION_DELTA_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._thread_instruction_delta = result.value;
                    },
                    TrackEvent.LegacyEventWire.ID_SCOPE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._id_scope = result.value;
                    },
                    TrackEvent.LegacyEventWire.USE_ASYNC_TTS_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._use_async_tts = result.value;
                    },
                    TrackEvent.LegacyEventWire.BIND_ID_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._bind_id = result.value;
                    },
                    TrackEvent.LegacyEventWire.BIND_TO_ENCLOSING_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._bind_to_enclosing = result.value;
                    },
                    TrackEvent.LegacyEventWire.FLOW_DIRECTION_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._flow_direction = @enumFromInt(result.value);
                    },
                    TrackEvent.LegacyEventWire.INSTANT_EVENT_SCOPE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._instant_event_scope = @enumFromInt(result.value);
                    },
                    TrackEvent.LegacyEventWire.PID_OVERRIDE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._pid_override = result.value;
                    },
                    TrackEvent.LegacyEventWire.TID_OVERRIDE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._tid_override = result.value;
                    },
                    TrackEvent.LegacyEventWire.UNSCOPED_ID_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._unscoped_id = result.value;
                    },
                    TrackEvent.LegacyEventWire.LOCAL_ID_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._local_id = result.value;
                    },
                    TrackEvent.LegacyEventWire.GLOBAL_ID_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._global_id = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getNameIid(self: *const TrackEvent.LegacyEventReader) u64 {
            return self._name_iid;
        }
        pub inline fn getPhase(self: *const TrackEvent.LegacyEventReader) i32 {
            return self._phase;
        }
        pub inline fn getDurationUs(self: *const TrackEvent.LegacyEventReader) i64 {
            return self._duration_us;
        }
        pub inline fn getThreadDurationUs(self: *const TrackEvent.LegacyEventReader) i64 {
            return self._thread_duration_us;
        }
        pub inline fn getThreadInstructionDelta(self: *const TrackEvent.LegacyEventReader) i64 {
            return self._thread_instruction_delta;
        }
        pub inline fn getIdScope(self: *const TrackEvent.LegacyEventReader) []const u8 {
            return self._id_scope orelse &[_]u8{};
        }
        pub inline fn getUseAsyncTts(self: *const TrackEvent.LegacyEventReader) bool {
            return self._use_async_tts;
        }
        pub inline fn getBindId(self: *const TrackEvent.LegacyEventReader) u64 {
            return self._bind_id;
        }
        pub inline fn getBindToEnclosing(self: *const TrackEvent.LegacyEventReader) bool {
            return self._bind_to_enclosing;
        }
        pub inline fn getFlowDirection(self: *const TrackEvent.LegacyEventReader) TrackEvent.LegacyEvent.FlowDirection {
            return self._flow_direction;
        }
        pub inline fn getInstantEventScope(self: *const TrackEvent.LegacyEventReader) TrackEvent.LegacyEvent.InstantEventScope {
            return self._instant_event_scope;
        }
        pub inline fn getPidOverride(self: *const TrackEvent.LegacyEventReader) i32 {
            return self._pid_override;
        }
        pub inline fn getTidOverride(self: *const TrackEvent.LegacyEventReader) i32 {
            return self._tid_override;
        }
        pub inline fn getUnscopedId(self: *const TrackEvent.LegacyEventReader) u64 {
            return self._unscoped_id;
        }
        pub inline fn getLocalId(self: *const TrackEvent.LegacyEventReader) u64 {
            return self._local_id;
        }
        pub inline fn getGlobalId(self: *const TrackEvent.LegacyEventReader) u64 {
            return self._global_id;
        }
    };
    // fields
    category_iids: ?[]const u64 = null,
    categories: ?[]const ?[]const u8 = null,
    type: TrackEvent.Type = @enumFromInt(0),
    track_uuid: u64 = 0,
    extra_counter_track_uuids: ?[]const u64 = null,
    extra_counter_values: ?[]const i64 = null,
    extra_double_counter_track_uuids: ?[]const u64 = null,
    extra_double_counter_values: ?[]const f64 = null,
    flow_ids_old: ?[]const u64 = null,
    flow_ids: ?[]const u64 = null,
    terminating_flow_ids_old: ?[]const u64 = null,
    terminating_flow_ids: ?[]const u64 = null,
    debug_annotations: ?[]const ?debug_annotation.DebugAnnotation = null,
    task_execution: ?task_execution.TaskExecution = null,
    log_message: ?log_message.LogMessage = null,
    cc_scheduler_state: ?chrome_compositor_scheduler_state.ChromeCompositorSchedulerState = null,
    chrome_user_event: ?chrome_user_event.ChromeUserEvent = null,
    chrome_keyed_service: ?chrome_keyed_service.ChromeKeyedService = null,
    chrome_legacy_ipc: ?chrome_legacy_ipc.ChromeLegacyIpc = null,
    chrome_histogram_sample: ?chrome_histogram_sample.ChromeHistogramSample = null,
    chrome_latency_info: ?chrome_latency_info.ChromeLatencyInfo = null,
    chrome_frame_reporter: ?chrome_frame_reporter.ChromeFrameReporter = null,
    chrome_application_state_info: ?chrome_application_state_info.ChromeApplicationStateInfo = null,
    chrome_renderer_scheduler_state: ?chrome_renderer_scheduler_state.ChromeRendererSchedulerState = null,
    chrome_window_handle_event_info: ?chrome_window_handle_event_info.ChromeWindowHandleEventInfo = null,
    chrome_content_settings_event_info: ?chrome_content_settings_event_info.ChromeContentSettingsEventInfo = null,
    chrome_active_processes: ?chrome_active_processes.ChromeActiveProcesses = null,
    screenshot: ?screenshot.Screenshot = null,
    chrome_message_pump: ?chrome_message_pump.ChromeMessagePump = null,
    chrome_mojo_event_info: ?chrome_mojo_event_info.ChromeMojoEventInfo = null,
    legacy_event: ?TrackEvent.LegacyEvent = null,
    name_iid: u64 = 0,
    name: ?[]const u8 = null,
    counter_value: i64 = 0,
    double_counter_value: f64 = 0.0,
    correlation_id: u64 = 0,
    correlation_id_str: ?[]const u8 = null,
    correlation_id_str_iid: u64 = 0,
    callstack: ?TrackEvent.Callstack = null,
    callstack_iid: u64 = 0,
    source_location: ?source_location.SourceLocation = null,
    source_location_iid: u64 = 0,
    timestamp_delta_us: i64 = 0,
    timestamp_absolute_us: i64 = 0,
    thread_time_delta_us: i64 = 0,
    thread_time_absolute_us: i64 = 0,
    thread_instruction_count_delta: i64 = 0,
    thread_instruction_count_absolute: i64 = 0,
    pub fn calcProtobufSize(self: *const TrackEvent) usize {
        var res: usize = 0;
        if (self.category_iids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(TrackEventWire.CATEGORY_IIDS_WIRE) + gremlin.sizes.sizeU64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                res += gremlin.sizes.sizeWireNumber(TrackEventWire.CATEGORY_IIDS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.categories) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TrackEventWire.CATEGORIES_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (@intFromEnum(self.type) != 0) {
            res += gremlin.sizes.sizeWireNumber(TrackEventWire.TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.type));
        }
        if (self.track_uuid != 0) {
            res += gremlin.sizes.sizeWireNumber(TrackEventWire.TRACK_UUID_WIRE) + gremlin.sizes.sizeU64(self.track_uuid);
        }
        if (self.extra_counter_track_uuids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(TrackEventWire.EXTRA_COUNTER_TRACK_UUIDS_WIRE) + gremlin.sizes.sizeU64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                res += gremlin.sizes.sizeWireNumber(TrackEventWire.EXTRA_COUNTER_TRACK_UUIDS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.extra_counter_values) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(TrackEventWire.EXTRA_COUNTER_VALUES_WIRE) + gremlin.sizes.sizeI64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI64(v);
                }
                res += gremlin.sizes.sizeWireNumber(TrackEventWire.EXTRA_COUNTER_VALUES_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.extra_double_counter_track_uuids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(TrackEventWire.EXTRA_DOUBLE_COUNTER_TRACK_UUIDS_WIRE) + gremlin.sizes.sizeU64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                res += gremlin.sizes.sizeWireNumber(TrackEventWire.EXTRA_DOUBLE_COUNTER_TRACK_UUIDS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.extra_double_counter_values) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(TrackEventWire.EXTRA_DOUBLE_COUNTER_VALUES_WIRE) + gremlin.sizes.sizeDouble(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeDouble(v);
                }
                res += gremlin.sizes.sizeWireNumber(TrackEventWire.EXTRA_DOUBLE_COUNTER_VALUES_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.flow_ids_old) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(TrackEventWire.FLOW_IDS_OLD_WIRE) + gremlin.sizes.sizeU64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                res += gremlin.sizes.sizeWireNumber(TrackEventWire.FLOW_IDS_OLD_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.flow_ids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(TrackEventWire.FLOW_IDS_WIRE) + gremlin.sizes.sizeFixed64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeFixed64(v);
                }
                res += gremlin.sizes.sizeWireNumber(TrackEventWire.FLOW_IDS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.terminating_flow_ids_old) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(TrackEventWire.TERMINATING_FLOW_IDS_OLD_WIRE) + gremlin.sizes.sizeU64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                res += gremlin.sizes.sizeWireNumber(TrackEventWire.TERMINATING_FLOW_IDS_OLD_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.terminating_flow_ids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(TrackEventWire.TERMINATING_FLOW_IDS_WIRE) + gremlin.sizes.sizeFixed64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeFixed64(v);
                }
                res += gremlin.sizes.sizeWireNumber(TrackEventWire.TERMINATING_FLOW_IDS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.debug_annotations) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TrackEventWire.DEBUG_ANNOTATIONS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.task_execution) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TrackEventWire.TASK_EXECUTION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.log_message) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TrackEventWire.LOG_MESSAGE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cc_scheduler_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TrackEventWire.CC_SCHEDULER_STATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_user_event) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TrackEventWire.CHROME_USER_EVENT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_keyed_service) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TrackEventWire.CHROME_KEYED_SERVICE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_legacy_ipc) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TrackEventWire.CHROME_LEGACY_IPC_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_histogram_sample) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TrackEventWire.CHROME_HISTOGRAM_SAMPLE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_latency_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TrackEventWire.CHROME_LATENCY_INFO_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_frame_reporter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TrackEventWire.CHROME_FRAME_REPORTER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_application_state_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TrackEventWire.CHROME_APPLICATION_STATE_INFO_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_renderer_scheduler_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TrackEventWire.CHROME_RENDERER_SCHEDULER_STATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_window_handle_event_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TrackEventWire.CHROME_WINDOW_HANDLE_EVENT_INFO_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_content_settings_event_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TrackEventWire.CHROME_CONTENT_SETTINGS_EVENT_INFO_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_active_processes) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TrackEventWire.CHROME_ACTIVE_PROCESSES_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.screenshot) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TrackEventWire.SCREENSHOT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_message_pump) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TrackEventWire.CHROME_MESSAGE_PUMP_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_mojo_event_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TrackEventWire.CHROME_MOJO_EVENT_INFO_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.legacy_event) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TrackEventWire.LEGACY_EVENT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.name_iid != 0) {
            res += gremlin.sizes.sizeWireNumber(TrackEventWire.NAME_IID_WIRE) + gremlin.sizes.sizeU64(self.name_iid);
        }
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TrackEventWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.counter_value != 0) {
            res += gremlin.sizes.sizeWireNumber(TrackEventWire.COUNTER_VALUE_WIRE) + gremlin.sizes.sizeI64(self.counter_value);
        }
        if (self.double_counter_value != 0.0) {
            res += gremlin.sizes.sizeWireNumber(TrackEventWire.DOUBLE_COUNTER_VALUE_WIRE) + gremlin.sizes.sizeDouble(self.double_counter_value);
        }
        if (self.correlation_id != 0) {
            res += gremlin.sizes.sizeWireNumber(TrackEventWire.CORRELATION_ID_WIRE) + gremlin.sizes.sizeU64(self.correlation_id);
        }
        if (self.correlation_id_str) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TrackEventWire.CORRELATION_ID_STR_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.correlation_id_str_iid != 0) {
            res += gremlin.sizes.sizeWireNumber(TrackEventWire.CORRELATION_ID_STR_IID_WIRE) + gremlin.sizes.sizeU64(self.correlation_id_str_iid);
        }
        if (self.callstack) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TrackEventWire.CALLSTACK_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.callstack_iid != 0) {
            res += gremlin.sizes.sizeWireNumber(TrackEventWire.CALLSTACK_IID_WIRE) + gremlin.sizes.sizeU64(self.callstack_iid);
        }
        if (self.source_location) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TrackEventWire.SOURCE_LOCATION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.source_location_iid != 0) {
            res += gremlin.sizes.sizeWireNumber(TrackEventWire.SOURCE_LOCATION_IID_WIRE) + gremlin.sizes.sizeU64(self.source_location_iid);
        }
        if (self.timestamp_delta_us != 0) {
            res += gremlin.sizes.sizeWireNumber(TrackEventWire.TIMESTAMP_DELTA_US_WIRE) + gremlin.sizes.sizeI64(self.timestamp_delta_us);
        }
        if (self.timestamp_absolute_us != 0) {
            res += gremlin.sizes.sizeWireNumber(TrackEventWire.TIMESTAMP_ABSOLUTE_US_WIRE) + gremlin.sizes.sizeI64(self.timestamp_absolute_us);
        }
        if (self.thread_time_delta_us != 0) {
            res += gremlin.sizes.sizeWireNumber(TrackEventWire.THREAD_TIME_DELTA_US_WIRE) + gremlin.sizes.sizeI64(self.thread_time_delta_us);
        }
        if (self.thread_time_absolute_us != 0) {
            res += gremlin.sizes.sizeWireNumber(TrackEventWire.THREAD_TIME_ABSOLUTE_US_WIRE) + gremlin.sizes.sizeI64(self.thread_time_absolute_us);
        }
        if (self.thread_instruction_count_delta != 0) {
            res += gremlin.sizes.sizeWireNumber(TrackEventWire.THREAD_INSTRUCTION_COUNT_DELTA_WIRE) + gremlin.sizes.sizeI64(self.thread_instruction_count_delta);
        }
        if (self.thread_instruction_count_absolute != 0) {
            res += gremlin.sizes.sizeWireNumber(TrackEventWire.THREAD_INSTRUCTION_COUNT_ABSOLUTE_WIRE) + gremlin.sizes.sizeI64(self.thread_instruction_count_absolute);
        }
        return res;
    }
    pub fn encode(self: *const TrackEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TrackEvent, target: *gremlin.Writer) void {
        if (self.category_iids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint64(TrackEventWire.CATEGORY_IIDS_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                target.appendBytesTag(TrackEventWire.CATEGORY_IIDS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint64WithoutTag(v);
                }
            }
        }
        if (self.categories) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(TrackEventWire.CATEGORIES_WIRE, v);
                } else {
                    target.appendBytesTag(TrackEventWire.CATEGORIES_WIRE, 0);
                }
            }
        }
        if (@intFromEnum(self.type) != 0) {
            target.appendInt32(TrackEventWire.TYPE_WIRE, @intFromEnum(self.type));
        }
        if (self.track_uuid != 0) {
            target.appendUint64(TrackEventWire.TRACK_UUID_WIRE, self.track_uuid);
        }
        if (self.extra_counter_track_uuids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint64(TrackEventWire.EXTRA_COUNTER_TRACK_UUIDS_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                target.appendBytesTag(TrackEventWire.EXTRA_COUNTER_TRACK_UUIDS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint64WithoutTag(v);
                }
            }
        }
        if (self.extra_counter_values) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt64(TrackEventWire.EXTRA_COUNTER_VALUES_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI64(v);
                }
                target.appendBytesTag(TrackEventWire.EXTRA_COUNTER_VALUES_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt64WithoutTag(v);
                }
            }
        }
        if (self.extra_double_counter_track_uuids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint64(TrackEventWire.EXTRA_DOUBLE_COUNTER_TRACK_UUIDS_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                target.appendBytesTag(TrackEventWire.EXTRA_DOUBLE_COUNTER_TRACK_UUIDS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint64WithoutTag(v);
                }
            }
        }
        if (self.extra_double_counter_values) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendFloat64(TrackEventWire.EXTRA_DOUBLE_COUNTER_VALUES_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeDouble(v);
                }
                target.appendBytesTag(TrackEventWire.EXTRA_DOUBLE_COUNTER_VALUES_WIRE, packed_size);
                for (arr) |v| {
                    target.appendFloat64WithoutTag(v);
                }
            }
        }
        if (self.flow_ids_old) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint64(TrackEventWire.FLOW_IDS_OLD_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                target.appendBytesTag(TrackEventWire.FLOW_IDS_OLD_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint64WithoutTag(v);
                }
            }
        }
        if (self.flow_ids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendFixed64(TrackEventWire.FLOW_IDS_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeFixed64(v);
                }
                target.appendBytesTag(TrackEventWire.FLOW_IDS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendFixed64WithoutTag(v);
                }
            }
        }
        if (self.terminating_flow_ids_old) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint64(TrackEventWire.TERMINATING_FLOW_IDS_OLD_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                target.appendBytesTag(TrackEventWire.TERMINATING_FLOW_IDS_OLD_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint64WithoutTag(v);
                }
            }
        }
        if (self.terminating_flow_ids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendFixed64(TrackEventWire.TERMINATING_FLOW_IDS_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeFixed64(v);
                }
                target.appendBytesTag(TrackEventWire.TERMINATING_FLOW_IDS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendFixed64WithoutTag(v);
                }
            }
        }
        if (self.debug_annotations) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(TrackEventWire.DEBUG_ANNOTATIONS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(TrackEventWire.DEBUG_ANNOTATIONS_WIRE, 0);
                }
            }
        }
        if (self.task_execution) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TrackEventWire.TASK_EXECUTION_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.log_message) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TrackEventWire.LOG_MESSAGE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cc_scheduler_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TrackEventWire.CC_SCHEDULER_STATE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_user_event) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TrackEventWire.CHROME_USER_EVENT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_keyed_service) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TrackEventWire.CHROME_KEYED_SERVICE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_legacy_ipc) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TrackEventWire.CHROME_LEGACY_IPC_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_histogram_sample) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TrackEventWire.CHROME_HISTOGRAM_SAMPLE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_latency_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TrackEventWire.CHROME_LATENCY_INFO_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_frame_reporter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TrackEventWire.CHROME_FRAME_REPORTER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_application_state_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TrackEventWire.CHROME_APPLICATION_STATE_INFO_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_renderer_scheduler_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TrackEventWire.CHROME_RENDERER_SCHEDULER_STATE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_window_handle_event_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TrackEventWire.CHROME_WINDOW_HANDLE_EVENT_INFO_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_content_settings_event_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TrackEventWire.CHROME_CONTENT_SETTINGS_EVENT_INFO_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_active_processes) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TrackEventWire.CHROME_ACTIVE_PROCESSES_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.screenshot) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TrackEventWire.SCREENSHOT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_message_pump) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TrackEventWire.CHROME_MESSAGE_PUMP_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_mojo_event_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TrackEventWire.CHROME_MOJO_EVENT_INFO_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.legacy_event) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TrackEventWire.LEGACY_EVENT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.name_iid != 0) {
            target.appendUint64(TrackEventWire.NAME_IID_WIRE, self.name_iid);
        }
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(TrackEventWire.NAME_WIRE, v);
            }
        }
        if (self.counter_value != 0) {
            target.appendInt64(TrackEventWire.COUNTER_VALUE_WIRE, self.counter_value);
        }
        if (self.double_counter_value != 0.0) {
            target.appendFloat64(TrackEventWire.DOUBLE_COUNTER_VALUE_WIRE, self.double_counter_value);
        }
        if (self.correlation_id != 0) {
            target.appendUint64(TrackEventWire.CORRELATION_ID_WIRE, self.correlation_id);
        }
        if (self.correlation_id_str) |v| {
            if (v.len > 0) {
                target.appendBytes(TrackEventWire.CORRELATION_ID_STR_WIRE, v);
            }
        }
        if (self.correlation_id_str_iid != 0) {
            target.appendUint64(TrackEventWire.CORRELATION_ID_STR_IID_WIRE, self.correlation_id_str_iid);
        }
        if (self.callstack) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TrackEventWire.CALLSTACK_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.callstack_iid != 0) {
            target.appendUint64(TrackEventWire.CALLSTACK_IID_WIRE, self.callstack_iid);
        }
        if (self.source_location) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TrackEventWire.SOURCE_LOCATION_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.source_location_iid != 0) {
            target.appendUint64(TrackEventWire.SOURCE_LOCATION_IID_WIRE, self.source_location_iid);
        }
        if (self.timestamp_delta_us != 0) {
            target.appendInt64(TrackEventWire.TIMESTAMP_DELTA_US_WIRE, self.timestamp_delta_us);
        }
        if (self.timestamp_absolute_us != 0) {
            target.appendInt64(TrackEventWire.TIMESTAMP_ABSOLUTE_US_WIRE, self.timestamp_absolute_us);
        }
        if (self.thread_time_delta_us != 0) {
            target.appendInt64(TrackEventWire.THREAD_TIME_DELTA_US_WIRE, self.thread_time_delta_us);
        }
        if (self.thread_time_absolute_us != 0) {
            target.appendInt64(TrackEventWire.THREAD_TIME_ABSOLUTE_US_WIRE, self.thread_time_absolute_us);
        }
        if (self.thread_instruction_count_delta != 0) {
            target.appendInt64(TrackEventWire.THREAD_INSTRUCTION_COUNT_DELTA_WIRE, self.thread_instruction_count_delta);
        }
        if (self.thread_instruction_count_absolute != 0) {
            target.appendInt64(TrackEventWire.THREAD_INSTRUCTION_COUNT_ABSOLUTE_WIRE, self.thread_instruction_count_absolute);
        }
    }
};
pub const TrackEventReader = struct {
    buf: gremlin.Reader,
    _category_iids_offset: ?usize = null,
    _category_iids_last_offset: ?usize = null,
    _category_iids_packed: bool = false,
    _categories_offset: ?usize = null,
    _categories_last_offset: ?usize = null,
    _categories_cnt: usize = 0,
    _type: TrackEvent.Type = @enumFromInt(0),
    _track_uuid: u64 = 0,
    _extra_counter_track_uuids_offset: ?usize = null,
    _extra_counter_track_uuids_last_offset: ?usize = null,
    _extra_counter_track_uuids_packed: bool = false,
    _extra_counter_values_offset: ?usize = null,
    _extra_counter_values_last_offset: ?usize = null,
    _extra_counter_values_packed: bool = false,
    _extra_double_counter_track_uuids_offset: ?usize = null,
    _extra_double_counter_track_uuids_last_offset: ?usize = null,
    _extra_double_counter_track_uuids_packed: bool = false,
    _extra_double_counter_values_offset: ?usize = null,
    _extra_double_counter_values_last_offset: ?usize = null,
    _extra_double_counter_values_packed: bool = false,
    _flow_ids_old_offset: ?usize = null,
    _flow_ids_old_last_offset: ?usize = null,
    _flow_ids_old_packed: bool = false,
    _flow_ids_offset: ?usize = null,
    _flow_ids_last_offset: ?usize = null,
    _flow_ids_packed: bool = false,
    _terminating_flow_ids_old_offset: ?usize = null,
    _terminating_flow_ids_old_last_offset: ?usize = null,
    _terminating_flow_ids_old_packed: bool = false,
    _terminating_flow_ids_offset: ?usize = null,
    _terminating_flow_ids_last_offset: ?usize = null,
    _terminating_flow_ids_packed: bool = false,
    _debug_annotations_offset: ?usize = null,
    _debug_annotations_last_offset: ?usize = null,
    _debug_annotations_cnt: usize = 0,
    _task_execution_buf: ?[]const u8 = null,
    _log_message_buf: ?[]const u8 = null,
    _cc_scheduler_state_buf: ?[]const u8 = null,
    _chrome_user_event_buf: ?[]const u8 = null,
    _chrome_keyed_service_buf: ?[]const u8 = null,
    _chrome_legacy_ipc_buf: ?[]const u8 = null,
    _chrome_histogram_sample_buf: ?[]const u8 = null,
    _chrome_latency_info_buf: ?[]const u8 = null,
    _chrome_frame_reporter_buf: ?[]const u8 = null,
    _chrome_application_state_info_buf: ?[]const u8 = null,
    _chrome_renderer_scheduler_state_buf: ?[]const u8 = null,
    _chrome_window_handle_event_info_buf: ?[]const u8 = null,
    _chrome_content_settings_event_info_buf: ?[]const u8 = null,
    _chrome_active_processes_buf: ?[]const u8 = null,
    _screenshot_buf: ?[]const u8 = null,
    _chrome_message_pump_buf: ?[]const u8 = null,
    _chrome_mojo_event_info_buf: ?[]const u8 = null,
    _legacy_event_buf: ?[]const u8 = null,
    _name_iid: u64 = 0,
    _name: ?[]const u8 = null,
    _counter_value: i64 = 0,
    _double_counter_value: f64 = 0.0,
    _correlation_id: u64 = 0,
    _correlation_id_str: ?[]const u8 = null,
    _correlation_id_str_iid: u64 = 0,
    _callstack_buf: ?[]const u8 = null,
    _callstack_iid: u64 = 0,
    _source_location_buf: ?[]const u8 = null,
    _source_location_iid: u64 = 0,
    _timestamp_delta_us: i64 = 0,
    _timestamp_absolute_us: i64 = 0,
    _thread_time_delta_us: i64 = 0,
    _thread_time_absolute_us: i64 = 0,
    _thread_instruction_count_delta: i64 = 0,
    _thread_instruction_count_absolute: i64 = 0,
    pub fn init(src: []const u8) gremlin.Error!TrackEventReader {
        const buf = gremlin.Reader.init(src);
        var res = TrackEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TrackEventWire.CATEGORY_IIDS_WIRE => {
                    if (res._category_iids_offset == null) {
                        res._category_iids_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._category_iids_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._category_iids_offset = offset + length_result.size;
                        res._category_iids_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._category_iids_last_offset.?;
                    } else {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._category_iids_last_offset = offset;
                    }
                },
                TrackEventWire.CATEGORIES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._categories_offset == null) {
                        res._categories_offset = offset - result.size;
                    }
                    res._categories_last_offset = offset;
                    res._categories_cnt += 1;
                },
                TrackEventWire.TYPE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._type = @enumFromInt(result.value);
                },
                TrackEventWire.TRACK_UUID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._track_uuid = result.value;
                },
                TrackEventWire.EXTRA_COUNTER_TRACK_UUIDS_WIRE => {
                    if (res._extra_counter_track_uuids_offset == null) {
                        res._extra_counter_track_uuids_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._extra_counter_track_uuids_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._extra_counter_track_uuids_offset = offset + length_result.size;
                        res._extra_counter_track_uuids_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._extra_counter_track_uuids_last_offset.?;
                    } else {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._extra_counter_track_uuids_last_offset = offset;
                    }
                },
                TrackEventWire.EXTRA_COUNTER_VALUES_WIRE => {
                    if (res._extra_counter_values_offset == null) {
                        res._extra_counter_values_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._extra_counter_values_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._extra_counter_values_offset = offset + length_result.size;
                        res._extra_counter_values_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._extra_counter_values_last_offset.?;
                    } else {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._extra_counter_values_last_offset = offset;
                    }
                },
                TrackEventWire.EXTRA_DOUBLE_COUNTER_TRACK_UUIDS_WIRE => {
                    if (res._extra_double_counter_track_uuids_offset == null) {
                        res._extra_double_counter_track_uuids_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._extra_double_counter_track_uuids_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._extra_double_counter_track_uuids_offset = offset + length_result.size;
                        res._extra_double_counter_track_uuids_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._extra_double_counter_track_uuids_last_offset.?;
                    } else {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._extra_double_counter_track_uuids_last_offset = offset;
                    }
                },
                TrackEventWire.EXTRA_DOUBLE_COUNTER_VALUES_WIRE => {
                    if (res._extra_double_counter_values_offset == null) {
                        res._extra_double_counter_values_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._extra_double_counter_values_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._extra_double_counter_values_offset = offset + length_result.size;
                        res._extra_double_counter_values_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._extra_double_counter_values_last_offset.?;
                    } else {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._extra_double_counter_values_last_offset = offset;
                    }
                },
                TrackEventWire.FLOW_IDS_OLD_WIRE => {
                    if (res._flow_ids_old_offset == null) {
                        res._flow_ids_old_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._flow_ids_old_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._flow_ids_old_offset = offset + length_result.size;
                        res._flow_ids_old_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._flow_ids_old_last_offset.?;
                    } else {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._flow_ids_old_last_offset = offset;
                    }
                },
                TrackEventWire.FLOW_IDS_WIRE => {
                    if (res._flow_ids_offset == null) {
                        res._flow_ids_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._flow_ids_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._flow_ids_offset = offset + length_result.size;
                        res._flow_ids_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._flow_ids_last_offset.?;
                    } else {
                        const result = try buf.readFixed64(offset);
                        offset += result.size;
                        res._flow_ids_last_offset = offset;
                    }
                },
                TrackEventWire.TERMINATING_FLOW_IDS_OLD_WIRE => {
                    if (res._terminating_flow_ids_old_offset == null) {
                        res._terminating_flow_ids_old_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._terminating_flow_ids_old_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._terminating_flow_ids_old_offset = offset + length_result.size;
                        res._terminating_flow_ids_old_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._terminating_flow_ids_old_last_offset.?;
                    } else {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._terminating_flow_ids_old_last_offset = offset;
                    }
                },
                TrackEventWire.TERMINATING_FLOW_IDS_WIRE => {
                    if (res._terminating_flow_ids_offset == null) {
                        res._terminating_flow_ids_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._terminating_flow_ids_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._terminating_flow_ids_offset = offset + length_result.size;
                        res._terminating_flow_ids_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._terminating_flow_ids_last_offset.?;
                    } else {
                        const result = try buf.readFixed64(offset);
                        offset += result.size;
                        res._terminating_flow_ids_last_offset = offset;
                    }
                },
                TrackEventWire.DEBUG_ANNOTATIONS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._debug_annotations_offset == null) {
                        res._debug_annotations_offset = offset - result.size;
                    }
                    res._debug_annotations_last_offset = offset;
                    res._debug_annotations_cnt += 1;
                },
                TrackEventWire.TASK_EXECUTION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._task_execution_buf = result.value;
                },
                TrackEventWire.LOG_MESSAGE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._log_message_buf = result.value;
                },
                TrackEventWire.CC_SCHEDULER_STATE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cc_scheduler_state_buf = result.value;
                },
                TrackEventWire.CHROME_USER_EVENT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_user_event_buf = result.value;
                },
                TrackEventWire.CHROME_KEYED_SERVICE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_keyed_service_buf = result.value;
                },
                TrackEventWire.CHROME_LEGACY_IPC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_legacy_ipc_buf = result.value;
                },
                TrackEventWire.CHROME_HISTOGRAM_SAMPLE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_histogram_sample_buf = result.value;
                },
                TrackEventWire.CHROME_LATENCY_INFO_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_latency_info_buf = result.value;
                },
                TrackEventWire.CHROME_FRAME_REPORTER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_frame_reporter_buf = result.value;
                },
                TrackEventWire.CHROME_APPLICATION_STATE_INFO_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_application_state_info_buf = result.value;
                },
                TrackEventWire.CHROME_RENDERER_SCHEDULER_STATE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_renderer_scheduler_state_buf = result.value;
                },
                TrackEventWire.CHROME_WINDOW_HANDLE_EVENT_INFO_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_window_handle_event_info_buf = result.value;
                },
                TrackEventWire.CHROME_CONTENT_SETTINGS_EVENT_INFO_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_content_settings_event_info_buf = result.value;
                },
                TrackEventWire.CHROME_ACTIVE_PROCESSES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_active_processes_buf = result.value;
                },
                TrackEventWire.SCREENSHOT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._screenshot_buf = result.value;
                },
                TrackEventWire.CHROME_MESSAGE_PUMP_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_message_pump_buf = result.value;
                },
                TrackEventWire.CHROME_MOJO_EVENT_INFO_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_mojo_event_info_buf = result.value;
                },
                TrackEventWire.LEGACY_EVENT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._legacy_event_buf = result.value;
                },
                TrackEventWire.NAME_IID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._name_iid = result.value;
                },
                TrackEventWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                TrackEventWire.COUNTER_VALUE_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._counter_value = result.value;
                },
                TrackEventWire.DOUBLE_COUNTER_VALUE_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._double_counter_value = result.value;
                },
                TrackEventWire.CORRELATION_ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._correlation_id = result.value;
                },
                TrackEventWire.CORRELATION_ID_STR_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._correlation_id_str = result.value;
                },
                TrackEventWire.CORRELATION_ID_STR_IID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._correlation_id_str_iid = result.value;
                },
                TrackEventWire.CALLSTACK_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._callstack_buf = result.value;
                },
                TrackEventWire.CALLSTACK_IID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._callstack_iid = result.value;
                },
                TrackEventWire.SOURCE_LOCATION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._source_location_buf = result.value;
                },
                TrackEventWire.SOURCE_LOCATION_IID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._source_location_iid = result.value;
                },
                TrackEventWire.TIMESTAMP_DELTA_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._timestamp_delta_us = result.value;
                },
                TrackEventWire.TIMESTAMP_ABSOLUTE_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._timestamp_absolute_us = result.value;
                },
                TrackEventWire.THREAD_TIME_DELTA_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._thread_time_delta_us = result.value;
                },
                TrackEventWire.THREAD_TIME_ABSOLUTE_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._thread_time_absolute_us = result.value;
                },
                TrackEventWire.THREAD_INSTRUCTION_COUNT_DELTA_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._thread_instruction_count_delta = result.value;
                },
                TrackEventWire.THREAD_INSTRUCTION_COUNT_ABSOLUTE_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._thread_instruction_count_absolute = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn categoryIidsNext(self: *TrackEventReader) gremlin.Error!?u64 {
        if (self._category_iids_offset == null) return null;
        const current_offset = self._category_iids_offset.?;
        if (current_offset >= self._category_iids_last_offset.?) {
            self._category_iids_offset = null;
            return null;
        }
        if (self._category_iids_packed) {
            const value_result = try self.buf.readUInt64(current_offset);
            self._category_iids_offset = current_offset + value_result.size;
            if (self._category_iids_offset.? >= self._category_iids_last_offset.?) {
                self._category_iids_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._category_iids_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == TrackEventWire.CATEGORY_IIDS_WIRE) {
                    self._category_iids_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._category_iids_offset = null;
            return value_result.value;
        }
    }
    pub fn categoriesCount(self: *const TrackEventReader) usize {
        return self._categories_cnt;
    }
    pub fn categoriesNext(self: *TrackEventReader) ?[]const u8 {
        if (self._categories_offset == null) return null;
        const current_offset = self._categories_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._categories_last_offset != null and current_offset >= self._categories_last_offset.?) {
            self._categories_offset = null;
            return result.value;
        }
        if (self._categories_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._categories_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TrackEventWire.CATEGORIES_WIRE) {
                self._categories_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._categories_offset = null;
        return result.value;
    }
    pub inline fn getType(self: *const TrackEventReader) TrackEvent.Type {
        return self._type;
    }
    pub inline fn getTrackUuid(self: *const TrackEventReader) u64 {
        return self._track_uuid;
    }
    pub fn extraCounterTrackUuidsNext(self: *TrackEventReader) gremlin.Error!?u64 {
        if (self._extra_counter_track_uuids_offset == null) return null;
        const current_offset = self._extra_counter_track_uuids_offset.?;
        if (current_offset >= self._extra_counter_track_uuids_last_offset.?) {
            self._extra_counter_track_uuids_offset = null;
            return null;
        }
        if (self._extra_counter_track_uuids_packed) {
            const value_result = try self.buf.readUInt64(current_offset);
            self._extra_counter_track_uuids_offset = current_offset + value_result.size;
            if (self._extra_counter_track_uuids_offset.? >= self._extra_counter_track_uuids_last_offset.?) {
                self._extra_counter_track_uuids_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._extra_counter_track_uuids_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == TrackEventWire.EXTRA_COUNTER_TRACK_UUIDS_WIRE) {
                    self._extra_counter_track_uuids_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._extra_counter_track_uuids_offset = null;
            return value_result.value;
        }
    }
    pub fn extraCounterValuesNext(self: *TrackEventReader) gremlin.Error!?i64 {
        if (self._extra_counter_values_offset == null) return null;
        const current_offset = self._extra_counter_values_offset.?;
        if (current_offset >= self._extra_counter_values_last_offset.?) {
            self._extra_counter_values_offset = null;
            return null;
        }
        if (self._extra_counter_values_packed) {
            const value_result = try self.buf.readInt64(current_offset);
            self._extra_counter_values_offset = current_offset + value_result.size;
            if (self._extra_counter_values_offset.? >= self._extra_counter_values_last_offset.?) {
                self._extra_counter_values_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._extra_counter_values_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == TrackEventWire.EXTRA_COUNTER_VALUES_WIRE) {
                    self._extra_counter_values_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._extra_counter_values_offset = null;
            return value_result.value;
        }
    }
    pub fn extraDoubleCounterTrackUuidsNext(self: *TrackEventReader) gremlin.Error!?u64 {
        if (self._extra_double_counter_track_uuids_offset == null) return null;
        const current_offset = self._extra_double_counter_track_uuids_offset.?;
        if (current_offset >= self._extra_double_counter_track_uuids_last_offset.?) {
            self._extra_double_counter_track_uuids_offset = null;
            return null;
        }
        if (self._extra_double_counter_track_uuids_packed) {
            const value_result = try self.buf.readUInt64(current_offset);
            self._extra_double_counter_track_uuids_offset = current_offset + value_result.size;
            if (self._extra_double_counter_track_uuids_offset.? >= self._extra_double_counter_track_uuids_last_offset.?) {
                self._extra_double_counter_track_uuids_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._extra_double_counter_track_uuids_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == TrackEventWire.EXTRA_DOUBLE_COUNTER_TRACK_UUIDS_WIRE) {
                    self._extra_double_counter_track_uuids_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._extra_double_counter_track_uuids_offset = null;
            return value_result.value;
        }
    }
    pub fn extraDoubleCounterValuesNext(self: *TrackEventReader) gremlin.Error!?f64 {
        if (self._extra_double_counter_values_offset == null) return null;
        const current_offset = self._extra_double_counter_values_offset.?;
        if (current_offset >= self._extra_double_counter_values_last_offset.?) {
            self._extra_double_counter_values_offset = null;
            return null;
        }
        if (self._extra_double_counter_values_packed) {
            const value_result = try self.buf.readFloat64(current_offset);
            self._extra_double_counter_values_offset = current_offset + value_result.size;
            if (self._extra_double_counter_values_offset.? >= self._extra_double_counter_values_last_offset.?) {
                self._extra_double_counter_values_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readFloat64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._extra_double_counter_values_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == TrackEventWire.EXTRA_DOUBLE_COUNTER_VALUES_WIRE) {
                    self._extra_double_counter_values_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._extra_double_counter_values_offset = null;
            return value_result.value;
        }
    }
    pub fn flowIdsOldNext(self: *TrackEventReader) gremlin.Error!?u64 {
        if (self._flow_ids_old_offset == null) return null;
        const current_offset = self._flow_ids_old_offset.?;
        if (current_offset >= self._flow_ids_old_last_offset.?) {
            self._flow_ids_old_offset = null;
            return null;
        }
        if (self._flow_ids_old_packed) {
            const value_result = try self.buf.readUInt64(current_offset);
            self._flow_ids_old_offset = current_offset + value_result.size;
            if (self._flow_ids_old_offset.? >= self._flow_ids_old_last_offset.?) {
                self._flow_ids_old_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._flow_ids_old_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == TrackEventWire.FLOW_IDS_OLD_WIRE) {
                    self._flow_ids_old_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._flow_ids_old_offset = null;
            return value_result.value;
        }
    }
    pub fn flowIdsNext(self: *TrackEventReader) gremlin.Error!?u64 {
        if (self._flow_ids_offset == null) return null;
        const current_offset = self._flow_ids_offset.?;
        if (current_offset >= self._flow_ids_last_offset.?) {
            self._flow_ids_offset = null;
            return null;
        }
        if (self._flow_ids_packed) {
            const value_result = try self.buf.readFixed64(current_offset);
            self._flow_ids_offset = current_offset + value_result.size;
            if (self._flow_ids_offset.? >= self._flow_ids_last_offset.?) {
                self._flow_ids_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readFixed64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._flow_ids_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == TrackEventWire.FLOW_IDS_WIRE) {
                    self._flow_ids_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._flow_ids_offset = null;
            return value_result.value;
        }
    }
    pub fn terminatingFlowIdsOldNext(self: *TrackEventReader) gremlin.Error!?u64 {
        if (self._terminating_flow_ids_old_offset == null) return null;
        const current_offset = self._terminating_flow_ids_old_offset.?;
        if (current_offset >= self._terminating_flow_ids_old_last_offset.?) {
            self._terminating_flow_ids_old_offset = null;
            return null;
        }
        if (self._terminating_flow_ids_old_packed) {
            const value_result = try self.buf.readUInt64(current_offset);
            self._terminating_flow_ids_old_offset = current_offset + value_result.size;
            if (self._terminating_flow_ids_old_offset.? >= self._terminating_flow_ids_old_last_offset.?) {
                self._terminating_flow_ids_old_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._terminating_flow_ids_old_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == TrackEventWire.TERMINATING_FLOW_IDS_OLD_WIRE) {
                    self._terminating_flow_ids_old_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._terminating_flow_ids_old_offset = null;
            return value_result.value;
        }
    }
    pub fn terminatingFlowIdsNext(self: *TrackEventReader) gremlin.Error!?u64 {
        if (self._terminating_flow_ids_offset == null) return null;
        const current_offset = self._terminating_flow_ids_offset.?;
        if (current_offset >= self._terminating_flow_ids_last_offset.?) {
            self._terminating_flow_ids_offset = null;
            return null;
        }
        if (self._terminating_flow_ids_packed) {
            const value_result = try self.buf.readFixed64(current_offset);
            self._terminating_flow_ids_offset = current_offset + value_result.size;
            if (self._terminating_flow_ids_offset.? >= self._terminating_flow_ids_last_offset.?) {
                self._terminating_flow_ids_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readFixed64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._terminating_flow_ids_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == TrackEventWire.TERMINATING_FLOW_IDS_WIRE) {
                    self._terminating_flow_ids_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._terminating_flow_ids_offset = null;
            return value_result.value;
        }
    }
    pub fn debugAnnotationsCount(self: *const TrackEventReader) usize {
        return self._debug_annotations_cnt;
    }
    pub fn debugAnnotationsNext(self: *TrackEventReader) ?debug_annotation.DebugAnnotationReader {
        if (self._debug_annotations_offset == null) return null;
        const current_offset = self._debug_annotations_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = debug_annotation.DebugAnnotationReader.init(result.value) catch return null;
        if (self._debug_annotations_last_offset != null and current_offset >= self._debug_annotations_last_offset.?) {
            self._debug_annotations_offset = null;
            return msg;
        }
        if (self._debug_annotations_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._debug_annotations_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TrackEventWire.DEBUG_ANNOTATIONS_WIRE) {
                self._debug_annotations_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._debug_annotations_offset = null;
        return msg;
    }
    pub fn getTaskExecution(self: *const TrackEventReader) gremlin.Error!task_execution.TaskExecutionReader {
        if (self._task_execution_buf) |buf| {
            return try task_execution.TaskExecutionReader.init(buf);
        }
        return try task_execution.TaskExecutionReader.init(&[_]u8{});
    }
    pub fn getLogMessage(self: *const TrackEventReader) gremlin.Error!log_message.LogMessageReader {
        if (self._log_message_buf) |buf| {
            return try log_message.LogMessageReader.init(buf);
        }
        return try log_message.LogMessageReader.init(&[_]u8{});
    }
    pub fn getCcSchedulerState(self: *const TrackEventReader) gremlin.Error!chrome_compositor_scheduler_state.ChromeCompositorSchedulerStateReader {
        if (self._cc_scheduler_state_buf) |buf| {
            return try chrome_compositor_scheduler_state.ChromeCompositorSchedulerStateReader.init(buf);
        }
        return try chrome_compositor_scheduler_state.ChromeCompositorSchedulerStateReader.init(&[_]u8{});
    }
    pub fn getChromeUserEvent(self: *const TrackEventReader) gremlin.Error!chrome_user_event.ChromeUserEventReader {
        if (self._chrome_user_event_buf) |buf| {
            return try chrome_user_event.ChromeUserEventReader.init(buf);
        }
        return try chrome_user_event.ChromeUserEventReader.init(&[_]u8{});
    }
    pub fn getChromeKeyedService(self: *const TrackEventReader) gremlin.Error!chrome_keyed_service.ChromeKeyedServiceReader {
        if (self._chrome_keyed_service_buf) |buf| {
            return try chrome_keyed_service.ChromeKeyedServiceReader.init(buf);
        }
        return try chrome_keyed_service.ChromeKeyedServiceReader.init(&[_]u8{});
    }
    pub fn getChromeLegacyIpc(self: *const TrackEventReader) gremlin.Error!chrome_legacy_ipc.ChromeLegacyIpcReader {
        if (self._chrome_legacy_ipc_buf) |buf| {
            return try chrome_legacy_ipc.ChromeLegacyIpcReader.init(buf);
        }
        return try chrome_legacy_ipc.ChromeLegacyIpcReader.init(&[_]u8{});
    }
    pub fn getChromeHistogramSample(self: *const TrackEventReader) gremlin.Error!chrome_histogram_sample.ChromeHistogramSampleReader {
        if (self._chrome_histogram_sample_buf) |buf| {
            return try chrome_histogram_sample.ChromeHistogramSampleReader.init(buf);
        }
        return try chrome_histogram_sample.ChromeHistogramSampleReader.init(&[_]u8{});
    }
    pub fn getChromeLatencyInfo(self: *const TrackEventReader) gremlin.Error!chrome_latency_info.ChromeLatencyInfoReader {
        if (self._chrome_latency_info_buf) |buf| {
            return try chrome_latency_info.ChromeLatencyInfoReader.init(buf);
        }
        return try chrome_latency_info.ChromeLatencyInfoReader.init(&[_]u8{});
    }
    pub fn getChromeFrameReporter(self: *const TrackEventReader) gremlin.Error!chrome_frame_reporter.ChromeFrameReporterReader {
        if (self._chrome_frame_reporter_buf) |buf| {
            return try chrome_frame_reporter.ChromeFrameReporterReader.init(buf);
        }
        return try chrome_frame_reporter.ChromeFrameReporterReader.init(&[_]u8{});
    }
    pub fn getChromeApplicationStateInfo(self: *const TrackEventReader) gremlin.Error!chrome_application_state_info.ChromeApplicationStateInfoReader {
        if (self._chrome_application_state_info_buf) |buf| {
            return try chrome_application_state_info.ChromeApplicationStateInfoReader.init(buf);
        }
        return try chrome_application_state_info.ChromeApplicationStateInfoReader.init(&[_]u8{});
    }
    pub fn getChromeRendererSchedulerState(self: *const TrackEventReader) gremlin.Error!chrome_renderer_scheduler_state.ChromeRendererSchedulerStateReader {
        if (self._chrome_renderer_scheduler_state_buf) |buf| {
            return try chrome_renderer_scheduler_state.ChromeRendererSchedulerStateReader.init(buf);
        }
        return try chrome_renderer_scheduler_state.ChromeRendererSchedulerStateReader.init(&[_]u8{});
    }
    pub fn getChromeWindowHandleEventInfo(self: *const TrackEventReader) gremlin.Error!chrome_window_handle_event_info.ChromeWindowHandleEventInfoReader {
        if (self._chrome_window_handle_event_info_buf) |buf| {
            return try chrome_window_handle_event_info.ChromeWindowHandleEventInfoReader.init(buf);
        }
        return try chrome_window_handle_event_info.ChromeWindowHandleEventInfoReader.init(&[_]u8{});
    }
    pub fn getChromeContentSettingsEventInfo(self: *const TrackEventReader) gremlin.Error!chrome_content_settings_event_info.ChromeContentSettingsEventInfoReader {
        if (self._chrome_content_settings_event_info_buf) |buf| {
            return try chrome_content_settings_event_info.ChromeContentSettingsEventInfoReader.init(buf);
        }
        return try chrome_content_settings_event_info.ChromeContentSettingsEventInfoReader.init(&[_]u8{});
    }
    pub fn getChromeActiveProcesses(self: *const TrackEventReader) gremlin.Error!chrome_active_processes.ChromeActiveProcessesReader {
        if (self._chrome_active_processes_buf) |buf| {
            return try chrome_active_processes.ChromeActiveProcessesReader.init(buf);
        }
        return try chrome_active_processes.ChromeActiveProcessesReader.init(&[_]u8{});
    }
    pub fn getScreenshot(self: *const TrackEventReader) gremlin.Error!screenshot.ScreenshotReader {
        if (self._screenshot_buf) |buf| {
            return try screenshot.ScreenshotReader.init(buf);
        }
        return try screenshot.ScreenshotReader.init(&[_]u8{});
    }
    pub fn getChromeMessagePump(self: *const TrackEventReader) gremlin.Error!chrome_message_pump.ChromeMessagePumpReader {
        if (self._chrome_message_pump_buf) |buf| {
            return try chrome_message_pump.ChromeMessagePumpReader.init(buf);
        }
        return try chrome_message_pump.ChromeMessagePumpReader.init(&[_]u8{});
    }
    pub fn getChromeMojoEventInfo(self: *const TrackEventReader) gremlin.Error!chrome_mojo_event_info.ChromeMojoEventInfoReader {
        if (self._chrome_mojo_event_info_buf) |buf| {
            return try chrome_mojo_event_info.ChromeMojoEventInfoReader.init(buf);
        }
        return try chrome_mojo_event_info.ChromeMojoEventInfoReader.init(&[_]u8{});
    }
    pub fn getLegacyEvent(self: *const TrackEventReader) gremlin.Error!TrackEvent.LegacyEventReader {
        if (self._legacy_event_buf) |buf| {
            return try TrackEvent.LegacyEventReader.init(buf);
        }
        return try TrackEvent.LegacyEventReader.init(&[_]u8{});
    }
    pub inline fn getNameIid(self: *const TrackEventReader) u64 {
        return self._name_iid;
    }
    pub inline fn getName(self: *const TrackEventReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub inline fn getCounterValue(self: *const TrackEventReader) i64 {
        return self._counter_value;
    }
    pub inline fn getDoubleCounterValue(self: *const TrackEventReader) f64 {
        return self._double_counter_value;
    }
    pub inline fn getCorrelationId(self: *const TrackEventReader) u64 {
        return self._correlation_id;
    }
    pub inline fn getCorrelationIdStr(self: *const TrackEventReader) []const u8 {
        return self._correlation_id_str orelse &[_]u8{};
    }
    pub inline fn getCorrelationIdStrIid(self: *const TrackEventReader) u64 {
        return self._correlation_id_str_iid;
    }
    pub fn getCallstack(self: *const TrackEventReader) gremlin.Error!TrackEvent.CallstackReader {
        if (self._callstack_buf) |buf| {
            return try TrackEvent.CallstackReader.init(buf);
        }
        return try TrackEvent.CallstackReader.init(&[_]u8{});
    }
    pub inline fn getCallstackIid(self: *const TrackEventReader) u64 {
        return self._callstack_iid;
    }
    pub fn getSourceLocation(self: *const TrackEventReader) gremlin.Error!source_location.SourceLocationReader {
        if (self._source_location_buf) |buf| {
            return try source_location.SourceLocationReader.init(buf);
        }
        return try source_location.SourceLocationReader.init(&[_]u8{});
    }
    pub inline fn getSourceLocationIid(self: *const TrackEventReader) u64 {
        return self._source_location_iid;
    }
    pub inline fn getTimestampDeltaUs(self: *const TrackEventReader) i64 {
        return self._timestamp_delta_us;
    }
    pub inline fn getTimestampAbsoluteUs(self: *const TrackEventReader) i64 {
        return self._timestamp_absolute_us;
    }
    pub inline fn getThreadTimeDeltaUs(self: *const TrackEventReader) i64 {
        return self._thread_time_delta_us;
    }
    pub inline fn getThreadTimeAbsoluteUs(self: *const TrackEventReader) i64 {
        return self._thread_time_absolute_us;
    }
    pub inline fn getThreadInstructionCountDelta(self: *const TrackEventReader) i64 {
        return self._thread_instruction_count_delta;
    }
    pub inline fn getThreadInstructionCountAbsolute(self: *const TrackEventReader) i64 {
        return self._thread_instruction_count_absolute;
    }
};
const TrackEventDefaultsWire = struct {
    const TRACK_UUID_WIRE: gremlin.ProtoWireNumber = 11;
    const EXTRA_COUNTER_TRACK_UUIDS_WIRE: gremlin.ProtoWireNumber = 31;
    const EXTRA_DOUBLE_COUNTER_TRACK_UUIDS_WIRE: gremlin.ProtoWireNumber = 45;
};
pub const TrackEventDefaults = struct {
    // fields
    track_uuid: u64 = 0,
    extra_counter_track_uuids: ?[]const u64 = null,
    extra_double_counter_track_uuids: ?[]const u64 = null,
    pub fn calcProtobufSize(self: *const TrackEventDefaults) usize {
        var res: usize = 0;
        if (self.track_uuid != 0) {
            res += gremlin.sizes.sizeWireNumber(TrackEventDefaultsWire.TRACK_UUID_WIRE) + gremlin.sizes.sizeU64(self.track_uuid);
        }
        if (self.extra_counter_track_uuids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(TrackEventDefaultsWire.EXTRA_COUNTER_TRACK_UUIDS_WIRE) + gremlin.sizes.sizeU64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                res += gremlin.sizes.sizeWireNumber(TrackEventDefaultsWire.EXTRA_COUNTER_TRACK_UUIDS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.extra_double_counter_track_uuids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(TrackEventDefaultsWire.EXTRA_DOUBLE_COUNTER_TRACK_UUIDS_WIRE) + gremlin.sizes.sizeU64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                res += gremlin.sizes.sizeWireNumber(TrackEventDefaultsWire.EXTRA_DOUBLE_COUNTER_TRACK_UUIDS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        return res;
    }
    pub fn encode(self: *const TrackEventDefaults, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TrackEventDefaults, target: *gremlin.Writer) void {
        if (self.track_uuid != 0) {
            target.appendUint64(TrackEventDefaultsWire.TRACK_UUID_WIRE, self.track_uuid);
        }
        if (self.extra_counter_track_uuids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint64(TrackEventDefaultsWire.EXTRA_COUNTER_TRACK_UUIDS_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                target.appendBytesTag(TrackEventDefaultsWire.EXTRA_COUNTER_TRACK_UUIDS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint64WithoutTag(v);
                }
            }
        }
        if (self.extra_double_counter_track_uuids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint64(TrackEventDefaultsWire.EXTRA_DOUBLE_COUNTER_TRACK_UUIDS_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                target.appendBytesTag(TrackEventDefaultsWire.EXTRA_DOUBLE_COUNTER_TRACK_UUIDS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint64WithoutTag(v);
                }
            }
        }
    }
};
pub const TrackEventDefaultsReader = struct {
    buf: gremlin.Reader,
    _track_uuid: u64 = 0,
    _extra_counter_track_uuids_offset: ?usize = null,
    _extra_counter_track_uuids_last_offset: ?usize = null,
    _extra_counter_track_uuids_packed: bool = false,
    _extra_double_counter_track_uuids_offset: ?usize = null,
    _extra_double_counter_track_uuids_last_offset: ?usize = null,
    _extra_double_counter_track_uuids_packed: bool = false,
    pub fn init(src: []const u8) gremlin.Error!TrackEventDefaultsReader {
        const buf = gremlin.Reader.init(src);
        var res = TrackEventDefaultsReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TrackEventDefaultsWire.TRACK_UUID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._track_uuid = result.value;
                },
                TrackEventDefaultsWire.EXTRA_COUNTER_TRACK_UUIDS_WIRE => {
                    if (res._extra_counter_track_uuids_offset == null) {
                        res._extra_counter_track_uuids_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._extra_counter_track_uuids_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._extra_counter_track_uuids_offset = offset + length_result.size;
                        res._extra_counter_track_uuids_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._extra_counter_track_uuids_last_offset.?;
                    } else {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._extra_counter_track_uuids_last_offset = offset;
                    }
                },
                TrackEventDefaultsWire.EXTRA_DOUBLE_COUNTER_TRACK_UUIDS_WIRE => {
                    if (res._extra_double_counter_track_uuids_offset == null) {
                        res._extra_double_counter_track_uuids_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._extra_double_counter_track_uuids_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._extra_double_counter_track_uuids_offset = offset + length_result.size;
                        res._extra_double_counter_track_uuids_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._extra_double_counter_track_uuids_last_offset.?;
                    } else {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._extra_double_counter_track_uuids_last_offset = offset;
                    }
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getTrackUuid(self: *const TrackEventDefaultsReader) u64 {
        return self._track_uuid;
    }
    pub fn extraCounterTrackUuidsNext(self: *TrackEventDefaultsReader) gremlin.Error!?u64 {
        if (self._extra_counter_track_uuids_offset == null) return null;
        const current_offset = self._extra_counter_track_uuids_offset.?;
        if (current_offset >= self._extra_counter_track_uuids_last_offset.?) {
            self._extra_counter_track_uuids_offset = null;
            return null;
        }
        if (self._extra_counter_track_uuids_packed) {
            const value_result = try self.buf.readUInt64(current_offset);
            self._extra_counter_track_uuids_offset = current_offset + value_result.size;
            if (self._extra_counter_track_uuids_offset.? >= self._extra_counter_track_uuids_last_offset.?) {
                self._extra_counter_track_uuids_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._extra_counter_track_uuids_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == TrackEventDefaultsWire.EXTRA_COUNTER_TRACK_UUIDS_WIRE) {
                    self._extra_counter_track_uuids_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._extra_counter_track_uuids_offset = null;
            return value_result.value;
        }
    }
    pub fn extraDoubleCounterTrackUuidsNext(self: *TrackEventDefaultsReader) gremlin.Error!?u64 {
        if (self._extra_double_counter_track_uuids_offset == null) return null;
        const current_offset = self._extra_double_counter_track_uuids_offset.?;
        if (current_offset >= self._extra_double_counter_track_uuids_last_offset.?) {
            self._extra_double_counter_track_uuids_offset = null;
            return null;
        }
        if (self._extra_double_counter_track_uuids_packed) {
            const value_result = try self.buf.readUInt64(current_offset);
            self._extra_double_counter_track_uuids_offset = current_offset + value_result.size;
            if (self._extra_double_counter_track_uuids_offset.? >= self._extra_double_counter_track_uuids_last_offset.?) {
                self._extra_double_counter_track_uuids_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._extra_double_counter_track_uuids_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == TrackEventDefaultsWire.EXTRA_DOUBLE_COUNTER_TRACK_UUIDS_WIRE) {
                    self._extra_double_counter_track_uuids_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._extra_double_counter_track_uuids_offset = null;
            return value_result.value;
        }
    }
};
const EventCategoryWire = struct {
    const IID_WIRE: gremlin.ProtoWireNumber = 1;
    const NAME_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const EventCategory = struct {
    // fields
    iid: u64 = 0,
    name: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const EventCategory) usize {
        var res: usize = 0;
        if (self.iid != 0) {
            res += gremlin.sizes.sizeWireNumber(EventCategoryWire.IID_WIRE) + gremlin.sizes.sizeU64(self.iid);
        }
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(EventCategoryWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const EventCategory, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const EventCategory, target: *gremlin.Writer) void {
        if (self.iid != 0) {
            target.appendUint64(EventCategoryWire.IID_WIRE, self.iid);
        }
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(EventCategoryWire.NAME_WIRE, v);
            }
        }
    }
};
pub const EventCategoryReader = struct {
    buf: gremlin.Reader,
    _iid: u64 = 0,
    _name: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!EventCategoryReader {
        const buf = gremlin.Reader.init(src);
        var res = EventCategoryReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                EventCategoryWire.IID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._iid = result.value;
                },
                EventCategoryWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getIid(self: *const EventCategoryReader) u64 {
        return self._iid;
    }
    pub inline fn getName(self: *const EventCategoryReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
};
const EventNameWire = struct {
    const IID_WIRE: gremlin.ProtoWireNumber = 1;
    const NAME_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const EventName = struct {
    // fields
    iid: u64 = 0,
    name: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const EventName) usize {
        var res: usize = 0;
        if (self.iid != 0) {
            res += gremlin.sizes.sizeWireNumber(EventNameWire.IID_WIRE) + gremlin.sizes.sizeU64(self.iid);
        }
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(EventNameWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const EventName, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const EventName, target: *gremlin.Writer) void {
        if (self.iid != 0) {
            target.appendUint64(EventNameWire.IID_WIRE, self.iid);
        }
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(EventNameWire.NAME_WIRE, v);
            }
        }
    }
};
pub const EventNameReader = struct {
    buf: gremlin.Reader,
    _iid: u64 = 0,
    _name: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!EventNameReader {
        const buf = gremlin.Reader.init(src);
        var res = EventNameReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                EventNameWire.IID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._iid = result.value;
                },
                EventNameWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getIid(self: *const EventNameReader) u64 {
        return self._iid;
    }
    pub inline fn getName(self: *const EventNameReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
};
