// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
const source_location = @import("source_location.proto.zig");
// enums
pub const ChromeCompositorSchedulerAction = enum(i32) {
    CC_SCHEDULER_ACTION_UNSPECIFIED = 0,
    CC_SCHEDULER_ACTION_NONE = 1,
    CC_SCHEDULER_ACTION_SEND_BEGIN_MAIN_FRAME = 2,
    CC_SCHEDULER_ACTION_COMMIT = 3,
    CC_SCHEDULER_ACTION_ACTIVATE_SYNC_TREE = 4,
    CC_SCHEDULER_ACTION_DRAW_IF_POSSIBLE = 5,
    CC_SCHEDULER_ACTION_DRAW_FORCED = 6,
    CC_SCHEDULER_ACTION_DRAW_ABORT = 7,
    CC_SCHEDULER_ACTION_BEGIN_LAYER_TREE_FRAME_SINK_CREATION = 8,
    CC_SCHEDULER_ACTION_PREPARE_TILES = 9,
    CC_SCHEDULER_ACTION_INVALIDATE_LAYER_TREE_FRAME_SINK = 10,
    CC_SCHEDULER_ACTION_PERFORM_IMPL_SIDE_INVALIDATION = 11,
    CC_SCHEDULER_ACTION_NOTIFY_BEGIN_MAIN_FRAME_NOT_EXPECTED_UNTIL = 12,
    CC_SCHEDULER_ACTION_NOTIFY_BEGIN_MAIN_FRAME_NOT_EXPECTED_SOON = 13,
};
// structs
const ChromeCompositorSchedulerStateWire = struct {
    const STATE_MACHINE_WIRE: gremlin.ProtoWireNumber = 1;
    const OBSERVING_BEGIN_FRAME_SOURCE_WIRE: gremlin.ProtoWireNumber = 2;
    const BEGIN_IMPL_FRAME_DEADLINE_TASK_WIRE: gremlin.ProtoWireNumber = 3;
    const PENDING_BEGIN_FRAME_TASK_WIRE: gremlin.ProtoWireNumber = 4;
    const SKIPPED_LAST_FRAME_MISSED_EXCEEDED_DEADLINE_WIRE: gremlin.ProtoWireNumber = 5;
    const INSIDE_ACTION_WIRE: gremlin.ProtoWireNumber = 7;
    const DEADLINE_MODE_WIRE: gremlin.ProtoWireNumber = 8;
    const DEADLINE_US_WIRE: gremlin.ProtoWireNumber = 9;
    const DEADLINE_SCHEDULED_AT_US_WIRE: gremlin.ProtoWireNumber = 10;
    const NOW_US_WIRE: gremlin.ProtoWireNumber = 11;
    const NOW_TO_DEADLINE_DELTA_US_WIRE: gremlin.ProtoWireNumber = 12;
    const NOW_TO_DEADLINE_SCHEDULED_AT_DELTA_US_WIRE: gremlin.ProtoWireNumber = 13;
    const BEGIN_IMPL_FRAME_ARGS_WIRE: gremlin.ProtoWireNumber = 14;
    const BEGIN_FRAME_OBSERVER_STATE_WIRE: gremlin.ProtoWireNumber = 15;
    const BEGIN_FRAME_SOURCE_STATE_WIRE: gremlin.ProtoWireNumber = 16;
    const COMPOSITOR_TIMING_HISTORY_WIRE: gremlin.ProtoWireNumber = 17;
};
pub const ChromeCompositorSchedulerState = struct {
    // nested enums
    pub const BeginImplFrameDeadlineMode = enum(i32) {
        DEADLINE_MODE_UNSPECIFIED = 0,
        DEADLINE_MODE_NONE = 1,
        DEADLINE_MODE_IMMEDIATE = 2,
        DEADLINE_MODE_REGULAR = 3,
        DEADLINE_MODE_LATE = 4,
        DEADLINE_MODE_BLOCKED = 5,
    };
    // fields
    state_machine: ?ChromeCompositorStateMachine = null,
    observing_begin_frame_source: bool = false,
    begin_impl_frame_deadline_task: bool = false,
    pending_begin_frame_task: bool = false,
    skipped_last_frame_missed_exceeded_deadline: bool = false,
    inside_action: ChromeCompositorSchedulerAction = @enumFromInt(0),
    deadline_mode: ChromeCompositorSchedulerState.BeginImplFrameDeadlineMode = @enumFromInt(0),
    deadline_us: i64 = 0,
    deadline_scheduled_at_us: i64 = 0,
    now_us: i64 = 0,
    now_to_deadline_delta_us: i64 = 0,
    now_to_deadline_scheduled_at_delta_us: i64 = 0,
    begin_impl_frame_args: ?BeginImplFrameArgs = null,
    begin_frame_observer_state: ?BeginFrameObserverState = null,
    begin_frame_source_state: ?BeginFrameSourceState = null,
    compositor_timing_history: ?CompositorTimingHistory = null,
    pub fn calcProtobufSize(self: *const ChromeCompositorSchedulerState) usize {
        var res: usize = 0;
        if (self.state_machine) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorSchedulerStateWire.STATE_MACHINE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.observing_begin_frame_source != false) {
            res += gremlin.sizes.sizeWireNumber(ChromeCompositorSchedulerStateWire.OBSERVING_BEGIN_FRAME_SOURCE_WIRE) + gremlin.sizes.sizeBool(self.observing_begin_frame_source);
        }
        if (self.begin_impl_frame_deadline_task != false) {
            res += gremlin.sizes.sizeWireNumber(ChromeCompositorSchedulerStateWire.BEGIN_IMPL_FRAME_DEADLINE_TASK_WIRE) + gremlin.sizes.sizeBool(self.begin_impl_frame_deadline_task);
        }
        if (self.pending_begin_frame_task != false) {
            res += gremlin.sizes.sizeWireNumber(ChromeCompositorSchedulerStateWire.PENDING_BEGIN_FRAME_TASK_WIRE) + gremlin.sizes.sizeBool(self.pending_begin_frame_task);
        }
        if (self.skipped_last_frame_missed_exceeded_deadline != false) {
            res += gremlin.sizes.sizeWireNumber(ChromeCompositorSchedulerStateWire.SKIPPED_LAST_FRAME_MISSED_EXCEEDED_DEADLINE_WIRE) + gremlin.sizes.sizeBool(self.skipped_last_frame_missed_exceeded_deadline);
        }
        if (@intFromEnum(self.inside_action) != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeCompositorSchedulerStateWire.INSIDE_ACTION_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.inside_action));
        }
        if (@intFromEnum(self.deadline_mode) != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeCompositorSchedulerStateWire.DEADLINE_MODE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.deadline_mode));
        }
        if (self.deadline_us != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeCompositorSchedulerStateWire.DEADLINE_US_WIRE) + gremlin.sizes.sizeI64(self.deadline_us);
        }
        if (self.deadline_scheduled_at_us != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeCompositorSchedulerStateWire.DEADLINE_SCHEDULED_AT_US_WIRE) + gremlin.sizes.sizeI64(self.deadline_scheduled_at_us);
        }
        if (self.now_us != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeCompositorSchedulerStateWire.NOW_US_WIRE) + gremlin.sizes.sizeI64(self.now_us);
        }
        if (self.now_to_deadline_delta_us != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeCompositorSchedulerStateWire.NOW_TO_DEADLINE_DELTA_US_WIRE) + gremlin.sizes.sizeI64(self.now_to_deadline_delta_us);
        }
        if (self.now_to_deadline_scheduled_at_delta_us != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeCompositorSchedulerStateWire.NOW_TO_DEADLINE_SCHEDULED_AT_DELTA_US_WIRE) + gremlin.sizes.sizeI64(self.now_to_deadline_scheduled_at_delta_us);
        }
        if (self.begin_impl_frame_args) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorSchedulerStateWire.BEGIN_IMPL_FRAME_ARGS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.begin_frame_observer_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorSchedulerStateWire.BEGIN_FRAME_OBSERVER_STATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.begin_frame_source_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorSchedulerStateWire.BEGIN_FRAME_SOURCE_STATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.compositor_timing_history) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorSchedulerStateWire.COMPOSITOR_TIMING_HISTORY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const ChromeCompositorSchedulerState, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ChromeCompositorSchedulerState, target: *gremlin.Writer) void {
        if (self.state_machine) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeCompositorSchedulerStateWire.STATE_MACHINE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.observing_begin_frame_source != false) {
            target.appendBool(ChromeCompositorSchedulerStateWire.OBSERVING_BEGIN_FRAME_SOURCE_WIRE, self.observing_begin_frame_source);
        }
        if (self.begin_impl_frame_deadline_task != false) {
            target.appendBool(ChromeCompositorSchedulerStateWire.BEGIN_IMPL_FRAME_DEADLINE_TASK_WIRE, self.begin_impl_frame_deadline_task);
        }
        if (self.pending_begin_frame_task != false) {
            target.appendBool(ChromeCompositorSchedulerStateWire.PENDING_BEGIN_FRAME_TASK_WIRE, self.pending_begin_frame_task);
        }
        if (self.skipped_last_frame_missed_exceeded_deadline != false) {
            target.appendBool(ChromeCompositorSchedulerStateWire.SKIPPED_LAST_FRAME_MISSED_EXCEEDED_DEADLINE_WIRE, self.skipped_last_frame_missed_exceeded_deadline);
        }
        if (@intFromEnum(self.inside_action) != 0) {
            target.appendInt32(ChromeCompositorSchedulerStateWire.INSIDE_ACTION_WIRE, @intFromEnum(self.inside_action));
        }
        if (@intFromEnum(self.deadline_mode) != 0) {
            target.appendInt32(ChromeCompositorSchedulerStateWire.DEADLINE_MODE_WIRE, @intFromEnum(self.deadline_mode));
        }
        if (self.deadline_us != 0) {
            target.appendInt64(ChromeCompositorSchedulerStateWire.DEADLINE_US_WIRE, self.deadline_us);
        }
        if (self.deadline_scheduled_at_us != 0) {
            target.appendInt64(ChromeCompositorSchedulerStateWire.DEADLINE_SCHEDULED_AT_US_WIRE, self.deadline_scheduled_at_us);
        }
        if (self.now_us != 0) {
            target.appendInt64(ChromeCompositorSchedulerStateWire.NOW_US_WIRE, self.now_us);
        }
        if (self.now_to_deadline_delta_us != 0) {
            target.appendInt64(ChromeCompositorSchedulerStateWire.NOW_TO_DEADLINE_DELTA_US_WIRE, self.now_to_deadline_delta_us);
        }
        if (self.now_to_deadline_scheduled_at_delta_us != 0) {
            target.appendInt64(ChromeCompositorSchedulerStateWire.NOW_TO_DEADLINE_SCHEDULED_AT_DELTA_US_WIRE, self.now_to_deadline_scheduled_at_delta_us);
        }
        if (self.begin_impl_frame_args) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeCompositorSchedulerStateWire.BEGIN_IMPL_FRAME_ARGS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.begin_frame_observer_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeCompositorSchedulerStateWire.BEGIN_FRAME_OBSERVER_STATE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.begin_frame_source_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeCompositorSchedulerStateWire.BEGIN_FRAME_SOURCE_STATE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.compositor_timing_history) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeCompositorSchedulerStateWire.COMPOSITOR_TIMING_HISTORY_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const ChromeCompositorSchedulerStateReader = struct {
    buf: gremlin.Reader,
    _state_machine_buf: ?[]const u8 = null,
    _observing_begin_frame_source: bool = false,
    _begin_impl_frame_deadline_task: bool = false,
    _pending_begin_frame_task: bool = false,
    _skipped_last_frame_missed_exceeded_deadline: bool = false,
    _inside_action: ChromeCompositorSchedulerAction = @enumFromInt(0),
    _deadline_mode: ChromeCompositorSchedulerState.BeginImplFrameDeadlineMode = @enumFromInt(0),
    _deadline_us: i64 = 0,
    _deadline_scheduled_at_us: i64 = 0,
    _now_us: i64 = 0,
    _now_to_deadline_delta_us: i64 = 0,
    _now_to_deadline_scheduled_at_delta_us: i64 = 0,
    _begin_impl_frame_args_buf: ?[]const u8 = null,
    _begin_frame_observer_state_buf: ?[]const u8 = null,
    _begin_frame_source_state_buf: ?[]const u8 = null,
    _compositor_timing_history_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!ChromeCompositorSchedulerStateReader {
        const buf = gremlin.Reader.init(src);
        var res = ChromeCompositorSchedulerStateReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ChromeCompositorSchedulerStateWire.STATE_MACHINE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._state_machine_buf = result.value;
                },
                ChromeCompositorSchedulerStateWire.OBSERVING_BEGIN_FRAME_SOURCE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._observing_begin_frame_source = result.value;
                },
                ChromeCompositorSchedulerStateWire.BEGIN_IMPL_FRAME_DEADLINE_TASK_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._begin_impl_frame_deadline_task = result.value;
                },
                ChromeCompositorSchedulerStateWire.PENDING_BEGIN_FRAME_TASK_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._pending_begin_frame_task = result.value;
                },
                ChromeCompositorSchedulerStateWire.SKIPPED_LAST_FRAME_MISSED_EXCEEDED_DEADLINE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._skipped_last_frame_missed_exceeded_deadline = result.value;
                },
                ChromeCompositorSchedulerStateWire.INSIDE_ACTION_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._inside_action = @enumFromInt(result.value);
                },
                ChromeCompositorSchedulerStateWire.DEADLINE_MODE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._deadline_mode = @enumFromInt(result.value);
                },
                ChromeCompositorSchedulerStateWire.DEADLINE_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._deadline_us = result.value;
                },
                ChromeCompositorSchedulerStateWire.DEADLINE_SCHEDULED_AT_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._deadline_scheduled_at_us = result.value;
                },
                ChromeCompositorSchedulerStateWire.NOW_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._now_us = result.value;
                },
                ChromeCompositorSchedulerStateWire.NOW_TO_DEADLINE_DELTA_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._now_to_deadline_delta_us = result.value;
                },
                ChromeCompositorSchedulerStateWire.NOW_TO_DEADLINE_SCHEDULED_AT_DELTA_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._now_to_deadline_scheduled_at_delta_us = result.value;
                },
                ChromeCompositorSchedulerStateWire.BEGIN_IMPL_FRAME_ARGS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._begin_impl_frame_args_buf = result.value;
                },
                ChromeCompositorSchedulerStateWire.BEGIN_FRAME_OBSERVER_STATE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._begin_frame_observer_state_buf = result.value;
                },
                ChromeCompositorSchedulerStateWire.BEGIN_FRAME_SOURCE_STATE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._begin_frame_source_state_buf = result.value;
                },
                ChromeCompositorSchedulerStateWire.COMPOSITOR_TIMING_HISTORY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._compositor_timing_history_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getStateMachine(self: *const ChromeCompositorSchedulerStateReader) gremlin.Error!ChromeCompositorStateMachineReader {
        if (self._state_machine_buf) |buf| {
            return try ChromeCompositorStateMachineReader.init(buf);
        }
        return try ChromeCompositorStateMachineReader.init(&[_]u8{});
    }
    pub inline fn getObservingBeginFrameSource(self: *const ChromeCompositorSchedulerStateReader) bool {
        return self._observing_begin_frame_source;
    }
    pub inline fn getBeginImplFrameDeadlineTask(self: *const ChromeCompositorSchedulerStateReader) bool {
        return self._begin_impl_frame_deadline_task;
    }
    pub inline fn getPendingBeginFrameTask(self: *const ChromeCompositorSchedulerStateReader) bool {
        return self._pending_begin_frame_task;
    }
    pub inline fn getSkippedLastFrameMissedExceededDeadline(self: *const ChromeCompositorSchedulerStateReader) bool {
        return self._skipped_last_frame_missed_exceeded_deadline;
    }
    pub inline fn getInsideAction(self: *const ChromeCompositorSchedulerStateReader) ChromeCompositorSchedulerAction {
        return self._inside_action;
    }
    pub inline fn getDeadlineMode(self: *const ChromeCompositorSchedulerStateReader) ChromeCompositorSchedulerState.BeginImplFrameDeadlineMode {
        return self._deadline_mode;
    }
    pub inline fn getDeadlineUs(self: *const ChromeCompositorSchedulerStateReader) i64 {
        return self._deadline_us;
    }
    pub inline fn getDeadlineScheduledAtUs(self: *const ChromeCompositorSchedulerStateReader) i64 {
        return self._deadline_scheduled_at_us;
    }
    pub inline fn getNowUs(self: *const ChromeCompositorSchedulerStateReader) i64 {
        return self._now_us;
    }
    pub inline fn getNowToDeadlineDeltaUs(self: *const ChromeCompositorSchedulerStateReader) i64 {
        return self._now_to_deadline_delta_us;
    }
    pub inline fn getNowToDeadlineScheduledAtDeltaUs(self: *const ChromeCompositorSchedulerStateReader) i64 {
        return self._now_to_deadline_scheduled_at_delta_us;
    }
    pub fn getBeginImplFrameArgs(self: *const ChromeCompositorSchedulerStateReader) gremlin.Error!BeginImplFrameArgsReader {
        if (self._begin_impl_frame_args_buf) |buf| {
            return try BeginImplFrameArgsReader.init(buf);
        }
        return try BeginImplFrameArgsReader.init(&[_]u8{});
    }
    pub fn getBeginFrameObserverState(self: *const ChromeCompositorSchedulerStateReader) gremlin.Error!BeginFrameObserverStateReader {
        if (self._begin_frame_observer_state_buf) |buf| {
            return try BeginFrameObserverStateReader.init(buf);
        }
        return try BeginFrameObserverStateReader.init(&[_]u8{});
    }
    pub fn getBeginFrameSourceState(self: *const ChromeCompositorSchedulerStateReader) gremlin.Error!BeginFrameSourceStateReader {
        if (self._begin_frame_source_state_buf) |buf| {
            return try BeginFrameSourceStateReader.init(buf);
        }
        return try BeginFrameSourceStateReader.init(&[_]u8{});
    }
    pub fn getCompositorTimingHistory(self: *const ChromeCompositorSchedulerStateReader) gremlin.Error!CompositorTimingHistoryReader {
        if (self._compositor_timing_history_buf) |buf| {
            return try CompositorTimingHistoryReader.init(buf);
        }
        return try CompositorTimingHistoryReader.init(&[_]u8{});
    }
};
const ChromeCompositorStateMachineWire = struct {
    const MAJOR_STATE_WIRE: gremlin.ProtoWireNumber = 1;
    const MINOR_STATE_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const ChromeCompositorStateMachine = struct {
    // nested structs
    const MajorStateWire = struct {
        const NEXT_ACTION_WIRE: gremlin.ProtoWireNumber = 1;
        const BEGIN_IMPL_FRAME_STATE_WIRE: gremlin.ProtoWireNumber = 2;
        const BEGIN_MAIN_FRAME_STATE_WIRE: gremlin.ProtoWireNumber = 3;
        const LAYER_TREE_FRAME_SINK_STATE_WIRE: gremlin.ProtoWireNumber = 4;
        const FORCED_REDRAW_STATE_WIRE: gremlin.ProtoWireNumber = 5;
    };
    pub const MajorState = struct {
        // nested enums
        pub const BeginImplFrameState = enum(i32) {
            BEGIN_IMPL_FRAME_UNSPECIFIED = 0,
            BEGIN_IMPL_FRAME_IDLE = 1,
            BEGIN_IMPL_FRAME_INSIDE_BEGIN_FRAME = 2,
            BEGIN_IMPL_FRAME_INSIDE_DEADLINE = 3,
        };
        pub const BeginMainFrameState = enum(i32) {
            BEGIN_MAIN_FRAME_UNSPECIFIED = 0,
            BEGIN_MAIN_FRAME_IDLE = 1,
            BEGIN_MAIN_FRAME_SENT = 2,
            BEGIN_MAIN_FRAME_READY_TO_COMMIT = 3,
        };
        pub const LayerTreeFrameSinkState = enum(i32) {
            LAYER_TREE_FRAME_UNSPECIFIED = 0,
            LAYER_TREE_FRAME_NONE = 1,
            LAYER_TREE_FRAME_ACTIVE = 2,
            LAYER_TREE_FRAME_CREATING = 3,
            LAYER_TREE_FRAME_WAITING_FOR_FIRST_COMMIT = 4,
            LAYER_TREE_FRAME_WAITING_FOR_FIRST_ACTIVATION = 5,
        };
        pub const ForcedRedrawOnTimeoutState = enum(i32) {
            FORCED_REDRAW_UNSPECIFIED = 0,
            FORCED_REDRAW_IDLE = 1,
            FORCED_REDRAW_WAITING_FOR_COMMIT = 2,
            FORCED_REDRAW_WAITING_FOR_ACTIVATION = 3,
            FORCED_REDRAW_WAITING_FOR_DRAW = 4,
        };
        // fields
        next_action: ChromeCompositorSchedulerAction = @enumFromInt(0),
        begin_impl_frame_state: ChromeCompositorStateMachine.MajorState.BeginImplFrameState = @enumFromInt(0),
        begin_main_frame_state: ChromeCompositorStateMachine.MajorState.BeginMainFrameState = @enumFromInt(0),
        layer_tree_frame_sink_state: ChromeCompositorStateMachine.MajorState.LayerTreeFrameSinkState = @enumFromInt(0),
        forced_redraw_state: ChromeCompositorStateMachine.MajorState.ForcedRedrawOnTimeoutState = @enumFromInt(0),
        pub fn calcProtobufSize(self: *const ChromeCompositorStateMachine.MajorState) usize {
            var res: usize = 0;
            if (@intFromEnum(self.next_action) != 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MajorStateWire.NEXT_ACTION_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.next_action));
            }
            if (@intFromEnum(self.begin_impl_frame_state) != 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MajorStateWire.BEGIN_IMPL_FRAME_STATE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.begin_impl_frame_state));
            }
            if (@intFromEnum(self.begin_main_frame_state) != 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MajorStateWire.BEGIN_MAIN_FRAME_STATE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.begin_main_frame_state));
            }
            if (@intFromEnum(self.layer_tree_frame_sink_state) != 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MajorStateWire.LAYER_TREE_FRAME_SINK_STATE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.layer_tree_frame_sink_state));
            }
            if (@intFromEnum(self.forced_redraw_state) != 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MajorStateWire.FORCED_REDRAW_STATE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.forced_redraw_state));
            }
            return res;
        }
        pub fn encode(self: *const ChromeCompositorStateMachine.MajorState, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const ChromeCompositorStateMachine.MajorState, target: *gremlin.Writer) void {
            if (@intFromEnum(self.next_action) != 0) {
                target.appendInt32(ChromeCompositorStateMachine.MajorStateWire.NEXT_ACTION_WIRE, @intFromEnum(self.next_action));
            }
            if (@intFromEnum(self.begin_impl_frame_state) != 0) {
                target.appendInt32(ChromeCompositorStateMachine.MajorStateWire.BEGIN_IMPL_FRAME_STATE_WIRE, @intFromEnum(self.begin_impl_frame_state));
            }
            if (@intFromEnum(self.begin_main_frame_state) != 0) {
                target.appendInt32(ChromeCompositorStateMachine.MajorStateWire.BEGIN_MAIN_FRAME_STATE_WIRE, @intFromEnum(self.begin_main_frame_state));
            }
            if (@intFromEnum(self.layer_tree_frame_sink_state) != 0) {
                target.appendInt32(ChromeCompositorStateMachine.MajorStateWire.LAYER_TREE_FRAME_SINK_STATE_WIRE, @intFromEnum(self.layer_tree_frame_sink_state));
            }
            if (@intFromEnum(self.forced_redraw_state) != 0) {
                target.appendInt32(ChromeCompositorStateMachine.MajorStateWire.FORCED_REDRAW_STATE_WIRE, @intFromEnum(self.forced_redraw_state));
            }
        }
    };
    pub const MajorStateReader = struct {
        buf: gremlin.Reader,
        _next_action: ChromeCompositorSchedulerAction = @enumFromInt(0),
        _begin_impl_frame_state: ChromeCompositorStateMachine.MajorState.BeginImplFrameState = @enumFromInt(0),
        _begin_main_frame_state: ChromeCompositorStateMachine.MajorState.BeginMainFrameState = @enumFromInt(0),
        _layer_tree_frame_sink_state: ChromeCompositorStateMachine.MajorState.LayerTreeFrameSinkState = @enumFromInt(0),
        _forced_redraw_state: ChromeCompositorStateMachine.MajorState.ForcedRedrawOnTimeoutState = @enumFromInt(0),
        pub fn init(src: []const u8) gremlin.Error!ChromeCompositorStateMachine.MajorStateReader {
            const buf = gremlin.Reader.init(src);
            var res = ChromeCompositorStateMachine.MajorStateReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    ChromeCompositorStateMachine.MajorStateWire.NEXT_ACTION_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._next_action = @enumFromInt(result.value);
                    },
                    ChromeCompositorStateMachine.MajorStateWire.BEGIN_IMPL_FRAME_STATE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._begin_impl_frame_state = @enumFromInt(result.value);
                    },
                    ChromeCompositorStateMachine.MajorStateWire.BEGIN_MAIN_FRAME_STATE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._begin_main_frame_state = @enumFromInt(result.value);
                    },
                    ChromeCompositorStateMachine.MajorStateWire.LAYER_TREE_FRAME_SINK_STATE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._layer_tree_frame_sink_state = @enumFromInt(result.value);
                    },
                    ChromeCompositorStateMachine.MajorStateWire.FORCED_REDRAW_STATE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._forced_redraw_state = @enumFromInt(result.value);
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getNextAction(self: *const ChromeCompositorStateMachine.MajorStateReader) ChromeCompositorSchedulerAction {
            return self._next_action;
        }
        pub inline fn getBeginImplFrameState(self: *const ChromeCompositorStateMachine.MajorStateReader) ChromeCompositorStateMachine.MajorState.BeginImplFrameState {
            return self._begin_impl_frame_state;
        }
        pub inline fn getBeginMainFrameState(self: *const ChromeCompositorStateMachine.MajorStateReader) ChromeCompositorStateMachine.MajorState.BeginMainFrameState {
            return self._begin_main_frame_state;
        }
        pub inline fn getLayerTreeFrameSinkState(self: *const ChromeCompositorStateMachine.MajorStateReader) ChromeCompositorStateMachine.MajorState.LayerTreeFrameSinkState {
            return self._layer_tree_frame_sink_state;
        }
        pub inline fn getForcedRedrawState(self: *const ChromeCompositorStateMachine.MajorStateReader) ChromeCompositorStateMachine.MajorState.ForcedRedrawOnTimeoutState {
            return self._forced_redraw_state;
        }
    };
    const MinorStateWire = struct {
        const COMMIT_COUNT_WIRE: gremlin.ProtoWireNumber = 1;
        const CURRENT_FRAME_NUMBER_WIRE: gremlin.ProtoWireNumber = 2;
        const LAST_FRAME_NUMBER_SUBMIT_PERFORMED_WIRE: gremlin.ProtoWireNumber = 3;
        const LAST_FRAME_NUMBER_DRAW_PERFORMED_WIRE: gremlin.ProtoWireNumber = 4;
        const LAST_FRAME_NUMBER_BEGIN_MAIN_FRAME_SENT_WIRE: gremlin.ProtoWireNumber = 5;
        const DID_DRAW_WIRE: gremlin.ProtoWireNumber = 6;
        const DID_SEND_BEGIN_MAIN_FRAME_FOR_CURRENT_FRAME_WIRE: gremlin.ProtoWireNumber = 7;
        const DID_NOTIFY_BEGIN_MAIN_FRAME_NOT_EXPECTED_UNTIL_WIRE: gremlin.ProtoWireNumber = 8;
        const DID_NOTIFY_BEGIN_MAIN_FRAME_NOT_EXPECTED_SOON_WIRE: gremlin.ProtoWireNumber = 9;
        const WANTS_BEGIN_MAIN_FRAME_NOT_EXPECTED_WIRE: gremlin.ProtoWireNumber = 10;
        const DID_COMMIT_DURING_FRAME_WIRE: gremlin.ProtoWireNumber = 11;
        const DID_INVALIDATE_LAYER_TREE_FRAME_SINK_WIRE: gremlin.ProtoWireNumber = 12;
        const DID_PERFORM_IMPL_SIDE_INVALIDAION_WIRE: gremlin.ProtoWireNumber = 13;
        const DID_PREPARE_TILES_WIRE: gremlin.ProtoWireNumber = 14;
        const CONSECUTIVE_CHECKERBOARD_ANIMATIONS_WIRE: gremlin.ProtoWireNumber = 15;
        const PENDING_SUBMIT_FRAMES_WIRE: gremlin.ProtoWireNumber = 16;
        const SUBMIT_FRAMES_WITH_CURRENT_LAYER_TREE_FRAME_SINK_WIRE: gremlin.ProtoWireNumber = 17;
        const NEEDS_REDRAW_WIRE: gremlin.ProtoWireNumber = 18;
        const NEEDS_PREPARE_TILES_WIRE: gremlin.ProtoWireNumber = 19;
        const NEEDS_BEGIN_MAIN_FRAME_WIRE: gremlin.ProtoWireNumber = 20;
        const NEEDS_ONE_BEGIN_IMPL_FRAME_WIRE: gremlin.ProtoWireNumber = 21;
        const VISIBLE_WIRE: gremlin.ProtoWireNumber = 22;
        const BEGIN_FRAME_SOURCE_PAUSED_WIRE: gremlin.ProtoWireNumber = 23;
        const CAN_DRAW_WIRE: gremlin.ProtoWireNumber = 24;
        const RESOURCELESS_DRAW_WIRE: gremlin.ProtoWireNumber = 25;
        const HAS_PENDING_TREE_WIRE: gremlin.ProtoWireNumber = 26;
        const PENDING_TREE_IS_READY_FOR_ACTIVATION_WIRE: gremlin.ProtoWireNumber = 27;
        const ACTIVE_TREE_NEEDS_FIRST_DRAW_WIRE: gremlin.ProtoWireNumber = 28;
        const ACTIVE_TREE_IS_READY_TO_DRAW_WIRE: gremlin.ProtoWireNumber = 29;
        const DID_CREATE_AND_INITIALIZE_FIRST_LAYER_TREE_FRAME_SINK_WIRE: gremlin.ProtoWireNumber = 30;
        const TREE_PRIORITY_WIRE: gremlin.ProtoWireNumber = 31;
        const SCROLL_HANDLER_STATE_WIRE: gremlin.ProtoWireNumber = 32;
        const CRITICAL_BEGIN_MAIN_FRAME_TO_ACTIVATE_IS_FAST_WIRE: gremlin.ProtoWireNumber = 33;
        const MAIN_THREAD_MISSED_LAST_DEADLINE_WIRE: gremlin.ProtoWireNumber = 34;
        const VIDEO_NEEDS_BEGIN_FRAMES_WIRE: gremlin.ProtoWireNumber = 36;
        const DEFER_BEGIN_MAIN_FRAME_WIRE: gremlin.ProtoWireNumber = 37;
        const LAST_COMMIT_HAD_NO_UPDATES_WIRE: gremlin.ProtoWireNumber = 38;
        const DID_DRAW_IN_LAST_FRAME_WIRE: gremlin.ProtoWireNumber = 39;
        const DID_SUBMIT_IN_LAST_FRAME_WIRE: gremlin.ProtoWireNumber = 40;
        const NEEDS_IMPL_SIDE_INVALIDATION_WIRE: gremlin.ProtoWireNumber = 41;
        const CURRENT_PENDING_TREE_IS_IMPL_SIDE_WIRE: gremlin.ProtoWireNumber = 42;
        const PREVIOUS_PENDING_TREE_WAS_IMPL_SIDE_WIRE: gremlin.ProtoWireNumber = 43;
        const PROCESSING_ANIMATION_WORKLETS_FOR_ACTIVE_TREE_WIRE: gremlin.ProtoWireNumber = 44;
        const PROCESSING_ANIMATION_WORKLETS_FOR_PENDING_TREE_WIRE: gremlin.ProtoWireNumber = 45;
        const PROCESSING_PAINT_WORKLETS_FOR_PENDING_TREE_WIRE: gremlin.ProtoWireNumber = 46;
    };
    pub const MinorState = struct {
        // nested enums
        pub const TreePriority = enum(i32) {
            TREE_PRIORITY_UNSPECIFIED = 0,
            TREE_PRIORITY_SAME_PRIORITY_FOR_BOTH_TREES = 1,
            TREE_PRIORITY_SMOOTHNESS_TAKES_PRIORITY = 2,
            TREE_PRIORITY_NEW_CONTENT_TAKES_PRIORITY = 3,
        };
        pub const ScrollHandlerState = enum(i32) {
            SCROLL_HANDLER_UNSPECIFIED = 0,
            SCROLL_AFFECTS_SCROLL_HANDLER = 1,
            SCROLL_DOES_NOT_AFFECT_SCROLL_HANDLER = 2,
        };
        // fields
        commit_count: i32 = 0,
        current_frame_number: i32 = 0,
        last_frame_number_submit_performed: i32 = 0,
        last_frame_number_draw_performed: i32 = 0,
        last_frame_number_begin_main_frame_sent: i32 = 0,
        did_draw: bool = false,
        did_send_begin_main_frame_for_current_frame: bool = false,
        did_notify_begin_main_frame_not_expected_until: bool = false,
        did_notify_begin_main_frame_not_expected_soon: bool = false,
        wants_begin_main_frame_not_expected: bool = false,
        did_commit_during_frame: bool = false,
        did_invalidate_layer_tree_frame_sink: bool = false,
        did_perform_impl_side_invalidaion: bool = false,
        did_prepare_tiles: bool = false,
        consecutive_checkerboard_animations: i32 = 0,
        pending_submit_frames: i32 = 0,
        submit_frames_with_current_layer_tree_frame_sink: i32 = 0,
        needs_redraw: bool = false,
        needs_prepare_tiles: bool = false,
        needs_begin_main_frame: bool = false,
        needs_one_begin_impl_frame: bool = false,
        visible: bool = false,
        begin_frame_source_paused: bool = false,
        can_draw: bool = false,
        resourceless_draw: bool = false,
        has_pending_tree: bool = false,
        pending_tree_is_ready_for_activation: bool = false,
        active_tree_needs_first_draw: bool = false,
        active_tree_is_ready_to_draw: bool = false,
        did_create_and_initialize_first_layer_tree_frame_sink: bool = false,
        tree_priority: ChromeCompositorStateMachine.MinorState.TreePriority = @enumFromInt(0),
        scroll_handler_state: ChromeCompositorStateMachine.MinorState.ScrollHandlerState = @enumFromInt(0),
        critical_begin_main_frame_to_activate_is_fast: bool = false,
        main_thread_missed_last_deadline: bool = false,
        video_needs_begin_frames: bool = false,
        defer_begin_main_frame: bool = false,
        last_commit_had_no_updates: bool = false,
        did_draw_in_last_frame: bool = false,
        did_submit_in_last_frame: bool = false,
        needs_impl_side_invalidation: bool = false,
        current_pending_tree_is_impl_side: bool = false,
        previous_pending_tree_was_impl_side: bool = false,
        processing_animation_worklets_for_active_tree: bool = false,
        processing_animation_worklets_for_pending_tree: bool = false,
        processing_paint_worklets_for_pending_tree: bool = false,
        pub fn calcProtobufSize(self: *const ChromeCompositorStateMachine.MinorState) usize {
            var res: usize = 0;
            if (self.commit_count != 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.COMMIT_COUNT_WIRE) + gremlin.sizes.sizeI32(self.commit_count);
            }
            if (self.current_frame_number != 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.CURRENT_FRAME_NUMBER_WIRE) + gremlin.sizes.sizeI32(self.current_frame_number);
            }
            if (self.last_frame_number_submit_performed != 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.LAST_FRAME_NUMBER_SUBMIT_PERFORMED_WIRE) + gremlin.sizes.sizeI32(self.last_frame_number_submit_performed);
            }
            if (self.last_frame_number_draw_performed != 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.LAST_FRAME_NUMBER_DRAW_PERFORMED_WIRE) + gremlin.sizes.sizeI32(self.last_frame_number_draw_performed);
            }
            if (self.last_frame_number_begin_main_frame_sent != 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.LAST_FRAME_NUMBER_BEGIN_MAIN_FRAME_SENT_WIRE) + gremlin.sizes.sizeI32(self.last_frame_number_begin_main_frame_sent);
            }
            if (self.did_draw != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.DID_DRAW_WIRE) + gremlin.sizes.sizeBool(self.did_draw);
            }
            if (self.did_send_begin_main_frame_for_current_frame != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.DID_SEND_BEGIN_MAIN_FRAME_FOR_CURRENT_FRAME_WIRE) + gremlin.sizes.sizeBool(self.did_send_begin_main_frame_for_current_frame);
            }
            if (self.did_notify_begin_main_frame_not_expected_until != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.DID_NOTIFY_BEGIN_MAIN_FRAME_NOT_EXPECTED_UNTIL_WIRE) + gremlin.sizes.sizeBool(self.did_notify_begin_main_frame_not_expected_until);
            }
            if (self.did_notify_begin_main_frame_not_expected_soon != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.DID_NOTIFY_BEGIN_MAIN_FRAME_NOT_EXPECTED_SOON_WIRE) + gremlin.sizes.sizeBool(self.did_notify_begin_main_frame_not_expected_soon);
            }
            if (self.wants_begin_main_frame_not_expected != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.WANTS_BEGIN_MAIN_FRAME_NOT_EXPECTED_WIRE) + gremlin.sizes.sizeBool(self.wants_begin_main_frame_not_expected);
            }
            if (self.did_commit_during_frame != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.DID_COMMIT_DURING_FRAME_WIRE) + gremlin.sizes.sizeBool(self.did_commit_during_frame);
            }
            if (self.did_invalidate_layer_tree_frame_sink != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.DID_INVALIDATE_LAYER_TREE_FRAME_SINK_WIRE) + gremlin.sizes.sizeBool(self.did_invalidate_layer_tree_frame_sink);
            }
            if (self.did_perform_impl_side_invalidaion != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.DID_PERFORM_IMPL_SIDE_INVALIDAION_WIRE) + gremlin.sizes.sizeBool(self.did_perform_impl_side_invalidaion);
            }
            if (self.did_prepare_tiles != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.DID_PREPARE_TILES_WIRE) + gremlin.sizes.sizeBool(self.did_prepare_tiles);
            }
            if (self.consecutive_checkerboard_animations != 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.CONSECUTIVE_CHECKERBOARD_ANIMATIONS_WIRE) + gremlin.sizes.sizeI32(self.consecutive_checkerboard_animations);
            }
            if (self.pending_submit_frames != 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.PENDING_SUBMIT_FRAMES_WIRE) + gremlin.sizes.sizeI32(self.pending_submit_frames);
            }
            if (self.submit_frames_with_current_layer_tree_frame_sink != 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.SUBMIT_FRAMES_WITH_CURRENT_LAYER_TREE_FRAME_SINK_WIRE) + gremlin.sizes.sizeI32(self.submit_frames_with_current_layer_tree_frame_sink);
            }
            if (self.needs_redraw != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.NEEDS_REDRAW_WIRE) + gremlin.sizes.sizeBool(self.needs_redraw);
            }
            if (self.needs_prepare_tiles != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.NEEDS_PREPARE_TILES_WIRE) + gremlin.sizes.sizeBool(self.needs_prepare_tiles);
            }
            if (self.needs_begin_main_frame != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.NEEDS_BEGIN_MAIN_FRAME_WIRE) + gremlin.sizes.sizeBool(self.needs_begin_main_frame);
            }
            if (self.needs_one_begin_impl_frame != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.NEEDS_ONE_BEGIN_IMPL_FRAME_WIRE) + gremlin.sizes.sizeBool(self.needs_one_begin_impl_frame);
            }
            if (self.visible != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.VISIBLE_WIRE) + gremlin.sizes.sizeBool(self.visible);
            }
            if (self.begin_frame_source_paused != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.BEGIN_FRAME_SOURCE_PAUSED_WIRE) + gremlin.sizes.sizeBool(self.begin_frame_source_paused);
            }
            if (self.can_draw != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.CAN_DRAW_WIRE) + gremlin.sizes.sizeBool(self.can_draw);
            }
            if (self.resourceless_draw != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.RESOURCELESS_DRAW_WIRE) + gremlin.sizes.sizeBool(self.resourceless_draw);
            }
            if (self.has_pending_tree != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.HAS_PENDING_TREE_WIRE) + gremlin.sizes.sizeBool(self.has_pending_tree);
            }
            if (self.pending_tree_is_ready_for_activation != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.PENDING_TREE_IS_READY_FOR_ACTIVATION_WIRE) + gremlin.sizes.sizeBool(self.pending_tree_is_ready_for_activation);
            }
            if (self.active_tree_needs_first_draw != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.ACTIVE_TREE_NEEDS_FIRST_DRAW_WIRE) + gremlin.sizes.sizeBool(self.active_tree_needs_first_draw);
            }
            if (self.active_tree_is_ready_to_draw != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.ACTIVE_TREE_IS_READY_TO_DRAW_WIRE) + gremlin.sizes.sizeBool(self.active_tree_is_ready_to_draw);
            }
            if (self.did_create_and_initialize_first_layer_tree_frame_sink != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.DID_CREATE_AND_INITIALIZE_FIRST_LAYER_TREE_FRAME_SINK_WIRE) + gremlin.sizes.sizeBool(self.did_create_and_initialize_first_layer_tree_frame_sink);
            }
            if (@intFromEnum(self.tree_priority) != 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.TREE_PRIORITY_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.tree_priority));
            }
            if (@intFromEnum(self.scroll_handler_state) != 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.SCROLL_HANDLER_STATE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.scroll_handler_state));
            }
            if (self.critical_begin_main_frame_to_activate_is_fast != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.CRITICAL_BEGIN_MAIN_FRAME_TO_ACTIVATE_IS_FAST_WIRE) + gremlin.sizes.sizeBool(self.critical_begin_main_frame_to_activate_is_fast);
            }
            if (self.main_thread_missed_last_deadline != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.MAIN_THREAD_MISSED_LAST_DEADLINE_WIRE) + gremlin.sizes.sizeBool(self.main_thread_missed_last_deadline);
            }
            if (self.video_needs_begin_frames != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.VIDEO_NEEDS_BEGIN_FRAMES_WIRE) + gremlin.sizes.sizeBool(self.video_needs_begin_frames);
            }
            if (self.defer_begin_main_frame != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.DEFER_BEGIN_MAIN_FRAME_WIRE) + gremlin.sizes.sizeBool(self.defer_begin_main_frame);
            }
            if (self.last_commit_had_no_updates != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.LAST_COMMIT_HAD_NO_UPDATES_WIRE) + gremlin.sizes.sizeBool(self.last_commit_had_no_updates);
            }
            if (self.did_draw_in_last_frame != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.DID_DRAW_IN_LAST_FRAME_WIRE) + gremlin.sizes.sizeBool(self.did_draw_in_last_frame);
            }
            if (self.did_submit_in_last_frame != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.DID_SUBMIT_IN_LAST_FRAME_WIRE) + gremlin.sizes.sizeBool(self.did_submit_in_last_frame);
            }
            if (self.needs_impl_side_invalidation != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.NEEDS_IMPL_SIDE_INVALIDATION_WIRE) + gremlin.sizes.sizeBool(self.needs_impl_side_invalidation);
            }
            if (self.current_pending_tree_is_impl_side != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.CURRENT_PENDING_TREE_IS_IMPL_SIDE_WIRE) + gremlin.sizes.sizeBool(self.current_pending_tree_is_impl_side);
            }
            if (self.previous_pending_tree_was_impl_side != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.PREVIOUS_PENDING_TREE_WAS_IMPL_SIDE_WIRE) + gremlin.sizes.sizeBool(self.previous_pending_tree_was_impl_side);
            }
            if (self.processing_animation_worklets_for_active_tree != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.PROCESSING_ANIMATION_WORKLETS_FOR_ACTIVE_TREE_WIRE) + gremlin.sizes.sizeBool(self.processing_animation_worklets_for_active_tree);
            }
            if (self.processing_animation_worklets_for_pending_tree != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.PROCESSING_ANIMATION_WORKLETS_FOR_PENDING_TREE_WIRE) + gremlin.sizes.sizeBool(self.processing_animation_worklets_for_pending_tree);
            }
            if (self.processing_paint_worklets_for_pending_tree != false) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachine.MinorStateWire.PROCESSING_PAINT_WORKLETS_FOR_PENDING_TREE_WIRE) + gremlin.sizes.sizeBool(self.processing_paint_worklets_for_pending_tree);
            }
            return res;
        }
        pub fn encode(self: *const ChromeCompositorStateMachine.MinorState, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const ChromeCompositorStateMachine.MinorState, target: *gremlin.Writer) void {
            if (self.commit_count != 0) {
                target.appendInt32(ChromeCompositorStateMachine.MinorStateWire.COMMIT_COUNT_WIRE, self.commit_count);
            }
            if (self.current_frame_number != 0) {
                target.appendInt32(ChromeCompositorStateMachine.MinorStateWire.CURRENT_FRAME_NUMBER_WIRE, self.current_frame_number);
            }
            if (self.last_frame_number_submit_performed != 0) {
                target.appendInt32(ChromeCompositorStateMachine.MinorStateWire.LAST_FRAME_NUMBER_SUBMIT_PERFORMED_WIRE, self.last_frame_number_submit_performed);
            }
            if (self.last_frame_number_draw_performed != 0) {
                target.appendInt32(ChromeCompositorStateMachine.MinorStateWire.LAST_FRAME_NUMBER_DRAW_PERFORMED_WIRE, self.last_frame_number_draw_performed);
            }
            if (self.last_frame_number_begin_main_frame_sent != 0) {
                target.appendInt32(ChromeCompositorStateMachine.MinorStateWire.LAST_FRAME_NUMBER_BEGIN_MAIN_FRAME_SENT_WIRE, self.last_frame_number_begin_main_frame_sent);
            }
            if (self.did_draw != false) {
                target.appendBool(ChromeCompositorStateMachine.MinorStateWire.DID_DRAW_WIRE, self.did_draw);
            }
            if (self.did_send_begin_main_frame_for_current_frame != false) {
                target.appendBool(ChromeCompositorStateMachine.MinorStateWire.DID_SEND_BEGIN_MAIN_FRAME_FOR_CURRENT_FRAME_WIRE, self.did_send_begin_main_frame_for_current_frame);
            }
            if (self.did_notify_begin_main_frame_not_expected_until != false) {
                target.appendBool(ChromeCompositorStateMachine.MinorStateWire.DID_NOTIFY_BEGIN_MAIN_FRAME_NOT_EXPECTED_UNTIL_WIRE, self.did_notify_begin_main_frame_not_expected_until);
            }
            if (self.did_notify_begin_main_frame_not_expected_soon != false) {
                target.appendBool(ChromeCompositorStateMachine.MinorStateWire.DID_NOTIFY_BEGIN_MAIN_FRAME_NOT_EXPECTED_SOON_WIRE, self.did_notify_begin_main_frame_not_expected_soon);
            }
            if (self.wants_begin_main_frame_not_expected != false) {
                target.appendBool(ChromeCompositorStateMachine.MinorStateWire.WANTS_BEGIN_MAIN_FRAME_NOT_EXPECTED_WIRE, self.wants_begin_main_frame_not_expected);
            }
            if (self.did_commit_during_frame != false) {
                target.appendBool(ChromeCompositorStateMachine.MinorStateWire.DID_COMMIT_DURING_FRAME_WIRE, self.did_commit_during_frame);
            }
            if (self.did_invalidate_layer_tree_frame_sink != false) {
                target.appendBool(ChromeCompositorStateMachine.MinorStateWire.DID_INVALIDATE_LAYER_TREE_FRAME_SINK_WIRE, self.did_invalidate_layer_tree_frame_sink);
            }
            if (self.did_perform_impl_side_invalidaion != false) {
                target.appendBool(ChromeCompositorStateMachine.MinorStateWire.DID_PERFORM_IMPL_SIDE_INVALIDAION_WIRE, self.did_perform_impl_side_invalidaion);
            }
            if (self.did_prepare_tiles != false) {
                target.appendBool(ChromeCompositorStateMachine.MinorStateWire.DID_PREPARE_TILES_WIRE, self.did_prepare_tiles);
            }
            if (self.consecutive_checkerboard_animations != 0) {
                target.appendInt32(ChromeCompositorStateMachine.MinorStateWire.CONSECUTIVE_CHECKERBOARD_ANIMATIONS_WIRE, self.consecutive_checkerboard_animations);
            }
            if (self.pending_submit_frames != 0) {
                target.appendInt32(ChromeCompositorStateMachine.MinorStateWire.PENDING_SUBMIT_FRAMES_WIRE, self.pending_submit_frames);
            }
            if (self.submit_frames_with_current_layer_tree_frame_sink != 0) {
                target.appendInt32(ChromeCompositorStateMachine.MinorStateWire.SUBMIT_FRAMES_WITH_CURRENT_LAYER_TREE_FRAME_SINK_WIRE, self.submit_frames_with_current_layer_tree_frame_sink);
            }
            if (self.needs_redraw != false) {
                target.appendBool(ChromeCompositorStateMachine.MinorStateWire.NEEDS_REDRAW_WIRE, self.needs_redraw);
            }
            if (self.needs_prepare_tiles != false) {
                target.appendBool(ChromeCompositorStateMachine.MinorStateWire.NEEDS_PREPARE_TILES_WIRE, self.needs_prepare_tiles);
            }
            if (self.needs_begin_main_frame != false) {
                target.appendBool(ChromeCompositorStateMachine.MinorStateWire.NEEDS_BEGIN_MAIN_FRAME_WIRE, self.needs_begin_main_frame);
            }
            if (self.needs_one_begin_impl_frame != false) {
                target.appendBool(ChromeCompositorStateMachine.MinorStateWire.NEEDS_ONE_BEGIN_IMPL_FRAME_WIRE, self.needs_one_begin_impl_frame);
            }
            if (self.visible != false) {
                target.appendBool(ChromeCompositorStateMachine.MinorStateWire.VISIBLE_WIRE, self.visible);
            }
            if (self.begin_frame_source_paused != false) {
                target.appendBool(ChromeCompositorStateMachine.MinorStateWire.BEGIN_FRAME_SOURCE_PAUSED_WIRE, self.begin_frame_source_paused);
            }
            if (self.can_draw != false) {
                target.appendBool(ChromeCompositorStateMachine.MinorStateWire.CAN_DRAW_WIRE, self.can_draw);
            }
            if (self.resourceless_draw != false) {
                target.appendBool(ChromeCompositorStateMachine.MinorStateWire.RESOURCELESS_DRAW_WIRE, self.resourceless_draw);
            }
            if (self.has_pending_tree != false) {
                target.appendBool(ChromeCompositorStateMachine.MinorStateWire.HAS_PENDING_TREE_WIRE, self.has_pending_tree);
            }
            if (self.pending_tree_is_ready_for_activation != false) {
                target.appendBool(ChromeCompositorStateMachine.MinorStateWire.PENDING_TREE_IS_READY_FOR_ACTIVATION_WIRE, self.pending_tree_is_ready_for_activation);
            }
            if (self.active_tree_needs_first_draw != false) {
                target.appendBool(ChromeCompositorStateMachine.MinorStateWire.ACTIVE_TREE_NEEDS_FIRST_DRAW_WIRE, self.active_tree_needs_first_draw);
            }
            if (self.active_tree_is_ready_to_draw != false) {
                target.appendBool(ChromeCompositorStateMachine.MinorStateWire.ACTIVE_TREE_IS_READY_TO_DRAW_WIRE, self.active_tree_is_ready_to_draw);
            }
            if (self.did_create_and_initialize_first_layer_tree_frame_sink != false) {
                target.appendBool(ChromeCompositorStateMachine.MinorStateWire.DID_CREATE_AND_INITIALIZE_FIRST_LAYER_TREE_FRAME_SINK_WIRE, self.did_create_and_initialize_first_layer_tree_frame_sink);
            }
            if (@intFromEnum(self.tree_priority) != 0) {
                target.appendInt32(ChromeCompositorStateMachine.MinorStateWire.TREE_PRIORITY_WIRE, @intFromEnum(self.tree_priority));
            }
            if (@intFromEnum(self.scroll_handler_state) != 0) {
                target.appendInt32(ChromeCompositorStateMachine.MinorStateWire.SCROLL_HANDLER_STATE_WIRE, @intFromEnum(self.scroll_handler_state));
            }
            if (self.critical_begin_main_frame_to_activate_is_fast != false) {
                target.appendBool(ChromeCompositorStateMachine.MinorStateWire.CRITICAL_BEGIN_MAIN_FRAME_TO_ACTIVATE_IS_FAST_WIRE, self.critical_begin_main_frame_to_activate_is_fast);
            }
            if (self.main_thread_missed_last_deadline != false) {
                target.appendBool(ChromeCompositorStateMachine.MinorStateWire.MAIN_THREAD_MISSED_LAST_DEADLINE_WIRE, self.main_thread_missed_last_deadline);
            }
            if (self.video_needs_begin_frames != false) {
                target.appendBool(ChromeCompositorStateMachine.MinorStateWire.VIDEO_NEEDS_BEGIN_FRAMES_WIRE, self.video_needs_begin_frames);
            }
            if (self.defer_begin_main_frame != false) {
                target.appendBool(ChromeCompositorStateMachine.MinorStateWire.DEFER_BEGIN_MAIN_FRAME_WIRE, self.defer_begin_main_frame);
            }
            if (self.last_commit_had_no_updates != false) {
                target.appendBool(ChromeCompositorStateMachine.MinorStateWire.LAST_COMMIT_HAD_NO_UPDATES_WIRE, self.last_commit_had_no_updates);
            }
            if (self.did_draw_in_last_frame != false) {
                target.appendBool(ChromeCompositorStateMachine.MinorStateWire.DID_DRAW_IN_LAST_FRAME_WIRE, self.did_draw_in_last_frame);
            }
            if (self.did_submit_in_last_frame != false) {
                target.appendBool(ChromeCompositorStateMachine.MinorStateWire.DID_SUBMIT_IN_LAST_FRAME_WIRE, self.did_submit_in_last_frame);
            }
            if (self.needs_impl_side_invalidation != false) {
                target.appendBool(ChromeCompositorStateMachine.MinorStateWire.NEEDS_IMPL_SIDE_INVALIDATION_WIRE, self.needs_impl_side_invalidation);
            }
            if (self.current_pending_tree_is_impl_side != false) {
                target.appendBool(ChromeCompositorStateMachine.MinorStateWire.CURRENT_PENDING_TREE_IS_IMPL_SIDE_WIRE, self.current_pending_tree_is_impl_side);
            }
            if (self.previous_pending_tree_was_impl_side != false) {
                target.appendBool(ChromeCompositorStateMachine.MinorStateWire.PREVIOUS_PENDING_TREE_WAS_IMPL_SIDE_WIRE, self.previous_pending_tree_was_impl_side);
            }
            if (self.processing_animation_worklets_for_active_tree != false) {
                target.appendBool(ChromeCompositorStateMachine.MinorStateWire.PROCESSING_ANIMATION_WORKLETS_FOR_ACTIVE_TREE_WIRE, self.processing_animation_worklets_for_active_tree);
            }
            if (self.processing_animation_worklets_for_pending_tree != false) {
                target.appendBool(ChromeCompositorStateMachine.MinorStateWire.PROCESSING_ANIMATION_WORKLETS_FOR_PENDING_TREE_WIRE, self.processing_animation_worklets_for_pending_tree);
            }
            if (self.processing_paint_worklets_for_pending_tree != false) {
                target.appendBool(ChromeCompositorStateMachine.MinorStateWire.PROCESSING_PAINT_WORKLETS_FOR_PENDING_TREE_WIRE, self.processing_paint_worklets_for_pending_tree);
            }
        }
    };
    pub const MinorStateReader = struct {
        buf: gremlin.Reader,
        _commit_count: i32 = 0,
        _current_frame_number: i32 = 0,
        _last_frame_number_submit_performed: i32 = 0,
        _last_frame_number_draw_performed: i32 = 0,
        _last_frame_number_begin_main_frame_sent: i32 = 0,
        _did_draw: bool = false,
        _did_send_begin_main_frame_for_current_frame: bool = false,
        _did_notify_begin_main_frame_not_expected_until: bool = false,
        _did_notify_begin_main_frame_not_expected_soon: bool = false,
        _wants_begin_main_frame_not_expected: bool = false,
        _did_commit_during_frame: bool = false,
        _did_invalidate_layer_tree_frame_sink: bool = false,
        _did_perform_impl_side_invalidaion: bool = false,
        _did_prepare_tiles: bool = false,
        _consecutive_checkerboard_animations: i32 = 0,
        _pending_submit_frames: i32 = 0,
        _submit_frames_with_current_layer_tree_frame_sink: i32 = 0,
        _needs_redraw: bool = false,
        _needs_prepare_tiles: bool = false,
        _needs_begin_main_frame: bool = false,
        _needs_one_begin_impl_frame: bool = false,
        _visible: bool = false,
        _begin_frame_source_paused: bool = false,
        _can_draw: bool = false,
        _resourceless_draw: bool = false,
        _has_pending_tree: bool = false,
        _pending_tree_is_ready_for_activation: bool = false,
        _active_tree_needs_first_draw: bool = false,
        _active_tree_is_ready_to_draw: bool = false,
        _did_create_and_initialize_first_layer_tree_frame_sink: bool = false,
        _tree_priority: ChromeCompositorStateMachine.MinorState.TreePriority = @enumFromInt(0),
        _scroll_handler_state: ChromeCompositorStateMachine.MinorState.ScrollHandlerState = @enumFromInt(0),
        _critical_begin_main_frame_to_activate_is_fast: bool = false,
        _main_thread_missed_last_deadline: bool = false,
        _video_needs_begin_frames: bool = false,
        _defer_begin_main_frame: bool = false,
        _last_commit_had_no_updates: bool = false,
        _did_draw_in_last_frame: bool = false,
        _did_submit_in_last_frame: bool = false,
        _needs_impl_side_invalidation: bool = false,
        _current_pending_tree_is_impl_side: bool = false,
        _previous_pending_tree_was_impl_side: bool = false,
        _processing_animation_worklets_for_active_tree: bool = false,
        _processing_animation_worklets_for_pending_tree: bool = false,
        _processing_paint_worklets_for_pending_tree: bool = false,
        pub fn init(src: []const u8) gremlin.Error!ChromeCompositorStateMachine.MinorStateReader {
            const buf = gremlin.Reader.init(src);
            var res = ChromeCompositorStateMachine.MinorStateReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    ChromeCompositorStateMachine.MinorStateWire.COMMIT_COUNT_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._commit_count = result.value;
                    },
                    ChromeCompositorStateMachine.MinorStateWire.CURRENT_FRAME_NUMBER_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._current_frame_number = result.value;
                    },
                    ChromeCompositorStateMachine.MinorStateWire.LAST_FRAME_NUMBER_SUBMIT_PERFORMED_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._last_frame_number_submit_performed = result.value;
                    },
                    ChromeCompositorStateMachine.MinorStateWire.LAST_FRAME_NUMBER_DRAW_PERFORMED_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._last_frame_number_draw_performed = result.value;
                    },
                    ChromeCompositorStateMachine.MinorStateWire.LAST_FRAME_NUMBER_BEGIN_MAIN_FRAME_SENT_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._last_frame_number_begin_main_frame_sent = result.value;
                    },
                    ChromeCompositorStateMachine.MinorStateWire.DID_DRAW_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._did_draw = result.value;
                    },
                    ChromeCompositorStateMachine.MinorStateWire.DID_SEND_BEGIN_MAIN_FRAME_FOR_CURRENT_FRAME_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._did_send_begin_main_frame_for_current_frame = result.value;
                    },
                    ChromeCompositorStateMachine.MinorStateWire.DID_NOTIFY_BEGIN_MAIN_FRAME_NOT_EXPECTED_UNTIL_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._did_notify_begin_main_frame_not_expected_until = result.value;
                    },
                    ChromeCompositorStateMachine.MinorStateWire.DID_NOTIFY_BEGIN_MAIN_FRAME_NOT_EXPECTED_SOON_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._did_notify_begin_main_frame_not_expected_soon = result.value;
                    },
                    ChromeCompositorStateMachine.MinorStateWire.WANTS_BEGIN_MAIN_FRAME_NOT_EXPECTED_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._wants_begin_main_frame_not_expected = result.value;
                    },
                    ChromeCompositorStateMachine.MinorStateWire.DID_COMMIT_DURING_FRAME_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._did_commit_during_frame = result.value;
                    },
                    ChromeCompositorStateMachine.MinorStateWire.DID_INVALIDATE_LAYER_TREE_FRAME_SINK_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._did_invalidate_layer_tree_frame_sink = result.value;
                    },
                    ChromeCompositorStateMachine.MinorStateWire.DID_PERFORM_IMPL_SIDE_INVALIDAION_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._did_perform_impl_side_invalidaion = result.value;
                    },
                    ChromeCompositorStateMachine.MinorStateWire.DID_PREPARE_TILES_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._did_prepare_tiles = result.value;
                    },
                    ChromeCompositorStateMachine.MinorStateWire.CONSECUTIVE_CHECKERBOARD_ANIMATIONS_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._consecutive_checkerboard_animations = result.value;
                    },
                    ChromeCompositorStateMachine.MinorStateWire.PENDING_SUBMIT_FRAMES_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._pending_submit_frames = result.value;
                    },
                    ChromeCompositorStateMachine.MinorStateWire.SUBMIT_FRAMES_WITH_CURRENT_LAYER_TREE_FRAME_SINK_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._submit_frames_with_current_layer_tree_frame_sink = result.value;
                    },
                    ChromeCompositorStateMachine.MinorStateWire.NEEDS_REDRAW_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._needs_redraw = result.value;
                    },
                    ChromeCompositorStateMachine.MinorStateWire.NEEDS_PREPARE_TILES_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._needs_prepare_tiles = result.value;
                    },
                    ChromeCompositorStateMachine.MinorStateWire.NEEDS_BEGIN_MAIN_FRAME_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._needs_begin_main_frame = result.value;
                    },
                    ChromeCompositorStateMachine.MinorStateWire.NEEDS_ONE_BEGIN_IMPL_FRAME_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._needs_one_begin_impl_frame = result.value;
                    },
                    ChromeCompositorStateMachine.MinorStateWire.VISIBLE_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._visible = result.value;
                    },
                    ChromeCompositorStateMachine.MinorStateWire.BEGIN_FRAME_SOURCE_PAUSED_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._begin_frame_source_paused = result.value;
                    },
                    ChromeCompositorStateMachine.MinorStateWire.CAN_DRAW_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._can_draw = result.value;
                    },
                    ChromeCompositorStateMachine.MinorStateWire.RESOURCELESS_DRAW_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._resourceless_draw = result.value;
                    },
                    ChromeCompositorStateMachine.MinorStateWire.HAS_PENDING_TREE_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._has_pending_tree = result.value;
                    },
                    ChromeCompositorStateMachine.MinorStateWire.PENDING_TREE_IS_READY_FOR_ACTIVATION_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._pending_tree_is_ready_for_activation = result.value;
                    },
                    ChromeCompositorStateMachine.MinorStateWire.ACTIVE_TREE_NEEDS_FIRST_DRAW_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._active_tree_needs_first_draw = result.value;
                    },
                    ChromeCompositorStateMachine.MinorStateWire.ACTIVE_TREE_IS_READY_TO_DRAW_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._active_tree_is_ready_to_draw = result.value;
                    },
                    ChromeCompositorStateMachine.MinorStateWire.DID_CREATE_AND_INITIALIZE_FIRST_LAYER_TREE_FRAME_SINK_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._did_create_and_initialize_first_layer_tree_frame_sink = result.value;
                    },
                    ChromeCompositorStateMachine.MinorStateWire.TREE_PRIORITY_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._tree_priority = @enumFromInt(result.value);
                    },
                    ChromeCompositorStateMachine.MinorStateWire.SCROLL_HANDLER_STATE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._scroll_handler_state = @enumFromInt(result.value);
                    },
                    ChromeCompositorStateMachine.MinorStateWire.CRITICAL_BEGIN_MAIN_FRAME_TO_ACTIVATE_IS_FAST_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._critical_begin_main_frame_to_activate_is_fast = result.value;
                    },
                    ChromeCompositorStateMachine.MinorStateWire.MAIN_THREAD_MISSED_LAST_DEADLINE_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._main_thread_missed_last_deadline = result.value;
                    },
                    ChromeCompositorStateMachine.MinorStateWire.VIDEO_NEEDS_BEGIN_FRAMES_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._video_needs_begin_frames = result.value;
                    },
                    ChromeCompositorStateMachine.MinorStateWire.DEFER_BEGIN_MAIN_FRAME_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._defer_begin_main_frame = result.value;
                    },
                    ChromeCompositorStateMachine.MinorStateWire.LAST_COMMIT_HAD_NO_UPDATES_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._last_commit_had_no_updates = result.value;
                    },
                    ChromeCompositorStateMachine.MinorStateWire.DID_DRAW_IN_LAST_FRAME_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._did_draw_in_last_frame = result.value;
                    },
                    ChromeCompositorStateMachine.MinorStateWire.DID_SUBMIT_IN_LAST_FRAME_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._did_submit_in_last_frame = result.value;
                    },
                    ChromeCompositorStateMachine.MinorStateWire.NEEDS_IMPL_SIDE_INVALIDATION_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._needs_impl_side_invalidation = result.value;
                    },
                    ChromeCompositorStateMachine.MinorStateWire.CURRENT_PENDING_TREE_IS_IMPL_SIDE_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._current_pending_tree_is_impl_side = result.value;
                    },
                    ChromeCompositorStateMachine.MinorStateWire.PREVIOUS_PENDING_TREE_WAS_IMPL_SIDE_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._previous_pending_tree_was_impl_side = result.value;
                    },
                    ChromeCompositorStateMachine.MinorStateWire.PROCESSING_ANIMATION_WORKLETS_FOR_ACTIVE_TREE_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._processing_animation_worklets_for_active_tree = result.value;
                    },
                    ChromeCompositorStateMachine.MinorStateWire.PROCESSING_ANIMATION_WORKLETS_FOR_PENDING_TREE_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._processing_animation_worklets_for_pending_tree = result.value;
                    },
                    ChromeCompositorStateMachine.MinorStateWire.PROCESSING_PAINT_WORKLETS_FOR_PENDING_TREE_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._processing_paint_worklets_for_pending_tree = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getCommitCount(self: *const ChromeCompositorStateMachine.MinorStateReader) i32 {
            return self._commit_count;
        }
        pub inline fn getCurrentFrameNumber(self: *const ChromeCompositorStateMachine.MinorStateReader) i32 {
            return self._current_frame_number;
        }
        pub inline fn getLastFrameNumberSubmitPerformed(self: *const ChromeCompositorStateMachine.MinorStateReader) i32 {
            return self._last_frame_number_submit_performed;
        }
        pub inline fn getLastFrameNumberDrawPerformed(self: *const ChromeCompositorStateMachine.MinorStateReader) i32 {
            return self._last_frame_number_draw_performed;
        }
        pub inline fn getLastFrameNumberBeginMainFrameSent(self: *const ChromeCompositorStateMachine.MinorStateReader) i32 {
            return self._last_frame_number_begin_main_frame_sent;
        }
        pub inline fn getDidDraw(self: *const ChromeCompositorStateMachine.MinorStateReader) bool {
            return self._did_draw;
        }
        pub inline fn getDidSendBeginMainFrameForCurrentFrame(self: *const ChromeCompositorStateMachine.MinorStateReader) bool {
            return self._did_send_begin_main_frame_for_current_frame;
        }
        pub inline fn getDidNotifyBeginMainFrameNotExpectedUntil(self: *const ChromeCompositorStateMachine.MinorStateReader) bool {
            return self._did_notify_begin_main_frame_not_expected_until;
        }
        pub inline fn getDidNotifyBeginMainFrameNotExpectedSoon(self: *const ChromeCompositorStateMachine.MinorStateReader) bool {
            return self._did_notify_begin_main_frame_not_expected_soon;
        }
        pub inline fn getWantsBeginMainFrameNotExpected(self: *const ChromeCompositorStateMachine.MinorStateReader) bool {
            return self._wants_begin_main_frame_not_expected;
        }
        pub inline fn getDidCommitDuringFrame(self: *const ChromeCompositorStateMachine.MinorStateReader) bool {
            return self._did_commit_during_frame;
        }
        pub inline fn getDidInvalidateLayerTreeFrameSink(self: *const ChromeCompositorStateMachine.MinorStateReader) bool {
            return self._did_invalidate_layer_tree_frame_sink;
        }
        pub inline fn getDidPerformImplSideInvalidaion(self: *const ChromeCompositorStateMachine.MinorStateReader) bool {
            return self._did_perform_impl_side_invalidaion;
        }
        pub inline fn getDidPrepareTiles(self: *const ChromeCompositorStateMachine.MinorStateReader) bool {
            return self._did_prepare_tiles;
        }
        pub inline fn getConsecutiveCheckerboardAnimations(self: *const ChromeCompositorStateMachine.MinorStateReader) i32 {
            return self._consecutive_checkerboard_animations;
        }
        pub inline fn getPendingSubmitFrames(self: *const ChromeCompositorStateMachine.MinorStateReader) i32 {
            return self._pending_submit_frames;
        }
        pub inline fn getSubmitFramesWithCurrentLayerTreeFrameSink(self: *const ChromeCompositorStateMachine.MinorStateReader) i32 {
            return self._submit_frames_with_current_layer_tree_frame_sink;
        }
        pub inline fn getNeedsRedraw(self: *const ChromeCompositorStateMachine.MinorStateReader) bool {
            return self._needs_redraw;
        }
        pub inline fn getNeedsPrepareTiles(self: *const ChromeCompositorStateMachine.MinorStateReader) bool {
            return self._needs_prepare_tiles;
        }
        pub inline fn getNeedsBeginMainFrame(self: *const ChromeCompositorStateMachine.MinorStateReader) bool {
            return self._needs_begin_main_frame;
        }
        pub inline fn getNeedsOneBeginImplFrame(self: *const ChromeCompositorStateMachine.MinorStateReader) bool {
            return self._needs_one_begin_impl_frame;
        }
        pub inline fn getVisible(self: *const ChromeCompositorStateMachine.MinorStateReader) bool {
            return self._visible;
        }
        pub inline fn getBeginFrameSourcePaused(self: *const ChromeCompositorStateMachine.MinorStateReader) bool {
            return self._begin_frame_source_paused;
        }
        pub inline fn getCanDraw(self: *const ChromeCompositorStateMachine.MinorStateReader) bool {
            return self._can_draw;
        }
        pub inline fn getResourcelessDraw(self: *const ChromeCompositorStateMachine.MinorStateReader) bool {
            return self._resourceless_draw;
        }
        pub inline fn getHasPendingTree(self: *const ChromeCompositorStateMachine.MinorStateReader) bool {
            return self._has_pending_tree;
        }
        pub inline fn getPendingTreeIsReadyForActivation(self: *const ChromeCompositorStateMachine.MinorStateReader) bool {
            return self._pending_tree_is_ready_for_activation;
        }
        pub inline fn getActiveTreeNeedsFirstDraw(self: *const ChromeCompositorStateMachine.MinorStateReader) bool {
            return self._active_tree_needs_first_draw;
        }
        pub inline fn getActiveTreeIsReadyToDraw(self: *const ChromeCompositorStateMachine.MinorStateReader) bool {
            return self._active_tree_is_ready_to_draw;
        }
        pub inline fn getDidCreateAndInitializeFirstLayerTreeFrameSink(self: *const ChromeCompositorStateMachine.MinorStateReader) bool {
            return self._did_create_and_initialize_first_layer_tree_frame_sink;
        }
        pub inline fn getTreePriority(self: *const ChromeCompositorStateMachine.MinorStateReader) ChromeCompositorStateMachine.MinorState.TreePriority {
            return self._tree_priority;
        }
        pub inline fn getScrollHandlerState(self: *const ChromeCompositorStateMachine.MinorStateReader) ChromeCompositorStateMachine.MinorState.ScrollHandlerState {
            return self._scroll_handler_state;
        }
        pub inline fn getCriticalBeginMainFrameToActivateIsFast(self: *const ChromeCompositorStateMachine.MinorStateReader) bool {
            return self._critical_begin_main_frame_to_activate_is_fast;
        }
        pub inline fn getMainThreadMissedLastDeadline(self: *const ChromeCompositorStateMachine.MinorStateReader) bool {
            return self._main_thread_missed_last_deadline;
        }
        pub inline fn getVideoNeedsBeginFrames(self: *const ChromeCompositorStateMachine.MinorStateReader) bool {
            return self._video_needs_begin_frames;
        }
        pub inline fn getDeferBeginMainFrame(self: *const ChromeCompositorStateMachine.MinorStateReader) bool {
            return self._defer_begin_main_frame;
        }
        pub inline fn getLastCommitHadNoUpdates(self: *const ChromeCompositorStateMachine.MinorStateReader) bool {
            return self._last_commit_had_no_updates;
        }
        pub inline fn getDidDrawInLastFrame(self: *const ChromeCompositorStateMachine.MinorStateReader) bool {
            return self._did_draw_in_last_frame;
        }
        pub inline fn getDidSubmitInLastFrame(self: *const ChromeCompositorStateMachine.MinorStateReader) bool {
            return self._did_submit_in_last_frame;
        }
        pub inline fn getNeedsImplSideInvalidation(self: *const ChromeCompositorStateMachine.MinorStateReader) bool {
            return self._needs_impl_side_invalidation;
        }
        pub inline fn getCurrentPendingTreeIsImplSide(self: *const ChromeCompositorStateMachine.MinorStateReader) bool {
            return self._current_pending_tree_is_impl_side;
        }
        pub inline fn getPreviousPendingTreeWasImplSide(self: *const ChromeCompositorStateMachine.MinorStateReader) bool {
            return self._previous_pending_tree_was_impl_side;
        }
        pub inline fn getProcessingAnimationWorkletsForActiveTree(self: *const ChromeCompositorStateMachine.MinorStateReader) bool {
            return self._processing_animation_worklets_for_active_tree;
        }
        pub inline fn getProcessingAnimationWorkletsForPendingTree(self: *const ChromeCompositorStateMachine.MinorStateReader) bool {
            return self._processing_animation_worklets_for_pending_tree;
        }
        pub inline fn getProcessingPaintWorkletsForPendingTree(self: *const ChromeCompositorStateMachine.MinorStateReader) bool {
            return self._processing_paint_worklets_for_pending_tree;
        }
    };
    // fields
    major_state: ?ChromeCompositorStateMachine.MajorState = null,
    minor_state: ?ChromeCompositorStateMachine.MinorState = null,
    pub fn calcProtobufSize(self: *const ChromeCompositorStateMachine) usize {
        var res: usize = 0;
        if (self.major_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineWire.MAJOR_STATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.minor_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeCompositorStateMachineWire.MINOR_STATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const ChromeCompositorStateMachine, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ChromeCompositorStateMachine, target: *gremlin.Writer) void {
        if (self.major_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeCompositorStateMachineWire.MAJOR_STATE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.minor_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChromeCompositorStateMachineWire.MINOR_STATE_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const ChromeCompositorStateMachineReader = struct {
    buf: gremlin.Reader,
    _major_state_buf: ?[]const u8 = null,
    _minor_state_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!ChromeCompositorStateMachineReader {
        const buf = gremlin.Reader.init(src);
        var res = ChromeCompositorStateMachineReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ChromeCompositorStateMachineWire.MAJOR_STATE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._major_state_buf = result.value;
                },
                ChromeCompositorStateMachineWire.MINOR_STATE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._minor_state_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getMajorState(self: *const ChromeCompositorStateMachineReader) gremlin.Error!ChromeCompositorStateMachine.MajorStateReader {
        if (self._major_state_buf) |buf| {
            return try ChromeCompositorStateMachine.MajorStateReader.init(buf);
        }
        return try ChromeCompositorStateMachine.MajorStateReader.init(&[_]u8{});
    }
    pub fn getMinorState(self: *const ChromeCompositorStateMachineReader) gremlin.Error!ChromeCompositorStateMachine.MinorStateReader {
        if (self._minor_state_buf) |buf| {
            return try ChromeCompositorStateMachine.MinorStateReader.init(buf);
        }
        return try ChromeCompositorStateMachine.MinorStateReader.init(&[_]u8{});
    }
};
const BeginFrameArgsWire = struct {
    const TYPE_WIRE: gremlin.ProtoWireNumber = 1;
    const SOURCE_ID_WIRE: gremlin.ProtoWireNumber = 2;
    const SEQUENCE_NUMBER_WIRE: gremlin.ProtoWireNumber = 3;
    const FRAME_TIME_US_WIRE: gremlin.ProtoWireNumber = 4;
    const DEADLINE_US_WIRE: gremlin.ProtoWireNumber = 5;
    const INTERVAL_DELTA_US_WIRE: gremlin.ProtoWireNumber = 6;
    const ON_CRITICAL_PATH_WIRE: gremlin.ProtoWireNumber = 7;
    const ANIMATE_ONLY_WIRE: gremlin.ProtoWireNumber = 8;
    const FRAMES_THROTTLED_SINCE_LAST_WIRE: gremlin.ProtoWireNumber = 12;
    const SOURCE_LOCATION_IID_WIRE: gremlin.ProtoWireNumber = 9;
    const SOURCE_LOCATION_WIRE: gremlin.ProtoWireNumber = 10;
};
pub const BeginFrameArgs = struct {
    // nested enums
    pub const BeginFrameArgsType = enum(i32) {
        BEGIN_FRAME_ARGS_TYPE_UNSPECIFIED = 0,
        BEGIN_FRAME_ARGS_TYPE_INVALID = 1,
        BEGIN_FRAME_ARGS_TYPE_NORMAL = 2,
        BEGIN_FRAME_ARGS_TYPE_MISSED = 3,
    };
    // fields
    type: BeginFrameArgs.BeginFrameArgsType = @enumFromInt(0),
    source_id: u64 = 0,
    sequence_number: u64 = 0,
    frame_time_us: i64 = 0,
    deadline_us: i64 = 0,
    interval_delta_us: i64 = 0,
    on_critical_path: bool = false,
    animate_only: bool = false,
    frames_throttled_since_last: i64 = 0,
    source_location_iid: u64 = 0,
    source_location: ?source_location.SourceLocation = null,
    pub fn calcProtobufSize(self: *const BeginFrameArgs) usize {
        var res: usize = 0;
        if (@intFromEnum(self.type) != 0) {
            res += gremlin.sizes.sizeWireNumber(BeginFrameArgsWire.TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.type));
        }
        if (self.source_id != 0) {
            res += gremlin.sizes.sizeWireNumber(BeginFrameArgsWire.SOURCE_ID_WIRE) + gremlin.sizes.sizeU64(self.source_id);
        }
        if (self.sequence_number != 0) {
            res += gremlin.sizes.sizeWireNumber(BeginFrameArgsWire.SEQUENCE_NUMBER_WIRE) + gremlin.sizes.sizeU64(self.sequence_number);
        }
        if (self.frame_time_us != 0) {
            res += gremlin.sizes.sizeWireNumber(BeginFrameArgsWire.FRAME_TIME_US_WIRE) + gremlin.sizes.sizeI64(self.frame_time_us);
        }
        if (self.deadline_us != 0) {
            res += gremlin.sizes.sizeWireNumber(BeginFrameArgsWire.DEADLINE_US_WIRE) + gremlin.sizes.sizeI64(self.deadline_us);
        }
        if (self.interval_delta_us != 0) {
            res += gremlin.sizes.sizeWireNumber(BeginFrameArgsWire.INTERVAL_DELTA_US_WIRE) + gremlin.sizes.sizeI64(self.interval_delta_us);
        }
        if (self.on_critical_path != false) {
            res += gremlin.sizes.sizeWireNumber(BeginFrameArgsWire.ON_CRITICAL_PATH_WIRE) + gremlin.sizes.sizeBool(self.on_critical_path);
        }
        if (self.animate_only != false) {
            res += gremlin.sizes.sizeWireNumber(BeginFrameArgsWire.ANIMATE_ONLY_WIRE) + gremlin.sizes.sizeBool(self.animate_only);
        }
        if (self.frames_throttled_since_last != 0) {
            res += gremlin.sizes.sizeWireNumber(BeginFrameArgsWire.FRAMES_THROTTLED_SINCE_LAST_WIRE) + gremlin.sizes.sizeI64(self.frames_throttled_since_last);
        }
        if (self.source_location_iid != 0) {
            res += gremlin.sizes.sizeWireNumber(BeginFrameArgsWire.SOURCE_LOCATION_IID_WIRE) + gremlin.sizes.sizeU64(self.source_location_iid);
        }
        if (self.source_location) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(BeginFrameArgsWire.SOURCE_LOCATION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const BeginFrameArgs, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const BeginFrameArgs, target: *gremlin.Writer) void {
        if (@intFromEnum(self.type) != 0) {
            target.appendInt32(BeginFrameArgsWire.TYPE_WIRE, @intFromEnum(self.type));
        }
        if (self.source_id != 0) {
            target.appendUint64(BeginFrameArgsWire.SOURCE_ID_WIRE, self.source_id);
        }
        if (self.sequence_number != 0) {
            target.appendUint64(BeginFrameArgsWire.SEQUENCE_NUMBER_WIRE, self.sequence_number);
        }
        if (self.frame_time_us != 0) {
            target.appendInt64(BeginFrameArgsWire.FRAME_TIME_US_WIRE, self.frame_time_us);
        }
        if (self.deadline_us != 0) {
            target.appendInt64(BeginFrameArgsWire.DEADLINE_US_WIRE, self.deadline_us);
        }
        if (self.interval_delta_us != 0) {
            target.appendInt64(BeginFrameArgsWire.INTERVAL_DELTA_US_WIRE, self.interval_delta_us);
        }
        if (self.on_critical_path != false) {
            target.appendBool(BeginFrameArgsWire.ON_CRITICAL_PATH_WIRE, self.on_critical_path);
        }
        if (self.animate_only != false) {
            target.appendBool(BeginFrameArgsWire.ANIMATE_ONLY_WIRE, self.animate_only);
        }
        if (self.frames_throttled_since_last != 0) {
            target.appendInt64(BeginFrameArgsWire.FRAMES_THROTTLED_SINCE_LAST_WIRE, self.frames_throttled_since_last);
        }
        if (self.source_location_iid != 0) {
            target.appendUint64(BeginFrameArgsWire.SOURCE_LOCATION_IID_WIRE, self.source_location_iid);
        }
        if (self.source_location) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(BeginFrameArgsWire.SOURCE_LOCATION_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const BeginFrameArgsReader = struct {
    buf: gremlin.Reader,
    _type: BeginFrameArgs.BeginFrameArgsType = @enumFromInt(0),
    _source_id: u64 = 0,
    _sequence_number: u64 = 0,
    _frame_time_us: i64 = 0,
    _deadline_us: i64 = 0,
    _interval_delta_us: i64 = 0,
    _on_critical_path: bool = false,
    _animate_only: bool = false,
    _frames_throttled_since_last: i64 = 0,
    _source_location_iid: u64 = 0,
    _source_location_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!BeginFrameArgsReader {
        const buf = gremlin.Reader.init(src);
        var res = BeginFrameArgsReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                BeginFrameArgsWire.TYPE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._type = @enumFromInt(result.value);
                },
                BeginFrameArgsWire.SOURCE_ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._source_id = result.value;
                },
                BeginFrameArgsWire.SEQUENCE_NUMBER_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._sequence_number = result.value;
                },
                BeginFrameArgsWire.FRAME_TIME_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._frame_time_us = result.value;
                },
                BeginFrameArgsWire.DEADLINE_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._deadline_us = result.value;
                },
                BeginFrameArgsWire.INTERVAL_DELTA_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._interval_delta_us = result.value;
                },
                BeginFrameArgsWire.ON_CRITICAL_PATH_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._on_critical_path = result.value;
                },
                BeginFrameArgsWire.ANIMATE_ONLY_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._animate_only = result.value;
                },
                BeginFrameArgsWire.FRAMES_THROTTLED_SINCE_LAST_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._frames_throttled_since_last = result.value;
                },
                BeginFrameArgsWire.SOURCE_LOCATION_IID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._source_location_iid = result.value;
                },
                BeginFrameArgsWire.SOURCE_LOCATION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._source_location_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getType(self: *const BeginFrameArgsReader) BeginFrameArgs.BeginFrameArgsType {
        return self._type;
    }
    pub inline fn getSourceId(self: *const BeginFrameArgsReader) u64 {
        return self._source_id;
    }
    pub inline fn getSequenceNumber(self: *const BeginFrameArgsReader) u64 {
        return self._sequence_number;
    }
    pub inline fn getFrameTimeUs(self: *const BeginFrameArgsReader) i64 {
        return self._frame_time_us;
    }
    pub inline fn getDeadlineUs(self: *const BeginFrameArgsReader) i64 {
        return self._deadline_us;
    }
    pub inline fn getIntervalDeltaUs(self: *const BeginFrameArgsReader) i64 {
        return self._interval_delta_us;
    }
    pub inline fn getOnCriticalPath(self: *const BeginFrameArgsReader) bool {
        return self._on_critical_path;
    }
    pub inline fn getAnimateOnly(self: *const BeginFrameArgsReader) bool {
        return self._animate_only;
    }
    pub inline fn getFramesThrottledSinceLast(self: *const BeginFrameArgsReader) i64 {
        return self._frames_throttled_since_last;
    }
    pub inline fn getSourceLocationIid(self: *const BeginFrameArgsReader) u64 {
        return self._source_location_iid;
    }
    pub fn getSourceLocation(self: *const BeginFrameArgsReader) gremlin.Error!source_location.SourceLocationReader {
        if (self._source_location_buf) |buf| {
            return try source_location.SourceLocationReader.init(buf);
        }
        return try source_location.SourceLocationReader.init(&[_]u8{});
    }
};
const BeginImplFrameArgsWire = struct {
    const UPDATED_AT_US_WIRE: gremlin.ProtoWireNumber = 1;
    const FINISHED_AT_US_WIRE: gremlin.ProtoWireNumber = 2;
    const STATE_WIRE: gremlin.ProtoWireNumber = 3;
    const TIMESTAMPS_IN_US_WIRE: gremlin.ProtoWireNumber = 6;
    const CURRENT_ARGS_WIRE: gremlin.ProtoWireNumber = 4;
    const LAST_ARGS_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const BeginImplFrameArgs = struct {
    // nested enums
    pub const State = enum(i32) {
        BEGIN_FRAME_FINISHED = 0,
        BEGIN_FRAME_USING = 1,
    };
    // nested structs
    const TimestampsInUsWire = struct {
        const INTERVAL_DELTA_WIRE: gremlin.ProtoWireNumber = 1;
        const NOW_TO_DEADLINE_DELTA_WIRE: gremlin.ProtoWireNumber = 2;
        const FRAME_TIME_TO_NOW_DELTA_WIRE: gremlin.ProtoWireNumber = 3;
        const FRAME_TIME_TO_DEADLINE_DELTA_WIRE: gremlin.ProtoWireNumber = 4;
        const NOW_WIRE: gremlin.ProtoWireNumber = 5;
        const FRAME_TIME_WIRE: gremlin.ProtoWireNumber = 6;
        const DEADLINE_WIRE: gremlin.ProtoWireNumber = 7;
    };
    pub const TimestampsInUs = struct {
        // fields
        interval_delta: i64 = 0,
        now_to_deadline_delta: i64 = 0,
        frame_time_to_now_delta: i64 = 0,
        frame_time_to_deadline_delta: i64 = 0,
        now: i64 = 0,
        frame_time: i64 = 0,
        deadline: i64 = 0,
        pub fn calcProtobufSize(self: *const BeginImplFrameArgs.TimestampsInUs) usize {
            var res: usize = 0;
            if (self.interval_delta != 0) {
                res += gremlin.sizes.sizeWireNumber(BeginImplFrameArgs.TimestampsInUsWire.INTERVAL_DELTA_WIRE) + gremlin.sizes.sizeI64(self.interval_delta);
            }
            if (self.now_to_deadline_delta != 0) {
                res += gremlin.sizes.sizeWireNumber(BeginImplFrameArgs.TimestampsInUsWire.NOW_TO_DEADLINE_DELTA_WIRE) + gremlin.sizes.sizeI64(self.now_to_deadline_delta);
            }
            if (self.frame_time_to_now_delta != 0) {
                res += gremlin.sizes.sizeWireNumber(BeginImplFrameArgs.TimestampsInUsWire.FRAME_TIME_TO_NOW_DELTA_WIRE) + gremlin.sizes.sizeI64(self.frame_time_to_now_delta);
            }
            if (self.frame_time_to_deadline_delta != 0) {
                res += gremlin.sizes.sizeWireNumber(BeginImplFrameArgs.TimestampsInUsWire.FRAME_TIME_TO_DEADLINE_DELTA_WIRE) + gremlin.sizes.sizeI64(self.frame_time_to_deadline_delta);
            }
            if (self.now != 0) {
                res += gremlin.sizes.sizeWireNumber(BeginImplFrameArgs.TimestampsInUsWire.NOW_WIRE) + gremlin.sizes.sizeI64(self.now);
            }
            if (self.frame_time != 0) {
                res += gremlin.sizes.sizeWireNumber(BeginImplFrameArgs.TimestampsInUsWire.FRAME_TIME_WIRE) + gremlin.sizes.sizeI64(self.frame_time);
            }
            if (self.deadline != 0) {
                res += gremlin.sizes.sizeWireNumber(BeginImplFrameArgs.TimestampsInUsWire.DEADLINE_WIRE) + gremlin.sizes.sizeI64(self.deadline);
            }
            return res;
        }
        pub fn encode(self: *const BeginImplFrameArgs.TimestampsInUs, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const BeginImplFrameArgs.TimestampsInUs, target: *gremlin.Writer) void {
            if (self.interval_delta != 0) {
                target.appendInt64(BeginImplFrameArgs.TimestampsInUsWire.INTERVAL_DELTA_WIRE, self.interval_delta);
            }
            if (self.now_to_deadline_delta != 0) {
                target.appendInt64(BeginImplFrameArgs.TimestampsInUsWire.NOW_TO_DEADLINE_DELTA_WIRE, self.now_to_deadline_delta);
            }
            if (self.frame_time_to_now_delta != 0) {
                target.appendInt64(BeginImplFrameArgs.TimestampsInUsWire.FRAME_TIME_TO_NOW_DELTA_WIRE, self.frame_time_to_now_delta);
            }
            if (self.frame_time_to_deadline_delta != 0) {
                target.appendInt64(BeginImplFrameArgs.TimestampsInUsWire.FRAME_TIME_TO_DEADLINE_DELTA_WIRE, self.frame_time_to_deadline_delta);
            }
            if (self.now != 0) {
                target.appendInt64(BeginImplFrameArgs.TimestampsInUsWire.NOW_WIRE, self.now);
            }
            if (self.frame_time != 0) {
                target.appendInt64(BeginImplFrameArgs.TimestampsInUsWire.FRAME_TIME_WIRE, self.frame_time);
            }
            if (self.deadline != 0) {
                target.appendInt64(BeginImplFrameArgs.TimestampsInUsWire.DEADLINE_WIRE, self.deadline);
            }
        }
    };
    pub const TimestampsInUsReader = struct {
        buf: gremlin.Reader,
        _interval_delta: i64 = 0,
        _now_to_deadline_delta: i64 = 0,
        _frame_time_to_now_delta: i64 = 0,
        _frame_time_to_deadline_delta: i64 = 0,
        _now: i64 = 0,
        _frame_time: i64 = 0,
        _deadline: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!BeginImplFrameArgs.TimestampsInUsReader {
            const buf = gremlin.Reader.init(src);
            var res = BeginImplFrameArgs.TimestampsInUsReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    BeginImplFrameArgs.TimestampsInUsWire.INTERVAL_DELTA_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._interval_delta = result.value;
                    },
                    BeginImplFrameArgs.TimestampsInUsWire.NOW_TO_DEADLINE_DELTA_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._now_to_deadline_delta = result.value;
                    },
                    BeginImplFrameArgs.TimestampsInUsWire.FRAME_TIME_TO_NOW_DELTA_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._frame_time_to_now_delta = result.value;
                    },
                    BeginImplFrameArgs.TimestampsInUsWire.FRAME_TIME_TO_DEADLINE_DELTA_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._frame_time_to_deadline_delta = result.value;
                    },
                    BeginImplFrameArgs.TimestampsInUsWire.NOW_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._now = result.value;
                    },
                    BeginImplFrameArgs.TimestampsInUsWire.FRAME_TIME_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._frame_time = result.value;
                    },
                    BeginImplFrameArgs.TimestampsInUsWire.DEADLINE_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._deadline = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getIntervalDelta(self: *const BeginImplFrameArgs.TimestampsInUsReader) i64 {
            return self._interval_delta;
        }
        pub inline fn getNowToDeadlineDelta(self: *const BeginImplFrameArgs.TimestampsInUsReader) i64 {
            return self._now_to_deadline_delta;
        }
        pub inline fn getFrameTimeToNowDelta(self: *const BeginImplFrameArgs.TimestampsInUsReader) i64 {
            return self._frame_time_to_now_delta;
        }
        pub inline fn getFrameTimeToDeadlineDelta(self: *const BeginImplFrameArgs.TimestampsInUsReader) i64 {
            return self._frame_time_to_deadline_delta;
        }
        pub inline fn getNow(self: *const BeginImplFrameArgs.TimestampsInUsReader) i64 {
            return self._now;
        }
        pub inline fn getFrameTime(self: *const BeginImplFrameArgs.TimestampsInUsReader) i64 {
            return self._frame_time;
        }
        pub inline fn getDeadline(self: *const BeginImplFrameArgs.TimestampsInUsReader) i64 {
            return self._deadline;
        }
    };
    // fields
    updated_at_us: i64 = 0,
    finished_at_us: i64 = 0,
    state: BeginImplFrameArgs.State = @enumFromInt(0),
    timestamps_in_us: ?BeginImplFrameArgs.TimestampsInUs = null,
    current_args: ?BeginFrameArgs = null,
    last_args: ?BeginFrameArgs = null,
    pub fn calcProtobufSize(self: *const BeginImplFrameArgs) usize {
        var res: usize = 0;
        if (self.updated_at_us != 0) {
            res += gremlin.sizes.sizeWireNumber(BeginImplFrameArgsWire.UPDATED_AT_US_WIRE) + gremlin.sizes.sizeI64(self.updated_at_us);
        }
        if (self.finished_at_us != 0) {
            res += gremlin.sizes.sizeWireNumber(BeginImplFrameArgsWire.FINISHED_AT_US_WIRE) + gremlin.sizes.sizeI64(self.finished_at_us);
        }
        if (@intFromEnum(self.state) != 0) {
            res += gremlin.sizes.sizeWireNumber(BeginImplFrameArgsWire.STATE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.state));
        }
        if (self.timestamps_in_us) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(BeginImplFrameArgsWire.TIMESTAMPS_IN_US_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.current_args) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(BeginImplFrameArgsWire.CURRENT_ARGS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.last_args) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(BeginImplFrameArgsWire.LAST_ARGS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const BeginImplFrameArgs, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const BeginImplFrameArgs, target: *gremlin.Writer) void {
        if (self.updated_at_us != 0) {
            target.appendInt64(BeginImplFrameArgsWire.UPDATED_AT_US_WIRE, self.updated_at_us);
        }
        if (self.finished_at_us != 0) {
            target.appendInt64(BeginImplFrameArgsWire.FINISHED_AT_US_WIRE, self.finished_at_us);
        }
        if (@intFromEnum(self.state) != 0) {
            target.appendInt32(BeginImplFrameArgsWire.STATE_WIRE, @intFromEnum(self.state));
        }
        if (self.timestamps_in_us) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(BeginImplFrameArgsWire.TIMESTAMPS_IN_US_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.current_args) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(BeginImplFrameArgsWire.CURRENT_ARGS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.last_args) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(BeginImplFrameArgsWire.LAST_ARGS_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const BeginImplFrameArgsReader = struct {
    buf: gremlin.Reader,
    _updated_at_us: i64 = 0,
    _finished_at_us: i64 = 0,
    _state: BeginImplFrameArgs.State = @enumFromInt(0),
    _timestamps_in_us_buf: ?[]const u8 = null,
    _current_args_buf: ?[]const u8 = null,
    _last_args_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!BeginImplFrameArgsReader {
        const buf = gremlin.Reader.init(src);
        var res = BeginImplFrameArgsReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                BeginImplFrameArgsWire.UPDATED_AT_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._updated_at_us = result.value;
                },
                BeginImplFrameArgsWire.FINISHED_AT_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._finished_at_us = result.value;
                },
                BeginImplFrameArgsWire.STATE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._state = @enumFromInt(result.value);
                },
                BeginImplFrameArgsWire.TIMESTAMPS_IN_US_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._timestamps_in_us_buf = result.value;
                },
                BeginImplFrameArgsWire.CURRENT_ARGS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._current_args_buf = result.value;
                },
                BeginImplFrameArgsWire.LAST_ARGS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._last_args_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getUpdatedAtUs(self: *const BeginImplFrameArgsReader) i64 {
        return self._updated_at_us;
    }
    pub inline fn getFinishedAtUs(self: *const BeginImplFrameArgsReader) i64 {
        return self._finished_at_us;
    }
    pub inline fn getState(self: *const BeginImplFrameArgsReader) BeginImplFrameArgs.State {
        return self._state;
    }
    pub fn getTimestampsInUs(self: *const BeginImplFrameArgsReader) gremlin.Error!BeginImplFrameArgs.TimestampsInUsReader {
        if (self._timestamps_in_us_buf) |buf| {
            return try BeginImplFrameArgs.TimestampsInUsReader.init(buf);
        }
        return try BeginImplFrameArgs.TimestampsInUsReader.init(&[_]u8{});
    }
    pub fn getCurrentArgs(self: *const BeginImplFrameArgsReader) gremlin.Error!BeginFrameArgsReader {
        if (self._current_args_buf) |buf| {
            return try BeginFrameArgsReader.init(buf);
        }
        return try BeginFrameArgsReader.init(&[_]u8{});
    }
    pub fn getLastArgs(self: *const BeginImplFrameArgsReader) gremlin.Error!BeginFrameArgsReader {
        if (self._last_args_buf) |buf| {
            return try BeginFrameArgsReader.init(buf);
        }
        return try BeginFrameArgsReader.init(&[_]u8{});
    }
};
const BeginFrameObserverStateWire = struct {
    const DROPPED_BEGIN_FRAME_ARGS_WIRE: gremlin.ProtoWireNumber = 1;
    const LAST_BEGIN_FRAME_ARGS_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const BeginFrameObserverState = struct {
    // fields
    dropped_begin_frame_args: i64 = 0,
    last_begin_frame_args: ?BeginFrameArgs = null,
    pub fn calcProtobufSize(self: *const BeginFrameObserverState) usize {
        var res: usize = 0;
        if (self.dropped_begin_frame_args != 0) {
            res += gremlin.sizes.sizeWireNumber(BeginFrameObserverStateWire.DROPPED_BEGIN_FRAME_ARGS_WIRE) + gremlin.sizes.sizeI64(self.dropped_begin_frame_args);
        }
        if (self.last_begin_frame_args) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(BeginFrameObserverStateWire.LAST_BEGIN_FRAME_ARGS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const BeginFrameObserverState, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const BeginFrameObserverState, target: *gremlin.Writer) void {
        if (self.dropped_begin_frame_args != 0) {
            target.appendInt64(BeginFrameObserverStateWire.DROPPED_BEGIN_FRAME_ARGS_WIRE, self.dropped_begin_frame_args);
        }
        if (self.last_begin_frame_args) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(BeginFrameObserverStateWire.LAST_BEGIN_FRAME_ARGS_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const BeginFrameObserverStateReader = struct {
    buf: gremlin.Reader,
    _dropped_begin_frame_args: i64 = 0,
    _last_begin_frame_args_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!BeginFrameObserverStateReader {
        const buf = gremlin.Reader.init(src);
        var res = BeginFrameObserverStateReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                BeginFrameObserverStateWire.DROPPED_BEGIN_FRAME_ARGS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._dropped_begin_frame_args = result.value;
                },
                BeginFrameObserverStateWire.LAST_BEGIN_FRAME_ARGS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._last_begin_frame_args_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDroppedBeginFrameArgs(self: *const BeginFrameObserverStateReader) i64 {
        return self._dropped_begin_frame_args;
    }
    pub fn getLastBeginFrameArgs(self: *const BeginFrameObserverStateReader) gremlin.Error!BeginFrameArgsReader {
        if (self._last_begin_frame_args_buf) |buf| {
            return try BeginFrameArgsReader.init(buf);
        }
        return try BeginFrameArgsReader.init(&[_]u8{});
    }
};
const BeginFrameSourceStateWire = struct {
    const SOURCE_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const PAUSED_WIRE: gremlin.ProtoWireNumber = 2;
    const NUM_OBSERVERS_WIRE: gremlin.ProtoWireNumber = 3;
    const LAST_BEGIN_FRAME_ARGS_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const BeginFrameSourceState = struct {
    // fields
    source_id: u32 = 0,
    paused: bool = false,
    num_observers: u32 = 0,
    last_begin_frame_args: ?BeginFrameArgs = null,
    pub fn calcProtobufSize(self: *const BeginFrameSourceState) usize {
        var res: usize = 0;
        if (self.source_id != 0) {
            res += gremlin.sizes.sizeWireNumber(BeginFrameSourceStateWire.SOURCE_ID_WIRE) + gremlin.sizes.sizeU32(self.source_id);
        }
        if (self.paused != false) {
            res += gremlin.sizes.sizeWireNumber(BeginFrameSourceStateWire.PAUSED_WIRE) + gremlin.sizes.sizeBool(self.paused);
        }
        if (self.num_observers != 0) {
            res += gremlin.sizes.sizeWireNumber(BeginFrameSourceStateWire.NUM_OBSERVERS_WIRE) + gremlin.sizes.sizeU32(self.num_observers);
        }
        if (self.last_begin_frame_args) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(BeginFrameSourceStateWire.LAST_BEGIN_FRAME_ARGS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const BeginFrameSourceState, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const BeginFrameSourceState, target: *gremlin.Writer) void {
        if (self.source_id != 0) {
            target.appendUint32(BeginFrameSourceStateWire.SOURCE_ID_WIRE, self.source_id);
        }
        if (self.paused != false) {
            target.appendBool(BeginFrameSourceStateWire.PAUSED_WIRE, self.paused);
        }
        if (self.num_observers != 0) {
            target.appendUint32(BeginFrameSourceStateWire.NUM_OBSERVERS_WIRE, self.num_observers);
        }
        if (self.last_begin_frame_args) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(BeginFrameSourceStateWire.LAST_BEGIN_FRAME_ARGS_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const BeginFrameSourceStateReader = struct {
    buf: gremlin.Reader,
    _source_id: u32 = 0,
    _paused: bool = false,
    _num_observers: u32 = 0,
    _last_begin_frame_args_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!BeginFrameSourceStateReader {
        const buf = gremlin.Reader.init(src);
        var res = BeginFrameSourceStateReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                BeginFrameSourceStateWire.SOURCE_ID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._source_id = result.value;
                },
                BeginFrameSourceStateWire.PAUSED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._paused = result.value;
                },
                BeginFrameSourceStateWire.NUM_OBSERVERS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._num_observers = result.value;
                },
                BeginFrameSourceStateWire.LAST_BEGIN_FRAME_ARGS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._last_begin_frame_args_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getSourceId(self: *const BeginFrameSourceStateReader) u32 {
        return self._source_id;
    }
    pub inline fn getPaused(self: *const BeginFrameSourceStateReader) bool {
        return self._paused;
    }
    pub inline fn getNumObservers(self: *const BeginFrameSourceStateReader) u32 {
        return self._num_observers;
    }
    pub fn getLastBeginFrameArgs(self: *const BeginFrameSourceStateReader) gremlin.Error!BeginFrameArgsReader {
        if (self._last_begin_frame_args_buf) |buf| {
            return try BeginFrameArgsReader.init(buf);
        }
        return try BeginFrameArgsReader.init(&[_]u8{});
    }
};
const CompositorTimingHistoryWire = struct {
    const BEGIN_MAIN_FRAME_QUEUE_CRITICAL_ESTIMATE_DELTA_US_WIRE: gremlin.ProtoWireNumber = 1;
    const BEGIN_MAIN_FRAME_QUEUE_NOT_CRITICAL_ESTIMATE_DELTA_US_WIRE: gremlin.ProtoWireNumber = 2;
    const BEGIN_MAIN_FRAME_START_TO_READY_TO_COMMIT_ESTIMATE_DELTA_US_WIRE: gremlin.ProtoWireNumber = 3;
    const COMMIT_TO_READY_TO_ACTIVATE_ESTIMATE_DELTA_US_WIRE: gremlin.ProtoWireNumber = 4;
    const PREPARE_TILES_ESTIMATE_DELTA_US_WIRE: gremlin.ProtoWireNumber = 5;
    const ACTIVATE_ESTIMATE_DELTA_US_WIRE: gremlin.ProtoWireNumber = 6;
    const DRAW_ESTIMATE_DELTA_US_WIRE: gremlin.ProtoWireNumber = 7;
};
pub const CompositorTimingHistory = struct {
    // fields
    begin_main_frame_queue_critical_estimate_delta_us: i64 = 0,
    begin_main_frame_queue_not_critical_estimate_delta_us: i64 = 0,
    begin_main_frame_start_to_ready_to_commit_estimate_delta_us: i64 = 0,
    commit_to_ready_to_activate_estimate_delta_us: i64 = 0,
    prepare_tiles_estimate_delta_us: i64 = 0,
    activate_estimate_delta_us: i64 = 0,
    draw_estimate_delta_us: i64 = 0,
    pub fn calcProtobufSize(self: *const CompositorTimingHistory) usize {
        var res: usize = 0;
        if (self.begin_main_frame_queue_critical_estimate_delta_us != 0) {
            res += gremlin.sizes.sizeWireNumber(CompositorTimingHistoryWire.BEGIN_MAIN_FRAME_QUEUE_CRITICAL_ESTIMATE_DELTA_US_WIRE) + gremlin.sizes.sizeI64(self.begin_main_frame_queue_critical_estimate_delta_us);
        }
        if (self.begin_main_frame_queue_not_critical_estimate_delta_us != 0) {
            res += gremlin.sizes.sizeWireNumber(CompositorTimingHistoryWire.BEGIN_MAIN_FRAME_QUEUE_NOT_CRITICAL_ESTIMATE_DELTA_US_WIRE) + gremlin.sizes.sizeI64(self.begin_main_frame_queue_not_critical_estimate_delta_us);
        }
        if (self.begin_main_frame_start_to_ready_to_commit_estimate_delta_us != 0) {
            res += gremlin.sizes.sizeWireNumber(CompositorTimingHistoryWire.BEGIN_MAIN_FRAME_START_TO_READY_TO_COMMIT_ESTIMATE_DELTA_US_WIRE) + gremlin.sizes.sizeI64(self.begin_main_frame_start_to_ready_to_commit_estimate_delta_us);
        }
        if (self.commit_to_ready_to_activate_estimate_delta_us != 0) {
            res += gremlin.sizes.sizeWireNumber(CompositorTimingHistoryWire.COMMIT_TO_READY_TO_ACTIVATE_ESTIMATE_DELTA_US_WIRE) + gremlin.sizes.sizeI64(self.commit_to_ready_to_activate_estimate_delta_us);
        }
        if (self.prepare_tiles_estimate_delta_us != 0) {
            res += gremlin.sizes.sizeWireNumber(CompositorTimingHistoryWire.PREPARE_TILES_ESTIMATE_DELTA_US_WIRE) + gremlin.sizes.sizeI64(self.prepare_tiles_estimate_delta_us);
        }
        if (self.activate_estimate_delta_us != 0) {
            res += gremlin.sizes.sizeWireNumber(CompositorTimingHistoryWire.ACTIVATE_ESTIMATE_DELTA_US_WIRE) + gremlin.sizes.sizeI64(self.activate_estimate_delta_us);
        }
        if (self.draw_estimate_delta_us != 0) {
            res += gremlin.sizes.sizeWireNumber(CompositorTimingHistoryWire.DRAW_ESTIMATE_DELTA_US_WIRE) + gremlin.sizes.sizeI64(self.draw_estimate_delta_us);
        }
        return res;
    }
    pub fn encode(self: *const CompositorTimingHistory, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const CompositorTimingHistory, target: *gremlin.Writer) void {
        if (self.begin_main_frame_queue_critical_estimate_delta_us != 0) {
            target.appendInt64(CompositorTimingHistoryWire.BEGIN_MAIN_FRAME_QUEUE_CRITICAL_ESTIMATE_DELTA_US_WIRE, self.begin_main_frame_queue_critical_estimate_delta_us);
        }
        if (self.begin_main_frame_queue_not_critical_estimate_delta_us != 0) {
            target.appendInt64(CompositorTimingHistoryWire.BEGIN_MAIN_FRAME_QUEUE_NOT_CRITICAL_ESTIMATE_DELTA_US_WIRE, self.begin_main_frame_queue_not_critical_estimate_delta_us);
        }
        if (self.begin_main_frame_start_to_ready_to_commit_estimate_delta_us != 0) {
            target.appendInt64(CompositorTimingHistoryWire.BEGIN_MAIN_FRAME_START_TO_READY_TO_COMMIT_ESTIMATE_DELTA_US_WIRE, self.begin_main_frame_start_to_ready_to_commit_estimate_delta_us);
        }
        if (self.commit_to_ready_to_activate_estimate_delta_us != 0) {
            target.appendInt64(CompositorTimingHistoryWire.COMMIT_TO_READY_TO_ACTIVATE_ESTIMATE_DELTA_US_WIRE, self.commit_to_ready_to_activate_estimate_delta_us);
        }
        if (self.prepare_tiles_estimate_delta_us != 0) {
            target.appendInt64(CompositorTimingHistoryWire.PREPARE_TILES_ESTIMATE_DELTA_US_WIRE, self.prepare_tiles_estimate_delta_us);
        }
        if (self.activate_estimate_delta_us != 0) {
            target.appendInt64(CompositorTimingHistoryWire.ACTIVATE_ESTIMATE_DELTA_US_WIRE, self.activate_estimate_delta_us);
        }
        if (self.draw_estimate_delta_us != 0) {
            target.appendInt64(CompositorTimingHistoryWire.DRAW_ESTIMATE_DELTA_US_WIRE, self.draw_estimate_delta_us);
        }
    }
};
pub const CompositorTimingHistoryReader = struct {
    buf: gremlin.Reader,
    _begin_main_frame_queue_critical_estimate_delta_us: i64 = 0,
    _begin_main_frame_queue_not_critical_estimate_delta_us: i64 = 0,
    _begin_main_frame_start_to_ready_to_commit_estimate_delta_us: i64 = 0,
    _commit_to_ready_to_activate_estimate_delta_us: i64 = 0,
    _prepare_tiles_estimate_delta_us: i64 = 0,
    _activate_estimate_delta_us: i64 = 0,
    _draw_estimate_delta_us: i64 = 0,
    pub fn init(src: []const u8) gremlin.Error!CompositorTimingHistoryReader {
        const buf = gremlin.Reader.init(src);
        var res = CompositorTimingHistoryReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                CompositorTimingHistoryWire.BEGIN_MAIN_FRAME_QUEUE_CRITICAL_ESTIMATE_DELTA_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._begin_main_frame_queue_critical_estimate_delta_us = result.value;
                },
                CompositorTimingHistoryWire.BEGIN_MAIN_FRAME_QUEUE_NOT_CRITICAL_ESTIMATE_DELTA_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._begin_main_frame_queue_not_critical_estimate_delta_us = result.value;
                },
                CompositorTimingHistoryWire.BEGIN_MAIN_FRAME_START_TO_READY_TO_COMMIT_ESTIMATE_DELTA_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._begin_main_frame_start_to_ready_to_commit_estimate_delta_us = result.value;
                },
                CompositorTimingHistoryWire.COMMIT_TO_READY_TO_ACTIVATE_ESTIMATE_DELTA_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._commit_to_ready_to_activate_estimate_delta_us = result.value;
                },
                CompositorTimingHistoryWire.PREPARE_TILES_ESTIMATE_DELTA_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._prepare_tiles_estimate_delta_us = result.value;
                },
                CompositorTimingHistoryWire.ACTIVATE_ESTIMATE_DELTA_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._activate_estimate_delta_us = result.value;
                },
                CompositorTimingHistoryWire.DRAW_ESTIMATE_DELTA_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._draw_estimate_delta_us = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getBeginMainFrameQueueCriticalEstimateDeltaUs(self: *const CompositorTimingHistoryReader) i64 {
        return self._begin_main_frame_queue_critical_estimate_delta_us;
    }
    pub inline fn getBeginMainFrameQueueNotCriticalEstimateDeltaUs(self: *const CompositorTimingHistoryReader) i64 {
        return self._begin_main_frame_queue_not_critical_estimate_delta_us;
    }
    pub inline fn getBeginMainFrameStartToReadyToCommitEstimateDeltaUs(self: *const CompositorTimingHistoryReader) i64 {
        return self._begin_main_frame_start_to_ready_to_commit_estimate_delta_us;
    }
    pub inline fn getCommitToReadyToActivateEstimateDeltaUs(self: *const CompositorTimingHistoryReader) i64 {
        return self._commit_to_ready_to_activate_estimate_delta_us;
    }
    pub inline fn getPrepareTilesEstimateDeltaUs(self: *const CompositorTimingHistoryReader) i64 {
        return self._prepare_tiles_estimate_delta_us;
    }
    pub inline fn getActivateEstimateDeltaUs(self: *const CompositorTimingHistoryReader) i64 {
        return self._activate_estimate_delta_us;
    }
    pub inline fn getDrawEstimateDeltaUs(self: *const CompositorTimingHistoryReader) i64 {
        return self._draw_estimate_delta_us;
    }
};
