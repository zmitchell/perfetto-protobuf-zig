// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const ChromeFrameReporterWire = struct {
    const STATE_WIRE: gremlin.ProtoWireNumber = 1;
    const REASON_WIRE: gremlin.ProtoWireNumber = 2;
    const FRAME_SOURCE_WIRE: gremlin.ProtoWireNumber = 3;
    const FRAME_SEQUENCE_WIRE: gremlin.ProtoWireNumber = 4;
    const AFFECTS_SMOOTHNESS_WIRE: gremlin.ProtoWireNumber = 5;
    const SCROLL_STATE_WIRE: gremlin.ProtoWireNumber = 6;
    const HAS_MAIN_ANIMATION_WIRE: gremlin.ProtoWireNumber = 7;
    const HAS_COMPOSITOR_ANIMATION_WIRE: gremlin.ProtoWireNumber = 8;
    const HAS_SMOOTH_INPUT_MAIN_WIRE: gremlin.ProtoWireNumber = 9;
    const HAS_MISSING_CONTENT_WIRE: gremlin.ProtoWireNumber = 10;
    const LAYER_TREE_HOST_ID_WIRE: gremlin.ProtoWireNumber = 11;
    const HAS_HIGH_LATENCY_WIRE: gremlin.ProtoWireNumber = 12;
    const FRAME_TYPE_WIRE: gremlin.ProtoWireNumber = 13;
    const HIGH_LATENCY_CONTRIBUTION_STAGE_WIRE: gremlin.ProtoWireNumber = 14;
    const CHECKERBOARDED_NEEDS_RASTER_WIRE: gremlin.ProtoWireNumber = 15;
    const CHECKERBOARDED_NEEDS_RECORD_WIRE: gremlin.ProtoWireNumber = 16;
    const SURFACE_FRAME_TRACE_ID_WIRE: gremlin.ProtoWireNumber = 17;
    const DISPLAY_TRACE_ID_WIRE: gremlin.ProtoWireNumber = 18;
};
pub const ChromeFrameReporter = struct {
    // nested enums
    pub const State = enum(i32) {
        STATE_NO_UPDATE_DESIRED = 0,
        STATE_PRESENTED_ALL = 1,
        STATE_PRESENTED_PARTIAL = 2,
        STATE_DROPPED = 3,
    };
    pub const FrameDropReason = enum(i32) {
        REASON_UNSPECIFIED = 0,
        REASON_DISPLAY_COMPOSITOR = 1,
        REASON_MAIN_THREAD = 2,
        REASON_CLIENT_COMPOSITOR = 3,
    };
    pub const ScrollState = enum(i32) {
        SCROLL_NONE = 0,
        SCROLL_MAIN_THREAD = 1,
        SCROLL_COMPOSITOR_THREAD = 2,
        SCROLL_RASTER = 3,
        SCROLL_UNKNOWN = 4,
    };
    pub const FrameType = enum(i32) {
        FORKED = 0,
        BACKFILL = 1,
    };
    // fields
    state: ChromeFrameReporter.State = @enumFromInt(0),
    reason: ChromeFrameReporter.FrameDropReason = @enumFromInt(0),
    frame_source: u64 = 0,
    frame_sequence: u64 = 0,
    affects_smoothness: bool = false,
    scroll_state: ChromeFrameReporter.ScrollState = @enumFromInt(0),
    has_main_animation: bool = false,
    has_compositor_animation: bool = false,
    has_smooth_input_main: bool = false,
    has_missing_content: bool = false,
    layer_tree_host_id: u64 = 0,
    has_high_latency: bool = false,
    frame_type: ChromeFrameReporter.FrameType = @enumFromInt(0),
    high_latency_contribution_stage: ?[]const ?[]const u8 = null,
    checkerboarded_needs_raster: bool = false,
    checkerboarded_needs_record: bool = false,
    surface_frame_trace_id: i64 = 0,
    display_trace_id: i64 = 0,
    pub fn calcProtobufSize(self: *const ChromeFrameReporter) usize {
        var res: usize = 0;
        if (@intFromEnum(self.state) != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeFrameReporterWire.STATE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.state));
        }
        if (@intFromEnum(self.reason) != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeFrameReporterWire.REASON_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.reason));
        }
        if (self.frame_source != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeFrameReporterWire.FRAME_SOURCE_WIRE) + gremlin.sizes.sizeU64(self.frame_source);
        }
        if (self.frame_sequence != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeFrameReporterWire.FRAME_SEQUENCE_WIRE) + gremlin.sizes.sizeU64(self.frame_sequence);
        }
        if (self.affects_smoothness != false) {
            res += gremlin.sizes.sizeWireNumber(ChromeFrameReporterWire.AFFECTS_SMOOTHNESS_WIRE) + gremlin.sizes.sizeBool(self.affects_smoothness);
        }
        if (@intFromEnum(self.scroll_state) != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeFrameReporterWire.SCROLL_STATE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.scroll_state));
        }
        if (self.has_main_animation != false) {
            res += gremlin.sizes.sizeWireNumber(ChromeFrameReporterWire.HAS_MAIN_ANIMATION_WIRE) + gremlin.sizes.sizeBool(self.has_main_animation);
        }
        if (self.has_compositor_animation != false) {
            res += gremlin.sizes.sizeWireNumber(ChromeFrameReporterWire.HAS_COMPOSITOR_ANIMATION_WIRE) + gremlin.sizes.sizeBool(self.has_compositor_animation);
        }
        if (self.has_smooth_input_main != false) {
            res += gremlin.sizes.sizeWireNumber(ChromeFrameReporterWire.HAS_SMOOTH_INPUT_MAIN_WIRE) + gremlin.sizes.sizeBool(self.has_smooth_input_main);
        }
        if (self.has_missing_content != false) {
            res += gremlin.sizes.sizeWireNumber(ChromeFrameReporterWire.HAS_MISSING_CONTENT_WIRE) + gremlin.sizes.sizeBool(self.has_missing_content);
        }
        if (self.layer_tree_host_id != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeFrameReporterWire.LAYER_TREE_HOST_ID_WIRE) + gremlin.sizes.sizeU64(self.layer_tree_host_id);
        }
        if (self.has_high_latency != false) {
            res += gremlin.sizes.sizeWireNumber(ChromeFrameReporterWire.HAS_HIGH_LATENCY_WIRE) + gremlin.sizes.sizeBool(self.has_high_latency);
        }
        if (@intFromEnum(self.frame_type) != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeFrameReporterWire.FRAME_TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.frame_type));
        }
        if (self.high_latency_contribution_stage) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ChromeFrameReporterWire.HIGH_LATENCY_CONTRIBUTION_STAGE_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.checkerboarded_needs_raster != false) {
            res += gremlin.sizes.sizeWireNumber(ChromeFrameReporterWire.CHECKERBOARDED_NEEDS_RASTER_WIRE) + gremlin.sizes.sizeBool(self.checkerboarded_needs_raster);
        }
        if (self.checkerboarded_needs_record != false) {
            res += gremlin.sizes.sizeWireNumber(ChromeFrameReporterWire.CHECKERBOARDED_NEEDS_RECORD_WIRE) + gremlin.sizes.sizeBool(self.checkerboarded_needs_record);
        }
        if (self.surface_frame_trace_id != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeFrameReporterWire.SURFACE_FRAME_TRACE_ID_WIRE) + gremlin.sizes.sizeI64(self.surface_frame_trace_id);
        }
        if (self.display_trace_id != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeFrameReporterWire.DISPLAY_TRACE_ID_WIRE) + gremlin.sizes.sizeI64(self.display_trace_id);
        }
        return res;
    }
    pub fn encode(self: *const ChromeFrameReporter, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ChromeFrameReporter, target: *gremlin.Writer) void {
        if (@intFromEnum(self.state) != 0) {
            target.appendInt32(ChromeFrameReporterWire.STATE_WIRE, @intFromEnum(self.state));
        }
        if (@intFromEnum(self.reason) != 0) {
            target.appendInt32(ChromeFrameReporterWire.REASON_WIRE, @intFromEnum(self.reason));
        }
        if (self.frame_source != 0) {
            target.appendUint64(ChromeFrameReporterWire.FRAME_SOURCE_WIRE, self.frame_source);
        }
        if (self.frame_sequence != 0) {
            target.appendUint64(ChromeFrameReporterWire.FRAME_SEQUENCE_WIRE, self.frame_sequence);
        }
        if (self.affects_smoothness != false) {
            target.appendBool(ChromeFrameReporterWire.AFFECTS_SMOOTHNESS_WIRE, self.affects_smoothness);
        }
        if (@intFromEnum(self.scroll_state) != 0) {
            target.appendInt32(ChromeFrameReporterWire.SCROLL_STATE_WIRE, @intFromEnum(self.scroll_state));
        }
        if (self.has_main_animation != false) {
            target.appendBool(ChromeFrameReporterWire.HAS_MAIN_ANIMATION_WIRE, self.has_main_animation);
        }
        if (self.has_compositor_animation != false) {
            target.appendBool(ChromeFrameReporterWire.HAS_COMPOSITOR_ANIMATION_WIRE, self.has_compositor_animation);
        }
        if (self.has_smooth_input_main != false) {
            target.appendBool(ChromeFrameReporterWire.HAS_SMOOTH_INPUT_MAIN_WIRE, self.has_smooth_input_main);
        }
        if (self.has_missing_content != false) {
            target.appendBool(ChromeFrameReporterWire.HAS_MISSING_CONTENT_WIRE, self.has_missing_content);
        }
        if (self.layer_tree_host_id != 0) {
            target.appendUint64(ChromeFrameReporterWire.LAYER_TREE_HOST_ID_WIRE, self.layer_tree_host_id);
        }
        if (self.has_high_latency != false) {
            target.appendBool(ChromeFrameReporterWire.HAS_HIGH_LATENCY_WIRE, self.has_high_latency);
        }
        if (@intFromEnum(self.frame_type) != 0) {
            target.appendInt32(ChromeFrameReporterWire.FRAME_TYPE_WIRE, @intFromEnum(self.frame_type));
        }
        if (self.high_latency_contribution_stage) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(ChromeFrameReporterWire.HIGH_LATENCY_CONTRIBUTION_STAGE_WIRE, v);
                } else {
                    target.appendBytesTag(ChromeFrameReporterWire.HIGH_LATENCY_CONTRIBUTION_STAGE_WIRE, 0);
                }
            }
        }
        if (self.checkerboarded_needs_raster != false) {
            target.appendBool(ChromeFrameReporterWire.CHECKERBOARDED_NEEDS_RASTER_WIRE, self.checkerboarded_needs_raster);
        }
        if (self.checkerboarded_needs_record != false) {
            target.appendBool(ChromeFrameReporterWire.CHECKERBOARDED_NEEDS_RECORD_WIRE, self.checkerboarded_needs_record);
        }
        if (self.surface_frame_trace_id != 0) {
            target.appendInt64(ChromeFrameReporterWire.SURFACE_FRAME_TRACE_ID_WIRE, self.surface_frame_trace_id);
        }
        if (self.display_trace_id != 0) {
            target.appendInt64(ChromeFrameReporterWire.DISPLAY_TRACE_ID_WIRE, self.display_trace_id);
        }
    }
};
pub const ChromeFrameReporterReader = struct {
    buf: gremlin.Reader,
    _state: ChromeFrameReporter.State = @enumFromInt(0),
    _reason: ChromeFrameReporter.FrameDropReason = @enumFromInt(0),
    _frame_source: u64 = 0,
    _frame_sequence: u64 = 0,
    _affects_smoothness: bool = false,
    _scroll_state: ChromeFrameReporter.ScrollState = @enumFromInt(0),
    _has_main_animation: bool = false,
    _has_compositor_animation: bool = false,
    _has_smooth_input_main: bool = false,
    _has_missing_content: bool = false,
    _layer_tree_host_id: u64 = 0,
    _has_high_latency: bool = false,
    _frame_type: ChromeFrameReporter.FrameType = @enumFromInt(0),
    _high_latency_contribution_stage_offset: ?usize = null,
    _high_latency_contribution_stage_last_offset: ?usize = null,
    _high_latency_contribution_stage_cnt: usize = 0,
    _checkerboarded_needs_raster: bool = false,
    _checkerboarded_needs_record: bool = false,
    _surface_frame_trace_id: i64 = 0,
    _display_trace_id: i64 = 0,
    pub fn init(src: []const u8) gremlin.Error!ChromeFrameReporterReader {
        const buf = gremlin.Reader.init(src);
        var res = ChromeFrameReporterReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ChromeFrameReporterWire.STATE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._state = @enumFromInt(result.value);
                },
                ChromeFrameReporterWire.REASON_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._reason = @enumFromInt(result.value);
                },
                ChromeFrameReporterWire.FRAME_SOURCE_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._frame_source = result.value;
                },
                ChromeFrameReporterWire.FRAME_SEQUENCE_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._frame_sequence = result.value;
                },
                ChromeFrameReporterWire.AFFECTS_SMOOTHNESS_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._affects_smoothness = result.value;
                },
                ChromeFrameReporterWire.SCROLL_STATE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._scroll_state = @enumFromInt(result.value);
                },
                ChromeFrameReporterWire.HAS_MAIN_ANIMATION_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._has_main_animation = result.value;
                },
                ChromeFrameReporterWire.HAS_COMPOSITOR_ANIMATION_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._has_compositor_animation = result.value;
                },
                ChromeFrameReporterWire.HAS_SMOOTH_INPUT_MAIN_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._has_smooth_input_main = result.value;
                },
                ChromeFrameReporterWire.HAS_MISSING_CONTENT_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._has_missing_content = result.value;
                },
                ChromeFrameReporterWire.LAYER_TREE_HOST_ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._layer_tree_host_id = result.value;
                },
                ChromeFrameReporterWire.HAS_HIGH_LATENCY_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._has_high_latency = result.value;
                },
                ChromeFrameReporterWire.FRAME_TYPE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._frame_type = @enumFromInt(result.value);
                },
                ChromeFrameReporterWire.HIGH_LATENCY_CONTRIBUTION_STAGE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._high_latency_contribution_stage_offset == null) {
                        res._high_latency_contribution_stage_offset = offset - result.size;
                    }
                    res._high_latency_contribution_stage_last_offset = offset;
                    res._high_latency_contribution_stage_cnt += 1;
                },
                ChromeFrameReporterWire.CHECKERBOARDED_NEEDS_RASTER_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._checkerboarded_needs_raster = result.value;
                },
                ChromeFrameReporterWire.CHECKERBOARDED_NEEDS_RECORD_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._checkerboarded_needs_record = result.value;
                },
                ChromeFrameReporterWire.SURFACE_FRAME_TRACE_ID_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._surface_frame_trace_id = result.value;
                },
                ChromeFrameReporterWire.DISPLAY_TRACE_ID_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._display_trace_id = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getState(self: *const ChromeFrameReporterReader) ChromeFrameReporter.State {
        return self._state;
    }
    pub inline fn getReason(self: *const ChromeFrameReporterReader) ChromeFrameReporter.FrameDropReason {
        return self._reason;
    }
    pub inline fn getFrameSource(self: *const ChromeFrameReporterReader) u64 {
        return self._frame_source;
    }
    pub inline fn getFrameSequence(self: *const ChromeFrameReporterReader) u64 {
        return self._frame_sequence;
    }
    pub inline fn getAffectsSmoothness(self: *const ChromeFrameReporterReader) bool {
        return self._affects_smoothness;
    }
    pub inline fn getScrollState(self: *const ChromeFrameReporterReader) ChromeFrameReporter.ScrollState {
        return self._scroll_state;
    }
    pub inline fn getHasMainAnimation(self: *const ChromeFrameReporterReader) bool {
        return self._has_main_animation;
    }
    pub inline fn getHasCompositorAnimation(self: *const ChromeFrameReporterReader) bool {
        return self._has_compositor_animation;
    }
    pub inline fn getHasSmoothInputMain(self: *const ChromeFrameReporterReader) bool {
        return self._has_smooth_input_main;
    }
    pub inline fn getHasMissingContent(self: *const ChromeFrameReporterReader) bool {
        return self._has_missing_content;
    }
    pub inline fn getLayerTreeHostId(self: *const ChromeFrameReporterReader) u64 {
        return self._layer_tree_host_id;
    }
    pub inline fn getHasHighLatency(self: *const ChromeFrameReporterReader) bool {
        return self._has_high_latency;
    }
    pub inline fn getFrameType(self: *const ChromeFrameReporterReader) ChromeFrameReporter.FrameType {
        return self._frame_type;
    }
    pub fn highLatencyContributionStageCount(self: *const ChromeFrameReporterReader) usize {
        return self._high_latency_contribution_stage_cnt;
    }
    pub fn highLatencyContributionStageNext(self: *ChromeFrameReporterReader) ?[]const u8 {
        if (self._high_latency_contribution_stage_offset == null) return null;
        const current_offset = self._high_latency_contribution_stage_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._high_latency_contribution_stage_last_offset != null and current_offset >= self._high_latency_contribution_stage_last_offset.?) {
            self._high_latency_contribution_stage_offset = null;
            return result.value;
        }
        if (self._high_latency_contribution_stage_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._high_latency_contribution_stage_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ChromeFrameReporterWire.HIGH_LATENCY_CONTRIBUTION_STAGE_WIRE) {
                self._high_latency_contribution_stage_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._high_latency_contribution_stage_offset = null;
        return result.value;
    }
    pub inline fn getCheckerboardedNeedsRaster(self: *const ChromeFrameReporterReader) bool {
        return self._checkerboarded_needs_raster;
    }
    pub inline fn getCheckerboardedNeedsRecord(self: *const ChromeFrameReporterReader) bool {
        return self._checkerboarded_needs_record;
    }
    pub inline fn getSurfaceFrameTraceId(self: *const ChromeFrameReporterReader) i64 {
        return self._surface_frame_trace_id;
    }
    pub inline fn getDisplayTraceId(self: *const ChromeFrameReporterReader) i64 {
        return self._display_trace_id;
    }
};
