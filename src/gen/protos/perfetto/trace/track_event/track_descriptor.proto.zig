// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
const process_descriptor = @import("process_descriptor.proto.zig");
const chrome_process_descriptor = @import("chrome_process_descriptor.proto.zig");
const thread_descriptor = @import("thread_descriptor.proto.zig");
const chrome_thread_descriptor = @import("chrome_thread_descriptor.proto.zig");
const counter_descriptor = @import("counter_descriptor.proto.zig");
// structs
const TrackDescriptorWire = struct {
    const UUID_WIRE: gremlin.ProtoWireNumber = 1;
    const PARENT_UUID_WIRE: gremlin.ProtoWireNumber = 5;
    const DESCRIPTION_WIRE: gremlin.ProtoWireNumber = 14;
    const PROCESS_WIRE: gremlin.ProtoWireNumber = 3;
    const CHROME_PROCESS_WIRE: gremlin.ProtoWireNumber = 6;
    const THREAD_WIRE: gremlin.ProtoWireNumber = 4;
    const CHROME_THREAD_WIRE: gremlin.ProtoWireNumber = 7;
    const COUNTER_WIRE: gremlin.ProtoWireNumber = 8;
    const DISALLOW_MERGING_WITH_SYSTEM_TRACKS_WIRE: gremlin.ProtoWireNumber = 9;
    const CHILD_ORDERING_WIRE: gremlin.ProtoWireNumber = 11;
    const SIBLING_ORDER_RANK_WIRE: gremlin.ProtoWireNumber = 12;
    const SIBLING_MERGE_BEHAVIOR_WIRE: gremlin.ProtoWireNumber = 15;
    const NAME_WIRE: gremlin.ProtoWireNumber = 2;
    const STATIC_NAME_WIRE: gremlin.ProtoWireNumber = 10;
    const ATRACE_NAME_WIRE: gremlin.ProtoWireNumber = 13;
    const SIBLING_MERGE_KEY_WIRE: gremlin.ProtoWireNumber = 16;
    const SIBLING_MERGE_KEY_INT_WIRE: gremlin.ProtoWireNumber = 17;
};
pub const TrackDescriptor = struct {
    // nested enums
    pub const ChildTracksOrdering = enum(i32) {
        UNKNOWN = 0,
        LEXICOGRAPHIC = 1,
        CHRONOLOGICAL = 2,
        EXPLICIT = 3,
    };
    pub const SiblingMergeBehavior = enum(i32) {
        SIBLING_MERGE_BEHAVIOR_UNSPECIFIED = 0,
        SIBLING_MERGE_BEHAVIOR_BY_TRACK_NAME = 1,
        SIBLING_MERGE_BEHAVIOR_NONE = 2,
        SIBLING_MERGE_BEHAVIOR_BY_SIBLING_MERGE_KEY = 3,
    };
    // fields
    uuid: u64 = 0,
    parent_uuid: u64 = 0,
    description: ?[]const u8 = null,
    process: ?process_descriptor.ProcessDescriptor = null,
    chrome_process: ?chrome_process_descriptor.ChromeProcessDescriptor = null,
    thread: ?thread_descriptor.ThreadDescriptor = null,
    chrome_thread: ?chrome_thread_descriptor.ChromeThreadDescriptor = null,
    counter: ?counter_descriptor.CounterDescriptor = null,
    disallow_merging_with_system_tracks: bool = false,
    child_ordering: TrackDescriptor.ChildTracksOrdering = @enumFromInt(0),
    sibling_order_rank: i32 = 0,
    sibling_merge_behavior: TrackDescriptor.SiblingMergeBehavior = @enumFromInt(0),
    name: ?[]const u8 = null,
    static_name: ?[]const u8 = null,
    atrace_name: ?[]const u8 = null,
    sibling_merge_key: ?[]const u8 = null,
    sibling_merge_key_int: u64 = 0,
    pub fn calcProtobufSize(self: *const TrackDescriptor) usize {
        var res: usize = 0;
        if (self.uuid != 0) {
            res += gremlin.sizes.sizeWireNumber(TrackDescriptorWire.UUID_WIRE) + gremlin.sizes.sizeU64(self.uuid);
        }
        if (self.parent_uuid != 0) {
            res += gremlin.sizes.sizeWireNumber(TrackDescriptorWire.PARENT_UUID_WIRE) + gremlin.sizes.sizeU64(self.parent_uuid);
        }
        if (self.description) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TrackDescriptorWire.DESCRIPTION_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.process) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TrackDescriptorWire.PROCESS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_process) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TrackDescriptorWire.CHROME_PROCESS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.thread) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TrackDescriptorWire.THREAD_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_thread) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TrackDescriptorWire.CHROME_THREAD_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.counter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TrackDescriptorWire.COUNTER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.disallow_merging_with_system_tracks != false) {
            res += gremlin.sizes.sizeWireNumber(TrackDescriptorWire.DISALLOW_MERGING_WITH_SYSTEM_TRACKS_WIRE) + gremlin.sizes.sizeBool(self.disallow_merging_with_system_tracks);
        }
        if (@intFromEnum(self.child_ordering) != 0) {
            res += gremlin.sizes.sizeWireNumber(TrackDescriptorWire.CHILD_ORDERING_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.child_ordering));
        }
        if (self.sibling_order_rank != 0) {
            res += gremlin.sizes.sizeWireNumber(TrackDescriptorWire.SIBLING_ORDER_RANK_WIRE) + gremlin.sizes.sizeI32(self.sibling_order_rank);
        }
        if (@intFromEnum(self.sibling_merge_behavior) != 0) {
            res += gremlin.sizes.sizeWireNumber(TrackDescriptorWire.SIBLING_MERGE_BEHAVIOR_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.sibling_merge_behavior));
        }
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TrackDescriptorWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.static_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TrackDescriptorWire.STATIC_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.atrace_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TrackDescriptorWire.ATRACE_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.sibling_merge_key) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TrackDescriptorWire.SIBLING_MERGE_KEY_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.sibling_merge_key_int != 0) {
            res += gremlin.sizes.sizeWireNumber(TrackDescriptorWire.SIBLING_MERGE_KEY_INT_WIRE) + gremlin.sizes.sizeU64(self.sibling_merge_key_int);
        }
        return res;
    }
    pub fn encode(self: *const TrackDescriptor, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TrackDescriptor, target: *gremlin.Writer) void {
        if (self.uuid != 0) {
            target.appendUint64(TrackDescriptorWire.UUID_WIRE, self.uuid);
        }
        if (self.parent_uuid != 0) {
            target.appendUint64(TrackDescriptorWire.PARENT_UUID_WIRE, self.parent_uuid);
        }
        if (self.description) |v| {
            if (v.len > 0) {
                target.appendBytes(TrackDescriptorWire.DESCRIPTION_WIRE, v);
            }
        }
        if (self.process) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TrackDescriptorWire.PROCESS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_process) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TrackDescriptorWire.CHROME_PROCESS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.thread) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TrackDescriptorWire.THREAD_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_thread) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TrackDescriptorWire.CHROME_THREAD_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.counter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TrackDescriptorWire.COUNTER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.disallow_merging_with_system_tracks != false) {
            target.appendBool(TrackDescriptorWire.DISALLOW_MERGING_WITH_SYSTEM_TRACKS_WIRE, self.disallow_merging_with_system_tracks);
        }
        if (@intFromEnum(self.child_ordering) != 0) {
            target.appendInt32(TrackDescriptorWire.CHILD_ORDERING_WIRE, @intFromEnum(self.child_ordering));
        }
        if (self.sibling_order_rank != 0) {
            target.appendInt32(TrackDescriptorWire.SIBLING_ORDER_RANK_WIRE, self.sibling_order_rank);
        }
        if (@intFromEnum(self.sibling_merge_behavior) != 0) {
            target.appendInt32(TrackDescriptorWire.SIBLING_MERGE_BEHAVIOR_WIRE, @intFromEnum(self.sibling_merge_behavior));
        }
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(TrackDescriptorWire.NAME_WIRE, v);
            }
        }
        if (self.static_name) |v| {
            if (v.len > 0) {
                target.appendBytes(TrackDescriptorWire.STATIC_NAME_WIRE, v);
            }
        }
        if (self.atrace_name) |v| {
            if (v.len > 0) {
                target.appendBytes(TrackDescriptorWire.ATRACE_NAME_WIRE, v);
            }
        }
        if (self.sibling_merge_key) |v| {
            if (v.len > 0) {
                target.appendBytes(TrackDescriptorWire.SIBLING_MERGE_KEY_WIRE, v);
            }
        }
        if (self.sibling_merge_key_int != 0) {
            target.appendUint64(TrackDescriptorWire.SIBLING_MERGE_KEY_INT_WIRE, self.sibling_merge_key_int);
        }
    }
};
pub const TrackDescriptorReader = struct {
    buf: gremlin.Reader,
    _uuid: u64 = 0,
    _parent_uuid: u64 = 0,
    _description: ?[]const u8 = null,
    _process_buf: ?[]const u8 = null,
    _chrome_process_buf: ?[]const u8 = null,
    _thread_buf: ?[]const u8 = null,
    _chrome_thread_buf: ?[]const u8 = null,
    _counter_buf: ?[]const u8 = null,
    _disallow_merging_with_system_tracks: bool = false,
    _child_ordering: TrackDescriptor.ChildTracksOrdering = @enumFromInt(0),
    _sibling_order_rank: i32 = 0,
    _sibling_merge_behavior: TrackDescriptor.SiblingMergeBehavior = @enumFromInt(0),
    _name: ?[]const u8 = null,
    _static_name: ?[]const u8 = null,
    _atrace_name: ?[]const u8 = null,
    _sibling_merge_key: ?[]const u8 = null,
    _sibling_merge_key_int: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!TrackDescriptorReader {
        const buf = gremlin.Reader.init(src);
        var res = TrackDescriptorReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TrackDescriptorWire.UUID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._uuid = result.value;
                },
                TrackDescriptorWire.PARENT_UUID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._parent_uuid = result.value;
                },
                TrackDescriptorWire.DESCRIPTION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._description = result.value;
                },
                TrackDescriptorWire.PROCESS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._process_buf = result.value;
                },
                TrackDescriptorWire.CHROME_PROCESS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_process_buf = result.value;
                },
                TrackDescriptorWire.THREAD_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._thread_buf = result.value;
                },
                TrackDescriptorWire.CHROME_THREAD_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_thread_buf = result.value;
                },
                TrackDescriptorWire.COUNTER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._counter_buf = result.value;
                },
                TrackDescriptorWire.DISALLOW_MERGING_WITH_SYSTEM_TRACKS_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._disallow_merging_with_system_tracks = result.value;
                },
                TrackDescriptorWire.CHILD_ORDERING_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._child_ordering = @enumFromInt(result.value);
                },
                TrackDescriptorWire.SIBLING_ORDER_RANK_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._sibling_order_rank = result.value;
                },
                TrackDescriptorWire.SIBLING_MERGE_BEHAVIOR_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._sibling_merge_behavior = @enumFromInt(result.value);
                },
                TrackDescriptorWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                TrackDescriptorWire.STATIC_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._static_name = result.value;
                },
                TrackDescriptorWire.ATRACE_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._atrace_name = result.value;
                },
                TrackDescriptorWire.SIBLING_MERGE_KEY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._sibling_merge_key = result.value;
                },
                TrackDescriptorWire.SIBLING_MERGE_KEY_INT_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._sibling_merge_key_int = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getUuid(self: *const TrackDescriptorReader) u64 {
        return self._uuid;
    }
    pub inline fn getParentUuid(self: *const TrackDescriptorReader) u64 {
        return self._parent_uuid;
    }
    pub inline fn getDescription(self: *const TrackDescriptorReader) []const u8 {
        return self._description orelse &[_]u8{};
    }
    pub fn getProcess(self: *const TrackDescriptorReader) gremlin.Error!process_descriptor.ProcessDescriptorReader {
        if (self._process_buf) |buf| {
            return try process_descriptor.ProcessDescriptorReader.init(buf);
        }
        return try process_descriptor.ProcessDescriptorReader.init(&[_]u8{});
    }
    pub fn getChromeProcess(self: *const TrackDescriptorReader) gremlin.Error!chrome_process_descriptor.ChromeProcessDescriptorReader {
        if (self._chrome_process_buf) |buf| {
            return try chrome_process_descriptor.ChromeProcessDescriptorReader.init(buf);
        }
        return try chrome_process_descriptor.ChromeProcessDescriptorReader.init(&[_]u8{});
    }
    pub fn getThread(self: *const TrackDescriptorReader) gremlin.Error!thread_descriptor.ThreadDescriptorReader {
        if (self._thread_buf) |buf| {
            return try thread_descriptor.ThreadDescriptorReader.init(buf);
        }
        return try thread_descriptor.ThreadDescriptorReader.init(&[_]u8{});
    }
    pub fn getChromeThread(self: *const TrackDescriptorReader) gremlin.Error!chrome_thread_descriptor.ChromeThreadDescriptorReader {
        if (self._chrome_thread_buf) |buf| {
            return try chrome_thread_descriptor.ChromeThreadDescriptorReader.init(buf);
        }
        return try chrome_thread_descriptor.ChromeThreadDescriptorReader.init(&[_]u8{});
    }
    pub fn getCounter(self: *const TrackDescriptorReader) gremlin.Error!counter_descriptor.CounterDescriptorReader {
        if (self._counter_buf) |buf| {
            return try counter_descriptor.CounterDescriptorReader.init(buf);
        }
        return try counter_descriptor.CounterDescriptorReader.init(&[_]u8{});
    }
    pub inline fn getDisallowMergingWithSystemTracks(self: *const TrackDescriptorReader) bool {
        return self._disallow_merging_with_system_tracks;
    }
    pub inline fn getChildOrdering(self: *const TrackDescriptorReader) TrackDescriptor.ChildTracksOrdering {
        return self._child_ordering;
    }
    pub inline fn getSiblingOrderRank(self: *const TrackDescriptorReader) i32 {
        return self._sibling_order_rank;
    }
    pub inline fn getSiblingMergeBehavior(self: *const TrackDescriptorReader) TrackDescriptor.SiblingMergeBehavior {
        return self._sibling_merge_behavior;
    }
    pub inline fn getName(self: *const TrackDescriptorReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub inline fn getStaticName(self: *const TrackDescriptorReader) []const u8 {
        return self._static_name orelse &[_]u8{};
    }
    pub inline fn getAtraceName(self: *const TrackDescriptorReader) []const u8 {
        return self._atrace_name orelse &[_]u8{};
    }
    pub inline fn getSiblingMergeKey(self: *const TrackDescriptorReader) []const u8 {
        return self._sibling_merge_key orelse &[_]u8{};
    }
    pub inline fn getSiblingMergeKeyInt(self: *const TrackDescriptorReader) u64 {
        return self._sibling_merge_key_int;
    }
};
