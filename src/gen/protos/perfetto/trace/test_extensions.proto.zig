// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
const track_event = @import("src/gen/protos/perfetto/trace/track_event/track_event.proto.zig");
const debug_annotation = @import("src/gen/protos/perfetto/trace/track_event/debug_annotation.proto.zig");
const task_execution = @import("src/gen/protos/perfetto/trace/track_event/task_execution.proto.zig");
const log_message = @import("src/gen/protos/perfetto/trace/track_event/log_message.proto.zig");
const chrome_compositor_scheduler_state = @import("src/gen/protos/perfetto/trace/track_event/chrome_compositor_scheduler_state.proto.zig");
const chrome_user_event = @import("src/gen/protos/perfetto/trace/track_event/chrome_user_event.proto.zig");
const chrome_keyed_service = @import("src/gen/protos/perfetto/trace/track_event/chrome_keyed_service.proto.zig");
const chrome_legacy_ipc = @import("src/gen/protos/perfetto/trace/track_event/chrome_legacy_ipc.proto.zig");
const chrome_histogram_sample = @import("src/gen/protos/perfetto/trace/track_event/chrome_histogram_sample.proto.zig");
const chrome_latency_info = @import("src/gen/protos/perfetto/trace/track_event/chrome_latency_info.proto.zig");
const chrome_frame_reporter = @import("src/gen/protos/perfetto/trace/track_event/chrome_frame_reporter.proto.zig");
const chrome_application_state_info = @import("src/gen/protos/perfetto/trace/track_event/chrome_application_state_info.proto.zig");
const chrome_renderer_scheduler_state = @import("src/gen/protos/perfetto/trace/track_event/chrome_renderer_scheduler_state.proto.zig");
const chrome_window_handle_event_info = @import("src/gen/protos/perfetto/trace/track_event/chrome_window_handle_event_info.proto.zig");
const chrome_content_settings_event_info = @import("src/gen/protos/perfetto/trace/track_event/chrome_content_settings_event_info.proto.zig");
const chrome_active_processes = @import("src/gen/protos/perfetto/trace/track_event/chrome_active_processes.proto.zig");
const screenshot = @import("src/gen/protos/perfetto/trace/track_event/screenshot.proto.zig");
const chrome_message_pump = @import("src/gen/protos/perfetto/trace/track_event/chrome_message_pump.proto.zig");
const chrome_mojo_event_info = @import("src/gen/protos/perfetto/trace/track_event/chrome_mojo_event_info.proto.zig");
const source_location = @import("src/gen/protos/perfetto/trace/track_event/source_location.proto.zig");
// structs
const TestExtensionWire = struct {
    const CATEGORY_IIDS_WIRE: gremlin.ProtoWireNumber = 3;
    const CATEGORIES_WIRE: gremlin.ProtoWireNumber = 22;
    const TYPE_WIRE: gremlin.ProtoWireNumber = 9;
    const TRACK_UUID_WIRE: gremlin.ProtoWireNumber = 11;
    const EXTRA_COUNTER_TRACK_UUIDS_WIRE: gremlin.ProtoWireNumber = 31;
    const EXTRA_COUNTER_VALUES_WIRE: gremlin.ProtoWireNumber = 12;
    const EXTRA_DOUBLE_COUNTER_TRACK_UUIDS_WIRE: gremlin.ProtoWireNumber = 45;
    const EXTRA_DOUBLE_COUNTER_VALUES_WIRE: gremlin.ProtoWireNumber = 46;
    const FLOW_IDS_OLD_WIRE: gremlin.ProtoWireNumber = 36;
    const FLOW_IDS_WIRE: gremlin.ProtoWireNumber = 47;
    const TERMINATING_FLOW_IDS_OLD_WIRE: gremlin.ProtoWireNumber = 42;
    const TERMINATING_FLOW_IDS_WIRE: gremlin.ProtoWireNumber = 48;
    const DEBUG_ANNOTATIONS_WIRE: gremlin.ProtoWireNumber = 4;
    const TASK_EXECUTION_WIRE: gremlin.ProtoWireNumber = 5;
    const LOG_MESSAGE_WIRE: gremlin.ProtoWireNumber = 21;
    const CC_SCHEDULER_STATE_WIRE: gremlin.ProtoWireNumber = 24;
    const CHROME_USER_EVENT_WIRE: gremlin.ProtoWireNumber = 25;
    const CHROME_KEYED_SERVICE_WIRE: gremlin.ProtoWireNumber = 26;
    const CHROME_LEGACY_IPC_WIRE: gremlin.ProtoWireNumber = 27;
    const CHROME_HISTOGRAM_SAMPLE_WIRE: gremlin.ProtoWireNumber = 28;
    const CHROME_LATENCY_INFO_WIRE: gremlin.ProtoWireNumber = 29;
    const CHROME_FRAME_REPORTER_WIRE: gremlin.ProtoWireNumber = 32;
    const CHROME_APPLICATION_STATE_INFO_WIRE: gremlin.ProtoWireNumber = 39;
    const CHROME_RENDERER_SCHEDULER_STATE_WIRE: gremlin.ProtoWireNumber = 40;
    const CHROME_WINDOW_HANDLE_EVENT_INFO_WIRE: gremlin.ProtoWireNumber = 41;
    const CHROME_CONTENT_SETTINGS_EVENT_INFO_WIRE: gremlin.ProtoWireNumber = 43;
    const CHROME_ACTIVE_PROCESSES_WIRE: gremlin.ProtoWireNumber = 49;
    const SCREENSHOT_WIRE: gremlin.ProtoWireNumber = 50;
    const CHROME_MESSAGE_PUMP_WIRE: gremlin.ProtoWireNumber = 35;
    const CHROME_MOJO_EVENT_INFO_WIRE: gremlin.ProtoWireNumber = 38;
    const LEGACY_EVENT_WIRE: gremlin.ProtoWireNumber = 6;
    const NAME_IID_WIRE: gremlin.ProtoWireNumber = 10;
    const NAME_WIRE: gremlin.ProtoWireNumber = 23;
    const COUNTER_VALUE_WIRE: gremlin.ProtoWireNumber = 30;
    const DOUBLE_COUNTER_VALUE_WIRE: gremlin.ProtoWireNumber = 44;
    const CORRELATION_ID_WIRE: gremlin.ProtoWireNumber = 52;
    const CORRELATION_ID_STR_WIRE: gremlin.ProtoWireNumber = 53;
    const CORRELATION_ID_STR_IID_WIRE: gremlin.ProtoWireNumber = 54;
    const CALLSTACK_WIRE: gremlin.ProtoWireNumber = 55;
    const CALLSTACK_IID_WIRE: gremlin.ProtoWireNumber = 56;
    const SOURCE_LOCATION_WIRE: gremlin.ProtoWireNumber = 33;
    const SOURCE_LOCATION_IID_WIRE: gremlin.ProtoWireNumber = 34;
    const TIMESTAMP_DELTA_US_WIRE: gremlin.ProtoWireNumber = 1;
    const TIMESTAMP_ABSOLUTE_US_WIRE: gremlin.ProtoWireNumber = 16;
    const THREAD_TIME_DELTA_US_WIRE: gremlin.ProtoWireNumber = 2;
    const THREAD_TIME_ABSOLUTE_US_WIRE: gremlin.ProtoWireNumber = 17;
    const THREAD_INSTRUCTION_COUNT_DELTA_WIRE: gremlin.ProtoWireNumber = 8;
    const THREAD_INSTRUCTION_COUNT_ABSOLUTE_WIRE: gremlin.ProtoWireNumber = 20;
};
pub const TestExtension = struct {
    // fields
    category_iids: ?[]const u64 = null,
    categories: ?[]const ?[]const u8 = null,
    type: track_event.TrackEvent.Type = @enumFromInt(0),
    track_uuid: u64 = 0,
    extra_counter_track_uuids: ?[]const u64 = null,
    extra_counter_values: ?[]const i64 = null,
    extra_double_counter_track_uuids: ?[]const u64 = null,
    extra_double_counter_values: ?[]const f64 = null,
    flow_ids_old: ?[]const u64 = null,
    flow_ids: ?[]const u64 = null,
    terminating_flow_ids_old: ?[]const u64 = null,
    terminating_flow_ids: ?[]const u64 = null,
    debug_annotations: ?[]const ?debug_annotation.DebugAnnotation = null,
    task_execution: ?task_execution.TaskExecution = null,
    log_message: ?log_message.LogMessage = null,
    cc_scheduler_state: ?chrome_compositor_scheduler_state.ChromeCompositorSchedulerState = null,
    chrome_user_event: ?chrome_user_event.ChromeUserEvent = null,
    chrome_keyed_service: ?chrome_keyed_service.ChromeKeyedService = null,
    chrome_legacy_ipc: ?chrome_legacy_ipc.ChromeLegacyIpc = null,
    chrome_histogram_sample: ?chrome_histogram_sample.ChromeHistogramSample = null,
    chrome_latency_info: ?chrome_latency_info.ChromeLatencyInfo = null,
    chrome_frame_reporter: ?chrome_frame_reporter.ChromeFrameReporter = null,
    chrome_application_state_info: ?chrome_application_state_info.ChromeApplicationStateInfo = null,
    chrome_renderer_scheduler_state: ?chrome_renderer_scheduler_state.ChromeRendererSchedulerState = null,
    chrome_window_handle_event_info: ?chrome_window_handle_event_info.ChromeWindowHandleEventInfo = null,
    chrome_content_settings_event_info: ?chrome_content_settings_event_info.ChromeContentSettingsEventInfo = null,
    chrome_active_processes: ?chrome_active_processes.ChromeActiveProcesses = null,
    screenshot: ?screenshot.Screenshot = null,
    chrome_message_pump: ?chrome_message_pump.ChromeMessagePump = null,
    chrome_mojo_event_info: ?chrome_mojo_event_info.ChromeMojoEventInfo = null,
    legacy_event: ?track_event.TrackEvent.LegacyEvent = null,
    name_iid: u64 = 0,
    name: ?[]const u8 = null,
    counter_value: i64 = 0,
    double_counter_value: f64 = 0.0,
    correlation_id: u64 = 0,
    correlation_id_str: ?[]const u8 = null,
    correlation_id_str_iid: u64 = 0,
    callstack: ?track_event.TrackEvent.Callstack = null,
    callstack_iid: u64 = 0,
    source_location: ?source_location.SourceLocation = null,
    source_location_iid: u64 = 0,
    timestamp_delta_us: i64 = 0,
    timestamp_absolute_us: i64 = 0,
    thread_time_delta_us: i64 = 0,
    thread_time_absolute_us: i64 = 0,
    thread_instruction_count_delta: i64 = 0,
    thread_instruction_count_absolute: i64 = 0,
    pub fn calcProtobufSize(self: *const TestExtension) usize {
        var res: usize = 0;
        if (self.category_iids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(TestExtensionWire.CATEGORY_IIDS_WIRE) + gremlin.sizes.sizeU64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                res += gremlin.sizes.sizeWireNumber(TestExtensionWire.CATEGORY_IIDS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.categories) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TestExtensionWire.CATEGORIES_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (@intFromEnum(self.type) != 0) {
            res += gremlin.sizes.sizeWireNumber(TestExtensionWire.TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.type));
        }
        if (self.track_uuid != 0) {
            res += gremlin.sizes.sizeWireNumber(TestExtensionWire.TRACK_UUID_WIRE) + gremlin.sizes.sizeU64(self.track_uuid);
        }
        if (self.extra_counter_track_uuids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(TestExtensionWire.EXTRA_COUNTER_TRACK_UUIDS_WIRE) + gremlin.sizes.sizeU64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                res += gremlin.sizes.sizeWireNumber(TestExtensionWire.EXTRA_COUNTER_TRACK_UUIDS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.extra_counter_values) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(TestExtensionWire.EXTRA_COUNTER_VALUES_WIRE) + gremlin.sizes.sizeI64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI64(v);
                }
                res += gremlin.sizes.sizeWireNumber(TestExtensionWire.EXTRA_COUNTER_VALUES_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.extra_double_counter_track_uuids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(TestExtensionWire.EXTRA_DOUBLE_COUNTER_TRACK_UUIDS_WIRE) + gremlin.sizes.sizeU64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                res += gremlin.sizes.sizeWireNumber(TestExtensionWire.EXTRA_DOUBLE_COUNTER_TRACK_UUIDS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.extra_double_counter_values) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(TestExtensionWire.EXTRA_DOUBLE_COUNTER_VALUES_WIRE) + gremlin.sizes.sizeDouble(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeDouble(v);
                }
                res += gremlin.sizes.sizeWireNumber(TestExtensionWire.EXTRA_DOUBLE_COUNTER_VALUES_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.flow_ids_old) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(TestExtensionWire.FLOW_IDS_OLD_WIRE) + gremlin.sizes.sizeU64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                res += gremlin.sizes.sizeWireNumber(TestExtensionWire.FLOW_IDS_OLD_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.flow_ids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(TestExtensionWire.FLOW_IDS_WIRE) + gremlin.sizes.sizeFixed64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeFixed64(v);
                }
                res += gremlin.sizes.sizeWireNumber(TestExtensionWire.FLOW_IDS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.terminating_flow_ids_old) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(TestExtensionWire.TERMINATING_FLOW_IDS_OLD_WIRE) + gremlin.sizes.sizeU64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                res += gremlin.sizes.sizeWireNumber(TestExtensionWire.TERMINATING_FLOW_IDS_OLD_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.terminating_flow_ids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(TestExtensionWire.TERMINATING_FLOW_IDS_WIRE) + gremlin.sizes.sizeFixed64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeFixed64(v);
                }
                res += gremlin.sizes.sizeWireNumber(TestExtensionWire.TERMINATING_FLOW_IDS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.debug_annotations) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TestExtensionWire.DEBUG_ANNOTATIONS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.task_execution) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TestExtensionWire.TASK_EXECUTION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.log_message) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TestExtensionWire.LOG_MESSAGE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cc_scheduler_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TestExtensionWire.CC_SCHEDULER_STATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_user_event) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TestExtensionWire.CHROME_USER_EVENT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_keyed_service) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TestExtensionWire.CHROME_KEYED_SERVICE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_legacy_ipc) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TestExtensionWire.CHROME_LEGACY_IPC_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_histogram_sample) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TestExtensionWire.CHROME_HISTOGRAM_SAMPLE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_latency_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TestExtensionWire.CHROME_LATENCY_INFO_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_frame_reporter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TestExtensionWire.CHROME_FRAME_REPORTER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_application_state_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TestExtensionWire.CHROME_APPLICATION_STATE_INFO_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_renderer_scheduler_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TestExtensionWire.CHROME_RENDERER_SCHEDULER_STATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_window_handle_event_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TestExtensionWire.CHROME_WINDOW_HANDLE_EVENT_INFO_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_content_settings_event_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TestExtensionWire.CHROME_CONTENT_SETTINGS_EVENT_INFO_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_active_processes) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TestExtensionWire.CHROME_ACTIVE_PROCESSES_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.screenshot) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TestExtensionWire.SCREENSHOT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_message_pump) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TestExtensionWire.CHROME_MESSAGE_PUMP_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_mojo_event_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TestExtensionWire.CHROME_MOJO_EVENT_INFO_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.legacy_event) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TestExtensionWire.LEGACY_EVENT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.name_iid != 0) {
            res += gremlin.sizes.sizeWireNumber(TestExtensionWire.NAME_IID_WIRE) + gremlin.sizes.sizeU64(self.name_iid);
        }
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TestExtensionWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.counter_value != 0) {
            res += gremlin.sizes.sizeWireNumber(TestExtensionWire.COUNTER_VALUE_WIRE) + gremlin.sizes.sizeI64(self.counter_value);
        }
        if (self.double_counter_value != 0.0) {
            res += gremlin.sizes.sizeWireNumber(TestExtensionWire.DOUBLE_COUNTER_VALUE_WIRE) + gremlin.sizes.sizeDouble(self.double_counter_value);
        }
        if (self.correlation_id != 0) {
            res += gremlin.sizes.sizeWireNumber(TestExtensionWire.CORRELATION_ID_WIRE) + gremlin.sizes.sizeU64(self.correlation_id);
        }
        if (self.correlation_id_str) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TestExtensionWire.CORRELATION_ID_STR_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.correlation_id_str_iid != 0) {
            res += gremlin.sizes.sizeWireNumber(TestExtensionWire.CORRELATION_ID_STR_IID_WIRE) + gremlin.sizes.sizeU64(self.correlation_id_str_iid);
        }
        if (self.callstack) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TestExtensionWire.CALLSTACK_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.callstack_iid != 0) {
            res += gremlin.sizes.sizeWireNumber(TestExtensionWire.CALLSTACK_IID_WIRE) + gremlin.sizes.sizeU64(self.callstack_iid);
        }
        if (self.source_location) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TestExtensionWire.SOURCE_LOCATION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.source_location_iid != 0) {
            res += gremlin.sizes.sizeWireNumber(TestExtensionWire.SOURCE_LOCATION_IID_WIRE) + gremlin.sizes.sizeU64(self.source_location_iid);
        }
        if (self.timestamp_delta_us != 0) {
            res += gremlin.sizes.sizeWireNumber(TestExtensionWire.TIMESTAMP_DELTA_US_WIRE) + gremlin.sizes.sizeI64(self.timestamp_delta_us);
        }
        if (self.timestamp_absolute_us != 0) {
            res += gremlin.sizes.sizeWireNumber(TestExtensionWire.TIMESTAMP_ABSOLUTE_US_WIRE) + gremlin.sizes.sizeI64(self.timestamp_absolute_us);
        }
        if (self.thread_time_delta_us != 0) {
            res += gremlin.sizes.sizeWireNumber(TestExtensionWire.THREAD_TIME_DELTA_US_WIRE) + gremlin.sizes.sizeI64(self.thread_time_delta_us);
        }
        if (self.thread_time_absolute_us != 0) {
            res += gremlin.sizes.sizeWireNumber(TestExtensionWire.THREAD_TIME_ABSOLUTE_US_WIRE) + gremlin.sizes.sizeI64(self.thread_time_absolute_us);
        }
        if (self.thread_instruction_count_delta != 0) {
            res += gremlin.sizes.sizeWireNumber(TestExtensionWire.THREAD_INSTRUCTION_COUNT_DELTA_WIRE) + gremlin.sizes.sizeI64(self.thread_instruction_count_delta);
        }
        if (self.thread_instruction_count_absolute != 0) {
            res += gremlin.sizes.sizeWireNumber(TestExtensionWire.THREAD_INSTRUCTION_COUNT_ABSOLUTE_WIRE) + gremlin.sizes.sizeI64(self.thread_instruction_count_absolute);
        }
        return res;
    }
    pub fn encode(self: *const TestExtension, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TestExtension, target: *gremlin.Writer) void {
        if (self.category_iids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint64(TestExtensionWire.CATEGORY_IIDS_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                target.appendBytesTag(TestExtensionWire.CATEGORY_IIDS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint64WithoutTag(v);
                }
            }
        }
        if (self.categories) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(TestExtensionWire.CATEGORIES_WIRE, v);
                } else {
                    target.appendBytesTag(TestExtensionWire.CATEGORIES_WIRE, 0);
                }
            }
        }
        if (@intFromEnum(self.type) != 0) {
            target.appendInt32(TestExtensionWire.TYPE_WIRE, @intFromEnum(self.type));
        }
        if (self.track_uuid != 0) {
            target.appendUint64(TestExtensionWire.TRACK_UUID_WIRE, self.track_uuid);
        }
        if (self.extra_counter_track_uuids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint64(TestExtensionWire.EXTRA_COUNTER_TRACK_UUIDS_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                target.appendBytesTag(TestExtensionWire.EXTRA_COUNTER_TRACK_UUIDS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint64WithoutTag(v);
                }
            }
        }
        if (self.extra_counter_values) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt64(TestExtensionWire.EXTRA_COUNTER_VALUES_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI64(v);
                }
                target.appendBytesTag(TestExtensionWire.EXTRA_COUNTER_VALUES_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt64WithoutTag(v);
                }
            }
        }
        if (self.extra_double_counter_track_uuids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint64(TestExtensionWire.EXTRA_DOUBLE_COUNTER_TRACK_UUIDS_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                target.appendBytesTag(TestExtensionWire.EXTRA_DOUBLE_COUNTER_TRACK_UUIDS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint64WithoutTag(v);
                }
            }
        }
        if (self.extra_double_counter_values) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendFloat64(TestExtensionWire.EXTRA_DOUBLE_COUNTER_VALUES_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeDouble(v);
                }
                target.appendBytesTag(TestExtensionWire.EXTRA_DOUBLE_COUNTER_VALUES_WIRE, packed_size);
                for (arr) |v| {
                    target.appendFloat64WithoutTag(v);
                }
            }
        }
        if (self.flow_ids_old) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint64(TestExtensionWire.FLOW_IDS_OLD_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                target.appendBytesTag(TestExtensionWire.FLOW_IDS_OLD_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint64WithoutTag(v);
                }
            }
        }
        if (self.flow_ids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendFixed64(TestExtensionWire.FLOW_IDS_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeFixed64(v);
                }
                target.appendBytesTag(TestExtensionWire.FLOW_IDS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendFixed64WithoutTag(v);
                }
            }
        }
        if (self.terminating_flow_ids_old) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint64(TestExtensionWire.TERMINATING_FLOW_IDS_OLD_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                target.appendBytesTag(TestExtensionWire.TERMINATING_FLOW_IDS_OLD_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint64WithoutTag(v);
                }
            }
        }
        if (self.terminating_flow_ids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendFixed64(TestExtensionWire.TERMINATING_FLOW_IDS_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeFixed64(v);
                }
                target.appendBytesTag(TestExtensionWire.TERMINATING_FLOW_IDS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendFixed64WithoutTag(v);
                }
            }
        }
        if (self.debug_annotations) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(TestExtensionWire.DEBUG_ANNOTATIONS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(TestExtensionWire.DEBUG_ANNOTATIONS_WIRE, 0);
                }
            }
        }
        if (self.task_execution) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TestExtensionWire.TASK_EXECUTION_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.log_message) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TestExtensionWire.LOG_MESSAGE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cc_scheduler_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TestExtensionWire.CC_SCHEDULER_STATE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_user_event) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TestExtensionWire.CHROME_USER_EVENT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_keyed_service) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TestExtensionWire.CHROME_KEYED_SERVICE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_legacy_ipc) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TestExtensionWire.CHROME_LEGACY_IPC_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_histogram_sample) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TestExtensionWire.CHROME_HISTOGRAM_SAMPLE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_latency_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TestExtensionWire.CHROME_LATENCY_INFO_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_frame_reporter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TestExtensionWire.CHROME_FRAME_REPORTER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_application_state_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TestExtensionWire.CHROME_APPLICATION_STATE_INFO_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_renderer_scheduler_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TestExtensionWire.CHROME_RENDERER_SCHEDULER_STATE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_window_handle_event_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TestExtensionWire.CHROME_WINDOW_HANDLE_EVENT_INFO_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_content_settings_event_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TestExtensionWire.CHROME_CONTENT_SETTINGS_EVENT_INFO_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_active_processes) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TestExtensionWire.CHROME_ACTIVE_PROCESSES_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.screenshot) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TestExtensionWire.SCREENSHOT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_message_pump) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TestExtensionWire.CHROME_MESSAGE_PUMP_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_mojo_event_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TestExtensionWire.CHROME_MOJO_EVENT_INFO_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.legacy_event) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TestExtensionWire.LEGACY_EVENT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.name_iid != 0) {
            target.appendUint64(TestExtensionWire.NAME_IID_WIRE, self.name_iid);
        }
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(TestExtensionWire.NAME_WIRE, v);
            }
        }
        if (self.counter_value != 0) {
            target.appendInt64(TestExtensionWire.COUNTER_VALUE_WIRE, self.counter_value);
        }
        if (self.double_counter_value != 0.0) {
            target.appendFloat64(TestExtensionWire.DOUBLE_COUNTER_VALUE_WIRE, self.double_counter_value);
        }
        if (self.correlation_id != 0) {
            target.appendUint64(TestExtensionWire.CORRELATION_ID_WIRE, self.correlation_id);
        }
        if (self.correlation_id_str) |v| {
            if (v.len > 0) {
                target.appendBytes(TestExtensionWire.CORRELATION_ID_STR_WIRE, v);
            }
        }
        if (self.correlation_id_str_iid != 0) {
            target.appendUint64(TestExtensionWire.CORRELATION_ID_STR_IID_WIRE, self.correlation_id_str_iid);
        }
        if (self.callstack) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TestExtensionWire.CALLSTACK_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.callstack_iid != 0) {
            target.appendUint64(TestExtensionWire.CALLSTACK_IID_WIRE, self.callstack_iid);
        }
        if (self.source_location) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TestExtensionWire.SOURCE_LOCATION_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.source_location_iid != 0) {
            target.appendUint64(TestExtensionWire.SOURCE_LOCATION_IID_WIRE, self.source_location_iid);
        }
        if (self.timestamp_delta_us != 0) {
            target.appendInt64(TestExtensionWire.TIMESTAMP_DELTA_US_WIRE, self.timestamp_delta_us);
        }
        if (self.timestamp_absolute_us != 0) {
            target.appendInt64(TestExtensionWire.TIMESTAMP_ABSOLUTE_US_WIRE, self.timestamp_absolute_us);
        }
        if (self.thread_time_delta_us != 0) {
            target.appendInt64(TestExtensionWire.THREAD_TIME_DELTA_US_WIRE, self.thread_time_delta_us);
        }
        if (self.thread_time_absolute_us != 0) {
            target.appendInt64(TestExtensionWire.THREAD_TIME_ABSOLUTE_US_WIRE, self.thread_time_absolute_us);
        }
        if (self.thread_instruction_count_delta != 0) {
            target.appendInt64(TestExtensionWire.THREAD_INSTRUCTION_COUNT_DELTA_WIRE, self.thread_instruction_count_delta);
        }
        if (self.thread_instruction_count_absolute != 0) {
            target.appendInt64(TestExtensionWire.THREAD_INSTRUCTION_COUNT_ABSOLUTE_WIRE, self.thread_instruction_count_absolute);
        }
    }
};
pub const TestExtensionReader = struct {
    buf: gremlin.Reader,
    _category_iids_offset: ?usize = null,
    _category_iids_last_offset: ?usize = null,
    _category_iids_packed: bool = false,
    _categories_offset: ?usize = null,
    _categories_last_offset: ?usize = null,
    _categories_cnt: usize = 0,
    _type: track_event.TrackEvent.Type = @enumFromInt(0),
    _track_uuid: u64 = 0,
    _extra_counter_track_uuids_offset: ?usize = null,
    _extra_counter_track_uuids_last_offset: ?usize = null,
    _extra_counter_track_uuids_packed: bool = false,
    _extra_counter_values_offset: ?usize = null,
    _extra_counter_values_last_offset: ?usize = null,
    _extra_counter_values_packed: bool = false,
    _extra_double_counter_track_uuids_offset: ?usize = null,
    _extra_double_counter_track_uuids_last_offset: ?usize = null,
    _extra_double_counter_track_uuids_packed: bool = false,
    _extra_double_counter_values_offset: ?usize = null,
    _extra_double_counter_values_last_offset: ?usize = null,
    _extra_double_counter_values_packed: bool = false,
    _flow_ids_old_offset: ?usize = null,
    _flow_ids_old_last_offset: ?usize = null,
    _flow_ids_old_packed: bool = false,
    _flow_ids_offset: ?usize = null,
    _flow_ids_last_offset: ?usize = null,
    _flow_ids_packed: bool = false,
    _terminating_flow_ids_old_offset: ?usize = null,
    _terminating_flow_ids_old_last_offset: ?usize = null,
    _terminating_flow_ids_old_packed: bool = false,
    _terminating_flow_ids_offset: ?usize = null,
    _terminating_flow_ids_last_offset: ?usize = null,
    _terminating_flow_ids_packed: bool = false,
    _debug_annotations_offset: ?usize = null,
    _debug_annotations_last_offset: ?usize = null,
    _debug_annotations_cnt: usize = 0,
    _task_execution_buf: ?[]const u8 = null,
    _log_message_buf: ?[]const u8 = null,
    _cc_scheduler_state_buf: ?[]const u8 = null,
    _chrome_user_event_buf: ?[]const u8 = null,
    _chrome_keyed_service_buf: ?[]const u8 = null,
    _chrome_legacy_ipc_buf: ?[]const u8 = null,
    _chrome_histogram_sample_buf: ?[]const u8 = null,
    _chrome_latency_info_buf: ?[]const u8 = null,
    _chrome_frame_reporter_buf: ?[]const u8 = null,
    _chrome_application_state_info_buf: ?[]const u8 = null,
    _chrome_renderer_scheduler_state_buf: ?[]const u8 = null,
    _chrome_window_handle_event_info_buf: ?[]const u8 = null,
    _chrome_content_settings_event_info_buf: ?[]const u8 = null,
    _chrome_active_processes_buf: ?[]const u8 = null,
    _screenshot_buf: ?[]const u8 = null,
    _chrome_message_pump_buf: ?[]const u8 = null,
    _chrome_mojo_event_info_buf: ?[]const u8 = null,
    _legacy_event_buf: ?[]const u8 = null,
    _name_iid: u64 = 0,
    _name: ?[]const u8 = null,
    _counter_value: i64 = 0,
    _double_counter_value: f64 = 0.0,
    _correlation_id: u64 = 0,
    _correlation_id_str: ?[]const u8 = null,
    _correlation_id_str_iid: u64 = 0,
    _callstack_buf: ?[]const u8 = null,
    _callstack_iid: u64 = 0,
    _source_location_buf: ?[]const u8 = null,
    _source_location_iid: u64 = 0,
    _timestamp_delta_us: i64 = 0,
    _timestamp_absolute_us: i64 = 0,
    _thread_time_delta_us: i64 = 0,
    _thread_time_absolute_us: i64 = 0,
    _thread_instruction_count_delta: i64 = 0,
    _thread_instruction_count_absolute: i64 = 0,
    pub fn init(src: []const u8) gremlin.Error!TestExtensionReader {
        const buf = gremlin.Reader.init(src);
        var res = TestExtensionReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TestExtensionWire.CATEGORY_IIDS_WIRE => {
                    if (res._category_iids_offset == null) {
                        res._category_iids_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._category_iids_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._category_iids_offset = offset + length_result.size;
                        res._category_iids_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._category_iids_last_offset.?;
                    } else {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._category_iids_last_offset = offset;
                    }
                },
                TestExtensionWire.CATEGORIES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._categories_offset == null) {
                        res._categories_offset = offset - result.size;
                    }
                    res._categories_last_offset = offset;
                    res._categories_cnt += 1;
                },
                TestExtensionWire.TYPE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._type = @enumFromInt(result.value);
                },
                TestExtensionWire.TRACK_UUID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._track_uuid = result.value;
                },
                TestExtensionWire.EXTRA_COUNTER_TRACK_UUIDS_WIRE => {
                    if (res._extra_counter_track_uuids_offset == null) {
                        res._extra_counter_track_uuids_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._extra_counter_track_uuids_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._extra_counter_track_uuids_offset = offset + length_result.size;
                        res._extra_counter_track_uuids_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._extra_counter_track_uuids_last_offset.?;
                    } else {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._extra_counter_track_uuids_last_offset = offset;
                    }
                },
                TestExtensionWire.EXTRA_COUNTER_VALUES_WIRE => {
                    if (res._extra_counter_values_offset == null) {
                        res._extra_counter_values_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._extra_counter_values_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._extra_counter_values_offset = offset + length_result.size;
                        res._extra_counter_values_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._extra_counter_values_last_offset.?;
                    } else {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._extra_counter_values_last_offset = offset;
                    }
                },
                TestExtensionWire.EXTRA_DOUBLE_COUNTER_TRACK_UUIDS_WIRE => {
                    if (res._extra_double_counter_track_uuids_offset == null) {
                        res._extra_double_counter_track_uuids_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._extra_double_counter_track_uuids_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._extra_double_counter_track_uuids_offset = offset + length_result.size;
                        res._extra_double_counter_track_uuids_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._extra_double_counter_track_uuids_last_offset.?;
                    } else {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._extra_double_counter_track_uuids_last_offset = offset;
                    }
                },
                TestExtensionWire.EXTRA_DOUBLE_COUNTER_VALUES_WIRE => {
                    if (res._extra_double_counter_values_offset == null) {
                        res._extra_double_counter_values_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._extra_double_counter_values_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._extra_double_counter_values_offset = offset + length_result.size;
                        res._extra_double_counter_values_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._extra_double_counter_values_last_offset.?;
                    } else {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._extra_double_counter_values_last_offset = offset;
                    }
                },
                TestExtensionWire.FLOW_IDS_OLD_WIRE => {
                    if (res._flow_ids_old_offset == null) {
                        res._flow_ids_old_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._flow_ids_old_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._flow_ids_old_offset = offset + length_result.size;
                        res._flow_ids_old_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._flow_ids_old_last_offset.?;
                    } else {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._flow_ids_old_last_offset = offset;
                    }
                },
                TestExtensionWire.FLOW_IDS_WIRE => {
                    if (res._flow_ids_offset == null) {
                        res._flow_ids_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._flow_ids_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._flow_ids_offset = offset + length_result.size;
                        res._flow_ids_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._flow_ids_last_offset.?;
                    } else {
                        const result = try buf.readFixed64(offset);
                        offset += result.size;
                        res._flow_ids_last_offset = offset;
                    }
                },
                TestExtensionWire.TERMINATING_FLOW_IDS_OLD_WIRE => {
                    if (res._terminating_flow_ids_old_offset == null) {
                        res._terminating_flow_ids_old_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._terminating_flow_ids_old_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._terminating_flow_ids_old_offset = offset + length_result.size;
                        res._terminating_flow_ids_old_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._terminating_flow_ids_old_last_offset.?;
                    } else {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._terminating_flow_ids_old_last_offset = offset;
                    }
                },
                TestExtensionWire.TERMINATING_FLOW_IDS_WIRE => {
                    if (res._terminating_flow_ids_offset == null) {
                        res._terminating_flow_ids_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._terminating_flow_ids_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._terminating_flow_ids_offset = offset + length_result.size;
                        res._terminating_flow_ids_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._terminating_flow_ids_last_offset.?;
                    } else {
                        const result = try buf.readFixed64(offset);
                        offset += result.size;
                        res._terminating_flow_ids_last_offset = offset;
                    }
                },
                TestExtensionWire.DEBUG_ANNOTATIONS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._debug_annotations_offset == null) {
                        res._debug_annotations_offset = offset - result.size;
                    }
                    res._debug_annotations_last_offset = offset;
                    res._debug_annotations_cnt += 1;
                },
                TestExtensionWire.TASK_EXECUTION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._task_execution_buf = result.value;
                },
                TestExtensionWire.LOG_MESSAGE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._log_message_buf = result.value;
                },
                TestExtensionWire.CC_SCHEDULER_STATE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cc_scheduler_state_buf = result.value;
                },
                TestExtensionWire.CHROME_USER_EVENT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_user_event_buf = result.value;
                },
                TestExtensionWire.CHROME_KEYED_SERVICE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_keyed_service_buf = result.value;
                },
                TestExtensionWire.CHROME_LEGACY_IPC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_legacy_ipc_buf = result.value;
                },
                TestExtensionWire.CHROME_HISTOGRAM_SAMPLE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_histogram_sample_buf = result.value;
                },
                TestExtensionWire.CHROME_LATENCY_INFO_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_latency_info_buf = result.value;
                },
                TestExtensionWire.CHROME_FRAME_REPORTER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_frame_reporter_buf = result.value;
                },
                TestExtensionWire.CHROME_APPLICATION_STATE_INFO_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_application_state_info_buf = result.value;
                },
                TestExtensionWire.CHROME_RENDERER_SCHEDULER_STATE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_renderer_scheduler_state_buf = result.value;
                },
                TestExtensionWire.CHROME_WINDOW_HANDLE_EVENT_INFO_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_window_handle_event_info_buf = result.value;
                },
                TestExtensionWire.CHROME_CONTENT_SETTINGS_EVENT_INFO_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_content_settings_event_info_buf = result.value;
                },
                TestExtensionWire.CHROME_ACTIVE_PROCESSES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_active_processes_buf = result.value;
                },
                TestExtensionWire.SCREENSHOT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._screenshot_buf = result.value;
                },
                TestExtensionWire.CHROME_MESSAGE_PUMP_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_message_pump_buf = result.value;
                },
                TestExtensionWire.CHROME_MOJO_EVENT_INFO_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_mojo_event_info_buf = result.value;
                },
                TestExtensionWire.LEGACY_EVENT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._legacy_event_buf = result.value;
                },
                TestExtensionWire.NAME_IID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._name_iid = result.value;
                },
                TestExtensionWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                TestExtensionWire.COUNTER_VALUE_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._counter_value = result.value;
                },
                TestExtensionWire.DOUBLE_COUNTER_VALUE_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._double_counter_value = result.value;
                },
                TestExtensionWire.CORRELATION_ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._correlation_id = result.value;
                },
                TestExtensionWire.CORRELATION_ID_STR_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._correlation_id_str = result.value;
                },
                TestExtensionWire.CORRELATION_ID_STR_IID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._correlation_id_str_iid = result.value;
                },
                TestExtensionWire.CALLSTACK_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._callstack_buf = result.value;
                },
                TestExtensionWire.CALLSTACK_IID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._callstack_iid = result.value;
                },
                TestExtensionWire.SOURCE_LOCATION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._source_location_buf = result.value;
                },
                TestExtensionWire.SOURCE_LOCATION_IID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._source_location_iid = result.value;
                },
                TestExtensionWire.TIMESTAMP_DELTA_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._timestamp_delta_us = result.value;
                },
                TestExtensionWire.TIMESTAMP_ABSOLUTE_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._timestamp_absolute_us = result.value;
                },
                TestExtensionWire.THREAD_TIME_DELTA_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._thread_time_delta_us = result.value;
                },
                TestExtensionWire.THREAD_TIME_ABSOLUTE_US_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._thread_time_absolute_us = result.value;
                },
                TestExtensionWire.THREAD_INSTRUCTION_COUNT_DELTA_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._thread_instruction_count_delta = result.value;
                },
                TestExtensionWire.THREAD_INSTRUCTION_COUNT_ABSOLUTE_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._thread_instruction_count_absolute = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn categoryIidsNext(self: *TestExtensionReader) gremlin.Error!?u64 {
        if (self._category_iids_offset == null) return null;
        const current_offset = self._category_iids_offset.?;
        if (current_offset >= self._category_iids_last_offset.?) {
            self._category_iids_offset = null;
            return null;
        }
        if (self._category_iids_packed) {
            const value_result = try self.buf.readUInt64(current_offset);
            self._category_iids_offset = current_offset + value_result.size;
            if (self._category_iids_offset.? >= self._category_iids_last_offset.?) {
                self._category_iids_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._category_iids_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == TestExtensionWire.CATEGORY_IIDS_WIRE) {
                    self._category_iids_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._category_iids_offset = null;
            return value_result.value;
        }
    }
    pub fn categoriesCount(self: *const TestExtensionReader) usize {
        return self._categories_cnt;
    }
    pub fn categoriesNext(self: *TestExtensionReader) ?[]const u8 {
        if (self._categories_offset == null) return null;
        const current_offset = self._categories_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._categories_last_offset != null and current_offset >= self._categories_last_offset.?) {
            self._categories_offset = null;
            return result.value;
        }
        if (self._categories_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._categories_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TestExtensionWire.CATEGORIES_WIRE) {
                self._categories_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._categories_offset = null;
        return result.value;
    }
    pub inline fn getType(self: *const TestExtensionReader) track_event.TrackEvent.Type {
        return self._type;
    }
    pub inline fn getTrackUuid(self: *const TestExtensionReader) u64 {
        return self._track_uuid;
    }
    pub fn extraCounterTrackUuidsNext(self: *TestExtensionReader) gremlin.Error!?u64 {
        if (self._extra_counter_track_uuids_offset == null) return null;
        const current_offset = self._extra_counter_track_uuids_offset.?;
        if (current_offset >= self._extra_counter_track_uuids_last_offset.?) {
            self._extra_counter_track_uuids_offset = null;
            return null;
        }
        if (self._extra_counter_track_uuids_packed) {
            const value_result = try self.buf.readUInt64(current_offset);
            self._extra_counter_track_uuids_offset = current_offset + value_result.size;
            if (self._extra_counter_track_uuids_offset.? >= self._extra_counter_track_uuids_last_offset.?) {
                self._extra_counter_track_uuids_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._extra_counter_track_uuids_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == TestExtensionWire.EXTRA_COUNTER_TRACK_UUIDS_WIRE) {
                    self._extra_counter_track_uuids_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._extra_counter_track_uuids_offset = null;
            return value_result.value;
        }
    }
    pub fn extraCounterValuesNext(self: *TestExtensionReader) gremlin.Error!?i64 {
        if (self._extra_counter_values_offset == null) return null;
        const current_offset = self._extra_counter_values_offset.?;
        if (current_offset >= self._extra_counter_values_last_offset.?) {
            self._extra_counter_values_offset = null;
            return null;
        }
        if (self._extra_counter_values_packed) {
            const value_result = try self.buf.readInt64(current_offset);
            self._extra_counter_values_offset = current_offset + value_result.size;
            if (self._extra_counter_values_offset.? >= self._extra_counter_values_last_offset.?) {
                self._extra_counter_values_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._extra_counter_values_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == TestExtensionWire.EXTRA_COUNTER_VALUES_WIRE) {
                    self._extra_counter_values_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._extra_counter_values_offset = null;
            return value_result.value;
        }
    }
    pub fn extraDoubleCounterTrackUuidsNext(self: *TestExtensionReader) gremlin.Error!?u64 {
        if (self._extra_double_counter_track_uuids_offset == null) return null;
        const current_offset = self._extra_double_counter_track_uuids_offset.?;
        if (current_offset >= self._extra_double_counter_track_uuids_last_offset.?) {
            self._extra_double_counter_track_uuids_offset = null;
            return null;
        }
        if (self._extra_double_counter_track_uuids_packed) {
            const value_result = try self.buf.readUInt64(current_offset);
            self._extra_double_counter_track_uuids_offset = current_offset + value_result.size;
            if (self._extra_double_counter_track_uuids_offset.? >= self._extra_double_counter_track_uuids_last_offset.?) {
                self._extra_double_counter_track_uuids_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._extra_double_counter_track_uuids_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == TestExtensionWire.EXTRA_DOUBLE_COUNTER_TRACK_UUIDS_WIRE) {
                    self._extra_double_counter_track_uuids_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._extra_double_counter_track_uuids_offset = null;
            return value_result.value;
        }
    }
    pub fn extraDoubleCounterValuesNext(self: *TestExtensionReader) gremlin.Error!?f64 {
        if (self._extra_double_counter_values_offset == null) return null;
        const current_offset = self._extra_double_counter_values_offset.?;
        if (current_offset >= self._extra_double_counter_values_last_offset.?) {
            self._extra_double_counter_values_offset = null;
            return null;
        }
        if (self._extra_double_counter_values_packed) {
            const value_result = try self.buf.readFloat64(current_offset);
            self._extra_double_counter_values_offset = current_offset + value_result.size;
            if (self._extra_double_counter_values_offset.? >= self._extra_double_counter_values_last_offset.?) {
                self._extra_double_counter_values_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readFloat64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._extra_double_counter_values_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == TestExtensionWire.EXTRA_DOUBLE_COUNTER_VALUES_WIRE) {
                    self._extra_double_counter_values_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._extra_double_counter_values_offset = null;
            return value_result.value;
        }
    }
    pub fn flowIdsOldNext(self: *TestExtensionReader) gremlin.Error!?u64 {
        if (self._flow_ids_old_offset == null) return null;
        const current_offset = self._flow_ids_old_offset.?;
        if (current_offset >= self._flow_ids_old_last_offset.?) {
            self._flow_ids_old_offset = null;
            return null;
        }
        if (self._flow_ids_old_packed) {
            const value_result = try self.buf.readUInt64(current_offset);
            self._flow_ids_old_offset = current_offset + value_result.size;
            if (self._flow_ids_old_offset.? >= self._flow_ids_old_last_offset.?) {
                self._flow_ids_old_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._flow_ids_old_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == TestExtensionWire.FLOW_IDS_OLD_WIRE) {
                    self._flow_ids_old_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._flow_ids_old_offset = null;
            return value_result.value;
        }
    }
    pub fn flowIdsNext(self: *TestExtensionReader) gremlin.Error!?u64 {
        if (self._flow_ids_offset == null) return null;
        const current_offset = self._flow_ids_offset.?;
        if (current_offset >= self._flow_ids_last_offset.?) {
            self._flow_ids_offset = null;
            return null;
        }
        if (self._flow_ids_packed) {
            const value_result = try self.buf.readFixed64(current_offset);
            self._flow_ids_offset = current_offset + value_result.size;
            if (self._flow_ids_offset.? >= self._flow_ids_last_offset.?) {
                self._flow_ids_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readFixed64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._flow_ids_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == TestExtensionWire.FLOW_IDS_WIRE) {
                    self._flow_ids_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._flow_ids_offset = null;
            return value_result.value;
        }
    }
    pub fn terminatingFlowIdsOldNext(self: *TestExtensionReader) gremlin.Error!?u64 {
        if (self._terminating_flow_ids_old_offset == null) return null;
        const current_offset = self._terminating_flow_ids_old_offset.?;
        if (current_offset >= self._terminating_flow_ids_old_last_offset.?) {
            self._terminating_flow_ids_old_offset = null;
            return null;
        }
        if (self._terminating_flow_ids_old_packed) {
            const value_result = try self.buf.readUInt64(current_offset);
            self._terminating_flow_ids_old_offset = current_offset + value_result.size;
            if (self._terminating_flow_ids_old_offset.? >= self._terminating_flow_ids_old_last_offset.?) {
                self._terminating_flow_ids_old_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._terminating_flow_ids_old_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == TestExtensionWire.TERMINATING_FLOW_IDS_OLD_WIRE) {
                    self._terminating_flow_ids_old_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._terminating_flow_ids_old_offset = null;
            return value_result.value;
        }
    }
    pub fn terminatingFlowIdsNext(self: *TestExtensionReader) gremlin.Error!?u64 {
        if (self._terminating_flow_ids_offset == null) return null;
        const current_offset = self._terminating_flow_ids_offset.?;
        if (current_offset >= self._terminating_flow_ids_last_offset.?) {
            self._terminating_flow_ids_offset = null;
            return null;
        }
        if (self._terminating_flow_ids_packed) {
            const value_result = try self.buf.readFixed64(current_offset);
            self._terminating_flow_ids_offset = current_offset + value_result.size;
            if (self._terminating_flow_ids_offset.? >= self._terminating_flow_ids_last_offset.?) {
                self._terminating_flow_ids_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readFixed64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._terminating_flow_ids_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == TestExtensionWire.TERMINATING_FLOW_IDS_WIRE) {
                    self._terminating_flow_ids_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._terminating_flow_ids_offset = null;
            return value_result.value;
        }
    }
    pub fn debugAnnotationsCount(self: *const TestExtensionReader) usize {
        return self._debug_annotations_cnt;
    }
    pub fn debugAnnotationsNext(self: *TestExtensionReader) ?debug_annotation.DebugAnnotationReader {
        if (self._debug_annotations_offset == null) return null;
        const current_offset = self._debug_annotations_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = debug_annotation.DebugAnnotationReader.init(result.value) catch return null;
        if (self._debug_annotations_last_offset != null and current_offset >= self._debug_annotations_last_offset.?) {
            self._debug_annotations_offset = null;
            return msg;
        }
        if (self._debug_annotations_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._debug_annotations_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TestExtensionWire.DEBUG_ANNOTATIONS_WIRE) {
                self._debug_annotations_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._debug_annotations_offset = null;
        return msg;
    }
    pub fn getTaskExecution(self: *const TestExtensionReader) gremlin.Error!task_execution.TaskExecutionReader {
        if (self._task_execution_buf) |buf| {
            return try task_execution.TaskExecutionReader.init(buf);
        }
        return try task_execution.TaskExecutionReader.init(&[_]u8{});
    }
    pub fn getLogMessage(self: *const TestExtensionReader) gremlin.Error!log_message.LogMessageReader {
        if (self._log_message_buf) |buf| {
            return try log_message.LogMessageReader.init(buf);
        }
        return try log_message.LogMessageReader.init(&[_]u8{});
    }
    pub fn getCcSchedulerState(self: *const TestExtensionReader) gremlin.Error!chrome_compositor_scheduler_state.ChromeCompositorSchedulerStateReader {
        if (self._cc_scheduler_state_buf) |buf| {
            return try chrome_compositor_scheduler_state.ChromeCompositorSchedulerStateReader.init(buf);
        }
        return try chrome_compositor_scheduler_state.ChromeCompositorSchedulerStateReader.init(&[_]u8{});
    }
    pub fn getChromeUserEvent(self: *const TestExtensionReader) gremlin.Error!chrome_user_event.ChromeUserEventReader {
        if (self._chrome_user_event_buf) |buf| {
            return try chrome_user_event.ChromeUserEventReader.init(buf);
        }
        return try chrome_user_event.ChromeUserEventReader.init(&[_]u8{});
    }
    pub fn getChromeKeyedService(self: *const TestExtensionReader) gremlin.Error!chrome_keyed_service.ChromeKeyedServiceReader {
        if (self._chrome_keyed_service_buf) |buf| {
            return try chrome_keyed_service.ChromeKeyedServiceReader.init(buf);
        }
        return try chrome_keyed_service.ChromeKeyedServiceReader.init(&[_]u8{});
    }
    pub fn getChromeLegacyIpc(self: *const TestExtensionReader) gremlin.Error!chrome_legacy_ipc.ChromeLegacyIpcReader {
        if (self._chrome_legacy_ipc_buf) |buf| {
            return try chrome_legacy_ipc.ChromeLegacyIpcReader.init(buf);
        }
        return try chrome_legacy_ipc.ChromeLegacyIpcReader.init(&[_]u8{});
    }
    pub fn getChromeHistogramSample(self: *const TestExtensionReader) gremlin.Error!chrome_histogram_sample.ChromeHistogramSampleReader {
        if (self._chrome_histogram_sample_buf) |buf| {
            return try chrome_histogram_sample.ChromeHistogramSampleReader.init(buf);
        }
        return try chrome_histogram_sample.ChromeHistogramSampleReader.init(&[_]u8{});
    }
    pub fn getChromeLatencyInfo(self: *const TestExtensionReader) gremlin.Error!chrome_latency_info.ChromeLatencyInfoReader {
        if (self._chrome_latency_info_buf) |buf| {
            return try chrome_latency_info.ChromeLatencyInfoReader.init(buf);
        }
        return try chrome_latency_info.ChromeLatencyInfoReader.init(&[_]u8{});
    }
    pub fn getChromeFrameReporter(self: *const TestExtensionReader) gremlin.Error!chrome_frame_reporter.ChromeFrameReporterReader {
        if (self._chrome_frame_reporter_buf) |buf| {
            return try chrome_frame_reporter.ChromeFrameReporterReader.init(buf);
        }
        return try chrome_frame_reporter.ChromeFrameReporterReader.init(&[_]u8{});
    }
    pub fn getChromeApplicationStateInfo(self: *const TestExtensionReader) gremlin.Error!chrome_application_state_info.ChromeApplicationStateInfoReader {
        if (self._chrome_application_state_info_buf) |buf| {
            return try chrome_application_state_info.ChromeApplicationStateInfoReader.init(buf);
        }
        return try chrome_application_state_info.ChromeApplicationStateInfoReader.init(&[_]u8{});
    }
    pub fn getChromeRendererSchedulerState(self: *const TestExtensionReader) gremlin.Error!chrome_renderer_scheduler_state.ChromeRendererSchedulerStateReader {
        if (self._chrome_renderer_scheduler_state_buf) |buf| {
            return try chrome_renderer_scheduler_state.ChromeRendererSchedulerStateReader.init(buf);
        }
        return try chrome_renderer_scheduler_state.ChromeRendererSchedulerStateReader.init(&[_]u8{});
    }
    pub fn getChromeWindowHandleEventInfo(self: *const TestExtensionReader) gremlin.Error!chrome_window_handle_event_info.ChromeWindowHandleEventInfoReader {
        if (self._chrome_window_handle_event_info_buf) |buf| {
            return try chrome_window_handle_event_info.ChromeWindowHandleEventInfoReader.init(buf);
        }
        return try chrome_window_handle_event_info.ChromeWindowHandleEventInfoReader.init(&[_]u8{});
    }
    pub fn getChromeContentSettingsEventInfo(self: *const TestExtensionReader) gremlin.Error!chrome_content_settings_event_info.ChromeContentSettingsEventInfoReader {
        if (self._chrome_content_settings_event_info_buf) |buf| {
            return try chrome_content_settings_event_info.ChromeContentSettingsEventInfoReader.init(buf);
        }
        return try chrome_content_settings_event_info.ChromeContentSettingsEventInfoReader.init(&[_]u8{});
    }
    pub fn getChromeActiveProcesses(self: *const TestExtensionReader) gremlin.Error!chrome_active_processes.ChromeActiveProcessesReader {
        if (self._chrome_active_processes_buf) |buf| {
            return try chrome_active_processes.ChromeActiveProcessesReader.init(buf);
        }
        return try chrome_active_processes.ChromeActiveProcessesReader.init(&[_]u8{});
    }
    pub fn getScreenshot(self: *const TestExtensionReader) gremlin.Error!screenshot.ScreenshotReader {
        if (self._screenshot_buf) |buf| {
            return try screenshot.ScreenshotReader.init(buf);
        }
        return try screenshot.ScreenshotReader.init(&[_]u8{});
    }
    pub fn getChromeMessagePump(self: *const TestExtensionReader) gremlin.Error!chrome_message_pump.ChromeMessagePumpReader {
        if (self._chrome_message_pump_buf) |buf| {
            return try chrome_message_pump.ChromeMessagePumpReader.init(buf);
        }
        return try chrome_message_pump.ChromeMessagePumpReader.init(&[_]u8{});
    }
    pub fn getChromeMojoEventInfo(self: *const TestExtensionReader) gremlin.Error!chrome_mojo_event_info.ChromeMojoEventInfoReader {
        if (self._chrome_mojo_event_info_buf) |buf| {
            return try chrome_mojo_event_info.ChromeMojoEventInfoReader.init(buf);
        }
        return try chrome_mojo_event_info.ChromeMojoEventInfoReader.init(&[_]u8{});
    }
    pub fn getLegacyEvent(self: *const TestExtensionReader) gremlin.Error!track_event.TrackEvent.LegacyEventReader {
        if (self._legacy_event_buf) |buf| {
            return try track_event.TrackEvent.LegacyEventReader.init(buf);
        }
        return try track_event.TrackEvent.LegacyEventReader.init(&[_]u8{});
    }
    pub inline fn getNameIid(self: *const TestExtensionReader) u64 {
        return self._name_iid;
    }
    pub inline fn getName(self: *const TestExtensionReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub inline fn getCounterValue(self: *const TestExtensionReader) i64 {
        return self._counter_value;
    }
    pub inline fn getDoubleCounterValue(self: *const TestExtensionReader) f64 {
        return self._double_counter_value;
    }
    pub inline fn getCorrelationId(self: *const TestExtensionReader) u64 {
        return self._correlation_id;
    }
    pub inline fn getCorrelationIdStr(self: *const TestExtensionReader) []const u8 {
        return self._correlation_id_str orelse &[_]u8{};
    }
    pub inline fn getCorrelationIdStrIid(self: *const TestExtensionReader) u64 {
        return self._correlation_id_str_iid;
    }
    pub fn getCallstack(self: *const TestExtensionReader) gremlin.Error!track_event.TrackEvent.CallstackReader {
        if (self._callstack_buf) |buf| {
            return try track_event.TrackEvent.CallstackReader.init(buf);
        }
        return try track_event.TrackEvent.CallstackReader.init(&[_]u8{});
    }
    pub inline fn getCallstackIid(self: *const TestExtensionReader) u64 {
        return self._callstack_iid;
    }
    pub fn getSourceLocation(self: *const TestExtensionReader) gremlin.Error!source_location.SourceLocationReader {
        if (self._source_location_buf) |buf| {
            return try source_location.SourceLocationReader.init(buf);
        }
        return try source_location.SourceLocationReader.init(&[_]u8{});
    }
    pub inline fn getSourceLocationIid(self: *const TestExtensionReader) u64 {
        return self._source_location_iid;
    }
    pub inline fn getTimestampDeltaUs(self: *const TestExtensionReader) i64 {
        return self._timestamp_delta_us;
    }
    pub inline fn getTimestampAbsoluteUs(self: *const TestExtensionReader) i64 {
        return self._timestamp_absolute_us;
    }
    pub inline fn getThreadTimeDeltaUs(self: *const TestExtensionReader) i64 {
        return self._thread_time_delta_us;
    }
    pub inline fn getThreadTimeAbsoluteUs(self: *const TestExtensionReader) i64 {
        return self._thread_time_absolute_us;
    }
    pub inline fn getThreadInstructionCountDelta(self: *const TestExtensionReader) i64 {
        return self._thread_instruction_count_delta;
    }
    pub inline fn getThreadInstructionCountAbsolute(self: *const TestExtensionReader) i64 {
        return self._thread_instruction_count_absolute;
    }
};
const TestExtensionChildWire = struct {
    const CHILD_FIELD_FOR_TESTING_WIRE: gremlin.ProtoWireNumber = 1;
    const DEBUG_ANNOTATIONS_WIRE: gremlin.ProtoWireNumber = 99;
};
pub const TestExtensionChild = struct {
    // fields
    child_field_for_testing: ?[]const u8 = null,
    debug_annotations: ?[]const ?debug_annotation.DebugAnnotation = null,
    pub fn calcProtobufSize(self: *const TestExtensionChild) usize {
        var res: usize = 0;
        if (self.child_field_for_testing) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TestExtensionChildWire.CHILD_FIELD_FOR_TESTING_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.debug_annotations) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TestExtensionChildWire.DEBUG_ANNOTATIONS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const TestExtensionChild, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TestExtensionChild, target: *gremlin.Writer) void {
        if (self.child_field_for_testing) |v| {
            if (v.len > 0) {
                target.appendBytes(TestExtensionChildWire.CHILD_FIELD_FOR_TESTING_WIRE, v);
            }
        }
        if (self.debug_annotations) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(TestExtensionChildWire.DEBUG_ANNOTATIONS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(TestExtensionChildWire.DEBUG_ANNOTATIONS_WIRE, 0);
                }
            }
        }
    }
};
pub const TestExtensionChildReader = struct {
    buf: gremlin.Reader,
    _child_field_for_testing: ?[]const u8 = null,
    _debug_annotations_offset: ?usize = null,
    _debug_annotations_last_offset: ?usize = null,
    _debug_annotations_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!TestExtensionChildReader {
        const buf = gremlin.Reader.init(src);
        var res = TestExtensionChildReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TestExtensionChildWire.CHILD_FIELD_FOR_TESTING_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._child_field_for_testing = result.value;
                },
                TestExtensionChildWire.DEBUG_ANNOTATIONS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._debug_annotations_offset == null) {
                        res._debug_annotations_offset = offset - result.size;
                    }
                    res._debug_annotations_last_offset = offset;
                    res._debug_annotations_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getChildFieldForTesting(self: *const TestExtensionChildReader) []const u8 {
        return self._child_field_for_testing orelse &[_]u8{};
    }
    pub fn debugAnnotationsCount(self: *const TestExtensionChildReader) usize {
        return self._debug_annotations_cnt;
    }
    pub fn debugAnnotationsNext(self: *TestExtensionChildReader) ?debug_annotation.DebugAnnotationReader {
        if (self._debug_annotations_offset == null) return null;
        const current_offset = self._debug_annotations_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = debug_annotation.DebugAnnotationReader.init(result.value) catch return null;
        if (self._debug_annotations_last_offset != null and current_offset >= self._debug_annotations_last_offset.?) {
            self._debug_annotations_offset = null;
            return msg;
        }
        if (self._debug_annotations_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._debug_annotations_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TestExtensionChildWire.DEBUG_ANNOTATIONS_WIRE) {
                self._debug_annotations_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._debug_annotations_offset = null;
        return msg;
    }
};
