// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
const sys_stats_counters = @import("src/gen/protos/perfetto/common/sys_stats_counters.proto.zig");
// structs
const SysStatsWire = struct {
    const MEMINFO_WIRE: gremlin.ProtoWireNumber = 1;
    const VMSTAT_WIRE: gremlin.ProtoWireNumber = 2;
    const CPU_STAT_WIRE: gremlin.ProtoWireNumber = 3;
    const NUM_FORKS_WIRE: gremlin.ProtoWireNumber = 4;
    const NUM_IRQ_TOTAL_WIRE: gremlin.ProtoWireNumber = 5;
    const NUM_IRQ_WIRE: gremlin.ProtoWireNumber = 6;
    const NUM_SOFTIRQ_TOTAL_WIRE: gremlin.ProtoWireNumber = 7;
    const NUM_SOFTIRQ_WIRE: gremlin.ProtoWireNumber = 8;
    const COLLECTION_END_TIMESTAMP_WIRE: gremlin.ProtoWireNumber = 9;
    const DEVFREQ_WIRE: gremlin.ProtoWireNumber = 10;
    const CPUFREQ_KHZ_WIRE: gremlin.ProtoWireNumber = 11;
    const BUDDY_INFO_WIRE: gremlin.ProtoWireNumber = 12;
    const DISK_STAT_WIRE: gremlin.ProtoWireNumber = 13;
    const PSI_WIRE: gremlin.ProtoWireNumber = 14;
    const THERMAL_ZONE_WIRE: gremlin.ProtoWireNumber = 15;
    const CPUIDLE_STATE_WIRE: gremlin.ProtoWireNumber = 16;
    const GPUFREQ_MHZ_WIRE: gremlin.ProtoWireNumber = 17;
};
pub const SysStats = struct {
    // nested structs
    const MeminfoValueWire = struct {
        const KEY_WIRE: gremlin.ProtoWireNumber = 1;
        const VALUE_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const MeminfoValue = struct {
        // fields
        key: sys_stats_counters.MeminfoCounters = @enumFromInt(0),
        value: u64 = 0,
        pub fn calcProtobufSize(self: *const SysStats.MeminfoValue) usize {
            var res: usize = 0;
            if (@intFromEnum(self.key) != 0) {
                res += gremlin.sizes.sizeWireNumber(SysStats.MeminfoValueWire.KEY_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.key));
            }
            if (self.value != 0) {
                res += gremlin.sizes.sizeWireNumber(SysStats.MeminfoValueWire.VALUE_WIRE) + gremlin.sizes.sizeU64(self.value);
            }
            return res;
        }
        pub fn encode(self: *const SysStats.MeminfoValue, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const SysStats.MeminfoValue, target: *gremlin.Writer) void {
            if (@intFromEnum(self.key) != 0) {
                target.appendInt32(SysStats.MeminfoValueWire.KEY_WIRE, @intFromEnum(self.key));
            }
            if (self.value != 0) {
                target.appendUint64(SysStats.MeminfoValueWire.VALUE_WIRE, self.value);
            }
        }
    };
    pub const MeminfoValueReader = struct {
        buf: gremlin.Reader,
        _key: sys_stats_counters.MeminfoCounters = @enumFromInt(0),
        _value: u64 = 0,
        pub fn init(src: []const u8) gremlin.Error!SysStats.MeminfoValueReader {
            const buf = gremlin.Reader.init(src);
            var res = SysStats.MeminfoValueReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    SysStats.MeminfoValueWire.KEY_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._key = @enumFromInt(result.value);
                    },
                    SysStats.MeminfoValueWire.VALUE_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._value = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getKey(self: *const SysStats.MeminfoValueReader) sys_stats_counters.MeminfoCounters {
            return self._key;
        }
        pub inline fn getValue(self: *const SysStats.MeminfoValueReader) u64 {
            return self._value;
        }
    };
    const VmstatValueWire = struct {
        const KEY_WIRE: gremlin.ProtoWireNumber = 1;
        const VALUE_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const VmstatValue = struct {
        // fields
        key: sys_stats_counters.VmstatCounters = @enumFromInt(0),
        value: u64 = 0,
        pub fn calcProtobufSize(self: *const SysStats.VmstatValue) usize {
            var res: usize = 0;
            if (@intFromEnum(self.key) != 0) {
                res += gremlin.sizes.sizeWireNumber(SysStats.VmstatValueWire.KEY_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.key));
            }
            if (self.value != 0) {
                res += gremlin.sizes.sizeWireNumber(SysStats.VmstatValueWire.VALUE_WIRE) + gremlin.sizes.sizeU64(self.value);
            }
            return res;
        }
        pub fn encode(self: *const SysStats.VmstatValue, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const SysStats.VmstatValue, target: *gremlin.Writer) void {
            if (@intFromEnum(self.key) != 0) {
                target.appendInt32(SysStats.VmstatValueWire.KEY_WIRE, @intFromEnum(self.key));
            }
            if (self.value != 0) {
                target.appendUint64(SysStats.VmstatValueWire.VALUE_WIRE, self.value);
            }
        }
    };
    pub const VmstatValueReader = struct {
        buf: gremlin.Reader,
        _key: sys_stats_counters.VmstatCounters = @enumFromInt(0),
        _value: u64 = 0,
        pub fn init(src: []const u8) gremlin.Error!SysStats.VmstatValueReader {
            const buf = gremlin.Reader.init(src);
            var res = SysStats.VmstatValueReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    SysStats.VmstatValueWire.KEY_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._key = @enumFromInt(result.value);
                    },
                    SysStats.VmstatValueWire.VALUE_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._value = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getKey(self: *const SysStats.VmstatValueReader) sys_stats_counters.VmstatCounters {
            return self._key;
        }
        pub inline fn getValue(self: *const SysStats.VmstatValueReader) u64 {
            return self._value;
        }
    };
    const CpuTimesWire = struct {
        const CPU_ID_WIRE: gremlin.ProtoWireNumber = 1;
        const USER_NS_WIRE: gremlin.ProtoWireNumber = 2;
        const USER_NICE_NS_WIRE: gremlin.ProtoWireNumber = 3;
        const SYSTEM_MODE_NS_WIRE: gremlin.ProtoWireNumber = 4;
        const IDLE_NS_WIRE: gremlin.ProtoWireNumber = 5;
        const IO_WAIT_NS_WIRE: gremlin.ProtoWireNumber = 6;
        const IRQ_NS_WIRE: gremlin.ProtoWireNumber = 7;
        const SOFTIRQ_NS_WIRE: gremlin.ProtoWireNumber = 8;
        const STEAL_NS_WIRE: gremlin.ProtoWireNumber = 9;
    };
    pub const CpuTimes = struct {
        // fields
        cpu_id: u32 = 0,
        user_ns: u64 = 0,
        user_nice_ns: u64 = 0,
        system_mode_ns: u64 = 0,
        idle_ns: u64 = 0,
        io_wait_ns: u64 = 0,
        irq_ns: u64 = 0,
        softirq_ns: u64 = 0,
        steal_ns: u64 = 0,
        pub fn calcProtobufSize(self: *const SysStats.CpuTimes) usize {
            var res: usize = 0;
            if (self.cpu_id != 0) {
                res += gremlin.sizes.sizeWireNumber(SysStats.CpuTimesWire.CPU_ID_WIRE) + gremlin.sizes.sizeU32(self.cpu_id);
            }
            if (self.user_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(SysStats.CpuTimesWire.USER_NS_WIRE) + gremlin.sizes.sizeU64(self.user_ns);
            }
            if (self.user_nice_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(SysStats.CpuTimesWire.USER_NICE_NS_WIRE) + gremlin.sizes.sizeU64(self.user_nice_ns);
            }
            if (self.system_mode_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(SysStats.CpuTimesWire.SYSTEM_MODE_NS_WIRE) + gremlin.sizes.sizeU64(self.system_mode_ns);
            }
            if (self.idle_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(SysStats.CpuTimesWire.IDLE_NS_WIRE) + gremlin.sizes.sizeU64(self.idle_ns);
            }
            if (self.io_wait_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(SysStats.CpuTimesWire.IO_WAIT_NS_WIRE) + gremlin.sizes.sizeU64(self.io_wait_ns);
            }
            if (self.irq_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(SysStats.CpuTimesWire.IRQ_NS_WIRE) + gremlin.sizes.sizeU64(self.irq_ns);
            }
            if (self.softirq_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(SysStats.CpuTimesWire.SOFTIRQ_NS_WIRE) + gremlin.sizes.sizeU64(self.softirq_ns);
            }
            if (self.steal_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(SysStats.CpuTimesWire.STEAL_NS_WIRE) + gremlin.sizes.sizeU64(self.steal_ns);
            }
            return res;
        }
        pub fn encode(self: *const SysStats.CpuTimes, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const SysStats.CpuTimes, target: *gremlin.Writer) void {
            if (self.cpu_id != 0) {
                target.appendUint32(SysStats.CpuTimesWire.CPU_ID_WIRE, self.cpu_id);
            }
            if (self.user_ns != 0) {
                target.appendUint64(SysStats.CpuTimesWire.USER_NS_WIRE, self.user_ns);
            }
            if (self.user_nice_ns != 0) {
                target.appendUint64(SysStats.CpuTimesWire.USER_NICE_NS_WIRE, self.user_nice_ns);
            }
            if (self.system_mode_ns != 0) {
                target.appendUint64(SysStats.CpuTimesWire.SYSTEM_MODE_NS_WIRE, self.system_mode_ns);
            }
            if (self.idle_ns != 0) {
                target.appendUint64(SysStats.CpuTimesWire.IDLE_NS_WIRE, self.idle_ns);
            }
            if (self.io_wait_ns != 0) {
                target.appendUint64(SysStats.CpuTimesWire.IO_WAIT_NS_WIRE, self.io_wait_ns);
            }
            if (self.irq_ns != 0) {
                target.appendUint64(SysStats.CpuTimesWire.IRQ_NS_WIRE, self.irq_ns);
            }
            if (self.softirq_ns != 0) {
                target.appendUint64(SysStats.CpuTimesWire.SOFTIRQ_NS_WIRE, self.softirq_ns);
            }
            if (self.steal_ns != 0) {
                target.appendUint64(SysStats.CpuTimesWire.STEAL_NS_WIRE, self.steal_ns);
            }
        }
    };
    pub const CpuTimesReader = struct {
        buf: gremlin.Reader,
        _cpu_id: u32 = 0,
        _user_ns: u64 = 0,
        _user_nice_ns: u64 = 0,
        _system_mode_ns: u64 = 0,
        _idle_ns: u64 = 0,
        _io_wait_ns: u64 = 0,
        _irq_ns: u64 = 0,
        _softirq_ns: u64 = 0,
        _steal_ns: u64 = 0,
        pub fn init(src: []const u8) gremlin.Error!SysStats.CpuTimesReader {
            const buf = gremlin.Reader.init(src);
            var res = SysStats.CpuTimesReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    SysStats.CpuTimesWire.CPU_ID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._cpu_id = result.value;
                    },
                    SysStats.CpuTimesWire.USER_NS_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._user_ns = result.value;
                    },
                    SysStats.CpuTimesWire.USER_NICE_NS_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._user_nice_ns = result.value;
                    },
                    SysStats.CpuTimesWire.SYSTEM_MODE_NS_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._system_mode_ns = result.value;
                    },
                    SysStats.CpuTimesWire.IDLE_NS_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._idle_ns = result.value;
                    },
                    SysStats.CpuTimesWire.IO_WAIT_NS_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._io_wait_ns = result.value;
                    },
                    SysStats.CpuTimesWire.IRQ_NS_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._irq_ns = result.value;
                    },
                    SysStats.CpuTimesWire.SOFTIRQ_NS_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._softirq_ns = result.value;
                    },
                    SysStats.CpuTimesWire.STEAL_NS_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._steal_ns = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getCpuId(self: *const SysStats.CpuTimesReader) u32 {
            return self._cpu_id;
        }
        pub inline fn getUserNs(self: *const SysStats.CpuTimesReader) u64 {
            return self._user_ns;
        }
        pub inline fn getUserNiceNs(self: *const SysStats.CpuTimesReader) u64 {
            return self._user_nice_ns;
        }
        pub inline fn getSystemModeNs(self: *const SysStats.CpuTimesReader) u64 {
            return self._system_mode_ns;
        }
        pub inline fn getIdleNs(self: *const SysStats.CpuTimesReader) u64 {
            return self._idle_ns;
        }
        pub inline fn getIoWaitNs(self: *const SysStats.CpuTimesReader) u64 {
            return self._io_wait_ns;
        }
        pub inline fn getIrqNs(self: *const SysStats.CpuTimesReader) u64 {
            return self._irq_ns;
        }
        pub inline fn getSoftirqNs(self: *const SysStats.CpuTimesReader) u64 {
            return self._softirq_ns;
        }
        pub inline fn getStealNs(self: *const SysStats.CpuTimesReader) u64 {
            return self._steal_ns;
        }
    };
    const InterruptCountWire = struct {
        const IRQ_WIRE: gremlin.ProtoWireNumber = 1;
        const COUNT_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const InterruptCount = struct {
        // fields
        irq: i32 = 0,
        count: u64 = 0,
        pub fn calcProtobufSize(self: *const SysStats.InterruptCount) usize {
            var res: usize = 0;
            if (self.irq != 0) {
                res += gremlin.sizes.sizeWireNumber(SysStats.InterruptCountWire.IRQ_WIRE) + gremlin.sizes.sizeI32(self.irq);
            }
            if (self.count != 0) {
                res += gremlin.sizes.sizeWireNumber(SysStats.InterruptCountWire.COUNT_WIRE) + gremlin.sizes.sizeU64(self.count);
            }
            return res;
        }
        pub fn encode(self: *const SysStats.InterruptCount, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const SysStats.InterruptCount, target: *gremlin.Writer) void {
            if (self.irq != 0) {
                target.appendInt32(SysStats.InterruptCountWire.IRQ_WIRE, self.irq);
            }
            if (self.count != 0) {
                target.appendUint64(SysStats.InterruptCountWire.COUNT_WIRE, self.count);
            }
        }
    };
    pub const InterruptCountReader = struct {
        buf: gremlin.Reader,
        _irq: i32 = 0,
        _count: u64 = 0,
        pub fn init(src: []const u8) gremlin.Error!SysStats.InterruptCountReader {
            const buf = gremlin.Reader.init(src);
            var res = SysStats.InterruptCountReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    SysStats.InterruptCountWire.IRQ_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._irq = result.value;
                    },
                    SysStats.InterruptCountWire.COUNT_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._count = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getIrq(self: *const SysStats.InterruptCountReader) i32 {
            return self._irq;
        }
        pub inline fn getCount(self: *const SysStats.InterruptCountReader) u64 {
            return self._count;
        }
    };
    const DevfreqValueWire = struct {
        const KEY_WIRE: gremlin.ProtoWireNumber = 1;
        const VALUE_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const DevfreqValue = struct {
        // fields
        key: ?[]const u8 = null,
        value: u64 = 0,
        pub fn calcProtobufSize(self: *const SysStats.DevfreqValue) usize {
            var res: usize = 0;
            if (self.key) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(SysStats.DevfreqValueWire.KEY_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.value != 0) {
                res += gremlin.sizes.sizeWireNumber(SysStats.DevfreqValueWire.VALUE_WIRE) + gremlin.sizes.sizeU64(self.value);
            }
            return res;
        }
        pub fn encode(self: *const SysStats.DevfreqValue, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const SysStats.DevfreqValue, target: *gremlin.Writer) void {
            if (self.key) |v| {
                if (v.len > 0) {
                    target.appendBytes(SysStats.DevfreqValueWire.KEY_WIRE, v);
                }
            }
            if (self.value != 0) {
                target.appendUint64(SysStats.DevfreqValueWire.VALUE_WIRE, self.value);
            }
        }
    };
    pub const DevfreqValueReader = struct {
        buf: gremlin.Reader,
        _key: ?[]const u8 = null,
        _value: u64 = 0,
        pub fn init(src: []const u8) gremlin.Error!SysStats.DevfreqValueReader {
            const buf = gremlin.Reader.init(src);
            var res = SysStats.DevfreqValueReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    SysStats.DevfreqValueWire.KEY_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._key = result.value;
                    },
                    SysStats.DevfreqValueWire.VALUE_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._value = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getKey(self: *const SysStats.DevfreqValueReader) []const u8 {
            return self._key orelse &[_]u8{};
        }
        pub inline fn getValue(self: *const SysStats.DevfreqValueReader) u64 {
            return self._value;
        }
    };
    const BuddyInfoWire = struct {
        const NODE_WIRE: gremlin.ProtoWireNumber = 1;
        const ZONE_WIRE: gremlin.ProtoWireNumber = 2;
        const ORDER_PAGES_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const BuddyInfo = struct {
        // fields
        node: ?[]const u8 = null,
        zone: ?[]const u8 = null,
        order_pages: ?[]const u32 = null,
        pub fn calcProtobufSize(self: *const SysStats.BuddyInfo) usize {
            var res: usize = 0;
            if (self.node) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(SysStats.BuddyInfoWire.NODE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.zone) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(SysStats.BuddyInfoWire.ZONE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.order_pages) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    res += gremlin.sizes.sizeWireNumber(SysStats.BuddyInfoWire.ORDER_PAGES_WIRE) + gremlin.sizes.sizeU32(arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeU32(v);
                    }
                    res += gremlin.sizes.sizeWireNumber(SysStats.BuddyInfoWire.ORDER_PAGES_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
                }
            }
            return res;
        }
        pub fn encode(self: *const SysStats.BuddyInfo, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const SysStats.BuddyInfo, target: *gremlin.Writer) void {
            if (self.node) |v| {
                if (v.len > 0) {
                    target.appendBytes(SysStats.BuddyInfoWire.NODE_WIRE, v);
                }
            }
            if (self.zone) |v| {
                if (v.len > 0) {
                    target.appendBytes(SysStats.BuddyInfoWire.ZONE_WIRE, v);
                }
            }
            if (self.order_pages) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    target.appendUint32(SysStats.BuddyInfoWire.ORDER_PAGES_WIRE, arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeU32(v);
                    }
                    target.appendBytesTag(SysStats.BuddyInfoWire.ORDER_PAGES_WIRE, packed_size);
                    for (arr) |v| {
                        target.appendUint32WithoutTag(v);
                    }
                }
            }
        }
    };
    pub const BuddyInfoReader = struct {
        buf: gremlin.Reader,
        _node: ?[]const u8 = null,
        _zone: ?[]const u8 = null,
        _order_pages_offset: ?usize = null,
        _order_pages_last_offset: ?usize = null,
        _order_pages_packed: bool = false,
        pub fn init(src: []const u8) gremlin.Error!SysStats.BuddyInfoReader {
            const buf = gremlin.Reader.init(src);
            var res = SysStats.BuddyInfoReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    SysStats.BuddyInfoWire.NODE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._node = result.value;
                    },
                    SysStats.BuddyInfoWire.ZONE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._zone = result.value;
                    },
                    SysStats.BuddyInfoWire.ORDER_PAGES_WIRE => {
                        if (res._order_pages_offset == null) {
                            res._order_pages_offset = offset;
                        }
                        if (tag.wire == gremlin.ProtoWireType.bytes) {
                            res._order_pages_packed = true;
                            const length_result = try buf.readVarInt(offset);
                            res._order_pages_offset = offset + length_result.size;
                            res._order_pages_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                            offset = res._order_pages_last_offset.?;
                        } else {
                            const result = try buf.readUInt32(offset);
                            offset += result.size;
                            res._order_pages_last_offset = offset;
                        }
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getNode(self: *const SysStats.BuddyInfoReader) []const u8 {
            return self._node orelse &[_]u8{};
        }
        pub inline fn getZone(self: *const SysStats.BuddyInfoReader) []const u8 {
            return self._zone orelse &[_]u8{};
        }
        pub fn orderPagesNext(self: *SysStats.BuddyInfoReader) gremlin.Error!?u32 {
            if (self._order_pages_offset == null) return null;
            const current_offset = self._order_pages_offset.?;
            if (current_offset >= self._order_pages_last_offset.?) {
                self._order_pages_offset = null;
                return null;
            }
            if (self._order_pages_packed) {
                const value_result = try self.buf.readUInt32(current_offset);
                self._order_pages_offset = current_offset + value_result.size;
                if (self._order_pages_offset.? >= self._order_pages_last_offset.?) {
                    self._order_pages_offset = null;
                }
                return value_result.value;
            } else {
                const value_result = try self.buf.readUInt32(current_offset);
                var next_offset = current_offset + value_result.size;
                const max_offset = self._order_pages_last_offset.?;
                // Search for the next occurrence of this field
                while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                    const next_tag = try self.buf.readTagAt(next_offset);
                    next_offset += next_tag.size;
                    if (next_tag.number == SysStats.BuddyInfoWire.ORDER_PAGES_WIRE) {
                        self._order_pages_offset = next_offset;
                        return value_result.value;
                    } else {
                        next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                    }
                }
                self._order_pages_offset = null;
                return value_result.value;
            }
        }
    };
    const DiskStatWire = struct {
        const DEVICE_NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const READ_SECTORS_WIRE: gremlin.ProtoWireNumber = 2;
        const READ_TIME_MS_WIRE: gremlin.ProtoWireNumber = 3;
        const WRITE_SECTORS_WIRE: gremlin.ProtoWireNumber = 4;
        const WRITE_TIME_MS_WIRE: gremlin.ProtoWireNumber = 5;
        const DISCARD_SECTORS_WIRE: gremlin.ProtoWireNumber = 6;
        const DISCARD_TIME_MS_WIRE: gremlin.ProtoWireNumber = 7;
        const FLUSH_COUNT_WIRE: gremlin.ProtoWireNumber = 8;
        const FLUSH_TIME_MS_WIRE: gremlin.ProtoWireNumber = 9;
    };
    pub const DiskStat = struct {
        // fields
        device_name: ?[]const u8 = null,
        read_sectors: u64 = 0,
        read_time_ms: u64 = 0,
        write_sectors: u64 = 0,
        write_time_ms: u64 = 0,
        discard_sectors: u64 = 0,
        discard_time_ms: u64 = 0,
        flush_count: u64 = 0,
        flush_time_ms: u64 = 0,
        pub fn calcProtobufSize(self: *const SysStats.DiskStat) usize {
            var res: usize = 0;
            if (self.device_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(SysStats.DiskStatWire.DEVICE_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.read_sectors != 0) {
                res += gremlin.sizes.sizeWireNumber(SysStats.DiskStatWire.READ_SECTORS_WIRE) + gremlin.sizes.sizeU64(self.read_sectors);
            }
            if (self.read_time_ms != 0) {
                res += gremlin.sizes.sizeWireNumber(SysStats.DiskStatWire.READ_TIME_MS_WIRE) + gremlin.sizes.sizeU64(self.read_time_ms);
            }
            if (self.write_sectors != 0) {
                res += gremlin.sizes.sizeWireNumber(SysStats.DiskStatWire.WRITE_SECTORS_WIRE) + gremlin.sizes.sizeU64(self.write_sectors);
            }
            if (self.write_time_ms != 0) {
                res += gremlin.sizes.sizeWireNumber(SysStats.DiskStatWire.WRITE_TIME_MS_WIRE) + gremlin.sizes.sizeU64(self.write_time_ms);
            }
            if (self.discard_sectors != 0) {
                res += gremlin.sizes.sizeWireNumber(SysStats.DiskStatWire.DISCARD_SECTORS_WIRE) + gremlin.sizes.sizeU64(self.discard_sectors);
            }
            if (self.discard_time_ms != 0) {
                res += gremlin.sizes.sizeWireNumber(SysStats.DiskStatWire.DISCARD_TIME_MS_WIRE) + gremlin.sizes.sizeU64(self.discard_time_ms);
            }
            if (self.flush_count != 0) {
                res += gremlin.sizes.sizeWireNumber(SysStats.DiskStatWire.FLUSH_COUNT_WIRE) + gremlin.sizes.sizeU64(self.flush_count);
            }
            if (self.flush_time_ms != 0) {
                res += gremlin.sizes.sizeWireNumber(SysStats.DiskStatWire.FLUSH_TIME_MS_WIRE) + gremlin.sizes.sizeU64(self.flush_time_ms);
            }
            return res;
        }
        pub fn encode(self: *const SysStats.DiskStat, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const SysStats.DiskStat, target: *gremlin.Writer) void {
            if (self.device_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(SysStats.DiskStatWire.DEVICE_NAME_WIRE, v);
                }
            }
            if (self.read_sectors != 0) {
                target.appendUint64(SysStats.DiskStatWire.READ_SECTORS_WIRE, self.read_sectors);
            }
            if (self.read_time_ms != 0) {
                target.appendUint64(SysStats.DiskStatWire.READ_TIME_MS_WIRE, self.read_time_ms);
            }
            if (self.write_sectors != 0) {
                target.appendUint64(SysStats.DiskStatWire.WRITE_SECTORS_WIRE, self.write_sectors);
            }
            if (self.write_time_ms != 0) {
                target.appendUint64(SysStats.DiskStatWire.WRITE_TIME_MS_WIRE, self.write_time_ms);
            }
            if (self.discard_sectors != 0) {
                target.appendUint64(SysStats.DiskStatWire.DISCARD_SECTORS_WIRE, self.discard_sectors);
            }
            if (self.discard_time_ms != 0) {
                target.appendUint64(SysStats.DiskStatWire.DISCARD_TIME_MS_WIRE, self.discard_time_ms);
            }
            if (self.flush_count != 0) {
                target.appendUint64(SysStats.DiskStatWire.FLUSH_COUNT_WIRE, self.flush_count);
            }
            if (self.flush_time_ms != 0) {
                target.appendUint64(SysStats.DiskStatWire.FLUSH_TIME_MS_WIRE, self.flush_time_ms);
            }
        }
    };
    pub const DiskStatReader = struct {
        buf: gremlin.Reader,
        _device_name: ?[]const u8 = null,
        _read_sectors: u64 = 0,
        _read_time_ms: u64 = 0,
        _write_sectors: u64 = 0,
        _write_time_ms: u64 = 0,
        _discard_sectors: u64 = 0,
        _discard_time_ms: u64 = 0,
        _flush_count: u64 = 0,
        _flush_time_ms: u64 = 0,
        pub fn init(src: []const u8) gremlin.Error!SysStats.DiskStatReader {
            const buf = gremlin.Reader.init(src);
            var res = SysStats.DiskStatReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    SysStats.DiskStatWire.DEVICE_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._device_name = result.value;
                    },
                    SysStats.DiskStatWire.READ_SECTORS_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._read_sectors = result.value;
                    },
                    SysStats.DiskStatWire.READ_TIME_MS_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._read_time_ms = result.value;
                    },
                    SysStats.DiskStatWire.WRITE_SECTORS_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._write_sectors = result.value;
                    },
                    SysStats.DiskStatWire.WRITE_TIME_MS_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._write_time_ms = result.value;
                    },
                    SysStats.DiskStatWire.DISCARD_SECTORS_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._discard_sectors = result.value;
                    },
                    SysStats.DiskStatWire.DISCARD_TIME_MS_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._discard_time_ms = result.value;
                    },
                    SysStats.DiskStatWire.FLUSH_COUNT_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._flush_count = result.value;
                    },
                    SysStats.DiskStatWire.FLUSH_TIME_MS_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._flush_time_ms = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getDeviceName(self: *const SysStats.DiskStatReader) []const u8 {
            return self._device_name orelse &[_]u8{};
        }
        pub inline fn getReadSectors(self: *const SysStats.DiskStatReader) u64 {
            return self._read_sectors;
        }
        pub inline fn getReadTimeMs(self: *const SysStats.DiskStatReader) u64 {
            return self._read_time_ms;
        }
        pub inline fn getWriteSectors(self: *const SysStats.DiskStatReader) u64 {
            return self._write_sectors;
        }
        pub inline fn getWriteTimeMs(self: *const SysStats.DiskStatReader) u64 {
            return self._write_time_ms;
        }
        pub inline fn getDiscardSectors(self: *const SysStats.DiskStatReader) u64 {
            return self._discard_sectors;
        }
        pub inline fn getDiscardTimeMs(self: *const SysStats.DiskStatReader) u64 {
            return self._discard_time_ms;
        }
        pub inline fn getFlushCount(self: *const SysStats.DiskStatReader) u64 {
            return self._flush_count;
        }
        pub inline fn getFlushTimeMs(self: *const SysStats.DiskStatReader) u64 {
            return self._flush_time_ms;
        }
    };
    const PsiSampleWire = struct {
        const RESOURCE_WIRE: gremlin.ProtoWireNumber = 1;
        const TOTAL_NS_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const PsiSample = struct {
        // nested enums
        pub const PsiResource = enum(i32) {
            PSI_RESOURCE_UNSPECIFIED = 0,
            PSI_RESOURCE_CPU_SOME = 1,
            PSI_RESOURCE_CPU_FULL = 2,
            PSI_RESOURCE_IO_SOME = 3,
            PSI_RESOURCE_IO_FULL = 4,
            PSI_RESOURCE_MEMORY_SOME = 5,
            PSI_RESOURCE_MEMORY_FULL = 6,
        };
        // fields
        resource: SysStats.PsiSample.PsiResource = @enumFromInt(0),
        total_ns: u64 = 0,
        pub fn calcProtobufSize(self: *const SysStats.PsiSample) usize {
            var res: usize = 0;
            if (@intFromEnum(self.resource) != 0) {
                res += gremlin.sizes.sizeWireNumber(SysStats.PsiSampleWire.RESOURCE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.resource));
            }
            if (self.total_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(SysStats.PsiSampleWire.TOTAL_NS_WIRE) + gremlin.sizes.sizeU64(self.total_ns);
            }
            return res;
        }
        pub fn encode(self: *const SysStats.PsiSample, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const SysStats.PsiSample, target: *gremlin.Writer) void {
            if (@intFromEnum(self.resource) != 0) {
                target.appendInt32(SysStats.PsiSampleWire.RESOURCE_WIRE, @intFromEnum(self.resource));
            }
            if (self.total_ns != 0) {
                target.appendUint64(SysStats.PsiSampleWire.TOTAL_NS_WIRE, self.total_ns);
            }
        }
    };
    pub const PsiSampleReader = struct {
        buf: gremlin.Reader,
        _resource: SysStats.PsiSample.PsiResource = @enumFromInt(0),
        _total_ns: u64 = 0,
        pub fn init(src: []const u8) gremlin.Error!SysStats.PsiSampleReader {
            const buf = gremlin.Reader.init(src);
            var res = SysStats.PsiSampleReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    SysStats.PsiSampleWire.RESOURCE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._resource = @enumFromInt(result.value);
                    },
                    SysStats.PsiSampleWire.TOTAL_NS_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._total_ns = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getResource(self: *const SysStats.PsiSampleReader) SysStats.PsiSample.PsiResource {
            return self._resource;
        }
        pub inline fn getTotalNs(self: *const SysStats.PsiSampleReader) u64 {
            return self._total_ns;
        }
    };
    const ThermalZoneWire = struct {
        const NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const TEMP_WIRE: gremlin.ProtoWireNumber = 2;
        const TYPE_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const ThermalZone = struct {
        // fields
        name: ?[]const u8 = null,
        temp: u64 = 0,
        type: ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const SysStats.ThermalZone) usize {
            var res: usize = 0;
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(SysStats.ThermalZoneWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.temp != 0) {
                res += gremlin.sizes.sizeWireNumber(SysStats.ThermalZoneWire.TEMP_WIRE) + gremlin.sizes.sizeU64(self.temp);
            }
            if (self.type) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(SysStats.ThermalZoneWire.TYPE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            return res;
        }
        pub fn encode(self: *const SysStats.ThermalZone, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const SysStats.ThermalZone, target: *gremlin.Writer) void {
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(SysStats.ThermalZoneWire.NAME_WIRE, v);
                }
            }
            if (self.temp != 0) {
                target.appendUint64(SysStats.ThermalZoneWire.TEMP_WIRE, self.temp);
            }
            if (self.type) |v| {
                if (v.len > 0) {
                    target.appendBytes(SysStats.ThermalZoneWire.TYPE_WIRE, v);
                }
            }
        }
    };
    pub const ThermalZoneReader = struct {
        buf: gremlin.Reader,
        _name: ?[]const u8 = null,
        _temp: u64 = 0,
        _type: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!SysStats.ThermalZoneReader {
            const buf = gremlin.Reader.init(src);
            var res = SysStats.ThermalZoneReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    SysStats.ThermalZoneWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    SysStats.ThermalZoneWire.TEMP_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._temp = result.value;
                    },
                    SysStats.ThermalZoneWire.TYPE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._type = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getName(self: *const SysStats.ThermalZoneReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub inline fn getTemp(self: *const SysStats.ThermalZoneReader) u64 {
            return self._temp;
        }
        pub inline fn getType(self: *const SysStats.ThermalZoneReader) []const u8 {
            return self._type orelse &[_]u8{};
        }
    };
    const CpuIdleStateEntryWire = struct {
        const STATE_WIRE: gremlin.ProtoWireNumber = 1;
        const DURATION_US_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const CpuIdleStateEntry = struct {
        // fields
        state: ?[]const u8 = null,
        duration_us: u64 = 0,
        pub fn calcProtobufSize(self: *const SysStats.CpuIdleStateEntry) usize {
            var res: usize = 0;
            if (self.state) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(SysStats.CpuIdleStateEntryWire.STATE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.duration_us != 0) {
                res += gremlin.sizes.sizeWireNumber(SysStats.CpuIdleStateEntryWire.DURATION_US_WIRE) + gremlin.sizes.sizeU64(self.duration_us);
            }
            return res;
        }
        pub fn encode(self: *const SysStats.CpuIdleStateEntry, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const SysStats.CpuIdleStateEntry, target: *gremlin.Writer) void {
            if (self.state) |v| {
                if (v.len > 0) {
                    target.appendBytes(SysStats.CpuIdleStateEntryWire.STATE_WIRE, v);
                }
            }
            if (self.duration_us != 0) {
                target.appendUint64(SysStats.CpuIdleStateEntryWire.DURATION_US_WIRE, self.duration_us);
            }
        }
    };
    pub const CpuIdleStateEntryReader = struct {
        buf: gremlin.Reader,
        _state: ?[]const u8 = null,
        _duration_us: u64 = 0,
        pub fn init(src: []const u8) gremlin.Error!SysStats.CpuIdleStateEntryReader {
            const buf = gremlin.Reader.init(src);
            var res = SysStats.CpuIdleStateEntryReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    SysStats.CpuIdleStateEntryWire.STATE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._state = result.value;
                    },
                    SysStats.CpuIdleStateEntryWire.DURATION_US_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._duration_us = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getState(self: *const SysStats.CpuIdleStateEntryReader) []const u8 {
            return self._state orelse &[_]u8{};
        }
        pub inline fn getDurationUs(self: *const SysStats.CpuIdleStateEntryReader) u64 {
            return self._duration_us;
        }
    };
    const CpuIdleStateWire = struct {
        const CPU_ID_WIRE: gremlin.ProtoWireNumber = 1;
        const CPUIDLE_STATE_ENTRY_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const CpuIdleState = struct {
        // fields
        cpu_id: u32 = 0,
        cpuidle_state_entry: ?[]const ?SysStats.CpuIdleStateEntry = null,
        pub fn calcProtobufSize(self: *const SysStats.CpuIdleState) usize {
            var res: usize = 0;
            if (self.cpu_id != 0) {
                res += gremlin.sizes.sizeWireNumber(SysStats.CpuIdleStateWire.CPU_ID_WIRE) + gremlin.sizes.sizeU32(self.cpu_id);
            }
            if (self.cpuidle_state_entry) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(SysStats.CpuIdleStateWire.CPUIDLE_STATE_ENTRY_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const SysStats.CpuIdleState, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const SysStats.CpuIdleState, target: *gremlin.Writer) void {
            if (self.cpu_id != 0) {
                target.appendUint32(SysStats.CpuIdleStateWire.CPU_ID_WIRE, self.cpu_id);
            }
            if (self.cpuidle_state_entry) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(SysStats.CpuIdleStateWire.CPUIDLE_STATE_ENTRY_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(SysStats.CpuIdleStateWire.CPUIDLE_STATE_ENTRY_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const CpuIdleStateReader = struct {
        buf: gremlin.Reader,
        _cpu_id: u32 = 0,
        _cpuidle_state_entry_offset: ?usize = null,
        _cpuidle_state_entry_last_offset: ?usize = null,
        _cpuidle_state_entry_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!SysStats.CpuIdleStateReader {
            const buf = gremlin.Reader.init(src);
            var res = SysStats.CpuIdleStateReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    SysStats.CpuIdleStateWire.CPU_ID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._cpu_id = result.value;
                    },
                    SysStats.CpuIdleStateWire.CPUIDLE_STATE_ENTRY_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._cpuidle_state_entry_offset == null) {
                            res._cpuidle_state_entry_offset = offset - result.size;
                        }
                        res._cpuidle_state_entry_last_offset = offset;
                        res._cpuidle_state_entry_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getCpuId(self: *const SysStats.CpuIdleStateReader) u32 {
            return self._cpu_id;
        }
        pub fn cpuidleStateEntryCount(self: *const SysStats.CpuIdleStateReader) usize {
            return self._cpuidle_state_entry_cnt;
        }
        pub fn cpuidleStateEntryNext(self: *SysStats.CpuIdleStateReader) ?SysStats.CpuIdleStateEntryReader {
            if (self._cpuidle_state_entry_offset == null) return null;
            const current_offset = self._cpuidle_state_entry_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = SysStats.CpuIdleStateEntryReader.init(result.value) catch return null;
            if (self._cpuidle_state_entry_last_offset != null and current_offset >= self._cpuidle_state_entry_last_offset.?) {
                self._cpuidle_state_entry_offset = null;
                return msg;
            }
            if (self._cpuidle_state_entry_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._cpuidle_state_entry_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == SysStats.CpuIdleStateWire.CPUIDLE_STATE_ENTRY_WIRE) {
                    self._cpuidle_state_entry_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._cpuidle_state_entry_offset = null;
            return msg;
        }
    };
    // fields
    meminfo: ?[]const ?SysStats.MeminfoValue = null,
    vmstat: ?[]const ?SysStats.VmstatValue = null,
    cpu_stat: ?[]const ?SysStats.CpuTimes = null,
    num_forks: u64 = 0,
    num_irq_total: u64 = 0,
    num_irq: ?[]const ?SysStats.InterruptCount = null,
    num_softirq_total: u64 = 0,
    num_softirq: ?[]const ?SysStats.InterruptCount = null,
    collection_end_timestamp: u64 = 0,
    devfreq: ?[]const ?SysStats.DevfreqValue = null,
    cpufreq_khz: ?[]const u32 = null,
    buddy_info: ?[]const ?SysStats.BuddyInfo = null,
    disk_stat: ?[]const ?SysStats.DiskStat = null,
    psi: ?[]const ?SysStats.PsiSample = null,
    thermal_zone: ?[]const ?SysStats.ThermalZone = null,
    cpuidle_state: ?[]const ?SysStats.CpuIdleState = null,
    gpufreq_mhz: ?[]const u64 = null,
    pub fn calcProtobufSize(self: *const SysStats) usize {
        var res: usize = 0;
        if (self.meminfo) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(SysStatsWire.MEMINFO_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.vmstat) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(SysStatsWire.VMSTAT_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.cpu_stat) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(SysStatsWire.CPU_STAT_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.num_forks != 0) {
            res += gremlin.sizes.sizeWireNumber(SysStatsWire.NUM_FORKS_WIRE) + gremlin.sizes.sizeU64(self.num_forks);
        }
        if (self.num_irq_total != 0) {
            res += gremlin.sizes.sizeWireNumber(SysStatsWire.NUM_IRQ_TOTAL_WIRE) + gremlin.sizes.sizeU64(self.num_irq_total);
        }
        if (self.num_irq) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(SysStatsWire.NUM_IRQ_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.num_softirq_total != 0) {
            res += gremlin.sizes.sizeWireNumber(SysStatsWire.NUM_SOFTIRQ_TOTAL_WIRE) + gremlin.sizes.sizeU64(self.num_softirq_total);
        }
        if (self.num_softirq) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(SysStatsWire.NUM_SOFTIRQ_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.collection_end_timestamp != 0) {
            res += gremlin.sizes.sizeWireNumber(SysStatsWire.COLLECTION_END_TIMESTAMP_WIRE) + gremlin.sizes.sizeU64(self.collection_end_timestamp);
        }
        if (self.devfreq) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(SysStatsWire.DEVFREQ_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.cpufreq_khz) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(SysStatsWire.CPUFREQ_KHZ_WIRE) + gremlin.sizes.sizeU32(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU32(v);
                }
                res += gremlin.sizes.sizeWireNumber(SysStatsWire.CPUFREQ_KHZ_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.buddy_info) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(SysStatsWire.BUDDY_INFO_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.disk_stat) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(SysStatsWire.DISK_STAT_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.psi) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(SysStatsWire.PSI_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.thermal_zone) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(SysStatsWire.THERMAL_ZONE_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.cpuidle_state) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(SysStatsWire.CPUIDLE_STATE_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.gpufreq_mhz) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(SysStatsWire.GPUFREQ_MHZ_WIRE) + gremlin.sizes.sizeU64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                res += gremlin.sizes.sizeWireNumber(SysStatsWire.GPUFREQ_MHZ_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        return res;
    }
    pub fn encode(self: *const SysStats, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SysStats, target: *gremlin.Writer) void {
        if (self.meminfo) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(SysStatsWire.MEMINFO_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(SysStatsWire.MEMINFO_WIRE, 0);
                }
            }
        }
        if (self.vmstat) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(SysStatsWire.VMSTAT_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(SysStatsWire.VMSTAT_WIRE, 0);
                }
            }
        }
        if (self.cpu_stat) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(SysStatsWire.CPU_STAT_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(SysStatsWire.CPU_STAT_WIRE, 0);
                }
            }
        }
        if (self.num_forks != 0) {
            target.appendUint64(SysStatsWire.NUM_FORKS_WIRE, self.num_forks);
        }
        if (self.num_irq_total != 0) {
            target.appendUint64(SysStatsWire.NUM_IRQ_TOTAL_WIRE, self.num_irq_total);
        }
        if (self.num_irq) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(SysStatsWire.NUM_IRQ_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(SysStatsWire.NUM_IRQ_WIRE, 0);
                }
            }
        }
        if (self.num_softirq_total != 0) {
            target.appendUint64(SysStatsWire.NUM_SOFTIRQ_TOTAL_WIRE, self.num_softirq_total);
        }
        if (self.num_softirq) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(SysStatsWire.NUM_SOFTIRQ_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(SysStatsWire.NUM_SOFTIRQ_WIRE, 0);
                }
            }
        }
        if (self.collection_end_timestamp != 0) {
            target.appendUint64(SysStatsWire.COLLECTION_END_TIMESTAMP_WIRE, self.collection_end_timestamp);
        }
        if (self.devfreq) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(SysStatsWire.DEVFREQ_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(SysStatsWire.DEVFREQ_WIRE, 0);
                }
            }
        }
        if (self.cpufreq_khz) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint32(SysStatsWire.CPUFREQ_KHZ_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU32(v);
                }
                target.appendBytesTag(SysStatsWire.CPUFREQ_KHZ_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint32WithoutTag(v);
                }
            }
        }
        if (self.buddy_info) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(SysStatsWire.BUDDY_INFO_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(SysStatsWire.BUDDY_INFO_WIRE, 0);
                }
            }
        }
        if (self.disk_stat) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(SysStatsWire.DISK_STAT_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(SysStatsWire.DISK_STAT_WIRE, 0);
                }
            }
        }
        if (self.psi) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(SysStatsWire.PSI_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(SysStatsWire.PSI_WIRE, 0);
                }
            }
        }
        if (self.thermal_zone) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(SysStatsWire.THERMAL_ZONE_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(SysStatsWire.THERMAL_ZONE_WIRE, 0);
                }
            }
        }
        if (self.cpuidle_state) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(SysStatsWire.CPUIDLE_STATE_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(SysStatsWire.CPUIDLE_STATE_WIRE, 0);
                }
            }
        }
        if (self.gpufreq_mhz) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint64(SysStatsWire.GPUFREQ_MHZ_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                target.appendBytesTag(SysStatsWire.GPUFREQ_MHZ_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint64WithoutTag(v);
                }
            }
        }
    }
};
pub const SysStatsReader = struct {
    buf: gremlin.Reader,
    _meminfo_offset: ?usize = null,
    _meminfo_last_offset: ?usize = null,
    _meminfo_cnt: usize = 0,
    _vmstat_offset: ?usize = null,
    _vmstat_last_offset: ?usize = null,
    _vmstat_cnt: usize = 0,
    _cpu_stat_offset: ?usize = null,
    _cpu_stat_last_offset: ?usize = null,
    _cpu_stat_cnt: usize = 0,
    _num_forks: u64 = 0,
    _num_irq_total: u64 = 0,
    _num_irq_offset: ?usize = null,
    _num_irq_last_offset: ?usize = null,
    _num_irq_cnt: usize = 0,
    _num_softirq_total: u64 = 0,
    _num_softirq_offset: ?usize = null,
    _num_softirq_last_offset: ?usize = null,
    _num_softirq_cnt: usize = 0,
    _collection_end_timestamp: u64 = 0,
    _devfreq_offset: ?usize = null,
    _devfreq_last_offset: ?usize = null,
    _devfreq_cnt: usize = 0,
    _cpufreq_khz_offset: ?usize = null,
    _cpufreq_khz_last_offset: ?usize = null,
    _cpufreq_khz_packed: bool = false,
    _buddy_info_offset: ?usize = null,
    _buddy_info_last_offset: ?usize = null,
    _buddy_info_cnt: usize = 0,
    _disk_stat_offset: ?usize = null,
    _disk_stat_last_offset: ?usize = null,
    _disk_stat_cnt: usize = 0,
    _psi_offset: ?usize = null,
    _psi_last_offset: ?usize = null,
    _psi_cnt: usize = 0,
    _thermal_zone_offset: ?usize = null,
    _thermal_zone_last_offset: ?usize = null,
    _thermal_zone_cnt: usize = 0,
    _cpuidle_state_offset: ?usize = null,
    _cpuidle_state_last_offset: ?usize = null,
    _cpuidle_state_cnt: usize = 0,
    _gpufreq_mhz_offset: ?usize = null,
    _gpufreq_mhz_last_offset: ?usize = null,
    _gpufreq_mhz_packed: bool = false,
    pub fn init(src: []const u8) gremlin.Error!SysStatsReader {
        const buf = gremlin.Reader.init(src);
        var res = SysStatsReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SysStatsWire.MEMINFO_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._meminfo_offset == null) {
                        res._meminfo_offset = offset - result.size;
                    }
                    res._meminfo_last_offset = offset;
                    res._meminfo_cnt += 1;
                },
                SysStatsWire.VMSTAT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._vmstat_offset == null) {
                        res._vmstat_offset = offset - result.size;
                    }
                    res._vmstat_last_offset = offset;
                    res._vmstat_cnt += 1;
                },
                SysStatsWire.CPU_STAT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._cpu_stat_offset == null) {
                        res._cpu_stat_offset = offset - result.size;
                    }
                    res._cpu_stat_last_offset = offset;
                    res._cpu_stat_cnt += 1;
                },
                SysStatsWire.NUM_FORKS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._num_forks = result.value;
                },
                SysStatsWire.NUM_IRQ_TOTAL_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._num_irq_total = result.value;
                },
                SysStatsWire.NUM_IRQ_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._num_irq_offset == null) {
                        res._num_irq_offset = offset - result.size;
                    }
                    res._num_irq_last_offset = offset;
                    res._num_irq_cnt += 1;
                },
                SysStatsWire.NUM_SOFTIRQ_TOTAL_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._num_softirq_total = result.value;
                },
                SysStatsWire.NUM_SOFTIRQ_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._num_softirq_offset == null) {
                        res._num_softirq_offset = offset - result.size;
                    }
                    res._num_softirq_last_offset = offset;
                    res._num_softirq_cnt += 1;
                },
                SysStatsWire.COLLECTION_END_TIMESTAMP_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._collection_end_timestamp = result.value;
                },
                SysStatsWire.DEVFREQ_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._devfreq_offset == null) {
                        res._devfreq_offset = offset - result.size;
                    }
                    res._devfreq_last_offset = offset;
                    res._devfreq_cnt += 1;
                },
                SysStatsWire.CPUFREQ_KHZ_WIRE => {
                    if (res._cpufreq_khz_offset == null) {
                        res._cpufreq_khz_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._cpufreq_khz_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._cpufreq_khz_offset = offset + length_result.size;
                        res._cpufreq_khz_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._cpufreq_khz_last_offset.?;
                    } else {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._cpufreq_khz_last_offset = offset;
                    }
                },
                SysStatsWire.BUDDY_INFO_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._buddy_info_offset == null) {
                        res._buddy_info_offset = offset - result.size;
                    }
                    res._buddy_info_last_offset = offset;
                    res._buddy_info_cnt += 1;
                },
                SysStatsWire.DISK_STAT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._disk_stat_offset == null) {
                        res._disk_stat_offset = offset - result.size;
                    }
                    res._disk_stat_last_offset = offset;
                    res._disk_stat_cnt += 1;
                },
                SysStatsWire.PSI_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._psi_offset == null) {
                        res._psi_offset = offset - result.size;
                    }
                    res._psi_last_offset = offset;
                    res._psi_cnt += 1;
                },
                SysStatsWire.THERMAL_ZONE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._thermal_zone_offset == null) {
                        res._thermal_zone_offset = offset - result.size;
                    }
                    res._thermal_zone_last_offset = offset;
                    res._thermal_zone_cnt += 1;
                },
                SysStatsWire.CPUIDLE_STATE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._cpuidle_state_offset == null) {
                        res._cpuidle_state_offset = offset - result.size;
                    }
                    res._cpuidle_state_last_offset = offset;
                    res._cpuidle_state_cnt += 1;
                },
                SysStatsWire.GPUFREQ_MHZ_WIRE => {
                    if (res._gpufreq_mhz_offset == null) {
                        res._gpufreq_mhz_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._gpufreq_mhz_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._gpufreq_mhz_offset = offset + length_result.size;
                        res._gpufreq_mhz_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._gpufreq_mhz_last_offset.?;
                    } else {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._gpufreq_mhz_last_offset = offset;
                    }
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn meminfoCount(self: *const SysStatsReader) usize {
        return self._meminfo_cnt;
    }
    pub fn meminfoNext(self: *SysStatsReader) ?SysStats.MeminfoValueReader {
        if (self._meminfo_offset == null) return null;
        const current_offset = self._meminfo_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = SysStats.MeminfoValueReader.init(result.value) catch return null;
        if (self._meminfo_last_offset != null and current_offset >= self._meminfo_last_offset.?) {
            self._meminfo_offset = null;
            return msg;
        }
        if (self._meminfo_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._meminfo_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == SysStatsWire.MEMINFO_WIRE) {
                self._meminfo_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._meminfo_offset = null;
        return msg;
    }
    pub fn vmstatCount(self: *const SysStatsReader) usize {
        return self._vmstat_cnt;
    }
    pub fn vmstatNext(self: *SysStatsReader) ?SysStats.VmstatValueReader {
        if (self._vmstat_offset == null) return null;
        const current_offset = self._vmstat_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = SysStats.VmstatValueReader.init(result.value) catch return null;
        if (self._vmstat_last_offset != null and current_offset >= self._vmstat_last_offset.?) {
            self._vmstat_offset = null;
            return msg;
        }
        if (self._vmstat_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._vmstat_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == SysStatsWire.VMSTAT_WIRE) {
                self._vmstat_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._vmstat_offset = null;
        return msg;
    }
    pub fn cpuStatCount(self: *const SysStatsReader) usize {
        return self._cpu_stat_cnt;
    }
    pub fn cpuStatNext(self: *SysStatsReader) ?SysStats.CpuTimesReader {
        if (self._cpu_stat_offset == null) return null;
        const current_offset = self._cpu_stat_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = SysStats.CpuTimesReader.init(result.value) catch return null;
        if (self._cpu_stat_last_offset != null and current_offset >= self._cpu_stat_last_offset.?) {
            self._cpu_stat_offset = null;
            return msg;
        }
        if (self._cpu_stat_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._cpu_stat_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == SysStatsWire.CPU_STAT_WIRE) {
                self._cpu_stat_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._cpu_stat_offset = null;
        return msg;
    }
    pub inline fn getNumForks(self: *const SysStatsReader) u64 {
        return self._num_forks;
    }
    pub inline fn getNumIrqTotal(self: *const SysStatsReader) u64 {
        return self._num_irq_total;
    }
    pub fn numIrqCount(self: *const SysStatsReader) usize {
        return self._num_irq_cnt;
    }
    pub fn numIrqNext(self: *SysStatsReader) ?SysStats.InterruptCountReader {
        if (self._num_irq_offset == null) return null;
        const current_offset = self._num_irq_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = SysStats.InterruptCountReader.init(result.value) catch return null;
        if (self._num_irq_last_offset != null and current_offset >= self._num_irq_last_offset.?) {
            self._num_irq_offset = null;
            return msg;
        }
        if (self._num_irq_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._num_irq_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == SysStatsWire.NUM_IRQ_WIRE) {
                self._num_irq_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._num_irq_offset = null;
        return msg;
    }
    pub inline fn getNumSoftirqTotal(self: *const SysStatsReader) u64 {
        return self._num_softirq_total;
    }
    pub fn numSoftirqCount(self: *const SysStatsReader) usize {
        return self._num_softirq_cnt;
    }
    pub fn numSoftirqNext(self: *SysStatsReader) ?SysStats.InterruptCountReader {
        if (self._num_softirq_offset == null) return null;
        const current_offset = self._num_softirq_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = SysStats.InterruptCountReader.init(result.value) catch return null;
        if (self._num_softirq_last_offset != null and current_offset >= self._num_softirq_last_offset.?) {
            self._num_softirq_offset = null;
            return msg;
        }
        if (self._num_softirq_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._num_softirq_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == SysStatsWire.NUM_SOFTIRQ_WIRE) {
                self._num_softirq_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._num_softirq_offset = null;
        return msg;
    }
    pub inline fn getCollectionEndTimestamp(self: *const SysStatsReader) u64 {
        return self._collection_end_timestamp;
    }
    pub fn devfreqCount(self: *const SysStatsReader) usize {
        return self._devfreq_cnt;
    }
    pub fn devfreqNext(self: *SysStatsReader) ?SysStats.DevfreqValueReader {
        if (self._devfreq_offset == null) return null;
        const current_offset = self._devfreq_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = SysStats.DevfreqValueReader.init(result.value) catch return null;
        if (self._devfreq_last_offset != null and current_offset >= self._devfreq_last_offset.?) {
            self._devfreq_offset = null;
            return msg;
        }
        if (self._devfreq_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._devfreq_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == SysStatsWire.DEVFREQ_WIRE) {
                self._devfreq_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._devfreq_offset = null;
        return msg;
    }
    pub fn cpufreqKhzNext(self: *SysStatsReader) gremlin.Error!?u32 {
        if (self._cpufreq_khz_offset == null) return null;
        const current_offset = self._cpufreq_khz_offset.?;
        if (current_offset >= self._cpufreq_khz_last_offset.?) {
            self._cpufreq_khz_offset = null;
            return null;
        }
        if (self._cpufreq_khz_packed) {
            const value_result = try self.buf.readUInt32(current_offset);
            self._cpufreq_khz_offset = current_offset + value_result.size;
            if (self._cpufreq_khz_offset.? >= self._cpufreq_khz_last_offset.?) {
                self._cpufreq_khz_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._cpufreq_khz_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == SysStatsWire.CPUFREQ_KHZ_WIRE) {
                    self._cpufreq_khz_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._cpufreq_khz_offset = null;
            return value_result.value;
        }
    }
    pub fn buddyInfoCount(self: *const SysStatsReader) usize {
        return self._buddy_info_cnt;
    }
    pub fn buddyInfoNext(self: *SysStatsReader) ?SysStats.BuddyInfoReader {
        if (self._buddy_info_offset == null) return null;
        const current_offset = self._buddy_info_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = SysStats.BuddyInfoReader.init(result.value) catch return null;
        if (self._buddy_info_last_offset != null and current_offset >= self._buddy_info_last_offset.?) {
            self._buddy_info_offset = null;
            return msg;
        }
        if (self._buddy_info_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._buddy_info_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == SysStatsWire.BUDDY_INFO_WIRE) {
                self._buddy_info_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._buddy_info_offset = null;
        return msg;
    }
    pub fn diskStatCount(self: *const SysStatsReader) usize {
        return self._disk_stat_cnt;
    }
    pub fn diskStatNext(self: *SysStatsReader) ?SysStats.DiskStatReader {
        if (self._disk_stat_offset == null) return null;
        const current_offset = self._disk_stat_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = SysStats.DiskStatReader.init(result.value) catch return null;
        if (self._disk_stat_last_offset != null and current_offset >= self._disk_stat_last_offset.?) {
            self._disk_stat_offset = null;
            return msg;
        }
        if (self._disk_stat_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._disk_stat_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == SysStatsWire.DISK_STAT_WIRE) {
                self._disk_stat_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._disk_stat_offset = null;
        return msg;
    }
    pub fn psiCount(self: *const SysStatsReader) usize {
        return self._psi_cnt;
    }
    pub fn psiNext(self: *SysStatsReader) ?SysStats.PsiSampleReader {
        if (self._psi_offset == null) return null;
        const current_offset = self._psi_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = SysStats.PsiSampleReader.init(result.value) catch return null;
        if (self._psi_last_offset != null and current_offset >= self._psi_last_offset.?) {
            self._psi_offset = null;
            return msg;
        }
        if (self._psi_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._psi_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == SysStatsWire.PSI_WIRE) {
                self._psi_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._psi_offset = null;
        return msg;
    }
    pub fn thermalZoneCount(self: *const SysStatsReader) usize {
        return self._thermal_zone_cnt;
    }
    pub fn thermalZoneNext(self: *SysStatsReader) ?SysStats.ThermalZoneReader {
        if (self._thermal_zone_offset == null) return null;
        const current_offset = self._thermal_zone_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = SysStats.ThermalZoneReader.init(result.value) catch return null;
        if (self._thermal_zone_last_offset != null and current_offset >= self._thermal_zone_last_offset.?) {
            self._thermal_zone_offset = null;
            return msg;
        }
        if (self._thermal_zone_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._thermal_zone_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == SysStatsWire.THERMAL_ZONE_WIRE) {
                self._thermal_zone_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._thermal_zone_offset = null;
        return msg;
    }
    pub fn cpuidleStateCount(self: *const SysStatsReader) usize {
        return self._cpuidle_state_cnt;
    }
    pub fn cpuidleStateNext(self: *SysStatsReader) ?SysStats.CpuIdleStateReader {
        if (self._cpuidle_state_offset == null) return null;
        const current_offset = self._cpuidle_state_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = SysStats.CpuIdleStateReader.init(result.value) catch return null;
        if (self._cpuidle_state_last_offset != null and current_offset >= self._cpuidle_state_last_offset.?) {
            self._cpuidle_state_offset = null;
            return msg;
        }
        if (self._cpuidle_state_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._cpuidle_state_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == SysStatsWire.CPUIDLE_STATE_WIRE) {
                self._cpuidle_state_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._cpuidle_state_offset = null;
        return msg;
    }
    pub fn gpufreqMhzNext(self: *SysStatsReader) gremlin.Error!?u64 {
        if (self._gpufreq_mhz_offset == null) return null;
        const current_offset = self._gpufreq_mhz_offset.?;
        if (current_offset >= self._gpufreq_mhz_last_offset.?) {
            self._gpufreq_mhz_offset = null;
            return null;
        }
        if (self._gpufreq_mhz_packed) {
            const value_result = try self.buf.readUInt64(current_offset);
            self._gpufreq_mhz_offset = current_offset + value_result.size;
            if (self._gpufreq_mhz_offset.? >= self._gpufreq_mhz_last_offset.?) {
                self._gpufreq_mhz_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._gpufreq_mhz_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == SysStatsWire.GPUFREQ_MHZ_WIRE) {
                    self._gpufreq_mhz_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._gpufreq_mhz_offset = null;
            return value_result.value;
        }
    }
};
