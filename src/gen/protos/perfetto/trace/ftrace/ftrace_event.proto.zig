// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
const ftrace = @import("ftrace.proto.zig");
const sched = @import("sched.proto.zig");
const power = @import("power.proto.zig");
const ipi = @import("ipi.proto.zig");
const irq = @import("irq.proto.zig");
const i2c = @import("i2c.proto.zig");
const lowmemorykiller = @import("lowmemorykiller.proto.zig");
const sync = @import("sync.proto.zig");
const ext4 = @import("ext4.proto.zig");
const block = @import("block.proto.zig");
const vmscan = @import("vmscan.proto.zig");
const binder = @import("binder.proto.zig");
const workqueue = @import("workqueue.proto.zig");
const regulator = @import("regulator.proto.zig");
const cgroup = @import("cgroup.proto.zig");
const mdss = @import("mdss.proto.zig");
const filemap = @import("filemap.proto.zig");
const compaction = @import("compaction.proto.zig");
const task = @import("task.proto.zig");
const f2fs = @import("f2fs.proto.zig");
const kmem = @import("kmem.proto.zig");
const fence = @import("fence.proto.zig");
const clk = @import("clk.proto.zig");
const signal = @import("signal.proto.zig");
const oom = @import("oom.proto.zig");
const generic = @import("generic.proto.zig");
const mm_event = @import("mm_event.proto.zig");
const raw_syscalls = @import("raw_syscalls.proto.zig");
const systrace = @import("systrace.proto.zig");
const sde = @import("sde.proto.zig");
const ion = @import("ion.proto.zig");
const scm = @import("scm.proto.zig");
const gpu_mem = @import("gpu_mem.proto.zig");
const thermal = @import("thermal.proto.zig");
const cpuhp = @import("cpuhp.proto.zig");
const fastrpc = @import("fastrpc.proto.zig");
const dpu = @import("dpu.proto.zig");
const g2d = @import("g2d.proto.zig");
const mali = @import("mali.proto.zig");
const dmabuf_heap = @import("dmabuf_heap.proto.zig");
const synthetic = @import("synthetic.proto.zig");
const net = @import("net.proto.zig");
const sock = @import("sock.proto.zig");
const tcp = @import("tcp.proto.zig");
const cros_ec = @import("cros_ec.proto.zig");
const skb = @import("skb.proto.zig");
const kvm = @import("kvm.proto.zig");
const ufs = @import("ufs.proto.zig");
const printk = @import("printk.proto.zig");
const drm = @import("drm.proto.zig");
const gpu_scheduler = @import("gpu_scheduler.proto.zig");
const dma_fence = @import("dma_fence.proto.zig");
const v4l2 = @import("v4l2.proto.zig");
const panel = @import("panel.proto.zig");
const android_fs = @import("android_fs.proto.zig");
const virtio_video = @import("virtio_video.proto.zig");
const trusty = @import("trusty.proto.zig");
const cma = @import("cma.proto.zig");
const lwis = @import("lwis.proto.zig");
const virtio_gpu = @import("virtio_gpu.proto.zig");
const hyp = @import("hyp.proto.zig");
const samsung = @import("samsung.proto.zig");
const perf_trace_counters = @import("perf_trace_counters.proto.zig");
const rpm = @import("rpm.proto.zig");
const google_icc_trace = @import("google_icc_trace.proto.zig");
const google_irm_trace = @import("google_irm_trace.proto.zig");
const thermal_exynos = @import("thermal_exynos.proto.zig");
const dcvsh = @import("dcvsh.proto.zig");
const kgsl = @import("kgsl.proto.zig");
const bcl_exynos = @import("bcl_exynos.proto.zig");
const pixel_mm = @import("pixel_mm.proto.zig");
const devfreq = @import("devfreq.proto.zig");
const cpm_trace = @import("cpm_trace.proto.zig");
const fs = @import("fs.proto.zig");
const timer = @import("timer.proto.zig");
const irq_vectors = @import("irq_vectors.proto.zig");
const dwc3 = @import("dwc3.proto.zig");
const hypervisor = @import("hypervisor.proto.zig");
const fwtp_ftrace = @import("fwtp_ftrace.proto.zig");
// structs
const FtraceEventWire = struct {
    const TIMESTAMP_WIRE: gremlin.ProtoWireNumber = 1;
    const PID_WIRE: gremlin.ProtoWireNumber = 2;
    const COMMON_FLAGS_WIRE: gremlin.ProtoWireNumber = 5;
    const PRINT_WIRE: gremlin.ProtoWireNumber = 3;
    const SCHED_SWITCH_WIRE: gremlin.ProtoWireNumber = 4;
    const CPU_FREQUENCY_WIRE: gremlin.ProtoWireNumber = 11;
    const CPU_FREQUENCY_LIMITS_WIRE: gremlin.ProtoWireNumber = 12;
    const CPU_IDLE_WIRE: gremlin.ProtoWireNumber = 13;
    const CLOCK_ENABLE_WIRE: gremlin.ProtoWireNumber = 14;
    const CLOCK_DISABLE_WIRE: gremlin.ProtoWireNumber = 15;
    const CLOCK_SET_RATE_WIRE: gremlin.ProtoWireNumber = 16;
    const SCHED_WAKEUP_WIRE: gremlin.ProtoWireNumber = 17;
    const SCHED_BLOCKED_REASON_WIRE: gremlin.ProtoWireNumber = 18;
    const SCHED_CPU_HOTPLUG_WIRE: gremlin.ProtoWireNumber = 19;
    const SCHED_WAKING_WIRE: gremlin.ProtoWireNumber = 20;
    const IPI_ENTRY_WIRE: gremlin.ProtoWireNumber = 21;
    const IPI_EXIT_WIRE: gremlin.ProtoWireNumber = 22;
    const IPI_RAISE_WIRE: gremlin.ProtoWireNumber = 23;
    const SOFTIRQ_ENTRY_WIRE: gremlin.ProtoWireNumber = 24;
    const SOFTIRQ_EXIT_WIRE: gremlin.ProtoWireNumber = 25;
    const SOFTIRQ_RAISE_WIRE: gremlin.ProtoWireNumber = 26;
    const I2C_READ_WIRE: gremlin.ProtoWireNumber = 27;
    const I2C_WRITE_WIRE: gremlin.ProtoWireNumber = 28;
    const I2C_RESULT_WIRE: gremlin.ProtoWireNumber = 29;
    const I2C_REPLY_WIRE: gremlin.ProtoWireNumber = 30;
    const SMBUS_READ_WIRE: gremlin.ProtoWireNumber = 31;
    const SMBUS_WRITE_WIRE: gremlin.ProtoWireNumber = 32;
    const SMBUS_RESULT_WIRE: gremlin.ProtoWireNumber = 33;
    const SMBUS_REPLY_WIRE: gremlin.ProtoWireNumber = 34;
    const LOWMEMORY_KILL_WIRE: gremlin.ProtoWireNumber = 35;
    const IRQ_HANDLER_ENTRY_WIRE: gremlin.ProtoWireNumber = 36;
    const IRQ_HANDLER_EXIT_WIRE: gremlin.ProtoWireNumber = 37;
    const SYNC_PT_WIRE: gremlin.ProtoWireNumber = 38;
    const SYNC_TIMELINE_WIRE: gremlin.ProtoWireNumber = 39;
    const SYNC_WAIT_WIRE: gremlin.ProtoWireNumber = 40;
    const EXT4_DA_WRITE_BEGIN_WIRE: gremlin.ProtoWireNumber = 41;
    const EXT4_DA_WRITE_END_WIRE: gremlin.ProtoWireNumber = 42;
    const EXT4_SYNC_FILE_ENTER_WIRE: gremlin.ProtoWireNumber = 43;
    const EXT4_SYNC_FILE_EXIT_WIRE: gremlin.ProtoWireNumber = 44;
    const BLOCK_RQ_ISSUE_WIRE: gremlin.ProtoWireNumber = 45;
    const MM_VMSCAN_DIRECT_RECLAIM_BEGIN_WIRE: gremlin.ProtoWireNumber = 46;
    const MM_VMSCAN_DIRECT_RECLAIM_END_WIRE: gremlin.ProtoWireNumber = 47;
    const MM_VMSCAN_KSWAPD_WAKE_WIRE: gremlin.ProtoWireNumber = 48;
    const MM_VMSCAN_KSWAPD_SLEEP_WIRE: gremlin.ProtoWireNumber = 49;
    const BINDER_TRANSACTION_WIRE: gremlin.ProtoWireNumber = 50;
    const BINDER_TRANSACTION_RECEIVED_WIRE: gremlin.ProtoWireNumber = 51;
    const BINDER_SET_PRIORITY_WIRE: gremlin.ProtoWireNumber = 52;
    const BINDER_LOCK_WIRE: gremlin.ProtoWireNumber = 53;
    const BINDER_LOCKED_WIRE: gremlin.ProtoWireNumber = 54;
    const BINDER_UNLOCK_WIRE: gremlin.ProtoWireNumber = 55;
    const WORKQUEUE_ACTIVATE_WORK_WIRE: gremlin.ProtoWireNumber = 56;
    const WORKQUEUE_EXECUTE_END_WIRE: gremlin.ProtoWireNumber = 57;
    const WORKQUEUE_EXECUTE_START_WIRE: gremlin.ProtoWireNumber = 58;
    const WORKQUEUE_QUEUE_WORK_WIRE: gremlin.ProtoWireNumber = 59;
    const REGULATOR_DISABLE_WIRE: gremlin.ProtoWireNumber = 60;
    const REGULATOR_DISABLE_COMPLETE_WIRE: gremlin.ProtoWireNumber = 61;
    const REGULATOR_ENABLE_WIRE: gremlin.ProtoWireNumber = 62;
    const REGULATOR_ENABLE_COMPLETE_WIRE: gremlin.ProtoWireNumber = 63;
    const REGULATOR_ENABLE_DELAY_WIRE: gremlin.ProtoWireNumber = 64;
    const REGULATOR_SET_VOLTAGE_WIRE: gremlin.ProtoWireNumber = 65;
    const REGULATOR_SET_VOLTAGE_COMPLETE_WIRE: gremlin.ProtoWireNumber = 66;
    const CGROUP_ATTACH_TASK_WIRE: gremlin.ProtoWireNumber = 67;
    const CGROUP_MKDIR_WIRE: gremlin.ProtoWireNumber = 68;
    const CGROUP_REMOUNT_WIRE: gremlin.ProtoWireNumber = 69;
    const CGROUP_RMDIR_WIRE: gremlin.ProtoWireNumber = 70;
    const CGROUP_TRANSFER_TASKS_WIRE: gremlin.ProtoWireNumber = 71;
    const CGROUP_DESTROY_ROOT_WIRE: gremlin.ProtoWireNumber = 72;
    const CGROUP_RELEASE_WIRE: gremlin.ProtoWireNumber = 73;
    const CGROUP_RENAME_WIRE: gremlin.ProtoWireNumber = 74;
    const CGROUP_SETUP_ROOT_WIRE: gremlin.ProtoWireNumber = 75;
    const MDP_CMD_KICKOFF_WIRE: gremlin.ProtoWireNumber = 76;
    const MDP_COMMIT_WIRE: gremlin.ProtoWireNumber = 77;
    const MDP_PERF_SET_OT_WIRE: gremlin.ProtoWireNumber = 78;
    const MDP_SSPP_CHANGE_WIRE: gremlin.ProtoWireNumber = 79;
    const TRACING_MARK_WRITE_WIRE: gremlin.ProtoWireNumber = 80;
    const MDP_CMD_PINGPONG_DONE_WIRE: gremlin.ProtoWireNumber = 81;
    const MDP_COMPARE_BW_WIRE: gremlin.ProtoWireNumber = 82;
    const MDP_PERF_SET_PANIC_LUTS_WIRE: gremlin.ProtoWireNumber = 83;
    const MDP_SSPP_SET_WIRE: gremlin.ProtoWireNumber = 84;
    const MDP_CMD_READPTR_DONE_WIRE: gremlin.ProtoWireNumber = 85;
    const MDP_MISR_CRC_WIRE: gremlin.ProtoWireNumber = 86;
    const MDP_PERF_SET_QOS_LUTS_WIRE: gremlin.ProtoWireNumber = 87;
    const MDP_TRACE_COUNTER_WIRE: gremlin.ProtoWireNumber = 88;
    const MDP_CMD_RELEASE_BW_WIRE: gremlin.ProtoWireNumber = 89;
    const MDP_MIXER_UPDATE_WIRE: gremlin.ProtoWireNumber = 90;
    const MDP_PERF_SET_WM_LEVELS_WIRE: gremlin.ProtoWireNumber = 91;
    const MDP_VIDEO_UNDERRUN_DONE_WIRE: gremlin.ProtoWireNumber = 92;
    const MDP_CMD_WAIT_PINGPONG_WIRE: gremlin.ProtoWireNumber = 93;
    const MDP_PERF_PREFILL_CALC_WIRE: gremlin.ProtoWireNumber = 94;
    const MDP_PERF_UPDATE_BUS_WIRE: gremlin.ProtoWireNumber = 95;
    const ROTATOR_BW_AO_AS_CONTEXT_WIRE: gremlin.ProtoWireNumber = 96;
    const MM_FILEMAP_ADD_TO_PAGE_CACHE_WIRE: gremlin.ProtoWireNumber = 97;
    const MM_FILEMAP_DELETE_FROM_PAGE_CACHE_WIRE: gremlin.ProtoWireNumber = 98;
    const MM_COMPACTION_BEGIN_WIRE: gremlin.ProtoWireNumber = 99;
    const MM_COMPACTION_DEFER_COMPACTION_WIRE: gremlin.ProtoWireNumber = 100;
    const MM_COMPACTION_DEFERRED_WIRE: gremlin.ProtoWireNumber = 101;
    const MM_COMPACTION_DEFER_RESET_WIRE: gremlin.ProtoWireNumber = 102;
    const MM_COMPACTION_END_WIRE: gremlin.ProtoWireNumber = 103;
    const MM_COMPACTION_FINISHED_WIRE: gremlin.ProtoWireNumber = 104;
    const MM_COMPACTION_ISOLATE_FREEPAGES_WIRE: gremlin.ProtoWireNumber = 105;
    const MM_COMPACTION_ISOLATE_MIGRATEPAGES_WIRE: gremlin.ProtoWireNumber = 106;
    const MM_COMPACTION_KCOMPACTD_SLEEP_WIRE: gremlin.ProtoWireNumber = 107;
    const MM_COMPACTION_KCOMPACTD_WAKE_WIRE: gremlin.ProtoWireNumber = 108;
    const MM_COMPACTION_MIGRATEPAGES_WIRE: gremlin.ProtoWireNumber = 109;
    const MM_COMPACTION_SUITABLE_WIRE: gremlin.ProtoWireNumber = 110;
    const MM_COMPACTION_TRY_TO_COMPACT_PAGES_WIRE: gremlin.ProtoWireNumber = 111;
    const MM_COMPACTION_WAKEUP_KCOMPACTD_WIRE: gremlin.ProtoWireNumber = 112;
    const SUSPEND_RESUME_WIRE: gremlin.ProtoWireNumber = 113;
    const SCHED_WAKEUP_NEW_WIRE: gremlin.ProtoWireNumber = 114;
    const BLOCK_BIO_BACKMERGE_WIRE: gremlin.ProtoWireNumber = 115;
    const BLOCK_BIO_BOUNCE_WIRE: gremlin.ProtoWireNumber = 116;
    const BLOCK_BIO_COMPLETE_WIRE: gremlin.ProtoWireNumber = 117;
    const BLOCK_BIO_FRONTMERGE_WIRE: gremlin.ProtoWireNumber = 118;
    const BLOCK_BIO_QUEUE_WIRE: gremlin.ProtoWireNumber = 119;
    const BLOCK_BIO_REMAP_WIRE: gremlin.ProtoWireNumber = 120;
    const BLOCK_DIRTY_BUFFER_WIRE: gremlin.ProtoWireNumber = 121;
    const BLOCK_GETRQ_WIRE: gremlin.ProtoWireNumber = 122;
    const BLOCK_PLUG_WIRE: gremlin.ProtoWireNumber = 123;
    const BLOCK_RQ_ABORT_WIRE: gremlin.ProtoWireNumber = 124;
    const BLOCK_RQ_COMPLETE_WIRE: gremlin.ProtoWireNumber = 125;
    const BLOCK_RQ_INSERT_WIRE: gremlin.ProtoWireNumber = 126;
    const BLOCK_RQ_REMAP_WIRE: gremlin.ProtoWireNumber = 128;
    const BLOCK_RQ_REQUEUE_WIRE: gremlin.ProtoWireNumber = 129;
    const BLOCK_SLEEPRQ_WIRE: gremlin.ProtoWireNumber = 130;
    const BLOCK_SPLIT_WIRE: gremlin.ProtoWireNumber = 131;
    const BLOCK_TOUCH_BUFFER_WIRE: gremlin.ProtoWireNumber = 132;
    const BLOCK_UNPLUG_WIRE: gremlin.ProtoWireNumber = 133;
    const EXT4_ALLOC_DA_BLOCKS_WIRE: gremlin.ProtoWireNumber = 134;
    const EXT4_ALLOCATE_BLOCKS_WIRE: gremlin.ProtoWireNumber = 135;
    const EXT4_ALLOCATE_INODE_WIRE: gremlin.ProtoWireNumber = 136;
    const EXT4_BEGIN_ORDERED_TRUNCATE_WIRE: gremlin.ProtoWireNumber = 137;
    const EXT4_COLLAPSE_RANGE_WIRE: gremlin.ProtoWireNumber = 138;
    const EXT4_DA_RELEASE_SPACE_WIRE: gremlin.ProtoWireNumber = 139;
    const EXT4_DA_RESERVE_SPACE_WIRE: gremlin.ProtoWireNumber = 140;
    const EXT4_DA_UPDATE_RESERVE_SPACE_WIRE: gremlin.ProtoWireNumber = 141;
    const EXT4_DA_WRITE_PAGES_WIRE: gremlin.ProtoWireNumber = 142;
    const EXT4_DA_WRITE_PAGES_EXTENT_WIRE: gremlin.ProtoWireNumber = 143;
    const EXT4_DIRECT_IO_ENTER_WIRE: gremlin.ProtoWireNumber = 144;
    const EXT4_DIRECT_IO_EXIT_WIRE: gremlin.ProtoWireNumber = 145;
    const EXT4_DISCARD_BLOCKS_WIRE: gremlin.ProtoWireNumber = 146;
    const EXT4_DISCARD_PREALLOCATIONS_WIRE: gremlin.ProtoWireNumber = 147;
    const EXT4_DROP_INODE_WIRE: gremlin.ProtoWireNumber = 148;
    const EXT4_ES_CACHE_EXTENT_WIRE: gremlin.ProtoWireNumber = 149;
    const EXT4_ES_FIND_DELAYED_EXTENT_RANGE_ENTER_WIRE: gremlin.ProtoWireNumber = 150;
    const EXT4_ES_FIND_DELAYED_EXTENT_RANGE_EXIT_WIRE: gremlin.ProtoWireNumber = 151;
    const EXT4_ES_INSERT_EXTENT_WIRE: gremlin.ProtoWireNumber = 152;
    const EXT4_ES_LOOKUP_EXTENT_ENTER_WIRE: gremlin.ProtoWireNumber = 153;
    const EXT4_ES_LOOKUP_EXTENT_EXIT_WIRE: gremlin.ProtoWireNumber = 154;
    const EXT4_ES_REMOVE_EXTENT_WIRE: gremlin.ProtoWireNumber = 155;
    const EXT4_ES_SHRINK_WIRE: gremlin.ProtoWireNumber = 156;
    const EXT4_ES_SHRINK_COUNT_WIRE: gremlin.ProtoWireNumber = 157;
    const EXT4_ES_SHRINK_SCAN_ENTER_WIRE: gremlin.ProtoWireNumber = 158;
    const EXT4_ES_SHRINK_SCAN_EXIT_WIRE: gremlin.ProtoWireNumber = 159;
    const EXT4_EVICT_INODE_WIRE: gremlin.ProtoWireNumber = 160;
    const EXT4_EXT_CONVERT_TO_INITIALIZED_ENTER_WIRE: gremlin.ProtoWireNumber = 161;
    const EXT4_EXT_CONVERT_TO_INITIALIZED_FASTPATH_WIRE: gremlin.ProtoWireNumber = 162;
    const EXT4_EXT_HANDLE_UNWRITTEN_EXTENTS_WIRE: gremlin.ProtoWireNumber = 163;
    const EXT4_EXT_IN_CACHE_WIRE: gremlin.ProtoWireNumber = 164;
    const EXT4_EXT_LOAD_EXTENT_WIRE: gremlin.ProtoWireNumber = 165;
    const EXT4_EXT_MAP_BLOCKS_ENTER_WIRE: gremlin.ProtoWireNumber = 166;
    const EXT4_EXT_MAP_BLOCKS_EXIT_WIRE: gremlin.ProtoWireNumber = 167;
    const EXT4_EXT_PUT_IN_CACHE_WIRE: gremlin.ProtoWireNumber = 168;
    const EXT4_EXT_REMOVE_SPACE_WIRE: gremlin.ProtoWireNumber = 169;
    const EXT4_EXT_REMOVE_SPACE_DONE_WIRE: gremlin.ProtoWireNumber = 170;
    const EXT4_EXT_RM_IDX_WIRE: gremlin.ProtoWireNumber = 171;
    const EXT4_EXT_RM_LEAF_WIRE: gremlin.ProtoWireNumber = 172;
    const EXT4_EXT_SHOW_EXTENT_WIRE: gremlin.ProtoWireNumber = 173;
    const EXT4_FALLOCATE_ENTER_WIRE: gremlin.ProtoWireNumber = 174;
    const EXT4_FALLOCATE_EXIT_WIRE: gremlin.ProtoWireNumber = 175;
    const EXT4_FIND_DELALLOC_RANGE_WIRE: gremlin.ProtoWireNumber = 176;
    const EXT4_FORGET_WIRE: gremlin.ProtoWireNumber = 177;
    const EXT4_FREE_BLOCKS_WIRE: gremlin.ProtoWireNumber = 178;
    const EXT4_FREE_INODE_WIRE: gremlin.ProtoWireNumber = 179;
    const EXT4_GET_IMPLIED_CLUSTER_ALLOC_EXIT_WIRE: gremlin.ProtoWireNumber = 180;
    const EXT4_GET_RESERVED_CLUSTER_ALLOC_WIRE: gremlin.ProtoWireNumber = 181;
    const EXT4_IND_MAP_BLOCKS_ENTER_WIRE: gremlin.ProtoWireNumber = 182;
    const EXT4_IND_MAP_BLOCKS_EXIT_WIRE: gremlin.ProtoWireNumber = 183;
    const EXT4_INSERT_RANGE_WIRE: gremlin.ProtoWireNumber = 184;
    const EXT4_INVALIDATEPAGE_WIRE: gremlin.ProtoWireNumber = 185;
    const EXT4_JOURNAL_START_WIRE: gremlin.ProtoWireNumber = 186;
    const EXT4_JOURNAL_START_RESERVED_WIRE: gremlin.ProtoWireNumber = 187;
    const EXT4_JOURNALLED_INVALIDATEPAGE_WIRE: gremlin.ProtoWireNumber = 188;
    const EXT4_JOURNALLED_WRITE_END_WIRE: gremlin.ProtoWireNumber = 189;
    const EXT4_LOAD_INODE_WIRE: gremlin.ProtoWireNumber = 190;
    const EXT4_LOAD_INODE_BITMAP_WIRE: gremlin.ProtoWireNumber = 191;
    const EXT4_MARK_INODE_DIRTY_WIRE: gremlin.ProtoWireNumber = 192;
    const EXT4_MB_BITMAP_LOAD_WIRE: gremlin.ProtoWireNumber = 193;
    const EXT4_MB_BUDDY_BITMAP_LOAD_WIRE: gremlin.ProtoWireNumber = 194;
    const EXT4_MB_DISCARD_PREALLOCATIONS_WIRE: gremlin.ProtoWireNumber = 195;
    const EXT4_MB_NEW_GROUP_PA_WIRE: gremlin.ProtoWireNumber = 196;
    const EXT4_MB_NEW_INODE_PA_WIRE: gremlin.ProtoWireNumber = 197;
    const EXT4_MB_RELEASE_GROUP_PA_WIRE: gremlin.ProtoWireNumber = 198;
    const EXT4_MB_RELEASE_INODE_PA_WIRE: gremlin.ProtoWireNumber = 199;
    const EXT4_MBALLOC_ALLOC_WIRE: gremlin.ProtoWireNumber = 200;
    const EXT4_MBALLOC_DISCARD_WIRE: gremlin.ProtoWireNumber = 201;
    const EXT4_MBALLOC_FREE_WIRE: gremlin.ProtoWireNumber = 202;
    const EXT4_MBALLOC_PREALLOC_WIRE: gremlin.ProtoWireNumber = 203;
    const EXT4_OTHER_INODE_UPDATE_TIME_WIRE: gremlin.ProtoWireNumber = 204;
    const EXT4_PUNCH_HOLE_WIRE: gremlin.ProtoWireNumber = 205;
    const EXT4_READ_BLOCK_BITMAP_LOAD_WIRE: gremlin.ProtoWireNumber = 206;
    const EXT4_READPAGE_WIRE: gremlin.ProtoWireNumber = 207;
    const EXT4_RELEASEPAGE_WIRE: gremlin.ProtoWireNumber = 208;
    const EXT4_REMOVE_BLOCKS_WIRE: gremlin.ProtoWireNumber = 209;
    const EXT4_REQUEST_BLOCKS_WIRE: gremlin.ProtoWireNumber = 210;
    const EXT4_REQUEST_INODE_WIRE: gremlin.ProtoWireNumber = 211;
    const EXT4_SYNC_FS_WIRE: gremlin.ProtoWireNumber = 212;
    const EXT4_TRIM_ALL_FREE_WIRE: gremlin.ProtoWireNumber = 213;
    const EXT4_TRIM_EXTENT_WIRE: gremlin.ProtoWireNumber = 214;
    const EXT4_TRUNCATE_ENTER_WIRE: gremlin.ProtoWireNumber = 215;
    const EXT4_TRUNCATE_EXIT_WIRE: gremlin.ProtoWireNumber = 216;
    const EXT4_UNLINK_ENTER_WIRE: gremlin.ProtoWireNumber = 217;
    const EXT4_UNLINK_EXIT_WIRE: gremlin.ProtoWireNumber = 218;
    const EXT4_WRITE_BEGIN_WIRE: gremlin.ProtoWireNumber = 219;
    const EXT4_WRITE_END_WIRE: gremlin.ProtoWireNumber = 230;
    const EXT4_WRITEPAGE_WIRE: gremlin.ProtoWireNumber = 231;
    const EXT4_WRITEPAGES_WIRE: gremlin.ProtoWireNumber = 232;
    const EXT4_WRITEPAGES_RESULT_WIRE: gremlin.ProtoWireNumber = 233;
    const EXT4_ZERO_RANGE_WIRE: gremlin.ProtoWireNumber = 234;
    const TASK_NEWTASK_WIRE: gremlin.ProtoWireNumber = 235;
    const TASK_RENAME_WIRE: gremlin.ProtoWireNumber = 236;
    const SCHED_PROCESS_EXEC_WIRE: gremlin.ProtoWireNumber = 237;
    const SCHED_PROCESS_EXIT_WIRE: gremlin.ProtoWireNumber = 238;
    const SCHED_PROCESS_FORK_WIRE: gremlin.ProtoWireNumber = 239;
    const SCHED_PROCESS_FREE_WIRE: gremlin.ProtoWireNumber = 240;
    const SCHED_PROCESS_HANG_WIRE: gremlin.ProtoWireNumber = 241;
    const SCHED_PROCESS_WAIT_WIRE: gremlin.ProtoWireNumber = 242;
    const F2FS_DO_SUBMIT_BIO_WIRE: gremlin.ProtoWireNumber = 243;
    const F2FS_EVICT_INODE_WIRE: gremlin.ProtoWireNumber = 244;
    const F2FS_FALLOCATE_WIRE: gremlin.ProtoWireNumber = 245;
    const F2FS_GET_DATA_BLOCK_WIRE: gremlin.ProtoWireNumber = 246;
    const F2FS_GET_VICTIM_WIRE: gremlin.ProtoWireNumber = 247;
    const F2FS_IGET_WIRE: gremlin.ProtoWireNumber = 248;
    const F2FS_IGET_EXIT_WIRE: gremlin.ProtoWireNumber = 249;
    const F2FS_NEW_INODE_WIRE: gremlin.ProtoWireNumber = 250;
    const F2FS_READPAGE_WIRE: gremlin.ProtoWireNumber = 251;
    const F2FS_RESERVE_NEW_BLOCK_WIRE: gremlin.ProtoWireNumber = 252;
    const F2FS_SET_PAGE_DIRTY_WIRE: gremlin.ProtoWireNumber = 253;
    const F2FS_SUBMIT_WRITE_PAGE_WIRE: gremlin.ProtoWireNumber = 254;
    const F2FS_SYNC_FILE_ENTER_WIRE: gremlin.ProtoWireNumber = 255;
    const F2FS_SYNC_FILE_EXIT_WIRE: gremlin.ProtoWireNumber = 256;
    const F2FS_SYNC_FS_WIRE: gremlin.ProtoWireNumber = 257;
    const F2FS_TRUNCATE_WIRE: gremlin.ProtoWireNumber = 258;
    const F2FS_TRUNCATE_BLOCKS_ENTER_WIRE: gremlin.ProtoWireNumber = 259;
    const F2FS_TRUNCATE_BLOCKS_EXIT_WIRE: gremlin.ProtoWireNumber = 260;
    const F2FS_TRUNCATE_DATA_BLOCKS_RANGE_WIRE: gremlin.ProtoWireNumber = 261;
    const F2FS_TRUNCATE_INODE_BLOCKS_ENTER_WIRE: gremlin.ProtoWireNumber = 262;
    const F2FS_TRUNCATE_INODE_BLOCKS_EXIT_WIRE: gremlin.ProtoWireNumber = 263;
    const F2FS_TRUNCATE_NODE_WIRE: gremlin.ProtoWireNumber = 264;
    const F2FS_TRUNCATE_NODES_ENTER_WIRE: gremlin.ProtoWireNumber = 265;
    const F2FS_TRUNCATE_NODES_EXIT_WIRE: gremlin.ProtoWireNumber = 266;
    const F2FS_TRUNCATE_PARTIAL_NODES_WIRE: gremlin.ProtoWireNumber = 267;
    const F2FS_UNLINK_ENTER_WIRE: gremlin.ProtoWireNumber = 268;
    const F2FS_UNLINK_EXIT_WIRE: gremlin.ProtoWireNumber = 269;
    const F2FS_VM_PAGE_MKWRITE_WIRE: gremlin.ProtoWireNumber = 270;
    const F2FS_WRITE_BEGIN_WIRE: gremlin.ProtoWireNumber = 271;
    const F2FS_WRITE_CHECKPOINT_WIRE: gremlin.ProtoWireNumber = 272;
    const F2FS_WRITE_END_WIRE: gremlin.ProtoWireNumber = 273;
    const ALLOC_PAGES_IOMMU_END_WIRE: gremlin.ProtoWireNumber = 274;
    const ALLOC_PAGES_IOMMU_FAIL_WIRE: gremlin.ProtoWireNumber = 275;
    const ALLOC_PAGES_IOMMU_START_WIRE: gremlin.ProtoWireNumber = 276;
    const ALLOC_PAGES_SYS_END_WIRE: gremlin.ProtoWireNumber = 277;
    const ALLOC_PAGES_SYS_FAIL_WIRE: gremlin.ProtoWireNumber = 278;
    const ALLOC_PAGES_SYS_START_WIRE: gremlin.ProtoWireNumber = 279;
    const DMA_ALLOC_CONTIGUOUS_RETRY_WIRE: gremlin.ProtoWireNumber = 280;
    const IOMMU_MAP_RANGE_WIRE: gremlin.ProtoWireNumber = 281;
    const IOMMU_SEC_PTBL_MAP_RANGE_END_WIRE: gremlin.ProtoWireNumber = 282;
    const IOMMU_SEC_PTBL_MAP_RANGE_START_WIRE: gremlin.ProtoWireNumber = 283;
    const ION_ALLOC_BUFFER_END_WIRE: gremlin.ProtoWireNumber = 284;
    const ION_ALLOC_BUFFER_FAIL_WIRE: gremlin.ProtoWireNumber = 285;
    const ION_ALLOC_BUFFER_FALLBACK_WIRE: gremlin.ProtoWireNumber = 286;
    const ION_ALLOC_BUFFER_START_WIRE: gremlin.ProtoWireNumber = 287;
    const ION_CP_ALLOC_RETRY_WIRE: gremlin.ProtoWireNumber = 288;
    const ION_CP_SECURE_BUFFER_END_WIRE: gremlin.ProtoWireNumber = 289;
    const ION_CP_SECURE_BUFFER_START_WIRE: gremlin.ProtoWireNumber = 290;
    const ION_PREFETCHING_WIRE: gremlin.ProtoWireNumber = 291;
    const ION_SECURE_CMA_ADD_TO_POOL_END_WIRE: gremlin.ProtoWireNumber = 292;
    const ION_SECURE_CMA_ADD_TO_POOL_START_WIRE: gremlin.ProtoWireNumber = 293;
    const ION_SECURE_CMA_ALLOCATE_END_WIRE: gremlin.ProtoWireNumber = 294;
    const ION_SECURE_CMA_ALLOCATE_START_WIRE: gremlin.ProtoWireNumber = 295;
    const ION_SECURE_CMA_SHRINK_POOL_END_WIRE: gremlin.ProtoWireNumber = 296;
    const ION_SECURE_CMA_SHRINK_POOL_START_WIRE: gremlin.ProtoWireNumber = 297;
    const KFREE_WIRE: gremlin.ProtoWireNumber = 298;
    const KMALLOC_WIRE: gremlin.ProtoWireNumber = 299;
    const KMALLOC_NODE_WIRE: gremlin.ProtoWireNumber = 300;
    const KMEM_CACHE_ALLOC_WIRE: gremlin.ProtoWireNumber = 301;
    const KMEM_CACHE_ALLOC_NODE_WIRE: gremlin.ProtoWireNumber = 302;
    const KMEM_CACHE_FREE_WIRE: gremlin.ProtoWireNumber = 303;
    const MIGRATE_PAGES_END_WIRE: gremlin.ProtoWireNumber = 304;
    const MIGRATE_PAGES_START_WIRE: gremlin.ProtoWireNumber = 305;
    const MIGRATE_RETRY_WIRE: gremlin.ProtoWireNumber = 306;
    const MM_PAGE_ALLOC_WIRE: gremlin.ProtoWireNumber = 307;
    const MM_PAGE_ALLOC_EXTFRAG_WIRE: gremlin.ProtoWireNumber = 308;
    const MM_PAGE_ALLOC_ZONE_LOCKED_WIRE: gremlin.ProtoWireNumber = 309;
    const MM_PAGE_FREE_WIRE: gremlin.ProtoWireNumber = 310;
    const MM_PAGE_FREE_BATCHED_WIRE: gremlin.ProtoWireNumber = 311;
    const MM_PAGE_PCPU_DRAIN_WIRE: gremlin.ProtoWireNumber = 312;
    const RSS_STAT_WIRE: gremlin.ProtoWireNumber = 313;
    const ION_HEAP_SHRINK_WIRE: gremlin.ProtoWireNumber = 314;
    const ION_HEAP_GROW_WIRE: gremlin.ProtoWireNumber = 315;
    const FENCE_INIT_WIRE: gremlin.ProtoWireNumber = 316;
    const FENCE_DESTROY_WIRE: gremlin.ProtoWireNumber = 317;
    const FENCE_ENABLE_SIGNAL_WIRE: gremlin.ProtoWireNumber = 318;
    const FENCE_SIGNALED_WIRE: gremlin.ProtoWireNumber = 319;
    const CLK_ENABLE_WIRE: gremlin.ProtoWireNumber = 320;
    const CLK_DISABLE_WIRE: gremlin.ProtoWireNumber = 321;
    const CLK_SET_RATE_WIRE: gremlin.ProtoWireNumber = 322;
    const BINDER_TRANSACTION_ALLOC_BUF_WIRE: gremlin.ProtoWireNumber = 323;
    const SIGNAL_DELIVER_WIRE: gremlin.ProtoWireNumber = 324;
    const SIGNAL_GENERATE_WIRE: gremlin.ProtoWireNumber = 325;
    const OOM_SCORE_ADJ_UPDATE_WIRE: gremlin.ProtoWireNumber = 326;
    const GENERIC_WIRE: gremlin.ProtoWireNumber = 327;
    const MM_EVENT_RECORD_WIRE: gremlin.ProtoWireNumber = 328;
    const SYS_ENTER_WIRE: gremlin.ProtoWireNumber = 329;
    const SYS_EXIT_WIRE: gremlin.ProtoWireNumber = 330;
    const ZERO_WIRE: gremlin.ProtoWireNumber = 331;
    const GPU_FREQUENCY_WIRE: gremlin.ProtoWireNumber = 332;
    const SDE_TRACING_MARK_WRITE_WIRE: gremlin.ProtoWireNumber = 333;
    const MARK_VICTIM_WIRE: gremlin.ProtoWireNumber = 334;
    const ION_STAT_WIRE: gremlin.ProtoWireNumber = 335;
    const ION_BUFFER_CREATE_WIRE: gremlin.ProtoWireNumber = 336;
    const ION_BUFFER_DESTROY_WIRE: gremlin.ProtoWireNumber = 337;
    const SCM_CALL_START_WIRE: gremlin.ProtoWireNumber = 338;
    const SCM_CALL_END_WIRE: gremlin.ProtoWireNumber = 339;
    const GPU_MEM_TOTAL_WIRE: gremlin.ProtoWireNumber = 340;
    const THERMAL_TEMPERATURE_WIRE: gremlin.ProtoWireNumber = 341;
    const CDEV_UPDATE_WIRE: gremlin.ProtoWireNumber = 342;
    const CPUHP_EXIT_WIRE: gremlin.ProtoWireNumber = 343;
    const CPUHP_MULTI_ENTER_WIRE: gremlin.ProtoWireNumber = 344;
    const CPUHP_ENTER_WIRE: gremlin.ProtoWireNumber = 345;
    const CPUHP_LATENCY_WIRE: gremlin.ProtoWireNumber = 346;
    const FASTRPC_DMA_STAT_WIRE: gremlin.ProtoWireNumber = 347;
    const DPU_TRACING_MARK_WRITE_WIRE: gremlin.ProtoWireNumber = 348;
    const G2D_TRACING_MARK_WRITE_WIRE: gremlin.ProtoWireNumber = 349;
    const MALI_TRACING_MARK_WRITE_WIRE: gremlin.ProtoWireNumber = 350;
    const DMA_HEAP_STAT_WIRE: gremlin.ProtoWireNumber = 351;
    const CPUHP_PAUSE_WIRE: gremlin.ProtoWireNumber = 352;
    const SCHED_PI_SETPRIO_WIRE: gremlin.ProtoWireNumber = 353;
    const SDE_SDE_EVTLOG_WIRE: gremlin.ProtoWireNumber = 354;
    const SDE_SDE_PERF_CALC_CRTC_WIRE: gremlin.ProtoWireNumber = 355;
    const SDE_SDE_PERF_CRTC_UPDATE_WIRE: gremlin.ProtoWireNumber = 356;
    const SDE_SDE_PERF_SET_QOS_LUTS_WIRE: gremlin.ProtoWireNumber = 357;
    const SDE_SDE_PERF_UPDATE_BUS_WIRE: gremlin.ProtoWireNumber = 358;
    const RSS_STAT_THROTTLED_WIRE: gremlin.ProtoWireNumber = 359;
    const NETIF_RECEIVE_SKB_WIRE: gremlin.ProtoWireNumber = 360;
    const NET_DEV_XMIT_WIRE: gremlin.ProtoWireNumber = 361;
    const INET_SOCK_SET_STATE_WIRE: gremlin.ProtoWireNumber = 362;
    const TCP_RETRANSMIT_SKB_WIRE: gremlin.ProtoWireNumber = 363;
    const CROS_EC_SENSORHUB_DATA_WIRE: gremlin.ProtoWireNumber = 364;
    const NAPI_GRO_RECEIVE_ENTRY_WIRE: gremlin.ProtoWireNumber = 365;
    const NAPI_GRO_RECEIVE_EXIT_WIRE: gremlin.ProtoWireNumber = 366;
    const KFREE_SKB_WIRE: gremlin.ProtoWireNumber = 367;
    const KVM_ACCESS_FAULT_WIRE: gremlin.ProtoWireNumber = 368;
    const KVM_ACK_IRQ_WIRE: gremlin.ProtoWireNumber = 369;
    const KVM_AGE_HVA_WIRE: gremlin.ProtoWireNumber = 370;
    const KVM_AGE_PAGE_WIRE: gremlin.ProtoWireNumber = 371;
    const KVM_ARM_CLEAR_DEBUG_WIRE: gremlin.ProtoWireNumber = 372;
    const KVM_ARM_SET_DREG32_WIRE: gremlin.ProtoWireNumber = 373;
    const KVM_ARM_SET_REGSET_WIRE: gremlin.ProtoWireNumber = 374;
    const KVM_ARM_SETUP_DEBUG_WIRE: gremlin.ProtoWireNumber = 375;
    const KVM_ENTRY_WIRE: gremlin.ProtoWireNumber = 376;
    const KVM_EXIT_WIRE: gremlin.ProtoWireNumber = 377;
    const KVM_FPU_WIRE: gremlin.ProtoWireNumber = 378;
    const KVM_GET_TIMER_MAP_WIRE: gremlin.ProtoWireNumber = 379;
    const KVM_GUEST_FAULT_WIRE: gremlin.ProtoWireNumber = 380;
    const KVM_HANDLE_SYS_REG_WIRE: gremlin.ProtoWireNumber = 381;
    const KVM_HVC_ARM64_WIRE: gremlin.ProtoWireNumber = 382;
    const KVM_IRQ_LINE_WIRE: gremlin.ProtoWireNumber = 383;
    const KVM_MMIO_WIRE: gremlin.ProtoWireNumber = 384;
    const KVM_MMIO_EMULATE_WIRE: gremlin.ProtoWireNumber = 385;
    const KVM_SET_GUEST_DEBUG_WIRE: gremlin.ProtoWireNumber = 386;
    const KVM_SET_IRQ_WIRE: gremlin.ProtoWireNumber = 387;
    const KVM_SET_SPTE_HVA_WIRE: gremlin.ProtoWireNumber = 388;
    const KVM_SET_WAY_FLUSH_WIRE: gremlin.ProtoWireNumber = 389;
    const KVM_SYS_ACCESS_WIRE: gremlin.ProtoWireNumber = 390;
    const KVM_TEST_AGE_HVA_WIRE: gremlin.ProtoWireNumber = 391;
    const KVM_TIMER_EMULATE_WIRE: gremlin.ProtoWireNumber = 392;
    const KVM_TIMER_HRTIMER_EXPIRE_WIRE: gremlin.ProtoWireNumber = 393;
    const KVM_TIMER_RESTORE_STATE_WIRE: gremlin.ProtoWireNumber = 394;
    const KVM_TIMER_SAVE_STATE_WIRE: gremlin.ProtoWireNumber = 395;
    const KVM_TIMER_UPDATE_IRQ_WIRE: gremlin.ProtoWireNumber = 396;
    const KVM_TOGGLE_CACHE_WIRE: gremlin.ProtoWireNumber = 397;
    const KVM_UNMAP_HVA_RANGE_WIRE: gremlin.ProtoWireNumber = 398;
    const KVM_USERSPACE_EXIT_WIRE: gremlin.ProtoWireNumber = 399;
    const KVM_VCPU_WAKEUP_WIRE: gremlin.ProtoWireNumber = 400;
    const KVM_WFX_ARM64_WIRE: gremlin.ProtoWireNumber = 401;
    const TRAP_REG_WIRE: gremlin.ProtoWireNumber = 402;
    const VGIC_UPDATE_IRQ_PENDING_WIRE: gremlin.ProtoWireNumber = 403;
    const WAKEUP_SOURCE_ACTIVATE_WIRE: gremlin.ProtoWireNumber = 404;
    const WAKEUP_SOURCE_DEACTIVATE_WIRE: gremlin.ProtoWireNumber = 405;
    const UFSHCD_COMMAND_WIRE: gremlin.ProtoWireNumber = 406;
    const UFSHCD_CLK_GATING_WIRE: gremlin.ProtoWireNumber = 407;
    const CONSOLE_WIRE: gremlin.ProtoWireNumber = 408;
    const DRM_VBLANK_EVENT_WIRE: gremlin.ProtoWireNumber = 409;
    const DRM_VBLANK_EVENT_DELIVERED_WIRE: gremlin.ProtoWireNumber = 410;
    const DRM_SCHED_JOB_WIRE: gremlin.ProtoWireNumber = 411;
    const DRM_RUN_JOB_WIRE: gremlin.ProtoWireNumber = 412;
    const DRM_SCHED_PROCESS_JOB_WIRE: gremlin.ProtoWireNumber = 413;
    const DMA_FENCE_INIT_WIRE: gremlin.ProtoWireNumber = 414;
    const DMA_FENCE_EMIT_WIRE: gremlin.ProtoWireNumber = 415;
    const DMA_FENCE_SIGNALED_WIRE: gremlin.ProtoWireNumber = 416;
    const DMA_FENCE_WAIT_START_WIRE: gremlin.ProtoWireNumber = 417;
    const DMA_FENCE_WAIT_END_WIRE: gremlin.ProtoWireNumber = 418;
    const F2FS_IOSTAT_WIRE: gremlin.ProtoWireNumber = 419;
    const F2FS_IOSTAT_LATENCY_WIRE: gremlin.ProtoWireNumber = 420;
    const SCHED_CPU_UTIL_CFS_WIRE: gremlin.ProtoWireNumber = 421;
    const V4L2_QBUF_WIRE: gremlin.ProtoWireNumber = 422;
    const V4L2_DQBUF_WIRE: gremlin.ProtoWireNumber = 423;
    const VB2_V4L2_BUF_QUEUE_WIRE: gremlin.ProtoWireNumber = 424;
    const VB2_V4L2_BUF_DONE_WIRE: gremlin.ProtoWireNumber = 425;
    const VB2_V4L2_QBUF_WIRE: gremlin.ProtoWireNumber = 426;
    const VB2_V4L2_DQBUF_WIRE: gremlin.ProtoWireNumber = 427;
    const DSI_CMD_FIFO_STATUS_WIRE: gremlin.ProtoWireNumber = 428;
    const DSI_RX_WIRE: gremlin.ProtoWireNumber = 429;
    const DSI_TX_WIRE: gremlin.ProtoWireNumber = 430;
    const ANDROID_FS_DATAREAD_END_WIRE: gremlin.ProtoWireNumber = 431;
    const ANDROID_FS_DATAREAD_START_WIRE: gremlin.ProtoWireNumber = 432;
    const ANDROID_FS_DATAWRITE_END_WIRE: gremlin.ProtoWireNumber = 433;
    const ANDROID_FS_DATAWRITE_START_WIRE: gremlin.ProtoWireNumber = 434;
    const ANDROID_FS_FSYNC_END_WIRE: gremlin.ProtoWireNumber = 435;
    const ANDROID_FS_FSYNC_START_WIRE: gremlin.ProtoWireNumber = 436;
    const FUNCGRAPH_ENTRY_WIRE: gremlin.ProtoWireNumber = 437;
    const FUNCGRAPH_EXIT_WIRE: gremlin.ProtoWireNumber = 438;
    const VIRTIO_VIDEO_CMD_WIRE: gremlin.ProtoWireNumber = 439;
    const VIRTIO_VIDEO_CMD_DONE_WIRE: gremlin.ProtoWireNumber = 440;
    const VIRTIO_VIDEO_RESOURCE_QUEUE_WIRE: gremlin.ProtoWireNumber = 441;
    const VIRTIO_VIDEO_RESOURCE_QUEUE_DONE_WIRE: gremlin.ProtoWireNumber = 442;
    const MM_SHRINK_SLAB_START_WIRE: gremlin.ProtoWireNumber = 443;
    const MM_SHRINK_SLAB_END_WIRE: gremlin.ProtoWireNumber = 444;
    const TRUSTY_SMC_WIRE: gremlin.ProtoWireNumber = 445;
    const TRUSTY_SMC_DONE_WIRE: gremlin.ProtoWireNumber = 446;
    const TRUSTY_STD_CALL32_WIRE: gremlin.ProtoWireNumber = 447;
    const TRUSTY_STD_CALL32_DONE_WIRE: gremlin.ProtoWireNumber = 448;
    const TRUSTY_SHARE_MEMORY_WIRE: gremlin.ProtoWireNumber = 449;
    const TRUSTY_SHARE_MEMORY_DONE_WIRE: gremlin.ProtoWireNumber = 450;
    const TRUSTY_RECLAIM_MEMORY_WIRE: gremlin.ProtoWireNumber = 451;
    const TRUSTY_RECLAIM_MEMORY_DONE_WIRE: gremlin.ProtoWireNumber = 452;
    const TRUSTY_IRQ_WIRE: gremlin.ProtoWireNumber = 453;
    const TRUSTY_IPC_HANDLE_EVENT_WIRE: gremlin.ProtoWireNumber = 454;
    const TRUSTY_IPC_CONNECT_WIRE: gremlin.ProtoWireNumber = 455;
    const TRUSTY_IPC_CONNECT_END_WIRE: gremlin.ProtoWireNumber = 456;
    const TRUSTY_IPC_WRITE_WIRE: gremlin.ProtoWireNumber = 457;
    const TRUSTY_IPC_POLL_WIRE: gremlin.ProtoWireNumber = 458;
    const TRUSTY_IPC_READ_WIRE: gremlin.ProtoWireNumber = 460;
    const TRUSTY_IPC_READ_END_WIRE: gremlin.ProtoWireNumber = 461;
    const TRUSTY_IPC_RX_WIRE: gremlin.ProtoWireNumber = 462;
    const TRUSTY_ENQUEUE_NOP_WIRE: gremlin.ProtoWireNumber = 464;
    const CMA_ALLOC_START_WIRE: gremlin.ProtoWireNumber = 465;
    const CMA_ALLOC_INFO_WIRE: gremlin.ProtoWireNumber = 466;
    const LWIS_TRACING_MARK_WRITE_WIRE: gremlin.ProtoWireNumber = 467;
    const VIRTIO_GPU_CMD_QUEUE_WIRE: gremlin.ProtoWireNumber = 468;
    const VIRTIO_GPU_CMD_RESPONSE_WIRE: gremlin.ProtoWireNumber = 469;
    const MALI_MALI_KCPU_CQS_SETWIRE: gremlin.ProtoWireNumber = 470;
    const MALI_MALI_KCPU_CQS_WAIT_STARTWIRE: gremlin.ProtoWireNumber = 471;
    const MALI_MALI_KCPU_CQS_WAIT_ENDWIRE: gremlin.ProtoWireNumber = 472;
    const MALI_MALI_KCPU_FENCE_SIGNALWIRE: gremlin.ProtoWireNumber = 473;
    const MALI_MALI_KCPU_FENCE_WAIT_STARTWIRE: gremlin.ProtoWireNumber = 474;
    const MALI_MALI_KCPU_FENCE_WAIT_ENDWIRE: gremlin.ProtoWireNumber = 475;
    const HYP_ENTER_WIRE: gremlin.ProtoWireNumber = 476;
    const HYP_EXIT_WIRE: gremlin.ProtoWireNumber = 477;
    const HOST_HCALL_WIRE: gremlin.ProtoWireNumber = 478;
    const HOST_SMC_WIRE: gremlin.ProtoWireNumber = 479;
    const HOST_MEM_ABORT_WIRE: gremlin.ProtoWireNumber = 480;
    const SUSPEND_RESUME_MINIMAL_WIRE: gremlin.ProtoWireNumber = 481;
    const MALI_MALI_CSF_INTERRUPT_STARTWIRE: gremlin.ProtoWireNumber = 482;
    const MALI_MALI_CSF_INTERRUPT_ENDWIRE: gremlin.ProtoWireNumber = 483;
    const SAMSUNG_TRACING_MARK_WRITE_WIRE: gremlin.ProtoWireNumber = 484;
    const BINDER_COMMAND_WIRE: gremlin.ProtoWireNumber = 485;
    const BINDER_RETURN_WIRE: gremlin.ProtoWireNumber = 486;
    const SCHED_SWITCH_WITH_CTRS_WIRE: gremlin.ProtoWireNumber = 487;
    const GPU_WORK_PERIOD_WIRE: gremlin.ProtoWireNumber = 488;
    const RPM_STATUS_WIRE: gremlin.ProtoWireNumber = 489;
    const PANEL_WRITE_GENERIC_WIRE: gremlin.ProtoWireNumber = 490;
    const SCHED_MIGRATE_TASK_WIRE: gremlin.ProtoWireNumber = 491;
    const DPU_DSI_CMD_FIFO_STATUS_WIRE: gremlin.ProtoWireNumber = 492;
    const DPU_DSI_RX_WIRE: gremlin.ProtoWireNumber = 493;
    const DPU_DSI_TX_WIRE: gremlin.ProtoWireNumber = 494;
    const F2FS_BACKGROUND_GC_WIRE: gremlin.ProtoWireNumber = 495;
    const F2FS_GC_BEGIN_WIRE: gremlin.ProtoWireNumber = 496;
    const F2FS_GC_END_WIRE: gremlin.ProtoWireNumber = 497;
    const FASTRPC_DMA_FREE_WIRE: gremlin.ProtoWireNumber = 498;
    const FASTRPC_DMA_ALLOC_WIRE: gremlin.ProtoWireNumber = 499;
    const FASTRPC_DMA_UNMAP_WIRE: gremlin.ProtoWireNumber = 500;
    const FASTRPC_DMA_MAP_WIRE: gremlin.ProtoWireNumber = 501;
    const GOOGLE_ICC_EVENT_WIRE: gremlin.ProtoWireNumber = 502;
    const GOOGLE_IRM_EVENT_WIRE: gremlin.ProtoWireNumber = 503;
    const DEVICE_PM_CALLBACK_START_WIRE: gremlin.ProtoWireNumber = 504;
    const DEVICE_PM_CALLBACK_END_WIRE: gremlin.ProtoWireNumber = 505;
    const THERMAL_EXYNOS_ACPM_BULK_WIRE: gremlin.ProtoWireNumber = 506;
    const THERMAL_EXYNOS_ACPM_HIGH_OVERHEAD_WIRE: gremlin.ProtoWireNumber = 507;
    const DCVSH_FREQ_WIRE: gremlin.ProtoWireNumber = 508;
    const KGSL_GPU_FREQUENCY_WIRE: gremlin.ProtoWireNumber = 509;
    const MALI_MALI_PM_MCU_HCTL_CORES_DOWN_SCALE_NOTIFY_PENDWIRE: gremlin.ProtoWireNumber = 510;
    const MALI_MALI_PM_MCU_HCTL_CORES_NOTIFY_PENDWIRE: gremlin.ProtoWireNumber = 511;
    const MALI_MALI_PM_MCU_HCTL_CORE_INACTIVE_PENDWIRE: gremlin.ProtoWireNumber = 512;
    const MALI_MALI_PM_MCU_HCTL_MCU_ON_RECHECKWIRE: gremlin.ProtoWireNumber = 513;
    const MALI_MALI_PM_MCU_HCTL_SHADERS_CORE_OFF_PENDWIRE: gremlin.ProtoWireNumber = 514;
    const MALI_MALI_PM_MCU_HCTL_SHADERS_PEND_OFFWIRE: gremlin.ProtoWireNumber = 515;
    const MALI_MALI_PM_MCU_HCTL_SHADERS_PEND_ONWIRE: gremlin.ProtoWireNumber = 516;
    const MALI_MALI_PM_MCU_HCTL_SHADERS_READY_OFFWIRE: gremlin.ProtoWireNumber = 517;
    const MALI_MALI_PM_MCU_IN_SLEEPWIRE: gremlin.ProtoWireNumber = 518;
    const MALI_MALI_PM_MCU_OFFWIRE: gremlin.ProtoWireNumber = 519;
    const MALI_MALI_PM_MCU_ONWIRE: gremlin.ProtoWireNumber = 520;
    const MALI_MALI_PM_MCU_ON_CORE_ATTR_UPDATE_PENDWIRE: gremlin.ProtoWireNumber = 521;
    const MALI_MALI_PM_MCU_ON_GLB_REINIT_PENDWIRE: gremlin.ProtoWireNumber = 522;
    const MALI_MALI_PM_MCU_ON_HALTWIRE: gremlin.ProtoWireNumber = 523;
    const MALI_MALI_PM_MCU_ON_HWCNT_DISABLEWIRE: gremlin.ProtoWireNumber = 524;
    const MALI_MALI_PM_MCU_ON_HWCNT_ENABLEWIRE: gremlin.ProtoWireNumber = 525;
    const MALI_MALI_PM_MCU_ON_PEND_HALTWIRE: gremlin.ProtoWireNumber = 526;
    const MALI_MALI_PM_MCU_ON_PEND_SLEEPWIRE: gremlin.ProtoWireNumber = 527;
    const MALI_MALI_PM_MCU_ON_SLEEP_INITIATEWIRE: gremlin.ProtoWireNumber = 528;
    const MALI_MALI_PM_MCU_PEND_OFFWIRE: gremlin.ProtoWireNumber = 529;
    const MALI_MALI_PM_MCU_PEND_ON_RELOADWIRE: gremlin.ProtoWireNumber = 530;
    const MALI_MALI_PM_MCU_POWER_DOWNWIRE: gremlin.ProtoWireNumber = 531;
    const MALI_MALI_PM_MCU_RESET_WAITWIRE: gremlin.ProtoWireNumber = 532;
    const BCL_IRQ_TRIGGER_WIRE: gremlin.ProtoWireNumber = 533;
    const KGSL_ADRENO_CMDBATCH_QUEUED_WIRE: gremlin.ProtoWireNumber = 534;
    const KGSL_ADRENO_CMDBATCH_SUBMITTED_WIRE: gremlin.ProtoWireNumber = 535;
    const KGSL_ADRENO_CMDBATCH_SYNC_WIRE: gremlin.ProtoWireNumber = 536;
    const KGSL_ADRENO_CMDBATCH_RETIRED_WIRE: gremlin.ProtoWireNumber = 537;
    const PIXEL_MM_KSWAPD_WAKE_WIRE: gremlin.ProtoWireNumber = 538;
    const PIXEL_MM_KSWAPD_DONE_WIRE: gremlin.ProtoWireNumber = 539;
    const SCHED_WAKEUP_TASK_ATTR_WIRE: gremlin.ProtoWireNumber = 540;
    const DEVFREQ_FREQUENCY_WIRE: gremlin.ProtoWireNumber = 541;
    const KPROBE_EVENT_WIRE: gremlin.ProtoWireNumber = 542;
    const PARAM_SET_VALUE_CPM_WIRE: gremlin.ProtoWireNumber = 543;
    const DO_SYS_OPEN_WIRE: gremlin.ProtoWireNumber = 544;
    const OPEN_EXEC_WIRE: gremlin.ProtoWireNumber = 545;
    const BLOCK_IO_START_WIRE: gremlin.ProtoWireNumber = 546;
    const BLOCK_IO_DONE_WIRE: gremlin.ProtoWireNumber = 547;
    const MALI_GPU_POWER_STATE_WIRE: gremlin.ProtoWireNumber = 548;
    const DPU_DISP_DPU_UNDERRUN_WIRE: gremlin.ProtoWireNumber = 549;
    const DPU_DISP_VBLANK_IRQ_ENABLE_WIRE: gremlin.ProtoWireNumber = 550;
    const HRTIMER_START_WIRE: gremlin.ProtoWireNumber = 551;
    const HRTIMER_CANCEL_WIRE: gremlin.ProtoWireNumber = 552;
    const HRTIMER_EXPIRE_ENTRY_WIRE: gremlin.ProtoWireNumber = 553;
    const HRTIMER_EXPIRE_EXIT_WIRE: gremlin.ProtoWireNumber = 554;
    const TIMER_START_WIRE: gremlin.ProtoWireNumber = 555;
    const TIMER_CANCEL_WIRE: gremlin.ProtoWireNumber = 556;
    const TIMER_EXPIRE_ENTRY_WIRE: gremlin.ProtoWireNumber = 557;
    const TIMER_EXPIRE_EXIT_WIRE: gremlin.ProtoWireNumber = 558;
    const LOCAL_TIMER_ENTRY_WIRE: gremlin.ProtoWireNumber = 559;
    const LOCAL_TIMER_EXIT_WIRE: gremlin.ProtoWireNumber = 560;
    const DWC3_ALLOC_REQUEST_WIRE: gremlin.ProtoWireNumber = 561;
    const DWC3_COMPLETE_TRB_WIRE: gremlin.ProtoWireNumber = 562;
    const DWC3_CTRL_REQ_WIRE: gremlin.ProtoWireNumber = 563;
    const DWC3_EP_DEQUEUE_WIRE: gremlin.ProtoWireNumber = 564;
    const DWC3_EP_QUEUE_WIRE: gremlin.ProtoWireNumber = 565;
    const DWC3_EVENT_WIRE: gremlin.ProtoWireNumber = 566;
    const DWC3_FREE_REQUEST_WIRE: gremlin.ProtoWireNumber = 567;
    const DWC3_GADGET_EP_CMD_WIRE: gremlin.ProtoWireNumber = 568;
    const DWC3_GADGET_EP_DISABLE_WIRE: gremlin.ProtoWireNumber = 569;
    const DWC3_GADGET_EP_ENABLE_WIRE: gremlin.ProtoWireNumber = 570;
    const DWC3_GADGET_GENERIC_CMD_WIRE: gremlin.ProtoWireNumber = 571;
    const DWC3_GADGET_GIVEBACK_WIRE: gremlin.ProtoWireNumber = 572;
    const DWC3_PREPARE_TRB_WIRE: gremlin.ProtoWireNumber = 573;
    const DWC3_READL_WIRE: gremlin.ProtoWireNumber = 574;
    const DWC3_WRITEL_WIRE: gremlin.ProtoWireNumber = 575;
    const CMA_ALLOC_FINISH_WIRE: gremlin.ProtoWireNumber = 576;
    const MM_ALLOC_CONTIG_MIGRATE_RANGE_INFO_WIRE: gremlin.ProtoWireNumber = 577;
    const HOST_FFA_CALL_WIRE: gremlin.ProtoWireNumber = 578;
    const DMABUF_RSS_STAT_WIRE: gremlin.ProtoWireNumber = 579;
    const IOMMU_IDMAP_WIRE: gremlin.ProtoWireNumber = 580;
    const PSCI_MEM_PROTECT_WIRE: gremlin.ProtoWireNumber = 581;
    const HYPERVISOR_HOST_HCALL_WIRE: gremlin.ProtoWireNumber = 582;
    const HYPERVISOR_HOST_SMC_WIRE: gremlin.ProtoWireNumber = 583;
    const HYPERVISOR_HYP_EXIT_WIRE: gremlin.ProtoWireNumber = 584;
    const HYPERVISOR_IOMMU_IDMAP_WIRE: gremlin.ProtoWireNumber = 585;
    const HYPERVISOR_PSCI_MEM_PROTECT_WIRE: gremlin.ProtoWireNumber = 586;
    const HYPERVISOR_HOST_MEM_ABORT_WIRE: gremlin.ProtoWireNumber = 587;
    const HYPERVISOR_HYP_ENTER_WIRE: gremlin.ProtoWireNumber = 588;
    const HYPERVISOR_IOMMU_IDMAP_COMPLETE_WIRE: gremlin.ProtoWireNumber = 589;
    const HYPERVISOR_VCPU_ILLEGAL_TRAP_WIRE: gremlin.ProtoWireNumber = 590;
    const DRM_SCHED_JOB_ADD_DEP_WIRE: gremlin.ProtoWireNumber = 591;
    const DRM_SCHED_JOB_DONE_WIRE: gremlin.ProtoWireNumber = 592;
    const DRM_SCHED_JOB_QUEUE_WIRE: gremlin.ProtoWireNumber = 593;
    const DRM_SCHED_JOB_RUN_WIRE: gremlin.ProtoWireNumber = 594;
    const DRM_SCHED_JOB_UNSCHEDULABLE_WIRE: gremlin.ProtoWireNumber = 595;
    const FWTP_PERFETTO_COUNTER_WIRE: gremlin.ProtoWireNumber = 596;
};
pub const FtraceEvent = struct {
    // fields
    timestamp: u64 = 0,
    pid: u32 = 0,
    common_flags: u32 = 0,
    print: ?ftrace.PrintFtraceEvent = null,
    sched_switch: ?sched.SchedSwitchFtraceEvent = null,
    cpu_frequency: ?power.CpuFrequencyFtraceEvent = null,
    cpu_frequency_limits: ?power.CpuFrequencyLimitsFtraceEvent = null,
    cpu_idle: ?power.CpuIdleFtraceEvent = null,
    clock_enable: ?power.ClockEnableFtraceEvent = null,
    clock_disable: ?power.ClockDisableFtraceEvent = null,
    clock_set_rate: ?power.ClockSetRateFtraceEvent = null,
    sched_wakeup: ?sched.SchedWakeupFtraceEvent = null,
    sched_blocked_reason: ?sched.SchedBlockedReasonFtraceEvent = null,
    sched_cpu_hotplug: ?sched.SchedCpuHotplugFtraceEvent = null,
    sched_waking: ?sched.SchedWakingFtraceEvent = null,
    ipi_entry: ?ipi.IpiEntryFtraceEvent = null,
    ipi_exit: ?ipi.IpiExitFtraceEvent = null,
    ipi_raise: ?ipi.IpiRaiseFtraceEvent = null,
    softirq_entry: ?irq.SoftirqEntryFtraceEvent = null,
    softirq_exit: ?irq.SoftirqExitFtraceEvent = null,
    softirq_raise: ?irq.SoftirqRaiseFtraceEvent = null,
    i2c_read: ?i2c.I2cReadFtraceEvent = null,
    i2c_write: ?i2c.I2cWriteFtraceEvent = null,
    i2c_result: ?i2c.I2cResultFtraceEvent = null,
    i2c_reply: ?i2c.I2cReplyFtraceEvent = null,
    smbus_read: ?i2c.SmbusReadFtraceEvent = null,
    smbus_write: ?i2c.SmbusWriteFtraceEvent = null,
    smbus_result: ?i2c.SmbusResultFtraceEvent = null,
    smbus_reply: ?i2c.SmbusReplyFtraceEvent = null,
    lowmemory_kill: ?lowmemorykiller.LowmemoryKillFtraceEvent = null,
    irq_handler_entry: ?irq.IrqHandlerEntryFtraceEvent = null,
    irq_handler_exit: ?irq.IrqHandlerExitFtraceEvent = null,
    sync_pt: ?sync.SyncPtFtraceEvent = null,
    sync_timeline: ?sync.SyncTimelineFtraceEvent = null,
    sync_wait: ?sync.SyncWaitFtraceEvent = null,
    ext4_da_write_begin: ?ext4.Ext4DaWriteBeginFtraceEvent = null,
    ext4_da_write_end: ?ext4.Ext4DaWriteEndFtraceEvent = null,
    ext4_sync_file_enter: ?ext4.Ext4SyncFileEnterFtraceEvent = null,
    ext4_sync_file_exit: ?ext4.Ext4SyncFileExitFtraceEvent = null,
    block_rq_issue: ?block.BlockRqIssueFtraceEvent = null,
    mm_vmscan_direct_reclaim_begin: ?vmscan.MmVmscanDirectReclaimBeginFtraceEvent = null,
    mm_vmscan_direct_reclaim_end: ?vmscan.MmVmscanDirectReclaimEndFtraceEvent = null,
    mm_vmscan_kswapd_wake: ?vmscan.MmVmscanKswapdWakeFtraceEvent = null,
    mm_vmscan_kswapd_sleep: ?vmscan.MmVmscanKswapdSleepFtraceEvent = null,
    binder_transaction: ?binder.BinderTransactionFtraceEvent = null,
    binder_transaction_received: ?binder.BinderTransactionReceivedFtraceEvent = null,
    binder_set_priority: ?binder.BinderSetPriorityFtraceEvent = null,
    binder_lock: ?binder.BinderLockFtraceEvent = null,
    binder_locked: ?binder.BinderLockedFtraceEvent = null,
    binder_unlock: ?binder.BinderUnlockFtraceEvent = null,
    workqueue_activate_work: ?workqueue.WorkqueueActivateWorkFtraceEvent = null,
    workqueue_execute_end: ?workqueue.WorkqueueExecuteEndFtraceEvent = null,
    workqueue_execute_start: ?workqueue.WorkqueueExecuteStartFtraceEvent = null,
    workqueue_queue_work: ?workqueue.WorkqueueQueueWorkFtraceEvent = null,
    regulator_disable: ?regulator.RegulatorDisableFtraceEvent = null,
    regulator_disable_complete: ?regulator.RegulatorDisableCompleteFtraceEvent = null,
    regulator_enable: ?regulator.RegulatorEnableFtraceEvent = null,
    regulator_enable_complete: ?regulator.RegulatorEnableCompleteFtraceEvent = null,
    regulator_enable_delay: ?regulator.RegulatorEnableDelayFtraceEvent = null,
    regulator_set_voltage: ?regulator.RegulatorSetVoltageFtraceEvent = null,
    regulator_set_voltage_complete: ?regulator.RegulatorSetVoltageCompleteFtraceEvent = null,
    cgroup_attach_task: ?cgroup.CgroupAttachTaskFtraceEvent = null,
    cgroup_mkdir: ?cgroup.CgroupMkdirFtraceEvent = null,
    cgroup_remount: ?cgroup.CgroupRemountFtraceEvent = null,
    cgroup_rmdir: ?cgroup.CgroupRmdirFtraceEvent = null,
    cgroup_transfer_tasks: ?cgroup.CgroupTransferTasksFtraceEvent = null,
    cgroup_destroy_root: ?cgroup.CgroupDestroyRootFtraceEvent = null,
    cgroup_release: ?cgroup.CgroupReleaseFtraceEvent = null,
    cgroup_rename: ?cgroup.CgroupRenameFtraceEvent = null,
    cgroup_setup_root: ?cgroup.CgroupSetupRootFtraceEvent = null,
    mdp_cmd_kickoff: ?mdss.MdpCmdKickoffFtraceEvent = null,
    mdp_commit: ?mdss.MdpCommitFtraceEvent = null,
    mdp_perf_set_ot: ?mdss.MdpPerfSetOtFtraceEvent = null,
    mdp_sspp_change: ?mdss.MdpSsppChangeFtraceEvent = null,
    tracing_mark_write: ?mdss.TracingMarkWriteFtraceEvent = null,
    mdp_cmd_pingpong_done: ?mdss.MdpCmdPingpongDoneFtraceEvent = null,
    mdp_compare_bw: ?mdss.MdpCompareBwFtraceEvent = null,
    mdp_perf_set_panic_luts: ?mdss.MdpPerfSetPanicLutsFtraceEvent = null,
    mdp_sspp_set: ?mdss.MdpSsppSetFtraceEvent = null,
    mdp_cmd_readptr_done: ?mdss.MdpCmdReadptrDoneFtraceEvent = null,
    mdp_misr_crc: ?mdss.MdpMisrCrcFtraceEvent = null,
    mdp_perf_set_qos_luts: ?mdss.MdpPerfSetQosLutsFtraceEvent = null,
    mdp_trace_counter: ?mdss.MdpTraceCounterFtraceEvent = null,
    mdp_cmd_release_bw: ?mdss.MdpCmdReleaseBwFtraceEvent = null,
    mdp_mixer_update: ?mdss.MdpMixerUpdateFtraceEvent = null,
    mdp_perf_set_wm_levels: ?mdss.MdpPerfSetWmLevelsFtraceEvent = null,
    mdp_video_underrun_done: ?mdss.MdpVideoUnderrunDoneFtraceEvent = null,
    mdp_cmd_wait_pingpong: ?mdss.MdpCmdWaitPingpongFtraceEvent = null,
    mdp_perf_prefill_calc: ?mdss.MdpPerfPrefillCalcFtraceEvent = null,
    mdp_perf_update_bus: ?mdss.MdpPerfUpdateBusFtraceEvent = null,
    rotator_bw_ao_as_context: ?mdss.RotatorBwAoAsContextFtraceEvent = null,
    mm_filemap_add_to_page_cache: ?filemap.MmFilemapAddToPageCacheFtraceEvent = null,
    mm_filemap_delete_from_page_cache: ?filemap.MmFilemapDeleteFromPageCacheFtraceEvent = null,
    mm_compaction_begin: ?compaction.MmCompactionBeginFtraceEvent = null,
    mm_compaction_defer_compaction: ?compaction.MmCompactionDeferCompactionFtraceEvent = null,
    mm_compaction_deferred: ?compaction.MmCompactionDeferredFtraceEvent = null,
    mm_compaction_defer_reset: ?compaction.MmCompactionDeferResetFtraceEvent = null,
    mm_compaction_end: ?compaction.MmCompactionEndFtraceEvent = null,
    mm_compaction_finished: ?compaction.MmCompactionFinishedFtraceEvent = null,
    mm_compaction_isolate_freepages: ?compaction.MmCompactionIsolateFreepagesFtraceEvent = null,
    mm_compaction_isolate_migratepages: ?compaction.MmCompactionIsolateMigratepagesFtraceEvent = null,
    mm_compaction_kcompactd_sleep: ?compaction.MmCompactionKcompactdSleepFtraceEvent = null,
    mm_compaction_kcompactd_wake: ?compaction.MmCompactionKcompactdWakeFtraceEvent = null,
    mm_compaction_migratepages: ?compaction.MmCompactionMigratepagesFtraceEvent = null,
    mm_compaction_suitable: ?compaction.MmCompactionSuitableFtraceEvent = null,
    mm_compaction_try_to_compact_pages: ?compaction.MmCompactionTryToCompactPagesFtraceEvent = null,
    mm_compaction_wakeup_kcompactd: ?compaction.MmCompactionWakeupKcompactdFtraceEvent = null,
    suspend_resume: ?power.SuspendResumeFtraceEvent = null,
    sched_wakeup_new: ?sched.SchedWakeupNewFtraceEvent = null,
    block_bio_backmerge: ?block.BlockBioBackmergeFtraceEvent = null,
    block_bio_bounce: ?block.BlockBioBounceFtraceEvent = null,
    block_bio_complete: ?block.BlockBioCompleteFtraceEvent = null,
    block_bio_frontmerge: ?block.BlockBioFrontmergeFtraceEvent = null,
    block_bio_queue: ?block.BlockBioQueueFtraceEvent = null,
    block_bio_remap: ?block.BlockBioRemapFtraceEvent = null,
    block_dirty_buffer: ?block.BlockDirtyBufferFtraceEvent = null,
    block_getrq: ?block.BlockGetrqFtraceEvent = null,
    block_plug: ?block.BlockPlugFtraceEvent = null,
    block_rq_abort: ?block.BlockRqAbortFtraceEvent = null,
    block_rq_complete: ?block.BlockRqCompleteFtraceEvent = null,
    block_rq_insert: ?block.BlockRqInsertFtraceEvent = null,
    block_rq_remap: ?block.BlockRqRemapFtraceEvent = null,
    block_rq_requeue: ?block.BlockRqRequeueFtraceEvent = null,
    block_sleeprq: ?block.BlockSleeprqFtraceEvent = null,
    block_split: ?block.BlockSplitFtraceEvent = null,
    block_touch_buffer: ?block.BlockTouchBufferFtraceEvent = null,
    block_unplug: ?block.BlockUnplugFtraceEvent = null,
    ext4_alloc_da_blocks: ?ext4.Ext4AllocDaBlocksFtraceEvent = null,
    ext4_allocate_blocks: ?ext4.Ext4AllocateBlocksFtraceEvent = null,
    ext4_allocate_inode: ?ext4.Ext4AllocateInodeFtraceEvent = null,
    ext4_begin_ordered_truncate: ?ext4.Ext4BeginOrderedTruncateFtraceEvent = null,
    ext4_collapse_range: ?ext4.Ext4CollapseRangeFtraceEvent = null,
    ext4_da_release_space: ?ext4.Ext4DaReleaseSpaceFtraceEvent = null,
    ext4_da_reserve_space: ?ext4.Ext4DaReserveSpaceFtraceEvent = null,
    ext4_da_update_reserve_space: ?ext4.Ext4DaUpdateReserveSpaceFtraceEvent = null,
    ext4_da_write_pages: ?ext4.Ext4DaWritePagesFtraceEvent = null,
    ext4_da_write_pages_extent: ?ext4.Ext4DaWritePagesExtentFtraceEvent = null,
    ext4_direct_i_o_enter: ?ext4.Ext4DirectIOEnterFtraceEvent = null,
    ext4_direct_i_o_exit: ?ext4.Ext4DirectIOExitFtraceEvent = null,
    ext4_discard_blocks: ?ext4.Ext4DiscardBlocksFtraceEvent = null,
    ext4_discard_preallocations: ?ext4.Ext4DiscardPreallocationsFtraceEvent = null,
    ext4_drop_inode: ?ext4.Ext4DropInodeFtraceEvent = null,
    ext4_es_cache_extent: ?ext4.Ext4EsCacheExtentFtraceEvent = null,
    ext4_es_find_delayed_extent_range_enter: ?ext4.Ext4EsFindDelayedExtentRangeEnterFtraceEvent = null,
    ext4_es_find_delayed_extent_range_exit: ?ext4.Ext4EsFindDelayedExtentRangeExitFtraceEvent = null,
    ext4_es_insert_extent: ?ext4.Ext4EsInsertExtentFtraceEvent = null,
    ext4_es_lookup_extent_enter: ?ext4.Ext4EsLookupExtentEnterFtraceEvent = null,
    ext4_es_lookup_extent_exit: ?ext4.Ext4EsLookupExtentExitFtraceEvent = null,
    ext4_es_remove_extent: ?ext4.Ext4EsRemoveExtentFtraceEvent = null,
    ext4_es_shrink: ?ext4.Ext4EsShrinkFtraceEvent = null,
    ext4_es_shrink_count: ?ext4.Ext4EsShrinkCountFtraceEvent = null,
    ext4_es_shrink_scan_enter: ?ext4.Ext4EsShrinkScanEnterFtraceEvent = null,
    ext4_es_shrink_scan_exit: ?ext4.Ext4EsShrinkScanExitFtraceEvent = null,
    ext4_evict_inode: ?ext4.Ext4EvictInodeFtraceEvent = null,
    ext4_ext_convert_to_initialized_enter: ?ext4.Ext4ExtConvertToInitializedEnterFtraceEvent = null,
    ext4_ext_convert_to_initialized_fastpath: ?ext4.Ext4ExtConvertToInitializedFastpathFtraceEvent = null,
    ext4_ext_handle_unwritten_extents: ?ext4.Ext4ExtHandleUnwrittenExtentsFtraceEvent = null,
    ext4_ext_in_cache: ?ext4.Ext4ExtInCacheFtraceEvent = null,
    ext4_ext_load_extent: ?ext4.Ext4ExtLoadExtentFtraceEvent = null,
    ext4_ext_map_blocks_enter: ?ext4.Ext4ExtMapBlocksEnterFtraceEvent = null,
    ext4_ext_map_blocks_exit: ?ext4.Ext4ExtMapBlocksExitFtraceEvent = null,
    ext4_ext_put_in_cache: ?ext4.Ext4ExtPutInCacheFtraceEvent = null,
    ext4_ext_remove_space: ?ext4.Ext4ExtRemoveSpaceFtraceEvent = null,
    ext4_ext_remove_space_done: ?ext4.Ext4ExtRemoveSpaceDoneFtraceEvent = null,
    ext4_ext_rm_idx: ?ext4.Ext4ExtRmIdxFtraceEvent = null,
    ext4_ext_rm_leaf: ?ext4.Ext4ExtRmLeafFtraceEvent = null,
    ext4_ext_show_extent: ?ext4.Ext4ExtShowExtentFtraceEvent = null,
    ext4_fallocate_enter: ?ext4.Ext4FallocateEnterFtraceEvent = null,
    ext4_fallocate_exit: ?ext4.Ext4FallocateExitFtraceEvent = null,
    ext4_find_delalloc_range: ?ext4.Ext4FindDelallocRangeFtraceEvent = null,
    ext4_forget: ?ext4.Ext4ForgetFtraceEvent = null,
    ext4_free_blocks: ?ext4.Ext4FreeBlocksFtraceEvent = null,
    ext4_free_inode: ?ext4.Ext4FreeInodeFtraceEvent = null,
    ext4_get_implied_cluster_alloc_exit: ?ext4.Ext4GetImpliedClusterAllocExitFtraceEvent = null,
    ext4_get_reserved_cluster_alloc: ?ext4.Ext4GetReservedClusterAllocFtraceEvent = null,
    ext4_ind_map_blocks_enter: ?ext4.Ext4IndMapBlocksEnterFtraceEvent = null,
    ext4_ind_map_blocks_exit: ?ext4.Ext4IndMapBlocksExitFtraceEvent = null,
    ext4_insert_range: ?ext4.Ext4InsertRangeFtraceEvent = null,
    ext4_invalidatepage: ?ext4.Ext4InvalidatepageFtraceEvent = null,
    ext4_journal_start: ?ext4.Ext4JournalStartFtraceEvent = null,
    ext4_journal_start_reserved: ?ext4.Ext4JournalStartReservedFtraceEvent = null,
    ext4_journalled_invalidatepage: ?ext4.Ext4JournalledInvalidatepageFtraceEvent = null,
    ext4_journalled_write_end: ?ext4.Ext4JournalledWriteEndFtraceEvent = null,
    ext4_load_inode: ?ext4.Ext4LoadInodeFtraceEvent = null,
    ext4_load_inode_bitmap: ?ext4.Ext4LoadInodeBitmapFtraceEvent = null,
    ext4_mark_inode_dirty: ?ext4.Ext4MarkInodeDirtyFtraceEvent = null,
    ext4_mb_bitmap_load: ?ext4.Ext4MbBitmapLoadFtraceEvent = null,
    ext4_mb_buddy_bitmap_load: ?ext4.Ext4MbBuddyBitmapLoadFtraceEvent = null,
    ext4_mb_discard_preallocations: ?ext4.Ext4MbDiscardPreallocationsFtraceEvent = null,
    ext4_mb_new_group_pa: ?ext4.Ext4MbNewGroupPaFtraceEvent = null,
    ext4_mb_new_inode_pa: ?ext4.Ext4MbNewInodePaFtraceEvent = null,
    ext4_mb_release_group_pa: ?ext4.Ext4MbReleaseGroupPaFtraceEvent = null,
    ext4_mb_release_inode_pa: ?ext4.Ext4MbReleaseInodePaFtraceEvent = null,
    ext4_mballoc_alloc: ?ext4.Ext4MballocAllocFtraceEvent = null,
    ext4_mballoc_discard: ?ext4.Ext4MballocDiscardFtraceEvent = null,
    ext4_mballoc_free: ?ext4.Ext4MballocFreeFtraceEvent = null,
    ext4_mballoc_prealloc: ?ext4.Ext4MballocPreallocFtraceEvent = null,
    ext4_other_inode_update_time: ?ext4.Ext4OtherInodeUpdateTimeFtraceEvent = null,
    ext4_punch_hole: ?ext4.Ext4PunchHoleFtraceEvent = null,
    ext4_read_block_bitmap_load: ?ext4.Ext4ReadBlockBitmapLoadFtraceEvent = null,
    ext4_readpage: ?ext4.Ext4ReadpageFtraceEvent = null,
    ext4_releasepage: ?ext4.Ext4ReleasepageFtraceEvent = null,
    ext4_remove_blocks: ?ext4.Ext4RemoveBlocksFtraceEvent = null,
    ext4_request_blocks: ?ext4.Ext4RequestBlocksFtraceEvent = null,
    ext4_request_inode: ?ext4.Ext4RequestInodeFtraceEvent = null,
    ext4_sync_fs: ?ext4.Ext4SyncFsFtraceEvent = null,
    ext4_trim_all_free: ?ext4.Ext4TrimAllFreeFtraceEvent = null,
    ext4_trim_extent: ?ext4.Ext4TrimExtentFtraceEvent = null,
    ext4_truncate_enter: ?ext4.Ext4TruncateEnterFtraceEvent = null,
    ext4_truncate_exit: ?ext4.Ext4TruncateExitFtraceEvent = null,
    ext4_unlink_enter: ?ext4.Ext4UnlinkEnterFtraceEvent = null,
    ext4_unlink_exit: ?ext4.Ext4UnlinkExitFtraceEvent = null,
    ext4_write_begin: ?ext4.Ext4WriteBeginFtraceEvent = null,
    ext4_write_end: ?ext4.Ext4WriteEndFtraceEvent = null,
    ext4_writepage: ?ext4.Ext4WritepageFtraceEvent = null,
    ext4_writepages: ?ext4.Ext4WritepagesFtraceEvent = null,
    ext4_writepages_result: ?ext4.Ext4WritepagesResultFtraceEvent = null,
    ext4_zero_range: ?ext4.Ext4ZeroRangeFtraceEvent = null,
    task_newtask: ?task.TaskNewtaskFtraceEvent = null,
    task_rename: ?task.TaskRenameFtraceEvent = null,
    sched_process_exec: ?sched.SchedProcessExecFtraceEvent = null,
    sched_process_exit: ?sched.SchedProcessExitFtraceEvent = null,
    sched_process_fork: ?sched.SchedProcessForkFtraceEvent = null,
    sched_process_free: ?sched.SchedProcessFreeFtraceEvent = null,
    sched_process_hang: ?sched.SchedProcessHangFtraceEvent = null,
    sched_process_wait: ?sched.SchedProcessWaitFtraceEvent = null,
    f2fs_do_submit_bio: ?f2fs.F2fsDoSubmitBioFtraceEvent = null,
    f2fs_evict_inode: ?f2fs.F2fsEvictInodeFtraceEvent = null,
    f2fs_fallocate: ?f2fs.F2fsFallocateFtraceEvent = null,
    f2fs_get_data_block: ?f2fs.F2fsGetDataBlockFtraceEvent = null,
    f2fs_get_victim: ?f2fs.F2fsGetVictimFtraceEvent = null,
    f2fs_iget: ?f2fs.F2fsIgetFtraceEvent = null,
    f2fs_iget_exit: ?f2fs.F2fsIgetExitFtraceEvent = null,
    f2fs_new_inode: ?f2fs.F2fsNewInodeFtraceEvent = null,
    f2fs_readpage: ?f2fs.F2fsReadpageFtraceEvent = null,
    f2fs_reserve_new_block: ?f2fs.F2fsReserveNewBlockFtraceEvent = null,
    f2fs_set_page_dirty: ?f2fs.F2fsSetPageDirtyFtraceEvent = null,
    f2fs_submit_write_page: ?f2fs.F2fsSubmitWritePageFtraceEvent = null,
    f2fs_sync_file_enter: ?f2fs.F2fsSyncFileEnterFtraceEvent = null,
    f2fs_sync_file_exit: ?f2fs.F2fsSyncFileExitFtraceEvent = null,
    f2fs_sync_fs: ?f2fs.F2fsSyncFsFtraceEvent = null,
    f2fs_truncate: ?f2fs.F2fsTruncateFtraceEvent = null,
    f2fs_truncate_blocks_enter: ?f2fs.F2fsTruncateBlocksEnterFtraceEvent = null,
    f2fs_truncate_blocks_exit: ?f2fs.F2fsTruncateBlocksExitFtraceEvent = null,
    f2fs_truncate_data_blocks_range: ?f2fs.F2fsTruncateDataBlocksRangeFtraceEvent = null,
    f2fs_truncate_inode_blocks_enter: ?f2fs.F2fsTruncateInodeBlocksEnterFtraceEvent = null,
    f2fs_truncate_inode_blocks_exit: ?f2fs.F2fsTruncateInodeBlocksExitFtraceEvent = null,
    f2fs_truncate_node: ?f2fs.F2fsTruncateNodeFtraceEvent = null,
    f2fs_truncate_nodes_enter: ?f2fs.F2fsTruncateNodesEnterFtraceEvent = null,
    f2fs_truncate_nodes_exit: ?f2fs.F2fsTruncateNodesExitFtraceEvent = null,
    f2fs_truncate_partial_nodes: ?f2fs.F2fsTruncatePartialNodesFtraceEvent = null,
    f2fs_unlink_enter: ?f2fs.F2fsUnlinkEnterFtraceEvent = null,
    f2fs_unlink_exit: ?f2fs.F2fsUnlinkExitFtraceEvent = null,
    f2fs_vm_page_mkwrite: ?f2fs.F2fsVmPageMkwriteFtraceEvent = null,
    f2fs_write_begin: ?f2fs.F2fsWriteBeginFtraceEvent = null,
    f2fs_write_checkpoint: ?f2fs.F2fsWriteCheckpointFtraceEvent = null,
    f2fs_write_end: ?f2fs.F2fsWriteEndFtraceEvent = null,
    alloc_pages_iommu_end: ?kmem.AllocPagesIommuEndFtraceEvent = null,
    alloc_pages_iommu_fail: ?kmem.AllocPagesIommuFailFtraceEvent = null,
    alloc_pages_iommu_start: ?kmem.AllocPagesIommuStartFtraceEvent = null,
    alloc_pages_sys_end: ?kmem.AllocPagesSysEndFtraceEvent = null,
    alloc_pages_sys_fail: ?kmem.AllocPagesSysFailFtraceEvent = null,
    alloc_pages_sys_start: ?kmem.AllocPagesSysStartFtraceEvent = null,
    dma_alloc_contiguous_retry: ?kmem.DmaAllocContiguousRetryFtraceEvent = null,
    iommu_map_range: ?kmem.IommuMapRangeFtraceEvent = null,
    iommu_sec_ptbl_map_range_end: ?kmem.IommuSecPtblMapRangeEndFtraceEvent = null,
    iommu_sec_ptbl_map_range_start: ?kmem.IommuSecPtblMapRangeStartFtraceEvent = null,
    ion_alloc_buffer_end: ?kmem.IonAllocBufferEndFtraceEvent = null,
    ion_alloc_buffer_fail: ?kmem.IonAllocBufferFailFtraceEvent = null,
    ion_alloc_buffer_fallback: ?kmem.IonAllocBufferFallbackFtraceEvent = null,
    ion_alloc_buffer_start: ?kmem.IonAllocBufferStartFtraceEvent = null,
    ion_cp_alloc_retry: ?kmem.IonCpAllocRetryFtraceEvent = null,
    ion_cp_secure_buffer_end: ?kmem.IonCpSecureBufferEndFtraceEvent = null,
    ion_cp_secure_buffer_start: ?kmem.IonCpSecureBufferStartFtraceEvent = null,
    ion_prefetching: ?kmem.IonPrefetchingFtraceEvent = null,
    ion_secure_cma_add_to_pool_end: ?kmem.IonSecureCmaAddToPoolEndFtraceEvent = null,
    ion_secure_cma_add_to_pool_start: ?kmem.IonSecureCmaAddToPoolStartFtraceEvent = null,
    ion_secure_cma_allocate_end: ?kmem.IonSecureCmaAllocateEndFtraceEvent = null,
    ion_secure_cma_allocate_start: ?kmem.IonSecureCmaAllocateStartFtraceEvent = null,
    ion_secure_cma_shrink_pool_end: ?kmem.IonSecureCmaShrinkPoolEndFtraceEvent = null,
    ion_secure_cma_shrink_pool_start: ?kmem.IonSecureCmaShrinkPoolStartFtraceEvent = null,
    kfree: ?kmem.KfreeFtraceEvent = null,
    kmalloc: ?kmem.KmallocFtraceEvent = null,
    kmalloc_node: ?kmem.KmallocNodeFtraceEvent = null,
    kmem_cache_alloc: ?kmem.KmemCacheAllocFtraceEvent = null,
    kmem_cache_alloc_node: ?kmem.KmemCacheAllocNodeFtraceEvent = null,
    kmem_cache_free: ?kmem.KmemCacheFreeFtraceEvent = null,
    migrate_pages_end: ?kmem.MigratePagesEndFtraceEvent = null,
    migrate_pages_start: ?kmem.MigratePagesStartFtraceEvent = null,
    migrate_retry: ?kmem.MigrateRetryFtraceEvent = null,
    mm_page_alloc: ?kmem.MmPageAllocFtraceEvent = null,
    mm_page_alloc_extfrag: ?kmem.MmPageAllocExtfragFtraceEvent = null,
    mm_page_alloc_zone_locked: ?kmem.MmPageAllocZoneLockedFtraceEvent = null,
    mm_page_free: ?kmem.MmPageFreeFtraceEvent = null,
    mm_page_free_batched: ?kmem.MmPageFreeBatchedFtraceEvent = null,
    mm_page_pcpu_drain: ?kmem.MmPagePcpuDrainFtraceEvent = null,
    rss_stat: ?kmem.RssStatFtraceEvent = null,
    ion_heap_shrink: ?kmem.IonHeapShrinkFtraceEvent = null,
    ion_heap_grow: ?kmem.IonHeapGrowFtraceEvent = null,
    fence_init: ?fence.FenceInitFtraceEvent = null,
    fence_destroy: ?fence.FenceDestroyFtraceEvent = null,
    fence_enable_signal: ?fence.FenceEnableSignalFtraceEvent = null,
    fence_signaled: ?fence.FenceSignaledFtraceEvent = null,
    clk_enable: ?clk.ClkEnableFtraceEvent = null,
    clk_disable: ?clk.ClkDisableFtraceEvent = null,
    clk_set_rate: ?clk.ClkSetRateFtraceEvent = null,
    binder_transaction_alloc_buf: ?binder.BinderTransactionAllocBufFtraceEvent = null,
    signal_deliver: ?signal.SignalDeliverFtraceEvent = null,
    signal_generate: ?signal.SignalGenerateFtraceEvent = null,
    oom_score_adj_update: ?oom.OomScoreAdjUpdateFtraceEvent = null,
    generic: ?generic.GenericFtraceEvent = null,
    mm_event_record: ?mm_event.MmEventRecordFtraceEvent = null,
    sys_enter: ?raw_syscalls.SysEnterFtraceEvent = null,
    sys_exit: ?raw_syscalls.SysExitFtraceEvent = null,
    zero: ?systrace.ZeroFtraceEvent = null,
    gpu_frequency: ?power.GpuFrequencyFtraceEvent = null,
    sde_tracing_mark_write: ?sde.SdeTracingMarkWriteFtraceEvent = null,
    mark_victim: ?oom.MarkVictimFtraceEvent = null,
    ion_stat: ?ion.IonStatFtraceEvent = null,
    ion_buffer_create: ?kmem.IonBufferCreateFtraceEvent = null,
    ion_buffer_destroy: ?kmem.IonBufferDestroyFtraceEvent = null,
    scm_call_start: ?scm.ScmCallStartFtraceEvent = null,
    scm_call_end: ?scm.ScmCallEndFtraceEvent = null,
    gpu_mem_total: ?gpu_mem.GpuMemTotalFtraceEvent = null,
    thermal_temperature: ?thermal.ThermalTemperatureFtraceEvent = null,
    cdev_update: ?thermal.CdevUpdateFtraceEvent = null,
    cpuhp_exit: ?cpuhp.CpuhpExitFtraceEvent = null,
    cpuhp_multi_enter: ?cpuhp.CpuhpMultiEnterFtraceEvent = null,
    cpuhp_enter: ?cpuhp.CpuhpEnterFtraceEvent = null,
    cpuhp_latency: ?cpuhp.CpuhpLatencyFtraceEvent = null,
    fastrpc_dma_stat: ?fastrpc.FastrpcDmaStatFtraceEvent = null,
    dpu_tracing_mark_write: ?dpu.DpuTracingMarkWriteFtraceEvent = null,
    g2d_tracing_mark_write: ?g2d.G2dTracingMarkWriteFtraceEvent = null,
    mali_tracing_mark_write: ?mali.MaliTracingMarkWriteFtraceEvent = null,
    dma_heap_stat: ?dmabuf_heap.DmaHeapStatFtraceEvent = null,
    cpuhp_pause: ?cpuhp.CpuhpPauseFtraceEvent = null,
    sched_pi_setprio: ?sched.SchedPiSetprioFtraceEvent = null,
    sde_sde_evtlog: ?sde.SdeSdeEvtlogFtraceEvent = null,
    sde_sde_perf_calc_crtc: ?sde.SdeSdePerfCalcCrtcFtraceEvent = null,
    sde_sde_perf_crtc_update: ?sde.SdeSdePerfCrtcUpdateFtraceEvent = null,
    sde_sde_perf_set_qos_luts: ?sde.SdeSdePerfSetQosLutsFtraceEvent = null,
    sde_sde_perf_update_bus: ?sde.SdeSdePerfUpdateBusFtraceEvent = null,
    rss_stat_throttled: ?synthetic.RssStatThrottledFtraceEvent = null,
    netif_receive_skb: ?net.NetifReceiveSkbFtraceEvent = null,
    net_dev_xmit: ?net.NetDevXmitFtraceEvent = null,
    inet_sock_set_state: ?sock.InetSockSetStateFtraceEvent = null,
    tcp_retransmit_skb: ?tcp.TcpRetransmitSkbFtraceEvent = null,
    cros_ec_sensorhub_data: ?cros_ec.CrosEcSensorhubDataFtraceEvent = null,
    napi_gro_receive_entry: ?net.NapiGroReceiveEntryFtraceEvent = null,
    napi_gro_receive_exit: ?net.NapiGroReceiveExitFtraceEvent = null,
    kfree_skb: ?skb.KfreeSkbFtraceEvent = null,
    kvm_access_fault: ?kvm.KvmAccessFaultFtraceEvent = null,
    kvm_ack_irq: ?kvm.KvmAckIrqFtraceEvent = null,
    kvm_age_hva: ?kvm.KvmAgeHvaFtraceEvent = null,
    kvm_age_page: ?kvm.KvmAgePageFtraceEvent = null,
    kvm_arm_clear_debug: ?kvm.KvmArmClearDebugFtraceEvent = null,
    kvm_arm_set_dreg32: ?kvm.KvmArmSetDreg32FtraceEvent = null,
    kvm_arm_set_regset: ?kvm.KvmArmSetRegsetFtraceEvent = null,
    kvm_arm_setup_debug: ?kvm.KvmArmSetupDebugFtraceEvent = null,
    kvm_entry: ?kvm.KvmEntryFtraceEvent = null,
    kvm_exit: ?kvm.KvmExitFtraceEvent = null,
    kvm_fpu: ?kvm.KvmFpuFtraceEvent = null,
    kvm_get_timer_map: ?kvm.KvmGetTimerMapFtraceEvent = null,
    kvm_guest_fault: ?kvm.KvmGuestFaultFtraceEvent = null,
    kvm_handle_sys_reg: ?kvm.KvmHandleSysRegFtraceEvent = null,
    kvm_hvc_arm64: ?kvm.KvmHvcArm64FtraceEvent = null,
    kvm_irq_line: ?kvm.KvmIrqLineFtraceEvent = null,
    kvm_mmio: ?kvm.KvmMmioFtraceEvent = null,
    kvm_mmio_emulate: ?kvm.KvmMmioEmulateFtraceEvent = null,
    kvm_set_guest_debug: ?kvm.KvmSetGuestDebugFtraceEvent = null,
    kvm_set_irq: ?kvm.KvmSetIrqFtraceEvent = null,
    kvm_set_spte_hva: ?kvm.KvmSetSpteHvaFtraceEvent = null,
    kvm_set_way_flush: ?kvm.KvmSetWayFlushFtraceEvent = null,
    kvm_sys_access: ?kvm.KvmSysAccessFtraceEvent = null,
    kvm_test_age_hva: ?kvm.KvmTestAgeHvaFtraceEvent = null,
    kvm_timer_emulate: ?kvm.KvmTimerEmulateFtraceEvent = null,
    kvm_timer_hrtimer_expire: ?kvm.KvmTimerHrtimerExpireFtraceEvent = null,
    kvm_timer_restore_state: ?kvm.KvmTimerRestoreStateFtraceEvent = null,
    kvm_timer_save_state: ?kvm.KvmTimerSaveStateFtraceEvent = null,
    kvm_timer_update_irq: ?kvm.KvmTimerUpdateIrqFtraceEvent = null,
    kvm_toggle_cache: ?kvm.KvmToggleCacheFtraceEvent = null,
    kvm_unmap_hva_range: ?kvm.KvmUnmapHvaRangeFtraceEvent = null,
    kvm_userspace_exit: ?kvm.KvmUserspaceExitFtraceEvent = null,
    kvm_vcpu_wakeup: ?kvm.KvmVcpuWakeupFtraceEvent = null,
    kvm_wfx_arm64: ?kvm.KvmWfxArm64FtraceEvent = null,
    trap_reg: ?kvm.TrapRegFtraceEvent = null,
    vgic_update_irq_pending: ?kvm.VgicUpdateIrqPendingFtraceEvent = null,
    wakeup_source_activate: ?power.WakeupSourceActivateFtraceEvent = null,
    wakeup_source_deactivate: ?power.WakeupSourceDeactivateFtraceEvent = null,
    ufshcd_command: ?ufs.UfshcdCommandFtraceEvent = null,
    ufshcd_clk_gating: ?ufs.UfshcdClkGatingFtraceEvent = null,
    console: ?printk.ConsoleFtraceEvent = null,
    drm_vblank_event: ?drm.DrmVblankEventFtraceEvent = null,
    drm_vblank_event_delivered: ?drm.DrmVblankEventDeliveredFtraceEvent = null,
    drm_sched_job: ?gpu_scheduler.DrmSchedJobFtraceEvent = null,
    drm_run_job: ?gpu_scheduler.DrmRunJobFtraceEvent = null,
    drm_sched_process_job: ?gpu_scheduler.DrmSchedProcessJobFtraceEvent = null,
    dma_fence_init: ?dma_fence.DmaFenceInitFtraceEvent = null,
    dma_fence_emit: ?dma_fence.DmaFenceEmitFtraceEvent = null,
    dma_fence_signaled: ?dma_fence.DmaFenceSignaledFtraceEvent = null,
    dma_fence_wait_start: ?dma_fence.DmaFenceWaitStartFtraceEvent = null,
    dma_fence_wait_end: ?dma_fence.DmaFenceWaitEndFtraceEvent = null,
    f2fs_iostat: ?f2fs.F2fsIostatFtraceEvent = null,
    f2fs_iostat_latency: ?f2fs.F2fsIostatLatencyFtraceEvent = null,
    sched_cpu_util_cfs: ?sched.SchedCpuUtilCfsFtraceEvent = null,
    v4l2_qbuf: ?v4l2.V4l2QbufFtraceEvent = null,
    v4l2_dqbuf: ?v4l2.V4l2DqbufFtraceEvent = null,
    vb2_v4l2_buf_queue: ?v4l2.Vb2V4l2BufQueueFtraceEvent = null,
    vb2_v4l2_buf_done: ?v4l2.Vb2V4l2BufDoneFtraceEvent = null,
    vb2_v4l2_qbuf: ?v4l2.Vb2V4l2QbufFtraceEvent = null,
    vb2_v4l2_dqbuf: ?v4l2.Vb2V4l2DqbufFtraceEvent = null,
    dsi_cmd_fifo_status: ?panel.DsiCmdFifoStatusFtraceEvent = null,
    dsi_rx: ?panel.DsiRxFtraceEvent = null,
    dsi_tx: ?panel.DsiTxFtraceEvent = null,
    android_fs_dataread_end: ?android_fs.AndroidFsDatareadEndFtraceEvent = null,
    android_fs_dataread_start: ?android_fs.AndroidFsDatareadStartFtraceEvent = null,
    android_fs_datawrite_end: ?android_fs.AndroidFsDatawriteEndFtraceEvent = null,
    android_fs_datawrite_start: ?android_fs.AndroidFsDatawriteStartFtraceEvent = null,
    android_fs_fsync_end: ?android_fs.AndroidFsFsyncEndFtraceEvent = null,
    android_fs_fsync_start: ?android_fs.AndroidFsFsyncStartFtraceEvent = null,
    funcgraph_entry: ?ftrace.FuncgraphEntryFtraceEvent = null,
    funcgraph_exit: ?ftrace.FuncgraphExitFtraceEvent = null,
    virtio_video_cmd: ?virtio_video.VirtioVideoCmdFtraceEvent = null,
    virtio_video_cmd_done: ?virtio_video.VirtioVideoCmdDoneFtraceEvent = null,
    virtio_video_resource_queue: ?virtio_video.VirtioVideoResourceQueueFtraceEvent = null,
    virtio_video_resource_queue_done: ?virtio_video.VirtioVideoResourceQueueDoneFtraceEvent = null,
    mm_shrink_slab_start: ?vmscan.MmShrinkSlabStartFtraceEvent = null,
    mm_shrink_slab_end: ?vmscan.MmShrinkSlabEndFtraceEvent = null,
    trusty_smc: ?trusty.TrustySmcFtraceEvent = null,
    trusty_smc_done: ?trusty.TrustySmcDoneFtraceEvent = null,
    trusty_std_call32: ?trusty.TrustyStdCall32FtraceEvent = null,
    trusty_std_call32_done: ?trusty.TrustyStdCall32DoneFtraceEvent = null,
    trusty_share_memory: ?trusty.TrustyShareMemoryFtraceEvent = null,
    trusty_share_memory_done: ?trusty.TrustyShareMemoryDoneFtraceEvent = null,
    trusty_reclaim_memory: ?trusty.TrustyReclaimMemoryFtraceEvent = null,
    trusty_reclaim_memory_done: ?trusty.TrustyReclaimMemoryDoneFtraceEvent = null,
    trusty_irq: ?trusty.TrustyIrqFtraceEvent = null,
    trusty_ipc_handle_event: ?trusty.TrustyIpcHandleEventFtraceEvent = null,
    trusty_ipc_connect: ?trusty.TrustyIpcConnectFtraceEvent = null,
    trusty_ipc_connect_end: ?trusty.TrustyIpcConnectEndFtraceEvent = null,
    trusty_ipc_write: ?trusty.TrustyIpcWriteFtraceEvent = null,
    trusty_ipc_poll: ?trusty.TrustyIpcPollFtraceEvent = null,
    trusty_ipc_read: ?trusty.TrustyIpcReadFtraceEvent = null,
    trusty_ipc_read_end: ?trusty.TrustyIpcReadEndFtraceEvent = null,
    trusty_ipc_rx: ?trusty.TrustyIpcRxFtraceEvent = null,
    trusty_enqueue_nop: ?trusty.TrustyEnqueueNopFtraceEvent = null,
    cma_alloc_start: ?cma.CmaAllocStartFtraceEvent = null,
    cma_alloc_info: ?cma.CmaAllocInfoFtraceEvent = null,
    lwis_tracing_mark_write: ?lwis.LwisTracingMarkWriteFtraceEvent = null,
    virtio_gpu_cmd_queue: ?virtio_gpu.VirtioGpuCmdQueueFtraceEvent = null,
    virtio_gpu_cmd_response: ?virtio_gpu.VirtioGpuCmdResponseFtraceEvent = null,
    mali_mali_k_c_p_u_c_q_s_s_e_t: ?mali.MaliMaliKCPUCQSSETFtraceEvent = null,
    mali_mali_k_c_p_u_c_q_s_w_a_i_t_s_t_a_r_t: ?mali.MaliMaliKCPUCQSWAITSTARTFtraceEvent = null,
    mali_mali_k_c_p_u_c_q_s_w_a_i_t_e_n_d: ?mali.MaliMaliKCPUCQSWAITENDFtraceEvent = null,
    mali_mali_k_c_p_u_f_e_n_c_e_s_i_g_n_a_l: ?mali.MaliMaliKCPUFENCESIGNALFtraceEvent = null,
    mali_mali_k_c_p_u_f_e_n_c_e_w_a_i_t_s_t_a_r_t: ?mali.MaliMaliKCPUFENCEWAITSTARTFtraceEvent = null,
    mali_mali_k_c_p_u_f_e_n_c_e_w_a_i_t_e_n_d: ?mali.MaliMaliKCPUFENCEWAITENDFtraceEvent = null,
    hyp_enter: ?hyp.HypEnterFtraceEvent = null,
    hyp_exit: ?hyp.HypExitFtraceEvent = null,
    host_hcall: ?hyp.HostHcallFtraceEvent = null,
    host_smc: ?hyp.HostSmcFtraceEvent = null,
    host_mem_abort: ?hyp.HostMemAbortFtraceEvent = null,
    suspend_resume_minimal: ?synthetic.SuspendResumeMinimalFtraceEvent = null,
    mali_mali_c_s_f_i_n_t_e_r_r_u_p_t_s_t_a_r_t: ?mali.MaliMaliCSFINTERRUPTSTARTFtraceEvent = null,
    mali_mali_c_s_f_i_n_t_e_r_r_u_p_t_e_n_d: ?mali.MaliMaliCSFINTERRUPTENDFtraceEvent = null,
    samsung_tracing_mark_write: ?samsung.SamsungTracingMarkWriteFtraceEvent = null,
    binder_command: ?binder.BinderCommandFtraceEvent = null,
    binder_return: ?binder.BinderReturnFtraceEvent = null,
    sched_switch_with_ctrs: ?perf_trace_counters.SchedSwitchWithCtrsFtraceEvent = null,
    gpu_work_period: ?power.GpuWorkPeriodFtraceEvent = null,
    rpm_status: ?rpm.RpmStatusFtraceEvent = null,
    panel_write_generic: ?panel.PanelWriteGenericFtraceEvent = null,
    sched_migrate_task: ?sched.SchedMigrateTaskFtraceEvent = null,
    dpu_dsi_cmd_fifo_status: ?dpu.DpuDsiCmdFifoStatusFtraceEvent = null,
    dpu_dsi_rx: ?dpu.DpuDsiRxFtraceEvent = null,
    dpu_dsi_tx: ?dpu.DpuDsiTxFtraceEvent = null,
    f2fs_background_gc: ?f2fs.F2fsBackgroundGcFtraceEvent = null,
    f2fs_gc_begin: ?f2fs.F2fsGcBeginFtraceEvent = null,
    f2fs_gc_end: ?f2fs.F2fsGcEndFtraceEvent = null,
    fastrpc_dma_free: ?fastrpc.FastrpcDmaFreeFtraceEvent = null,
    fastrpc_dma_alloc: ?fastrpc.FastrpcDmaAllocFtraceEvent = null,
    fastrpc_dma_unmap: ?fastrpc.FastrpcDmaUnmapFtraceEvent = null,
    fastrpc_dma_map: ?fastrpc.FastrpcDmaMapFtraceEvent = null,
    google_icc_event: ?google_icc_trace.GoogleIccEventFtraceEvent = null,
    google_irm_event: ?google_irm_trace.GoogleIrmEventFtraceEvent = null,
    device_pm_callback_start: ?power.DevicePmCallbackStartFtraceEvent = null,
    device_pm_callback_end: ?power.DevicePmCallbackEndFtraceEvent = null,
    thermal_exynos_acpm_bulk: ?thermal_exynos.ThermalExynosAcpmBulkFtraceEvent = null,
    thermal_exynos_acpm_high_overhead: ?thermal_exynos.ThermalExynosAcpmHighOverheadFtraceEvent = null,
    dcvsh_freq: ?dcvsh.DcvshFreqFtraceEvent = null,
    kgsl_gpu_frequency: ?kgsl.KgslGpuFrequencyFtraceEvent = null,
    mali_mali_p_m_m_c_u_h_c_t_l_c_o_r_e_s_d_o_w_n_s_c_a_l_e_n_o_t_i_f_y_p_e_n_d: ?mali.MaliMaliPMMCUHCTLCORESDOWNSCALENOTIFYPENDFtraceEvent = null,
    mali_mali_p_m_m_c_u_h_c_t_l_c_o_r_e_s_n_o_t_i_f_y_p_e_n_d: ?mali.MaliMaliPMMCUHCTLCORESNOTIFYPENDFtraceEvent = null,
    mali_mali_p_m_m_c_u_h_c_t_l_c_o_r_e_i_n_a_c_t_i_v_e_p_e_n_d: ?mali.MaliMaliPMMCUHCTLCOREINACTIVEPENDFtraceEvent = null,
    mali_mali_p_m_m_c_u_h_c_t_l_m_c_u_o_n_r_e_c_h_e_c_k: ?mali.MaliMaliPMMCUHCTLMCUONRECHECKFtraceEvent = null,
    mali_mali_p_m_m_c_u_h_c_t_l_s_h_a_d_e_r_s_c_o_r_e_o_f_f_p_e_n_d: ?mali.MaliMaliPMMCUHCTLSHADERSCOREOFFPENDFtraceEvent = null,
    mali_mali_p_m_m_c_u_h_c_t_l_s_h_a_d_e_r_s_p_e_n_d_o_f_f: ?mali.MaliMaliPMMCUHCTLSHADERSPENDOFFFtraceEvent = null,
    mali_mali_p_m_m_c_u_h_c_t_l_s_h_a_d_e_r_s_p_e_n_d_o_n: ?mali.MaliMaliPMMCUHCTLSHADERSPENDONFtraceEvent = null,
    mali_mali_p_m_m_c_u_h_c_t_l_s_h_a_d_e_r_s_r_e_a_d_y_o_f_f: ?mali.MaliMaliPMMCUHCTLSHADERSREADYOFFFtraceEvent = null,
    mali_mali_p_m_m_c_u_i_n_s_l_e_e_p: ?mali.MaliMaliPMMCUINSLEEPFtraceEvent = null,
    mali_mali_p_m_m_c_u_o_f_f: ?mali.MaliMaliPMMCUOFFFtraceEvent = null,
    mali_mali_p_m_m_c_u_o_n: ?mali.MaliMaliPMMCUONFtraceEvent = null,
    mali_mali_p_m_m_c_u_o_n_c_o_r_e_a_t_t_r_u_p_d_a_t_e_p_e_n_d: ?mali.MaliMaliPMMCUONCOREATTRUPDATEPENDFtraceEvent = null,
    mali_mali_p_m_m_c_u_o_n_g_l_b_r_e_i_n_i_t_p_e_n_d: ?mali.MaliMaliPMMCUONGLBREINITPENDFtraceEvent = null,
    mali_mali_p_m_m_c_u_o_n_h_a_l_t: ?mali.MaliMaliPMMCUONHALTFtraceEvent = null,
    mali_mali_p_m_m_c_u_o_n_h_w_c_n_t_d_i_s_a_b_l_e: ?mali.MaliMaliPMMCUONHWCNTDISABLEFtraceEvent = null,
    mali_mali_p_m_m_c_u_o_n_h_w_c_n_t_e_n_a_b_l_e: ?mali.MaliMaliPMMCUONHWCNTENABLEFtraceEvent = null,
    mali_mali_p_m_m_c_u_o_n_p_e_n_d_h_a_l_t: ?mali.MaliMaliPMMCUONPENDHALTFtraceEvent = null,
    mali_mali_p_m_m_c_u_o_n_p_e_n_d_s_l_e_e_p: ?mali.MaliMaliPMMCUONPENDSLEEPFtraceEvent = null,
    mali_mali_p_m_m_c_u_o_n_s_l_e_e_p_i_n_i_t_i_a_t_e: ?mali.MaliMaliPMMCUONSLEEPINITIATEFtraceEvent = null,
    mali_mali_p_m_m_c_u_p_e_n_d_o_f_f: ?mali.MaliMaliPMMCUPENDOFFFtraceEvent = null,
    mali_mali_p_m_m_c_u_p_e_n_d_o_n_r_e_l_o_a_d: ?mali.MaliMaliPMMCUPENDONRELOADFtraceEvent = null,
    mali_mali_p_m_m_c_u_p_o_w_e_r_d_o_w_n: ?mali.MaliMaliPMMCUPOWERDOWNFtraceEvent = null,
    mali_mali_p_m_m_c_u_r_e_s_e_t_w_a_i_t: ?mali.MaliMaliPMMCURESETWAITFtraceEvent = null,
    bcl_irq_trigger: ?bcl_exynos.BclIrqTriggerFtraceEvent = null,
    kgsl_adreno_cmdbatch_queued: ?kgsl.KgslAdrenoCmdbatchQueuedFtraceEvent = null,
    kgsl_adreno_cmdbatch_submitted: ?kgsl.KgslAdrenoCmdbatchSubmittedFtraceEvent = null,
    kgsl_adreno_cmdbatch_sync: ?kgsl.KgslAdrenoCmdbatchSyncFtraceEvent = null,
    kgsl_adreno_cmdbatch_retired: ?kgsl.KgslAdrenoCmdbatchRetiredFtraceEvent = null,
    pixel_mm_kswapd_wake: ?pixel_mm.PixelMmKswapdWakeFtraceEvent = null,
    pixel_mm_kswapd_done: ?pixel_mm.PixelMmKswapdDoneFtraceEvent = null,
    sched_wakeup_task_attr: ?sched.SchedWakeupTaskAttrFtraceEvent = null,
    devfreq_frequency: ?devfreq.DevfreqFrequencyFtraceEvent = null,
    kprobe_event: ?generic.KprobeEvent = null,
    param_set_value_cpm: ?cpm_trace.ParamSetValueCpmFtraceEvent = null,
    do_sys_open: ?fs.DoSysOpenFtraceEvent = null,
    open_exec: ?fs.OpenExecFtraceEvent = null,
    block_io_start: ?block.BlockIoStartFtraceEvent = null,
    block_io_done: ?block.BlockIoDoneFtraceEvent = null,
    mali_gpu_power_state: ?mali.MaliGpuPowerStateFtraceEvent = null,
    dpu_disp_dpu_underrun: ?dpu.DpuDispDpuUnderrunFtraceEvent = null,
    dpu_disp_vblank_irq_enable: ?dpu.DpuDispVblankIrqEnableFtraceEvent = null,
    hrtimer_start: ?timer.HrtimerStartFtraceEvent = null,
    hrtimer_cancel: ?timer.HrtimerCancelFtraceEvent = null,
    hrtimer_expire_entry: ?timer.HrtimerExpireEntryFtraceEvent = null,
    hrtimer_expire_exit: ?timer.HrtimerExpireExitFtraceEvent = null,
    timer_start: ?timer.TimerStartFtraceEvent = null,
    timer_cancel: ?timer.TimerCancelFtraceEvent = null,
    timer_expire_entry: ?timer.TimerExpireEntryFtraceEvent = null,
    timer_expire_exit: ?timer.TimerExpireExitFtraceEvent = null,
    local_timer_entry: ?irq_vectors.LocalTimerEntryFtraceEvent = null,
    local_timer_exit: ?irq_vectors.LocalTimerExitFtraceEvent = null,
    dwc3_alloc_request: ?dwc3.Dwc3AllocRequestFtraceEvent = null,
    dwc3_complete_trb: ?dwc3.Dwc3CompleteTrbFtraceEvent = null,
    dwc3_ctrl_req: ?dwc3.Dwc3CtrlReqFtraceEvent = null,
    dwc3_ep_dequeue: ?dwc3.Dwc3EpDequeueFtraceEvent = null,
    dwc3_ep_queue: ?dwc3.Dwc3EpQueueFtraceEvent = null,
    dwc3_event: ?dwc3.Dwc3EventFtraceEvent = null,
    dwc3_free_request: ?dwc3.Dwc3FreeRequestFtraceEvent = null,
    dwc3_gadget_ep_cmd: ?dwc3.Dwc3GadgetEpCmdFtraceEvent = null,
    dwc3_gadget_ep_disable: ?dwc3.Dwc3GadgetEpDisableFtraceEvent = null,
    dwc3_gadget_ep_enable: ?dwc3.Dwc3GadgetEpEnableFtraceEvent = null,
    dwc3_gadget_generic_cmd: ?dwc3.Dwc3GadgetGenericCmdFtraceEvent = null,
    dwc3_gadget_giveback: ?dwc3.Dwc3GadgetGivebackFtraceEvent = null,
    dwc3_prepare_trb: ?dwc3.Dwc3PrepareTrbFtraceEvent = null,
    dwc3_readl: ?dwc3.Dwc3ReadlFtraceEvent = null,
    dwc3_writel: ?dwc3.Dwc3WritelFtraceEvent = null,
    cma_alloc_finish: ?cma.CmaAllocFinishFtraceEvent = null,
    mm_alloc_contig_migrate_range_info: ?kmem.MmAllocContigMigrateRangeInfoFtraceEvent = null,
    host_ffa_call: ?hyp.HostFfaCallFtraceEvent = null,
    dmabuf_rss_stat: ?kmem.DmabufRssStatFtraceEvent = null,
    iommu_idmap: ?hyp.IommuIdmapFtraceEvent = null,
    psci_mem_protect: ?hyp.PsciMemProtectFtraceEvent = null,
    hypervisor_host_hcall: ?hypervisor.HypervisorHostHcallFtraceEvent = null,
    hypervisor_host_smc: ?hypervisor.HypervisorHostSmcFtraceEvent = null,
    hypervisor_hyp_exit: ?hypervisor.HypervisorHypExitFtraceEvent = null,
    hypervisor_iommu_idmap: ?hypervisor.HypervisorIommuIdmapFtraceEvent = null,
    hypervisor_psci_mem_protect: ?hypervisor.HypervisorPsciMemProtectFtraceEvent = null,
    hypervisor_host_mem_abort: ?hypervisor.HypervisorHostMemAbortFtraceEvent = null,
    hypervisor_hyp_enter: ?hypervisor.HypervisorHypEnterFtraceEvent = null,
    hypervisor_iommu_idmap_complete: ?hypervisor.HypervisorIommuIdmapCompleteFtraceEvent = null,
    hypervisor_vcpu_illegal_trap: ?hypervisor.HypervisorVcpuIllegalTrapFtraceEvent = null,
    drm_sched_job_add_dep: ?gpu_scheduler.DrmSchedJobAddDepFtraceEvent = null,
    drm_sched_job_done: ?gpu_scheduler.DrmSchedJobDoneFtraceEvent = null,
    drm_sched_job_queue: ?gpu_scheduler.DrmSchedJobQueueFtraceEvent = null,
    drm_sched_job_run: ?gpu_scheduler.DrmSchedJobRunFtraceEvent = null,
    drm_sched_job_unschedulable: ?gpu_scheduler.DrmSchedJobUnschedulableFtraceEvent = null,
    fwtp_perfetto_counter: ?fwtp_ftrace.FwtpPerfettoCounterFtraceEvent = null,
    pub fn calcProtobufSize(self: *const FtraceEvent) usize {
        var res: usize = 0;
        if (self.timestamp != 0) {
            res += gremlin.sizes.sizeWireNumber(FtraceEventWire.TIMESTAMP_WIRE) + gremlin.sizes.sizeU64(self.timestamp);
        }
        if (self.pid != 0) {
            res += gremlin.sizes.sizeWireNumber(FtraceEventWire.PID_WIRE) + gremlin.sizes.sizeU32(self.pid);
        }
        if (self.common_flags != 0) {
            res += gremlin.sizes.sizeWireNumber(FtraceEventWire.COMMON_FLAGS_WIRE) + gremlin.sizes.sizeU32(self.common_flags);
        }
        if (self.print) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.PRINT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.sched_switch) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.SCHED_SWITCH_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cpu_frequency) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.CPU_FREQUENCY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cpu_frequency_limits) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.CPU_FREQUENCY_LIMITS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cpu_idle) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.CPU_IDLE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.clock_enable) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.CLOCK_ENABLE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.clock_disable) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.CLOCK_DISABLE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.clock_set_rate) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.CLOCK_SET_RATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.sched_wakeup) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.SCHED_WAKEUP_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.sched_blocked_reason) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.SCHED_BLOCKED_REASON_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.sched_cpu_hotplug) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.SCHED_CPU_HOTPLUG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.sched_waking) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.SCHED_WAKING_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ipi_entry) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.IPI_ENTRY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ipi_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.IPI_EXIT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ipi_raise) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.IPI_RAISE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.softirq_entry) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.SOFTIRQ_ENTRY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.softirq_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.SOFTIRQ_EXIT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.softirq_raise) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.SOFTIRQ_RAISE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.i2c_read) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.I2C_READ_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.i2c_write) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.I2C_WRITE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.i2c_result) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.I2C_RESULT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.i2c_reply) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.I2C_REPLY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.smbus_read) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.SMBUS_READ_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.smbus_write) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.SMBUS_WRITE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.smbus_result) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.SMBUS_RESULT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.smbus_reply) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.SMBUS_REPLY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.lowmemory_kill) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.LOWMEMORY_KILL_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.irq_handler_entry) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.IRQ_HANDLER_ENTRY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.irq_handler_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.IRQ_HANDLER_EXIT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.sync_pt) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.SYNC_PT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.sync_timeline) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.SYNC_TIMELINE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.sync_wait) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.SYNC_WAIT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_da_write_begin) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_DA_WRITE_BEGIN_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_da_write_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_DA_WRITE_END_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_sync_file_enter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_SYNC_FILE_ENTER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_sync_file_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_SYNC_FILE_EXIT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.block_rq_issue) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.BLOCK_RQ_ISSUE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mm_vmscan_direct_reclaim_begin) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MM_VMSCAN_DIRECT_RECLAIM_BEGIN_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mm_vmscan_direct_reclaim_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MM_VMSCAN_DIRECT_RECLAIM_END_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mm_vmscan_kswapd_wake) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MM_VMSCAN_KSWAPD_WAKE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mm_vmscan_kswapd_sleep) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MM_VMSCAN_KSWAPD_SLEEP_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.binder_transaction) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.BINDER_TRANSACTION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.binder_transaction_received) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.BINDER_TRANSACTION_RECEIVED_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.binder_set_priority) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.BINDER_SET_PRIORITY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.binder_lock) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.BINDER_LOCK_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.binder_locked) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.BINDER_LOCKED_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.binder_unlock) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.BINDER_UNLOCK_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.workqueue_activate_work) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.WORKQUEUE_ACTIVATE_WORK_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.workqueue_execute_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.WORKQUEUE_EXECUTE_END_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.workqueue_execute_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.WORKQUEUE_EXECUTE_START_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.workqueue_queue_work) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.WORKQUEUE_QUEUE_WORK_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.regulator_disable) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.REGULATOR_DISABLE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.regulator_disable_complete) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.REGULATOR_DISABLE_COMPLETE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.regulator_enable) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.REGULATOR_ENABLE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.regulator_enable_complete) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.REGULATOR_ENABLE_COMPLETE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.regulator_enable_delay) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.REGULATOR_ENABLE_DELAY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.regulator_set_voltage) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.REGULATOR_SET_VOLTAGE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.regulator_set_voltage_complete) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.REGULATOR_SET_VOLTAGE_COMPLETE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cgroup_attach_task) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.CGROUP_ATTACH_TASK_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cgroup_mkdir) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.CGROUP_MKDIR_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cgroup_remount) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.CGROUP_REMOUNT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cgroup_rmdir) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.CGROUP_RMDIR_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cgroup_transfer_tasks) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.CGROUP_TRANSFER_TASKS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cgroup_destroy_root) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.CGROUP_DESTROY_ROOT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cgroup_release) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.CGROUP_RELEASE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cgroup_rename) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.CGROUP_RENAME_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cgroup_setup_root) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.CGROUP_SETUP_ROOT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mdp_cmd_kickoff) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MDP_CMD_KICKOFF_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mdp_commit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MDP_COMMIT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mdp_perf_set_ot) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MDP_PERF_SET_OT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mdp_sspp_change) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MDP_SSPP_CHANGE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.tracing_mark_write) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.TRACING_MARK_WRITE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mdp_cmd_pingpong_done) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MDP_CMD_PINGPONG_DONE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mdp_compare_bw) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MDP_COMPARE_BW_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mdp_perf_set_panic_luts) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MDP_PERF_SET_PANIC_LUTS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mdp_sspp_set) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MDP_SSPP_SET_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mdp_cmd_readptr_done) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MDP_CMD_READPTR_DONE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mdp_misr_crc) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MDP_MISR_CRC_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mdp_perf_set_qos_luts) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MDP_PERF_SET_QOS_LUTS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mdp_trace_counter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MDP_TRACE_COUNTER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mdp_cmd_release_bw) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MDP_CMD_RELEASE_BW_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mdp_mixer_update) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MDP_MIXER_UPDATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mdp_perf_set_wm_levels) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MDP_PERF_SET_WM_LEVELS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mdp_video_underrun_done) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MDP_VIDEO_UNDERRUN_DONE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mdp_cmd_wait_pingpong) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MDP_CMD_WAIT_PINGPONG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mdp_perf_prefill_calc) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MDP_PERF_PREFILL_CALC_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mdp_perf_update_bus) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MDP_PERF_UPDATE_BUS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.rotator_bw_ao_as_context) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.ROTATOR_BW_AO_AS_CONTEXT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mm_filemap_add_to_page_cache) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MM_FILEMAP_ADD_TO_PAGE_CACHE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mm_filemap_delete_from_page_cache) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MM_FILEMAP_DELETE_FROM_PAGE_CACHE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mm_compaction_begin) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MM_COMPACTION_BEGIN_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mm_compaction_defer_compaction) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MM_COMPACTION_DEFER_COMPACTION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mm_compaction_deferred) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MM_COMPACTION_DEFERRED_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mm_compaction_defer_reset) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MM_COMPACTION_DEFER_RESET_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mm_compaction_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MM_COMPACTION_END_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mm_compaction_finished) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MM_COMPACTION_FINISHED_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mm_compaction_isolate_freepages) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MM_COMPACTION_ISOLATE_FREEPAGES_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mm_compaction_isolate_migratepages) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MM_COMPACTION_ISOLATE_MIGRATEPAGES_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mm_compaction_kcompactd_sleep) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MM_COMPACTION_KCOMPACTD_SLEEP_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mm_compaction_kcompactd_wake) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MM_COMPACTION_KCOMPACTD_WAKE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mm_compaction_migratepages) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MM_COMPACTION_MIGRATEPAGES_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mm_compaction_suitable) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MM_COMPACTION_SUITABLE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mm_compaction_try_to_compact_pages) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MM_COMPACTION_TRY_TO_COMPACT_PAGES_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mm_compaction_wakeup_kcompactd) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MM_COMPACTION_WAKEUP_KCOMPACTD_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.suspend_resume) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.SUSPEND_RESUME_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.sched_wakeup_new) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.SCHED_WAKEUP_NEW_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.block_bio_backmerge) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.BLOCK_BIO_BACKMERGE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.block_bio_bounce) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.BLOCK_BIO_BOUNCE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.block_bio_complete) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.BLOCK_BIO_COMPLETE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.block_bio_frontmerge) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.BLOCK_BIO_FRONTMERGE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.block_bio_queue) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.BLOCK_BIO_QUEUE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.block_bio_remap) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.BLOCK_BIO_REMAP_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.block_dirty_buffer) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.BLOCK_DIRTY_BUFFER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.block_getrq) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.BLOCK_GETRQ_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.block_plug) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.BLOCK_PLUG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.block_rq_abort) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.BLOCK_RQ_ABORT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.block_rq_complete) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.BLOCK_RQ_COMPLETE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.block_rq_insert) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.BLOCK_RQ_INSERT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.block_rq_remap) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.BLOCK_RQ_REMAP_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.block_rq_requeue) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.BLOCK_RQ_REQUEUE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.block_sleeprq) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.BLOCK_SLEEPRQ_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.block_split) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.BLOCK_SPLIT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.block_touch_buffer) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.BLOCK_TOUCH_BUFFER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.block_unplug) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.BLOCK_UNPLUG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_alloc_da_blocks) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_ALLOC_DA_BLOCKS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_allocate_blocks) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_ALLOCATE_BLOCKS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_allocate_inode) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_ALLOCATE_INODE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_begin_ordered_truncate) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_BEGIN_ORDERED_TRUNCATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_collapse_range) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_COLLAPSE_RANGE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_da_release_space) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_DA_RELEASE_SPACE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_da_reserve_space) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_DA_RESERVE_SPACE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_da_update_reserve_space) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_DA_UPDATE_RESERVE_SPACE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_da_write_pages) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_DA_WRITE_PAGES_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_da_write_pages_extent) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_DA_WRITE_PAGES_EXTENT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_direct_i_o_enter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_DIRECT_IO_ENTER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_direct_i_o_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_DIRECT_IO_EXIT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_discard_blocks) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_DISCARD_BLOCKS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_discard_preallocations) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_DISCARD_PREALLOCATIONS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_drop_inode) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_DROP_INODE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_es_cache_extent) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_ES_CACHE_EXTENT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_es_find_delayed_extent_range_enter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_ES_FIND_DELAYED_EXTENT_RANGE_ENTER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_es_find_delayed_extent_range_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_ES_FIND_DELAYED_EXTENT_RANGE_EXIT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_es_insert_extent) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_ES_INSERT_EXTENT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_es_lookup_extent_enter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_ES_LOOKUP_EXTENT_ENTER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_es_lookup_extent_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_ES_LOOKUP_EXTENT_EXIT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_es_remove_extent) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_ES_REMOVE_EXTENT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_es_shrink) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_ES_SHRINK_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_es_shrink_count) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_ES_SHRINK_COUNT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_es_shrink_scan_enter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_ES_SHRINK_SCAN_ENTER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_es_shrink_scan_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_ES_SHRINK_SCAN_EXIT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_evict_inode) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_EVICT_INODE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_ext_convert_to_initialized_enter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_EXT_CONVERT_TO_INITIALIZED_ENTER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_ext_convert_to_initialized_fastpath) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_EXT_CONVERT_TO_INITIALIZED_FASTPATH_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_ext_handle_unwritten_extents) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_EXT_HANDLE_UNWRITTEN_EXTENTS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_ext_in_cache) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_EXT_IN_CACHE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_ext_load_extent) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_EXT_LOAD_EXTENT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_ext_map_blocks_enter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_EXT_MAP_BLOCKS_ENTER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_ext_map_blocks_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_EXT_MAP_BLOCKS_EXIT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_ext_put_in_cache) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_EXT_PUT_IN_CACHE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_ext_remove_space) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_EXT_REMOVE_SPACE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_ext_remove_space_done) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_EXT_REMOVE_SPACE_DONE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_ext_rm_idx) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_EXT_RM_IDX_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_ext_rm_leaf) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_EXT_RM_LEAF_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_ext_show_extent) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_EXT_SHOW_EXTENT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_fallocate_enter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_FALLOCATE_ENTER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_fallocate_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_FALLOCATE_EXIT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_find_delalloc_range) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_FIND_DELALLOC_RANGE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_forget) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_FORGET_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_free_blocks) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_FREE_BLOCKS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_free_inode) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_FREE_INODE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_get_implied_cluster_alloc_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_GET_IMPLIED_CLUSTER_ALLOC_EXIT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_get_reserved_cluster_alloc) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_GET_RESERVED_CLUSTER_ALLOC_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_ind_map_blocks_enter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_IND_MAP_BLOCKS_ENTER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_ind_map_blocks_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_IND_MAP_BLOCKS_EXIT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_insert_range) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_INSERT_RANGE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_invalidatepage) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_INVALIDATEPAGE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_journal_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_JOURNAL_START_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_journal_start_reserved) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_JOURNAL_START_RESERVED_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_journalled_invalidatepage) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_JOURNALLED_INVALIDATEPAGE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_journalled_write_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_JOURNALLED_WRITE_END_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_load_inode) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_LOAD_INODE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_load_inode_bitmap) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_LOAD_INODE_BITMAP_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_mark_inode_dirty) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_MARK_INODE_DIRTY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_mb_bitmap_load) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_MB_BITMAP_LOAD_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_mb_buddy_bitmap_load) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_MB_BUDDY_BITMAP_LOAD_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_mb_discard_preallocations) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_MB_DISCARD_PREALLOCATIONS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_mb_new_group_pa) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_MB_NEW_GROUP_PA_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_mb_new_inode_pa) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_MB_NEW_INODE_PA_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_mb_release_group_pa) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_MB_RELEASE_GROUP_PA_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_mb_release_inode_pa) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_MB_RELEASE_INODE_PA_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_mballoc_alloc) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_MBALLOC_ALLOC_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_mballoc_discard) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_MBALLOC_DISCARD_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_mballoc_free) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_MBALLOC_FREE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_mballoc_prealloc) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_MBALLOC_PREALLOC_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_other_inode_update_time) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_OTHER_INODE_UPDATE_TIME_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_punch_hole) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_PUNCH_HOLE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_read_block_bitmap_load) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_READ_BLOCK_BITMAP_LOAD_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_readpage) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_READPAGE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_releasepage) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_RELEASEPAGE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_remove_blocks) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_REMOVE_BLOCKS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_request_blocks) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_REQUEST_BLOCKS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_request_inode) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_REQUEST_INODE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_sync_fs) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_SYNC_FS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_trim_all_free) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_TRIM_ALL_FREE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_trim_extent) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_TRIM_EXTENT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_truncate_enter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_TRUNCATE_ENTER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_truncate_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_TRUNCATE_EXIT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_unlink_enter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_UNLINK_ENTER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_unlink_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_UNLINK_EXIT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_write_begin) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_WRITE_BEGIN_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_write_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_WRITE_END_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_writepage) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_WRITEPAGE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_writepages) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_WRITEPAGES_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_writepages_result) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_WRITEPAGES_RESULT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ext4_zero_range) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.EXT4_ZERO_RANGE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.task_newtask) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.TASK_NEWTASK_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.task_rename) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.TASK_RENAME_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.sched_process_exec) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.SCHED_PROCESS_EXEC_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.sched_process_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.SCHED_PROCESS_EXIT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.sched_process_fork) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.SCHED_PROCESS_FORK_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.sched_process_free) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.SCHED_PROCESS_FREE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.sched_process_hang) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.SCHED_PROCESS_HANG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.sched_process_wait) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.SCHED_PROCESS_WAIT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.f2fs_do_submit_bio) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.F2FS_DO_SUBMIT_BIO_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.f2fs_evict_inode) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.F2FS_EVICT_INODE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.f2fs_fallocate) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.F2FS_FALLOCATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.f2fs_get_data_block) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.F2FS_GET_DATA_BLOCK_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.f2fs_get_victim) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.F2FS_GET_VICTIM_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.f2fs_iget) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.F2FS_IGET_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.f2fs_iget_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.F2FS_IGET_EXIT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.f2fs_new_inode) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.F2FS_NEW_INODE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.f2fs_readpage) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.F2FS_READPAGE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.f2fs_reserve_new_block) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.F2FS_RESERVE_NEW_BLOCK_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.f2fs_set_page_dirty) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.F2FS_SET_PAGE_DIRTY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.f2fs_submit_write_page) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.F2FS_SUBMIT_WRITE_PAGE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.f2fs_sync_file_enter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.F2FS_SYNC_FILE_ENTER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.f2fs_sync_file_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.F2FS_SYNC_FILE_EXIT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.f2fs_sync_fs) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.F2FS_SYNC_FS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.f2fs_truncate) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.F2FS_TRUNCATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.f2fs_truncate_blocks_enter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.F2FS_TRUNCATE_BLOCKS_ENTER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.f2fs_truncate_blocks_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.F2FS_TRUNCATE_BLOCKS_EXIT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.f2fs_truncate_data_blocks_range) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.F2FS_TRUNCATE_DATA_BLOCKS_RANGE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.f2fs_truncate_inode_blocks_enter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.F2FS_TRUNCATE_INODE_BLOCKS_ENTER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.f2fs_truncate_inode_blocks_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.F2FS_TRUNCATE_INODE_BLOCKS_EXIT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.f2fs_truncate_node) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.F2FS_TRUNCATE_NODE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.f2fs_truncate_nodes_enter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.F2FS_TRUNCATE_NODES_ENTER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.f2fs_truncate_nodes_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.F2FS_TRUNCATE_NODES_EXIT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.f2fs_truncate_partial_nodes) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.F2FS_TRUNCATE_PARTIAL_NODES_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.f2fs_unlink_enter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.F2FS_UNLINK_ENTER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.f2fs_unlink_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.F2FS_UNLINK_EXIT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.f2fs_vm_page_mkwrite) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.F2FS_VM_PAGE_MKWRITE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.f2fs_write_begin) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.F2FS_WRITE_BEGIN_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.f2fs_write_checkpoint) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.F2FS_WRITE_CHECKPOINT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.f2fs_write_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.F2FS_WRITE_END_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.alloc_pages_iommu_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.ALLOC_PAGES_IOMMU_END_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.alloc_pages_iommu_fail) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.ALLOC_PAGES_IOMMU_FAIL_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.alloc_pages_iommu_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.ALLOC_PAGES_IOMMU_START_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.alloc_pages_sys_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.ALLOC_PAGES_SYS_END_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.alloc_pages_sys_fail) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.ALLOC_PAGES_SYS_FAIL_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.alloc_pages_sys_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.ALLOC_PAGES_SYS_START_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.dma_alloc_contiguous_retry) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DMA_ALLOC_CONTIGUOUS_RETRY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.iommu_map_range) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.IOMMU_MAP_RANGE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.iommu_sec_ptbl_map_range_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.IOMMU_SEC_PTBL_MAP_RANGE_END_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.iommu_sec_ptbl_map_range_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.IOMMU_SEC_PTBL_MAP_RANGE_START_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ion_alloc_buffer_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.ION_ALLOC_BUFFER_END_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ion_alloc_buffer_fail) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.ION_ALLOC_BUFFER_FAIL_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ion_alloc_buffer_fallback) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.ION_ALLOC_BUFFER_FALLBACK_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ion_alloc_buffer_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.ION_ALLOC_BUFFER_START_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ion_cp_alloc_retry) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.ION_CP_ALLOC_RETRY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ion_cp_secure_buffer_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.ION_CP_SECURE_BUFFER_END_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ion_cp_secure_buffer_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.ION_CP_SECURE_BUFFER_START_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ion_prefetching) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.ION_PREFETCHING_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ion_secure_cma_add_to_pool_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.ION_SECURE_CMA_ADD_TO_POOL_END_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ion_secure_cma_add_to_pool_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.ION_SECURE_CMA_ADD_TO_POOL_START_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ion_secure_cma_allocate_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.ION_SECURE_CMA_ALLOCATE_END_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ion_secure_cma_allocate_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.ION_SECURE_CMA_ALLOCATE_START_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ion_secure_cma_shrink_pool_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.ION_SECURE_CMA_SHRINK_POOL_END_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ion_secure_cma_shrink_pool_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.ION_SECURE_CMA_SHRINK_POOL_START_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kfree) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KFREE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kmalloc) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KMALLOC_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kmalloc_node) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KMALLOC_NODE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kmem_cache_alloc) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KMEM_CACHE_ALLOC_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kmem_cache_alloc_node) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KMEM_CACHE_ALLOC_NODE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kmem_cache_free) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KMEM_CACHE_FREE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.migrate_pages_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MIGRATE_PAGES_END_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.migrate_pages_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MIGRATE_PAGES_START_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.migrate_retry) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MIGRATE_RETRY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mm_page_alloc) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MM_PAGE_ALLOC_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mm_page_alloc_extfrag) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MM_PAGE_ALLOC_EXTFRAG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mm_page_alloc_zone_locked) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MM_PAGE_ALLOC_ZONE_LOCKED_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mm_page_free) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MM_PAGE_FREE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mm_page_free_batched) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MM_PAGE_FREE_BATCHED_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mm_page_pcpu_drain) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MM_PAGE_PCPU_DRAIN_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.rss_stat) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.RSS_STAT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ion_heap_shrink) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.ION_HEAP_SHRINK_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ion_heap_grow) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.ION_HEAP_GROW_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.fence_init) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.FENCE_INIT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.fence_destroy) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.FENCE_DESTROY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.fence_enable_signal) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.FENCE_ENABLE_SIGNAL_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.fence_signaled) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.FENCE_SIGNALED_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.clk_enable) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.CLK_ENABLE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.clk_disable) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.CLK_DISABLE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.clk_set_rate) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.CLK_SET_RATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.binder_transaction_alloc_buf) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.BINDER_TRANSACTION_ALLOC_BUF_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.signal_deliver) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.SIGNAL_DELIVER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.signal_generate) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.SIGNAL_GENERATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.oom_score_adj_update) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.OOM_SCORE_ADJ_UPDATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.generic) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.GENERIC_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mm_event_record) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MM_EVENT_RECORD_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.sys_enter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.SYS_ENTER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.sys_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.SYS_EXIT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.zero) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.ZERO_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.gpu_frequency) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.GPU_FREQUENCY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.sde_tracing_mark_write) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.SDE_TRACING_MARK_WRITE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mark_victim) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MARK_VICTIM_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ion_stat) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.ION_STAT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ion_buffer_create) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.ION_BUFFER_CREATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ion_buffer_destroy) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.ION_BUFFER_DESTROY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.scm_call_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.SCM_CALL_START_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.scm_call_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.SCM_CALL_END_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.gpu_mem_total) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.GPU_MEM_TOTAL_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.thermal_temperature) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.THERMAL_TEMPERATURE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cdev_update) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.CDEV_UPDATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cpuhp_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.CPUHP_EXIT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cpuhp_multi_enter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.CPUHP_MULTI_ENTER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cpuhp_enter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.CPUHP_ENTER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cpuhp_latency) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.CPUHP_LATENCY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.fastrpc_dma_stat) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.FASTRPC_DMA_STAT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.dpu_tracing_mark_write) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DPU_TRACING_MARK_WRITE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.g2d_tracing_mark_write) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.G2D_TRACING_MARK_WRITE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mali_tracing_mark_write) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MALI_TRACING_MARK_WRITE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.dma_heap_stat) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DMA_HEAP_STAT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cpuhp_pause) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.CPUHP_PAUSE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.sched_pi_setprio) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.SCHED_PI_SETPRIO_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.sde_sde_evtlog) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.SDE_SDE_EVTLOG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.sde_sde_perf_calc_crtc) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.SDE_SDE_PERF_CALC_CRTC_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.sde_sde_perf_crtc_update) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.SDE_SDE_PERF_CRTC_UPDATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.sde_sde_perf_set_qos_luts) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.SDE_SDE_PERF_SET_QOS_LUTS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.sde_sde_perf_update_bus) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.SDE_SDE_PERF_UPDATE_BUS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.rss_stat_throttled) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.RSS_STAT_THROTTLED_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.netif_receive_skb) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.NETIF_RECEIVE_SKB_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.net_dev_xmit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.NET_DEV_XMIT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.inet_sock_set_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.INET_SOCK_SET_STATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.tcp_retransmit_skb) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.TCP_RETRANSMIT_SKB_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cros_ec_sensorhub_data) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.CROS_EC_SENSORHUB_DATA_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.napi_gro_receive_entry) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.NAPI_GRO_RECEIVE_ENTRY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.napi_gro_receive_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.NAPI_GRO_RECEIVE_EXIT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kfree_skb) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KFREE_SKB_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kvm_access_fault) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KVM_ACCESS_FAULT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kvm_ack_irq) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KVM_ACK_IRQ_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kvm_age_hva) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KVM_AGE_HVA_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kvm_age_page) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KVM_AGE_PAGE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kvm_arm_clear_debug) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KVM_ARM_CLEAR_DEBUG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kvm_arm_set_dreg32) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KVM_ARM_SET_DREG32_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kvm_arm_set_regset) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KVM_ARM_SET_REGSET_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kvm_arm_setup_debug) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KVM_ARM_SETUP_DEBUG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kvm_entry) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KVM_ENTRY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kvm_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KVM_EXIT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kvm_fpu) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KVM_FPU_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kvm_get_timer_map) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KVM_GET_TIMER_MAP_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kvm_guest_fault) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KVM_GUEST_FAULT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kvm_handle_sys_reg) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KVM_HANDLE_SYS_REG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kvm_hvc_arm64) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KVM_HVC_ARM64_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kvm_irq_line) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KVM_IRQ_LINE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kvm_mmio) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KVM_MMIO_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kvm_mmio_emulate) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KVM_MMIO_EMULATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kvm_set_guest_debug) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KVM_SET_GUEST_DEBUG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kvm_set_irq) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KVM_SET_IRQ_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kvm_set_spte_hva) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KVM_SET_SPTE_HVA_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kvm_set_way_flush) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KVM_SET_WAY_FLUSH_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kvm_sys_access) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KVM_SYS_ACCESS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kvm_test_age_hva) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KVM_TEST_AGE_HVA_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kvm_timer_emulate) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KVM_TIMER_EMULATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kvm_timer_hrtimer_expire) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KVM_TIMER_HRTIMER_EXPIRE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kvm_timer_restore_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KVM_TIMER_RESTORE_STATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kvm_timer_save_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KVM_TIMER_SAVE_STATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kvm_timer_update_irq) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KVM_TIMER_UPDATE_IRQ_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kvm_toggle_cache) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KVM_TOGGLE_CACHE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kvm_unmap_hva_range) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KVM_UNMAP_HVA_RANGE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kvm_userspace_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KVM_USERSPACE_EXIT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kvm_vcpu_wakeup) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KVM_VCPU_WAKEUP_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kvm_wfx_arm64) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KVM_WFX_ARM64_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.trap_reg) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.TRAP_REG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.vgic_update_irq_pending) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.VGIC_UPDATE_IRQ_PENDING_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.wakeup_source_activate) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.WAKEUP_SOURCE_ACTIVATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.wakeup_source_deactivate) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.WAKEUP_SOURCE_DEACTIVATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ufshcd_command) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.UFSHCD_COMMAND_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ufshcd_clk_gating) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.UFSHCD_CLK_GATING_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.console) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.CONSOLE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.drm_vblank_event) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DRM_VBLANK_EVENT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.drm_vblank_event_delivered) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DRM_VBLANK_EVENT_DELIVERED_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.drm_sched_job) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DRM_SCHED_JOB_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.drm_run_job) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DRM_RUN_JOB_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.drm_sched_process_job) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DRM_SCHED_PROCESS_JOB_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.dma_fence_init) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DMA_FENCE_INIT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.dma_fence_emit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DMA_FENCE_EMIT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.dma_fence_signaled) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DMA_FENCE_SIGNALED_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.dma_fence_wait_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DMA_FENCE_WAIT_START_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.dma_fence_wait_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DMA_FENCE_WAIT_END_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.f2fs_iostat) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.F2FS_IOSTAT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.f2fs_iostat_latency) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.F2FS_IOSTAT_LATENCY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.sched_cpu_util_cfs) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.SCHED_CPU_UTIL_CFS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.v4l2_qbuf) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.V4L2_QBUF_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.v4l2_dqbuf) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.V4L2_DQBUF_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.vb2_v4l2_buf_queue) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.VB2_V4L2_BUF_QUEUE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.vb2_v4l2_buf_done) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.VB2_V4L2_BUF_DONE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.vb2_v4l2_qbuf) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.VB2_V4L2_QBUF_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.vb2_v4l2_dqbuf) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.VB2_V4L2_DQBUF_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.dsi_cmd_fifo_status) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DSI_CMD_FIFO_STATUS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.dsi_rx) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DSI_RX_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.dsi_tx) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DSI_TX_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_fs_dataread_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.ANDROID_FS_DATAREAD_END_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_fs_dataread_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.ANDROID_FS_DATAREAD_START_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_fs_datawrite_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.ANDROID_FS_DATAWRITE_END_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_fs_datawrite_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.ANDROID_FS_DATAWRITE_START_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_fs_fsync_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.ANDROID_FS_FSYNC_END_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_fs_fsync_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.ANDROID_FS_FSYNC_START_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.funcgraph_entry) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.FUNCGRAPH_ENTRY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.funcgraph_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.FUNCGRAPH_EXIT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.virtio_video_cmd) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.VIRTIO_VIDEO_CMD_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.virtio_video_cmd_done) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.VIRTIO_VIDEO_CMD_DONE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.virtio_video_resource_queue) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.VIRTIO_VIDEO_RESOURCE_QUEUE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.virtio_video_resource_queue_done) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.VIRTIO_VIDEO_RESOURCE_QUEUE_DONE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mm_shrink_slab_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MM_SHRINK_SLAB_START_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mm_shrink_slab_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MM_SHRINK_SLAB_END_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.trusty_smc) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.TRUSTY_SMC_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.trusty_smc_done) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.TRUSTY_SMC_DONE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.trusty_std_call32) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.TRUSTY_STD_CALL32_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.trusty_std_call32_done) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.TRUSTY_STD_CALL32_DONE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.trusty_share_memory) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.TRUSTY_SHARE_MEMORY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.trusty_share_memory_done) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.TRUSTY_SHARE_MEMORY_DONE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.trusty_reclaim_memory) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.TRUSTY_RECLAIM_MEMORY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.trusty_reclaim_memory_done) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.TRUSTY_RECLAIM_MEMORY_DONE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.trusty_irq) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.TRUSTY_IRQ_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.trusty_ipc_handle_event) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.TRUSTY_IPC_HANDLE_EVENT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.trusty_ipc_connect) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.TRUSTY_IPC_CONNECT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.trusty_ipc_connect_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.TRUSTY_IPC_CONNECT_END_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.trusty_ipc_write) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.TRUSTY_IPC_WRITE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.trusty_ipc_poll) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.TRUSTY_IPC_POLL_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.trusty_ipc_read) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.TRUSTY_IPC_READ_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.trusty_ipc_read_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.TRUSTY_IPC_READ_END_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.trusty_ipc_rx) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.TRUSTY_IPC_RX_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.trusty_enqueue_nop) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.TRUSTY_ENQUEUE_NOP_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cma_alloc_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.CMA_ALLOC_START_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cma_alloc_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.CMA_ALLOC_INFO_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.lwis_tracing_mark_write) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.LWIS_TRACING_MARK_WRITE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.virtio_gpu_cmd_queue) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.VIRTIO_GPU_CMD_QUEUE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.virtio_gpu_cmd_response) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.VIRTIO_GPU_CMD_RESPONSE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mali_mali_k_c_p_u_c_q_s_s_e_t) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MALI_MALI_KCPU_CQS_SETWIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mali_mali_k_c_p_u_c_q_s_w_a_i_t_s_t_a_r_t) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MALI_MALI_KCPU_CQS_WAIT_STARTWIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mali_mali_k_c_p_u_c_q_s_w_a_i_t_e_n_d) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MALI_MALI_KCPU_CQS_WAIT_ENDWIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mali_mali_k_c_p_u_f_e_n_c_e_s_i_g_n_a_l) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MALI_MALI_KCPU_FENCE_SIGNALWIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mali_mali_k_c_p_u_f_e_n_c_e_w_a_i_t_s_t_a_r_t) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MALI_MALI_KCPU_FENCE_WAIT_STARTWIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mali_mali_k_c_p_u_f_e_n_c_e_w_a_i_t_e_n_d) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MALI_MALI_KCPU_FENCE_WAIT_ENDWIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.hyp_enter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.HYP_ENTER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.hyp_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.HYP_EXIT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.host_hcall) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.HOST_HCALL_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.host_smc) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.HOST_SMC_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.host_mem_abort) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.HOST_MEM_ABORT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.suspend_resume_minimal) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.SUSPEND_RESUME_MINIMAL_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mali_mali_c_s_f_i_n_t_e_r_r_u_p_t_s_t_a_r_t) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MALI_MALI_CSF_INTERRUPT_STARTWIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mali_mali_c_s_f_i_n_t_e_r_r_u_p_t_e_n_d) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MALI_MALI_CSF_INTERRUPT_ENDWIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.samsung_tracing_mark_write) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.SAMSUNG_TRACING_MARK_WRITE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.binder_command) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.BINDER_COMMAND_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.binder_return) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.BINDER_RETURN_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.sched_switch_with_ctrs) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.SCHED_SWITCH_WITH_CTRS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.gpu_work_period) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.GPU_WORK_PERIOD_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.rpm_status) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.RPM_STATUS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.panel_write_generic) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.PANEL_WRITE_GENERIC_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.sched_migrate_task) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.SCHED_MIGRATE_TASK_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.dpu_dsi_cmd_fifo_status) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DPU_DSI_CMD_FIFO_STATUS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.dpu_dsi_rx) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DPU_DSI_RX_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.dpu_dsi_tx) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DPU_DSI_TX_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.f2fs_background_gc) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.F2FS_BACKGROUND_GC_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.f2fs_gc_begin) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.F2FS_GC_BEGIN_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.f2fs_gc_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.F2FS_GC_END_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.fastrpc_dma_free) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.FASTRPC_DMA_FREE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.fastrpc_dma_alloc) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.FASTRPC_DMA_ALLOC_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.fastrpc_dma_unmap) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.FASTRPC_DMA_UNMAP_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.fastrpc_dma_map) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.FASTRPC_DMA_MAP_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.google_icc_event) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.GOOGLE_ICC_EVENT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.google_irm_event) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.GOOGLE_IRM_EVENT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.device_pm_callback_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DEVICE_PM_CALLBACK_START_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.device_pm_callback_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DEVICE_PM_CALLBACK_END_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.thermal_exynos_acpm_bulk) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.THERMAL_EXYNOS_ACPM_BULK_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.thermal_exynos_acpm_high_overhead) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.THERMAL_EXYNOS_ACPM_HIGH_OVERHEAD_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.dcvsh_freq) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DCVSH_FREQ_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kgsl_gpu_frequency) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KGSL_GPU_FREQUENCY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mali_mali_p_m_m_c_u_h_c_t_l_c_o_r_e_s_d_o_w_n_s_c_a_l_e_n_o_t_i_f_y_p_e_n_d) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MALI_MALI_PM_MCU_HCTL_CORES_DOWN_SCALE_NOTIFY_PENDWIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mali_mali_p_m_m_c_u_h_c_t_l_c_o_r_e_s_n_o_t_i_f_y_p_e_n_d) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MALI_MALI_PM_MCU_HCTL_CORES_NOTIFY_PENDWIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mali_mali_p_m_m_c_u_h_c_t_l_c_o_r_e_i_n_a_c_t_i_v_e_p_e_n_d) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MALI_MALI_PM_MCU_HCTL_CORE_INACTIVE_PENDWIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mali_mali_p_m_m_c_u_h_c_t_l_m_c_u_o_n_r_e_c_h_e_c_k) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MALI_MALI_PM_MCU_HCTL_MCU_ON_RECHECKWIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mali_mali_p_m_m_c_u_h_c_t_l_s_h_a_d_e_r_s_c_o_r_e_o_f_f_p_e_n_d) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MALI_MALI_PM_MCU_HCTL_SHADERS_CORE_OFF_PENDWIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mali_mali_p_m_m_c_u_h_c_t_l_s_h_a_d_e_r_s_p_e_n_d_o_f_f) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MALI_MALI_PM_MCU_HCTL_SHADERS_PEND_OFFWIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mali_mali_p_m_m_c_u_h_c_t_l_s_h_a_d_e_r_s_p_e_n_d_o_n) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MALI_MALI_PM_MCU_HCTL_SHADERS_PEND_ONWIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mali_mali_p_m_m_c_u_h_c_t_l_s_h_a_d_e_r_s_r_e_a_d_y_o_f_f) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MALI_MALI_PM_MCU_HCTL_SHADERS_READY_OFFWIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mali_mali_p_m_m_c_u_i_n_s_l_e_e_p) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MALI_MALI_PM_MCU_IN_SLEEPWIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mali_mali_p_m_m_c_u_o_f_f) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MALI_MALI_PM_MCU_OFFWIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mali_mali_p_m_m_c_u_o_n) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MALI_MALI_PM_MCU_ONWIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mali_mali_p_m_m_c_u_o_n_c_o_r_e_a_t_t_r_u_p_d_a_t_e_p_e_n_d) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MALI_MALI_PM_MCU_ON_CORE_ATTR_UPDATE_PENDWIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mali_mali_p_m_m_c_u_o_n_g_l_b_r_e_i_n_i_t_p_e_n_d) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MALI_MALI_PM_MCU_ON_GLB_REINIT_PENDWIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mali_mali_p_m_m_c_u_o_n_h_a_l_t) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MALI_MALI_PM_MCU_ON_HALTWIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mali_mali_p_m_m_c_u_o_n_h_w_c_n_t_d_i_s_a_b_l_e) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MALI_MALI_PM_MCU_ON_HWCNT_DISABLEWIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mali_mali_p_m_m_c_u_o_n_h_w_c_n_t_e_n_a_b_l_e) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MALI_MALI_PM_MCU_ON_HWCNT_ENABLEWIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mali_mali_p_m_m_c_u_o_n_p_e_n_d_h_a_l_t) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MALI_MALI_PM_MCU_ON_PEND_HALTWIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mali_mali_p_m_m_c_u_o_n_p_e_n_d_s_l_e_e_p) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MALI_MALI_PM_MCU_ON_PEND_SLEEPWIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mali_mali_p_m_m_c_u_o_n_s_l_e_e_p_i_n_i_t_i_a_t_e) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MALI_MALI_PM_MCU_ON_SLEEP_INITIATEWIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mali_mali_p_m_m_c_u_p_e_n_d_o_f_f) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MALI_MALI_PM_MCU_PEND_OFFWIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mali_mali_p_m_m_c_u_p_e_n_d_o_n_r_e_l_o_a_d) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MALI_MALI_PM_MCU_PEND_ON_RELOADWIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mali_mali_p_m_m_c_u_p_o_w_e_r_d_o_w_n) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MALI_MALI_PM_MCU_POWER_DOWNWIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mali_mali_p_m_m_c_u_r_e_s_e_t_w_a_i_t) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MALI_MALI_PM_MCU_RESET_WAITWIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.bcl_irq_trigger) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.BCL_IRQ_TRIGGER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kgsl_adreno_cmdbatch_queued) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KGSL_ADRENO_CMDBATCH_QUEUED_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kgsl_adreno_cmdbatch_submitted) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KGSL_ADRENO_CMDBATCH_SUBMITTED_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kgsl_adreno_cmdbatch_sync) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KGSL_ADRENO_CMDBATCH_SYNC_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kgsl_adreno_cmdbatch_retired) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KGSL_ADRENO_CMDBATCH_RETIRED_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.pixel_mm_kswapd_wake) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.PIXEL_MM_KSWAPD_WAKE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.pixel_mm_kswapd_done) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.PIXEL_MM_KSWAPD_DONE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.sched_wakeup_task_attr) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.SCHED_WAKEUP_TASK_ATTR_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.devfreq_frequency) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DEVFREQ_FREQUENCY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kprobe_event) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.KPROBE_EVENT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.param_set_value_cpm) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.PARAM_SET_VALUE_CPM_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.do_sys_open) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DO_SYS_OPEN_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.open_exec) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.OPEN_EXEC_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.block_io_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.BLOCK_IO_START_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.block_io_done) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.BLOCK_IO_DONE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mali_gpu_power_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MALI_GPU_POWER_STATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.dpu_disp_dpu_underrun) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DPU_DISP_DPU_UNDERRUN_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.dpu_disp_vblank_irq_enable) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DPU_DISP_VBLANK_IRQ_ENABLE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.hrtimer_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.HRTIMER_START_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.hrtimer_cancel) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.HRTIMER_CANCEL_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.hrtimer_expire_entry) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.HRTIMER_EXPIRE_ENTRY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.hrtimer_expire_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.HRTIMER_EXPIRE_EXIT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.timer_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.TIMER_START_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.timer_cancel) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.TIMER_CANCEL_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.timer_expire_entry) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.TIMER_EXPIRE_ENTRY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.timer_expire_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.TIMER_EXPIRE_EXIT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.local_timer_entry) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.LOCAL_TIMER_ENTRY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.local_timer_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.LOCAL_TIMER_EXIT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.dwc3_alloc_request) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DWC3_ALLOC_REQUEST_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.dwc3_complete_trb) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DWC3_COMPLETE_TRB_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.dwc3_ctrl_req) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DWC3_CTRL_REQ_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.dwc3_ep_dequeue) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DWC3_EP_DEQUEUE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.dwc3_ep_queue) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DWC3_EP_QUEUE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.dwc3_event) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DWC3_EVENT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.dwc3_free_request) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DWC3_FREE_REQUEST_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.dwc3_gadget_ep_cmd) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DWC3_GADGET_EP_CMD_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.dwc3_gadget_ep_disable) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DWC3_GADGET_EP_DISABLE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.dwc3_gadget_ep_enable) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DWC3_GADGET_EP_ENABLE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.dwc3_gadget_generic_cmd) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DWC3_GADGET_GENERIC_CMD_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.dwc3_gadget_giveback) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DWC3_GADGET_GIVEBACK_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.dwc3_prepare_trb) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DWC3_PREPARE_TRB_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.dwc3_readl) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DWC3_READL_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.dwc3_writel) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DWC3_WRITEL_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cma_alloc_finish) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.CMA_ALLOC_FINISH_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.mm_alloc_contig_migrate_range_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.MM_ALLOC_CONTIG_MIGRATE_RANGE_INFO_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.host_ffa_call) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.HOST_FFA_CALL_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.dmabuf_rss_stat) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DMABUF_RSS_STAT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.iommu_idmap) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.IOMMU_IDMAP_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.psci_mem_protect) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.PSCI_MEM_PROTECT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.hypervisor_host_hcall) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.HYPERVISOR_HOST_HCALL_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.hypervisor_host_smc) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.HYPERVISOR_HOST_SMC_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.hypervisor_hyp_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.HYPERVISOR_HYP_EXIT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.hypervisor_iommu_idmap) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.HYPERVISOR_IOMMU_IDMAP_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.hypervisor_psci_mem_protect) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.HYPERVISOR_PSCI_MEM_PROTECT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.hypervisor_host_mem_abort) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.HYPERVISOR_HOST_MEM_ABORT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.hypervisor_hyp_enter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.HYPERVISOR_HYP_ENTER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.hypervisor_iommu_idmap_complete) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.HYPERVISOR_IOMMU_IDMAP_COMPLETE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.hypervisor_vcpu_illegal_trap) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.HYPERVISOR_VCPU_ILLEGAL_TRAP_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.drm_sched_job_add_dep) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DRM_SCHED_JOB_ADD_DEP_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.drm_sched_job_done) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DRM_SCHED_JOB_DONE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.drm_sched_job_queue) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DRM_SCHED_JOB_QUEUE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.drm_sched_job_run) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DRM_SCHED_JOB_RUN_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.drm_sched_job_unschedulable) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.DRM_SCHED_JOB_UNSCHEDULABLE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.fwtp_perfetto_counter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventWire.FWTP_PERFETTO_COUNTER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const FtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const FtraceEvent, target: *gremlin.Writer) void {
        if (self.timestamp != 0) {
            target.appendUint64(FtraceEventWire.TIMESTAMP_WIRE, self.timestamp);
        }
        if (self.pid != 0) {
            target.appendUint32(FtraceEventWire.PID_WIRE, self.pid);
        }
        if (self.common_flags != 0) {
            target.appendUint32(FtraceEventWire.COMMON_FLAGS_WIRE, self.common_flags);
        }
        if (self.print) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.PRINT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.sched_switch) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.SCHED_SWITCH_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cpu_frequency) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.CPU_FREQUENCY_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cpu_frequency_limits) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.CPU_FREQUENCY_LIMITS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cpu_idle) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.CPU_IDLE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.clock_enable) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.CLOCK_ENABLE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.clock_disable) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.CLOCK_DISABLE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.clock_set_rate) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.CLOCK_SET_RATE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.sched_wakeup) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.SCHED_WAKEUP_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.sched_blocked_reason) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.SCHED_BLOCKED_REASON_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.sched_cpu_hotplug) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.SCHED_CPU_HOTPLUG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.sched_waking) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.SCHED_WAKING_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ipi_entry) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.IPI_ENTRY_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ipi_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.IPI_EXIT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ipi_raise) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.IPI_RAISE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.softirq_entry) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.SOFTIRQ_ENTRY_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.softirq_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.SOFTIRQ_EXIT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.softirq_raise) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.SOFTIRQ_RAISE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.i2c_read) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.I2C_READ_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.i2c_write) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.I2C_WRITE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.i2c_result) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.I2C_RESULT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.i2c_reply) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.I2C_REPLY_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.smbus_read) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.SMBUS_READ_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.smbus_write) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.SMBUS_WRITE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.smbus_result) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.SMBUS_RESULT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.smbus_reply) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.SMBUS_REPLY_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.lowmemory_kill) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.LOWMEMORY_KILL_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.irq_handler_entry) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.IRQ_HANDLER_ENTRY_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.irq_handler_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.IRQ_HANDLER_EXIT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.sync_pt) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.SYNC_PT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.sync_timeline) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.SYNC_TIMELINE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.sync_wait) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.SYNC_WAIT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_da_write_begin) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_DA_WRITE_BEGIN_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_da_write_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_DA_WRITE_END_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_sync_file_enter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_SYNC_FILE_ENTER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_sync_file_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_SYNC_FILE_EXIT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.block_rq_issue) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.BLOCK_RQ_ISSUE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mm_vmscan_direct_reclaim_begin) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MM_VMSCAN_DIRECT_RECLAIM_BEGIN_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mm_vmscan_direct_reclaim_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MM_VMSCAN_DIRECT_RECLAIM_END_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mm_vmscan_kswapd_wake) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MM_VMSCAN_KSWAPD_WAKE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mm_vmscan_kswapd_sleep) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MM_VMSCAN_KSWAPD_SLEEP_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.binder_transaction) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.BINDER_TRANSACTION_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.binder_transaction_received) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.BINDER_TRANSACTION_RECEIVED_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.binder_set_priority) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.BINDER_SET_PRIORITY_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.binder_lock) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.BINDER_LOCK_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.binder_locked) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.BINDER_LOCKED_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.binder_unlock) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.BINDER_UNLOCK_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.workqueue_activate_work) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.WORKQUEUE_ACTIVATE_WORK_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.workqueue_execute_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.WORKQUEUE_EXECUTE_END_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.workqueue_execute_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.WORKQUEUE_EXECUTE_START_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.workqueue_queue_work) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.WORKQUEUE_QUEUE_WORK_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.regulator_disable) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.REGULATOR_DISABLE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.regulator_disable_complete) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.REGULATOR_DISABLE_COMPLETE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.regulator_enable) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.REGULATOR_ENABLE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.regulator_enable_complete) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.REGULATOR_ENABLE_COMPLETE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.regulator_enable_delay) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.REGULATOR_ENABLE_DELAY_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.regulator_set_voltage) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.REGULATOR_SET_VOLTAGE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.regulator_set_voltage_complete) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.REGULATOR_SET_VOLTAGE_COMPLETE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cgroup_attach_task) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.CGROUP_ATTACH_TASK_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cgroup_mkdir) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.CGROUP_MKDIR_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cgroup_remount) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.CGROUP_REMOUNT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cgroup_rmdir) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.CGROUP_RMDIR_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cgroup_transfer_tasks) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.CGROUP_TRANSFER_TASKS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cgroup_destroy_root) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.CGROUP_DESTROY_ROOT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cgroup_release) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.CGROUP_RELEASE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cgroup_rename) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.CGROUP_RENAME_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cgroup_setup_root) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.CGROUP_SETUP_ROOT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mdp_cmd_kickoff) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MDP_CMD_KICKOFF_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mdp_commit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MDP_COMMIT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mdp_perf_set_ot) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MDP_PERF_SET_OT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mdp_sspp_change) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MDP_SSPP_CHANGE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.tracing_mark_write) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.TRACING_MARK_WRITE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mdp_cmd_pingpong_done) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MDP_CMD_PINGPONG_DONE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mdp_compare_bw) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MDP_COMPARE_BW_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mdp_perf_set_panic_luts) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MDP_PERF_SET_PANIC_LUTS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mdp_sspp_set) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MDP_SSPP_SET_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mdp_cmd_readptr_done) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MDP_CMD_READPTR_DONE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mdp_misr_crc) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MDP_MISR_CRC_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mdp_perf_set_qos_luts) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MDP_PERF_SET_QOS_LUTS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mdp_trace_counter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MDP_TRACE_COUNTER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mdp_cmd_release_bw) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MDP_CMD_RELEASE_BW_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mdp_mixer_update) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MDP_MIXER_UPDATE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mdp_perf_set_wm_levels) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MDP_PERF_SET_WM_LEVELS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mdp_video_underrun_done) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MDP_VIDEO_UNDERRUN_DONE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mdp_cmd_wait_pingpong) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MDP_CMD_WAIT_PINGPONG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mdp_perf_prefill_calc) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MDP_PERF_PREFILL_CALC_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mdp_perf_update_bus) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MDP_PERF_UPDATE_BUS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.rotator_bw_ao_as_context) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.ROTATOR_BW_AO_AS_CONTEXT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mm_filemap_add_to_page_cache) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MM_FILEMAP_ADD_TO_PAGE_CACHE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mm_filemap_delete_from_page_cache) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MM_FILEMAP_DELETE_FROM_PAGE_CACHE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mm_compaction_begin) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MM_COMPACTION_BEGIN_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mm_compaction_defer_compaction) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MM_COMPACTION_DEFER_COMPACTION_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mm_compaction_deferred) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MM_COMPACTION_DEFERRED_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mm_compaction_defer_reset) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MM_COMPACTION_DEFER_RESET_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mm_compaction_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MM_COMPACTION_END_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mm_compaction_finished) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MM_COMPACTION_FINISHED_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mm_compaction_isolate_freepages) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MM_COMPACTION_ISOLATE_FREEPAGES_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mm_compaction_isolate_migratepages) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MM_COMPACTION_ISOLATE_MIGRATEPAGES_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mm_compaction_kcompactd_sleep) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MM_COMPACTION_KCOMPACTD_SLEEP_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mm_compaction_kcompactd_wake) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MM_COMPACTION_KCOMPACTD_WAKE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mm_compaction_migratepages) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MM_COMPACTION_MIGRATEPAGES_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mm_compaction_suitable) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MM_COMPACTION_SUITABLE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mm_compaction_try_to_compact_pages) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MM_COMPACTION_TRY_TO_COMPACT_PAGES_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mm_compaction_wakeup_kcompactd) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MM_COMPACTION_WAKEUP_KCOMPACTD_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.suspend_resume) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.SUSPEND_RESUME_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.sched_wakeup_new) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.SCHED_WAKEUP_NEW_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.block_bio_backmerge) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.BLOCK_BIO_BACKMERGE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.block_bio_bounce) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.BLOCK_BIO_BOUNCE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.block_bio_complete) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.BLOCK_BIO_COMPLETE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.block_bio_frontmerge) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.BLOCK_BIO_FRONTMERGE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.block_bio_queue) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.BLOCK_BIO_QUEUE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.block_bio_remap) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.BLOCK_BIO_REMAP_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.block_dirty_buffer) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.BLOCK_DIRTY_BUFFER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.block_getrq) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.BLOCK_GETRQ_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.block_plug) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.BLOCK_PLUG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.block_rq_abort) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.BLOCK_RQ_ABORT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.block_rq_complete) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.BLOCK_RQ_COMPLETE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.block_rq_insert) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.BLOCK_RQ_INSERT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.block_rq_remap) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.BLOCK_RQ_REMAP_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.block_rq_requeue) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.BLOCK_RQ_REQUEUE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.block_sleeprq) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.BLOCK_SLEEPRQ_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.block_split) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.BLOCK_SPLIT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.block_touch_buffer) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.BLOCK_TOUCH_BUFFER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.block_unplug) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.BLOCK_UNPLUG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_alloc_da_blocks) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_ALLOC_DA_BLOCKS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_allocate_blocks) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_ALLOCATE_BLOCKS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_allocate_inode) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_ALLOCATE_INODE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_begin_ordered_truncate) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_BEGIN_ORDERED_TRUNCATE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_collapse_range) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_COLLAPSE_RANGE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_da_release_space) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_DA_RELEASE_SPACE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_da_reserve_space) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_DA_RESERVE_SPACE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_da_update_reserve_space) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_DA_UPDATE_RESERVE_SPACE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_da_write_pages) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_DA_WRITE_PAGES_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_da_write_pages_extent) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_DA_WRITE_PAGES_EXTENT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_direct_i_o_enter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_DIRECT_IO_ENTER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_direct_i_o_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_DIRECT_IO_EXIT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_discard_blocks) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_DISCARD_BLOCKS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_discard_preallocations) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_DISCARD_PREALLOCATIONS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_drop_inode) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_DROP_INODE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_es_cache_extent) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_ES_CACHE_EXTENT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_es_find_delayed_extent_range_enter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_ES_FIND_DELAYED_EXTENT_RANGE_ENTER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_es_find_delayed_extent_range_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_ES_FIND_DELAYED_EXTENT_RANGE_EXIT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_es_insert_extent) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_ES_INSERT_EXTENT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_es_lookup_extent_enter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_ES_LOOKUP_EXTENT_ENTER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_es_lookup_extent_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_ES_LOOKUP_EXTENT_EXIT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_es_remove_extent) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_ES_REMOVE_EXTENT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_es_shrink) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_ES_SHRINK_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_es_shrink_count) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_ES_SHRINK_COUNT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_es_shrink_scan_enter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_ES_SHRINK_SCAN_ENTER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_es_shrink_scan_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_ES_SHRINK_SCAN_EXIT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_evict_inode) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_EVICT_INODE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_ext_convert_to_initialized_enter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_EXT_CONVERT_TO_INITIALIZED_ENTER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_ext_convert_to_initialized_fastpath) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_EXT_CONVERT_TO_INITIALIZED_FASTPATH_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_ext_handle_unwritten_extents) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_EXT_HANDLE_UNWRITTEN_EXTENTS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_ext_in_cache) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_EXT_IN_CACHE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_ext_load_extent) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_EXT_LOAD_EXTENT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_ext_map_blocks_enter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_EXT_MAP_BLOCKS_ENTER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_ext_map_blocks_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_EXT_MAP_BLOCKS_EXIT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_ext_put_in_cache) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_EXT_PUT_IN_CACHE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_ext_remove_space) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_EXT_REMOVE_SPACE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_ext_remove_space_done) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_EXT_REMOVE_SPACE_DONE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_ext_rm_idx) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_EXT_RM_IDX_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_ext_rm_leaf) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_EXT_RM_LEAF_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_ext_show_extent) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_EXT_SHOW_EXTENT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_fallocate_enter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_FALLOCATE_ENTER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_fallocate_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_FALLOCATE_EXIT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_find_delalloc_range) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_FIND_DELALLOC_RANGE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_forget) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_FORGET_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_free_blocks) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_FREE_BLOCKS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_free_inode) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_FREE_INODE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_get_implied_cluster_alloc_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_GET_IMPLIED_CLUSTER_ALLOC_EXIT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_get_reserved_cluster_alloc) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_GET_RESERVED_CLUSTER_ALLOC_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_ind_map_blocks_enter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_IND_MAP_BLOCKS_ENTER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_ind_map_blocks_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_IND_MAP_BLOCKS_EXIT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_insert_range) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_INSERT_RANGE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_invalidatepage) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_INVALIDATEPAGE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_journal_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_JOURNAL_START_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_journal_start_reserved) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_JOURNAL_START_RESERVED_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_journalled_invalidatepage) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_JOURNALLED_INVALIDATEPAGE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_journalled_write_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_JOURNALLED_WRITE_END_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_load_inode) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_LOAD_INODE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_load_inode_bitmap) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_LOAD_INODE_BITMAP_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_mark_inode_dirty) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_MARK_INODE_DIRTY_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_mb_bitmap_load) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_MB_BITMAP_LOAD_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_mb_buddy_bitmap_load) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_MB_BUDDY_BITMAP_LOAD_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_mb_discard_preallocations) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_MB_DISCARD_PREALLOCATIONS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_mb_new_group_pa) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_MB_NEW_GROUP_PA_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_mb_new_inode_pa) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_MB_NEW_INODE_PA_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_mb_release_group_pa) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_MB_RELEASE_GROUP_PA_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_mb_release_inode_pa) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_MB_RELEASE_INODE_PA_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_mballoc_alloc) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_MBALLOC_ALLOC_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_mballoc_discard) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_MBALLOC_DISCARD_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_mballoc_free) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_MBALLOC_FREE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_mballoc_prealloc) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_MBALLOC_PREALLOC_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_other_inode_update_time) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_OTHER_INODE_UPDATE_TIME_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_punch_hole) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_PUNCH_HOLE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_read_block_bitmap_load) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_READ_BLOCK_BITMAP_LOAD_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_readpage) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_READPAGE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_releasepage) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_RELEASEPAGE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_remove_blocks) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_REMOVE_BLOCKS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_request_blocks) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_REQUEST_BLOCKS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_request_inode) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_REQUEST_INODE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_sync_fs) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_SYNC_FS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_trim_all_free) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_TRIM_ALL_FREE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_trim_extent) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_TRIM_EXTENT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_truncate_enter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_TRUNCATE_ENTER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_truncate_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_TRUNCATE_EXIT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_unlink_enter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_UNLINK_ENTER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_unlink_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_UNLINK_EXIT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_write_begin) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_WRITE_BEGIN_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_write_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_WRITE_END_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_writepage) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_WRITEPAGE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_writepages) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_WRITEPAGES_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_writepages_result) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_WRITEPAGES_RESULT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ext4_zero_range) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.EXT4_ZERO_RANGE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.task_newtask) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.TASK_NEWTASK_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.task_rename) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.TASK_RENAME_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.sched_process_exec) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.SCHED_PROCESS_EXEC_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.sched_process_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.SCHED_PROCESS_EXIT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.sched_process_fork) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.SCHED_PROCESS_FORK_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.sched_process_free) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.SCHED_PROCESS_FREE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.sched_process_hang) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.SCHED_PROCESS_HANG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.sched_process_wait) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.SCHED_PROCESS_WAIT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.f2fs_do_submit_bio) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.F2FS_DO_SUBMIT_BIO_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.f2fs_evict_inode) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.F2FS_EVICT_INODE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.f2fs_fallocate) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.F2FS_FALLOCATE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.f2fs_get_data_block) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.F2FS_GET_DATA_BLOCK_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.f2fs_get_victim) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.F2FS_GET_VICTIM_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.f2fs_iget) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.F2FS_IGET_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.f2fs_iget_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.F2FS_IGET_EXIT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.f2fs_new_inode) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.F2FS_NEW_INODE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.f2fs_readpage) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.F2FS_READPAGE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.f2fs_reserve_new_block) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.F2FS_RESERVE_NEW_BLOCK_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.f2fs_set_page_dirty) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.F2FS_SET_PAGE_DIRTY_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.f2fs_submit_write_page) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.F2FS_SUBMIT_WRITE_PAGE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.f2fs_sync_file_enter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.F2FS_SYNC_FILE_ENTER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.f2fs_sync_file_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.F2FS_SYNC_FILE_EXIT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.f2fs_sync_fs) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.F2FS_SYNC_FS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.f2fs_truncate) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.F2FS_TRUNCATE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.f2fs_truncate_blocks_enter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.F2FS_TRUNCATE_BLOCKS_ENTER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.f2fs_truncate_blocks_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.F2FS_TRUNCATE_BLOCKS_EXIT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.f2fs_truncate_data_blocks_range) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.F2FS_TRUNCATE_DATA_BLOCKS_RANGE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.f2fs_truncate_inode_blocks_enter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.F2FS_TRUNCATE_INODE_BLOCKS_ENTER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.f2fs_truncate_inode_blocks_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.F2FS_TRUNCATE_INODE_BLOCKS_EXIT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.f2fs_truncate_node) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.F2FS_TRUNCATE_NODE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.f2fs_truncate_nodes_enter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.F2FS_TRUNCATE_NODES_ENTER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.f2fs_truncate_nodes_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.F2FS_TRUNCATE_NODES_EXIT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.f2fs_truncate_partial_nodes) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.F2FS_TRUNCATE_PARTIAL_NODES_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.f2fs_unlink_enter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.F2FS_UNLINK_ENTER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.f2fs_unlink_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.F2FS_UNLINK_EXIT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.f2fs_vm_page_mkwrite) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.F2FS_VM_PAGE_MKWRITE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.f2fs_write_begin) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.F2FS_WRITE_BEGIN_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.f2fs_write_checkpoint) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.F2FS_WRITE_CHECKPOINT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.f2fs_write_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.F2FS_WRITE_END_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.alloc_pages_iommu_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.ALLOC_PAGES_IOMMU_END_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.alloc_pages_iommu_fail) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.ALLOC_PAGES_IOMMU_FAIL_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.alloc_pages_iommu_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.ALLOC_PAGES_IOMMU_START_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.alloc_pages_sys_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.ALLOC_PAGES_SYS_END_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.alloc_pages_sys_fail) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.ALLOC_PAGES_SYS_FAIL_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.alloc_pages_sys_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.ALLOC_PAGES_SYS_START_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.dma_alloc_contiguous_retry) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DMA_ALLOC_CONTIGUOUS_RETRY_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.iommu_map_range) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.IOMMU_MAP_RANGE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.iommu_sec_ptbl_map_range_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.IOMMU_SEC_PTBL_MAP_RANGE_END_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.iommu_sec_ptbl_map_range_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.IOMMU_SEC_PTBL_MAP_RANGE_START_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ion_alloc_buffer_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.ION_ALLOC_BUFFER_END_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ion_alloc_buffer_fail) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.ION_ALLOC_BUFFER_FAIL_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ion_alloc_buffer_fallback) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.ION_ALLOC_BUFFER_FALLBACK_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ion_alloc_buffer_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.ION_ALLOC_BUFFER_START_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ion_cp_alloc_retry) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.ION_CP_ALLOC_RETRY_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ion_cp_secure_buffer_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.ION_CP_SECURE_BUFFER_END_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ion_cp_secure_buffer_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.ION_CP_SECURE_BUFFER_START_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ion_prefetching) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.ION_PREFETCHING_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ion_secure_cma_add_to_pool_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.ION_SECURE_CMA_ADD_TO_POOL_END_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ion_secure_cma_add_to_pool_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.ION_SECURE_CMA_ADD_TO_POOL_START_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ion_secure_cma_allocate_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.ION_SECURE_CMA_ALLOCATE_END_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ion_secure_cma_allocate_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.ION_SECURE_CMA_ALLOCATE_START_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ion_secure_cma_shrink_pool_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.ION_SECURE_CMA_SHRINK_POOL_END_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ion_secure_cma_shrink_pool_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.ION_SECURE_CMA_SHRINK_POOL_START_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kfree) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KFREE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kmalloc) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KMALLOC_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kmalloc_node) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KMALLOC_NODE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kmem_cache_alloc) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KMEM_CACHE_ALLOC_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kmem_cache_alloc_node) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KMEM_CACHE_ALLOC_NODE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kmem_cache_free) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KMEM_CACHE_FREE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.migrate_pages_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MIGRATE_PAGES_END_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.migrate_pages_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MIGRATE_PAGES_START_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.migrate_retry) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MIGRATE_RETRY_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mm_page_alloc) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MM_PAGE_ALLOC_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mm_page_alloc_extfrag) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MM_PAGE_ALLOC_EXTFRAG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mm_page_alloc_zone_locked) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MM_PAGE_ALLOC_ZONE_LOCKED_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mm_page_free) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MM_PAGE_FREE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mm_page_free_batched) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MM_PAGE_FREE_BATCHED_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mm_page_pcpu_drain) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MM_PAGE_PCPU_DRAIN_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.rss_stat) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.RSS_STAT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ion_heap_shrink) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.ION_HEAP_SHRINK_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ion_heap_grow) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.ION_HEAP_GROW_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.fence_init) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.FENCE_INIT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.fence_destroy) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.FENCE_DESTROY_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.fence_enable_signal) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.FENCE_ENABLE_SIGNAL_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.fence_signaled) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.FENCE_SIGNALED_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.clk_enable) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.CLK_ENABLE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.clk_disable) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.CLK_DISABLE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.clk_set_rate) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.CLK_SET_RATE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.binder_transaction_alloc_buf) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.BINDER_TRANSACTION_ALLOC_BUF_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.signal_deliver) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.SIGNAL_DELIVER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.signal_generate) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.SIGNAL_GENERATE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.oom_score_adj_update) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.OOM_SCORE_ADJ_UPDATE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.generic) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.GENERIC_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mm_event_record) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MM_EVENT_RECORD_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.sys_enter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.SYS_ENTER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.sys_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.SYS_EXIT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.zero) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.ZERO_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.gpu_frequency) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.GPU_FREQUENCY_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.sde_tracing_mark_write) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.SDE_TRACING_MARK_WRITE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mark_victim) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MARK_VICTIM_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ion_stat) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.ION_STAT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ion_buffer_create) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.ION_BUFFER_CREATE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ion_buffer_destroy) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.ION_BUFFER_DESTROY_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.scm_call_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.SCM_CALL_START_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.scm_call_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.SCM_CALL_END_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.gpu_mem_total) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.GPU_MEM_TOTAL_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.thermal_temperature) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.THERMAL_TEMPERATURE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cdev_update) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.CDEV_UPDATE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cpuhp_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.CPUHP_EXIT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cpuhp_multi_enter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.CPUHP_MULTI_ENTER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cpuhp_enter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.CPUHP_ENTER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cpuhp_latency) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.CPUHP_LATENCY_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.fastrpc_dma_stat) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.FASTRPC_DMA_STAT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.dpu_tracing_mark_write) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DPU_TRACING_MARK_WRITE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.g2d_tracing_mark_write) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.G2D_TRACING_MARK_WRITE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mali_tracing_mark_write) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MALI_TRACING_MARK_WRITE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.dma_heap_stat) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DMA_HEAP_STAT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cpuhp_pause) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.CPUHP_PAUSE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.sched_pi_setprio) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.SCHED_PI_SETPRIO_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.sde_sde_evtlog) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.SDE_SDE_EVTLOG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.sde_sde_perf_calc_crtc) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.SDE_SDE_PERF_CALC_CRTC_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.sde_sde_perf_crtc_update) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.SDE_SDE_PERF_CRTC_UPDATE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.sde_sde_perf_set_qos_luts) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.SDE_SDE_PERF_SET_QOS_LUTS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.sde_sde_perf_update_bus) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.SDE_SDE_PERF_UPDATE_BUS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.rss_stat_throttled) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.RSS_STAT_THROTTLED_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.netif_receive_skb) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.NETIF_RECEIVE_SKB_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.net_dev_xmit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.NET_DEV_XMIT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.inet_sock_set_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.INET_SOCK_SET_STATE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.tcp_retransmit_skb) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.TCP_RETRANSMIT_SKB_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cros_ec_sensorhub_data) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.CROS_EC_SENSORHUB_DATA_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.napi_gro_receive_entry) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.NAPI_GRO_RECEIVE_ENTRY_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.napi_gro_receive_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.NAPI_GRO_RECEIVE_EXIT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kfree_skb) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KFREE_SKB_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kvm_access_fault) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KVM_ACCESS_FAULT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kvm_ack_irq) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KVM_ACK_IRQ_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kvm_age_hva) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KVM_AGE_HVA_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kvm_age_page) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KVM_AGE_PAGE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kvm_arm_clear_debug) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KVM_ARM_CLEAR_DEBUG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kvm_arm_set_dreg32) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KVM_ARM_SET_DREG32_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kvm_arm_set_regset) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KVM_ARM_SET_REGSET_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kvm_arm_setup_debug) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KVM_ARM_SETUP_DEBUG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kvm_entry) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KVM_ENTRY_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kvm_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KVM_EXIT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kvm_fpu) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KVM_FPU_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kvm_get_timer_map) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KVM_GET_TIMER_MAP_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kvm_guest_fault) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KVM_GUEST_FAULT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kvm_handle_sys_reg) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KVM_HANDLE_SYS_REG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kvm_hvc_arm64) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KVM_HVC_ARM64_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kvm_irq_line) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KVM_IRQ_LINE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kvm_mmio) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KVM_MMIO_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kvm_mmio_emulate) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KVM_MMIO_EMULATE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kvm_set_guest_debug) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KVM_SET_GUEST_DEBUG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kvm_set_irq) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KVM_SET_IRQ_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kvm_set_spte_hva) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KVM_SET_SPTE_HVA_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kvm_set_way_flush) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KVM_SET_WAY_FLUSH_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kvm_sys_access) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KVM_SYS_ACCESS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kvm_test_age_hva) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KVM_TEST_AGE_HVA_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kvm_timer_emulate) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KVM_TIMER_EMULATE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kvm_timer_hrtimer_expire) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KVM_TIMER_HRTIMER_EXPIRE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kvm_timer_restore_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KVM_TIMER_RESTORE_STATE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kvm_timer_save_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KVM_TIMER_SAVE_STATE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kvm_timer_update_irq) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KVM_TIMER_UPDATE_IRQ_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kvm_toggle_cache) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KVM_TOGGLE_CACHE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kvm_unmap_hva_range) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KVM_UNMAP_HVA_RANGE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kvm_userspace_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KVM_USERSPACE_EXIT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kvm_vcpu_wakeup) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KVM_VCPU_WAKEUP_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kvm_wfx_arm64) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KVM_WFX_ARM64_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.trap_reg) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.TRAP_REG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.vgic_update_irq_pending) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.VGIC_UPDATE_IRQ_PENDING_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.wakeup_source_activate) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.WAKEUP_SOURCE_ACTIVATE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.wakeup_source_deactivate) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.WAKEUP_SOURCE_DEACTIVATE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ufshcd_command) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.UFSHCD_COMMAND_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ufshcd_clk_gating) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.UFSHCD_CLK_GATING_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.console) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.CONSOLE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.drm_vblank_event) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DRM_VBLANK_EVENT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.drm_vblank_event_delivered) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DRM_VBLANK_EVENT_DELIVERED_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.drm_sched_job) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DRM_SCHED_JOB_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.drm_run_job) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DRM_RUN_JOB_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.drm_sched_process_job) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DRM_SCHED_PROCESS_JOB_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.dma_fence_init) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DMA_FENCE_INIT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.dma_fence_emit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DMA_FENCE_EMIT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.dma_fence_signaled) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DMA_FENCE_SIGNALED_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.dma_fence_wait_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DMA_FENCE_WAIT_START_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.dma_fence_wait_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DMA_FENCE_WAIT_END_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.f2fs_iostat) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.F2FS_IOSTAT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.f2fs_iostat_latency) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.F2FS_IOSTAT_LATENCY_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.sched_cpu_util_cfs) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.SCHED_CPU_UTIL_CFS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.v4l2_qbuf) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.V4L2_QBUF_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.v4l2_dqbuf) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.V4L2_DQBUF_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.vb2_v4l2_buf_queue) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.VB2_V4L2_BUF_QUEUE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.vb2_v4l2_buf_done) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.VB2_V4L2_BUF_DONE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.vb2_v4l2_qbuf) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.VB2_V4L2_QBUF_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.vb2_v4l2_dqbuf) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.VB2_V4L2_DQBUF_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.dsi_cmd_fifo_status) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DSI_CMD_FIFO_STATUS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.dsi_rx) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DSI_RX_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.dsi_tx) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DSI_TX_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_fs_dataread_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.ANDROID_FS_DATAREAD_END_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_fs_dataread_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.ANDROID_FS_DATAREAD_START_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_fs_datawrite_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.ANDROID_FS_DATAWRITE_END_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_fs_datawrite_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.ANDROID_FS_DATAWRITE_START_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_fs_fsync_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.ANDROID_FS_FSYNC_END_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_fs_fsync_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.ANDROID_FS_FSYNC_START_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.funcgraph_entry) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.FUNCGRAPH_ENTRY_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.funcgraph_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.FUNCGRAPH_EXIT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.virtio_video_cmd) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.VIRTIO_VIDEO_CMD_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.virtio_video_cmd_done) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.VIRTIO_VIDEO_CMD_DONE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.virtio_video_resource_queue) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.VIRTIO_VIDEO_RESOURCE_QUEUE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.virtio_video_resource_queue_done) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.VIRTIO_VIDEO_RESOURCE_QUEUE_DONE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mm_shrink_slab_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MM_SHRINK_SLAB_START_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mm_shrink_slab_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MM_SHRINK_SLAB_END_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.trusty_smc) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.TRUSTY_SMC_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.trusty_smc_done) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.TRUSTY_SMC_DONE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.trusty_std_call32) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.TRUSTY_STD_CALL32_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.trusty_std_call32_done) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.TRUSTY_STD_CALL32_DONE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.trusty_share_memory) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.TRUSTY_SHARE_MEMORY_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.trusty_share_memory_done) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.TRUSTY_SHARE_MEMORY_DONE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.trusty_reclaim_memory) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.TRUSTY_RECLAIM_MEMORY_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.trusty_reclaim_memory_done) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.TRUSTY_RECLAIM_MEMORY_DONE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.trusty_irq) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.TRUSTY_IRQ_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.trusty_ipc_handle_event) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.TRUSTY_IPC_HANDLE_EVENT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.trusty_ipc_connect) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.TRUSTY_IPC_CONNECT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.trusty_ipc_connect_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.TRUSTY_IPC_CONNECT_END_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.trusty_ipc_write) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.TRUSTY_IPC_WRITE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.trusty_ipc_poll) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.TRUSTY_IPC_POLL_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.trusty_ipc_read) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.TRUSTY_IPC_READ_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.trusty_ipc_read_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.TRUSTY_IPC_READ_END_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.trusty_ipc_rx) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.TRUSTY_IPC_RX_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.trusty_enqueue_nop) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.TRUSTY_ENQUEUE_NOP_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cma_alloc_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.CMA_ALLOC_START_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cma_alloc_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.CMA_ALLOC_INFO_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.lwis_tracing_mark_write) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.LWIS_TRACING_MARK_WRITE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.virtio_gpu_cmd_queue) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.VIRTIO_GPU_CMD_QUEUE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.virtio_gpu_cmd_response) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.VIRTIO_GPU_CMD_RESPONSE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mali_mali_k_c_p_u_c_q_s_s_e_t) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MALI_MALI_KCPU_CQS_SETWIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mali_mali_k_c_p_u_c_q_s_w_a_i_t_s_t_a_r_t) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MALI_MALI_KCPU_CQS_WAIT_STARTWIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mali_mali_k_c_p_u_c_q_s_w_a_i_t_e_n_d) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MALI_MALI_KCPU_CQS_WAIT_ENDWIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mali_mali_k_c_p_u_f_e_n_c_e_s_i_g_n_a_l) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MALI_MALI_KCPU_FENCE_SIGNALWIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mali_mali_k_c_p_u_f_e_n_c_e_w_a_i_t_s_t_a_r_t) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MALI_MALI_KCPU_FENCE_WAIT_STARTWIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mali_mali_k_c_p_u_f_e_n_c_e_w_a_i_t_e_n_d) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MALI_MALI_KCPU_FENCE_WAIT_ENDWIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.hyp_enter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.HYP_ENTER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.hyp_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.HYP_EXIT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.host_hcall) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.HOST_HCALL_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.host_smc) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.HOST_SMC_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.host_mem_abort) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.HOST_MEM_ABORT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.suspend_resume_minimal) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.SUSPEND_RESUME_MINIMAL_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mali_mali_c_s_f_i_n_t_e_r_r_u_p_t_s_t_a_r_t) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MALI_MALI_CSF_INTERRUPT_STARTWIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mali_mali_c_s_f_i_n_t_e_r_r_u_p_t_e_n_d) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MALI_MALI_CSF_INTERRUPT_ENDWIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.samsung_tracing_mark_write) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.SAMSUNG_TRACING_MARK_WRITE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.binder_command) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.BINDER_COMMAND_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.binder_return) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.BINDER_RETURN_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.sched_switch_with_ctrs) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.SCHED_SWITCH_WITH_CTRS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.gpu_work_period) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.GPU_WORK_PERIOD_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.rpm_status) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.RPM_STATUS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.panel_write_generic) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.PANEL_WRITE_GENERIC_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.sched_migrate_task) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.SCHED_MIGRATE_TASK_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.dpu_dsi_cmd_fifo_status) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DPU_DSI_CMD_FIFO_STATUS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.dpu_dsi_rx) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DPU_DSI_RX_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.dpu_dsi_tx) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DPU_DSI_TX_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.f2fs_background_gc) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.F2FS_BACKGROUND_GC_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.f2fs_gc_begin) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.F2FS_GC_BEGIN_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.f2fs_gc_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.F2FS_GC_END_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.fastrpc_dma_free) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.FASTRPC_DMA_FREE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.fastrpc_dma_alloc) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.FASTRPC_DMA_ALLOC_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.fastrpc_dma_unmap) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.FASTRPC_DMA_UNMAP_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.fastrpc_dma_map) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.FASTRPC_DMA_MAP_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.google_icc_event) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.GOOGLE_ICC_EVENT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.google_irm_event) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.GOOGLE_IRM_EVENT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.device_pm_callback_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DEVICE_PM_CALLBACK_START_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.device_pm_callback_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DEVICE_PM_CALLBACK_END_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.thermal_exynos_acpm_bulk) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.THERMAL_EXYNOS_ACPM_BULK_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.thermal_exynos_acpm_high_overhead) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.THERMAL_EXYNOS_ACPM_HIGH_OVERHEAD_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.dcvsh_freq) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DCVSH_FREQ_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kgsl_gpu_frequency) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KGSL_GPU_FREQUENCY_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mali_mali_p_m_m_c_u_h_c_t_l_c_o_r_e_s_d_o_w_n_s_c_a_l_e_n_o_t_i_f_y_p_e_n_d) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MALI_MALI_PM_MCU_HCTL_CORES_DOWN_SCALE_NOTIFY_PENDWIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mali_mali_p_m_m_c_u_h_c_t_l_c_o_r_e_s_n_o_t_i_f_y_p_e_n_d) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MALI_MALI_PM_MCU_HCTL_CORES_NOTIFY_PENDWIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mali_mali_p_m_m_c_u_h_c_t_l_c_o_r_e_i_n_a_c_t_i_v_e_p_e_n_d) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MALI_MALI_PM_MCU_HCTL_CORE_INACTIVE_PENDWIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mali_mali_p_m_m_c_u_h_c_t_l_m_c_u_o_n_r_e_c_h_e_c_k) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MALI_MALI_PM_MCU_HCTL_MCU_ON_RECHECKWIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mali_mali_p_m_m_c_u_h_c_t_l_s_h_a_d_e_r_s_c_o_r_e_o_f_f_p_e_n_d) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MALI_MALI_PM_MCU_HCTL_SHADERS_CORE_OFF_PENDWIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mali_mali_p_m_m_c_u_h_c_t_l_s_h_a_d_e_r_s_p_e_n_d_o_f_f) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MALI_MALI_PM_MCU_HCTL_SHADERS_PEND_OFFWIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mali_mali_p_m_m_c_u_h_c_t_l_s_h_a_d_e_r_s_p_e_n_d_o_n) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MALI_MALI_PM_MCU_HCTL_SHADERS_PEND_ONWIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mali_mali_p_m_m_c_u_h_c_t_l_s_h_a_d_e_r_s_r_e_a_d_y_o_f_f) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MALI_MALI_PM_MCU_HCTL_SHADERS_READY_OFFWIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mali_mali_p_m_m_c_u_i_n_s_l_e_e_p) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MALI_MALI_PM_MCU_IN_SLEEPWIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mali_mali_p_m_m_c_u_o_f_f) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MALI_MALI_PM_MCU_OFFWIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mali_mali_p_m_m_c_u_o_n) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MALI_MALI_PM_MCU_ONWIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mali_mali_p_m_m_c_u_o_n_c_o_r_e_a_t_t_r_u_p_d_a_t_e_p_e_n_d) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MALI_MALI_PM_MCU_ON_CORE_ATTR_UPDATE_PENDWIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mali_mali_p_m_m_c_u_o_n_g_l_b_r_e_i_n_i_t_p_e_n_d) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MALI_MALI_PM_MCU_ON_GLB_REINIT_PENDWIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mali_mali_p_m_m_c_u_o_n_h_a_l_t) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MALI_MALI_PM_MCU_ON_HALTWIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mali_mali_p_m_m_c_u_o_n_h_w_c_n_t_d_i_s_a_b_l_e) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MALI_MALI_PM_MCU_ON_HWCNT_DISABLEWIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mali_mali_p_m_m_c_u_o_n_h_w_c_n_t_e_n_a_b_l_e) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MALI_MALI_PM_MCU_ON_HWCNT_ENABLEWIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mali_mali_p_m_m_c_u_o_n_p_e_n_d_h_a_l_t) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MALI_MALI_PM_MCU_ON_PEND_HALTWIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mali_mali_p_m_m_c_u_o_n_p_e_n_d_s_l_e_e_p) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MALI_MALI_PM_MCU_ON_PEND_SLEEPWIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mali_mali_p_m_m_c_u_o_n_s_l_e_e_p_i_n_i_t_i_a_t_e) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MALI_MALI_PM_MCU_ON_SLEEP_INITIATEWIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mali_mali_p_m_m_c_u_p_e_n_d_o_f_f) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MALI_MALI_PM_MCU_PEND_OFFWIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mali_mali_p_m_m_c_u_p_e_n_d_o_n_r_e_l_o_a_d) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MALI_MALI_PM_MCU_PEND_ON_RELOADWIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mali_mali_p_m_m_c_u_p_o_w_e_r_d_o_w_n) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MALI_MALI_PM_MCU_POWER_DOWNWIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mali_mali_p_m_m_c_u_r_e_s_e_t_w_a_i_t) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MALI_MALI_PM_MCU_RESET_WAITWIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.bcl_irq_trigger) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.BCL_IRQ_TRIGGER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kgsl_adreno_cmdbatch_queued) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KGSL_ADRENO_CMDBATCH_QUEUED_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kgsl_adreno_cmdbatch_submitted) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KGSL_ADRENO_CMDBATCH_SUBMITTED_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kgsl_adreno_cmdbatch_sync) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KGSL_ADRENO_CMDBATCH_SYNC_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kgsl_adreno_cmdbatch_retired) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KGSL_ADRENO_CMDBATCH_RETIRED_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.pixel_mm_kswapd_wake) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.PIXEL_MM_KSWAPD_WAKE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.pixel_mm_kswapd_done) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.PIXEL_MM_KSWAPD_DONE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.sched_wakeup_task_attr) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.SCHED_WAKEUP_TASK_ATTR_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.devfreq_frequency) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DEVFREQ_FREQUENCY_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kprobe_event) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.KPROBE_EVENT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.param_set_value_cpm) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.PARAM_SET_VALUE_CPM_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.do_sys_open) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DO_SYS_OPEN_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.open_exec) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.OPEN_EXEC_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.block_io_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.BLOCK_IO_START_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.block_io_done) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.BLOCK_IO_DONE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mali_gpu_power_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MALI_GPU_POWER_STATE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.dpu_disp_dpu_underrun) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DPU_DISP_DPU_UNDERRUN_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.dpu_disp_vblank_irq_enable) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DPU_DISP_VBLANK_IRQ_ENABLE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.hrtimer_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.HRTIMER_START_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.hrtimer_cancel) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.HRTIMER_CANCEL_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.hrtimer_expire_entry) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.HRTIMER_EXPIRE_ENTRY_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.hrtimer_expire_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.HRTIMER_EXPIRE_EXIT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.timer_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.TIMER_START_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.timer_cancel) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.TIMER_CANCEL_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.timer_expire_entry) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.TIMER_EXPIRE_ENTRY_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.timer_expire_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.TIMER_EXPIRE_EXIT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.local_timer_entry) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.LOCAL_TIMER_ENTRY_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.local_timer_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.LOCAL_TIMER_EXIT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.dwc3_alloc_request) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DWC3_ALLOC_REQUEST_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.dwc3_complete_trb) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DWC3_COMPLETE_TRB_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.dwc3_ctrl_req) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DWC3_CTRL_REQ_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.dwc3_ep_dequeue) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DWC3_EP_DEQUEUE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.dwc3_ep_queue) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DWC3_EP_QUEUE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.dwc3_event) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DWC3_EVENT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.dwc3_free_request) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DWC3_FREE_REQUEST_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.dwc3_gadget_ep_cmd) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DWC3_GADGET_EP_CMD_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.dwc3_gadget_ep_disable) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DWC3_GADGET_EP_DISABLE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.dwc3_gadget_ep_enable) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DWC3_GADGET_EP_ENABLE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.dwc3_gadget_generic_cmd) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DWC3_GADGET_GENERIC_CMD_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.dwc3_gadget_giveback) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DWC3_GADGET_GIVEBACK_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.dwc3_prepare_trb) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DWC3_PREPARE_TRB_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.dwc3_readl) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DWC3_READL_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.dwc3_writel) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DWC3_WRITEL_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cma_alloc_finish) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.CMA_ALLOC_FINISH_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.mm_alloc_contig_migrate_range_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.MM_ALLOC_CONTIG_MIGRATE_RANGE_INFO_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.host_ffa_call) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.HOST_FFA_CALL_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.dmabuf_rss_stat) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DMABUF_RSS_STAT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.iommu_idmap) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.IOMMU_IDMAP_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.psci_mem_protect) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.PSCI_MEM_PROTECT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.hypervisor_host_hcall) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.HYPERVISOR_HOST_HCALL_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.hypervisor_host_smc) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.HYPERVISOR_HOST_SMC_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.hypervisor_hyp_exit) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.HYPERVISOR_HYP_EXIT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.hypervisor_iommu_idmap) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.HYPERVISOR_IOMMU_IDMAP_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.hypervisor_psci_mem_protect) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.HYPERVISOR_PSCI_MEM_PROTECT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.hypervisor_host_mem_abort) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.HYPERVISOR_HOST_MEM_ABORT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.hypervisor_hyp_enter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.HYPERVISOR_HYP_ENTER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.hypervisor_iommu_idmap_complete) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.HYPERVISOR_IOMMU_IDMAP_COMPLETE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.hypervisor_vcpu_illegal_trap) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.HYPERVISOR_VCPU_ILLEGAL_TRAP_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.drm_sched_job_add_dep) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DRM_SCHED_JOB_ADD_DEP_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.drm_sched_job_done) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DRM_SCHED_JOB_DONE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.drm_sched_job_queue) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DRM_SCHED_JOB_QUEUE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.drm_sched_job_run) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DRM_SCHED_JOB_RUN_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.drm_sched_job_unschedulable) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.DRM_SCHED_JOB_UNSCHEDULABLE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.fwtp_perfetto_counter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventWire.FWTP_PERFETTO_COUNTER_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const FtraceEventReader = struct {
    buf: gremlin.Reader,
    _timestamp: u64 = 0,
    _pid: u32 = 0,
    _common_flags: u32 = 0,
    _print_buf: ?[]const u8 = null,
    _sched_switch_buf: ?[]const u8 = null,
    _cpu_frequency_buf: ?[]const u8 = null,
    _cpu_frequency_limits_buf: ?[]const u8 = null,
    _cpu_idle_buf: ?[]const u8 = null,
    _clock_enable_buf: ?[]const u8 = null,
    _clock_disable_buf: ?[]const u8 = null,
    _clock_set_rate_buf: ?[]const u8 = null,
    _sched_wakeup_buf: ?[]const u8 = null,
    _sched_blocked_reason_buf: ?[]const u8 = null,
    _sched_cpu_hotplug_buf: ?[]const u8 = null,
    _sched_waking_buf: ?[]const u8 = null,
    _ipi_entry_buf: ?[]const u8 = null,
    _ipi_exit_buf: ?[]const u8 = null,
    _ipi_raise_buf: ?[]const u8 = null,
    _softirq_entry_buf: ?[]const u8 = null,
    _softirq_exit_buf: ?[]const u8 = null,
    _softirq_raise_buf: ?[]const u8 = null,
    _i2c_read_buf: ?[]const u8 = null,
    _i2c_write_buf: ?[]const u8 = null,
    _i2c_result_buf: ?[]const u8 = null,
    _i2c_reply_buf: ?[]const u8 = null,
    _smbus_read_buf: ?[]const u8 = null,
    _smbus_write_buf: ?[]const u8 = null,
    _smbus_result_buf: ?[]const u8 = null,
    _smbus_reply_buf: ?[]const u8 = null,
    _lowmemory_kill_buf: ?[]const u8 = null,
    _irq_handler_entry_buf: ?[]const u8 = null,
    _irq_handler_exit_buf: ?[]const u8 = null,
    _sync_pt_buf: ?[]const u8 = null,
    _sync_timeline_buf: ?[]const u8 = null,
    _sync_wait_buf: ?[]const u8 = null,
    _ext4_da_write_begin_buf: ?[]const u8 = null,
    _ext4_da_write_end_buf: ?[]const u8 = null,
    _ext4_sync_file_enter_buf: ?[]const u8 = null,
    _ext4_sync_file_exit_buf: ?[]const u8 = null,
    _block_rq_issue_buf: ?[]const u8 = null,
    _mm_vmscan_direct_reclaim_begin_buf: ?[]const u8 = null,
    _mm_vmscan_direct_reclaim_end_buf: ?[]const u8 = null,
    _mm_vmscan_kswapd_wake_buf: ?[]const u8 = null,
    _mm_vmscan_kswapd_sleep_buf: ?[]const u8 = null,
    _binder_transaction_buf: ?[]const u8 = null,
    _binder_transaction_received_buf: ?[]const u8 = null,
    _binder_set_priority_buf: ?[]const u8 = null,
    _binder_lock_buf: ?[]const u8 = null,
    _binder_locked_buf: ?[]const u8 = null,
    _binder_unlock_buf: ?[]const u8 = null,
    _workqueue_activate_work_buf: ?[]const u8 = null,
    _workqueue_execute_end_buf: ?[]const u8 = null,
    _workqueue_execute_start_buf: ?[]const u8 = null,
    _workqueue_queue_work_buf: ?[]const u8 = null,
    _regulator_disable_buf: ?[]const u8 = null,
    _regulator_disable_complete_buf: ?[]const u8 = null,
    _regulator_enable_buf: ?[]const u8 = null,
    _regulator_enable_complete_buf: ?[]const u8 = null,
    _regulator_enable_delay_buf: ?[]const u8 = null,
    _regulator_set_voltage_buf: ?[]const u8 = null,
    _regulator_set_voltage_complete_buf: ?[]const u8 = null,
    _cgroup_attach_task_buf: ?[]const u8 = null,
    _cgroup_mkdir_buf: ?[]const u8 = null,
    _cgroup_remount_buf: ?[]const u8 = null,
    _cgroup_rmdir_buf: ?[]const u8 = null,
    _cgroup_transfer_tasks_buf: ?[]const u8 = null,
    _cgroup_destroy_root_buf: ?[]const u8 = null,
    _cgroup_release_buf: ?[]const u8 = null,
    _cgroup_rename_buf: ?[]const u8 = null,
    _cgroup_setup_root_buf: ?[]const u8 = null,
    _mdp_cmd_kickoff_buf: ?[]const u8 = null,
    _mdp_commit_buf: ?[]const u8 = null,
    _mdp_perf_set_ot_buf: ?[]const u8 = null,
    _mdp_sspp_change_buf: ?[]const u8 = null,
    _tracing_mark_write_buf: ?[]const u8 = null,
    _mdp_cmd_pingpong_done_buf: ?[]const u8 = null,
    _mdp_compare_bw_buf: ?[]const u8 = null,
    _mdp_perf_set_panic_luts_buf: ?[]const u8 = null,
    _mdp_sspp_set_buf: ?[]const u8 = null,
    _mdp_cmd_readptr_done_buf: ?[]const u8 = null,
    _mdp_misr_crc_buf: ?[]const u8 = null,
    _mdp_perf_set_qos_luts_buf: ?[]const u8 = null,
    _mdp_trace_counter_buf: ?[]const u8 = null,
    _mdp_cmd_release_bw_buf: ?[]const u8 = null,
    _mdp_mixer_update_buf: ?[]const u8 = null,
    _mdp_perf_set_wm_levels_buf: ?[]const u8 = null,
    _mdp_video_underrun_done_buf: ?[]const u8 = null,
    _mdp_cmd_wait_pingpong_buf: ?[]const u8 = null,
    _mdp_perf_prefill_calc_buf: ?[]const u8 = null,
    _mdp_perf_update_bus_buf: ?[]const u8 = null,
    _rotator_bw_ao_as_context_buf: ?[]const u8 = null,
    _mm_filemap_add_to_page_cache_buf: ?[]const u8 = null,
    _mm_filemap_delete_from_page_cache_buf: ?[]const u8 = null,
    _mm_compaction_begin_buf: ?[]const u8 = null,
    _mm_compaction_defer_compaction_buf: ?[]const u8 = null,
    _mm_compaction_deferred_buf: ?[]const u8 = null,
    _mm_compaction_defer_reset_buf: ?[]const u8 = null,
    _mm_compaction_end_buf: ?[]const u8 = null,
    _mm_compaction_finished_buf: ?[]const u8 = null,
    _mm_compaction_isolate_freepages_buf: ?[]const u8 = null,
    _mm_compaction_isolate_migratepages_buf: ?[]const u8 = null,
    _mm_compaction_kcompactd_sleep_buf: ?[]const u8 = null,
    _mm_compaction_kcompactd_wake_buf: ?[]const u8 = null,
    _mm_compaction_migratepages_buf: ?[]const u8 = null,
    _mm_compaction_suitable_buf: ?[]const u8 = null,
    _mm_compaction_try_to_compact_pages_buf: ?[]const u8 = null,
    _mm_compaction_wakeup_kcompactd_buf: ?[]const u8 = null,
    _suspend_resume_buf: ?[]const u8 = null,
    _sched_wakeup_new_buf: ?[]const u8 = null,
    _block_bio_backmerge_buf: ?[]const u8 = null,
    _block_bio_bounce_buf: ?[]const u8 = null,
    _block_bio_complete_buf: ?[]const u8 = null,
    _block_bio_frontmerge_buf: ?[]const u8 = null,
    _block_bio_queue_buf: ?[]const u8 = null,
    _block_bio_remap_buf: ?[]const u8 = null,
    _block_dirty_buffer_buf: ?[]const u8 = null,
    _block_getrq_buf: ?[]const u8 = null,
    _block_plug_buf: ?[]const u8 = null,
    _block_rq_abort_buf: ?[]const u8 = null,
    _block_rq_complete_buf: ?[]const u8 = null,
    _block_rq_insert_buf: ?[]const u8 = null,
    _block_rq_remap_buf: ?[]const u8 = null,
    _block_rq_requeue_buf: ?[]const u8 = null,
    _block_sleeprq_buf: ?[]const u8 = null,
    _block_split_buf: ?[]const u8 = null,
    _block_touch_buffer_buf: ?[]const u8 = null,
    _block_unplug_buf: ?[]const u8 = null,
    _ext4_alloc_da_blocks_buf: ?[]const u8 = null,
    _ext4_allocate_blocks_buf: ?[]const u8 = null,
    _ext4_allocate_inode_buf: ?[]const u8 = null,
    _ext4_begin_ordered_truncate_buf: ?[]const u8 = null,
    _ext4_collapse_range_buf: ?[]const u8 = null,
    _ext4_da_release_space_buf: ?[]const u8 = null,
    _ext4_da_reserve_space_buf: ?[]const u8 = null,
    _ext4_da_update_reserve_space_buf: ?[]const u8 = null,
    _ext4_da_write_pages_buf: ?[]const u8 = null,
    _ext4_da_write_pages_extent_buf: ?[]const u8 = null,
    _ext4_direct_i_o_enter_buf: ?[]const u8 = null,
    _ext4_direct_i_o_exit_buf: ?[]const u8 = null,
    _ext4_discard_blocks_buf: ?[]const u8 = null,
    _ext4_discard_preallocations_buf: ?[]const u8 = null,
    _ext4_drop_inode_buf: ?[]const u8 = null,
    _ext4_es_cache_extent_buf: ?[]const u8 = null,
    _ext4_es_find_delayed_extent_range_enter_buf: ?[]const u8 = null,
    _ext4_es_find_delayed_extent_range_exit_buf: ?[]const u8 = null,
    _ext4_es_insert_extent_buf: ?[]const u8 = null,
    _ext4_es_lookup_extent_enter_buf: ?[]const u8 = null,
    _ext4_es_lookup_extent_exit_buf: ?[]const u8 = null,
    _ext4_es_remove_extent_buf: ?[]const u8 = null,
    _ext4_es_shrink_buf: ?[]const u8 = null,
    _ext4_es_shrink_count_buf: ?[]const u8 = null,
    _ext4_es_shrink_scan_enter_buf: ?[]const u8 = null,
    _ext4_es_shrink_scan_exit_buf: ?[]const u8 = null,
    _ext4_evict_inode_buf: ?[]const u8 = null,
    _ext4_ext_convert_to_initialized_enter_buf: ?[]const u8 = null,
    _ext4_ext_convert_to_initialized_fastpath_buf: ?[]const u8 = null,
    _ext4_ext_handle_unwritten_extents_buf: ?[]const u8 = null,
    _ext4_ext_in_cache_buf: ?[]const u8 = null,
    _ext4_ext_load_extent_buf: ?[]const u8 = null,
    _ext4_ext_map_blocks_enter_buf: ?[]const u8 = null,
    _ext4_ext_map_blocks_exit_buf: ?[]const u8 = null,
    _ext4_ext_put_in_cache_buf: ?[]const u8 = null,
    _ext4_ext_remove_space_buf: ?[]const u8 = null,
    _ext4_ext_remove_space_done_buf: ?[]const u8 = null,
    _ext4_ext_rm_idx_buf: ?[]const u8 = null,
    _ext4_ext_rm_leaf_buf: ?[]const u8 = null,
    _ext4_ext_show_extent_buf: ?[]const u8 = null,
    _ext4_fallocate_enter_buf: ?[]const u8 = null,
    _ext4_fallocate_exit_buf: ?[]const u8 = null,
    _ext4_find_delalloc_range_buf: ?[]const u8 = null,
    _ext4_forget_buf: ?[]const u8 = null,
    _ext4_free_blocks_buf: ?[]const u8 = null,
    _ext4_free_inode_buf: ?[]const u8 = null,
    _ext4_get_implied_cluster_alloc_exit_buf: ?[]const u8 = null,
    _ext4_get_reserved_cluster_alloc_buf: ?[]const u8 = null,
    _ext4_ind_map_blocks_enter_buf: ?[]const u8 = null,
    _ext4_ind_map_blocks_exit_buf: ?[]const u8 = null,
    _ext4_insert_range_buf: ?[]const u8 = null,
    _ext4_invalidatepage_buf: ?[]const u8 = null,
    _ext4_journal_start_buf: ?[]const u8 = null,
    _ext4_journal_start_reserved_buf: ?[]const u8 = null,
    _ext4_journalled_invalidatepage_buf: ?[]const u8 = null,
    _ext4_journalled_write_end_buf: ?[]const u8 = null,
    _ext4_load_inode_buf: ?[]const u8 = null,
    _ext4_load_inode_bitmap_buf: ?[]const u8 = null,
    _ext4_mark_inode_dirty_buf: ?[]const u8 = null,
    _ext4_mb_bitmap_load_buf: ?[]const u8 = null,
    _ext4_mb_buddy_bitmap_load_buf: ?[]const u8 = null,
    _ext4_mb_discard_preallocations_buf: ?[]const u8 = null,
    _ext4_mb_new_group_pa_buf: ?[]const u8 = null,
    _ext4_mb_new_inode_pa_buf: ?[]const u8 = null,
    _ext4_mb_release_group_pa_buf: ?[]const u8 = null,
    _ext4_mb_release_inode_pa_buf: ?[]const u8 = null,
    _ext4_mballoc_alloc_buf: ?[]const u8 = null,
    _ext4_mballoc_discard_buf: ?[]const u8 = null,
    _ext4_mballoc_free_buf: ?[]const u8 = null,
    _ext4_mballoc_prealloc_buf: ?[]const u8 = null,
    _ext4_other_inode_update_time_buf: ?[]const u8 = null,
    _ext4_punch_hole_buf: ?[]const u8 = null,
    _ext4_read_block_bitmap_load_buf: ?[]const u8 = null,
    _ext4_readpage_buf: ?[]const u8 = null,
    _ext4_releasepage_buf: ?[]const u8 = null,
    _ext4_remove_blocks_buf: ?[]const u8 = null,
    _ext4_request_blocks_buf: ?[]const u8 = null,
    _ext4_request_inode_buf: ?[]const u8 = null,
    _ext4_sync_fs_buf: ?[]const u8 = null,
    _ext4_trim_all_free_buf: ?[]const u8 = null,
    _ext4_trim_extent_buf: ?[]const u8 = null,
    _ext4_truncate_enter_buf: ?[]const u8 = null,
    _ext4_truncate_exit_buf: ?[]const u8 = null,
    _ext4_unlink_enter_buf: ?[]const u8 = null,
    _ext4_unlink_exit_buf: ?[]const u8 = null,
    _ext4_write_begin_buf: ?[]const u8 = null,
    _ext4_write_end_buf: ?[]const u8 = null,
    _ext4_writepage_buf: ?[]const u8 = null,
    _ext4_writepages_buf: ?[]const u8 = null,
    _ext4_writepages_result_buf: ?[]const u8 = null,
    _ext4_zero_range_buf: ?[]const u8 = null,
    _task_newtask_buf: ?[]const u8 = null,
    _task_rename_buf: ?[]const u8 = null,
    _sched_process_exec_buf: ?[]const u8 = null,
    _sched_process_exit_buf: ?[]const u8 = null,
    _sched_process_fork_buf: ?[]const u8 = null,
    _sched_process_free_buf: ?[]const u8 = null,
    _sched_process_hang_buf: ?[]const u8 = null,
    _sched_process_wait_buf: ?[]const u8 = null,
    _f2fs_do_submit_bio_buf: ?[]const u8 = null,
    _f2fs_evict_inode_buf: ?[]const u8 = null,
    _f2fs_fallocate_buf: ?[]const u8 = null,
    _f2fs_get_data_block_buf: ?[]const u8 = null,
    _f2fs_get_victim_buf: ?[]const u8 = null,
    _f2fs_iget_buf: ?[]const u8 = null,
    _f2fs_iget_exit_buf: ?[]const u8 = null,
    _f2fs_new_inode_buf: ?[]const u8 = null,
    _f2fs_readpage_buf: ?[]const u8 = null,
    _f2fs_reserve_new_block_buf: ?[]const u8 = null,
    _f2fs_set_page_dirty_buf: ?[]const u8 = null,
    _f2fs_submit_write_page_buf: ?[]const u8 = null,
    _f2fs_sync_file_enter_buf: ?[]const u8 = null,
    _f2fs_sync_file_exit_buf: ?[]const u8 = null,
    _f2fs_sync_fs_buf: ?[]const u8 = null,
    _f2fs_truncate_buf: ?[]const u8 = null,
    _f2fs_truncate_blocks_enter_buf: ?[]const u8 = null,
    _f2fs_truncate_blocks_exit_buf: ?[]const u8 = null,
    _f2fs_truncate_data_blocks_range_buf: ?[]const u8 = null,
    _f2fs_truncate_inode_blocks_enter_buf: ?[]const u8 = null,
    _f2fs_truncate_inode_blocks_exit_buf: ?[]const u8 = null,
    _f2fs_truncate_node_buf: ?[]const u8 = null,
    _f2fs_truncate_nodes_enter_buf: ?[]const u8 = null,
    _f2fs_truncate_nodes_exit_buf: ?[]const u8 = null,
    _f2fs_truncate_partial_nodes_buf: ?[]const u8 = null,
    _f2fs_unlink_enter_buf: ?[]const u8 = null,
    _f2fs_unlink_exit_buf: ?[]const u8 = null,
    _f2fs_vm_page_mkwrite_buf: ?[]const u8 = null,
    _f2fs_write_begin_buf: ?[]const u8 = null,
    _f2fs_write_checkpoint_buf: ?[]const u8 = null,
    _f2fs_write_end_buf: ?[]const u8 = null,
    _alloc_pages_iommu_end_buf: ?[]const u8 = null,
    _alloc_pages_iommu_fail_buf: ?[]const u8 = null,
    _alloc_pages_iommu_start_buf: ?[]const u8 = null,
    _alloc_pages_sys_end_buf: ?[]const u8 = null,
    _alloc_pages_sys_fail_buf: ?[]const u8 = null,
    _alloc_pages_sys_start_buf: ?[]const u8 = null,
    _dma_alloc_contiguous_retry_buf: ?[]const u8 = null,
    _iommu_map_range_buf: ?[]const u8 = null,
    _iommu_sec_ptbl_map_range_end_buf: ?[]const u8 = null,
    _iommu_sec_ptbl_map_range_start_buf: ?[]const u8 = null,
    _ion_alloc_buffer_end_buf: ?[]const u8 = null,
    _ion_alloc_buffer_fail_buf: ?[]const u8 = null,
    _ion_alloc_buffer_fallback_buf: ?[]const u8 = null,
    _ion_alloc_buffer_start_buf: ?[]const u8 = null,
    _ion_cp_alloc_retry_buf: ?[]const u8 = null,
    _ion_cp_secure_buffer_end_buf: ?[]const u8 = null,
    _ion_cp_secure_buffer_start_buf: ?[]const u8 = null,
    _ion_prefetching_buf: ?[]const u8 = null,
    _ion_secure_cma_add_to_pool_end_buf: ?[]const u8 = null,
    _ion_secure_cma_add_to_pool_start_buf: ?[]const u8 = null,
    _ion_secure_cma_allocate_end_buf: ?[]const u8 = null,
    _ion_secure_cma_allocate_start_buf: ?[]const u8 = null,
    _ion_secure_cma_shrink_pool_end_buf: ?[]const u8 = null,
    _ion_secure_cma_shrink_pool_start_buf: ?[]const u8 = null,
    _kfree_buf: ?[]const u8 = null,
    _kmalloc_buf: ?[]const u8 = null,
    _kmalloc_node_buf: ?[]const u8 = null,
    _kmem_cache_alloc_buf: ?[]const u8 = null,
    _kmem_cache_alloc_node_buf: ?[]const u8 = null,
    _kmem_cache_free_buf: ?[]const u8 = null,
    _migrate_pages_end_buf: ?[]const u8 = null,
    _migrate_pages_start_buf: ?[]const u8 = null,
    _migrate_retry_buf: ?[]const u8 = null,
    _mm_page_alloc_buf: ?[]const u8 = null,
    _mm_page_alloc_extfrag_buf: ?[]const u8 = null,
    _mm_page_alloc_zone_locked_buf: ?[]const u8 = null,
    _mm_page_free_buf: ?[]const u8 = null,
    _mm_page_free_batched_buf: ?[]const u8 = null,
    _mm_page_pcpu_drain_buf: ?[]const u8 = null,
    _rss_stat_buf: ?[]const u8 = null,
    _ion_heap_shrink_buf: ?[]const u8 = null,
    _ion_heap_grow_buf: ?[]const u8 = null,
    _fence_init_buf: ?[]const u8 = null,
    _fence_destroy_buf: ?[]const u8 = null,
    _fence_enable_signal_buf: ?[]const u8 = null,
    _fence_signaled_buf: ?[]const u8 = null,
    _clk_enable_buf: ?[]const u8 = null,
    _clk_disable_buf: ?[]const u8 = null,
    _clk_set_rate_buf: ?[]const u8 = null,
    _binder_transaction_alloc_buf_buf: ?[]const u8 = null,
    _signal_deliver_buf: ?[]const u8 = null,
    _signal_generate_buf: ?[]const u8 = null,
    _oom_score_adj_update_buf: ?[]const u8 = null,
    _generic_buf: ?[]const u8 = null,
    _mm_event_record_buf: ?[]const u8 = null,
    _sys_enter_buf: ?[]const u8 = null,
    _sys_exit_buf: ?[]const u8 = null,
    _zero_buf: ?[]const u8 = null,
    _gpu_frequency_buf: ?[]const u8 = null,
    _sde_tracing_mark_write_buf: ?[]const u8 = null,
    _mark_victim_buf: ?[]const u8 = null,
    _ion_stat_buf: ?[]const u8 = null,
    _ion_buffer_create_buf: ?[]const u8 = null,
    _ion_buffer_destroy_buf: ?[]const u8 = null,
    _scm_call_start_buf: ?[]const u8 = null,
    _scm_call_end_buf: ?[]const u8 = null,
    _gpu_mem_total_buf: ?[]const u8 = null,
    _thermal_temperature_buf: ?[]const u8 = null,
    _cdev_update_buf: ?[]const u8 = null,
    _cpuhp_exit_buf: ?[]const u8 = null,
    _cpuhp_multi_enter_buf: ?[]const u8 = null,
    _cpuhp_enter_buf: ?[]const u8 = null,
    _cpuhp_latency_buf: ?[]const u8 = null,
    _fastrpc_dma_stat_buf: ?[]const u8 = null,
    _dpu_tracing_mark_write_buf: ?[]const u8 = null,
    _g2d_tracing_mark_write_buf: ?[]const u8 = null,
    _mali_tracing_mark_write_buf: ?[]const u8 = null,
    _dma_heap_stat_buf: ?[]const u8 = null,
    _cpuhp_pause_buf: ?[]const u8 = null,
    _sched_pi_setprio_buf: ?[]const u8 = null,
    _sde_sde_evtlog_buf: ?[]const u8 = null,
    _sde_sde_perf_calc_crtc_buf: ?[]const u8 = null,
    _sde_sde_perf_crtc_update_buf: ?[]const u8 = null,
    _sde_sde_perf_set_qos_luts_buf: ?[]const u8 = null,
    _sde_sde_perf_update_bus_buf: ?[]const u8 = null,
    _rss_stat_throttled_buf: ?[]const u8 = null,
    _netif_receive_skb_buf: ?[]const u8 = null,
    _net_dev_xmit_buf: ?[]const u8 = null,
    _inet_sock_set_state_buf: ?[]const u8 = null,
    _tcp_retransmit_skb_buf: ?[]const u8 = null,
    _cros_ec_sensorhub_data_buf: ?[]const u8 = null,
    _napi_gro_receive_entry_buf: ?[]const u8 = null,
    _napi_gro_receive_exit_buf: ?[]const u8 = null,
    _kfree_skb_buf: ?[]const u8 = null,
    _kvm_access_fault_buf: ?[]const u8 = null,
    _kvm_ack_irq_buf: ?[]const u8 = null,
    _kvm_age_hva_buf: ?[]const u8 = null,
    _kvm_age_page_buf: ?[]const u8 = null,
    _kvm_arm_clear_debug_buf: ?[]const u8 = null,
    _kvm_arm_set_dreg32_buf: ?[]const u8 = null,
    _kvm_arm_set_regset_buf: ?[]const u8 = null,
    _kvm_arm_setup_debug_buf: ?[]const u8 = null,
    _kvm_entry_buf: ?[]const u8 = null,
    _kvm_exit_buf: ?[]const u8 = null,
    _kvm_fpu_buf: ?[]const u8 = null,
    _kvm_get_timer_map_buf: ?[]const u8 = null,
    _kvm_guest_fault_buf: ?[]const u8 = null,
    _kvm_handle_sys_reg_buf: ?[]const u8 = null,
    _kvm_hvc_arm64_buf: ?[]const u8 = null,
    _kvm_irq_line_buf: ?[]const u8 = null,
    _kvm_mmio_buf: ?[]const u8 = null,
    _kvm_mmio_emulate_buf: ?[]const u8 = null,
    _kvm_set_guest_debug_buf: ?[]const u8 = null,
    _kvm_set_irq_buf: ?[]const u8 = null,
    _kvm_set_spte_hva_buf: ?[]const u8 = null,
    _kvm_set_way_flush_buf: ?[]const u8 = null,
    _kvm_sys_access_buf: ?[]const u8 = null,
    _kvm_test_age_hva_buf: ?[]const u8 = null,
    _kvm_timer_emulate_buf: ?[]const u8 = null,
    _kvm_timer_hrtimer_expire_buf: ?[]const u8 = null,
    _kvm_timer_restore_state_buf: ?[]const u8 = null,
    _kvm_timer_save_state_buf: ?[]const u8 = null,
    _kvm_timer_update_irq_buf: ?[]const u8 = null,
    _kvm_toggle_cache_buf: ?[]const u8 = null,
    _kvm_unmap_hva_range_buf: ?[]const u8 = null,
    _kvm_userspace_exit_buf: ?[]const u8 = null,
    _kvm_vcpu_wakeup_buf: ?[]const u8 = null,
    _kvm_wfx_arm64_buf: ?[]const u8 = null,
    _trap_reg_buf: ?[]const u8 = null,
    _vgic_update_irq_pending_buf: ?[]const u8 = null,
    _wakeup_source_activate_buf: ?[]const u8 = null,
    _wakeup_source_deactivate_buf: ?[]const u8 = null,
    _ufshcd_command_buf: ?[]const u8 = null,
    _ufshcd_clk_gating_buf: ?[]const u8 = null,
    _console_buf: ?[]const u8 = null,
    _drm_vblank_event_buf: ?[]const u8 = null,
    _drm_vblank_event_delivered_buf: ?[]const u8 = null,
    _drm_sched_job_buf: ?[]const u8 = null,
    _drm_run_job_buf: ?[]const u8 = null,
    _drm_sched_process_job_buf: ?[]const u8 = null,
    _dma_fence_init_buf: ?[]const u8 = null,
    _dma_fence_emit_buf: ?[]const u8 = null,
    _dma_fence_signaled_buf: ?[]const u8 = null,
    _dma_fence_wait_start_buf: ?[]const u8 = null,
    _dma_fence_wait_end_buf: ?[]const u8 = null,
    _f2fs_iostat_buf: ?[]const u8 = null,
    _f2fs_iostat_latency_buf: ?[]const u8 = null,
    _sched_cpu_util_cfs_buf: ?[]const u8 = null,
    _v4l2_qbuf_buf: ?[]const u8 = null,
    _v4l2_dqbuf_buf: ?[]const u8 = null,
    _vb2_v4l2_buf_queue_buf: ?[]const u8 = null,
    _vb2_v4l2_buf_done_buf: ?[]const u8 = null,
    _vb2_v4l2_qbuf_buf: ?[]const u8 = null,
    _vb2_v4l2_dqbuf_buf: ?[]const u8 = null,
    _dsi_cmd_fifo_status_buf: ?[]const u8 = null,
    _dsi_rx_buf: ?[]const u8 = null,
    _dsi_tx_buf: ?[]const u8 = null,
    _android_fs_dataread_end_buf: ?[]const u8 = null,
    _android_fs_dataread_start_buf: ?[]const u8 = null,
    _android_fs_datawrite_end_buf: ?[]const u8 = null,
    _android_fs_datawrite_start_buf: ?[]const u8 = null,
    _android_fs_fsync_end_buf: ?[]const u8 = null,
    _android_fs_fsync_start_buf: ?[]const u8 = null,
    _funcgraph_entry_buf: ?[]const u8 = null,
    _funcgraph_exit_buf: ?[]const u8 = null,
    _virtio_video_cmd_buf: ?[]const u8 = null,
    _virtio_video_cmd_done_buf: ?[]const u8 = null,
    _virtio_video_resource_queue_buf: ?[]const u8 = null,
    _virtio_video_resource_queue_done_buf: ?[]const u8 = null,
    _mm_shrink_slab_start_buf: ?[]const u8 = null,
    _mm_shrink_slab_end_buf: ?[]const u8 = null,
    _trusty_smc_buf: ?[]const u8 = null,
    _trusty_smc_done_buf: ?[]const u8 = null,
    _trusty_std_call32_buf: ?[]const u8 = null,
    _trusty_std_call32_done_buf: ?[]const u8 = null,
    _trusty_share_memory_buf: ?[]const u8 = null,
    _trusty_share_memory_done_buf: ?[]const u8 = null,
    _trusty_reclaim_memory_buf: ?[]const u8 = null,
    _trusty_reclaim_memory_done_buf: ?[]const u8 = null,
    _trusty_irq_buf: ?[]const u8 = null,
    _trusty_ipc_handle_event_buf: ?[]const u8 = null,
    _trusty_ipc_connect_buf: ?[]const u8 = null,
    _trusty_ipc_connect_end_buf: ?[]const u8 = null,
    _trusty_ipc_write_buf: ?[]const u8 = null,
    _trusty_ipc_poll_buf: ?[]const u8 = null,
    _trusty_ipc_read_buf: ?[]const u8 = null,
    _trusty_ipc_read_end_buf: ?[]const u8 = null,
    _trusty_ipc_rx_buf: ?[]const u8 = null,
    _trusty_enqueue_nop_buf: ?[]const u8 = null,
    _cma_alloc_start_buf: ?[]const u8 = null,
    _cma_alloc_info_buf: ?[]const u8 = null,
    _lwis_tracing_mark_write_buf: ?[]const u8 = null,
    _virtio_gpu_cmd_queue_buf: ?[]const u8 = null,
    _virtio_gpu_cmd_response_buf: ?[]const u8 = null,
    _mali_mali_k_c_p_u_c_q_s_s_e_t_buf: ?[]const u8 = null,
    _mali_mali_k_c_p_u_c_q_s_w_a_i_t_s_t_a_r_t_buf: ?[]const u8 = null,
    _mali_mali_k_c_p_u_c_q_s_w_a_i_t_e_n_d_buf: ?[]const u8 = null,
    _mali_mali_k_c_p_u_f_e_n_c_e_s_i_g_n_a_l_buf: ?[]const u8 = null,
    _mali_mali_k_c_p_u_f_e_n_c_e_w_a_i_t_s_t_a_r_t_buf: ?[]const u8 = null,
    _mali_mali_k_c_p_u_f_e_n_c_e_w_a_i_t_e_n_d_buf: ?[]const u8 = null,
    _hyp_enter_buf: ?[]const u8 = null,
    _hyp_exit_buf: ?[]const u8 = null,
    _host_hcall_buf: ?[]const u8 = null,
    _host_smc_buf: ?[]const u8 = null,
    _host_mem_abort_buf: ?[]const u8 = null,
    _suspend_resume_minimal_buf: ?[]const u8 = null,
    _mali_mali_c_s_f_i_n_t_e_r_r_u_p_t_s_t_a_r_t_buf: ?[]const u8 = null,
    _mali_mali_c_s_f_i_n_t_e_r_r_u_p_t_e_n_d_buf: ?[]const u8 = null,
    _samsung_tracing_mark_write_buf: ?[]const u8 = null,
    _binder_command_buf: ?[]const u8 = null,
    _binder_return_buf: ?[]const u8 = null,
    _sched_switch_with_ctrs_buf: ?[]const u8 = null,
    _gpu_work_period_buf: ?[]const u8 = null,
    _rpm_status_buf: ?[]const u8 = null,
    _panel_write_generic_buf: ?[]const u8 = null,
    _sched_migrate_task_buf: ?[]const u8 = null,
    _dpu_dsi_cmd_fifo_status_buf: ?[]const u8 = null,
    _dpu_dsi_rx_buf: ?[]const u8 = null,
    _dpu_dsi_tx_buf: ?[]const u8 = null,
    _f2fs_background_gc_buf: ?[]const u8 = null,
    _f2fs_gc_begin_buf: ?[]const u8 = null,
    _f2fs_gc_end_buf: ?[]const u8 = null,
    _fastrpc_dma_free_buf: ?[]const u8 = null,
    _fastrpc_dma_alloc_buf: ?[]const u8 = null,
    _fastrpc_dma_unmap_buf: ?[]const u8 = null,
    _fastrpc_dma_map_buf: ?[]const u8 = null,
    _google_icc_event_buf: ?[]const u8 = null,
    _google_irm_event_buf: ?[]const u8 = null,
    _device_pm_callback_start_buf: ?[]const u8 = null,
    _device_pm_callback_end_buf: ?[]const u8 = null,
    _thermal_exynos_acpm_bulk_buf: ?[]const u8 = null,
    _thermal_exynos_acpm_high_overhead_buf: ?[]const u8 = null,
    _dcvsh_freq_buf: ?[]const u8 = null,
    _kgsl_gpu_frequency_buf: ?[]const u8 = null,
    _mali_mali_p_m_m_c_u_h_c_t_l_c_o_r_e_s_d_o_w_n_s_c_a_l_e_n_o_t_i_f_y_p_e_n_d_buf: ?[]const u8 = null,
    _mali_mali_p_m_m_c_u_h_c_t_l_c_o_r_e_s_n_o_t_i_f_y_p_e_n_d_buf: ?[]const u8 = null,
    _mali_mali_p_m_m_c_u_h_c_t_l_c_o_r_e_i_n_a_c_t_i_v_e_p_e_n_d_buf: ?[]const u8 = null,
    _mali_mali_p_m_m_c_u_h_c_t_l_m_c_u_o_n_r_e_c_h_e_c_k_buf: ?[]const u8 = null,
    _mali_mali_p_m_m_c_u_h_c_t_l_s_h_a_d_e_r_s_c_o_r_e_o_f_f_p_e_n_d_buf: ?[]const u8 = null,
    _mali_mali_p_m_m_c_u_h_c_t_l_s_h_a_d_e_r_s_p_e_n_d_o_f_f_buf: ?[]const u8 = null,
    _mali_mali_p_m_m_c_u_h_c_t_l_s_h_a_d_e_r_s_p_e_n_d_o_n_buf: ?[]const u8 = null,
    _mali_mali_p_m_m_c_u_h_c_t_l_s_h_a_d_e_r_s_r_e_a_d_y_o_f_f_buf: ?[]const u8 = null,
    _mali_mali_p_m_m_c_u_i_n_s_l_e_e_p_buf: ?[]const u8 = null,
    _mali_mali_p_m_m_c_u_o_f_f_buf: ?[]const u8 = null,
    _mali_mali_p_m_m_c_u_o_n_buf: ?[]const u8 = null,
    _mali_mali_p_m_m_c_u_o_n_c_o_r_e_a_t_t_r_u_p_d_a_t_e_p_e_n_d_buf: ?[]const u8 = null,
    _mali_mali_p_m_m_c_u_o_n_g_l_b_r_e_i_n_i_t_p_e_n_d_buf: ?[]const u8 = null,
    _mali_mali_p_m_m_c_u_o_n_h_a_l_t_buf: ?[]const u8 = null,
    _mali_mali_p_m_m_c_u_o_n_h_w_c_n_t_d_i_s_a_b_l_e_buf: ?[]const u8 = null,
    _mali_mali_p_m_m_c_u_o_n_h_w_c_n_t_e_n_a_b_l_e_buf: ?[]const u8 = null,
    _mali_mali_p_m_m_c_u_o_n_p_e_n_d_h_a_l_t_buf: ?[]const u8 = null,
    _mali_mali_p_m_m_c_u_o_n_p_e_n_d_s_l_e_e_p_buf: ?[]const u8 = null,
    _mali_mali_p_m_m_c_u_o_n_s_l_e_e_p_i_n_i_t_i_a_t_e_buf: ?[]const u8 = null,
    _mali_mali_p_m_m_c_u_p_e_n_d_o_f_f_buf: ?[]const u8 = null,
    _mali_mali_p_m_m_c_u_p_e_n_d_o_n_r_e_l_o_a_d_buf: ?[]const u8 = null,
    _mali_mali_p_m_m_c_u_p_o_w_e_r_d_o_w_n_buf: ?[]const u8 = null,
    _mali_mali_p_m_m_c_u_r_e_s_e_t_w_a_i_t_buf: ?[]const u8 = null,
    _bcl_irq_trigger_buf: ?[]const u8 = null,
    _kgsl_adreno_cmdbatch_queued_buf: ?[]const u8 = null,
    _kgsl_adreno_cmdbatch_submitted_buf: ?[]const u8 = null,
    _kgsl_adreno_cmdbatch_sync_buf: ?[]const u8 = null,
    _kgsl_adreno_cmdbatch_retired_buf: ?[]const u8 = null,
    _pixel_mm_kswapd_wake_buf: ?[]const u8 = null,
    _pixel_mm_kswapd_done_buf: ?[]const u8 = null,
    _sched_wakeup_task_attr_buf: ?[]const u8 = null,
    _devfreq_frequency_buf: ?[]const u8 = null,
    _kprobe_event_buf: ?[]const u8 = null,
    _param_set_value_cpm_buf: ?[]const u8 = null,
    _do_sys_open_buf: ?[]const u8 = null,
    _open_exec_buf: ?[]const u8 = null,
    _block_io_start_buf: ?[]const u8 = null,
    _block_io_done_buf: ?[]const u8 = null,
    _mali_gpu_power_state_buf: ?[]const u8 = null,
    _dpu_disp_dpu_underrun_buf: ?[]const u8 = null,
    _dpu_disp_vblank_irq_enable_buf: ?[]const u8 = null,
    _hrtimer_start_buf: ?[]const u8 = null,
    _hrtimer_cancel_buf: ?[]const u8 = null,
    _hrtimer_expire_entry_buf: ?[]const u8 = null,
    _hrtimer_expire_exit_buf: ?[]const u8 = null,
    _timer_start_buf: ?[]const u8 = null,
    _timer_cancel_buf: ?[]const u8 = null,
    _timer_expire_entry_buf: ?[]const u8 = null,
    _timer_expire_exit_buf: ?[]const u8 = null,
    _local_timer_entry_buf: ?[]const u8 = null,
    _local_timer_exit_buf: ?[]const u8 = null,
    _dwc3_alloc_request_buf: ?[]const u8 = null,
    _dwc3_complete_trb_buf: ?[]const u8 = null,
    _dwc3_ctrl_req_buf: ?[]const u8 = null,
    _dwc3_ep_dequeue_buf: ?[]const u8 = null,
    _dwc3_ep_queue_buf: ?[]const u8 = null,
    _dwc3_event_buf: ?[]const u8 = null,
    _dwc3_free_request_buf: ?[]const u8 = null,
    _dwc3_gadget_ep_cmd_buf: ?[]const u8 = null,
    _dwc3_gadget_ep_disable_buf: ?[]const u8 = null,
    _dwc3_gadget_ep_enable_buf: ?[]const u8 = null,
    _dwc3_gadget_generic_cmd_buf: ?[]const u8 = null,
    _dwc3_gadget_giveback_buf: ?[]const u8 = null,
    _dwc3_prepare_trb_buf: ?[]const u8 = null,
    _dwc3_readl_buf: ?[]const u8 = null,
    _dwc3_writel_buf: ?[]const u8 = null,
    _cma_alloc_finish_buf: ?[]const u8 = null,
    _mm_alloc_contig_migrate_range_info_buf: ?[]const u8 = null,
    _host_ffa_call_buf: ?[]const u8 = null,
    _dmabuf_rss_stat_buf: ?[]const u8 = null,
    _iommu_idmap_buf: ?[]const u8 = null,
    _psci_mem_protect_buf: ?[]const u8 = null,
    _hypervisor_host_hcall_buf: ?[]const u8 = null,
    _hypervisor_host_smc_buf: ?[]const u8 = null,
    _hypervisor_hyp_exit_buf: ?[]const u8 = null,
    _hypervisor_iommu_idmap_buf: ?[]const u8 = null,
    _hypervisor_psci_mem_protect_buf: ?[]const u8 = null,
    _hypervisor_host_mem_abort_buf: ?[]const u8 = null,
    _hypervisor_hyp_enter_buf: ?[]const u8 = null,
    _hypervisor_iommu_idmap_complete_buf: ?[]const u8 = null,
    _hypervisor_vcpu_illegal_trap_buf: ?[]const u8 = null,
    _drm_sched_job_add_dep_buf: ?[]const u8 = null,
    _drm_sched_job_done_buf: ?[]const u8 = null,
    _drm_sched_job_queue_buf: ?[]const u8 = null,
    _drm_sched_job_run_buf: ?[]const u8 = null,
    _drm_sched_job_unschedulable_buf: ?[]const u8 = null,
    _fwtp_perfetto_counter_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!FtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = FtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                FtraceEventWire.TIMESTAMP_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._timestamp = result.value;
                },
                FtraceEventWire.PID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._pid = result.value;
                },
                FtraceEventWire.COMMON_FLAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._common_flags = result.value;
                },
                FtraceEventWire.PRINT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._print_buf = result.value;
                },
                FtraceEventWire.SCHED_SWITCH_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._sched_switch_buf = result.value;
                },
                FtraceEventWire.CPU_FREQUENCY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cpu_frequency_buf = result.value;
                },
                FtraceEventWire.CPU_FREQUENCY_LIMITS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cpu_frequency_limits_buf = result.value;
                },
                FtraceEventWire.CPU_IDLE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cpu_idle_buf = result.value;
                },
                FtraceEventWire.CLOCK_ENABLE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._clock_enable_buf = result.value;
                },
                FtraceEventWire.CLOCK_DISABLE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._clock_disable_buf = result.value;
                },
                FtraceEventWire.CLOCK_SET_RATE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._clock_set_rate_buf = result.value;
                },
                FtraceEventWire.SCHED_WAKEUP_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._sched_wakeup_buf = result.value;
                },
                FtraceEventWire.SCHED_BLOCKED_REASON_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._sched_blocked_reason_buf = result.value;
                },
                FtraceEventWire.SCHED_CPU_HOTPLUG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._sched_cpu_hotplug_buf = result.value;
                },
                FtraceEventWire.SCHED_WAKING_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._sched_waking_buf = result.value;
                },
                FtraceEventWire.IPI_ENTRY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ipi_entry_buf = result.value;
                },
                FtraceEventWire.IPI_EXIT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ipi_exit_buf = result.value;
                },
                FtraceEventWire.IPI_RAISE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ipi_raise_buf = result.value;
                },
                FtraceEventWire.SOFTIRQ_ENTRY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._softirq_entry_buf = result.value;
                },
                FtraceEventWire.SOFTIRQ_EXIT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._softirq_exit_buf = result.value;
                },
                FtraceEventWire.SOFTIRQ_RAISE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._softirq_raise_buf = result.value;
                },
                FtraceEventWire.I2C_READ_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._i2c_read_buf = result.value;
                },
                FtraceEventWire.I2C_WRITE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._i2c_write_buf = result.value;
                },
                FtraceEventWire.I2C_RESULT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._i2c_result_buf = result.value;
                },
                FtraceEventWire.I2C_REPLY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._i2c_reply_buf = result.value;
                },
                FtraceEventWire.SMBUS_READ_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._smbus_read_buf = result.value;
                },
                FtraceEventWire.SMBUS_WRITE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._smbus_write_buf = result.value;
                },
                FtraceEventWire.SMBUS_RESULT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._smbus_result_buf = result.value;
                },
                FtraceEventWire.SMBUS_REPLY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._smbus_reply_buf = result.value;
                },
                FtraceEventWire.LOWMEMORY_KILL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._lowmemory_kill_buf = result.value;
                },
                FtraceEventWire.IRQ_HANDLER_ENTRY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._irq_handler_entry_buf = result.value;
                },
                FtraceEventWire.IRQ_HANDLER_EXIT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._irq_handler_exit_buf = result.value;
                },
                FtraceEventWire.SYNC_PT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._sync_pt_buf = result.value;
                },
                FtraceEventWire.SYNC_TIMELINE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._sync_timeline_buf = result.value;
                },
                FtraceEventWire.SYNC_WAIT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._sync_wait_buf = result.value;
                },
                FtraceEventWire.EXT4_DA_WRITE_BEGIN_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_da_write_begin_buf = result.value;
                },
                FtraceEventWire.EXT4_DA_WRITE_END_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_da_write_end_buf = result.value;
                },
                FtraceEventWire.EXT4_SYNC_FILE_ENTER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_sync_file_enter_buf = result.value;
                },
                FtraceEventWire.EXT4_SYNC_FILE_EXIT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_sync_file_exit_buf = result.value;
                },
                FtraceEventWire.BLOCK_RQ_ISSUE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._block_rq_issue_buf = result.value;
                },
                FtraceEventWire.MM_VMSCAN_DIRECT_RECLAIM_BEGIN_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mm_vmscan_direct_reclaim_begin_buf = result.value;
                },
                FtraceEventWire.MM_VMSCAN_DIRECT_RECLAIM_END_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mm_vmscan_direct_reclaim_end_buf = result.value;
                },
                FtraceEventWire.MM_VMSCAN_KSWAPD_WAKE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mm_vmscan_kswapd_wake_buf = result.value;
                },
                FtraceEventWire.MM_VMSCAN_KSWAPD_SLEEP_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mm_vmscan_kswapd_sleep_buf = result.value;
                },
                FtraceEventWire.BINDER_TRANSACTION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._binder_transaction_buf = result.value;
                },
                FtraceEventWire.BINDER_TRANSACTION_RECEIVED_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._binder_transaction_received_buf = result.value;
                },
                FtraceEventWire.BINDER_SET_PRIORITY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._binder_set_priority_buf = result.value;
                },
                FtraceEventWire.BINDER_LOCK_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._binder_lock_buf = result.value;
                },
                FtraceEventWire.BINDER_LOCKED_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._binder_locked_buf = result.value;
                },
                FtraceEventWire.BINDER_UNLOCK_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._binder_unlock_buf = result.value;
                },
                FtraceEventWire.WORKQUEUE_ACTIVATE_WORK_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._workqueue_activate_work_buf = result.value;
                },
                FtraceEventWire.WORKQUEUE_EXECUTE_END_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._workqueue_execute_end_buf = result.value;
                },
                FtraceEventWire.WORKQUEUE_EXECUTE_START_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._workqueue_execute_start_buf = result.value;
                },
                FtraceEventWire.WORKQUEUE_QUEUE_WORK_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._workqueue_queue_work_buf = result.value;
                },
                FtraceEventWire.REGULATOR_DISABLE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._regulator_disable_buf = result.value;
                },
                FtraceEventWire.REGULATOR_DISABLE_COMPLETE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._regulator_disable_complete_buf = result.value;
                },
                FtraceEventWire.REGULATOR_ENABLE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._regulator_enable_buf = result.value;
                },
                FtraceEventWire.REGULATOR_ENABLE_COMPLETE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._regulator_enable_complete_buf = result.value;
                },
                FtraceEventWire.REGULATOR_ENABLE_DELAY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._regulator_enable_delay_buf = result.value;
                },
                FtraceEventWire.REGULATOR_SET_VOLTAGE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._regulator_set_voltage_buf = result.value;
                },
                FtraceEventWire.REGULATOR_SET_VOLTAGE_COMPLETE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._regulator_set_voltage_complete_buf = result.value;
                },
                FtraceEventWire.CGROUP_ATTACH_TASK_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cgroup_attach_task_buf = result.value;
                },
                FtraceEventWire.CGROUP_MKDIR_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cgroup_mkdir_buf = result.value;
                },
                FtraceEventWire.CGROUP_REMOUNT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cgroup_remount_buf = result.value;
                },
                FtraceEventWire.CGROUP_RMDIR_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cgroup_rmdir_buf = result.value;
                },
                FtraceEventWire.CGROUP_TRANSFER_TASKS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cgroup_transfer_tasks_buf = result.value;
                },
                FtraceEventWire.CGROUP_DESTROY_ROOT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cgroup_destroy_root_buf = result.value;
                },
                FtraceEventWire.CGROUP_RELEASE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cgroup_release_buf = result.value;
                },
                FtraceEventWire.CGROUP_RENAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cgroup_rename_buf = result.value;
                },
                FtraceEventWire.CGROUP_SETUP_ROOT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cgroup_setup_root_buf = result.value;
                },
                FtraceEventWire.MDP_CMD_KICKOFF_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mdp_cmd_kickoff_buf = result.value;
                },
                FtraceEventWire.MDP_COMMIT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mdp_commit_buf = result.value;
                },
                FtraceEventWire.MDP_PERF_SET_OT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mdp_perf_set_ot_buf = result.value;
                },
                FtraceEventWire.MDP_SSPP_CHANGE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mdp_sspp_change_buf = result.value;
                },
                FtraceEventWire.TRACING_MARK_WRITE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._tracing_mark_write_buf = result.value;
                },
                FtraceEventWire.MDP_CMD_PINGPONG_DONE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mdp_cmd_pingpong_done_buf = result.value;
                },
                FtraceEventWire.MDP_COMPARE_BW_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mdp_compare_bw_buf = result.value;
                },
                FtraceEventWire.MDP_PERF_SET_PANIC_LUTS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mdp_perf_set_panic_luts_buf = result.value;
                },
                FtraceEventWire.MDP_SSPP_SET_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mdp_sspp_set_buf = result.value;
                },
                FtraceEventWire.MDP_CMD_READPTR_DONE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mdp_cmd_readptr_done_buf = result.value;
                },
                FtraceEventWire.MDP_MISR_CRC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mdp_misr_crc_buf = result.value;
                },
                FtraceEventWire.MDP_PERF_SET_QOS_LUTS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mdp_perf_set_qos_luts_buf = result.value;
                },
                FtraceEventWire.MDP_TRACE_COUNTER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mdp_trace_counter_buf = result.value;
                },
                FtraceEventWire.MDP_CMD_RELEASE_BW_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mdp_cmd_release_bw_buf = result.value;
                },
                FtraceEventWire.MDP_MIXER_UPDATE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mdp_mixer_update_buf = result.value;
                },
                FtraceEventWire.MDP_PERF_SET_WM_LEVELS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mdp_perf_set_wm_levels_buf = result.value;
                },
                FtraceEventWire.MDP_VIDEO_UNDERRUN_DONE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mdp_video_underrun_done_buf = result.value;
                },
                FtraceEventWire.MDP_CMD_WAIT_PINGPONG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mdp_cmd_wait_pingpong_buf = result.value;
                },
                FtraceEventWire.MDP_PERF_PREFILL_CALC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mdp_perf_prefill_calc_buf = result.value;
                },
                FtraceEventWire.MDP_PERF_UPDATE_BUS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mdp_perf_update_bus_buf = result.value;
                },
                FtraceEventWire.ROTATOR_BW_AO_AS_CONTEXT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._rotator_bw_ao_as_context_buf = result.value;
                },
                FtraceEventWire.MM_FILEMAP_ADD_TO_PAGE_CACHE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mm_filemap_add_to_page_cache_buf = result.value;
                },
                FtraceEventWire.MM_FILEMAP_DELETE_FROM_PAGE_CACHE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mm_filemap_delete_from_page_cache_buf = result.value;
                },
                FtraceEventWire.MM_COMPACTION_BEGIN_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mm_compaction_begin_buf = result.value;
                },
                FtraceEventWire.MM_COMPACTION_DEFER_COMPACTION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mm_compaction_defer_compaction_buf = result.value;
                },
                FtraceEventWire.MM_COMPACTION_DEFERRED_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mm_compaction_deferred_buf = result.value;
                },
                FtraceEventWire.MM_COMPACTION_DEFER_RESET_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mm_compaction_defer_reset_buf = result.value;
                },
                FtraceEventWire.MM_COMPACTION_END_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mm_compaction_end_buf = result.value;
                },
                FtraceEventWire.MM_COMPACTION_FINISHED_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mm_compaction_finished_buf = result.value;
                },
                FtraceEventWire.MM_COMPACTION_ISOLATE_FREEPAGES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mm_compaction_isolate_freepages_buf = result.value;
                },
                FtraceEventWire.MM_COMPACTION_ISOLATE_MIGRATEPAGES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mm_compaction_isolate_migratepages_buf = result.value;
                },
                FtraceEventWire.MM_COMPACTION_KCOMPACTD_SLEEP_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mm_compaction_kcompactd_sleep_buf = result.value;
                },
                FtraceEventWire.MM_COMPACTION_KCOMPACTD_WAKE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mm_compaction_kcompactd_wake_buf = result.value;
                },
                FtraceEventWire.MM_COMPACTION_MIGRATEPAGES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mm_compaction_migratepages_buf = result.value;
                },
                FtraceEventWire.MM_COMPACTION_SUITABLE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mm_compaction_suitable_buf = result.value;
                },
                FtraceEventWire.MM_COMPACTION_TRY_TO_COMPACT_PAGES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mm_compaction_try_to_compact_pages_buf = result.value;
                },
                FtraceEventWire.MM_COMPACTION_WAKEUP_KCOMPACTD_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mm_compaction_wakeup_kcompactd_buf = result.value;
                },
                FtraceEventWire.SUSPEND_RESUME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._suspend_resume_buf = result.value;
                },
                FtraceEventWire.SCHED_WAKEUP_NEW_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._sched_wakeup_new_buf = result.value;
                },
                FtraceEventWire.BLOCK_BIO_BACKMERGE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._block_bio_backmerge_buf = result.value;
                },
                FtraceEventWire.BLOCK_BIO_BOUNCE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._block_bio_bounce_buf = result.value;
                },
                FtraceEventWire.BLOCK_BIO_COMPLETE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._block_bio_complete_buf = result.value;
                },
                FtraceEventWire.BLOCK_BIO_FRONTMERGE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._block_bio_frontmerge_buf = result.value;
                },
                FtraceEventWire.BLOCK_BIO_QUEUE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._block_bio_queue_buf = result.value;
                },
                FtraceEventWire.BLOCK_BIO_REMAP_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._block_bio_remap_buf = result.value;
                },
                FtraceEventWire.BLOCK_DIRTY_BUFFER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._block_dirty_buffer_buf = result.value;
                },
                FtraceEventWire.BLOCK_GETRQ_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._block_getrq_buf = result.value;
                },
                FtraceEventWire.BLOCK_PLUG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._block_plug_buf = result.value;
                },
                FtraceEventWire.BLOCK_RQ_ABORT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._block_rq_abort_buf = result.value;
                },
                FtraceEventWire.BLOCK_RQ_COMPLETE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._block_rq_complete_buf = result.value;
                },
                FtraceEventWire.BLOCK_RQ_INSERT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._block_rq_insert_buf = result.value;
                },
                FtraceEventWire.BLOCK_RQ_REMAP_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._block_rq_remap_buf = result.value;
                },
                FtraceEventWire.BLOCK_RQ_REQUEUE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._block_rq_requeue_buf = result.value;
                },
                FtraceEventWire.BLOCK_SLEEPRQ_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._block_sleeprq_buf = result.value;
                },
                FtraceEventWire.BLOCK_SPLIT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._block_split_buf = result.value;
                },
                FtraceEventWire.BLOCK_TOUCH_BUFFER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._block_touch_buffer_buf = result.value;
                },
                FtraceEventWire.BLOCK_UNPLUG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._block_unplug_buf = result.value;
                },
                FtraceEventWire.EXT4_ALLOC_DA_BLOCKS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_alloc_da_blocks_buf = result.value;
                },
                FtraceEventWire.EXT4_ALLOCATE_BLOCKS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_allocate_blocks_buf = result.value;
                },
                FtraceEventWire.EXT4_ALLOCATE_INODE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_allocate_inode_buf = result.value;
                },
                FtraceEventWire.EXT4_BEGIN_ORDERED_TRUNCATE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_begin_ordered_truncate_buf = result.value;
                },
                FtraceEventWire.EXT4_COLLAPSE_RANGE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_collapse_range_buf = result.value;
                },
                FtraceEventWire.EXT4_DA_RELEASE_SPACE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_da_release_space_buf = result.value;
                },
                FtraceEventWire.EXT4_DA_RESERVE_SPACE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_da_reserve_space_buf = result.value;
                },
                FtraceEventWire.EXT4_DA_UPDATE_RESERVE_SPACE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_da_update_reserve_space_buf = result.value;
                },
                FtraceEventWire.EXT4_DA_WRITE_PAGES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_da_write_pages_buf = result.value;
                },
                FtraceEventWire.EXT4_DA_WRITE_PAGES_EXTENT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_da_write_pages_extent_buf = result.value;
                },
                FtraceEventWire.EXT4_DIRECT_IO_ENTER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_direct_i_o_enter_buf = result.value;
                },
                FtraceEventWire.EXT4_DIRECT_IO_EXIT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_direct_i_o_exit_buf = result.value;
                },
                FtraceEventWire.EXT4_DISCARD_BLOCKS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_discard_blocks_buf = result.value;
                },
                FtraceEventWire.EXT4_DISCARD_PREALLOCATIONS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_discard_preallocations_buf = result.value;
                },
                FtraceEventWire.EXT4_DROP_INODE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_drop_inode_buf = result.value;
                },
                FtraceEventWire.EXT4_ES_CACHE_EXTENT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_es_cache_extent_buf = result.value;
                },
                FtraceEventWire.EXT4_ES_FIND_DELAYED_EXTENT_RANGE_ENTER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_es_find_delayed_extent_range_enter_buf = result.value;
                },
                FtraceEventWire.EXT4_ES_FIND_DELAYED_EXTENT_RANGE_EXIT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_es_find_delayed_extent_range_exit_buf = result.value;
                },
                FtraceEventWire.EXT4_ES_INSERT_EXTENT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_es_insert_extent_buf = result.value;
                },
                FtraceEventWire.EXT4_ES_LOOKUP_EXTENT_ENTER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_es_lookup_extent_enter_buf = result.value;
                },
                FtraceEventWire.EXT4_ES_LOOKUP_EXTENT_EXIT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_es_lookup_extent_exit_buf = result.value;
                },
                FtraceEventWire.EXT4_ES_REMOVE_EXTENT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_es_remove_extent_buf = result.value;
                },
                FtraceEventWire.EXT4_ES_SHRINK_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_es_shrink_buf = result.value;
                },
                FtraceEventWire.EXT4_ES_SHRINK_COUNT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_es_shrink_count_buf = result.value;
                },
                FtraceEventWire.EXT4_ES_SHRINK_SCAN_ENTER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_es_shrink_scan_enter_buf = result.value;
                },
                FtraceEventWire.EXT4_ES_SHRINK_SCAN_EXIT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_es_shrink_scan_exit_buf = result.value;
                },
                FtraceEventWire.EXT4_EVICT_INODE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_evict_inode_buf = result.value;
                },
                FtraceEventWire.EXT4_EXT_CONVERT_TO_INITIALIZED_ENTER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_ext_convert_to_initialized_enter_buf = result.value;
                },
                FtraceEventWire.EXT4_EXT_CONVERT_TO_INITIALIZED_FASTPATH_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_ext_convert_to_initialized_fastpath_buf = result.value;
                },
                FtraceEventWire.EXT4_EXT_HANDLE_UNWRITTEN_EXTENTS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_ext_handle_unwritten_extents_buf = result.value;
                },
                FtraceEventWire.EXT4_EXT_IN_CACHE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_ext_in_cache_buf = result.value;
                },
                FtraceEventWire.EXT4_EXT_LOAD_EXTENT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_ext_load_extent_buf = result.value;
                },
                FtraceEventWire.EXT4_EXT_MAP_BLOCKS_ENTER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_ext_map_blocks_enter_buf = result.value;
                },
                FtraceEventWire.EXT4_EXT_MAP_BLOCKS_EXIT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_ext_map_blocks_exit_buf = result.value;
                },
                FtraceEventWire.EXT4_EXT_PUT_IN_CACHE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_ext_put_in_cache_buf = result.value;
                },
                FtraceEventWire.EXT4_EXT_REMOVE_SPACE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_ext_remove_space_buf = result.value;
                },
                FtraceEventWire.EXT4_EXT_REMOVE_SPACE_DONE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_ext_remove_space_done_buf = result.value;
                },
                FtraceEventWire.EXT4_EXT_RM_IDX_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_ext_rm_idx_buf = result.value;
                },
                FtraceEventWire.EXT4_EXT_RM_LEAF_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_ext_rm_leaf_buf = result.value;
                },
                FtraceEventWire.EXT4_EXT_SHOW_EXTENT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_ext_show_extent_buf = result.value;
                },
                FtraceEventWire.EXT4_FALLOCATE_ENTER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_fallocate_enter_buf = result.value;
                },
                FtraceEventWire.EXT4_FALLOCATE_EXIT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_fallocate_exit_buf = result.value;
                },
                FtraceEventWire.EXT4_FIND_DELALLOC_RANGE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_find_delalloc_range_buf = result.value;
                },
                FtraceEventWire.EXT4_FORGET_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_forget_buf = result.value;
                },
                FtraceEventWire.EXT4_FREE_BLOCKS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_free_blocks_buf = result.value;
                },
                FtraceEventWire.EXT4_FREE_INODE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_free_inode_buf = result.value;
                },
                FtraceEventWire.EXT4_GET_IMPLIED_CLUSTER_ALLOC_EXIT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_get_implied_cluster_alloc_exit_buf = result.value;
                },
                FtraceEventWire.EXT4_GET_RESERVED_CLUSTER_ALLOC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_get_reserved_cluster_alloc_buf = result.value;
                },
                FtraceEventWire.EXT4_IND_MAP_BLOCKS_ENTER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_ind_map_blocks_enter_buf = result.value;
                },
                FtraceEventWire.EXT4_IND_MAP_BLOCKS_EXIT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_ind_map_blocks_exit_buf = result.value;
                },
                FtraceEventWire.EXT4_INSERT_RANGE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_insert_range_buf = result.value;
                },
                FtraceEventWire.EXT4_INVALIDATEPAGE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_invalidatepage_buf = result.value;
                },
                FtraceEventWire.EXT4_JOURNAL_START_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_journal_start_buf = result.value;
                },
                FtraceEventWire.EXT4_JOURNAL_START_RESERVED_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_journal_start_reserved_buf = result.value;
                },
                FtraceEventWire.EXT4_JOURNALLED_INVALIDATEPAGE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_journalled_invalidatepage_buf = result.value;
                },
                FtraceEventWire.EXT4_JOURNALLED_WRITE_END_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_journalled_write_end_buf = result.value;
                },
                FtraceEventWire.EXT4_LOAD_INODE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_load_inode_buf = result.value;
                },
                FtraceEventWire.EXT4_LOAD_INODE_BITMAP_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_load_inode_bitmap_buf = result.value;
                },
                FtraceEventWire.EXT4_MARK_INODE_DIRTY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_mark_inode_dirty_buf = result.value;
                },
                FtraceEventWire.EXT4_MB_BITMAP_LOAD_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_mb_bitmap_load_buf = result.value;
                },
                FtraceEventWire.EXT4_MB_BUDDY_BITMAP_LOAD_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_mb_buddy_bitmap_load_buf = result.value;
                },
                FtraceEventWire.EXT4_MB_DISCARD_PREALLOCATIONS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_mb_discard_preallocations_buf = result.value;
                },
                FtraceEventWire.EXT4_MB_NEW_GROUP_PA_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_mb_new_group_pa_buf = result.value;
                },
                FtraceEventWire.EXT4_MB_NEW_INODE_PA_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_mb_new_inode_pa_buf = result.value;
                },
                FtraceEventWire.EXT4_MB_RELEASE_GROUP_PA_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_mb_release_group_pa_buf = result.value;
                },
                FtraceEventWire.EXT4_MB_RELEASE_INODE_PA_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_mb_release_inode_pa_buf = result.value;
                },
                FtraceEventWire.EXT4_MBALLOC_ALLOC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_mballoc_alloc_buf = result.value;
                },
                FtraceEventWire.EXT4_MBALLOC_DISCARD_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_mballoc_discard_buf = result.value;
                },
                FtraceEventWire.EXT4_MBALLOC_FREE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_mballoc_free_buf = result.value;
                },
                FtraceEventWire.EXT4_MBALLOC_PREALLOC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_mballoc_prealloc_buf = result.value;
                },
                FtraceEventWire.EXT4_OTHER_INODE_UPDATE_TIME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_other_inode_update_time_buf = result.value;
                },
                FtraceEventWire.EXT4_PUNCH_HOLE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_punch_hole_buf = result.value;
                },
                FtraceEventWire.EXT4_READ_BLOCK_BITMAP_LOAD_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_read_block_bitmap_load_buf = result.value;
                },
                FtraceEventWire.EXT4_READPAGE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_readpage_buf = result.value;
                },
                FtraceEventWire.EXT4_RELEASEPAGE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_releasepage_buf = result.value;
                },
                FtraceEventWire.EXT4_REMOVE_BLOCKS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_remove_blocks_buf = result.value;
                },
                FtraceEventWire.EXT4_REQUEST_BLOCKS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_request_blocks_buf = result.value;
                },
                FtraceEventWire.EXT4_REQUEST_INODE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_request_inode_buf = result.value;
                },
                FtraceEventWire.EXT4_SYNC_FS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_sync_fs_buf = result.value;
                },
                FtraceEventWire.EXT4_TRIM_ALL_FREE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_trim_all_free_buf = result.value;
                },
                FtraceEventWire.EXT4_TRIM_EXTENT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_trim_extent_buf = result.value;
                },
                FtraceEventWire.EXT4_TRUNCATE_ENTER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_truncate_enter_buf = result.value;
                },
                FtraceEventWire.EXT4_TRUNCATE_EXIT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_truncate_exit_buf = result.value;
                },
                FtraceEventWire.EXT4_UNLINK_ENTER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_unlink_enter_buf = result.value;
                },
                FtraceEventWire.EXT4_UNLINK_EXIT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_unlink_exit_buf = result.value;
                },
                FtraceEventWire.EXT4_WRITE_BEGIN_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_write_begin_buf = result.value;
                },
                FtraceEventWire.EXT4_WRITE_END_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_write_end_buf = result.value;
                },
                FtraceEventWire.EXT4_WRITEPAGE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_writepage_buf = result.value;
                },
                FtraceEventWire.EXT4_WRITEPAGES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_writepages_buf = result.value;
                },
                FtraceEventWire.EXT4_WRITEPAGES_RESULT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_writepages_result_buf = result.value;
                },
                FtraceEventWire.EXT4_ZERO_RANGE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ext4_zero_range_buf = result.value;
                },
                FtraceEventWire.TASK_NEWTASK_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._task_newtask_buf = result.value;
                },
                FtraceEventWire.TASK_RENAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._task_rename_buf = result.value;
                },
                FtraceEventWire.SCHED_PROCESS_EXEC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._sched_process_exec_buf = result.value;
                },
                FtraceEventWire.SCHED_PROCESS_EXIT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._sched_process_exit_buf = result.value;
                },
                FtraceEventWire.SCHED_PROCESS_FORK_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._sched_process_fork_buf = result.value;
                },
                FtraceEventWire.SCHED_PROCESS_FREE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._sched_process_free_buf = result.value;
                },
                FtraceEventWire.SCHED_PROCESS_HANG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._sched_process_hang_buf = result.value;
                },
                FtraceEventWire.SCHED_PROCESS_WAIT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._sched_process_wait_buf = result.value;
                },
                FtraceEventWire.F2FS_DO_SUBMIT_BIO_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._f2fs_do_submit_bio_buf = result.value;
                },
                FtraceEventWire.F2FS_EVICT_INODE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._f2fs_evict_inode_buf = result.value;
                },
                FtraceEventWire.F2FS_FALLOCATE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._f2fs_fallocate_buf = result.value;
                },
                FtraceEventWire.F2FS_GET_DATA_BLOCK_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._f2fs_get_data_block_buf = result.value;
                },
                FtraceEventWire.F2FS_GET_VICTIM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._f2fs_get_victim_buf = result.value;
                },
                FtraceEventWire.F2FS_IGET_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._f2fs_iget_buf = result.value;
                },
                FtraceEventWire.F2FS_IGET_EXIT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._f2fs_iget_exit_buf = result.value;
                },
                FtraceEventWire.F2FS_NEW_INODE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._f2fs_new_inode_buf = result.value;
                },
                FtraceEventWire.F2FS_READPAGE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._f2fs_readpage_buf = result.value;
                },
                FtraceEventWire.F2FS_RESERVE_NEW_BLOCK_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._f2fs_reserve_new_block_buf = result.value;
                },
                FtraceEventWire.F2FS_SET_PAGE_DIRTY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._f2fs_set_page_dirty_buf = result.value;
                },
                FtraceEventWire.F2FS_SUBMIT_WRITE_PAGE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._f2fs_submit_write_page_buf = result.value;
                },
                FtraceEventWire.F2FS_SYNC_FILE_ENTER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._f2fs_sync_file_enter_buf = result.value;
                },
                FtraceEventWire.F2FS_SYNC_FILE_EXIT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._f2fs_sync_file_exit_buf = result.value;
                },
                FtraceEventWire.F2FS_SYNC_FS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._f2fs_sync_fs_buf = result.value;
                },
                FtraceEventWire.F2FS_TRUNCATE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._f2fs_truncate_buf = result.value;
                },
                FtraceEventWire.F2FS_TRUNCATE_BLOCKS_ENTER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._f2fs_truncate_blocks_enter_buf = result.value;
                },
                FtraceEventWire.F2FS_TRUNCATE_BLOCKS_EXIT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._f2fs_truncate_blocks_exit_buf = result.value;
                },
                FtraceEventWire.F2FS_TRUNCATE_DATA_BLOCKS_RANGE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._f2fs_truncate_data_blocks_range_buf = result.value;
                },
                FtraceEventWire.F2FS_TRUNCATE_INODE_BLOCKS_ENTER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._f2fs_truncate_inode_blocks_enter_buf = result.value;
                },
                FtraceEventWire.F2FS_TRUNCATE_INODE_BLOCKS_EXIT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._f2fs_truncate_inode_blocks_exit_buf = result.value;
                },
                FtraceEventWire.F2FS_TRUNCATE_NODE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._f2fs_truncate_node_buf = result.value;
                },
                FtraceEventWire.F2FS_TRUNCATE_NODES_ENTER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._f2fs_truncate_nodes_enter_buf = result.value;
                },
                FtraceEventWire.F2FS_TRUNCATE_NODES_EXIT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._f2fs_truncate_nodes_exit_buf = result.value;
                },
                FtraceEventWire.F2FS_TRUNCATE_PARTIAL_NODES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._f2fs_truncate_partial_nodes_buf = result.value;
                },
                FtraceEventWire.F2FS_UNLINK_ENTER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._f2fs_unlink_enter_buf = result.value;
                },
                FtraceEventWire.F2FS_UNLINK_EXIT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._f2fs_unlink_exit_buf = result.value;
                },
                FtraceEventWire.F2FS_VM_PAGE_MKWRITE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._f2fs_vm_page_mkwrite_buf = result.value;
                },
                FtraceEventWire.F2FS_WRITE_BEGIN_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._f2fs_write_begin_buf = result.value;
                },
                FtraceEventWire.F2FS_WRITE_CHECKPOINT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._f2fs_write_checkpoint_buf = result.value;
                },
                FtraceEventWire.F2FS_WRITE_END_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._f2fs_write_end_buf = result.value;
                },
                FtraceEventWire.ALLOC_PAGES_IOMMU_END_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._alloc_pages_iommu_end_buf = result.value;
                },
                FtraceEventWire.ALLOC_PAGES_IOMMU_FAIL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._alloc_pages_iommu_fail_buf = result.value;
                },
                FtraceEventWire.ALLOC_PAGES_IOMMU_START_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._alloc_pages_iommu_start_buf = result.value;
                },
                FtraceEventWire.ALLOC_PAGES_SYS_END_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._alloc_pages_sys_end_buf = result.value;
                },
                FtraceEventWire.ALLOC_PAGES_SYS_FAIL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._alloc_pages_sys_fail_buf = result.value;
                },
                FtraceEventWire.ALLOC_PAGES_SYS_START_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._alloc_pages_sys_start_buf = result.value;
                },
                FtraceEventWire.DMA_ALLOC_CONTIGUOUS_RETRY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dma_alloc_contiguous_retry_buf = result.value;
                },
                FtraceEventWire.IOMMU_MAP_RANGE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._iommu_map_range_buf = result.value;
                },
                FtraceEventWire.IOMMU_SEC_PTBL_MAP_RANGE_END_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._iommu_sec_ptbl_map_range_end_buf = result.value;
                },
                FtraceEventWire.IOMMU_SEC_PTBL_MAP_RANGE_START_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._iommu_sec_ptbl_map_range_start_buf = result.value;
                },
                FtraceEventWire.ION_ALLOC_BUFFER_END_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ion_alloc_buffer_end_buf = result.value;
                },
                FtraceEventWire.ION_ALLOC_BUFFER_FAIL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ion_alloc_buffer_fail_buf = result.value;
                },
                FtraceEventWire.ION_ALLOC_BUFFER_FALLBACK_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ion_alloc_buffer_fallback_buf = result.value;
                },
                FtraceEventWire.ION_ALLOC_BUFFER_START_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ion_alloc_buffer_start_buf = result.value;
                },
                FtraceEventWire.ION_CP_ALLOC_RETRY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ion_cp_alloc_retry_buf = result.value;
                },
                FtraceEventWire.ION_CP_SECURE_BUFFER_END_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ion_cp_secure_buffer_end_buf = result.value;
                },
                FtraceEventWire.ION_CP_SECURE_BUFFER_START_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ion_cp_secure_buffer_start_buf = result.value;
                },
                FtraceEventWire.ION_PREFETCHING_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ion_prefetching_buf = result.value;
                },
                FtraceEventWire.ION_SECURE_CMA_ADD_TO_POOL_END_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ion_secure_cma_add_to_pool_end_buf = result.value;
                },
                FtraceEventWire.ION_SECURE_CMA_ADD_TO_POOL_START_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ion_secure_cma_add_to_pool_start_buf = result.value;
                },
                FtraceEventWire.ION_SECURE_CMA_ALLOCATE_END_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ion_secure_cma_allocate_end_buf = result.value;
                },
                FtraceEventWire.ION_SECURE_CMA_ALLOCATE_START_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ion_secure_cma_allocate_start_buf = result.value;
                },
                FtraceEventWire.ION_SECURE_CMA_SHRINK_POOL_END_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ion_secure_cma_shrink_pool_end_buf = result.value;
                },
                FtraceEventWire.ION_SECURE_CMA_SHRINK_POOL_START_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ion_secure_cma_shrink_pool_start_buf = result.value;
                },
                FtraceEventWire.KFREE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kfree_buf = result.value;
                },
                FtraceEventWire.KMALLOC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kmalloc_buf = result.value;
                },
                FtraceEventWire.KMALLOC_NODE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kmalloc_node_buf = result.value;
                },
                FtraceEventWire.KMEM_CACHE_ALLOC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kmem_cache_alloc_buf = result.value;
                },
                FtraceEventWire.KMEM_CACHE_ALLOC_NODE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kmem_cache_alloc_node_buf = result.value;
                },
                FtraceEventWire.KMEM_CACHE_FREE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kmem_cache_free_buf = result.value;
                },
                FtraceEventWire.MIGRATE_PAGES_END_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._migrate_pages_end_buf = result.value;
                },
                FtraceEventWire.MIGRATE_PAGES_START_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._migrate_pages_start_buf = result.value;
                },
                FtraceEventWire.MIGRATE_RETRY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._migrate_retry_buf = result.value;
                },
                FtraceEventWire.MM_PAGE_ALLOC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mm_page_alloc_buf = result.value;
                },
                FtraceEventWire.MM_PAGE_ALLOC_EXTFRAG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mm_page_alloc_extfrag_buf = result.value;
                },
                FtraceEventWire.MM_PAGE_ALLOC_ZONE_LOCKED_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mm_page_alloc_zone_locked_buf = result.value;
                },
                FtraceEventWire.MM_PAGE_FREE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mm_page_free_buf = result.value;
                },
                FtraceEventWire.MM_PAGE_FREE_BATCHED_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mm_page_free_batched_buf = result.value;
                },
                FtraceEventWire.MM_PAGE_PCPU_DRAIN_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mm_page_pcpu_drain_buf = result.value;
                },
                FtraceEventWire.RSS_STAT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._rss_stat_buf = result.value;
                },
                FtraceEventWire.ION_HEAP_SHRINK_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ion_heap_shrink_buf = result.value;
                },
                FtraceEventWire.ION_HEAP_GROW_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ion_heap_grow_buf = result.value;
                },
                FtraceEventWire.FENCE_INIT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._fence_init_buf = result.value;
                },
                FtraceEventWire.FENCE_DESTROY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._fence_destroy_buf = result.value;
                },
                FtraceEventWire.FENCE_ENABLE_SIGNAL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._fence_enable_signal_buf = result.value;
                },
                FtraceEventWire.FENCE_SIGNALED_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._fence_signaled_buf = result.value;
                },
                FtraceEventWire.CLK_ENABLE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._clk_enable_buf = result.value;
                },
                FtraceEventWire.CLK_DISABLE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._clk_disable_buf = result.value;
                },
                FtraceEventWire.CLK_SET_RATE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._clk_set_rate_buf = result.value;
                },
                FtraceEventWire.BINDER_TRANSACTION_ALLOC_BUF_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._binder_transaction_alloc_buf_buf = result.value;
                },
                FtraceEventWire.SIGNAL_DELIVER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._signal_deliver_buf = result.value;
                },
                FtraceEventWire.SIGNAL_GENERATE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._signal_generate_buf = result.value;
                },
                FtraceEventWire.OOM_SCORE_ADJ_UPDATE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._oom_score_adj_update_buf = result.value;
                },
                FtraceEventWire.GENERIC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._generic_buf = result.value;
                },
                FtraceEventWire.MM_EVENT_RECORD_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mm_event_record_buf = result.value;
                },
                FtraceEventWire.SYS_ENTER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._sys_enter_buf = result.value;
                },
                FtraceEventWire.SYS_EXIT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._sys_exit_buf = result.value;
                },
                FtraceEventWire.ZERO_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._zero_buf = result.value;
                },
                FtraceEventWire.GPU_FREQUENCY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._gpu_frequency_buf = result.value;
                },
                FtraceEventWire.SDE_TRACING_MARK_WRITE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._sde_tracing_mark_write_buf = result.value;
                },
                FtraceEventWire.MARK_VICTIM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mark_victim_buf = result.value;
                },
                FtraceEventWire.ION_STAT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ion_stat_buf = result.value;
                },
                FtraceEventWire.ION_BUFFER_CREATE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ion_buffer_create_buf = result.value;
                },
                FtraceEventWire.ION_BUFFER_DESTROY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ion_buffer_destroy_buf = result.value;
                },
                FtraceEventWire.SCM_CALL_START_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._scm_call_start_buf = result.value;
                },
                FtraceEventWire.SCM_CALL_END_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._scm_call_end_buf = result.value;
                },
                FtraceEventWire.GPU_MEM_TOTAL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._gpu_mem_total_buf = result.value;
                },
                FtraceEventWire.THERMAL_TEMPERATURE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._thermal_temperature_buf = result.value;
                },
                FtraceEventWire.CDEV_UPDATE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cdev_update_buf = result.value;
                },
                FtraceEventWire.CPUHP_EXIT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cpuhp_exit_buf = result.value;
                },
                FtraceEventWire.CPUHP_MULTI_ENTER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cpuhp_multi_enter_buf = result.value;
                },
                FtraceEventWire.CPUHP_ENTER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cpuhp_enter_buf = result.value;
                },
                FtraceEventWire.CPUHP_LATENCY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cpuhp_latency_buf = result.value;
                },
                FtraceEventWire.FASTRPC_DMA_STAT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._fastrpc_dma_stat_buf = result.value;
                },
                FtraceEventWire.DPU_TRACING_MARK_WRITE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dpu_tracing_mark_write_buf = result.value;
                },
                FtraceEventWire.G2D_TRACING_MARK_WRITE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._g2d_tracing_mark_write_buf = result.value;
                },
                FtraceEventWire.MALI_TRACING_MARK_WRITE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mali_tracing_mark_write_buf = result.value;
                },
                FtraceEventWire.DMA_HEAP_STAT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dma_heap_stat_buf = result.value;
                },
                FtraceEventWire.CPUHP_PAUSE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cpuhp_pause_buf = result.value;
                },
                FtraceEventWire.SCHED_PI_SETPRIO_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._sched_pi_setprio_buf = result.value;
                },
                FtraceEventWire.SDE_SDE_EVTLOG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._sde_sde_evtlog_buf = result.value;
                },
                FtraceEventWire.SDE_SDE_PERF_CALC_CRTC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._sde_sde_perf_calc_crtc_buf = result.value;
                },
                FtraceEventWire.SDE_SDE_PERF_CRTC_UPDATE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._sde_sde_perf_crtc_update_buf = result.value;
                },
                FtraceEventWire.SDE_SDE_PERF_SET_QOS_LUTS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._sde_sde_perf_set_qos_luts_buf = result.value;
                },
                FtraceEventWire.SDE_SDE_PERF_UPDATE_BUS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._sde_sde_perf_update_bus_buf = result.value;
                },
                FtraceEventWire.RSS_STAT_THROTTLED_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._rss_stat_throttled_buf = result.value;
                },
                FtraceEventWire.NETIF_RECEIVE_SKB_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._netif_receive_skb_buf = result.value;
                },
                FtraceEventWire.NET_DEV_XMIT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._net_dev_xmit_buf = result.value;
                },
                FtraceEventWire.INET_SOCK_SET_STATE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._inet_sock_set_state_buf = result.value;
                },
                FtraceEventWire.TCP_RETRANSMIT_SKB_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._tcp_retransmit_skb_buf = result.value;
                },
                FtraceEventWire.CROS_EC_SENSORHUB_DATA_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cros_ec_sensorhub_data_buf = result.value;
                },
                FtraceEventWire.NAPI_GRO_RECEIVE_ENTRY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._napi_gro_receive_entry_buf = result.value;
                },
                FtraceEventWire.NAPI_GRO_RECEIVE_EXIT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._napi_gro_receive_exit_buf = result.value;
                },
                FtraceEventWire.KFREE_SKB_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kfree_skb_buf = result.value;
                },
                FtraceEventWire.KVM_ACCESS_FAULT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kvm_access_fault_buf = result.value;
                },
                FtraceEventWire.KVM_ACK_IRQ_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kvm_ack_irq_buf = result.value;
                },
                FtraceEventWire.KVM_AGE_HVA_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kvm_age_hva_buf = result.value;
                },
                FtraceEventWire.KVM_AGE_PAGE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kvm_age_page_buf = result.value;
                },
                FtraceEventWire.KVM_ARM_CLEAR_DEBUG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kvm_arm_clear_debug_buf = result.value;
                },
                FtraceEventWire.KVM_ARM_SET_DREG32_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kvm_arm_set_dreg32_buf = result.value;
                },
                FtraceEventWire.KVM_ARM_SET_REGSET_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kvm_arm_set_regset_buf = result.value;
                },
                FtraceEventWire.KVM_ARM_SETUP_DEBUG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kvm_arm_setup_debug_buf = result.value;
                },
                FtraceEventWire.KVM_ENTRY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kvm_entry_buf = result.value;
                },
                FtraceEventWire.KVM_EXIT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kvm_exit_buf = result.value;
                },
                FtraceEventWire.KVM_FPU_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kvm_fpu_buf = result.value;
                },
                FtraceEventWire.KVM_GET_TIMER_MAP_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kvm_get_timer_map_buf = result.value;
                },
                FtraceEventWire.KVM_GUEST_FAULT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kvm_guest_fault_buf = result.value;
                },
                FtraceEventWire.KVM_HANDLE_SYS_REG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kvm_handle_sys_reg_buf = result.value;
                },
                FtraceEventWire.KVM_HVC_ARM64_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kvm_hvc_arm64_buf = result.value;
                },
                FtraceEventWire.KVM_IRQ_LINE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kvm_irq_line_buf = result.value;
                },
                FtraceEventWire.KVM_MMIO_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kvm_mmio_buf = result.value;
                },
                FtraceEventWire.KVM_MMIO_EMULATE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kvm_mmio_emulate_buf = result.value;
                },
                FtraceEventWire.KVM_SET_GUEST_DEBUG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kvm_set_guest_debug_buf = result.value;
                },
                FtraceEventWire.KVM_SET_IRQ_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kvm_set_irq_buf = result.value;
                },
                FtraceEventWire.KVM_SET_SPTE_HVA_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kvm_set_spte_hva_buf = result.value;
                },
                FtraceEventWire.KVM_SET_WAY_FLUSH_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kvm_set_way_flush_buf = result.value;
                },
                FtraceEventWire.KVM_SYS_ACCESS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kvm_sys_access_buf = result.value;
                },
                FtraceEventWire.KVM_TEST_AGE_HVA_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kvm_test_age_hva_buf = result.value;
                },
                FtraceEventWire.KVM_TIMER_EMULATE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kvm_timer_emulate_buf = result.value;
                },
                FtraceEventWire.KVM_TIMER_HRTIMER_EXPIRE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kvm_timer_hrtimer_expire_buf = result.value;
                },
                FtraceEventWire.KVM_TIMER_RESTORE_STATE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kvm_timer_restore_state_buf = result.value;
                },
                FtraceEventWire.KVM_TIMER_SAVE_STATE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kvm_timer_save_state_buf = result.value;
                },
                FtraceEventWire.KVM_TIMER_UPDATE_IRQ_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kvm_timer_update_irq_buf = result.value;
                },
                FtraceEventWire.KVM_TOGGLE_CACHE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kvm_toggle_cache_buf = result.value;
                },
                FtraceEventWire.KVM_UNMAP_HVA_RANGE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kvm_unmap_hva_range_buf = result.value;
                },
                FtraceEventWire.KVM_USERSPACE_EXIT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kvm_userspace_exit_buf = result.value;
                },
                FtraceEventWire.KVM_VCPU_WAKEUP_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kvm_vcpu_wakeup_buf = result.value;
                },
                FtraceEventWire.KVM_WFX_ARM64_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kvm_wfx_arm64_buf = result.value;
                },
                FtraceEventWire.TRAP_REG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._trap_reg_buf = result.value;
                },
                FtraceEventWire.VGIC_UPDATE_IRQ_PENDING_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._vgic_update_irq_pending_buf = result.value;
                },
                FtraceEventWire.WAKEUP_SOURCE_ACTIVATE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._wakeup_source_activate_buf = result.value;
                },
                FtraceEventWire.WAKEUP_SOURCE_DEACTIVATE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._wakeup_source_deactivate_buf = result.value;
                },
                FtraceEventWire.UFSHCD_COMMAND_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ufshcd_command_buf = result.value;
                },
                FtraceEventWire.UFSHCD_CLK_GATING_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ufshcd_clk_gating_buf = result.value;
                },
                FtraceEventWire.CONSOLE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._console_buf = result.value;
                },
                FtraceEventWire.DRM_VBLANK_EVENT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._drm_vblank_event_buf = result.value;
                },
                FtraceEventWire.DRM_VBLANK_EVENT_DELIVERED_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._drm_vblank_event_delivered_buf = result.value;
                },
                FtraceEventWire.DRM_SCHED_JOB_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._drm_sched_job_buf = result.value;
                },
                FtraceEventWire.DRM_RUN_JOB_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._drm_run_job_buf = result.value;
                },
                FtraceEventWire.DRM_SCHED_PROCESS_JOB_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._drm_sched_process_job_buf = result.value;
                },
                FtraceEventWire.DMA_FENCE_INIT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dma_fence_init_buf = result.value;
                },
                FtraceEventWire.DMA_FENCE_EMIT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dma_fence_emit_buf = result.value;
                },
                FtraceEventWire.DMA_FENCE_SIGNALED_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dma_fence_signaled_buf = result.value;
                },
                FtraceEventWire.DMA_FENCE_WAIT_START_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dma_fence_wait_start_buf = result.value;
                },
                FtraceEventWire.DMA_FENCE_WAIT_END_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dma_fence_wait_end_buf = result.value;
                },
                FtraceEventWire.F2FS_IOSTAT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._f2fs_iostat_buf = result.value;
                },
                FtraceEventWire.F2FS_IOSTAT_LATENCY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._f2fs_iostat_latency_buf = result.value;
                },
                FtraceEventWire.SCHED_CPU_UTIL_CFS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._sched_cpu_util_cfs_buf = result.value;
                },
                FtraceEventWire.V4L2_QBUF_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._v4l2_qbuf_buf = result.value;
                },
                FtraceEventWire.V4L2_DQBUF_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._v4l2_dqbuf_buf = result.value;
                },
                FtraceEventWire.VB2_V4L2_BUF_QUEUE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._vb2_v4l2_buf_queue_buf = result.value;
                },
                FtraceEventWire.VB2_V4L2_BUF_DONE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._vb2_v4l2_buf_done_buf = result.value;
                },
                FtraceEventWire.VB2_V4L2_QBUF_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._vb2_v4l2_qbuf_buf = result.value;
                },
                FtraceEventWire.VB2_V4L2_DQBUF_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._vb2_v4l2_dqbuf_buf = result.value;
                },
                FtraceEventWire.DSI_CMD_FIFO_STATUS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dsi_cmd_fifo_status_buf = result.value;
                },
                FtraceEventWire.DSI_RX_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dsi_rx_buf = result.value;
                },
                FtraceEventWire.DSI_TX_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dsi_tx_buf = result.value;
                },
                FtraceEventWire.ANDROID_FS_DATAREAD_END_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_fs_dataread_end_buf = result.value;
                },
                FtraceEventWire.ANDROID_FS_DATAREAD_START_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_fs_dataread_start_buf = result.value;
                },
                FtraceEventWire.ANDROID_FS_DATAWRITE_END_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_fs_datawrite_end_buf = result.value;
                },
                FtraceEventWire.ANDROID_FS_DATAWRITE_START_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_fs_datawrite_start_buf = result.value;
                },
                FtraceEventWire.ANDROID_FS_FSYNC_END_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_fs_fsync_end_buf = result.value;
                },
                FtraceEventWire.ANDROID_FS_FSYNC_START_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_fs_fsync_start_buf = result.value;
                },
                FtraceEventWire.FUNCGRAPH_ENTRY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._funcgraph_entry_buf = result.value;
                },
                FtraceEventWire.FUNCGRAPH_EXIT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._funcgraph_exit_buf = result.value;
                },
                FtraceEventWire.VIRTIO_VIDEO_CMD_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._virtio_video_cmd_buf = result.value;
                },
                FtraceEventWire.VIRTIO_VIDEO_CMD_DONE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._virtio_video_cmd_done_buf = result.value;
                },
                FtraceEventWire.VIRTIO_VIDEO_RESOURCE_QUEUE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._virtio_video_resource_queue_buf = result.value;
                },
                FtraceEventWire.VIRTIO_VIDEO_RESOURCE_QUEUE_DONE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._virtio_video_resource_queue_done_buf = result.value;
                },
                FtraceEventWire.MM_SHRINK_SLAB_START_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mm_shrink_slab_start_buf = result.value;
                },
                FtraceEventWire.MM_SHRINK_SLAB_END_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mm_shrink_slab_end_buf = result.value;
                },
                FtraceEventWire.TRUSTY_SMC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._trusty_smc_buf = result.value;
                },
                FtraceEventWire.TRUSTY_SMC_DONE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._trusty_smc_done_buf = result.value;
                },
                FtraceEventWire.TRUSTY_STD_CALL32_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._trusty_std_call32_buf = result.value;
                },
                FtraceEventWire.TRUSTY_STD_CALL32_DONE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._trusty_std_call32_done_buf = result.value;
                },
                FtraceEventWire.TRUSTY_SHARE_MEMORY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._trusty_share_memory_buf = result.value;
                },
                FtraceEventWire.TRUSTY_SHARE_MEMORY_DONE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._trusty_share_memory_done_buf = result.value;
                },
                FtraceEventWire.TRUSTY_RECLAIM_MEMORY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._trusty_reclaim_memory_buf = result.value;
                },
                FtraceEventWire.TRUSTY_RECLAIM_MEMORY_DONE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._trusty_reclaim_memory_done_buf = result.value;
                },
                FtraceEventWire.TRUSTY_IRQ_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._trusty_irq_buf = result.value;
                },
                FtraceEventWire.TRUSTY_IPC_HANDLE_EVENT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._trusty_ipc_handle_event_buf = result.value;
                },
                FtraceEventWire.TRUSTY_IPC_CONNECT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._trusty_ipc_connect_buf = result.value;
                },
                FtraceEventWire.TRUSTY_IPC_CONNECT_END_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._trusty_ipc_connect_end_buf = result.value;
                },
                FtraceEventWire.TRUSTY_IPC_WRITE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._trusty_ipc_write_buf = result.value;
                },
                FtraceEventWire.TRUSTY_IPC_POLL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._trusty_ipc_poll_buf = result.value;
                },
                FtraceEventWire.TRUSTY_IPC_READ_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._trusty_ipc_read_buf = result.value;
                },
                FtraceEventWire.TRUSTY_IPC_READ_END_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._trusty_ipc_read_end_buf = result.value;
                },
                FtraceEventWire.TRUSTY_IPC_RX_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._trusty_ipc_rx_buf = result.value;
                },
                FtraceEventWire.TRUSTY_ENQUEUE_NOP_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._trusty_enqueue_nop_buf = result.value;
                },
                FtraceEventWire.CMA_ALLOC_START_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cma_alloc_start_buf = result.value;
                },
                FtraceEventWire.CMA_ALLOC_INFO_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cma_alloc_info_buf = result.value;
                },
                FtraceEventWire.LWIS_TRACING_MARK_WRITE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._lwis_tracing_mark_write_buf = result.value;
                },
                FtraceEventWire.VIRTIO_GPU_CMD_QUEUE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._virtio_gpu_cmd_queue_buf = result.value;
                },
                FtraceEventWire.VIRTIO_GPU_CMD_RESPONSE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._virtio_gpu_cmd_response_buf = result.value;
                },
                FtraceEventWire.MALI_MALI_KCPU_CQS_SETWIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mali_mali_k_c_p_u_c_q_s_s_e_t_buf = result.value;
                },
                FtraceEventWire.MALI_MALI_KCPU_CQS_WAIT_STARTWIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mali_mali_k_c_p_u_c_q_s_w_a_i_t_s_t_a_r_t_buf = result.value;
                },
                FtraceEventWire.MALI_MALI_KCPU_CQS_WAIT_ENDWIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mali_mali_k_c_p_u_c_q_s_w_a_i_t_e_n_d_buf = result.value;
                },
                FtraceEventWire.MALI_MALI_KCPU_FENCE_SIGNALWIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mali_mali_k_c_p_u_f_e_n_c_e_s_i_g_n_a_l_buf = result.value;
                },
                FtraceEventWire.MALI_MALI_KCPU_FENCE_WAIT_STARTWIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mali_mali_k_c_p_u_f_e_n_c_e_w_a_i_t_s_t_a_r_t_buf = result.value;
                },
                FtraceEventWire.MALI_MALI_KCPU_FENCE_WAIT_ENDWIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mali_mali_k_c_p_u_f_e_n_c_e_w_a_i_t_e_n_d_buf = result.value;
                },
                FtraceEventWire.HYP_ENTER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._hyp_enter_buf = result.value;
                },
                FtraceEventWire.HYP_EXIT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._hyp_exit_buf = result.value;
                },
                FtraceEventWire.HOST_HCALL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._host_hcall_buf = result.value;
                },
                FtraceEventWire.HOST_SMC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._host_smc_buf = result.value;
                },
                FtraceEventWire.HOST_MEM_ABORT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._host_mem_abort_buf = result.value;
                },
                FtraceEventWire.SUSPEND_RESUME_MINIMAL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._suspend_resume_minimal_buf = result.value;
                },
                FtraceEventWire.MALI_MALI_CSF_INTERRUPT_STARTWIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mali_mali_c_s_f_i_n_t_e_r_r_u_p_t_s_t_a_r_t_buf = result.value;
                },
                FtraceEventWire.MALI_MALI_CSF_INTERRUPT_ENDWIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mali_mali_c_s_f_i_n_t_e_r_r_u_p_t_e_n_d_buf = result.value;
                },
                FtraceEventWire.SAMSUNG_TRACING_MARK_WRITE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._samsung_tracing_mark_write_buf = result.value;
                },
                FtraceEventWire.BINDER_COMMAND_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._binder_command_buf = result.value;
                },
                FtraceEventWire.BINDER_RETURN_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._binder_return_buf = result.value;
                },
                FtraceEventWire.SCHED_SWITCH_WITH_CTRS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._sched_switch_with_ctrs_buf = result.value;
                },
                FtraceEventWire.GPU_WORK_PERIOD_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._gpu_work_period_buf = result.value;
                },
                FtraceEventWire.RPM_STATUS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._rpm_status_buf = result.value;
                },
                FtraceEventWire.PANEL_WRITE_GENERIC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._panel_write_generic_buf = result.value;
                },
                FtraceEventWire.SCHED_MIGRATE_TASK_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._sched_migrate_task_buf = result.value;
                },
                FtraceEventWire.DPU_DSI_CMD_FIFO_STATUS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dpu_dsi_cmd_fifo_status_buf = result.value;
                },
                FtraceEventWire.DPU_DSI_RX_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dpu_dsi_rx_buf = result.value;
                },
                FtraceEventWire.DPU_DSI_TX_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dpu_dsi_tx_buf = result.value;
                },
                FtraceEventWire.F2FS_BACKGROUND_GC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._f2fs_background_gc_buf = result.value;
                },
                FtraceEventWire.F2FS_GC_BEGIN_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._f2fs_gc_begin_buf = result.value;
                },
                FtraceEventWire.F2FS_GC_END_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._f2fs_gc_end_buf = result.value;
                },
                FtraceEventWire.FASTRPC_DMA_FREE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._fastrpc_dma_free_buf = result.value;
                },
                FtraceEventWire.FASTRPC_DMA_ALLOC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._fastrpc_dma_alloc_buf = result.value;
                },
                FtraceEventWire.FASTRPC_DMA_UNMAP_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._fastrpc_dma_unmap_buf = result.value;
                },
                FtraceEventWire.FASTRPC_DMA_MAP_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._fastrpc_dma_map_buf = result.value;
                },
                FtraceEventWire.GOOGLE_ICC_EVENT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._google_icc_event_buf = result.value;
                },
                FtraceEventWire.GOOGLE_IRM_EVENT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._google_irm_event_buf = result.value;
                },
                FtraceEventWire.DEVICE_PM_CALLBACK_START_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._device_pm_callback_start_buf = result.value;
                },
                FtraceEventWire.DEVICE_PM_CALLBACK_END_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._device_pm_callback_end_buf = result.value;
                },
                FtraceEventWire.THERMAL_EXYNOS_ACPM_BULK_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._thermal_exynos_acpm_bulk_buf = result.value;
                },
                FtraceEventWire.THERMAL_EXYNOS_ACPM_HIGH_OVERHEAD_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._thermal_exynos_acpm_high_overhead_buf = result.value;
                },
                FtraceEventWire.DCVSH_FREQ_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dcvsh_freq_buf = result.value;
                },
                FtraceEventWire.KGSL_GPU_FREQUENCY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kgsl_gpu_frequency_buf = result.value;
                },
                FtraceEventWire.MALI_MALI_PM_MCU_HCTL_CORES_DOWN_SCALE_NOTIFY_PENDWIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mali_mali_p_m_m_c_u_h_c_t_l_c_o_r_e_s_d_o_w_n_s_c_a_l_e_n_o_t_i_f_y_p_e_n_d_buf = result.value;
                },
                FtraceEventWire.MALI_MALI_PM_MCU_HCTL_CORES_NOTIFY_PENDWIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mali_mali_p_m_m_c_u_h_c_t_l_c_o_r_e_s_n_o_t_i_f_y_p_e_n_d_buf = result.value;
                },
                FtraceEventWire.MALI_MALI_PM_MCU_HCTL_CORE_INACTIVE_PENDWIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mali_mali_p_m_m_c_u_h_c_t_l_c_o_r_e_i_n_a_c_t_i_v_e_p_e_n_d_buf = result.value;
                },
                FtraceEventWire.MALI_MALI_PM_MCU_HCTL_MCU_ON_RECHECKWIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mali_mali_p_m_m_c_u_h_c_t_l_m_c_u_o_n_r_e_c_h_e_c_k_buf = result.value;
                },
                FtraceEventWire.MALI_MALI_PM_MCU_HCTL_SHADERS_CORE_OFF_PENDWIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mali_mali_p_m_m_c_u_h_c_t_l_s_h_a_d_e_r_s_c_o_r_e_o_f_f_p_e_n_d_buf = result.value;
                },
                FtraceEventWire.MALI_MALI_PM_MCU_HCTL_SHADERS_PEND_OFFWIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mali_mali_p_m_m_c_u_h_c_t_l_s_h_a_d_e_r_s_p_e_n_d_o_f_f_buf = result.value;
                },
                FtraceEventWire.MALI_MALI_PM_MCU_HCTL_SHADERS_PEND_ONWIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mali_mali_p_m_m_c_u_h_c_t_l_s_h_a_d_e_r_s_p_e_n_d_o_n_buf = result.value;
                },
                FtraceEventWire.MALI_MALI_PM_MCU_HCTL_SHADERS_READY_OFFWIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mali_mali_p_m_m_c_u_h_c_t_l_s_h_a_d_e_r_s_r_e_a_d_y_o_f_f_buf = result.value;
                },
                FtraceEventWire.MALI_MALI_PM_MCU_IN_SLEEPWIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mali_mali_p_m_m_c_u_i_n_s_l_e_e_p_buf = result.value;
                },
                FtraceEventWire.MALI_MALI_PM_MCU_OFFWIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mali_mali_p_m_m_c_u_o_f_f_buf = result.value;
                },
                FtraceEventWire.MALI_MALI_PM_MCU_ONWIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mali_mali_p_m_m_c_u_o_n_buf = result.value;
                },
                FtraceEventWire.MALI_MALI_PM_MCU_ON_CORE_ATTR_UPDATE_PENDWIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mali_mali_p_m_m_c_u_o_n_c_o_r_e_a_t_t_r_u_p_d_a_t_e_p_e_n_d_buf = result.value;
                },
                FtraceEventWire.MALI_MALI_PM_MCU_ON_GLB_REINIT_PENDWIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mali_mali_p_m_m_c_u_o_n_g_l_b_r_e_i_n_i_t_p_e_n_d_buf = result.value;
                },
                FtraceEventWire.MALI_MALI_PM_MCU_ON_HALTWIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mali_mali_p_m_m_c_u_o_n_h_a_l_t_buf = result.value;
                },
                FtraceEventWire.MALI_MALI_PM_MCU_ON_HWCNT_DISABLEWIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mali_mali_p_m_m_c_u_o_n_h_w_c_n_t_d_i_s_a_b_l_e_buf = result.value;
                },
                FtraceEventWire.MALI_MALI_PM_MCU_ON_HWCNT_ENABLEWIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mali_mali_p_m_m_c_u_o_n_h_w_c_n_t_e_n_a_b_l_e_buf = result.value;
                },
                FtraceEventWire.MALI_MALI_PM_MCU_ON_PEND_HALTWIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mali_mali_p_m_m_c_u_o_n_p_e_n_d_h_a_l_t_buf = result.value;
                },
                FtraceEventWire.MALI_MALI_PM_MCU_ON_PEND_SLEEPWIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mali_mali_p_m_m_c_u_o_n_p_e_n_d_s_l_e_e_p_buf = result.value;
                },
                FtraceEventWire.MALI_MALI_PM_MCU_ON_SLEEP_INITIATEWIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mali_mali_p_m_m_c_u_o_n_s_l_e_e_p_i_n_i_t_i_a_t_e_buf = result.value;
                },
                FtraceEventWire.MALI_MALI_PM_MCU_PEND_OFFWIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mali_mali_p_m_m_c_u_p_e_n_d_o_f_f_buf = result.value;
                },
                FtraceEventWire.MALI_MALI_PM_MCU_PEND_ON_RELOADWIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mali_mali_p_m_m_c_u_p_e_n_d_o_n_r_e_l_o_a_d_buf = result.value;
                },
                FtraceEventWire.MALI_MALI_PM_MCU_POWER_DOWNWIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mali_mali_p_m_m_c_u_p_o_w_e_r_d_o_w_n_buf = result.value;
                },
                FtraceEventWire.MALI_MALI_PM_MCU_RESET_WAITWIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mali_mali_p_m_m_c_u_r_e_s_e_t_w_a_i_t_buf = result.value;
                },
                FtraceEventWire.BCL_IRQ_TRIGGER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._bcl_irq_trigger_buf = result.value;
                },
                FtraceEventWire.KGSL_ADRENO_CMDBATCH_QUEUED_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kgsl_adreno_cmdbatch_queued_buf = result.value;
                },
                FtraceEventWire.KGSL_ADRENO_CMDBATCH_SUBMITTED_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kgsl_adreno_cmdbatch_submitted_buf = result.value;
                },
                FtraceEventWire.KGSL_ADRENO_CMDBATCH_SYNC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kgsl_adreno_cmdbatch_sync_buf = result.value;
                },
                FtraceEventWire.KGSL_ADRENO_CMDBATCH_RETIRED_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kgsl_adreno_cmdbatch_retired_buf = result.value;
                },
                FtraceEventWire.PIXEL_MM_KSWAPD_WAKE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._pixel_mm_kswapd_wake_buf = result.value;
                },
                FtraceEventWire.PIXEL_MM_KSWAPD_DONE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._pixel_mm_kswapd_done_buf = result.value;
                },
                FtraceEventWire.SCHED_WAKEUP_TASK_ATTR_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._sched_wakeup_task_attr_buf = result.value;
                },
                FtraceEventWire.DEVFREQ_FREQUENCY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._devfreq_frequency_buf = result.value;
                },
                FtraceEventWire.KPROBE_EVENT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kprobe_event_buf = result.value;
                },
                FtraceEventWire.PARAM_SET_VALUE_CPM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._param_set_value_cpm_buf = result.value;
                },
                FtraceEventWire.DO_SYS_OPEN_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._do_sys_open_buf = result.value;
                },
                FtraceEventWire.OPEN_EXEC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._open_exec_buf = result.value;
                },
                FtraceEventWire.BLOCK_IO_START_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._block_io_start_buf = result.value;
                },
                FtraceEventWire.BLOCK_IO_DONE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._block_io_done_buf = result.value;
                },
                FtraceEventWire.MALI_GPU_POWER_STATE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mali_gpu_power_state_buf = result.value;
                },
                FtraceEventWire.DPU_DISP_DPU_UNDERRUN_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dpu_disp_dpu_underrun_buf = result.value;
                },
                FtraceEventWire.DPU_DISP_VBLANK_IRQ_ENABLE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dpu_disp_vblank_irq_enable_buf = result.value;
                },
                FtraceEventWire.HRTIMER_START_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._hrtimer_start_buf = result.value;
                },
                FtraceEventWire.HRTIMER_CANCEL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._hrtimer_cancel_buf = result.value;
                },
                FtraceEventWire.HRTIMER_EXPIRE_ENTRY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._hrtimer_expire_entry_buf = result.value;
                },
                FtraceEventWire.HRTIMER_EXPIRE_EXIT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._hrtimer_expire_exit_buf = result.value;
                },
                FtraceEventWire.TIMER_START_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._timer_start_buf = result.value;
                },
                FtraceEventWire.TIMER_CANCEL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._timer_cancel_buf = result.value;
                },
                FtraceEventWire.TIMER_EXPIRE_ENTRY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._timer_expire_entry_buf = result.value;
                },
                FtraceEventWire.TIMER_EXPIRE_EXIT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._timer_expire_exit_buf = result.value;
                },
                FtraceEventWire.LOCAL_TIMER_ENTRY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._local_timer_entry_buf = result.value;
                },
                FtraceEventWire.LOCAL_TIMER_EXIT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._local_timer_exit_buf = result.value;
                },
                FtraceEventWire.DWC3_ALLOC_REQUEST_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dwc3_alloc_request_buf = result.value;
                },
                FtraceEventWire.DWC3_COMPLETE_TRB_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dwc3_complete_trb_buf = result.value;
                },
                FtraceEventWire.DWC3_CTRL_REQ_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dwc3_ctrl_req_buf = result.value;
                },
                FtraceEventWire.DWC3_EP_DEQUEUE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dwc3_ep_dequeue_buf = result.value;
                },
                FtraceEventWire.DWC3_EP_QUEUE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dwc3_ep_queue_buf = result.value;
                },
                FtraceEventWire.DWC3_EVENT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dwc3_event_buf = result.value;
                },
                FtraceEventWire.DWC3_FREE_REQUEST_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dwc3_free_request_buf = result.value;
                },
                FtraceEventWire.DWC3_GADGET_EP_CMD_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dwc3_gadget_ep_cmd_buf = result.value;
                },
                FtraceEventWire.DWC3_GADGET_EP_DISABLE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dwc3_gadget_ep_disable_buf = result.value;
                },
                FtraceEventWire.DWC3_GADGET_EP_ENABLE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dwc3_gadget_ep_enable_buf = result.value;
                },
                FtraceEventWire.DWC3_GADGET_GENERIC_CMD_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dwc3_gadget_generic_cmd_buf = result.value;
                },
                FtraceEventWire.DWC3_GADGET_GIVEBACK_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dwc3_gadget_giveback_buf = result.value;
                },
                FtraceEventWire.DWC3_PREPARE_TRB_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dwc3_prepare_trb_buf = result.value;
                },
                FtraceEventWire.DWC3_READL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dwc3_readl_buf = result.value;
                },
                FtraceEventWire.DWC3_WRITEL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dwc3_writel_buf = result.value;
                },
                FtraceEventWire.CMA_ALLOC_FINISH_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cma_alloc_finish_buf = result.value;
                },
                FtraceEventWire.MM_ALLOC_CONTIG_MIGRATE_RANGE_INFO_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._mm_alloc_contig_migrate_range_info_buf = result.value;
                },
                FtraceEventWire.HOST_FFA_CALL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._host_ffa_call_buf = result.value;
                },
                FtraceEventWire.DMABUF_RSS_STAT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dmabuf_rss_stat_buf = result.value;
                },
                FtraceEventWire.IOMMU_IDMAP_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._iommu_idmap_buf = result.value;
                },
                FtraceEventWire.PSCI_MEM_PROTECT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._psci_mem_protect_buf = result.value;
                },
                FtraceEventWire.HYPERVISOR_HOST_HCALL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._hypervisor_host_hcall_buf = result.value;
                },
                FtraceEventWire.HYPERVISOR_HOST_SMC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._hypervisor_host_smc_buf = result.value;
                },
                FtraceEventWire.HYPERVISOR_HYP_EXIT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._hypervisor_hyp_exit_buf = result.value;
                },
                FtraceEventWire.HYPERVISOR_IOMMU_IDMAP_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._hypervisor_iommu_idmap_buf = result.value;
                },
                FtraceEventWire.HYPERVISOR_PSCI_MEM_PROTECT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._hypervisor_psci_mem_protect_buf = result.value;
                },
                FtraceEventWire.HYPERVISOR_HOST_MEM_ABORT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._hypervisor_host_mem_abort_buf = result.value;
                },
                FtraceEventWire.HYPERVISOR_HYP_ENTER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._hypervisor_hyp_enter_buf = result.value;
                },
                FtraceEventWire.HYPERVISOR_IOMMU_IDMAP_COMPLETE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._hypervisor_iommu_idmap_complete_buf = result.value;
                },
                FtraceEventWire.HYPERVISOR_VCPU_ILLEGAL_TRAP_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._hypervisor_vcpu_illegal_trap_buf = result.value;
                },
                FtraceEventWire.DRM_SCHED_JOB_ADD_DEP_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._drm_sched_job_add_dep_buf = result.value;
                },
                FtraceEventWire.DRM_SCHED_JOB_DONE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._drm_sched_job_done_buf = result.value;
                },
                FtraceEventWire.DRM_SCHED_JOB_QUEUE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._drm_sched_job_queue_buf = result.value;
                },
                FtraceEventWire.DRM_SCHED_JOB_RUN_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._drm_sched_job_run_buf = result.value;
                },
                FtraceEventWire.DRM_SCHED_JOB_UNSCHEDULABLE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._drm_sched_job_unschedulable_buf = result.value;
                },
                FtraceEventWire.FWTP_PERFETTO_COUNTER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._fwtp_perfetto_counter_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getTimestamp(self: *const FtraceEventReader) u64 {
        return self._timestamp;
    }
    pub inline fn getPid(self: *const FtraceEventReader) u32 {
        return self._pid;
    }
    pub inline fn getCommonFlags(self: *const FtraceEventReader) u32 {
        return self._common_flags;
    }
    pub fn getPrint(self: *const FtraceEventReader) gremlin.Error!ftrace.PrintFtraceEventReader {
        if (self._print_buf) |buf| {
            return try ftrace.PrintFtraceEventReader.init(buf);
        }
        return try ftrace.PrintFtraceEventReader.init(&[_]u8{});
    }
    pub fn getSchedSwitch(self: *const FtraceEventReader) gremlin.Error!sched.SchedSwitchFtraceEventReader {
        if (self._sched_switch_buf) |buf| {
            return try sched.SchedSwitchFtraceEventReader.init(buf);
        }
        return try sched.SchedSwitchFtraceEventReader.init(&[_]u8{});
    }
    pub fn getCpuFrequency(self: *const FtraceEventReader) gremlin.Error!power.CpuFrequencyFtraceEventReader {
        if (self._cpu_frequency_buf) |buf| {
            return try power.CpuFrequencyFtraceEventReader.init(buf);
        }
        return try power.CpuFrequencyFtraceEventReader.init(&[_]u8{});
    }
    pub fn getCpuFrequencyLimits(self: *const FtraceEventReader) gremlin.Error!power.CpuFrequencyLimitsFtraceEventReader {
        if (self._cpu_frequency_limits_buf) |buf| {
            return try power.CpuFrequencyLimitsFtraceEventReader.init(buf);
        }
        return try power.CpuFrequencyLimitsFtraceEventReader.init(&[_]u8{});
    }
    pub fn getCpuIdle(self: *const FtraceEventReader) gremlin.Error!power.CpuIdleFtraceEventReader {
        if (self._cpu_idle_buf) |buf| {
            return try power.CpuIdleFtraceEventReader.init(buf);
        }
        return try power.CpuIdleFtraceEventReader.init(&[_]u8{});
    }
    pub fn getClockEnable(self: *const FtraceEventReader) gremlin.Error!power.ClockEnableFtraceEventReader {
        if (self._clock_enable_buf) |buf| {
            return try power.ClockEnableFtraceEventReader.init(buf);
        }
        return try power.ClockEnableFtraceEventReader.init(&[_]u8{});
    }
    pub fn getClockDisable(self: *const FtraceEventReader) gremlin.Error!power.ClockDisableFtraceEventReader {
        if (self._clock_disable_buf) |buf| {
            return try power.ClockDisableFtraceEventReader.init(buf);
        }
        return try power.ClockDisableFtraceEventReader.init(&[_]u8{});
    }
    pub fn getClockSetRate(self: *const FtraceEventReader) gremlin.Error!power.ClockSetRateFtraceEventReader {
        if (self._clock_set_rate_buf) |buf| {
            return try power.ClockSetRateFtraceEventReader.init(buf);
        }
        return try power.ClockSetRateFtraceEventReader.init(&[_]u8{});
    }
    pub fn getSchedWakeup(self: *const FtraceEventReader) gremlin.Error!sched.SchedWakeupFtraceEventReader {
        if (self._sched_wakeup_buf) |buf| {
            return try sched.SchedWakeupFtraceEventReader.init(buf);
        }
        return try sched.SchedWakeupFtraceEventReader.init(&[_]u8{});
    }
    pub fn getSchedBlockedReason(self: *const FtraceEventReader) gremlin.Error!sched.SchedBlockedReasonFtraceEventReader {
        if (self._sched_blocked_reason_buf) |buf| {
            return try sched.SchedBlockedReasonFtraceEventReader.init(buf);
        }
        return try sched.SchedBlockedReasonFtraceEventReader.init(&[_]u8{});
    }
    pub fn getSchedCpuHotplug(self: *const FtraceEventReader) gremlin.Error!sched.SchedCpuHotplugFtraceEventReader {
        if (self._sched_cpu_hotplug_buf) |buf| {
            return try sched.SchedCpuHotplugFtraceEventReader.init(buf);
        }
        return try sched.SchedCpuHotplugFtraceEventReader.init(&[_]u8{});
    }
    pub fn getSchedWaking(self: *const FtraceEventReader) gremlin.Error!sched.SchedWakingFtraceEventReader {
        if (self._sched_waking_buf) |buf| {
            return try sched.SchedWakingFtraceEventReader.init(buf);
        }
        return try sched.SchedWakingFtraceEventReader.init(&[_]u8{});
    }
    pub fn getIpiEntry(self: *const FtraceEventReader) gremlin.Error!ipi.IpiEntryFtraceEventReader {
        if (self._ipi_entry_buf) |buf| {
            return try ipi.IpiEntryFtraceEventReader.init(buf);
        }
        return try ipi.IpiEntryFtraceEventReader.init(&[_]u8{});
    }
    pub fn getIpiExit(self: *const FtraceEventReader) gremlin.Error!ipi.IpiExitFtraceEventReader {
        if (self._ipi_exit_buf) |buf| {
            return try ipi.IpiExitFtraceEventReader.init(buf);
        }
        return try ipi.IpiExitFtraceEventReader.init(&[_]u8{});
    }
    pub fn getIpiRaise(self: *const FtraceEventReader) gremlin.Error!ipi.IpiRaiseFtraceEventReader {
        if (self._ipi_raise_buf) |buf| {
            return try ipi.IpiRaiseFtraceEventReader.init(buf);
        }
        return try ipi.IpiRaiseFtraceEventReader.init(&[_]u8{});
    }
    pub fn getSoftirqEntry(self: *const FtraceEventReader) gremlin.Error!irq.SoftirqEntryFtraceEventReader {
        if (self._softirq_entry_buf) |buf| {
            return try irq.SoftirqEntryFtraceEventReader.init(buf);
        }
        return try irq.SoftirqEntryFtraceEventReader.init(&[_]u8{});
    }
    pub fn getSoftirqExit(self: *const FtraceEventReader) gremlin.Error!irq.SoftirqExitFtraceEventReader {
        if (self._softirq_exit_buf) |buf| {
            return try irq.SoftirqExitFtraceEventReader.init(buf);
        }
        return try irq.SoftirqExitFtraceEventReader.init(&[_]u8{});
    }
    pub fn getSoftirqRaise(self: *const FtraceEventReader) gremlin.Error!irq.SoftirqRaiseFtraceEventReader {
        if (self._softirq_raise_buf) |buf| {
            return try irq.SoftirqRaiseFtraceEventReader.init(buf);
        }
        return try irq.SoftirqRaiseFtraceEventReader.init(&[_]u8{});
    }
    pub fn getI2cRead(self: *const FtraceEventReader) gremlin.Error!i2c.I2cReadFtraceEventReader {
        if (self._i2c_read_buf) |buf| {
            return try i2c.I2cReadFtraceEventReader.init(buf);
        }
        return try i2c.I2cReadFtraceEventReader.init(&[_]u8{});
    }
    pub fn getI2cWrite(self: *const FtraceEventReader) gremlin.Error!i2c.I2cWriteFtraceEventReader {
        if (self._i2c_write_buf) |buf| {
            return try i2c.I2cWriteFtraceEventReader.init(buf);
        }
        return try i2c.I2cWriteFtraceEventReader.init(&[_]u8{});
    }
    pub fn getI2cResult(self: *const FtraceEventReader) gremlin.Error!i2c.I2cResultFtraceEventReader {
        if (self._i2c_result_buf) |buf| {
            return try i2c.I2cResultFtraceEventReader.init(buf);
        }
        return try i2c.I2cResultFtraceEventReader.init(&[_]u8{});
    }
    pub fn getI2cReply(self: *const FtraceEventReader) gremlin.Error!i2c.I2cReplyFtraceEventReader {
        if (self._i2c_reply_buf) |buf| {
            return try i2c.I2cReplyFtraceEventReader.init(buf);
        }
        return try i2c.I2cReplyFtraceEventReader.init(&[_]u8{});
    }
    pub fn getSmbusRead(self: *const FtraceEventReader) gremlin.Error!i2c.SmbusReadFtraceEventReader {
        if (self._smbus_read_buf) |buf| {
            return try i2c.SmbusReadFtraceEventReader.init(buf);
        }
        return try i2c.SmbusReadFtraceEventReader.init(&[_]u8{});
    }
    pub fn getSmbusWrite(self: *const FtraceEventReader) gremlin.Error!i2c.SmbusWriteFtraceEventReader {
        if (self._smbus_write_buf) |buf| {
            return try i2c.SmbusWriteFtraceEventReader.init(buf);
        }
        return try i2c.SmbusWriteFtraceEventReader.init(&[_]u8{});
    }
    pub fn getSmbusResult(self: *const FtraceEventReader) gremlin.Error!i2c.SmbusResultFtraceEventReader {
        if (self._smbus_result_buf) |buf| {
            return try i2c.SmbusResultFtraceEventReader.init(buf);
        }
        return try i2c.SmbusResultFtraceEventReader.init(&[_]u8{});
    }
    pub fn getSmbusReply(self: *const FtraceEventReader) gremlin.Error!i2c.SmbusReplyFtraceEventReader {
        if (self._smbus_reply_buf) |buf| {
            return try i2c.SmbusReplyFtraceEventReader.init(buf);
        }
        return try i2c.SmbusReplyFtraceEventReader.init(&[_]u8{});
    }
    pub fn getLowmemoryKill(self: *const FtraceEventReader) gremlin.Error!lowmemorykiller.LowmemoryKillFtraceEventReader {
        if (self._lowmemory_kill_buf) |buf| {
            return try lowmemorykiller.LowmemoryKillFtraceEventReader.init(buf);
        }
        return try lowmemorykiller.LowmemoryKillFtraceEventReader.init(&[_]u8{});
    }
    pub fn getIrqHandlerEntry(self: *const FtraceEventReader) gremlin.Error!irq.IrqHandlerEntryFtraceEventReader {
        if (self._irq_handler_entry_buf) |buf| {
            return try irq.IrqHandlerEntryFtraceEventReader.init(buf);
        }
        return try irq.IrqHandlerEntryFtraceEventReader.init(&[_]u8{});
    }
    pub fn getIrqHandlerExit(self: *const FtraceEventReader) gremlin.Error!irq.IrqHandlerExitFtraceEventReader {
        if (self._irq_handler_exit_buf) |buf| {
            return try irq.IrqHandlerExitFtraceEventReader.init(buf);
        }
        return try irq.IrqHandlerExitFtraceEventReader.init(&[_]u8{});
    }
    pub fn getSyncPt(self: *const FtraceEventReader) gremlin.Error!sync.SyncPtFtraceEventReader {
        if (self._sync_pt_buf) |buf| {
            return try sync.SyncPtFtraceEventReader.init(buf);
        }
        return try sync.SyncPtFtraceEventReader.init(&[_]u8{});
    }
    pub fn getSyncTimeline(self: *const FtraceEventReader) gremlin.Error!sync.SyncTimelineFtraceEventReader {
        if (self._sync_timeline_buf) |buf| {
            return try sync.SyncTimelineFtraceEventReader.init(buf);
        }
        return try sync.SyncTimelineFtraceEventReader.init(&[_]u8{});
    }
    pub fn getSyncWait(self: *const FtraceEventReader) gremlin.Error!sync.SyncWaitFtraceEventReader {
        if (self._sync_wait_buf) |buf| {
            return try sync.SyncWaitFtraceEventReader.init(buf);
        }
        return try sync.SyncWaitFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4DaWriteBegin(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4DaWriteBeginFtraceEventReader {
        if (self._ext4_da_write_begin_buf) |buf| {
            return try ext4.Ext4DaWriteBeginFtraceEventReader.init(buf);
        }
        return try ext4.Ext4DaWriteBeginFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4DaWriteEnd(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4DaWriteEndFtraceEventReader {
        if (self._ext4_da_write_end_buf) |buf| {
            return try ext4.Ext4DaWriteEndFtraceEventReader.init(buf);
        }
        return try ext4.Ext4DaWriteEndFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4SyncFileEnter(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4SyncFileEnterFtraceEventReader {
        if (self._ext4_sync_file_enter_buf) |buf| {
            return try ext4.Ext4SyncFileEnterFtraceEventReader.init(buf);
        }
        return try ext4.Ext4SyncFileEnterFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4SyncFileExit(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4SyncFileExitFtraceEventReader {
        if (self._ext4_sync_file_exit_buf) |buf| {
            return try ext4.Ext4SyncFileExitFtraceEventReader.init(buf);
        }
        return try ext4.Ext4SyncFileExitFtraceEventReader.init(&[_]u8{});
    }
    pub fn getBlockRqIssue(self: *const FtraceEventReader) gremlin.Error!block.BlockRqIssueFtraceEventReader {
        if (self._block_rq_issue_buf) |buf| {
            return try block.BlockRqIssueFtraceEventReader.init(buf);
        }
        return try block.BlockRqIssueFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMmVmscanDirectReclaimBegin(self: *const FtraceEventReader) gremlin.Error!vmscan.MmVmscanDirectReclaimBeginFtraceEventReader {
        if (self._mm_vmscan_direct_reclaim_begin_buf) |buf| {
            return try vmscan.MmVmscanDirectReclaimBeginFtraceEventReader.init(buf);
        }
        return try vmscan.MmVmscanDirectReclaimBeginFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMmVmscanDirectReclaimEnd(self: *const FtraceEventReader) gremlin.Error!vmscan.MmVmscanDirectReclaimEndFtraceEventReader {
        if (self._mm_vmscan_direct_reclaim_end_buf) |buf| {
            return try vmscan.MmVmscanDirectReclaimEndFtraceEventReader.init(buf);
        }
        return try vmscan.MmVmscanDirectReclaimEndFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMmVmscanKswapdWake(self: *const FtraceEventReader) gremlin.Error!vmscan.MmVmscanKswapdWakeFtraceEventReader {
        if (self._mm_vmscan_kswapd_wake_buf) |buf| {
            return try vmscan.MmVmscanKswapdWakeFtraceEventReader.init(buf);
        }
        return try vmscan.MmVmscanKswapdWakeFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMmVmscanKswapdSleep(self: *const FtraceEventReader) gremlin.Error!vmscan.MmVmscanKswapdSleepFtraceEventReader {
        if (self._mm_vmscan_kswapd_sleep_buf) |buf| {
            return try vmscan.MmVmscanKswapdSleepFtraceEventReader.init(buf);
        }
        return try vmscan.MmVmscanKswapdSleepFtraceEventReader.init(&[_]u8{});
    }
    pub fn getBinderTransaction(self: *const FtraceEventReader) gremlin.Error!binder.BinderTransactionFtraceEventReader {
        if (self._binder_transaction_buf) |buf| {
            return try binder.BinderTransactionFtraceEventReader.init(buf);
        }
        return try binder.BinderTransactionFtraceEventReader.init(&[_]u8{});
    }
    pub fn getBinderTransactionReceived(self: *const FtraceEventReader) gremlin.Error!binder.BinderTransactionReceivedFtraceEventReader {
        if (self._binder_transaction_received_buf) |buf| {
            return try binder.BinderTransactionReceivedFtraceEventReader.init(buf);
        }
        return try binder.BinderTransactionReceivedFtraceEventReader.init(&[_]u8{});
    }
    pub fn getBinderSetPriority(self: *const FtraceEventReader) gremlin.Error!binder.BinderSetPriorityFtraceEventReader {
        if (self._binder_set_priority_buf) |buf| {
            return try binder.BinderSetPriorityFtraceEventReader.init(buf);
        }
        return try binder.BinderSetPriorityFtraceEventReader.init(&[_]u8{});
    }
    pub fn getBinderLock(self: *const FtraceEventReader) gremlin.Error!binder.BinderLockFtraceEventReader {
        if (self._binder_lock_buf) |buf| {
            return try binder.BinderLockFtraceEventReader.init(buf);
        }
        return try binder.BinderLockFtraceEventReader.init(&[_]u8{});
    }
    pub fn getBinderLocked(self: *const FtraceEventReader) gremlin.Error!binder.BinderLockedFtraceEventReader {
        if (self._binder_locked_buf) |buf| {
            return try binder.BinderLockedFtraceEventReader.init(buf);
        }
        return try binder.BinderLockedFtraceEventReader.init(&[_]u8{});
    }
    pub fn getBinderUnlock(self: *const FtraceEventReader) gremlin.Error!binder.BinderUnlockFtraceEventReader {
        if (self._binder_unlock_buf) |buf| {
            return try binder.BinderUnlockFtraceEventReader.init(buf);
        }
        return try binder.BinderUnlockFtraceEventReader.init(&[_]u8{});
    }
    pub fn getWorkqueueActivateWork(self: *const FtraceEventReader) gremlin.Error!workqueue.WorkqueueActivateWorkFtraceEventReader {
        if (self._workqueue_activate_work_buf) |buf| {
            return try workqueue.WorkqueueActivateWorkFtraceEventReader.init(buf);
        }
        return try workqueue.WorkqueueActivateWorkFtraceEventReader.init(&[_]u8{});
    }
    pub fn getWorkqueueExecuteEnd(self: *const FtraceEventReader) gremlin.Error!workqueue.WorkqueueExecuteEndFtraceEventReader {
        if (self._workqueue_execute_end_buf) |buf| {
            return try workqueue.WorkqueueExecuteEndFtraceEventReader.init(buf);
        }
        return try workqueue.WorkqueueExecuteEndFtraceEventReader.init(&[_]u8{});
    }
    pub fn getWorkqueueExecuteStart(self: *const FtraceEventReader) gremlin.Error!workqueue.WorkqueueExecuteStartFtraceEventReader {
        if (self._workqueue_execute_start_buf) |buf| {
            return try workqueue.WorkqueueExecuteStartFtraceEventReader.init(buf);
        }
        return try workqueue.WorkqueueExecuteStartFtraceEventReader.init(&[_]u8{});
    }
    pub fn getWorkqueueQueueWork(self: *const FtraceEventReader) gremlin.Error!workqueue.WorkqueueQueueWorkFtraceEventReader {
        if (self._workqueue_queue_work_buf) |buf| {
            return try workqueue.WorkqueueQueueWorkFtraceEventReader.init(buf);
        }
        return try workqueue.WorkqueueQueueWorkFtraceEventReader.init(&[_]u8{});
    }
    pub fn getRegulatorDisable(self: *const FtraceEventReader) gremlin.Error!regulator.RegulatorDisableFtraceEventReader {
        if (self._regulator_disable_buf) |buf| {
            return try regulator.RegulatorDisableFtraceEventReader.init(buf);
        }
        return try regulator.RegulatorDisableFtraceEventReader.init(&[_]u8{});
    }
    pub fn getRegulatorDisableComplete(self: *const FtraceEventReader) gremlin.Error!regulator.RegulatorDisableCompleteFtraceEventReader {
        if (self._regulator_disable_complete_buf) |buf| {
            return try regulator.RegulatorDisableCompleteFtraceEventReader.init(buf);
        }
        return try regulator.RegulatorDisableCompleteFtraceEventReader.init(&[_]u8{});
    }
    pub fn getRegulatorEnable(self: *const FtraceEventReader) gremlin.Error!regulator.RegulatorEnableFtraceEventReader {
        if (self._regulator_enable_buf) |buf| {
            return try regulator.RegulatorEnableFtraceEventReader.init(buf);
        }
        return try regulator.RegulatorEnableFtraceEventReader.init(&[_]u8{});
    }
    pub fn getRegulatorEnableComplete(self: *const FtraceEventReader) gremlin.Error!regulator.RegulatorEnableCompleteFtraceEventReader {
        if (self._regulator_enable_complete_buf) |buf| {
            return try regulator.RegulatorEnableCompleteFtraceEventReader.init(buf);
        }
        return try regulator.RegulatorEnableCompleteFtraceEventReader.init(&[_]u8{});
    }
    pub fn getRegulatorEnableDelay(self: *const FtraceEventReader) gremlin.Error!regulator.RegulatorEnableDelayFtraceEventReader {
        if (self._regulator_enable_delay_buf) |buf| {
            return try regulator.RegulatorEnableDelayFtraceEventReader.init(buf);
        }
        return try regulator.RegulatorEnableDelayFtraceEventReader.init(&[_]u8{});
    }
    pub fn getRegulatorSetVoltage(self: *const FtraceEventReader) gremlin.Error!regulator.RegulatorSetVoltageFtraceEventReader {
        if (self._regulator_set_voltage_buf) |buf| {
            return try regulator.RegulatorSetVoltageFtraceEventReader.init(buf);
        }
        return try regulator.RegulatorSetVoltageFtraceEventReader.init(&[_]u8{});
    }
    pub fn getRegulatorSetVoltageComplete(self: *const FtraceEventReader) gremlin.Error!regulator.RegulatorSetVoltageCompleteFtraceEventReader {
        if (self._regulator_set_voltage_complete_buf) |buf| {
            return try regulator.RegulatorSetVoltageCompleteFtraceEventReader.init(buf);
        }
        return try regulator.RegulatorSetVoltageCompleteFtraceEventReader.init(&[_]u8{});
    }
    pub fn getCgroupAttachTask(self: *const FtraceEventReader) gremlin.Error!cgroup.CgroupAttachTaskFtraceEventReader {
        if (self._cgroup_attach_task_buf) |buf| {
            return try cgroup.CgroupAttachTaskFtraceEventReader.init(buf);
        }
        return try cgroup.CgroupAttachTaskFtraceEventReader.init(&[_]u8{});
    }
    pub fn getCgroupMkdir(self: *const FtraceEventReader) gremlin.Error!cgroup.CgroupMkdirFtraceEventReader {
        if (self._cgroup_mkdir_buf) |buf| {
            return try cgroup.CgroupMkdirFtraceEventReader.init(buf);
        }
        return try cgroup.CgroupMkdirFtraceEventReader.init(&[_]u8{});
    }
    pub fn getCgroupRemount(self: *const FtraceEventReader) gremlin.Error!cgroup.CgroupRemountFtraceEventReader {
        if (self._cgroup_remount_buf) |buf| {
            return try cgroup.CgroupRemountFtraceEventReader.init(buf);
        }
        return try cgroup.CgroupRemountFtraceEventReader.init(&[_]u8{});
    }
    pub fn getCgroupRmdir(self: *const FtraceEventReader) gremlin.Error!cgroup.CgroupRmdirFtraceEventReader {
        if (self._cgroup_rmdir_buf) |buf| {
            return try cgroup.CgroupRmdirFtraceEventReader.init(buf);
        }
        return try cgroup.CgroupRmdirFtraceEventReader.init(&[_]u8{});
    }
    pub fn getCgroupTransferTasks(self: *const FtraceEventReader) gremlin.Error!cgroup.CgroupTransferTasksFtraceEventReader {
        if (self._cgroup_transfer_tasks_buf) |buf| {
            return try cgroup.CgroupTransferTasksFtraceEventReader.init(buf);
        }
        return try cgroup.CgroupTransferTasksFtraceEventReader.init(&[_]u8{});
    }
    pub fn getCgroupDestroyRoot(self: *const FtraceEventReader) gremlin.Error!cgroup.CgroupDestroyRootFtraceEventReader {
        if (self._cgroup_destroy_root_buf) |buf| {
            return try cgroup.CgroupDestroyRootFtraceEventReader.init(buf);
        }
        return try cgroup.CgroupDestroyRootFtraceEventReader.init(&[_]u8{});
    }
    pub fn getCgroupRelease(self: *const FtraceEventReader) gremlin.Error!cgroup.CgroupReleaseFtraceEventReader {
        if (self._cgroup_release_buf) |buf| {
            return try cgroup.CgroupReleaseFtraceEventReader.init(buf);
        }
        return try cgroup.CgroupReleaseFtraceEventReader.init(&[_]u8{});
    }
    pub fn getCgroupRename(self: *const FtraceEventReader) gremlin.Error!cgroup.CgroupRenameFtraceEventReader {
        if (self._cgroup_rename_buf) |buf| {
            return try cgroup.CgroupRenameFtraceEventReader.init(buf);
        }
        return try cgroup.CgroupRenameFtraceEventReader.init(&[_]u8{});
    }
    pub fn getCgroupSetupRoot(self: *const FtraceEventReader) gremlin.Error!cgroup.CgroupSetupRootFtraceEventReader {
        if (self._cgroup_setup_root_buf) |buf| {
            return try cgroup.CgroupSetupRootFtraceEventReader.init(buf);
        }
        return try cgroup.CgroupSetupRootFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMdpCmdKickoff(self: *const FtraceEventReader) gremlin.Error!mdss.MdpCmdKickoffFtraceEventReader {
        if (self._mdp_cmd_kickoff_buf) |buf| {
            return try mdss.MdpCmdKickoffFtraceEventReader.init(buf);
        }
        return try mdss.MdpCmdKickoffFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMdpCommit(self: *const FtraceEventReader) gremlin.Error!mdss.MdpCommitFtraceEventReader {
        if (self._mdp_commit_buf) |buf| {
            return try mdss.MdpCommitFtraceEventReader.init(buf);
        }
        return try mdss.MdpCommitFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMdpPerfSetOt(self: *const FtraceEventReader) gremlin.Error!mdss.MdpPerfSetOtFtraceEventReader {
        if (self._mdp_perf_set_ot_buf) |buf| {
            return try mdss.MdpPerfSetOtFtraceEventReader.init(buf);
        }
        return try mdss.MdpPerfSetOtFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMdpSsppChange(self: *const FtraceEventReader) gremlin.Error!mdss.MdpSsppChangeFtraceEventReader {
        if (self._mdp_sspp_change_buf) |buf| {
            return try mdss.MdpSsppChangeFtraceEventReader.init(buf);
        }
        return try mdss.MdpSsppChangeFtraceEventReader.init(&[_]u8{});
    }
    pub fn getTracingMarkWrite(self: *const FtraceEventReader) gremlin.Error!mdss.TracingMarkWriteFtraceEventReader {
        if (self._tracing_mark_write_buf) |buf| {
            return try mdss.TracingMarkWriteFtraceEventReader.init(buf);
        }
        return try mdss.TracingMarkWriteFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMdpCmdPingpongDone(self: *const FtraceEventReader) gremlin.Error!mdss.MdpCmdPingpongDoneFtraceEventReader {
        if (self._mdp_cmd_pingpong_done_buf) |buf| {
            return try mdss.MdpCmdPingpongDoneFtraceEventReader.init(buf);
        }
        return try mdss.MdpCmdPingpongDoneFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMdpCompareBw(self: *const FtraceEventReader) gremlin.Error!mdss.MdpCompareBwFtraceEventReader {
        if (self._mdp_compare_bw_buf) |buf| {
            return try mdss.MdpCompareBwFtraceEventReader.init(buf);
        }
        return try mdss.MdpCompareBwFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMdpPerfSetPanicLuts(self: *const FtraceEventReader) gremlin.Error!mdss.MdpPerfSetPanicLutsFtraceEventReader {
        if (self._mdp_perf_set_panic_luts_buf) |buf| {
            return try mdss.MdpPerfSetPanicLutsFtraceEventReader.init(buf);
        }
        return try mdss.MdpPerfSetPanicLutsFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMdpSsppSet(self: *const FtraceEventReader) gremlin.Error!mdss.MdpSsppSetFtraceEventReader {
        if (self._mdp_sspp_set_buf) |buf| {
            return try mdss.MdpSsppSetFtraceEventReader.init(buf);
        }
        return try mdss.MdpSsppSetFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMdpCmdReadptrDone(self: *const FtraceEventReader) gremlin.Error!mdss.MdpCmdReadptrDoneFtraceEventReader {
        if (self._mdp_cmd_readptr_done_buf) |buf| {
            return try mdss.MdpCmdReadptrDoneFtraceEventReader.init(buf);
        }
        return try mdss.MdpCmdReadptrDoneFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMdpMisrCrc(self: *const FtraceEventReader) gremlin.Error!mdss.MdpMisrCrcFtraceEventReader {
        if (self._mdp_misr_crc_buf) |buf| {
            return try mdss.MdpMisrCrcFtraceEventReader.init(buf);
        }
        return try mdss.MdpMisrCrcFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMdpPerfSetQosLuts(self: *const FtraceEventReader) gremlin.Error!mdss.MdpPerfSetQosLutsFtraceEventReader {
        if (self._mdp_perf_set_qos_luts_buf) |buf| {
            return try mdss.MdpPerfSetQosLutsFtraceEventReader.init(buf);
        }
        return try mdss.MdpPerfSetQosLutsFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMdpTraceCounter(self: *const FtraceEventReader) gremlin.Error!mdss.MdpTraceCounterFtraceEventReader {
        if (self._mdp_trace_counter_buf) |buf| {
            return try mdss.MdpTraceCounterFtraceEventReader.init(buf);
        }
        return try mdss.MdpTraceCounterFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMdpCmdReleaseBw(self: *const FtraceEventReader) gremlin.Error!mdss.MdpCmdReleaseBwFtraceEventReader {
        if (self._mdp_cmd_release_bw_buf) |buf| {
            return try mdss.MdpCmdReleaseBwFtraceEventReader.init(buf);
        }
        return try mdss.MdpCmdReleaseBwFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMdpMixerUpdate(self: *const FtraceEventReader) gremlin.Error!mdss.MdpMixerUpdateFtraceEventReader {
        if (self._mdp_mixer_update_buf) |buf| {
            return try mdss.MdpMixerUpdateFtraceEventReader.init(buf);
        }
        return try mdss.MdpMixerUpdateFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMdpPerfSetWmLevels(self: *const FtraceEventReader) gremlin.Error!mdss.MdpPerfSetWmLevelsFtraceEventReader {
        if (self._mdp_perf_set_wm_levels_buf) |buf| {
            return try mdss.MdpPerfSetWmLevelsFtraceEventReader.init(buf);
        }
        return try mdss.MdpPerfSetWmLevelsFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMdpVideoUnderrunDone(self: *const FtraceEventReader) gremlin.Error!mdss.MdpVideoUnderrunDoneFtraceEventReader {
        if (self._mdp_video_underrun_done_buf) |buf| {
            return try mdss.MdpVideoUnderrunDoneFtraceEventReader.init(buf);
        }
        return try mdss.MdpVideoUnderrunDoneFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMdpCmdWaitPingpong(self: *const FtraceEventReader) gremlin.Error!mdss.MdpCmdWaitPingpongFtraceEventReader {
        if (self._mdp_cmd_wait_pingpong_buf) |buf| {
            return try mdss.MdpCmdWaitPingpongFtraceEventReader.init(buf);
        }
        return try mdss.MdpCmdWaitPingpongFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMdpPerfPrefillCalc(self: *const FtraceEventReader) gremlin.Error!mdss.MdpPerfPrefillCalcFtraceEventReader {
        if (self._mdp_perf_prefill_calc_buf) |buf| {
            return try mdss.MdpPerfPrefillCalcFtraceEventReader.init(buf);
        }
        return try mdss.MdpPerfPrefillCalcFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMdpPerfUpdateBus(self: *const FtraceEventReader) gremlin.Error!mdss.MdpPerfUpdateBusFtraceEventReader {
        if (self._mdp_perf_update_bus_buf) |buf| {
            return try mdss.MdpPerfUpdateBusFtraceEventReader.init(buf);
        }
        return try mdss.MdpPerfUpdateBusFtraceEventReader.init(&[_]u8{});
    }
    pub fn getRotatorBwAoAsContext(self: *const FtraceEventReader) gremlin.Error!mdss.RotatorBwAoAsContextFtraceEventReader {
        if (self._rotator_bw_ao_as_context_buf) |buf| {
            return try mdss.RotatorBwAoAsContextFtraceEventReader.init(buf);
        }
        return try mdss.RotatorBwAoAsContextFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMmFilemapAddToPageCache(self: *const FtraceEventReader) gremlin.Error!filemap.MmFilemapAddToPageCacheFtraceEventReader {
        if (self._mm_filemap_add_to_page_cache_buf) |buf| {
            return try filemap.MmFilemapAddToPageCacheFtraceEventReader.init(buf);
        }
        return try filemap.MmFilemapAddToPageCacheFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMmFilemapDeleteFromPageCache(self: *const FtraceEventReader) gremlin.Error!filemap.MmFilemapDeleteFromPageCacheFtraceEventReader {
        if (self._mm_filemap_delete_from_page_cache_buf) |buf| {
            return try filemap.MmFilemapDeleteFromPageCacheFtraceEventReader.init(buf);
        }
        return try filemap.MmFilemapDeleteFromPageCacheFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMmCompactionBegin(self: *const FtraceEventReader) gremlin.Error!compaction.MmCompactionBeginFtraceEventReader {
        if (self._mm_compaction_begin_buf) |buf| {
            return try compaction.MmCompactionBeginFtraceEventReader.init(buf);
        }
        return try compaction.MmCompactionBeginFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMmCompactionDeferCompaction(self: *const FtraceEventReader) gremlin.Error!compaction.MmCompactionDeferCompactionFtraceEventReader {
        if (self._mm_compaction_defer_compaction_buf) |buf| {
            return try compaction.MmCompactionDeferCompactionFtraceEventReader.init(buf);
        }
        return try compaction.MmCompactionDeferCompactionFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMmCompactionDeferred(self: *const FtraceEventReader) gremlin.Error!compaction.MmCompactionDeferredFtraceEventReader {
        if (self._mm_compaction_deferred_buf) |buf| {
            return try compaction.MmCompactionDeferredFtraceEventReader.init(buf);
        }
        return try compaction.MmCompactionDeferredFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMmCompactionDeferReset(self: *const FtraceEventReader) gremlin.Error!compaction.MmCompactionDeferResetFtraceEventReader {
        if (self._mm_compaction_defer_reset_buf) |buf| {
            return try compaction.MmCompactionDeferResetFtraceEventReader.init(buf);
        }
        return try compaction.MmCompactionDeferResetFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMmCompactionEnd(self: *const FtraceEventReader) gremlin.Error!compaction.MmCompactionEndFtraceEventReader {
        if (self._mm_compaction_end_buf) |buf| {
            return try compaction.MmCompactionEndFtraceEventReader.init(buf);
        }
        return try compaction.MmCompactionEndFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMmCompactionFinished(self: *const FtraceEventReader) gremlin.Error!compaction.MmCompactionFinishedFtraceEventReader {
        if (self._mm_compaction_finished_buf) |buf| {
            return try compaction.MmCompactionFinishedFtraceEventReader.init(buf);
        }
        return try compaction.MmCompactionFinishedFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMmCompactionIsolateFreepages(self: *const FtraceEventReader) gremlin.Error!compaction.MmCompactionIsolateFreepagesFtraceEventReader {
        if (self._mm_compaction_isolate_freepages_buf) |buf| {
            return try compaction.MmCompactionIsolateFreepagesFtraceEventReader.init(buf);
        }
        return try compaction.MmCompactionIsolateFreepagesFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMmCompactionIsolateMigratepages(self: *const FtraceEventReader) gremlin.Error!compaction.MmCompactionIsolateMigratepagesFtraceEventReader {
        if (self._mm_compaction_isolate_migratepages_buf) |buf| {
            return try compaction.MmCompactionIsolateMigratepagesFtraceEventReader.init(buf);
        }
        return try compaction.MmCompactionIsolateMigratepagesFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMmCompactionKcompactdSleep(self: *const FtraceEventReader) gremlin.Error!compaction.MmCompactionKcompactdSleepFtraceEventReader {
        if (self._mm_compaction_kcompactd_sleep_buf) |buf| {
            return try compaction.MmCompactionKcompactdSleepFtraceEventReader.init(buf);
        }
        return try compaction.MmCompactionKcompactdSleepFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMmCompactionKcompactdWake(self: *const FtraceEventReader) gremlin.Error!compaction.MmCompactionKcompactdWakeFtraceEventReader {
        if (self._mm_compaction_kcompactd_wake_buf) |buf| {
            return try compaction.MmCompactionKcompactdWakeFtraceEventReader.init(buf);
        }
        return try compaction.MmCompactionKcompactdWakeFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMmCompactionMigratepages(self: *const FtraceEventReader) gremlin.Error!compaction.MmCompactionMigratepagesFtraceEventReader {
        if (self._mm_compaction_migratepages_buf) |buf| {
            return try compaction.MmCompactionMigratepagesFtraceEventReader.init(buf);
        }
        return try compaction.MmCompactionMigratepagesFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMmCompactionSuitable(self: *const FtraceEventReader) gremlin.Error!compaction.MmCompactionSuitableFtraceEventReader {
        if (self._mm_compaction_suitable_buf) |buf| {
            return try compaction.MmCompactionSuitableFtraceEventReader.init(buf);
        }
        return try compaction.MmCompactionSuitableFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMmCompactionTryToCompactPages(self: *const FtraceEventReader) gremlin.Error!compaction.MmCompactionTryToCompactPagesFtraceEventReader {
        if (self._mm_compaction_try_to_compact_pages_buf) |buf| {
            return try compaction.MmCompactionTryToCompactPagesFtraceEventReader.init(buf);
        }
        return try compaction.MmCompactionTryToCompactPagesFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMmCompactionWakeupKcompactd(self: *const FtraceEventReader) gremlin.Error!compaction.MmCompactionWakeupKcompactdFtraceEventReader {
        if (self._mm_compaction_wakeup_kcompactd_buf) |buf| {
            return try compaction.MmCompactionWakeupKcompactdFtraceEventReader.init(buf);
        }
        return try compaction.MmCompactionWakeupKcompactdFtraceEventReader.init(&[_]u8{});
    }
    pub fn getSuspendResume(self: *const FtraceEventReader) gremlin.Error!power.SuspendResumeFtraceEventReader {
        if (self._suspend_resume_buf) |buf| {
            return try power.SuspendResumeFtraceEventReader.init(buf);
        }
        return try power.SuspendResumeFtraceEventReader.init(&[_]u8{});
    }
    pub fn getSchedWakeupNew(self: *const FtraceEventReader) gremlin.Error!sched.SchedWakeupNewFtraceEventReader {
        if (self._sched_wakeup_new_buf) |buf| {
            return try sched.SchedWakeupNewFtraceEventReader.init(buf);
        }
        return try sched.SchedWakeupNewFtraceEventReader.init(&[_]u8{});
    }
    pub fn getBlockBioBackmerge(self: *const FtraceEventReader) gremlin.Error!block.BlockBioBackmergeFtraceEventReader {
        if (self._block_bio_backmerge_buf) |buf| {
            return try block.BlockBioBackmergeFtraceEventReader.init(buf);
        }
        return try block.BlockBioBackmergeFtraceEventReader.init(&[_]u8{});
    }
    pub fn getBlockBioBounce(self: *const FtraceEventReader) gremlin.Error!block.BlockBioBounceFtraceEventReader {
        if (self._block_bio_bounce_buf) |buf| {
            return try block.BlockBioBounceFtraceEventReader.init(buf);
        }
        return try block.BlockBioBounceFtraceEventReader.init(&[_]u8{});
    }
    pub fn getBlockBioComplete(self: *const FtraceEventReader) gremlin.Error!block.BlockBioCompleteFtraceEventReader {
        if (self._block_bio_complete_buf) |buf| {
            return try block.BlockBioCompleteFtraceEventReader.init(buf);
        }
        return try block.BlockBioCompleteFtraceEventReader.init(&[_]u8{});
    }
    pub fn getBlockBioFrontmerge(self: *const FtraceEventReader) gremlin.Error!block.BlockBioFrontmergeFtraceEventReader {
        if (self._block_bio_frontmerge_buf) |buf| {
            return try block.BlockBioFrontmergeFtraceEventReader.init(buf);
        }
        return try block.BlockBioFrontmergeFtraceEventReader.init(&[_]u8{});
    }
    pub fn getBlockBioQueue(self: *const FtraceEventReader) gremlin.Error!block.BlockBioQueueFtraceEventReader {
        if (self._block_bio_queue_buf) |buf| {
            return try block.BlockBioQueueFtraceEventReader.init(buf);
        }
        return try block.BlockBioQueueFtraceEventReader.init(&[_]u8{});
    }
    pub fn getBlockBioRemap(self: *const FtraceEventReader) gremlin.Error!block.BlockBioRemapFtraceEventReader {
        if (self._block_bio_remap_buf) |buf| {
            return try block.BlockBioRemapFtraceEventReader.init(buf);
        }
        return try block.BlockBioRemapFtraceEventReader.init(&[_]u8{});
    }
    pub fn getBlockDirtyBuffer(self: *const FtraceEventReader) gremlin.Error!block.BlockDirtyBufferFtraceEventReader {
        if (self._block_dirty_buffer_buf) |buf| {
            return try block.BlockDirtyBufferFtraceEventReader.init(buf);
        }
        return try block.BlockDirtyBufferFtraceEventReader.init(&[_]u8{});
    }
    pub fn getBlockGetrq(self: *const FtraceEventReader) gremlin.Error!block.BlockGetrqFtraceEventReader {
        if (self._block_getrq_buf) |buf| {
            return try block.BlockGetrqFtraceEventReader.init(buf);
        }
        return try block.BlockGetrqFtraceEventReader.init(&[_]u8{});
    }
    pub fn getBlockPlug(self: *const FtraceEventReader) gremlin.Error!block.BlockPlugFtraceEventReader {
        if (self._block_plug_buf) |buf| {
            return try block.BlockPlugFtraceEventReader.init(buf);
        }
        return try block.BlockPlugFtraceEventReader.init(&[_]u8{});
    }
    pub fn getBlockRqAbort(self: *const FtraceEventReader) gremlin.Error!block.BlockRqAbortFtraceEventReader {
        if (self._block_rq_abort_buf) |buf| {
            return try block.BlockRqAbortFtraceEventReader.init(buf);
        }
        return try block.BlockRqAbortFtraceEventReader.init(&[_]u8{});
    }
    pub fn getBlockRqComplete(self: *const FtraceEventReader) gremlin.Error!block.BlockRqCompleteFtraceEventReader {
        if (self._block_rq_complete_buf) |buf| {
            return try block.BlockRqCompleteFtraceEventReader.init(buf);
        }
        return try block.BlockRqCompleteFtraceEventReader.init(&[_]u8{});
    }
    pub fn getBlockRqInsert(self: *const FtraceEventReader) gremlin.Error!block.BlockRqInsertFtraceEventReader {
        if (self._block_rq_insert_buf) |buf| {
            return try block.BlockRqInsertFtraceEventReader.init(buf);
        }
        return try block.BlockRqInsertFtraceEventReader.init(&[_]u8{});
    }
    pub fn getBlockRqRemap(self: *const FtraceEventReader) gremlin.Error!block.BlockRqRemapFtraceEventReader {
        if (self._block_rq_remap_buf) |buf| {
            return try block.BlockRqRemapFtraceEventReader.init(buf);
        }
        return try block.BlockRqRemapFtraceEventReader.init(&[_]u8{});
    }
    pub fn getBlockRqRequeue(self: *const FtraceEventReader) gremlin.Error!block.BlockRqRequeueFtraceEventReader {
        if (self._block_rq_requeue_buf) |buf| {
            return try block.BlockRqRequeueFtraceEventReader.init(buf);
        }
        return try block.BlockRqRequeueFtraceEventReader.init(&[_]u8{});
    }
    pub fn getBlockSleeprq(self: *const FtraceEventReader) gremlin.Error!block.BlockSleeprqFtraceEventReader {
        if (self._block_sleeprq_buf) |buf| {
            return try block.BlockSleeprqFtraceEventReader.init(buf);
        }
        return try block.BlockSleeprqFtraceEventReader.init(&[_]u8{});
    }
    pub fn getBlockSplit(self: *const FtraceEventReader) gremlin.Error!block.BlockSplitFtraceEventReader {
        if (self._block_split_buf) |buf| {
            return try block.BlockSplitFtraceEventReader.init(buf);
        }
        return try block.BlockSplitFtraceEventReader.init(&[_]u8{});
    }
    pub fn getBlockTouchBuffer(self: *const FtraceEventReader) gremlin.Error!block.BlockTouchBufferFtraceEventReader {
        if (self._block_touch_buffer_buf) |buf| {
            return try block.BlockTouchBufferFtraceEventReader.init(buf);
        }
        return try block.BlockTouchBufferFtraceEventReader.init(&[_]u8{});
    }
    pub fn getBlockUnplug(self: *const FtraceEventReader) gremlin.Error!block.BlockUnplugFtraceEventReader {
        if (self._block_unplug_buf) |buf| {
            return try block.BlockUnplugFtraceEventReader.init(buf);
        }
        return try block.BlockUnplugFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4AllocDaBlocks(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4AllocDaBlocksFtraceEventReader {
        if (self._ext4_alloc_da_blocks_buf) |buf| {
            return try ext4.Ext4AllocDaBlocksFtraceEventReader.init(buf);
        }
        return try ext4.Ext4AllocDaBlocksFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4AllocateBlocks(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4AllocateBlocksFtraceEventReader {
        if (self._ext4_allocate_blocks_buf) |buf| {
            return try ext4.Ext4AllocateBlocksFtraceEventReader.init(buf);
        }
        return try ext4.Ext4AllocateBlocksFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4AllocateInode(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4AllocateInodeFtraceEventReader {
        if (self._ext4_allocate_inode_buf) |buf| {
            return try ext4.Ext4AllocateInodeFtraceEventReader.init(buf);
        }
        return try ext4.Ext4AllocateInodeFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4BeginOrderedTruncate(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4BeginOrderedTruncateFtraceEventReader {
        if (self._ext4_begin_ordered_truncate_buf) |buf| {
            return try ext4.Ext4BeginOrderedTruncateFtraceEventReader.init(buf);
        }
        return try ext4.Ext4BeginOrderedTruncateFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4CollapseRange(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4CollapseRangeFtraceEventReader {
        if (self._ext4_collapse_range_buf) |buf| {
            return try ext4.Ext4CollapseRangeFtraceEventReader.init(buf);
        }
        return try ext4.Ext4CollapseRangeFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4DaReleaseSpace(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4DaReleaseSpaceFtraceEventReader {
        if (self._ext4_da_release_space_buf) |buf| {
            return try ext4.Ext4DaReleaseSpaceFtraceEventReader.init(buf);
        }
        return try ext4.Ext4DaReleaseSpaceFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4DaReserveSpace(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4DaReserveSpaceFtraceEventReader {
        if (self._ext4_da_reserve_space_buf) |buf| {
            return try ext4.Ext4DaReserveSpaceFtraceEventReader.init(buf);
        }
        return try ext4.Ext4DaReserveSpaceFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4DaUpdateReserveSpace(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4DaUpdateReserveSpaceFtraceEventReader {
        if (self._ext4_da_update_reserve_space_buf) |buf| {
            return try ext4.Ext4DaUpdateReserveSpaceFtraceEventReader.init(buf);
        }
        return try ext4.Ext4DaUpdateReserveSpaceFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4DaWritePages(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4DaWritePagesFtraceEventReader {
        if (self._ext4_da_write_pages_buf) |buf| {
            return try ext4.Ext4DaWritePagesFtraceEventReader.init(buf);
        }
        return try ext4.Ext4DaWritePagesFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4DaWritePagesExtent(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4DaWritePagesExtentFtraceEventReader {
        if (self._ext4_da_write_pages_extent_buf) |buf| {
            return try ext4.Ext4DaWritePagesExtentFtraceEventReader.init(buf);
        }
        return try ext4.Ext4DaWritePagesExtentFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4DirectIOEnter(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4DirectIOEnterFtraceEventReader {
        if (self._ext4_direct_i_o_enter_buf) |buf| {
            return try ext4.Ext4DirectIOEnterFtraceEventReader.init(buf);
        }
        return try ext4.Ext4DirectIOEnterFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4DirectIOExit(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4DirectIOExitFtraceEventReader {
        if (self._ext4_direct_i_o_exit_buf) |buf| {
            return try ext4.Ext4DirectIOExitFtraceEventReader.init(buf);
        }
        return try ext4.Ext4DirectIOExitFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4DiscardBlocks(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4DiscardBlocksFtraceEventReader {
        if (self._ext4_discard_blocks_buf) |buf| {
            return try ext4.Ext4DiscardBlocksFtraceEventReader.init(buf);
        }
        return try ext4.Ext4DiscardBlocksFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4DiscardPreallocations(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4DiscardPreallocationsFtraceEventReader {
        if (self._ext4_discard_preallocations_buf) |buf| {
            return try ext4.Ext4DiscardPreallocationsFtraceEventReader.init(buf);
        }
        return try ext4.Ext4DiscardPreallocationsFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4DropInode(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4DropInodeFtraceEventReader {
        if (self._ext4_drop_inode_buf) |buf| {
            return try ext4.Ext4DropInodeFtraceEventReader.init(buf);
        }
        return try ext4.Ext4DropInodeFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4EsCacheExtent(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4EsCacheExtentFtraceEventReader {
        if (self._ext4_es_cache_extent_buf) |buf| {
            return try ext4.Ext4EsCacheExtentFtraceEventReader.init(buf);
        }
        return try ext4.Ext4EsCacheExtentFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4EsFindDelayedExtentRangeEnter(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4EsFindDelayedExtentRangeEnterFtraceEventReader {
        if (self._ext4_es_find_delayed_extent_range_enter_buf) |buf| {
            return try ext4.Ext4EsFindDelayedExtentRangeEnterFtraceEventReader.init(buf);
        }
        return try ext4.Ext4EsFindDelayedExtentRangeEnterFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4EsFindDelayedExtentRangeExit(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4EsFindDelayedExtentRangeExitFtraceEventReader {
        if (self._ext4_es_find_delayed_extent_range_exit_buf) |buf| {
            return try ext4.Ext4EsFindDelayedExtentRangeExitFtraceEventReader.init(buf);
        }
        return try ext4.Ext4EsFindDelayedExtentRangeExitFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4EsInsertExtent(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4EsInsertExtentFtraceEventReader {
        if (self._ext4_es_insert_extent_buf) |buf| {
            return try ext4.Ext4EsInsertExtentFtraceEventReader.init(buf);
        }
        return try ext4.Ext4EsInsertExtentFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4EsLookupExtentEnter(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4EsLookupExtentEnterFtraceEventReader {
        if (self._ext4_es_lookup_extent_enter_buf) |buf| {
            return try ext4.Ext4EsLookupExtentEnterFtraceEventReader.init(buf);
        }
        return try ext4.Ext4EsLookupExtentEnterFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4EsLookupExtentExit(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4EsLookupExtentExitFtraceEventReader {
        if (self._ext4_es_lookup_extent_exit_buf) |buf| {
            return try ext4.Ext4EsLookupExtentExitFtraceEventReader.init(buf);
        }
        return try ext4.Ext4EsLookupExtentExitFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4EsRemoveExtent(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4EsRemoveExtentFtraceEventReader {
        if (self._ext4_es_remove_extent_buf) |buf| {
            return try ext4.Ext4EsRemoveExtentFtraceEventReader.init(buf);
        }
        return try ext4.Ext4EsRemoveExtentFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4EsShrink(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4EsShrinkFtraceEventReader {
        if (self._ext4_es_shrink_buf) |buf| {
            return try ext4.Ext4EsShrinkFtraceEventReader.init(buf);
        }
        return try ext4.Ext4EsShrinkFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4EsShrinkCount(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4EsShrinkCountFtraceEventReader {
        if (self._ext4_es_shrink_count_buf) |buf| {
            return try ext4.Ext4EsShrinkCountFtraceEventReader.init(buf);
        }
        return try ext4.Ext4EsShrinkCountFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4EsShrinkScanEnter(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4EsShrinkScanEnterFtraceEventReader {
        if (self._ext4_es_shrink_scan_enter_buf) |buf| {
            return try ext4.Ext4EsShrinkScanEnterFtraceEventReader.init(buf);
        }
        return try ext4.Ext4EsShrinkScanEnterFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4EsShrinkScanExit(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4EsShrinkScanExitFtraceEventReader {
        if (self._ext4_es_shrink_scan_exit_buf) |buf| {
            return try ext4.Ext4EsShrinkScanExitFtraceEventReader.init(buf);
        }
        return try ext4.Ext4EsShrinkScanExitFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4EvictInode(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4EvictInodeFtraceEventReader {
        if (self._ext4_evict_inode_buf) |buf| {
            return try ext4.Ext4EvictInodeFtraceEventReader.init(buf);
        }
        return try ext4.Ext4EvictInodeFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4ExtConvertToInitializedEnter(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4ExtConvertToInitializedEnterFtraceEventReader {
        if (self._ext4_ext_convert_to_initialized_enter_buf) |buf| {
            return try ext4.Ext4ExtConvertToInitializedEnterFtraceEventReader.init(buf);
        }
        return try ext4.Ext4ExtConvertToInitializedEnterFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4ExtConvertToInitializedFastpath(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4ExtConvertToInitializedFastpathFtraceEventReader {
        if (self._ext4_ext_convert_to_initialized_fastpath_buf) |buf| {
            return try ext4.Ext4ExtConvertToInitializedFastpathFtraceEventReader.init(buf);
        }
        return try ext4.Ext4ExtConvertToInitializedFastpathFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4ExtHandleUnwrittenExtents(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4ExtHandleUnwrittenExtentsFtraceEventReader {
        if (self._ext4_ext_handle_unwritten_extents_buf) |buf| {
            return try ext4.Ext4ExtHandleUnwrittenExtentsFtraceEventReader.init(buf);
        }
        return try ext4.Ext4ExtHandleUnwrittenExtentsFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4ExtInCache(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4ExtInCacheFtraceEventReader {
        if (self._ext4_ext_in_cache_buf) |buf| {
            return try ext4.Ext4ExtInCacheFtraceEventReader.init(buf);
        }
        return try ext4.Ext4ExtInCacheFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4ExtLoadExtent(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4ExtLoadExtentFtraceEventReader {
        if (self._ext4_ext_load_extent_buf) |buf| {
            return try ext4.Ext4ExtLoadExtentFtraceEventReader.init(buf);
        }
        return try ext4.Ext4ExtLoadExtentFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4ExtMapBlocksEnter(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4ExtMapBlocksEnterFtraceEventReader {
        if (self._ext4_ext_map_blocks_enter_buf) |buf| {
            return try ext4.Ext4ExtMapBlocksEnterFtraceEventReader.init(buf);
        }
        return try ext4.Ext4ExtMapBlocksEnterFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4ExtMapBlocksExit(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4ExtMapBlocksExitFtraceEventReader {
        if (self._ext4_ext_map_blocks_exit_buf) |buf| {
            return try ext4.Ext4ExtMapBlocksExitFtraceEventReader.init(buf);
        }
        return try ext4.Ext4ExtMapBlocksExitFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4ExtPutInCache(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4ExtPutInCacheFtraceEventReader {
        if (self._ext4_ext_put_in_cache_buf) |buf| {
            return try ext4.Ext4ExtPutInCacheFtraceEventReader.init(buf);
        }
        return try ext4.Ext4ExtPutInCacheFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4ExtRemoveSpace(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4ExtRemoveSpaceFtraceEventReader {
        if (self._ext4_ext_remove_space_buf) |buf| {
            return try ext4.Ext4ExtRemoveSpaceFtraceEventReader.init(buf);
        }
        return try ext4.Ext4ExtRemoveSpaceFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4ExtRemoveSpaceDone(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4ExtRemoveSpaceDoneFtraceEventReader {
        if (self._ext4_ext_remove_space_done_buf) |buf| {
            return try ext4.Ext4ExtRemoveSpaceDoneFtraceEventReader.init(buf);
        }
        return try ext4.Ext4ExtRemoveSpaceDoneFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4ExtRmIdx(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4ExtRmIdxFtraceEventReader {
        if (self._ext4_ext_rm_idx_buf) |buf| {
            return try ext4.Ext4ExtRmIdxFtraceEventReader.init(buf);
        }
        return try ext4.Ext4ExtRmIdxFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4ExtRmLeaf(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4ExtRmLeafFtraceEventReader {
        if (self._ext4_ext_rm_leaf_buf) |buf| {
            return try ext4.Ext4ExtRmLeafFtraceEventReader.init(buf);
        }
        return try ext4.Ext4ExtRmLeafFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4ExtShowExtent(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4ExtShowExtentFtraceEventReader {
        if (self._ext4_ext_show_extent_buf) |buf| {
            return try ext4.Ext4ExtShowExtentFtraceEventReader.init(buf);
        }
        return try ext4.Ext4ExtShowExtentFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4FallocateEnter(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4FallocateEnterFtraceEventReader {
        if (self._ext4_fallocate_enter_buf) |buf| {
            return try ext4.Ext4FallocateEnterFtraceEventReader.init(buf);
        }
        return try ext4.Ext4FallocateEnterFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4FallocateExit(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4FallocateExitFtraceEventReader {
        if (self._ext4_fallocate_exit_buf) |buf| {
            return try ext4.Ext4FallocateExitFtraceEventReader.init(buf);
        }
        return try ext4.Ext4FallocateExitFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4FindDelallocRange(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4FindDelallocRangeFtraceEventReader {
        if (self._ext4_find_delalloc_range_buf) |buf| {
            return try ext4.Ext4FindDelallocRangeFtraceEventReader.init(buf);
        }
        return try ext4.Ext4FindDelallocRangeFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4Forget(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4ForgetFtraceEventReader {
        if (self._ext4_forget_buf) |buf| {
            return try ext4.Ext4ForgetFtraceEventReader.init(buf);
        }
        return try ext4.Ext4ForgetFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4FreeBlocks(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4FreeBlocksFtraceEventReader {
        if (self._ext4_free_blocks_buf) |buf| {
            return try ext4.Ext4FreeBlocksFtraceEventReader.init(buf);
        }
        return try ext4.Ext4FreeBlocksFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4FreeInode(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4FreeInodeFtraceEventReader {
        if (self._ext4_free_inode_buf) |buf| {
            return try ext4.Ext4FreeInodeFtraceEventReader.init(buf);
        }
        return try ext4.Ext4FreeInodeFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4GetImpliedClusterAllocExit(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4GetImpliedClusterAllocExitFtraceEventReader {
        if (self._ext4_get_implied_cluster_alloc_exit_buf) |buf| {
            return try ext4.Ext4GetImpliedClusterAllocExitFtraceEventReader.init(buf);
        }
        return try ext4.Ext4GetImpliedClusterAllocExitFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4GetReservedClusterAlloc(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4GetReservedClusterAllocFtraceEventReader {
        if (self._ext4_get_reserved_cluster_alloc_buf) |buf| {
            return try ext4.Ext4GetReservedClusterAllocFtraceEventReader.init(buf);
        }
        return try ext4.Ext4GetReservedClusterAllocFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4IndMapBlocksEnter(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4IndMapBlocksEnterFtraceEventReader {
        if (self._ext4_ind_map_blocks_enter_buf) |buf| {
            return try ext4.Ext4IndMapBlocksEnterFtraceEventReader.init(buf);
        }
        return try ext4.Ext4IndMapBlocksEnterFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4IndMapBlocksExit(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4IndMapBlocksExitFtraceEventReader {
        if (self._ext4_ind_map_blocks_exit_buf) |buf| {
            return try ext4.Ext4IndMapBlocksExitFtraceEventReader.init(buf);
        }
        return try ext4.Ext4IndMapBlocksExitFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4InsertRange(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4InsertRangeFtraceEventReader {
        if (self._ext4_insert_range_buf) |buf| {
            return try ext4.Ext4InsertRangeFtraceEventReader.init(buf);
        }
        return try ext4.Ext4InsertRangeFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4Invalidatepage(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4InvalidatepageFtraceEventReader {
        if (self._ext4_invalidatepage_buf) |buf| {
            return try ext4.Ext4InvalidatepageFtraceEventReader.init(buf);
        }
        return try ext4.Ext4InvalidatepageFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4JournalStart(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4JournalStartFtraceEventReader {
        if (self._ext4_journal_start_buf) |buf| {
            return try ext4.Ext4JournalStartFtraceEventReader.init(buf);
        }
        return try ext4.Ext4JournalStartFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4JournalStartReserved(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4JournalStartReservedFtraceEventReader {
        if (self._ext4_journal_start_reserved_buf) |buf| {
            return try ext4.Ext4JournalStartReservedFtraceEventReader.init(buf);
        }
        return try ext4.Ext4JournalStartReservedFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4JournalledInvalidatepage(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4JournalledInvalidatepageFtraceEventReader {
        if (self._ext4_journalled_invalidatepage_buf) |buf| {
            return try ext4.Ext4JournalledInvalidatepageFtraceEventReader.init(buf);
        }
        return try ext4.Ext4JournalledInvalidatepageFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4JournalledWriteEnd(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4JournalledWriteEndFtraceEventReader {
        if (self._ext4_journalled_write_end_buf) |buf| {
            return try ext4.Ext4JournalledWriteEndFtraceEventReader.init(buf);
        }
        return try ext4.Ext4JournalledWriteEndFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4LoadInode(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4LoadInodeFtraceEventReader {
        if (self._ext4_load_inode_buf) |buf| {
            return try ext4.Ext4LoadInodeFtraceEventReader.init(buf);
        }
        return try ext4.Ext4LoadInodeFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4LoadInodeBitmap(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4LoadInodeBitmapFtraceEventReader {
        if (self._ext4_load_inode_bitmap_buf) |buf| {
            return try ext4.Ext4LoadInodeBitmapFtraceEventReader.init(buf);
        }
        return try ext4.Ext4LoadInodeBitmapFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4MarkInodeDirty(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4MarkInodeDirtyFtraceEventReader {
        if (self._ext4_mark_inode_dirty_buf) |buf| {
            return try ext4.Ext4MarkInodeDirtyFtraceEventReader.init(buf);
        }
        return try ext4.Ext4MarkInodeDirtyFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4MbBitmapLoad(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4MbBitmapLoadFtraceEventReader {
        if (self._ext4_mb_bitmap_load_buf) |buf| {
            return try ext4.Ext4MbBitmapLoadFtraceEventReader.init(buf);
        }
        return try ext4.Ext4MbBitmapLoadFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4MbBuddyBitmapLoad(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4MbBuddyBitmapLoadFtraceEventReader {
        if (self._ext4_mb_buddy_bitmap_load_buf) |buf| {
            return try ext4.Ext4MbBuddyBitmapLoadFtraceEventReader.init(buf);
        }
        return try ext4.Ext4MbBuddyBitmapLoadFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4MbDiscardPreallocations(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4MbDiscardPreallocationsFtraceEventReader {
        if (self._ext4_mb_discard_preallocations_buf) |buf| {
            return try ext4.Ext4MbDiscardPreallocationsFtraceEventReader.init(buf);
        }
        return try ext4.Ext4MbDiscardPreallocationsFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4MbNewGroupPa(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4MbNewGroupPaFtraceEventReader {
        if (self._ext4_mb_new_group_pa_buf) |buf| {
            return try ext4.Ext4MbNewGroupPaFtraceEventReader.init(buf);
        }
        return try ext4.Ext4MbNewGroupPaFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4MbNewInodePa(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4MbNewInodePaFtraceEventReader {
        if (self._ext4_mb_new_inode_pa_buf) |buf| {
            return try ext4.Ext4MbNewInodePaFtraceEventReader.init(buf);
        }
        return try ext4.Ext4MbNewInodePaFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4MbReleaseGroupPa(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4MbReleaseGroupPaFtraceEventReader {
        if (self._ext4_mb_release_group_pa_buf) |buf| {
            return try ext4.Ext4MbReleaseGroupPaFtraceEventReader.init(buf);
        }
        return try ext4.Ext4MbReleaseGroupPaFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4MbReleaseInodePa(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4MbReleaseInodePaFtraceEventReader {
        if (self._ext4_mb_release_inode_pa_buf) |buf| {
            return try ext4.Ext4MbReleaseInodePaFtraceEventReader.init(buf);
        }
        return try ext4.Ext4MbReleaseInodePaFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4MballocAlloc(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4MballocAllocFtraceEventReader {
        if (self._ext4_mballoc_alloc_buf) |buf| {
            return try ext4.Ext4MballocAllocFtraceEventReader.init(buf);
        }
        return try ext4.Ext4MballocAllocFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4MballocDiscard(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4MballocDiscardFtraceEventReader {
        if (self._ext4_mballoc_discard_buf) |buf| {
            return try ext4.Ext4MballocDiscardFtraceEventReader.init(buf);
        }
        return try ext4.Ext4MballocDiscardFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4MballocFree(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4MballocFreeFtraceEventReader {
        if (self._ext4_mballoc_free_buf) |buf| {
            return try ext4.Ext4MballocFreeFtraceEventReader.init(buf);
        }
        return try ext4.Ext4MballocFreeFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4MballocPrealloc(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4MballocPreallocFtraceEventReader {
        if (self._ext4_mballoc_prealloc_buf) |buf| {
            return try ext4.Ext4MballocPreallocFtraceEventReader.init(buf);
        }
        return try ext4.Ext4MballocPreallocFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4OtherInodeUpdateTime(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4OtherInodeUpdateTimeFtraceEventReader {
        if (self._ext4_other_inode_update_time_buf) |buf| {
            return try ext4.Ext4OtherInodeUpdateTimeFtraceEventReader.init(buf);
        }
        return try ext4.Ext4OtherInodeUpdateTimeFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4PunchHole(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4PunchHoleFtraceEventReader {
        if (self._ext4_punch_hole_buf) |buf| {
            return try ext4.Ext4PunchHoleFtraceEventReader.init(buf);
        }
        return try ext4.Ext4PunchHoleFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4ReadBlockBitmapLoad(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4ReadBlockBitmapLoadFtraceEventReader {
        if (self._ext4_read_block_bitmap_load_buf) |buf| {
            return try ext4.Ext4ReadBlockBitmapLoadFtraceEventReader.init(buf);
        }
        return try ext4.Ext4ReadBlockBitmapLoadFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4Readpage(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4ReadpageFtraceEventReader {
        if (self._ext4_readpage_buf) |buf| {
            return try ext4.Ext4ReadpageFtraceEventReader.init(buf);
        }
        return try ext4.Ext4ReadpageFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4Releasepage(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4ReleasepageFtraceEventReader {
        if (self._ext4_releasepage_buf) |buf| {
            return try ext4.Ext4ReleasepageFtraceEventReader.init(buf);
        }
        return try ext4.Ext4ReleasepageFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4RemoveBlocks(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4RemoveBlocksFtraceEventReader {
        if (self._ext4_remove_blocks_buf) |buf| {
            return try ext4.Ext4RemoveBlocksFtraceEventReader.init(buf);
        }
        return try ext4.Ext4RemoveBlocksFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4RequestBlocks(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4RequestBlocksFtraceEventReader {
        if (self._ext4_request_blocks_buf) |buf| {
            return try ext4.Ext4RequestBlocksFtraceEventReader.init(buf);
        }
        return try ext4.Ext4RequestBlocksFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4RequestInode(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4RequestInodeFtraceEventReader {
        if (self._ext4_request_inode_buf) |buf| {
            return try ext4.Ext4RequestInodeFtraceEventReader.init(buf);
        }
        return try ext4.Ext4RequestInodeFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4SyncFs(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4SyncFsFtraceEventReader {
        if (self._ext4_sync_fs_buf) |buf| {
            return try ext4.Ext4SyncFsFtraceEventReader.init(buf);
        }
        return try ext4.Ext4SyncFsFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4TrimAllFree(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4TrimAllFreeFtraceEventReader {
        if (self._ext4_trim_all_free_buf) |buf| {
            return try ext4.Ext4TrimAllFreeFtraceEventReader.init(buf);
        }
        return try ext4.Ext4TrimAllFreeFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4TrimExtent(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4TrimExtentFtraceEventReader {
        if (self._ext4_trim_extent_buf) |buf| {
            return try ext4.Ext4TrimExtentFtraceEventReader.init(buf);
        }
        return try ext4.Ext4TrimExtentFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4TruncateEnter(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4TruncateEnterFtraceEventReader {
        if (self._ext4_truncate_enter_buf) |buf| {
            return try ext4.Ext4TruncateEnterFtraceEventReader.init(buf);
        }
        return try ext4.Ext4TruncateEnterFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4TruncateExit(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4TruncateExitFtraceEventReader {
        if (self._ext4_truncate_exit_buf) |buf| {
            return try ext4.Ext4TruncateExitFtraceEventReader.init(buf);
        }
        return try ext4.Ext4TruncateExitFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4UnlinkEnter(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4UnlinkEnterFtraceEventReader {
        if (self._ext4_unlink_enter_buf) |buf| {
            return try ext4.Ext4UnlinkEnterFtraceEventReader.init(buf);
        }
        return try ext4.Ext4UnlinkEnterFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4UnlinkExit(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4UnlinkExitFtraceEventReader {
        if (self._ext4_unlink_exit_buf) |buf| {
            return try ext4.Ext4UnlinkExitFtraceEventReader.init(buf);
        }
        return try ext4.Ext4UnlinkExitFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4WriteBegin(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4WriteBeginFtraceEventReader {
        if (self._ext4_write_begin_buf) |buf| {
            return try ext4.Ext4WriteBeginFtraceEventReader.init(buf);
        }
        return try ext4.Ext4WriteBeginFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4WriteEnd(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4WriteEndFtraceEventReader {
        if (self._ext4_write_end_buf) |buf| {
            return try ext4.Ext4WriteEndFtraceEventReader.init(buf);
        }
        return try ext4.Ext4WriteEndFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4Writepage(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4WritepageFtraceEventReader {
        if (self._ext4_writepage_buf) |buf| {
            return try ext4.Ext4WritepageFtraceEventReader.init(buf);
        }
        return try ext4.Ext4WritepageFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4Writepages(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4WritepagesFtraceEventReader {
        if (self._ext4_writepages_buf) |buf| {
            return try ext4.Ext4WritepagesFtraceEventReader.init(buf);
        }
        return try ext4.Ext4WritepagesFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4WritepagesResult(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4WritepagesResultFtraceEventReader {
        if (self._ext4_writepages_result_buf) |buf| {
            return try ext4.Ext4WritepagesResultFtraceEventReader.init(buf);
        }
        return try ext4.Ext4WritepagesResultFtraceEventReader.init(&[_]u8{});
    }
    pub fn getExt4ZeroRange(self: *const FtraceEventReader) gremlin.Error!ext4.Ext4ZeroRangeFtraceEventReader {
        if (self._ext4_zero_range_buf) |buf| {
            return try ext4.Ext4ZeroRangeFtraceEventReader.init(buf);
        }
        return try ext4.Ext4ZeroRangeFtraceEventReader.init(&[_]u8{});
    }
    pub fn getTaskNewtask(self: *const FtraceEventReader) gremlin.Error!task.TaskNewtaskFtraceEventReader {
        if (self._task_newtask_buf) |buf| {
            return try task.TaskNewtaskFtraceEventReader.init(buf);
        }
        return try task.TaskNewtaskFtraceEventReader.init(&[_]u8{});
    }
    pub fn getTaskRename(self: *const FtraceEventReader) gremlin.Error!task.TaskRenameFtraceEventReader {
        if (self._task_rename_buf) |buf| {
            return try task.TaskRenameFtraceEventReader.init(buf);
        }
        return try task.TaskRenameFtraceEventReader.init(&[_]u8{});
    }
    pub fn getSchedProcessExec(self: *const FtraceEventReader) gremlin.Error!sched.SchedProcessExecFtraceEventReader {
        if (self._sched_process_exec_buf) |buf| {
            return try sched.SchedProcessExecFtraceEventReader.init(buf);
        }
        return try sched.SchedProcessExecFtraceEventReader.init(&[_]u8{});
    }
    pub fn getSchedProcessExit(self: *const FtraceEventReader) gremlin.Error!sched.SchedProcessExitFtraceEventReader {
        if (self._sched_process_exit_buf) |buf| {
            return try sched.SchedProcessExitFtraceEventReader.init(buf);
        }
        return try sched.SchedProcessExitFtraceEventReader.init(&[_]u8{});
    }
    pub fn getSchedProcessFork(self: *const FtraceEventReader) gremlin.Error!sched.SchedProcessForkFtraceEventReader {
        if (self._sched_process_fork_buf) |buf| {
            return try sched.SchedProcessForkFtraceEventReader.init(buf);
        }
        return try sched.SchedProcessForkFtraceEventReader.init(&[_]u8{});
    }
    pub fn getSchedProcessFree(self: *const FtraceEventReader) gremlin.Error!sched.SchedProcessFreeFtraceEventReader {
        if (self._sched_process_free_buf) |buf| {
            return try sched.SchedProcessFreeFtraceEventReader.init(buf);
        }
        return try sched.SchedProcessFreeFtraceEventReader.init(&[_]u8{});
    }
    pub fn getSchedProcessHang(self: *const FtraceEventReader) gremlin.Error!sched.SchedProcessHangFtraceEventReader {
        if (self._sched_process_hang_buf) |buf| {
            return try sched.SchedProcessHangFtraceEventReader.init(buf);
        }
        return try sched.SchedProcessHangFtraceEventReader.init(&[_]u8{});
    }
    pub fn getSchedProcessWait(self: *const FtraceEventReader) gremlin.Error!sched.SchedProcessWaitFtraceEventReader {
        if (self._sched_process_wait_buf) |buf| {
            return try sched.SchedProcessWaitFtraceEventReader.init(buf);
        }
        return try sched.SchedProcessWaitFtraceEventReader.init(&[_]u8{});
    }
    pub fn getF2fsDoSubmitBio(self: *const FtraceEventReader) gremlin.Error!f2fs.F2fsDoSubmitBioFtraceEventReader {
        if (self._f2fs_do_submit_bio_buf) |buf| {
            return try f2fs.F2fsDoSubmitBioFtraceEventReader.init(buf);
        }
        return try f2fs.F2fsDoSubmitBioFtraceEventReader.init(&[_]u8{});
    }
    pub fn getF2fsEvictInode(self: *const FtraceEventReader) gremlin.Error!f2fs.F2fsEvictInodeFtraceEventReader {
        if (self._f2fs_evict_inode_buf) |buf| {
            return try f2fs.F2fsEvictInodeFtraceEventReader.init(buf);
        }
        return try f2fs.F2fsEvictInodeFtraceEventReader.init(&[_]u8{});
    }
    pub fn getF2fsFallocate(self: *const FtraceEventReader) gremlin.Error!f2fs.F2fsFallocateFtraceEventReader {
        if (self._f2fs_fallocate_buf) |buf| {
            return try f2fs.F2fsFallocateFtraceEventReader.init(buf);
        }
        return try f2fs.F2fsFallocateFtraceEventReader.init(&[_]u8{});
    }
    pub fn getF2fsGetDataBlock(self: *const FtraceEventReader) gremlin.Error!f2fs.F2fsGetDataBlockFtraceEventReader {
        if (self._f2fs_get_data_block_buf) |buf| {
            return try f2fs.F2fsGetDataBlockFtraceEventReader.init(buf);
        }
        return try f2fs.F2fsGetDataBlockFtraceEventReader.init(&[_]u8{});
    }
    pub fn getF2fsGetVictim(self: *const FtraceEventReader) gremlin.Error!f2fs.F2fsGetVictimFtraceEventReader {
        if (self._f2fs_get_victim_buf) |buf| {
            return try f2fs.F2fsGetVictimFtraceEventReader.init(buf);
        }
        return try f2fs.F2fsGetVictimFtraceEventReader.init(&[_]u8{});
    }
    pub fn getF2fsIget(self: *const FtraceEventReader) gremlin.Error!f2fs.F2fsIgetFtraceEventReader {
        if (self._f2fs_iget_buf) |buf| {
            return try f2fs.F2fsIgetFtraceEventReader.init(buf);
        }
        return try f2fs.F2fsIgetFtraceEventReader.init(&[_]u8{});
    }
    pub fn getF2fsIgetExit(self: *const FtraceEventReader) gremlin.Error!f2fs.F2fsIgetExitFtraceEventReader {
        if (self._f2fs_iget_exit_buf) |buf| {
            return try f2fs.F2fsIgetExitFtraceEventReader.init(buf);
        }
        return try f2fs.F2fsIgetExitFtraceEventReader.init(&[_]u8{});
    }
    pub fn getF2fsNewInode(self: *const FtraceEventReader) gremlin.Error!f2fs.F2fsNewInodeFtraceEventReader {
        if (self._f2fs_new_inode_buf) |buf| {
            return try f2fs.F2fsNewInodeFtraceEventReader.init(buf);
        }
        return try f2fs.F2fsNewInodeFtraceEventReader.init(&[_]u8{});
    }
    pub fn getF2fsReadpage(self: *const FtraceEventReader) gremlin.Error!f2fs.F2fsReadpageFtraceEventReader {
        if (self._f2fs_readpage_buf) |buf| {
            return try f2fs.F2fsReadpageFtraceEventReader.init(buf);
        }
        return try f2fs.F2fsReadpageFtraceEventReader.init(&[_]u8{});
    }
    pub fn getF2fsReserveNewBlock(self: *const FtraceEventReader) gremlin.Error!f2fs.F2fsReserveNewBlockFtraceEventReader {
        if (self._f2fs_reserve_new_block_buf) |buf| {
            return try f2fs.F2fsReserveNewBlockFtraceEventReader.init(buf);
        }
        return try f2fs.F2fsReserveNewBlockFtraceEventReader.init(&[_]u8{});
    }
    pub fn getF2fsSetPageDirty(self: *const FtraceEventReader) gremlin.Error!f2fs.F2fsSetPageDirtyFtraceEventReader {
        if (self._f2fs_set_page_dirty_buf) |buf| {
            return try f2fs.F2fsSetPageDirtyFtraceEventReader.init(buf);
        }
        return try f2fs.F2fsSetPageDirtyFtraceEventReader.init(&[_]u8{});
    }
    pub fn getF2fsSubmitWritePage(self: *const FtraceEventReader) gremlin.Error!f2fs.F2fsSubmitWritePageFtraceEventReader {
        if (self._f2fs_submit_write_page_buf) |buf| {
            return try f2fs.F2fsSubmitWritePageFtraceEventReader.init(buf);
        }
        return try f2fs.F2fsSubmitWritePageFtraceEventReader.init(&[_]u8{});
    }
    pub fn getF2fsSyncFileEnter(self: *const FtraceEventReader) gremlin.Error!f2fs.F2fsSyncFileEnterFtraceEventReader {
        if (self._f2fs_sync_file_enter_buf) |buf| {
            return try f2fs.F2fsSyncFileEnterFtraceEventReader.init(buf);
        }
        return try f2fs.F2fsSyncFileEnterFtraceEventReader.init(&[_]u8{});
    }
    pub fn getF2fsSyncFileExit(self: *const FtraceEventReader) gremlin.Error!f2fs.F2fsSyncFileExitFtraceEventReader {
        if (self._f2fs_sync_file_exit_buf) |buf| {
            return try f2fs.F2fsSyncFileExitFtraceEventReader.init(buf);
        }
        return try f2fs.F2fsSyncFileExitFtraceEventReader.init(&[_]u8{});
    }
    pub fn getF2fsSyncFs(self: *const FtraceEventReader) gremlin.Error!f2fs.F2fsSyncFsFtraceEventReader {
        if (self._f2fs_sync_fs_buf) |buf| {
            return try f2fs.F2fsSyncFsFtraceEventReader.init(buf);
        }
        return try f2fs.F2fsSyncFsFtraceEventReader.init(&[_]u8{});
    }
    pub fn getF2fsTruncate(self: *const FtraceEventReader) gremlin.Error!f2fs.F2fsTruncateFtraceEventReader {
        if (self._f2fs_truncate_buf) |buf| {
            return try f2fs.F2fsTruncateFtraceEventReader.init(buf);
        }
        return try f2fs.F2fsTruncateFtraceEventReader.init(&[_]u8{});
    }
    pub fn getF2fsTruncateBlocksEnter(self: *const FtraceEventReader) gremlin.Error!f2fs.F2fsTruncateBlocksEnterFtraceEventReader {
        if (self._f2fs_truncate_blocks_enter_buf) |buf| {
            return try f2fs.F2fsTruncateBlocksEnterFtraceEventReader.init(buf);
        }
        return try f2fs.F2fsTruncateBlocksEnterFtraceEventReader.init(&[_]u8{});
    }
    pub fn getF2fsTruncateBlocksExit(self: *const FtraceEventReader) gremlin.Error!f2fs.F2fsTruncateBlocksExitFtraceEventReader {
        if (self._f2fs_truncate_blocks_exit_buf) |buf| {
            return try f2fs.F2fsTruncateBlocksExitFtraceEventReader.init(buf);
        }
        return try f2fs.F2fsTruncateBlocksExitFtraceEventReader.init(&[_]u8{});
    }
    pub fn getF2fsTruncateDataBlocksRange(self: *const FtraceEventReader) gremlin.Error!f2fs.F2fsTruncateDataBlocksRangeFtraceEventReader {
        if (self._f2fs_truncate_data_blocks_range_buf) |buf| {
            return try f2fs.F2fsTruncateDataBlocksRangeFtraceEventReader.init(buf);
        }
        return try f2fs.F2fsTruncateDataBlocksRangeFtraceEventReader.init(&[_]u8{});
    }
    pub fn getF2fsTruncateInodeBlocksEnter(self: *const FtraceEventReader) gremlin.Error!f2fs.F2fsTruncateInodeBlocksEnterFtraceEventReader {
        if (self._f2fs_truncate_inode_blocks_enter_buf) |buf| {
            return try f2fs.F2fsTruncateInodeBlocksEnterFtraceEventReader.init(buf);
        }
        return try f2fs.F2fsTruncateInodeBlocksEnterFtraceEventReader.init(&[_]u8{});
    }
    pub fn getF2fsTruncateInodeBlocksExit(self: *const FtraceEventReader) gremlin.Error!f2fs.F2fsTruncateInodeBlocksExitFtraceEventReader {
        if (self._f2fs_truncate_inode_blocks_exit_buf) |buf| {
            return try f2fs.F2fsTruncateInodeBlocksExitFtraceEventReader.init(buf);
        }
        return try f2fs.F2fsTruncateInodeBlocksExitFtraceEventReader.init(&[_]u8{});
    }
    pub fn getF2fsTruncateNode(self: *const FtraceEventReader) gremlin.Error!f2fs.F2fsTruncateNodeFtraceEventReader {
        if (self._f2fs_truncate_node_buf) |buf| {
            return try f2fs.F2fsTruncateNodeFtraceEventReader.init(buf);
        }
        return try f2fs.F2fsTruncateNodeFtraceEventReader.init(&[_]u8{});
    }
    pub fn getF2fsTruncateNodesEnter(self: *const FtraceEventReader) gremlin.Error!f2fs.F2fsTruncateNodesEnterFtraceEventReader {
        if (self._f2fs_truncate_nodes_enter_buf) |buf| {
            return try f2fs.F2fsTruncateNodesEnterFtraceEventReader.init(buf);
        }
        return try f2fs.F2fsTruncateNodesEnterFtraceEventReader.init(&[_]u8{});
    }
    pub fn getF2fsTruncateNodesExit(self: *const FtraceEventReader) gremlin.Error!f2fs.F2fsTruncateNodesExitFtraceEventReader {
        if (self._f2fs_truncate_nodes_exit_buf) |buf| {
            return try f2fs.F2fsTruncateNodesExitFtraceEventReader.init(buf);
        }
        return try f2fs.F2fsTruncateNodesExitFtraceEventReader.init(&[_]u8{});
    }
    pub fn getF2fsTruncatePartialNodes(self: *const FtraceEventReader) gremlin.Error!f2fs.F2fsTruncatePartialNodesFtraceEventReader {
        if (self._f2fs_truncate_partial_nodes_buf) |buf| {
            return try f2fs.F2fsTruncatePartialNodesFtraceEventReader.init(buf);
        }
        return try f2fs.F2fsTruncatePartialNodesFtraceEventReader.init(&[_]u8{});
    }
    pub fn getF2fsUnlinkEnter(self: *const FtraceEventReader) gremlin.Error!f2fs.F2fsUnlinkEnterFtraceEventReader {
        if (self._f2fs_unlink_enter_buf) |buf| {
            return try f2fs.F2fsUnlinkEnterFtraceEventReader.init(buf);
        }
        return try f2fs.F2fsUnlinkEnterFtraceEventReader.init(&[_]u8{});
    }
    pub fn getF2fsUnlinkExit(self: *const FtraceEventReader) gremlin.Error!f2fs.F2fsUnlinkExitFtraceEventReader {
        if (self._f2fs_unlink_exit_buf) |buf| {
            return try f2fs.F2fsUnlinkExitFtraceEventReader.init(buf);
        }
        return try f2fs.F2fsUnlinkExitFtraceEventReader.init(&[_]u8{});
    }
    pub fn getF2fsVmPageMkwrite(self: *const FtraceEventReader) gremlin.Error!f2fs.F2fsVmPageMkwriteFtraceEventReader {
        if (self._f2fs_vm_page_mkwrite_buf) |buf| {
            return try f2fs.F2fsVmPageMkwriteFtraceEventReader.init(buf);
        }
        return try f2fs.F2fsVmPageMkwriteFtraceEventReader.init(&[_]u8{});
    }
    pub fn getF2fsWriteBegin(self: *const FtraceEventReader) gremlin.Error!f2fs.F2fsWriteBeginFtraceEventReader {
        if (self._f2fs_write_begin_buf) |buf| {
            return try f2fs.F2fsWriteBeginFtraceEventReader.init(buf);
        }
        return try f2fs.F2fsWriteBeginFtraceEventReader.init(&[_]u8{});
    }
    pub fn getF2fsWriteCheckpoint(self: *const FtraceEventReader) gremlin.Error!f2fs.F2fsWriteCheckpointFtraceEventReader {
        if (self._f2fs_write_checkpoint_buf) |buf| {
            return try f2fs.F2fsWriteCheckpointFtraceEventReader.init(buf);
        }
        return try f2fs.F2fsWriteCheckpointFtraceEventReader.init(&[_]u8{});
    }
    pub fn getF2fsWriteEnd(self: *const FtraceEventReader) gremlin.Error!f2fs.F2fsWriteEndFtraceEventReader {
        if (self._f2fs_write_end_buf) |buf| {
            return try f2fs.F2fsWriteEndFtraceEventReader.init(buf);
        }
        return try f2fs.F2fsWriteEndFtraceEventReader.init(&[_]u8{});
    }
    pub fn getAllocPagesIommuEnd(self: *const FtraceEventReader) gremlin.Error!kmem.AllocPagesIommuEndFtraceEventReader {
        if (self._alloc_pages_iommu_end_buf) |buf| {
            return try kmem.AllocPagesIommuEndFtraceEventReader.init(buf);
        }
        return try kmem.AllocPagesIommuEndFtraceEventReader.init(&[_]u8{});
    }
    pub fn getAllocPagesIommuFail(self: *const FtraceEventReader) gremlin.Error!kmem.AllocPagesIommuFailFtraceEventReader {
        if (self._alloc_pages_iommu_fail_buf) |buf| {
            return try kmem.AllocPagesIommuFailFtraceEventReader.init(buf);
        }
        return try kmem.AllocPagesIommuFailFtraceEventReader.init(&[_]u8{});
    }
    pub fn getAllocPagesIommuStart(self: *const FtraceEventReader) gremlin.Error!kmem.AllocPagesIommuStartFtraceEventReader {
        if (self._alloc_pages_iommu_start_buf) |buf| {
            return try kmem.AllocPagesIommuStartFtraceEventReader.init(buf);
        }
        return try kmem.AllocPagesIommuStartFtraceEventReader.init(&[_]u8{});
    }
    pub fn getAllocPagesSysEnd(self: *const FtraceEventReader) gremlin.Error!kmem.AllocPagesSysEndFtraceEventReader {
        if (self._alloc_pages_sys_end_buf) |buf| {
            return try kmem.AllocPagesSysEndFtraceEventReader.init(buf);
        }
        return try kmem.AllocPagesSysEndFtraceEventReader.init(&[_]u8{});
    }
    pub fn getAllocPagesSysFail(self: *const FtraceEventReader) gremlin.Error!kmem.AllocPagesSysFailFtraceEventReader {
        if (self._alloc_pages_sys_fail_buf) |buf| {
            return try kmem.AllocPagesSysFailFtraceEventReader.init(buf);
        }
        return try kmem.AllocPagesSysFailFtraceEventReader.init(&[_]u8{});
    }
    pub fn getAllocPagesSysStart(self: *const FtraceEventReader) gremlin.Error!kmem.AllocPagesSysStartFtraceEventReader {
        if (self._alloc_pages_sys_start_buf) |buf| {
            return try kmem.AllocPagesSysStartFtraceEventReader.init(buf);
        }
        return try kmem.AllocPagesSysStartFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDmaAllocContiguousRetry(self: *const FtraceEventReader) gremlin.Error!kmem.DmaAllocContiguousRetryFtraceEventReader {
        if (self._dma_alloc_contiguous_retry_buf) |buf| {
            return try kmem.DmaAllocContiguousRetryFtraceEventReader.init(buf);
        }
        return try kmem.DmaAllocContiguousRetryFtraceEventReader.init(&[_]u8{});
    }
    pub fn getIommuMapRange(self: *const FtraceEventReader) gremlin.Error!kmem.IommuMapRangeFtraceEventReader {
        if (self._iommu_map_range_buf) |buf| {
            return try kmem.IommuMapRangeFtraceEventReader.init(buf);
        }
        return try kmem.IommuMapRangeFtraceEventReader.init(&[_]u8{});
    }
    pub fn getIommuSecPtblMapRangeEnd(self: *const FtraceEventReader) gremlin.Error!kmem.IommuSecPtblMapRangeEndFtraceEventReader {
        if (self._iommu_sec_ptbl_map_range_end_buf) |buf| {
            return try kmem.IommuSecPtblMapRangeEndFtraceEventReader.init(buf);
        }
        return try kmem.IommuSecPtblMapRangeEndFtraceEventReader.init(&[_]u8{});
    }
    pub fn getIommuSecPtblMapRangeStart(self: *const FtraceEventReader) gremlin.Error!kmem.IommuSecPtblMapRangeStartFtraceEventReader {
        if (self._iommu_sec_ptbl_map_range_start_buf) |buf| {
            return try kmem.IommuSecPtblMapRangeStartFtraceEventReader.init(buf);
        }
        return try kmem.IommuSecPtblMapRangeStartFtraceEventReader.init(&[_]u8{});
    }
    pub fn getIonAllocBufferEnd(self: *const FtraceEventReader) gremlin.Error!kmem.IonAllocBufferEndFtraceEventReader {
        if (self._ion_alloc_buffer_end_buf) |buf| {
            return try kmem.IonAllocBufferEndFtraceEventReader.init(buf);
        }
        return try kmem.IonAllocBufferEndFtraceEventReader.init(&[_]u8{});
    }
    pub fn getIonAllocBufferFail(self: *const FtraceEventReader) gremlin.Error!kmem.IonAllocBufferFailFtraceEventReader {
        if (self._ion_alloc_buffer_fail_buf) |buf| {
            return try kmem.IonAllocBufferFailFtraceEventReader.init(buf);
        }
        return try kmem.IonAllocBufferFailFtraceEventReader.init(&[_]u8{});
    }
    pub fn getIonAllocBufferFallback(self: *const FtraceEventReader) gremlin.Error!kmem.IonAllocBufferFallbackFtraceEventReader {
        if (self._ion_alloc_buffer_fallback_buf) |buf| {
            return try kmem.IonAllocBufferFallbackFtraceEventReader.init(buf);
        }
        return try kmem.IonAllocBufferFallbackFtraceEventReader.init(&[_]u8{});
    }
    pub fn getIonAllocBufferStart(self: *const FtraceEventReader) gremlin.Error!kmem.IonAllocBufferStartFtraceEventReader {
        if (self._ion_alloc_buffer_start_buf) |buf| {
            return try kmem.IonAllocBufferStartFtraceEventReader.init(buf);
        }
        return try kmem.IonAllocBufferStartFtraceEventReader.init(&[_]u8{});
    }
    pub fn getIonCpAllocRetry(self: *const FtraceEventReader) gremlin.Error!kmem.IonCpAllocRetryFtraceEventReader {
        if (self._ion_cp_alloc_retry_buf) |buf| {
            return try kmem.IonCpAllocRetryFtraceEventReader.init(buf);
        }
        return try kmem.IonCpAllocRetryFtraceEventReader.init(&[_]u8{});
    }
    pub fn getIonCpSecureBufferEnd(self: *const FtraceEventReader) gremlin.Error!kmem.IonCpSecureBufferEndFtraceEventReader {
        if (self._ion_cp_secure_buffer_end_buf) |buf| {
            return try kmem.IonCpSecureBufferEndFtraceEventReader.init(buf);
        }
        return try kmem.IonCpSecureBufferEndFtraceEventReader.init(&[_]u8{});
    }
    pub fn getIonCpSecureBufferStart(self: *const FtraceEventReader) gremlin.Error!kmem.IonCpSecureBufferStartFtraceEventReader {
        if (self._ion_cp_secure_buffer_start_buf) |buf| {
            return try kmem.IonCpSecureBufferStartFtraceEventReader.init(buf);
        }
        return try kmem.IonCpSecureBufferStartFtraceEventReader.init(&[_]u8{});
    }
    pub fn getIonPrefetching(self: *const FtraceEventReader) gremlin.Error!kmem.IonPrefetchingFtraceEventReader {
        if (self._ion_prefetching_buf) |buf| {
            return try kmem.IonPrefetchingFtraceEventReader.init(buf);
        }
        return try kmem.IonPrefetchingFtraceEventReader.init(&[_]u8{});
    }
    pub fn getIonSecureCmaAddToPoolEnd(self: *const FtraceEventReader) gremlin.Error!kmem.IonSecureCmaAddToPoolEndFtraceEventReader {
        if (self._ion_secure_cma_add_to_pool_end_buf) |buf| {
            return try kmem.IonSecureCmaAddToPoolEndFtraceEventReader.init(buf);
        }
        return try kmem.IonSecureCmaAddToPoolEndFtraceEventReader.init(&[_]u8{});
    }
    pub fn getIonSecureCmaAddToPoolStart(self: *const FtraceEventReader) gremlin.Error!kmem.IonSecureCmaAddToPoolStartFtraceEventReader {
        if (self._ion_secure_cma_add_to_pool_start_buf) |buf| {
            return try kmem.IonSecureCmaAddToPoolStartFtraceEventReader.init(buf);
        }
        return try kmem.IonSecureCmaAddToPoolStartFtraceEventReader.init(&[_]u8{});
    }
    pub fn getIonSecureCmaAllocateEnd(self: *const FtraceEventReader) gremlin.Error!kmem.IonSecureCmaAllocateEndFtraceEventReader {
        if (self._ion_secure_cma_allocate_end_buf) |buf| {
            return try kmem.IonSecureCmaAllocateEndFtraceEventReader.init(buf);
        }
        return try kmem.IonSecureCmaAllocateEndFtraceEventReader.init(&[_]u8{});
    }
    pub fn getIonSecureCmaAllocateStart(self: *const FtraceEventReader) gremlin.Error!kmem.IonSecureCmaAllocateStartFtraceEventReader {
        if (self._ion_secure_cma_allocate_start_buf) |buf| {
            return try kmem.IonSecureCmaAllocateStartFtraceEventReader.init(buf);
        }
        return try kmem.IonSecureCmaAllocateStartFtraceEventReader.init(&[_]u8{});
    }
    pub fn getIonSecureCmaShrinkPoolEnd(self: *const FtraceEventReader) gremlin.Error!kmem.IonSecureCmaShrinkPoolEndFtraceEventReader {
        if (self._ion_secure_cma_shrink_pool_end_buf) |buf| {
            return try kmem.IonSecureCmaShrinkPoolEndFtraceEventReader.init(buf);
        }
        return try kmem.IonSecureCmaShrinkPoolEndFtraceEventReader.init(&[_]u8{});
    }
    pub fn getIonSecureCmaShrinkPoolStart(self: *const FtraceEventReader) gremlin.Error!kmem.IonSecureCmaShrinkPoolStartFtraceEventReader {
        if (self._ion_secure_cma_shrink_pool_start_buf) |buf| {
            return try kmem.IonSecureCmaShrinkPoolStartFtraceEventReader.init(buf);
        }
        return try kmem.IonSecureCmaShrinkPoolStartFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKfree(self: *const FtraceEventReader) gremlin.Error!kmem.KfreeFtraceEventReader {
        if (self._kfree_buf) |buf| {
            return try kmem.KfreeFtraceEventReader.init(buf);
        }
        return try kmem.KfreeFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKmalloc(self: *const FtraceEventReader) gremlin.Error!kmem.KmallocFtraceEventReader {
        if (self._kmalloc_buf) |buf| {
            return try kmem.KmallocFtraceEventReader.init(buf);
        }
        return try kmem.KmallocFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKmallocNode(self: *const FtraceEventReader) gremlin.Error!kmem.KmallocNodeFtraceEventReader {
        if (self._kmalloc_node_buf) |buf| {
            return try kmem.KmallocNodeFtraceEventReader.init(buf);
        }
        return try kmem.KmallocNodeFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKmemCacheAlloc(self: *const FtraceEventReader) gremlin.Error!kmem.KmemCacheAllocFtraceEventReader {
        if (self._kmem_cache_alloc_buf) |buf| {
            return try kmem.KmemCacheAllocFtraceEventReader.init(buf);
        }
        return try kmem.KmemCacheAllocFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKmemCacheAllocNode(self: *const FtraceEventReader) gremlin.Error!kmem.KmemCacheAllocNodeFtraceEventReader {
        if (self._kmem_cache_alloc_node_buf) |buf| {
            return try kmem.KmemCacheAllocNodeFtraceEventReader.init(buf);
        }
        return try kmem.KmemCacheAllocNodeFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKmemCacheFree(self: *const FtraceEventReader) gremlin.Error!kmem.KmemCacheFreeFtraceEventReader {
        if (self._kmem_cache_free_buf) |buf| {
            return try kmem.KmemCacheFreeFtraceEventReader.init(buf);
        }
        return try kmem.KmemCacheFreeFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMigratePagesEnd(self: *const FtraceEventReader) gremlin.Error!kmem.MigratePagesEndFtraceEventReader {
        if (self._migrate_pages_end_buf) |buf| {
            return try kmem.MigratePagesEndFtraceEventReader.init(buf);
        }
        return try kmem.MigratePagesEndFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMigratePagesStart(self: *const FtraceEventReader) gremlin.Error!kmem.MigratePagesStartFtraceEventReader {
        if (self._migrate_pages_start_buf) |buf| {
            return try kmem.MigratePagesStartFtraceEventReader.init(buf);
        }
        return try kmem.MigratePagesStartFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMigrateRetry(self: *const FtraceEventReader) gremlin.Error!kmem.MigrateRetryFtraceEventReader {
        if (self._migrate_retry_buf) |buf| {
            return try kmem.MigrateRetryFtraceEventReader.init(buf);
        }
        return try kmem.MigrateRetryFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMmPageAlloc(self: *const FtraceEventReader) gremlin.Error!kmem.MmPageAllocFtraceEventReader {
        if (self._mm_page_alloc_buf) |buf| {
            return try kmem.MmPageAllocFtraceEventReader.init(buf);
        }
        return try kmem.MmPageAllocFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMmPageAllocExtfrag(self: *const FtraceEventReader) gremlin.Error!kmem.MmPageAllocExtfragFtraceEventReader {
        if (self._mm_page_alloc_extfrag_buf) |buf| {
            return try kmem.MmPageAllocExtfragFtraceEventReader.init(buf);
        }
        return try kmem.MmPageAllocExtfragFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMmPageAllocZoneLocked(self: *const FtraceEventReader) gremlin.Error!kmem.MmPageAllocZoneLockedFtraceEventReader {
        if (self._mm_page_alloc_zone_locked_buf) |buf| {
            return try kmem.MmPageAllocZoneLockedFtraceEventReader.init(buf);
        }
        return try kmem.MmPageAllocZoneLockedFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMmPageFree(self: *const FtraceEventReader) gremlin.Error!kmem.MmPageFreeFtraceEventReader {
        if (self._mm_page_free_buf) |buf| {
            return try kmem.MmPageFreeFtraceEventReader.init(buf);
        }
        return try kmem.MmPageFreeFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMmPageFreeBatched(self: *const FtraceEventReader) gremlin.Error!kmem.MmPageFreeBatchedFtraceEventReader {
        if (self._mm_page_free_batched_buf) |buf| {
            return try kmem.MmPageFreeBatchedFtraceEventReader.init(buf);
        }
        return try kmem.MmPageFreeBatchedFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMmPagePcpuDrain(self: *const FtraceEventReader) gremlin.Error!kmem.MmPagePcpuDrainFtraceEventReader {
        if (self._mm_page_pcpu_drain_buf) |buf| {
            return try kmem.MmPagePcpuDrainFtraceEventReader.init(buf);
        }
        return try kmem.MmPagePcpuDrainFtraceEventReader.init(&[_]u8{});
    }
    pub fn getRssStat(self: *const FtraceEventReader) gremlin.Error!kmem.RssStatFtraceEventReader {
        if (self._rss_stat_buf) |buf| {
            return try kmem.RssStatFtraceEventReader.init(buf);
        }
        return try kmem.RssStatFtraceEventReader.init(&[_]u8{});
    }
    pub fn getIonHeapShrink(self: *const FtraceEventReader) gremlin.Error!kmem.IonHeapShrinkFtraceEventReader {
        if (self._ion_heap_shrink_buf) |buf| {
            return try kmem.IonHeapShrinkFtraceEventReader.init(buf);
        }
        return try kmem.IonHeapShrinkFtraceEventReader.init(&[_]u8{});
    }
    pub fn getIonHeapGrow(self: *const FtraceEventReader) gremlin.Error!kmem.IonHeapGrowFtraceEventReader {
        if (self._ion_heap_grow_buf) |buf| {
            return try kmem.IonHeapGrowFtraceEventReader.init(buf);
        }
        return try kmem.IonHeapGrowFtraceEventReader.init(&[_]u8{});
    }
    pub fn getFenceInit(self: *const FtraceEventReader) gremlin.Error!fence.FenceInitFtraceEventReader {
        if (self._fence_init_buf) |buf| {
            return try fence.FenceInitFtraceEventReader.init(buf);
        }
        return try fence.FenceInitFtraceEventReader.init(&[_]u8{});
    }
    pub fn getFenceDestroy(self: *const FtraceEventReader) gremlin.Error!fence.FenceDestroyFtraceEventReader {
        if (self._fence_destroy_buf) |buf| {
            return try fence.FenceDestroyFtraceEventReader.init(buf);
        }
        return try fence.FenceDestroyFtraceEventReader.init(&[_]u8{});
    }
    pub fn getFenceEnableSignal(self: *const FtraceEventReader) gremlin.Error!fence.FenceEnableSignalFtraceEventReader {
        if (self._fence_enable_signal_buf) |buf| {
            return try fence.FenceEnableSignalFtraceEventReader.init(buf);
        }
        return try fence.FenceEnableSignalFtraceEventReader.init(&[_]u8{});
    }
    pub fn getFenceSignaled(self: *const FtraceEventReader) gremlin.Error!fence.FenceSignaledFtraceEventReader {
        if (self._fence_signaled_buf) |buf| {
            return try fence.FenceSignaledFtraceEventReader.init(buf);
        }
        return try fence.FenceSignaledFtraceEventReader.init(&[_]u8{});
    }
    pub fn getClkEnable(self: *const FtraceEventReader) gremlin.Error!clk.ClkEnableFtraceEventReader {
        if (self._clk_enable_buf) |buf| {
            return try clk.ClkEnableFtraceEventReader.init(buf);
        }
        return try clk.ClkEnableFtraceEventReader.init(&[_]u8{});
    }
    pub fn getClkDisable(self: *const FtraceEventReader) gremlin.Error!clk.ClkDisableFtraceEventReader {
        if (self._clk_disable_buf) |buf| {
            return try clk.ClkDisableFtraceEventReader.init(buf);
        }
        return try clk.ClkDisableFtraceEventReader.init(&[_]u8{});
    }
    pub fn getClkSetRate(self: *const FtraceEventReader) gremlin.Error!clk.ClkSetRateFtraceEventReader {
        if (self._clk_set_rate_buf) |buf| {
            return try clk.ClkSetRateFtraceEventReader.init(buf);
        }
        return try clk.ClkSetRateFtraceEventReader.init(&[_]u8{});
    }
    pub fn getBinderTransactionAllocBuf(self: *const FtraceEventReader) gremlin.Error!binder.BinderTransactionAllocBufFtraceEventReader {
        if (self._binder_transaction_alloc_buf_buf) |buf| {
            return try binder.BinderTransactionAllocBufFtraceEventReader.init(buf);
        }
        return try binder.BinderTransactionAllocBufFtraceEventReader.init(&[_]u8{});
    }
    pub fn getSignalDeliver(self: *const FtraceEventReader) gremlin.Error!signal.SignalDeliverFtraceEventReader {
        if (self._signal_deliver_buf) |buf| {
            return try signal.SignalDeliverFtraceEventReader.init(buf);
        }
        return try signal.SignalDeliverFtraceEventReader.init(&[_]u8{});
    }
    pub fn getSignalGenerate(self: *const FtraceEventReader) gremlin.Error!signal.SignalGenerateFtraceEventReader {
        if (self._signal_generate_buf) |buf| {
            return try signal.SignalGenerateFtraceEventReader.init(buf);
        }
        return try signal.SignalGenerateFtraceEventReader.init(&[_]u8{});
    }
    pub fn getOomScoreAdjUpdate(self: *const FtraceEventReader) gremlin.Error!oom.OomScoreAdjUpdateFtraceEventReader {
        if (self._oom_score_adj_update_buf) |buf| {
            return try oom.OomScoreAdjUpdateFtraceEventReader.init(buf);
        }
        return try oom.OomScoreAdjUpdateFtraceEventReader.init(&[_]u8{});
    }
    pub fn getGeneric(self: *const FtraceEventReader) gremlin.Error!generic.GenericFtraceEventReader {
        if (self._generic_buf) |buf| {
            return try generic.GenericFtraceEventReader.init(buf);
        }
        return try generic.GenericFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMmEventRecord(self: *const FtraceEventReader) gremlin.Error!mm_event.MmEventRecordFtraceEventReader {
        if (self._mm_event_record_buf) |buf| {
            return try mm_event.MmEventRecordFtraceEventReader.init(buf);
        }
        return try mm_event.MmEventRecordFtraceEventReader.init(&[_]u8{});
    }
    pub fn getSysEnter(self: *const FtraceEventReader) gremlin.Error!raw_syscalls.SysEnterFtraceEventReader {
        if (self._sys_enter_buf) |buf| {
            return try raw_syscalls.SysEnterFtraceEventReader.init(buf);
        }
        return try raw_syscalls.SysEnterFtraceEventReader.init(&[_]u8{});
    }
    pub fn getSysExit(self: *const FtraceEventReader) gremlin.Error!raw_syscalls.SysExitFtraceEventReader {
        if (self._sys_exit_buf) |buf| {
            return try raw_syscalls.SysExitFtraceEventReader.init(buf);
        }
        return try raw_syscalls.SysExitFtraceEventReader.init(&[_]u8{});
    }
    pub fn getZero(self: *const FtraceEventReader) gremlin.Error!systrace.ZeroFtraceEventReader {
        if (self._zero_buf) |buf| {
            return try systrace.ZeroFtraceEventReader.init(buf);
        }
        return try systrace.ZeroFtraceEventReader.init(&[_]u8{});
    }
    pub fn getGpuFrequency(self: *const FtraceEventReader) gremlin.Error!power.GpuFrequencyFtraceEventReader {
        if (self._gpu_frequency_buf) |buf| {
            return try power.GpuFrequencyFtraceEventReader.init(buf);
        }
        return try power.GpuFrequencyFtraceEventReader.init(&[_]u8{});
    }
    pub fn getSdeTracingMarkWrite(self: *const FtraceEventReader) gremlin.Error!sde.SdeTracingMarkWriteFtraceEventReader {
        if (self._sde_tracing_mark_write_buf) |buf| {
            return try sde.SdeTracingMarkWriteFtraceEventReader.init(buf);
        }
        return try sde.SdeTracingMarkWriteFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMarkVictim(self: *const FtraceEventReader) gremlin.Error!oom.MarkVictimFtraceEventReader {
        if (self._mark_victim_buf) |buf| {
            return try oom.MarkVictimFtraceEventReader.init(buf);
        }
        return try oom.MarkVictimFtraceEventReader.init(&[_]u8{});
    }
    pub fn getIonStat(self: *const FtraceEventReader) gremlin.Error!ion.IonStatFtraceEventReader {
        if (self._ion_stat_buf) |buf| {
            return try ion.IonStatFtraceEventReader.init(buf);
        }
        return try ion.IonStatFtraceEventReader.init(&[_]u8{});
    }
    pub fn getIonBufferCreate(self: *const FtraceEventReader) gremlin.Error!kmem.IonBufferCreateFtraceEventReader {
        if (self._ion_buffer_create_buf) |buf| {
            return try kmem.IonBufferCreateFtraceEventReader.init(buf);
        }
        return try kmem.IonBufferCreateFtraceEventReader.init(&[_]u8{});
    }
    pub fn getIonBufferDestroy(self: *const FtraceEventReader) gremlin.Error!kmem.IonBufferDestroyFtraceEventReader {
        if (self._ion_buffer_destroy_buf) |buf| {
            return try kmem.IonBufferDestroyFtraceEventReader.init(buf);
        }
        return try kmem.IonBufferDestroyFtraceEventReader.init(&[_]u8{});
    }
    pub fn getScmCallStart(self: *const FtraceEventReader) gremlin.Error!scm.ScmCallStartFtraceEventReader {
        if (self._scm_call_start_buf) |buf| {
            return try scm.ScmCallStartFtraceEventReader.init(buf);
        }
        return try scm.ScmCallStartFtraceEventReader.init(&[_]u8{});
    }
    pub fn getScmCallEnd(self: *const FtraceEventReader) gremlin.Error!scm.ScmCallEndFtraceEventReader {
        if (self._scm_call_end_buf) |buf| {
            return try scm.ScmCallEndFtraceEventReader.init(buf);
        }
        return try scm.ScmCallEndFtraceEventReader.init(&[_]u8{});
    }
    pub fn getGpuMemTotal(self: *const FtraceEventReader) gremlin.Error!gpu_mem.GpuMemTotalFtraceEventReader {
        if (self._gpu_mem_total_buf) |buf| {
            return try gpu_mem.GpuMemTotalFtraceEventReader.init(buf);
        }
        return try gpu_mem.GpuMemTotalFtraceEventReader.init(&[_]u8{});
    }
    pub fn getThermalTemperature(self: *const FtraceEventReader) gremlin.Error!thermal.ThermalTemperatureFtraceEventReader {
        if (self._thermal_temperature_buf) |buf| {
            return try thermal.ThermalTemperatureFtraceEventReader.init(buf);
        }
        return try thermal.ThermalTemperatureFtraceEventReader.init(&[_]u8{});
    }
    pub fn getCdevUpdate(self: *const FtraceEventReader) gremlin.Error!thermal.CdevUpdateFtraceEventReader {
        if (self._cdev_update_buf) |buf| {
            return try thermal.CdevUpdateFtraceEventReader.init(buf);
        }
        return try thermal.CdevUpdateFtraceEventReader.init(&[_]u8{});
    }
    pub fn getCpuhpExit(self: *const FtraceEventReader) gremlin.Error!cpuhp.CpuhpExitFtraceEventReader {
        if (self._cpuhp_exit_buf) |buf| {
            return try cpuhp.CpuhpExitFtraceEventReader.init(buf);
        }
        return try cpuhp.CpuhpExitFtraceEventReader.init(&[_]u8{});
    }
    pub fn getCpuhpMultiEnter(self: *const FtraceEventReader) gremlin.Error!cpuhp.CpuhpMultiEnterFtraceEventReader {
        if (self._cpuhp_multi_enter_buf) |buf| {
            return try cpuhp.CpuhpMultiEnterFtraceEventReader.init(buf);
        }
        return try cpuhp.CpuhpMultiEnterFtraceEventReader.init(&[_]u8{});
    }
    pub fn getCpuhpEnter(self: *const FtraceEventReader) gremlin.Error!cpuhp.CpuhpEnterFtraceEventReader {
        if (self._cpuhp_enter_buf) |buf| {
            return try cpuhp.CpuhpEnterFtraceEventReader.init(buf);
        }
        return try cpuhp.CpuhpEnterFtraceEventReader.init(&[_]u8{});
    }
    pub fn getCpuhpLatency(self: *const FtraceEventReader) gremlin.Error!cpuhp.CpuhpLatencyFtraceEventReader {
        if (self._cpuhp_latency_buf) |buf| {
            return try cpuhp.CpuhpLatencyFtraceEventReader.init(buf);
        }
        return try cpuhp.CpuhpLatencyFtraceEventReader.init(&[_]u8{});
    }
    pub fn getFastrpcDmaStat(self: *const FtraceEventReader) gremlin.Error!fastrpc.FastrpcDmaStatFtraceEventReader {
        if (self._fastrpc_dma_stat_buf) |buf| {
            return try fastrpc.FastrpcDmaStatFtraceEventReader.init(buf);
        }
        return try fastrpc.FastrpcDmaStatFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDpuTracingMarkWrite(self: *const FtraceEventReader) gremlin.Error!dpu.DpuTracingMarkWriteFtraceEventReader {
        if (self._dpu_tracing_mark_write_buf) |buf| {
            return try dpu.DpuTracingMarkWriteFtraceEventReader.init(buf);
        }
        return try dpu.DpuTracingMarkWriteFtraceEventReader.init(&[_]u8{});
    }
    pub fn getG2dTracingMarkWrite(self: *const FtraceEventReader) gremlin.Error!g2d.G2dTracingMarkWriteFtraceEventReader {
        if (self._g2d_tracing_mark_write_buf) |buf| {
            return try g2d.G2dTracingMarkWriteFtraceEventReader.init(buf);
        }
        return try g2d.G2dTracingMarkWriteFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMaliTracingMarkWrite(self: *const FtraceEventReader) gremlin.Error!mali.MaliTracingMarkWriteFtraceEventReader {
        if (self._mali_tracing_mark_write_buf) |buf| {
            return try mali.MaliTracingMarkWriteFtraceEventReader.init(buf);
        }
        return try mali.MaliTracingMarkWriteFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDmaHeapStat(self: *const FtraceEventReader) gremlin.Error!dmabuf_heap.DmaHeapStatFtraceEventReader {
        if (self._dma_heap_stat_buf) |buf| {
            return try dmabuf_heap.DmaHeapStatFtraceEventReader.init(buf);
        }
        return try dmabuf_heap.DmaHeapStatFtraceEventReader.init(&[_]u8{});
    }
    pub fn getCpuhpPause(self: *const FtraceEventReader) gremlin.Error!cpuhp.CpuhpPauseFtraceEventReader {
        if (self._cpuhp_pause_buf) |buf| {
            return try cpuhp.CpuhpPauseFtraceEventReader.init(buf);
        }
        return try cpuhp.CpuhpPauseFtraceEventReader.init(&[_]u8{});
    }
    pub fn getSchedPiSetprio(self: *const FtraceEventReader) gremlin.Error!sched.SchedPiSetprioFtraceEventReader {
        if (self._sched_pi_setprio_buf) |buf| {
            return try sched.SchedPiSetprioFtraceEventReader.init(buf);
        }
        return try sched.SchedPiSetprioFtraceEventReader.init(&[_]u8{});
    }
    pub fn getSdeSdeEvtlog(self: *const FtraceEventReader) gremlin.Error!sde.SdeSdeEvtlogFtraceEventReader {
        if (self._sde_sde_evtlog_buf) |buf| {
            return try sde.SdeSdeEvtlogFtraceEventReader.init(buf);
        }
        return try sde.SdeSdeEvtlogFtraceEventReader.init(&[_]u8{});
    }
    pub fn getSdeSdePerfCalcCrtc(self: *const FtraceEventReader) gremlin.Error!sde.SdeSdePerfCalcCrtcFtraceEventReader {
        if (self._sde_sde_perf_calc_crtc_buf) |buf| {
            return try sde.SdeSdePerfCalcCrtcFtraceEventReader.init(buf);
        }
        return try sde.SdeSdePerfCalcCrtcFtraceEventReader.init(&[_]u8{});
    }
    pub fn getSdeSdePerfCrtcUpdate(self: *const FtraceEventReader) gremlin.Error!sde.SdeSdePerfCrtcUpdateFtraceEventReader {
        if (self._sde_sde_perf_crtc_update_buf) |buf| {
            return try sde.SdeSdePerfCrtcUpdateFtraceEventReader.init(buf);
        }
        return try sde.SdeSdePerfCrtcUpdateFtraceEventReader.init(&[_]u8{});
    }
    pub fn getSdeSdePerfSetQosLuts(self: *const FtraceEventReader) gremlin.Error!sde.SdeSdePerfSetQosLutsFtraceEventReader {
        if (self._sde_sde_perf_set_qos_luts_buf) |buf| {
            return try sde.SdeSdePerfSetQosLutsFtraceEventReader.init(buf);
        }
        return try sde.SdeSdePerfSetQosLutsFtraceEventReader.init(&[_]u8{});
    }
    pub fn getSdeSdePerfUpdateBus(self: *const FtraceEventReader) gremlin.Error!sde.SdeSdePerfUpdateBusFtraceEventReader {
        if (self._sde_sde_perf_update_bus_buf) |buf| {
            return try sde.SdeSdePerfUpdateBusFtraceEventReader.init(buf);
        }
        return try sde.SdeSdePerfUpdateBusFtraceEventReader.init(&[_]u8{});
    }
    pub fn getRssStatThrottled(self: *const FtraceEventReader) gremlin.Error!synthetic.RssStatThrottledFtraceEventReader {
        if (self._rss_stat_throttled_buf) |buf| {
            return try synthetic.RssStatThrottledFtraceEventReader.init(buf);
        }
        return try synthetic.RssStatThrottledFtraceEventReader.init(&[_]u8{});
    }
    pub fn getNetifReceiveSkb(self: *const FtraceEventReader) gremlin.Error!net.NetifReceiveSkbFtraceEventReader {
        if (self._netif_receive_skb_buf) |buf| {
            return try net.NetifReceiveSkbFtraceEventReader.init(buf);
        }
        return try net.NetifReceiveSkbFtraceEventReader.init(&[_]u8{});
    }
    pub fn getNetDevXmit(self: *const FtraceEventReader) gremlin.Error!net.NetDevXmitFtraceEventReader {
        if (self._net_dev_xmit_buf) |buf| {
            return try net.NetDevXmitFtraceEventReader.init(buf);
        }
        return try net.NetDevXmitFtraceEventReader.init(&[_]u8{});
    }
    pub fn getInetSockSetState(self: *const FtraceEventReader) gremlin.Error!sock.InetSockSetStateFtraceEventReader {
        if (self._inet_sock_set_state_buf) |buf| {
            return try sock.InetSockSetStateFtraceEventReader.init(buf);
        }
        return try sock.InetSockSetStateFtraceEventReader.init(&[_]u8{});
    }
    pub fn getTcpRetransmitSkb(self: *const FtraceEventReader) gremlin.Error!tcp.TcpRetransmitSkbFtraceEventReader {
        if (self._tcp_retransmit_skb_buf) |buf| {
            return try tcp.TcpRetransmitSkbFtraceEventReader.init(buf);
        }
        return try tcp.TcpRetransmitSkbFtraceEventReader.init(&[_]u8{});
    }
    pub fn getCrosEcSensorhubData(self: *const FtraceEventReader) gremlin.Error!cros_ec.CrosEcSensorhubDataFtraceEventReader {
        if (self._cros_ec_sensorhub_data_buf) |buf| {
            return try cros_ec.CrosEcSensorhubDataFtraceEventReader.init(buf);
        }
        return try cros_ec.CrosEcSensorhubDataFtraceEventReader.init(&[_]u8{});
    }
    pub fn getNapiGroReceiveEntry(self: *const FtraceEventReader) gremlin.Error!net.NapiGroReceiveEntryFtraceEventReader {
        if (self._napi_gro_receive_entry_buf) |buf| {
            return try net.NapiGroReceiveEntryFtraceEventReader.init(buf);
        }
        return try net.NapiGroReceiveEntryFtraceEventReader.init(&[_]u8{});
    }
    pub fn getNapiGroReceiveExit(self: *const FtraceEventReader) gremlin.Error!net.NapiGroReceiveExitFtraceEventReader {
        if (self._napi_gro_receive_exit_buf) |buf| {
            return try net.NapiGroReceiveExitFtraceEventReader.init(buf);
        }
        return try net.NapiGroReceiveExitFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKfreeSkb(self: *const FtraceEventReader) gremlin.Error!skb.KfreeSkbFtraceEventReader {
        if (self._kfree_skb_buf) |buf| {
            return try skb.KfreeSkbFtraceEventReader.init(buf);
        }
        return try skb.KfreeSkbFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKvmAccessFault(self: *const FtraceEventReader) gremlin.Error!kvm.KvmAccessFaultFtraceEventReader {
        if (self._kvm_access_fault_buf) |buf| {
            return try kvm.KvmAccessFaultFtraceEventReader.init(buf);
        }
        return try kvm.KvmAccessFaultFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKvmAckIrq(self: *const FtraceEventReader) gremlin.Error!kvm.KvmAckIrqFtraceEventReader {
        if (self._kvm_ack_irq_buf) |buf| {
            return try kvm.KvmAckIrqFtraceEventReader.init(buf);
        }
        return try kvm.KvmAckIrqFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKvmAgeHva(self: *const FtraceEventReader) gremlin.Error!kvm.KvmAgeHvaFtraceEventReader {
        if (self._kvm_age_hva_buf) |buf| {
            return try kvm.KvmAgeHvaFtraceEventReader.init(buf);
        }
        return try kvm.KvmAgeHvaFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKvmAgePage(self: *const FtraceEventReader) gremlin.Error!kvm.KvmAgePageFtraceEventReader {
        if (self._kvm_age_page_buf) |buf| {
            return try kvm.KvmAgePageFtraceEventReader.init(buf);
        }
        return try kvm.KvmAgePageFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKvmArmClearDebug(self: *const FtraceEventReader) gremlin.Error!kvm.KvmArmClearDebugFtraceEventReader {
        if (self._kvm_arm_clear_debug_buf) |buf| {
            return try kvm.KvmArmClearDebugFtraceEventReader.init(buf);
        }
        return try kvm.KvmArmClearDebugFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKvmArmSetDreg32(self: *const FtraceEventReader) gremlin.Error!kvm.KvmArmSetDreg32FtraceEventReader {
        if (self._kvm_arm_set_dreg32_buf) |buf| {
            return try kvm.KvmArmSetDreg32FtraceEventReader.init(buf);
        }
        return try kvm.KvmArmSetDreg32FtraceEventReader.init(&[_]u8{});
    }
    pub fn getKvmArmSetRegset(self: *const FtraceEventReader) gremlin.Error!kvm.KvmArmSetRegsetFtraceEventReader {
        if (self._kvm_arm_set_regset_buf) |buf| {
            return try kvm.KvmArmSetRegsetFtraceEventReader.init(buf);
        }
        return try kvm.KvmArmSetRegsetFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKvmArmSetupDebug(self: *const FtraceEventReader) gremlin.Error!kvm.KvmArmSetupDebugFtraceEventReader {
        if (self._kvm_arm_setup_debug_buf) |buf| {
            return try kvm.KvmArmSetupDebugFtraceEventReader.init(buf);
        }
        return try kvm.KvmArmSetupDebugFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKvmEntry(self: *const FtraceEventReader) gremlin.Error!kvm.KvmEntryFtraceEventReader {
        if (self._kvm_entry_buf) |buf| {
            return try kvm.KvmEntryFtraceEventReader.init(buf);
        }
        return try kvm.KvmEntryFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKvmExit(self: *const FtraceEventReader) gremlin.Error!kvm.KvmExitFtraceEventReader {
        if (self._kvm_exit_buf) |buf| {
            return try kvm.KvmExitFtraceEventReader.init(buf);
        }
        return try kvm.KvmExitFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKvmFpu(self: *const FtraceEventReader) gremlin.Error!kvm.KvmFpuFtraceEventReader {
        if (self._kvm_fpu_buf) |buf| {
            return try kvm.KvmFpuFtraceEventReader.init(buf);
        }
        return try kvm.KvmFpuFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKvmGetTimerMap(self: *const FtraceEventReader) gremlin.Error!kvm.KvmGetTimerMapFtraceEventReader {
        if (self._kvm_get_timer_map_buf) |buf| {
            return try kvm.KvmGetTimerMapFtraceEventReader.init(buf);
        }
        return try kvm.KvmGetTimerMapFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKvmGuestFault(self: *const FtraceEventReader) gremlin.Error!kvm.KvmGuestFaultFtraceEventReader {
        if (self._kvm_guest_fault_buf) |buf| {
            return try kvm.KvmGuestFaultFtraceEventReader.init(buf);
        }
        return try kvm.KvmGuestFaultFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKvmHandleSysReg(self: *const FtraceEventReader) gremlin.Error!kvm.KvmHandleSysRegFtraceEventReader {
        if (self._kvm_handle_sys_reg_buf) |buf| {
            return try kvm.KvmHandleSysRegFtraceEventReader.init(buf);
        }
        return try kvm.KvmHandleSysRegFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKvmHvcArm64(self: *const FtraceEventReader) gremlin.Error!kvm.KvmHvcArm64FtraceEventReader {
        if (self._kvm_hvc_arm64_buf) |buf| {
            return try kvm.KvmHvcArm64FtraceEventReader.init(buf);
        }
        return try kvm.KvmHvcArm64FtraceEventReader.init(&[_]u8{});
    }
    pub fn getKvmIrqLine(self: *const FtraceEventReader) gremlin.Error!kvm.KvmIrqLineFtraceEventReader {
        if (self._kvm_irq_line_buf) |buf| {
            return try kvm.KvmIrqLineFtraceEventReader.init(buf);
        }
        return try kvm.KvmIrqLineFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKvmMmio(self: *const FtraceEventReader) gremlin.Error!kvm.KvmMmioFtraceEventReader {
        if (self._kvm_mmio_buf) |buf| {
            return try kvm.KvmMmioFtraceEventReader.init(buf);
        }
        return try kvm.KvmMmioFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKvmMmioEmulate(self: *const FtraceEventReader) gremlin.Error!kvm.KvmMmioEmulateFtraceEventReader {
        if (self._kvm_mmio_emulate_buf) |buf| {
            return try kvm.KvmMmioEmulateFtraceEventReader.init(buf);
        }
        return try kvm.KvmMmioEmulateFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKvmSetGuestDebug(self: *const FtraceEventReader) gremlin.Error!kvm.KvmSetGuestDebugFtraceEventReader {
        if (self._kvm_set_guest_debug_buf) |buf| {
            return try kvm.KvmSetGuestDebugFtraceEventReader.init(buf);
        }
        return try kvm.KvmSetGuestDebugFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKvmSetIrq(self: *const FtraceEventReader) gremlin.Error!kvm.KvmSetIrqFtraceEventReader {
        if (self._kvm_set_irq_buf) |buf| {
            return try kvm.KvmSetIrqFtraceEventReader.init(buf);
        }
        return try kvm.KvmSetIrqFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKvmSetSpteHva(self: *const FtraceEventReader) gremlin.Error!kvm.KvmSetSpteHvaFtraceEventReader {
        if (self._kvm_set_spte_hva_buf) |buf| {
            return try kvm.KvmSetSpteHvaFtraceEventReader.init(buf);
        }
        return try kvm.KvmSetSpteHvaFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKvmSetWayFlush(self: *const FtraceEventReader) gremlin.Error!kvm.KvmSetWayFlushFtraceEventReader {
        if (self._kvm_set_way_flush_buf) |buf| {
            return try kvm.KvmSetWayFlushFtraceEventReader.init(buf);
        }
        return try kvm.KvmSetWayFlushFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKvmSysAccess(self: *const FtraceEventReader) gremlin.Error!kvm.KvmSysAccessFtraceEventReader {
        if (self._kvm_sys_access_buf) |buf| {
            return try kvm.KvmSysAccessFtraceEventReader.init(buf);
        }
        return try kvm.KvmSysAccessFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKvmTestAgeHva(self: *const FtraceEventReader) gremlin.Error!kvm.KvmTestAgeHvaFtraceEventReader {
        if (self._kvm_test_age_hva_buf) |buf| {
            return try kvm.KvmTestAgeHvaFtraceEventReader.init(buf);
        }
        return try kvm.KvmTestAgeHvaFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKvmTimerEmulate(self: *const FtraceEventReader) gremlin.Error!kvm.KvmTimerEmulateFtraceEventReader {
        if (self._kvm_timer_emulate_buf) |buf| {
            return try kvm.KvmTimerEmulateFtraceEventReader.init(buf);
        }
        return try kvm.KvmTimerEmulateFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKvmTimerHrtimerExpire(self: *const FtraceEventReader) gremlin.Error!kvm.KvmTimerHrtimerExpireFtraceEventReader {
        if (self._kvm_timer_hrtimer_expire_buf) |buf| {
            return try kvm.KvmTimerHrtimerExpireFtraceEventReader.init(buf);
        }
        return try kvm.KvmTimerHrtimerExpireFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKvmTimerRestoreState(self: *const FtraceEventReader) gremlin.Error!kvm.KvmTimerRestoreStateFtraceEventReader {
        if (self._kvm_timer_restore_state_buf) |buf| {
            return try kvm.KvmTimerRestoreStateFtraceEventReader.init(buf);
        }
        return try kvm.KvmTimerRestoreStateFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKvmTimerSaveState(self: *const FtraceEventReader) gremlin.Error!kvm.KvmTimerSaveStateFtraceEventReader {
        if (self._kvm_timer_save_state_buf) |buf| {
            return try kvm.KvmTimerSaveStateFtraceEventReader.init(buf);
        }
        return try kvm.KvmTimerSaveStateFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKvmTimerUpdateIrq(self: *const FtraceEventReader) gremlin.Error!kvm.KvmTimerUpdateIrqFtraceEventReader {
        if (self._kvm_timer_update_irq_buf) |buf| {
            return try kvm.KvmTimerUpdateIrqFtraceEventReader.init(buf);
        }
        return try kvm.KvmTimerUpdateIrqFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKvmToggleCache(self: *const FtraceEventReader) gremlin.Error!kvm.KvmToggleCacheFtraceEventReader {
        if (self._kvm_toggle_cache_buf) |buf| {
            return try kvm.KvmToggleCacheFtraceEventReader.init(buf);
        }
        return try kvm.KvmToggleCacheFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKvmUnmapHvaRange(self: *const FtraceEventReader) gremlin.Error!kvm.KvmUnmapHvaRangeFtraceEventReader {
        if (self._kvm_unmap_hva_range_buf) |buf| {
            return try kvm.KvmUnmapHvaRangeFtraceEventReader.init(buf);
        }
        return try kvm.KvmUnmapHvaRangeFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKvmUserspaceExit(self: *const FtraceEventReader) gremlin.Error!kvm.KvmUserspaceExitFtraceEventReader {
        if (self._kvm_userspace_exit_buf) |buf| {
            return try kvm.KvmUserspaceExitFtraceEventReader.init(buf);
        }
        return try kvm.KvmUserspaceExitFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKvmVcpuWakeup(self: *const FtraceEventReader) gremlin.Error!kvm.KvmVcpuWakeupFtraceEventReader {
        if (self._kvm_vcpu_wakeup_buf) |buf| {
            return try kvm.KvmVcpuWakeupFtraceEventReader.init(buf);
        }
        return try kvm.KvmVcpuWakeupFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKvmWfxArm64(self: *const FtraceEventReader) gremlin.Error!kvm.KvmWfxArm64FtraceEventReader {
        if (self._kvm_wfx_arm64_buf) |buf| {
            return try kvm.KvmWfxArm64FtraceEventReader.init(buf);
        }
        return try kvm.KvmWfxArm64FtraceEventReader.init(&[_]u8{});
    }
    pub fn getTrapReg(self: *const FtraceEventReader) gremlin.Error!kvm.TrapRegFtraceEventReader {
        if (self._trap_reg_buf) |buf| {
            return try kvm.TrapRegFtraceEventReader.init(buf);
        }
        return try kvm.TrapRegFtraceEventReader.init(&[_]u8{});
    }
    pub fn getVgicUpdateIrqPending(self: *const FtraceEventReader) gremlin.Error!kvm.VgicUpdateIrqPendingFtraceEventReader {
        if (self._vgic_update_irq_pending_buf) |buf| {
            return try kvm.VgicUpdateIrqPendingFtraceEventReader.init(buf);
        }
        return try kvm.VgicUpdateIrqPendingFtraceEventReader.init(&[_]u8{});
    }
    pub fn getWakeupSourceActivate(self: *const FtraceEventReader) gremlin.Error!power.WakeupSourceActivateFtraceEventReader {
        if (self._wakeup_source_activate_buf) |buf| {
            return try power.WakeupSourceActivateFtraceEventReader.init(buf);
        }
        return try power.WakeupSourceActivateFtraceEventReader.init(&[_]u8{});
    }
    pub fn getWakeupSourceDeactivate(self: *const FtraceEventReader) gremlin.Error!power.WakeupSourceDeactivateFtraceEventReader {
        if (self._wakeup_source_deactivate_buf) |buf| {
            return try power.WakeupSourceDeactivateFtraceEventReader.init(buf);
        }
        return try power.WakeupSourceDeactivateFtraceEventReader.init(&[_]u8{});
    }
    pub fn getUfshcdCommand(self: *const FtraceEventReader) gremlin.Error!ufs.UfshcdCommandFtraceEventReader {
        if (self._ufshcd_command_buf) |buf| {
            return try ufs.UfshcdCommandFtraceEventReader.init(buf);
        }
        return try ufs.UfshcdCommandFtraceEventReader.init(&[_]u8{});
    }
    pub fn getUfshcdClkGating(self: *const FtraceEventReader) gremlin.Error!ufs.UfshcdClkGatingFtraceEventReader {
        if (self._ufshcd_clk_gating_buf) |buf| {
            return try ufs.UfshcdClkGatingFtraceEventReader.init(buf);
        }
        return try ufs.UfshcdClkGatingFtraceEventReader.init(&[_]u8{});
    }
    pub fn getConsole(self: *const FtraceEventReader) gremlin.Error!printk.ConsoleFtraceEventReader {
        if (self._console_buf) |buf| {
            return try printk.ConsoleFtraceEventReader.init(buf);
        }
        return try printk.ConsoleFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDrmVblankEvent(self: *const FtraceEventReader) gremlin.Error!drm.DrmVblankEventFtraceEventReader {
        if (self._drm_vblank_event_buf) |buf| {
            return try drm.DrmVblankEventFtraceEventReader.init(buf);
        }
        return try drm.DrmVblankEventFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDrmVblankEventDelivered(self: *const FtraceEventReader) gremlin.Error!drm.DrmVblankEventDeliveredFtraceEventReader {
        if (self._drm_vblank_event_delivered_buf) |buf| {
            return try drm.DrmVblankEventDeliveredFtraceEventReader.init(buf);
        }
        return try drm.DrmVblankEventDeliveredFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDrmSchedJob(self: *const FtraceEventReader) gremlin.Error!gpu_scheduler.DrmSchedJobFtraceEventReader {
        if (self._drm_sched_job_buf) |buf| {
            return try gpu_scheduler.DrmSchedJobFtraceEventReader.init(buf);
        }
        return try gpu_scheduler.DrmSchedJobFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDrmRunJob(self: *const FtraceEventReader) gremlin.Error!gpu_scheduler.DrmRunJobFtraceEventReader {
        if (self._drm_run_job_buf) |buf| {
            return try gpu_scheduler.DrmRunJobFtraceEventReader.init(buf);
        }
        return try gpu_scheduler.DrmRunJobFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDrmSchedProcessJob(self: *const FtraceEventReader) gremlin.Error!gpu_scheduler.DrmSchedProcessJobFtraceEventReader {
        if (self._drm_sched_process_job_buf) |buf| {
            return try gpu_scheduler.DrmSchedProcessJobFtraceEventReader.init(buf);
        }
        return try gpu_scheduler.DrmSchedProcessJobFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDmaFenceInit(self: *const FtraceEventReader) gremlin.Error!dma_fence.DmaFenceInitFtraceEventReader {
        if (self._dma_fence_init_buf) |buf| {
            return try dma_fence.DmaFenceInitFtraceEventReader.init(buf);
        }
        return try dma_fence.DmaFenceInitFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDmaFenceEmit(self: *const FtraceEventReader) gremlin.Error!dma_fence.DmaFenceEmitFtraceEventReader {
        if (self._dma_fence_emit_buf) |buf| {
            return try dma_fence.DmaFenceEmitFtraceEventReader.init(buf);
        }
        return try dma_fence.DmaFenceEmitFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDmaFenceSignaled(self: *const FtraceEventReader) gremlin.Error!dma_fence.DmaFenceSignaledFtraceEventReader {
        if (self._dma_fence_signaled_buf) |buf| {
            return try dma_fence.DmaFenceSignaledFtraceEventReader.init(buf);
        }
        return try dma_fence.DmaFenceSignaledFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDmaFenceWaitStart(self: *const FtraceEventReader) gremlin.Error!dma_fence.DmaFenceWaitStartFtraceEventReader {
        if (self._dma_fence_wait_start_buf) |buf| {
            return try dma_fence.DmaFenceWaitStartFtraceEventReader.init(buf);
        }
        return try dma_fence.DmaFenceWaitStartFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDmaFenceWaitEnd(self: *const FtraceEventReader) gremlin.Error!dma_fence.DmaFenceWaitEndFtraceEventReader {
        if (self._dma_fence_wait_end_buf) |buf| {
            return try dma_fence.DmaFenceWaitEndFtraceEventReader.init(buf);
        }
        return try dma_fence.DmaFenceWaitEndFtraceEventReader.init(&[_]u8{});
    }
    pub fn getF2fsIostat(self: *const FtraceEventReader) gremlin.Error!f2fs.F2fsIostatFtraceEventReader {
        if (self._f2fs_iostat_buf) |buf| {
            return try f2fs.F2fsIostatFtraceEventReader.init(buf);
        }
        return try f2fs.F2fsIostatFtraceEventReader.init(&[_]u8{});
    }
    pub fn getF2fsIostatLatency(self: *const FtraceEventReader) gremlin.Error!f2fs.F2fsIostatLatencyFtraceEventReader {
        if (self._f2fs_iostat_latency_buf) |buf| {
            return try f2fs.F2fsIostatLatencyFtraceEventReader.init(buf);
        }
        return try f2fs.F2fsIostatLatencyFtraceEventReader.init(&[_]u8{});
    }
    pub fn getSchedCpuUtilCfs(self: *const FtraceEventReader) gremlin.Error!sched.SchedCpuUtilCfsFtraceEventReader {
        if (self._sched_cpu_util_cfs_buf) |buf| {
            return try sched.SchedCpuUtilCfsFtraceEventReader.init(buf);
        }
        return try sched.SchedCpuUtilCfsFtraceEventReader.init(&[_]u8{});
    }
    pub fn getV4l2Qbuf(self: *const FtraceEventReader) gremlin.Error!v4l2.V4l2QbufFtraceEventReader {
        if (self._v4l2_qbuf_buf) |buf| {
            return try v4l2.V4l2QbufFtraceEventReader.init(buf);
        }
        return try v4l2.V4l2QbufFtraceEventReader.init(&[_]u8{});
    }
    pub fn getV4l2Dqbuf(self: *const FtraceEventReader) gremlin.Error!v4l2.V4l2DqbufFtraceEventReader {
        if (self._v4l2_dqbuf_buf) |buf| {
            return try v4l2.V4l2DqbufFtraceEventReader.init(buf);
        }
        return try v4l2.V4l2DqbufFtraceEventReader.init(&[_]u8{});
    }
    pub fn getVb2V4l2BufQueue(self: *const FtraceEventReader) gremlin.Error!v4l2.Vb2V4l2BufQueueFtraceEventReader {
        if (self._vb2_v4l2_buf_queue_buf) |buf| {
            return try v4l2.Vb2V4l2BufQueueFtraceEventReader.init(buf);
        }
        return try v4l2.Vb2V4l2BufQueueFtraceEventReader.init(&[_]u8{});
    }
    pub fn getVb2V4l2BufDone(self: *const FtraceEventReader) gremlin.Error!v4l2.Vb2V4l2BufDoneFtraceEventReader {
        if (self._vb2_v4l2_buf_done_buf) |buf| {
            return try v4l2.Vb2V4l2BufDoneFtraceEventReader.init(buf);
        }
        return try v4l2.Vb2V4l2BufDoneFtraceEventReader.init(&[_]u8{});
    }
    pub fn getVb2V4l2Qbuf(self: *const FtraceEventReader) gremlin.Error!v4l2.Vb2V4l2QbufFtraceEventReader {
        if (self._vb2_v4l2_qbuf_buf) |buf| {
            return try v4l2.Vb2V4l2QbufFtraceEventReader.init(buf);
        }
        return try v4l2.Vb2V4l2QbufFtraceEventReader.init(&[_]u8{});
    }
    pub fn getVb2V4l2Dqbuf(self: *const FtraceEventReader) gremlin.Error!v4l2.Vb2V4l2DqbufFtraceEventReader {
        if (self._vb2_v4l2_dqbuf_buf) |buf| {
            return try v4l2.Vb2V4l2DqbufFtraceEventReader.init(buf);
        }
        return try v4l2.Vb2V4l2DqbufFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDsiCmdFifoStatus(self: *const FtraceEventReader) gremlin.Error!panel.DsiCmdFifoStatusFtraceEventReader {
        if (self._dsi_cmd_fifo_status_buf) |buf| {
            return try panel.DsiCmdFifoStatusFtraceEventReader.init(buf);
        }
        return try panel.DsiCmdFifoStatusFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDsiRx(self: *const FtraceEventReader) gremlin.Error!panel.DsiRxFtraceEventReader {
        if (self._dsi_rx_buf) |buf| {
            return try panel.DsiRxFtraceEventReader.init(buf);
        }
        return try panel.DsiRxFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDsiTx(self: *const FtraceEventReader) gremlin.Error!panel.DsiTxFtraceEventReader {
        if (self._dsi_tx_buf) |buf| {
            return try panel.DsiTxFtraceEventReader.init(buf);
        }
        return try panel.DsiTxFtraceEventReader.init(&[_]u8{});
    }
    pub fn getAndroidFsDatareadEnd(self: *const FtraceEventReader) gremlin.Error!android_fs.AndroidFsDatareadEndFtraceEventReader {
        if (self._android_fs_dataread_end_buf) |buf| {
            return try android_fs.AndroidFsDatareadEndFtraceEventReader.init(buf);
        }
        return try android_fs.AndroidFsDatareadEndFtraceEventReader.init(&[_]u8{});
    }
    pub fn getAndroidFsDatareadStart(self: *const FtraceEventReader) gremlin.Error!android_fs.AndroidFsDatareadStartFtraceEventReader {
        if (self._android_fs_dataread_start_buf) |buf| {
            return try android_fs.AndroidFsDatareadStartFtraceEventReader.init(buf);
        }
        return try android_fs.AndroidFsDatareadStartFtraceEventReader.init(&[_]u8{});
    }
    pub fn getAndroidFsDatawriteEnd(self: *const FtraceEventReader) gremlin.Error!android_fs.AndroidFsDatawriteEndFtraceEventReader {
        if (self._android_fs_datawrite_end_buf) |buf| {
            return try android_fs.AndroidFsDatawriteEndFtraceEventReader.init(buf);
        }
        return try android_fs.AndroidFsDatawriteEndFtraceEventReader.init(&[_]u8{});
    }
    pub fn getAndroidFsDatawriteStart(self: *const FtraceEventReader) gremlin.Error!android_fs.AndroidFsDatawriteStartFtraceEventReader {
        if (self._android_fs_datawrite_start_buf) |buf| {
            return try android_fs.AndroidFsDatawriteStartFtraceEventReader.init(buf);
        }
        return try android_fs.AndroidFsDatawriteStartFtraceEventReader.init(&[_]u8{});
    }
    pub fn getAndroidFsFsyncEnd(self: *const FtraceEventReader) gremlin.Error!android_fs.AndroidFsFsyncEndFtraceEventReader {
        if (self._android_fs_fsync_end_buf) |buf| {
            return try android_fs.AndroidFsFsyncEndFtraceEventReader.init(buf);
        }
        return try android_fs.AndroidFsFsyncEndFtraceEventReader.init(&[_]u8{});
    }
    pub fn getAndroidFsFsyncStart(self: *const FtraceEventReader) gremlin.Error!android_fs.AndroidFsFsyncStartFtraceEventReader {
        if (self._android_fs_fsync_start_buf) |buf| {
            return try android_fs.AndroidFsFsyncStartFtraceEventReader.init(buf);
        }
        return try android_fs.AndroidFsFsyncStartFtraceEventReader.init(&[_]u8{});
    }
    pub fn getFuncgraphEntry(self: *const FtraceEventReader) gremlin.Error!ftrace.FuncgraphEntryFtraceEventReader {
        if (self._funcgraph_entry_buf) |buf| {
            return try ftrace.FuncgraphEntryFtraceEventReader.init(buf);
        }
        return try ftrace.FuncgraphEntryFtraceEventReader.init(&[_]u8{});
    }
    pub fn getFuncgraphExit(self: *const FtraceEventReader) gremlin.Error!ftrace.FuncgraphExitFtraceEventReader {
        if (self._funcgraph_exit_buf) |buf| {
            return try ftrace.FuncgraphExitFtraceEventReader.init(buf);
        }
        return try ftrace.FuncgraphExitFtraceEventReader.init(&[_]u8{});
    }
    pub fn getVirtioVideoCmd(self: *const FtraceEventReader) gremlin.Error!virtio_video.VirtioVideoCmdFtraceEventReader {
        if (self._virtio_video_cmd_buf) |buf| {
            return try virtio_video.VirtioVideoCmdFtraceEventReader.init(buf);
        }
        return try virtio_video.VirtioVideoCmdFtraceEventReader.init(&[_]u8{});
    }
    pub fn getVirtioVideoCmdDone(self: *const FtraceEventReader) gremlin.Error!virtio_video.VirtioVideoCmdDoneFtraceEventReader {
        if (self._virtio_video_cmd_done_buf) |buf| {
            return try virtio_video.VirtioVideoCmdDoneFtraceEventReader.init(buf);
        }
        return try virtio_video.VirtioVideoCmdDoneFtraceEventReader.init(&[_]u8{});
    }
    pub fn getVirtioVideoResourceQueue(self: *const FtraceEventReader) gremlin.Error!virtio_video.VirtioVideoResourceQueueFtraceEventReader {
        if (self._virtio_video_resource_queue_buf) |buf| {
            return try virtio_video.VirtioVideoResourceQueueFtraceEventReader.init(buf);
        }
        return try virtio_video.VirtioVideoResourceQueueFtraceEventReader.init(&[_]u8{});
    }
    pub fn getVirtioVideoResourceQueueDone(self: *const FtraceEventReader) gremlin.Error!virtio_video.VirtioVideoResourceQueueDoneFtraceEventReader {
        if (self._virtio_video_resource_queue_done_buf) |buf| {
            return try virtio_video.VirtioVideoResourceQueueDoneFtraceEventReader.init(buf);
        }
        return try virtio_video.VirtioVideoResourceQueueDoneFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMmShrinkSlabStart(self: *const FtraceEventReader) gremlin.Error!vmscan.MmShrinkSlabStartFtraceEventReader {
        if (self._mm_shrink_slab_start_buf) |buf| {
            return try vmscan.MmShrinkSlabStartFtraceEventReader.init(buf);
        }
        return try vmscan.MmShrinkSlabStartFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMmShrinkSlabEnd(self: *const FtraceEventReader) gremlin.Error!vmscan.MmShrinkSlabEndFtraceEventReader {
        if (self._mm_shrink_slab_end_buf) |buf| {
            return try vmscan.MmShrinkSlabEndFtraceEventReader.init(buf);
        }
        return try vmscan.MmShrinkSlabEndFtraceEventReader.init(&[_]u8{});
    }
    pub fn getTrustySmc(self: *const FtraceEventReader) gremlin.Error!trusty.TrustySmcFtraceEventReader {
        if (self._trusty_smc_buf) |buf| {
            return try trusty.TrustySmcFtraceEventReader.init(buf);
        }
        return try trusty.TrustySmcFtraceEventReader.init(&[_]u8{});
    }
    pub fn getTrustySmcDone(self: *const FtraceEventReader) gremlin.Error!trusty.TrustySmcDoneFtraceEventReader {
        if (self._trusty_smc_done_buf) |buf| {
            return try trusty.TrustySmcDoneFtraceEventReader.init(buf);
        }
        return try trusty.TrustySmcDoneFtraceEventReader.init(&[_]u8{});
    }
    pub fn getTrustyStdCall32(self: *const FtraceEventReader) gremlin.Error!trusty.TrustyStdCall32FtraceEventReader {
        if (self._trusty_std_call32_buf) |buf| {
            return try trusty.TrustyStdCall32FtraceEventReader.init(buf);
        }
        return try trusty.TrustyStdCall32FtraceEventReader.init(&[_]u8{});
    }
    pub fn getTrustyStdCall32Done(self: *const FtraceEventReader) gremlin.Error!trusty.TrustyStdCall32DoneFtraceEventReader {
        if (self._trusty_std_call32_done_buf) |buf| {
            return try trusty.TrustyStdCall32DoneFtraceEventReader.init(buf);
        }
        return try trusty.TrustyStdCall32DoneFtraceEventReader.init(&[_]u8{});
    }
    pub fn getTrustyShareMemory(self: *const FtraceEventReader) gremlin.Error!trusty.TrustyShareMemoryFtraceEventReader {
        if (self._trusty_share_memory_buf) |buf| {
            return try trusty.TrustyShareMemoryFtraceEventReader.init(buf);
        }
        return try trusty.TrustyShareMemoryFtraceEventReader.init(&[_]u8{});
    }
    pub fn getTrustyShareMemoryDone(self: *const FtraceEventReader) gremlin.Error!trusty.TrustyShareMemoryDoneFtraceEventReader {
        if (self._trusty_share_memory_done_buf) |buf| {
            return try trusty.TrustyShareMemoryDoneFtraceEventReader.init(buf);
        }
        return try trusty.TrustyShareMemoryDoneFtraceEventReader.init(&[_]u8{});
    }
    pub fn getTrustyReclaimMemory(self: *const FtraceEventReader) gremlin.Error!trusty.TrustyReclaimMemoryFtraceEventReader {
        if (self._trusty_reclaim_memory_buf) |buf| {
            return try trusty.TrustyReclaimMemoryFtraceEventReader.init(buf);
        }
        return try trusty.TrustyReclaimMemoryFtraceEventReader.init(&[_]u8{});
    }
    pub fn getTrustyReclaimMemoryDone(self: *const FtraceEventReader) gremlin.Error!trusty.TrustyReclaimMemoryDoneFtraceEventReader {
        if (self._trusty_reclaim_memory_done_buf) |buf| {
            return try trusty.TrustyReclaimMemoryDoneFtraceEventReader.init(buf);
        }
        return try trusty.TrustyReclaimMemoryDoneFtraceEventReader.init(&[_]u8{});
    }
    pub fn getTrustyIrq(self: *const FtraceEventReader) gremlin.Error!trusty.TrustyIrqFtraceEventReader {
        if (self._trusty_irq_buf) |buf| {
            return try trusty.TrustyIrqFtraceEventReader.init(buf);
        }
        return try trusty.TrustyIrqFtraceEventReader.init(&[_]u8{});
    }
    pub fn getTrustyIpcHandleEvent(self: *const FtraceEventReader) gremlin.Error!trusty.TrustyIpcHandleEventFtraceEventReader {
        if (self._trusty_ipc_handle_event_buf) |buf| {
            return try trusty.TrustyIpcHandleEventFtraceEventReader.init(buf);
        }
        return try trusty.TrustyIpcHandleEventFtraceEventReader.init(&[_]u8{});
    }
    pub fn getTrustyIpcConnect(self: *const FtraceEventReader) gremlin.Error!trusty.TrustyIpcConnectFtraceEventReader {
        if (self._trusty_ipc_connect_buf) |buf| {
            return try trusty.TrustyIpcConnectFtraceEventReader.init(buf);
        }
        return try trusty.TrustyIpcConnectFtraceEventReader.init(&[_]u8{});
    }
    pub fn getTrustyIpcConnectEnd(self: *const FtraceEventReader) gremlin.Error!trusty.TrustyIpcConnectEndFtraceEventReader {
        if (self._trusty_ipc_connect_end_buf) |buf| {
            return try trusty.TrustyIpcConnectEndFtraceEventReader.init(buf);
        }
        return try trusty.TrustyIpcConnectEndFtraceEventReader.init(&[_]u8{});
    }
    pub fn getTrustyIpcWrite(self: *const FtraceEventReader) gremlin.Error!trusty.TrustyIpcWriteFtraceEventReader {
        if (self._trusty_ipc_write_buf) |buf| {
            return try trusty.TrustyIpcWriteFtraceEventReader.init(buf);
        }
        return try trusty.TrustyIpcWriteFtraceEventReader.init(&[_]u8{});
    }
    pub fn getTrustyIpcPoll(self: *const FtraceEventReader) gremlin.Error!trusty.TrustyIpcPollFtraceEventReader {
        if (self._trusty_ipc_poll_buf) |buf| {
            return try trusty.TrustyIpcPollFtraceEventReader.init(buf);
        }
        return try trusty.TrustyIpcPollFtraceEventReader.init(&[_]u8{});
    }
    pub fn getTrustyIpcRead(self: *const FtraceEventReader) gremlin.Error!trusty.TrustyIpcReadFtraceEventReader {
        if (self._trusty_ipc_read_buf) |buf| {
            return try trusty.TrustyIpcReadFtraceEventReader.init(buf);
        }
        return try trusty.TrustyIpcReadFtraceEventReader.init(&[_]u8{});
    }
    pub fn getTrustyIpcReadEnd(self: *const FtraceEventReader) gremlin.Error!trusty.TrustyIpcReadEndFtraceEventReader {
        if (self._trusty_ipc_read_end_buf) |buf| {
            return try trusty.TrustyIpcReadEndFtraceEventReader.init(buf);
        }
        return try trusty.TrustyIpcReadEndFtraceEventReader.init(&[_]u8{});
    }
    pub fn getTrustyIpcRx(self: *const FtraceEventReader) gremlin.Error!trusty.TrustyIpcRxFtraceEventReader {
        if (self._trusty_ipc_rx_buf) |buf| {
            return try trusty.TrustyIpcRxFtraceEventReader.init(buf);
        }
        return try trusty.TrustyIpcRxFtraceEventReader.init(&[_]u8{});
    }
    pub fn getTrustyEnqueueNop(self: *const FtraceEventReader) gremlin.Error!trusty.TrustyEnqueueNopFtraceEventReader {
        if (self._trusty_enqueue_nop_buf) |buf| {
            return try trusty.TrustyEnqueueNopFtraceEventReader.init(buf);
        }
        return try trusty.TrustyEnqueueNopFtraceEventReader.init(&[_]u8{});
    }
    pub fn getCmaAllocStart(self: *const FtraceEventReader) gremlin.Error!cma.CmaAllocStartFtraceEventReader {
        if (self._cma_alloc_start_buf) |buf| {
            return try cma.CmaAllocStartFtraceEventReader.init(buf);
        }
        return try cma.CmaAllocStartFtraceEventReader.init(&[_]u8{});
    }
    pub fn getCmaAllocInfo(self: *const FtraceEventReader) gremlin.Error!cma.CmaAllocInfoFtraceEventReader {
        if (self._cma_alloc_info_buf) |buf| {
            return try cma.CmaAllocInfoFtraceEventReader.init(buf);
        }
        return try cma.CmaAllocInfoFtraceEventReader.init(&[_]u8{});
    }
    pub fn getLwisTracingMarkWrite(self: *const FtraceEventReader) gremlin.Error!lwis.LwisTracingMarkWriteFtraceEventReader {
        if (self._lwis_tracing_mark_write_buf) |buf| {
            return try lwis.LwisTracingMarkWriteFtraceEventReader.init(buf);
        }
        return try lwis.LwisTracingMarkWriteFtraceEventReader.init(&[_]u8{});
    }
    pub fn getVirtioGpuCmdQueue(self: *const FtraceEventReader) gremlin.Error!virtio_gpu.VirtioGpuCmdQueueFtraceEventReader {
        if (self._virtio_gpu_cmd_queue_buf) |buf| {
            return try virtio_gpu.VirtioGpuCmdQueueFtraceEventReader.init(buf);
        }
        return try virtio_gpu.VirtioGpuCmdQueueFtraceEventReader.init(&[_]u8{});
    }
    pub fn getVirtioGpuCmdResponse(self: *const FtraceEventReader) gremlin.Error!virtio_gpu.VirtioGpuCmdResponseFtraceEventReader {
        if (self._virtio_gpu_cmd_response_buf) |buf| {
            return try virtio_gpu.VirtioGpuCmdResponseFtraceEventReader.init(buf);
        }
        return try virtio_gpu.VirtioGpuCmdResponseFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMaliMaliKCPUCQSSET(self: *const FtraceEventReader) gremlin.Error!mali.MaliMaliKCPUCQSSETFtraceEventReader {
        if (self._mali_mali_k_c_p_u_c_q_s_s_e_t_buf) |buf| {
            return try mali.MaliMaliKCPUCQSSETFtraceEventReader.init(buf);
        }
        return try mali.MaliMaliKCPUCQSSETFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMaliMaliKCPUCQSWAITSTART(self: *const FtraceEventReader) gremlin.Error!mali.MaliMaliKCPUCQSWAITSTARTFtraceEventReader {
        if (self._mali_mali_k_c_p_u_c_q_s_w_a_i_t_s_t_a_r_t_buf) |buf| {
            return try mali.MaliMaliKCPUCQSWAITSTARTFtraceEventReader.init(buf);
        }
        return try mali.MaliMaliKCPUCQSWAITSTARTFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMaliMaliKCPUCQSWAITEND(self: *const FtraceEventReader) gremlin.Error!mali.MaliMaliKCPUCQSWAITENDFtraceEventReader {
        if (self._mali_mali_k_c_p_u_c_q_s_w_a_i_t_e_n_d_buf) |buf| {
            return try mali.MaliMaliKCPUCQSWAITENDFtraceEventReader.init(buf);
        }
        return try mali.MaliMaliKCPUCQSWAITENDFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMaliMaliKCPUFENCESIGNAL(self: *const FtraceEventReader) gremlin.Error!mali.MaliMaliKCPUFENCESIGNALFtraceEventReader {
        if (self._mali_mali_k_c_p_u_f_e_n_c_e_s_i_g_n_a_l_buf) |buf| {
            return try mali.MaliMaliKCPUFENCESIGNALFtraceEventReader.init(buf);
        }
        return try mali.MaliMaliKCPUFENCESIGNALFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMaliMaliKCPUFENCEWAITSTART(self: *const FtraceEventReader) gremlin.Error!mali.MaliMaliKCPUFENCEWAITSTARTFtraceEventReader {
        if (self._mali_mali_k_c_p_u_f_e_n_c_e_w_a_i_t_s_t_a_r_t_buf) |buf| {
            return try mali.MaliMaliKCPUFENCEWAITSTARTFtraceEventReader.init(buf);
        }
        return try mali.MaliMaliKCPUFENCEWAITSTARTFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMaliMaliKCPUFENCEWAITEND(self: *const FtraceEventReader) gremlin.Error!mali.MaliMaliKCPUFENCEWAITENDFtraceEventReader {
        if (self._mali_mali_k_c_p_u_f_e_n_c_e_w_a_i_t_e_n_d_buf) |buf| {
            return try mali.MaliMaliKCPUFENCEWAITENDFtraceEventReader.init(buf);
        }
        return try mali.MaliMaliKCPUFENCEWAITENDFtraceEventReader.init(&[_]u8{});
    }
    pub fn getHypEnter(self: *const FtraceEventReader) gremlin.Error!hyp.HypEnterFtraceEventReader {
        if (self._hyp_enter_buf) |buf| {
            return try hyp.HypEnterFtraceEventReader.init(buf);
        }
        return try hyp.HypEnterFtraceEventReader.init(&[_]u8{});
    }
    pub fn getHypExit(self: *const FtraceEventReader) gremlin.Error!hyp.HypExitFtraceEventReader {
        if (self._hyp_exit_buf) |buf| {
            return try hyp.HypExitFtraceEventReader.init(buf);
        }
        return try hyp.HypExitFtraceEventReader.init(&[_]u8{});
    }
    pub fn getHostHcall(self: *const FtraceEventReader) gremlin.Error!hyp.HostHcallFtraceEventReader {
        if (self._host_hcall_buf) |buf| {
            return try hyp.HostHcallFtraceEventReader.init(buf);
        }
        return try hyp.HostHcallFtraceEventReader.init(&[_]u8{});
    }
    pub fn getHostSmc(self: *const FtraceEventReader) gremlin.Error!hyp.HostSmcFtraceEventReader {
        if (self._host_smc_buf) |buf| {
            return try hyp.HostSmcFtraceEventReader.init(buf);
        }
        return try hyp.HostSmcFtraceEventReader.init(&[_]u8{});
    }
    pub fn getHostMemAbort(self: *const FtraceEventReader) gremlin.Error!hyp.HostMemAbortFtraceEventReader {
        if (self._host_mem_abort_buf) |buf| {
            return try hyp.HostMemAbortFtraceEventReader.init(buf);
        }
        return try hyp.HostMemAbortFtraceEventReader.init(&[_]u8{});
    }
    pub fn getSuspendResumeMinimal(self: *const FtraceEventReader) gremlin.Error!synthetic.SuspendResumeMinimalFtraceEventReader {
        if (self._suspend_resume_minimal_buf) |buf| {
            return try synthetic.SuspendResumeMinimalFtraceEventReader.init(buf);
        }
        return try synthetic.SuspendResumeMinimalFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMaliMaliCSFINTERRUPTSTART(self: *const FtraceEventReader) gremlin.Error!mali.MaliMaliCSFINTERRUPTSTARTFtraceEventReader {
        if (self._mali_mali_c_s_f_i_n_t_e_r_r_u_p_t_s_t_a_r_t_buf) |buf| {
            return try mali.MaliMaliCSFINTERRUPTSTARTFtraceEventReader.init(buf);
        }
        return try mali.MaliMaliCSFINTERRUPTSTARTFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMaliMaliCSFINTERRUPTEND(self: *const FtraceEventReader) gremlin.Error!mali.MaliMaliCSFINTERRUPTENDFtraceEventReader {
        if (self._mali_mali_c_s_f_i_n_t_e_r_r_u_p_t_e_n_d_buf) |buf| {
            return try mali.MaliMaliCSFINTERRUPTENDFtraceEventReader.init(buf);
        }
        return try mali.MaliMaliCSFINTERRUPTENDFtraceEventReader.init(&[_]u8{});
    }
    pub fn getSamsungTracingMarkWrite(self: *const FtraceEventReader) gremlin.Error!samsung.SamsungTracingMarkWriteFtraceEventReader {
        if (self._samsung_tracing_mark_write_buf) |buf| {
            return try samsung.SamsungTracingMarkWriteFtraceEventReader.init(buf);
        }
        return try samsung.SamsungTracingMarkWriteFtraceEventReader.init(&[_]u8{});
    }
    pub fn getBinderCommand(self: *const FtraceEventReader) gremlin.Error!binder.BinderCommandFtraceEventReader {
        if (self._binder_command_buf) |buf| {
            return try binder.BinderCommandFtraceEventReader.init(buf);
        }
        return try binder.BinderCommandFtraceEventReader.init(&[_]u8{});
    }
    pub fn getBinderReturn(self: *const FtraceEventReader) gremlin.Error!binder.BinderReturnFtraceEventReader {
        if (self._binder_return_buf) |buf| {
            return try binder.BinderReturnFtraceEventReader.init(buf);
        }
        return try binder.BinderReturnFtraceEventReader.init(&[_]u8{});
    }
    pub fn getSchedSwitchWithCtrs(self: *const FtraceEventReader) gremlin.Error!perf_trace_counters.SchedSwitchWithCtrsFtraceEventReader {
        if (self._sched_switch_with_ctrs_buf) |buf| {
            return try perf_trace_counters.SchedSwitchWithCtrsFtraceEventReader.init(buf);
        }
        return try perf_trace_counters.SchedSwitchWithCtrsFtraceEventReader.init(&[_]u8{});
    }
    pub fn getGpuWorkPeriod(self: *const FtraceEventReader) gremlin.Error!power.GpuWorkPeriodFtraceEventReader {
        if (self._gpu_work_period_buf) |buf| {
            return try power.GpuWorkPeriodFtraceEventReader.init(buf);
        }
        return try power.GpuWorkPeriodFtraceEventReader.init(&[_]u8{});
    }
    pub fn getRpmStatus(self: *const FtraceEventReader) gremlin.Error!rpm.RpmStatusFtraceEventReader {
        if (self._rpm_status_buf) |buf| {
            return try rpm.RpmStatusFtraceEventReader.init(buf);
        }
        return try rpm.RpmStatusFtraceEventReader.init(&[_]u8{});
    }
    pub fn getPanelWriteGeneric(self: *const FtraceEventReader) gremlin.Error!panel.PanelWriteGenericFtraceEventReader {
        if (self._panel_write_generic_buf) |buf| {
            return try panel.PanelWriteGenericFtraceEventReader.init(buf);
        }
        return try panel.PanelWriteGenericFtraceEventReader.init(&[_]u8{});
    }
    pub fn getSchedMigrateTask(self: *const FtraceEventReader) gremlin.Error!sched.SchedMigrateTaskFtraceEventReader {
        if (self._sched_migrate_task_buf) |buf| {
            return try sched.SchedMigrateTaskFtraceEventReader.init(buf);
        }
        return try sched.SchedMigrateTaskFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDpuDsiCmdFifoStatus(self: *const FtraceEventReader) gremlin.Error!dpu.DpuDsiCmdFifoStatusFtraceEventReader {
        if (self._dpu_dsi_cmd_fifo_status_buf) |buf| {
            return try dpu.DpuDsiCmdFifoStatusFtraceEventReader.init(buf);
        }
        return try dpu.DpuDsiCmdFifoStatusFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDpuDsiRx(self: *const FtraceEventReader) gremlin.Error!dpu.DpuDsiRxFtraceEventReader {
        if (self._dpu_dsi_rx_buf) |buf| {
            return try dpu.DpuDsiRxFtraceEventReader.init(buf);
        }
        return try dpu.DpuDsiRxFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDpuDsiTx(self: *const FtraceEventReader) gremlin.Error!dpu.DpuDsiTxFtraceEventReader {
        if (self._dpu_dsi_tx_buf) |buf| {
            return try dpu.DpuDsiTxFtraceEventReader.init(buf);
        }
        return try dpu.DpuDsiTxFtraceEventReader.init(&[_]u8{});
    }
    pub fn getF2fsBackgroundGc(self: *const FtraceEventReader) gremlin.Error!f2fs.F2fsBackgroundGcFtraceEventReader {
        if (self._f2fs_background_gc_buf) |buf| {
            return try f2fs.F2fsBackgroundGcFtraceEventReader.init(buf);
        }
        return try f2fs.F2fsBackgroundGcFtraceEventReader.init(&[_]u8{});
    }
    pub fn getF2fsGcBegin(self: *const FtraceEventReader) gremlin.Error!f2fs.F2fsGcBeginFtraceEventReader {
        if (self._f2fs_gc_begin_buf) |buf| {
            return try f2fs.F2fsGcBeginFtraceEventReader.init(buf);
        }
        return try f2fs.F2fsGcBeginFtraceEventReader.init(&[_]u8{});
    }
    pub fn getF2fsGcEnd(self: *const FtraceEventReader) gremlin.Error!f2fs.F2fsGcEndFtraceEventReader {
        if (self._f2fs_gc_end_buf) |buf| {
            return try f2fs.F2fsGcEndFtraceEventReader.init(buf);
        }
        return try f2fs.F2fsGcEndFtraceEventReader.init(&[_]u8{});
    }
    pub fn getFastrpcDmaFree(self: *const FtraceEventReader) gremlin.Error!fastrpc.FastrpcDmaFreeFtraceEventReader {
        if (self._fastrpc_dma_free_buf) |buf| {
            return try fastrpc.FastrpcDmaFreeFtraceEventReader.init(buf);
        }
        return try fastrpc.FastrpcDmaFreeFtraceEventReader.init(&[_]u8{});
    }
    pub fn getFastrpcDmaAlloc(self: *const FtraceEventReader) gremlin.Error!fastrpc.FastrpcDmaAllocFtraceEventReader {
        if (self._fastrpc_dma_alloc_buf) |buf| {
            return try fastrpc.FastrpcDmaAllocFtraceEventReader.init(buf);
        }
        return try fastrpc.FastrpcDmaAllocFtraceEventReader.init(&[_]u8{});
    }
    pub fn getFastrpcDmaUnmap(self: *const FtraceEventReader) gremlin.Error!fastrpc.FastrpcDmaUnmapFtraceEventReader {
        if (self._fastrpc_dma_unmap_buf) |buf| {
            return try fastrpc.FastrpcDmaUnmapFtraceEventReader.init(buf);
        }
        return try fastrpc.FastrpcDmaUnmapFtraceEventReader.init(&[_]u8{});
    }
    pub fn getFastrpcDmaMap(self: *const FtraceEventReader) gremlin.Error!fastrpc.FastrpcDmaMapFtraceEventReader {
        if (self._fastrpc_dma_map_buf) |buf| {
            return try fastrpc.FastrpcDmaMapFtraceEventReader.init(buf);
        }
        return try fastrpc.FastrpcDmaMapFtraceEventReader.init(&[_]u8{});
    }
    pub fn getGoogleIccEvent(self: *const FtraceEventReader) gremlin.Error!google_icc_trace.GoogleIccEventFtraceEventReader {
        if (self._google_icc_event_buf) |buf| {
            return try google_icc_trace.GoogleIccEventFtraceEventReader.init(buf);
        }
        return try google_icc_trace.GoogleIccEventFtraceEventReader.init(&[_]u8{});
    }
    pub fn getGoogleIrmEvent(self: *const FtraceEventReader) gremlin.Error!google_irm_trace.GoogleIrmEventFtraceEventReader {
        if (self._google_irm_event_buf) |buf| {
            return try google_irm_trace.GoogleIrmEventFtraceEventReader.init(buf);
        }
        return try google_irm_trace.GoogleIrmEventFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDevicePmCallbackStart(self: *const FtraceEventReader) gremlin.Error!power.DevicePmCallbackStartFtraceEventReader {
        if (self._device_pm_callback_start_buf) |buf| {
            return try power.DevicePmCallbackStartFtraceEventReader.init(buf);
        }
        return try power.DevicePmCallbackStartFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDevicePmCallbackEnd(self: *const FtraceEventReader) gremlin.Error!power.DevicePmCallbackEndFtraceEventReader {
        if (self._device_pm_callback_end_buf) |buf| {
            return try power.DevicePmCallbackEndFtraceEventReader.init(buf);
        }
        return try power.DevicePmCallbackEndFtraceEventReader.init(&[_]u8{});
    }
    pub fn getThermalExynosAcpmBulk(self: *const FtraceEventReader) gremlin.Error!thermal_exynos.ThermalExynosAcpmBulkFtraceEventReader {
        if (self._thermal_exynos_acpm_bulk_buf) |buf| {
            return try thermal_exynos.ThermalExynosAcpmBulkFtraceEventReader.init(buf);
        }
        return try thermal_exynos.ThermalExynosAcpmBulkFtraceEventReader.init(&[_]u8{});
    }
    pub fn getThermalExynosAcpmHighOverhead(self: *const FtraceEventReader) gremlin.Error!thermal_exynos.ThermalExynosAcpmHighOverheadFtraceEventReader {
        if (self._thermal_exynos_acpm_high_overhead_buf) |buf| {
            return try thermal_exynos.ThermalExynosAcpmHighOverheadFtraceEventReader.init(buf);
        }
        return try thermal_exynos.ThermalExynosAcpmHighOverheadFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDcvshFreq(self: *const FtraceEventReader) gremlin.Error!dcvsh.DcvshFreqFtraceEventReader {
        if (self._dcvsh_freq_buf) |buf| {
            return try dcvsh.DcvshFreqFtraceEventReader.init(buf);
        }
        return try dcvsh.DcvshFreqFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKgslGpuFrequency(self: *const FtraceEventReader) gremlin.Error!kgsl.KgslGpuFrequencyFtraceEventReader {
        if (self._kgsl_gpu_frequency_buf) |buf| {
            return try kgsl.KgslGpuFrequencyFtraceEventReader.init(buf);
        }
        return try kgsl.KgslGpuFrequencyFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMaliMaliPMMCUHCTLCORESDOWNSCALENOTIFYPEND(self: *const FtraceEventReader) gremlin.Error!mali.MaliMaliPMMCUHCTLCORESDOWNSCALENOTIFYPENDFtraceEventReader {
        if (self._mali_mali_p_m_m_c_u_h_c_t_l_c_o_r_e_s_d_o_w_n_s_c_a_l_e_n_o_t_i_f_y_p_e_n_d_buf) |buf| {
            return try mali.MaliMaliPMMCUHCTLCORESDOWNSCALENOTIFYPENDFtraceEventReader.init(buf);
        }
        return try mali.MaliMaliPMMCUHCTLCORESDOWNSCALENOTIFYPENDFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMaliMaliPMMCUHCTLCORESNOTIFYPEND(self: *const FtraceEventReader) gremlin.Error!mali.MaliMaliPMMCUHCTLCORESNOTIFYPENDFtraceEventReader {
        if (self._mali_mali_p_m_m_c_u_h_c_t_l_c_o_r_e_s_n_o_t_i_f_y_p_e_n_d_buf) |buf| {
            return try mali.MaliMaliPMMCUHCTLCORESNOTIFYPENDFtraceEventReader.init(buf);
        }
        return try mali.MaliMaliPMMCUHCTLCORESNOTIFYPENDFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMaliMaliPMMCUHCTLCOREINACTIVEPEND(self: *const FtraceEventReader) gremlin.Error!mali.MaliMaliPMMCUHCTLCOREINACTIVEPENDFtraceEventReader {
        if (self._mali_mali_p_m_m_c_u_h_c_t_l_c_o_r_e_i_n_a_c_t_i_v_e_p_e_n_d_buf) |buf| {
            return try mali.MaliMaliPMMCUHCTLCOREINACTIVEPENDFtraceEventReader.init(buf);
        }
        return try mali.MaliMaliPMMCUHCTLCOREINACTIVEPENDFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMaliMaliPMMCUHCTLMCUONRECHECK(self: *const FtraceEventReader) gremlin.Error!mali.MaliMaliPMMCUHCTLMCUONRECHECKFtraceEventReader {
        if (self._mali_mali_p_m_m_c_u_h_c_t_l_m_c_u_o_n_r_e_c_h_e_c_k_buf) |buf| {
            return try mali.MaliMaliPMMCUHCTLMCUONRECHECKFtraceEventReader.init(buf);
        }
        return try mali.MaliMaliPMMCUHCTLMCUONRECHECKFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMaliMaliPMMCUHCTLSHADERSCOREOFFPEND(self: *const FtraceEventReader) gremlin.Error!mali.MaliMaliPMMCUHCTLSHADERSCOREOFFPENDFtraceEventReader {
        if (self._mali_mali_p_m_m_c_u_h_c_t_l_s_h_a_d_e_r_s_c_o_r_e_o_f_f_p_e_n_d_buf) |buf| {
            return try mali.MaliMaliPMMCUHCTLSHADERSCOREOFFPENDFtraceEventReader.init(buf);
        }
        return try mali.MaliMaliPMMCUHCTLSHADERSCOREOFFPENDFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMaliMaliPMMCUHCTLSHADERSPENDOFF(self: *const FtraceEventReader) gremlin.Error!mali.MaliMaliPMMCUHCTLSHADERSPENDOFFFtraceEventReader {
        if (self._mali_mali_p_m_m_c_u_h_c_t_l_s_h_a_d_e_r_s_p_e_n_d_o_f_f_buf) |buf| {
            return try mali.MaliMaliPMMCUHCTLSHADERSPENDOFFFtraceEventReader.init(buf);
        }
        return try mali.MaliMaliPMMCUHCTLSHADERSPENDOFFFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMaliMaliPMMCUHCTLSHADERSPENDON(self: *const FtraceEventReader) gremlin.Error!mali.MaliMaliPMMCUHCTLSHADERSPENDONFtraceEventReader {
        if (self._mali_mali_p_m_m_c_u_h_c_t_l_s_h_a_d_e_r_s_p_e_n_d_o_n_buf) |buf| {
            return try mali.MaliMaliPMMCUHCTLSHADERSPENDONFtraceEventReader.init(buf);
        }
        return try mali.MaliMaliPMMCUHCTLSHADERSPENDONFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMaliMaliPMMCUHCTLSHADERSREADYOFF(self: *const FtraceEventReader) gremlin.Error!mali.MaliMaliPMMCUHCTLSHADERSREADYOFFFtraceEventReader {
        if (self._mali_mali_p_m_m_c_u_h_c_t_l_s_h_a_d_e_r_s_r_e_a_d_y_o_f_f_buf) |buf| {
            return try mali.MaliMaliPMMCUHCTLSHADERSREADYOFFFtraceEventReader.init(buf);
        }
        return try mali.MaliMaliPMMCUHCTLSHADERSREADYOFFFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMaliMaliPMMCUINSLEEP(self: *const FtraceEventReader) gremlin.Error!mali.MaliMaliPMMCUINSLEEPFtraceEventReader {
        if (self._mali_mali_p_m_m_c_u_i_n_s_l_e_e_p_buf) |buf| {
            return try mali.MaliMaliPMMCUINSLEEPFtraceEventReader.init(buf);
        }
        return try mali.MaliMaliPMMCUINSLEEPFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMaliMaliPMMCUOFF(self: *const FtraceEventReader) gremlin.Error!mali.MaliMaliPMMCUOFFFtraceEventReader {
        if (self._mali_mali_p_m_m_c_u_o_f_f_buf) |buf| {
            return try mali.MaliMaliPMMCUOFFFtraceEventReader.init(buf);
        }
        return try mali.MaliMaliPMMCUOFFFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMaliMaliPMMCUON(self: *const FtraceEventReader) gremlin.Error!mali.MaliMaliPMMCUONFtraceEventReader {
        if (self._mali_mali_p_m_m_c_u_o_n_buf) |buf| {
            return try mali.MaliMaliPMMCUONFtraceEventReader.init(buf);
        }
        return try mali.MaliMaliPMMCUONFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMaliMaliPMMCUONCOREATTRUPDATEPEND(self: *const FtraceEventReader) gremlin.Error!mali.MaliMaliPMMCUONCOREATTRUPDATEPENDFtraceEventReader {
        if (self._mali_mali_p_m_m_c_u_o_n_c_o_r_e_a_t_t_r_u_p_d_a_t_e_p_e_n_d_buf) |buf| {
            return try mali.MaliMaliPMMCUONCOREATTRUPDATEPENDFtraceEventReader.init(buf);
        }
        return try mali.MaliMaliPMMCUONCOREATTRUPDATEPENDFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMaliMaliPMMCUONGLBREINITPEND(self: *const FtraceEventReader) gremlin.Error!mali.MaliMaliPMMCUONGLBREINITPENDFtraceEventReader {
        if (self._mali_mali_p_m_m_c_u_o_n_g_l_b_r_e_i_n_i_t_p_e_n_d_buf) |buf| {
            return try mali.MaliMaliPMMCUONGLBREINITPENDFtraceEventReader.init(buf);
        }
        return try mali.MaliMaliPMMCUONGLBREINITPENDFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMaliMaliPMMCUONHALT(self: *const FtraceEventReader) gremlin.Error!mali.MaliMaliPMMCUONHALTFtraceEventReader {
        if (self._mali_mali_p_m_m_c_u_o_n_h_a_l_t_buf) |buf| {
            return try mali.MaliMaliPMMCUONHALTFtraceEventReader.init(buf);
        }
        return try mali.MaliMaliPMMCUONHALTFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMaliMaliPMMCUONHWCNTDISABLE(self: *const FtraceEventReader) gremlin.Error!mali.MaliMaliPMMCUONHWCNTDISABLEFtraceEventReader {
        if (self._mali_mali_p_m_m_c_u_o_n_h_w_c_n_t_d_i_s_a_b_l_e_buf) |buf| {
            return try mali.MaliMaliPMMCUONHWCNTDISABLEFtraceEventReader.init(buf);
        }
        return try mali.MaliMaliPMMCUONHWCNTDISABLEFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMaliMaliPMMCUONHWCNTENABLE(self: *const FtraceEventReader) gremlin.Error!mali.MaliMaliPMMCUONHWCNTENABLEFtraceEventReader {
        if (self._mali_mali_p_m_m_c_u_o_n_h_w_c_n_t_e_n_a_b_l_e_buf) |buf| {
            return try mali.MaliMaliPMMCUONHWCNTENABLEFtraceEventReader.init(buf);
        }
        return try mali.MaliMaliPMMCUONHWCNTENABLEFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMaliMaliPMMCUONPENDHALT(self: *const FtraceEventReader) gremlin.Error!mali.MaliMaliPMMCUONPENDHALTFtraceEventReader {
        if (self._mali_mali_p_m_m_c_u_o_n_p_e_n_d_h_a_l_t_buf) |buf| {
            return try mali.MaliMaliPMMCUONPENDHALTFtraceEventReader.init(buf);
        }
        return try mali.MaliMaliPMMCUONPENDHALTFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMaliMaliPMMCUONPENDSLEEP(self: *const FtraceEventReader) gremlin.Error!mali.MaliMaliPMMCUONPENDSLEEPFtraceEventReader {
        if (self._mali_mali_p_m_m_c_u_o_n_p_e_n_d_s_l_e_e_p_buf) |buf| {
            return try mali.MaliMaliPMMCUONPENDSLEEPFtraceEventReader.init(buf);
        }
        return try mali.MaliMaliPMMCUONPENDSLEEPFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMaliMaliPMMCUONSLEEPINITIATE(self: *const FtraceEventReader) gremlin.Error!mali.MaliMaliPMMCUONSLEEPINITIATEFtraceEventReader {
        if (self._mali_mali_p_m_m_c_u_o_n_s_l_e_e_p_i_n_i_t_i_a_t_e_buf) |buf| {
            return try mali.MaliMaliPMMCUONSLEEPINITIATEFtraceEventReader.init(buf);
        }
        return try mali.MaliMaliPMMCUONSLEEPINITIATEFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMaliMaliPMMCUPENDOFF(self: *const FtraceEventReader) gremlin.Error!mali.MaliMaliPMMCUPENDOFFFtraceEventReader {
        if (self._mali_mali_p_m_m_c_u_p_e_n_d_o_f_f_buf) |buf| {
            return try mali.MaliMaliPMMCUPENDOFFFtraceEventReader.init(buf);
        }
        return try mali.MaliMaliPMMCUPENDOFFFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMaliMaliPMMCUPENDONRELOAD(self: *const FtraceEventReader) gremlin.Error!mali.MaliMaliPMMCUPENDONRELOADFtraceEventReader {
        if (self._mali_mali_p_m_m_c_u_p_e_n_d_o_n_r_e_l_o_a_d_buf) |buf| {
            return try mali.MaliMaliPMMCUPENDONRELOADFtraceEventReader.init(buf);
        }
        return try mali.MaliMaliPMMCUPENDONRELOADFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMaliMaliPMMCUPOWERDOWN(self: *const FtraceEventReader) gremlin.Error!mali.MaliMaliPMMCUPOWERDOWNFtraceEventReader {
        if (self._mali_mali_p_m_m_c_u_p_o_w_e_r_d_o_w_n_buf) |buf| {
            return try mali.MaliMaliPMMCUPOWERDOWNFtraceEventReader.init(buf);
        }
        return try mali.MaliMaliPMMCUPOWERDOWNFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMaliMaliPMMCURESETWAIT(self: *const FtraceEventReader) gremlin.Error!mali.MaliMaliPMMCURESETWAITFtraceEventReader {
        if (self._mali_mali_p_m_m_c_u_r_e_s_e_t_w_a_i_t_buf) |buf| {
            return try mali.MaliMaliPMMCURESETWAITFtraceEventReader.init(buf);
        }
        return try mali.MaliMaliPMMCURESETWAITFtraceEventReader.init(&[_]u8{});
    }
    pub fn getBclIrqTrigger(self: *const FtraceEventReader) gremlin.Error!bcl_exynos.BclIrqTriggerFtraceEventReader {
        if (self._bcl_irq_trigger_buf) |buf| {
            return try bcl_exynos.BclIrqTriggerFtraceEventReader.init(buf);
        }
        return try bcl_exynos.BclIrqTriggerFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKgslAdrenoCmdbatchQueued(self: *const FtraceEventReader) gremlin.Error!kgsl.KgslAdrenoCmdbatchQueuedFtraceEventReader {
        if (self._kgsl_adreno_cmdbatch_queued_buf) |buf| {
            return try kgsl.KgslAdrenoCmdbatchQueuedFtraceEventReader.init(buf);
        }
        return try kgsl.KgslAdrenoCmdbatchQueuedFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKgslAdrenoCmdbatchSubmitted(self: *const FtraceEventReader) gremlin.Error!kgsl.KgslAdrenoCmdbatchSubmittedFtraceEventReader {
        if (self._kgsl_adreno_cmdbatch_submitted_buf) |buf| {
            return try kgsl.KgslAdrenoCmdbatchSubmittedFtraceEventReader.init(buf);
        }
        return try kgsl.KgslAdrenoCmdbatchSubmittedFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKgslAdrenoCmdbatchSync(self: *const FtraceEventReader) gremlin.Error!kgsl.KgslAdrenoCmdbatchSyncFtraceEventReader {
        if (self._kgsl_adreno_cmdbatch_sync_buf) |buf| {
            return try kgsl.KgslAdrenoCmdbatchSyncFtraceEventReader.init(buf);
        }
        return try kgsl.KgslAdrenoCmdbatchSyncFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKgslAdrenoCmdbatchRetired(self: *const FtraceEventReader) gremlin.Error!kgsl.KgslAdrenoCmdbatchRetiredFtraceEventReader {
        if (self._kgsl_adreno_cmdbatch_retired_buf) |buf| {
            return try kgsl.KgslAdrenoCmdbatchRetiredFtraceEventReader.init(buf);
        }
        return try kgsl.KgslAdrenoCmdbatchRetiredFtraceEventReader.init(&[_]u8{});
    }
    pub fn getPixelMmKswapdWake(self: *const FtraceEventReader) gremlin.Error!pixel_mm.PixelMmKswapdWakeFtraceEventReader {
        if (self._pixel_mm_kswapd_wake_buf) |buf| {
            return try pixel_mm.PixelMmKswapdWakeFtraceEventReader.init(buf);
        }
        return try pixel_mm.PixelMmKswapdWakeFtraceEventReader.init(&[_]u8{});
    }
    pub fn getPixelMmKswapdDone(self: *const FtraceEventReader) gremlin.Error!pixel_mm.PixelMmKswapdDoneFtraceEventReader {
        if (self._pixel_mm_kswapd_done_buf) |buf| {
            return try pixel_mm.PixelMmKswapdDoneFtraceEventReader.init(buf);
        }
        return try pixel_mm.PixelMmKswapdDoneFtraceEventReader.init(&[_]u8{});
    }
    pub fn getSchedWakeupTaskAttr(self: *const FtraceEventReader) gremlin.Error!sched.SchedWakeupTaskAttrFtraceEventReader {
        if (self._sched_wakeup_task_attr_buf) |buf| {
            return try sched.SchedWakeupTaskAttrFtraceEventReader.init(buf);
        }
        return try sched.SchedWakeupTaskAttrFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDevfreqFrequency(self: *const FtraceEventReader) gremlin.Error!devfreq.DevfreqFrequencyFtraceEventReader {
        if (self._devfreq_frequency_buf) |buf| {
            return try devfreq.DevfreqFrequencyFtraceEventReader.init(buf);
        }
        return try devfreq.DevfreqFrequencyFtraceEventReader.init(&[_]u8{});
    }
    pub fn getKprobeEvent(self: *const FtraceEventReader) gremlin.Error!generic.KprobeEventReader {
        if (self._kprobe_event_buf) |buf| {
            return try generic.KprobeEventReader.init(buf);
        }
        return try generic.KprobeEventReader.init(&[_]u8{});
    }
    pub fn getParamSetValueCpm(self: *const FtraceEventReader) gremlin.Error!cpm_trace.ParamSetValueCpmFtraceEventReader {
        if (self._param_set_value_cpm_buf) |buf| {
            return try cpm_trace.ParamSetValueCpmFtraceEventReader.init(buf);
        }
        return try cpm_trace.ParamSetValueCpmFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDoSysOpen(self: *const FtraceEventReader) gremlin.Error!fs.DoSysOpenFtraceEventReader {
        if (self._do_sys_open_buf) |buf| {
            return try fs.DoSysOpenFtraceEventReader.init(buf);
        }
        return try fs.DoSysOpenFtraceEventReader.init(&[_]u8{});
    }
    pub fn getOpenExec(self: *const FtraceEventReader) gremlin.Error!fs.OpenExecFtraceEventReader {
        if (self._open_exec_buf) |buf| {
            return try fs.OpenExecFtraceEventReader.init(buf);
        }
        return try fs.OpenExecFtraceEventReader.init(&[_]u8{});
    }
    pub fn getBlockIoStart(self: *const FtraceEventReader) gremlin.Error!block.BlockIoStartFtraceEventReader {
        if (self._block_io_start_buf) |buf| {
            return try block.BlockIoStartFtraceEventReader.init(buf);
        }
        return try block.BlockIoStartFtraceEventReader.init(&[_]u8{});
    }
    pub fn getBlockIoDone(self: *const FtraceEventReader) gremlin.Error!block.BlockIoDoneFtraceEventReader {
        if (self._block_io_done_buf) |buf| {
            return try block.BlockIoDoneFtraceEventReader.init(buf);
        }
        return try block.BlockIoDoneFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMaliGpuPowerState(self: *const FtraceEventReader) gremlin.Error!mali.MaliGpuPowerStateFtraceEventReader {
        if (self._mali_gpu_power_state_buf) |buf| {
            return try mali.MaliGpuPowerStateFtraceEventReader.init(buf);
        }
        return try mali.MaliGpuPowerStateFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDpuDispDpuUnderrun(self: *const FtraceEventReader) gremlin.Error!dpu.DpuDispDpuUnderrunFtraceEventReader {
        if (self._dpu_disp_dpu_underrun_buf) |buf| {
            return try dpu.DpuDispDpuUnderrunFtraceEventReader.init(buf);
        }
        return try dpu.DpuDispDpuUnderrunFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDpuDispVblankIrqEnable(self: *const FtraceEventReader) gremlin.Error!dpu.DpuDispVblankIrqEnableFtraceEventReader {
        if (self._dpu_disp_vblank_irq_enable_buf) |buf| {
            return try dpu.DpuDispVblankIrqEnableFtraceEventReader.init(buf);
        }
        return try dpu.DpuDispVblankIrqEnableFtraceEventReader.init(&[_]u8{});
    }
    pub fn getHrtimerStart(self: *const FtraceEventReader) gremlin.Error!timer.HrtimerStartFtraceEventReader {
        if (self._hrtimer_start_buf) |buf| {
            return try timer.HrtimerStartFtraceEventReader.init(buf);
        }
        return try timer.HrtimerStartFtraceEventReader.init(&[_]u8{});
    }
    pub fn getHrtimerCancel(self: *const FtraceEventReader) gremlin.Error!timer.HrtimerCancelFtraceEventReader {
        if (self._hrtimer_cancel_buf) |buf| {
            return try timer.HrtimerCancelFtraceEventReader.init(buf);
        }
        return try timer.HrtimerCancelFtraceEventReader.init(&[_]u8{});
    }
    pub fn getHrtimerExpireEntry(self: *const FtraceEventReader) gremlin.Error!timer.HrtimerExpireEntryFtraceEventReader {
        if (self._hrtimer_expire_entry_buf) |buf| {
            return try timer.HrtimerExpireEntryFtraceEventReader.init(buf);
        }
        return try timer.HrtimerExpireEntryFtraceEventReader.init(&[_]u8{});
    }
    pub fn getHrtimerExpireExit(self: *const FtraceEventReader) gremlin.Error!timer.HrtimerExpireExitFtraceEventReader {
        if (self._hrtimer_expire_exit_buf) |buf| {
            return try timer.HrtimerExpireExitFtraceEventReader.init(buf);
        }
        return try timer.HrtimerExpireExitFtraceEventReader.init(&[_]u8{});
    }
    pub fn getTimerStart(self: *const FtraceEventReader) gremlin.Error!timer.TimerStartFtraceEventReader {
        if (self._timer_start_buf) |buf| {
            return try timer.TimerStartFtraceEventReader.init(buf);
        }
        return try timer.TimerStartFtraceEventReader.init(&[_]u8{});
    }
    pub fn getTimerCancel(self: *const FtraceEventReader) gremlin.Error!timer.TimerCancelFtraceEventReader {
        if (self._timer_cancel_buf) |buf| {
            return try timer.TimerCancelFtraceEventReader.init(buf);
        }
        return try timer.TimerCancelFtraceEventReader.init(&[_]u8{});
    }
    pub fn getTimerExpireEntry(self: *const FtraceEventReader) gremlin.Error!timer.TimerExpireEntryFtraceEventReader {
        if (self._timer_expire_entry_buf) |buf| {
            return try timer.TimerExpireEntryFtraceEventReader.init(buf);
        }
        return try timer.TimerExpireEntryFtraceEventReader.init(&[_]u8{});
    }
    pub fn getTimerExpireExit(self: *const FtraceEventReader) gremlin.Error!timer.TimerExpireExitFtraceEventReader {
        if (self._timer_expire_exit_buf) |buf| {
            return try timer.TimerExpireExitFtraceEventReader.init(buf);
        }
        return try timer.TimerExpireExitFtraceEventReader.init(&[_]u8{});
    }
    pub fn getLocalTimerEntry(self: *const FtraceEventReader) gremlin.Error!irq_vectors.LocalTimerEntryFtraceEventReader {
        if (self._local_timer_entry_buf) |buf| {
            return try irq_vectors.LocalTimerEntryFtraceEventReader.init(buf);
        }
        return try irq_vectors.LocalTimerEntryFtraceEventReader.init(&[_]u8{});
    }
    pub fn getLocalTimerExit(self: *const FtraceEventReader) gremlin.Error!irq_vectors.LocalTimerExitFtraceEventReader {
        if (self._local_timer_exit_buf) |buf| {
            return try irq_vectors.LocalTimerExitFtraceEventReader.init(buf);
        }
        return try irq_vectors.LocalTimerExitFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDwc3AllocRequest(self: *const FtraceEventReader) gremlin.Error!dwc3.Dwc3AllocRequestFtraceEventReader {
        if (self._dwc3_alloc_request_buf) |buf| {
            return try dwc3.Dwc3AllocRequestFtraceEventReader.init(buf);
        }
        return try dwc3.Dwc3AllocRequestFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDwc3CompleteTrb(self: *const FtraceEventReader) gremlin.Error!dwc3.Dwc3CompleteTrbFtraceEventReader {
        if (self._dwc3_complete_trb_buf) |buf| {
            return try dwc3.Dwc3CompleteTrbFtraceEventReader.init(buf);
        }
        return try dwc3.Dwc3CompleteTrbFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDwc3CtrlReq(self: *const FtraceEventReader) gremlin.Error!dwc3.Dwc3CtrlReqFtraceEventReader {
        if (self._dwc3_ctrl_req_buf) |buf| {
            return try dwc3.Dwc3CtrlReqFtraceEventReader.init(buf);
        }
        return try dwc3.Dwc3CtrlReqFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDwc3EpDequeue(self: *const FtraceEventReader) gremlin.Error!dwc3.Dwc3EpDequeueFtraceEventReader {
        if (self._dwc3_ep_dequeue_buf) |buf| {
            return try dwc3.Dwc3EpDequeueFtraceEventReader.init(buf);
        }
        return try dwc3.Dwc3EpDequeueFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDwc3EpQueue(self: *const FtraceEventReader) gremlin.Error!dwc3.Dwc3EpQueueFtraceEventReader {
        if (self._dwc3_ep_queue_buf) |buf| {
            return try dwc3.Dwc3EpQueueFtraceEventReader.init(buf);
        }
        return try dwc3.Dwc3EpQueueFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDwc3Event(self: *const FtraceEventReader) gremlin.Error!dwc3.Dwc3EventFtraceEventReader {
        if (self._dwc3_event_buf) |buf| {
            return try dwc3.Dwc3EventFtraceEventReader.init(buf);
        }
        return try dwc3.Dwc3EventFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDwc3FreeRequest(self: *const FtraceEventReader) gremlin.Error!dwc3.Dwc3FreeRequestFtraceEventReader {
        if (self._dwc3_free_request_buf) |buf| {
            return try dwc3.Dwc3FreeRequestFtraceEventReader.init(buf);
        }
        return try dwc3.Dwc3FreeRequestFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDwc3GadgetEpCmd(self: *const FtraceEventReader) gremlin.Error!dwc3.Dwc3GadgetEpCmdFtraceEventReader {
        if (self._dwc3_gadget_ep_cmd_buf) |buf| {
            return try dwc3.Dwc3GadgetEpCmdFtraceEventReader.init(buf);
        }
        return try dwc3.Dwc3GadgetEpCmdFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDwc3GadgetEpDisable(self: *const FtraceEventReader) gremlin.Error!dwc3.Dwc3GadgetEpDisableFtraceEventReader {
        if (self._dwc3_gadget_ep_disable_buf) |buf| {
            return try dwc3.Dwc3GadgetEpDisableFtraceEventReader.init(buf);
        }
        return try dwc3.Dwc3GadgetEpDisableFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDwc3GadgetEpEnable(self: *const FtraceEventReader) gremlin.Error!dwc3.Dwc3GadgetEpEnableFtraceEventReader {
        if (self._dwc3_gadget_ep_enable_buf) |buf| {
            return try dwc3.Dwc3GadgetEpEnableFtraceEventReader.init(buf);
        }
        return try dwc3.Dwc3GadgetEpEnableFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDwc3GadgetGenericCmd(self: *const FtraceEventReader) gremlin.Error!dwc3.Dwc3GadgetGenericCmdFtraceEventReader {
        if (self._dwc3_gadget_generic_cmd_buf) |buf| {
            return try dwc3.Dwc3GadgetGenericCmdFtraceEventReader.init(buf);
        }
        return try dwc3.Dwc3GadgetGenericCmdFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDwc3GadgetGiveback(self: *const FtraceEventReader) gremlin.Error!dwc3.Dwc3GadgetGivebackFtraceEventReader {
        if (self._dwc3_gadget_giveback_buf) |buf| {
            return try dwc3.Dwc3GadgetGivebackFtraceEventReader.init(buf);
        }
        return try dwc3.Dwc3GadgetGivebackFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDwc3PrepareTrb(self: *const FtraceEventReader) gremlin.Error!dwc3.Dwc3PrepareTrbFtraceEventReader {
        if (self._dwc3_prepare_trb_buf) |buf| {
            return try dwc3.Dwc3PrepareTrbFtraceEventReader.init(buf);
        }
        return try dwc3.Dwc3PrepareTrbFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDwc3Readl(self: *const FtraceEventReader) gremlin.Error!dwc3.Dwc3ReadlFtraceEventReader {
        if (self._dwc3_readl_buf) |buf| {
            return try dwc3.Dwc3ReadlFtraceEventReader.init(buf);
        }
        return try dwc3.Dwc3ReadlFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDwc3Writel(self: *const FtraceEventReader) gremlin.Error!dwc3.Dwc3WritelFtraceEventReader {
        if (self._dwc3_writel_buf) |buf| {
            return try dwc3.Dwc3WritelFtraceEventReader.init(buf);
        }
        return try dwc3.Dwc3WritelFtraceEventReader.init(&[_]u8{});
    }
    pub fn getCmaAllocFinish(self: *const FtraceEventReader) gremlin.Error!cma.CmaAllocFinishFtraceEventReader {
        if (self._cma_alloc_finish_buf) |buf| {
            return try cma.CmaAllocFinishFtraceEventReader.init(buf);
        }
        return try cma.CmaAllocFinishFtraceEventReader.init(&[_]u8{});
    }
    pub fn getMmAllocContigMigrateRangeInfo(self: *const FtraceEventReader) gremlin.Error!kmem.MmAllocContigMigrateRangeInfoFtraceEventReader {
        if (self._mm_alloc_contig_migrate_range_info_buf) |buf| {
            return try kmem.MmAllocContigMigrateRangeInfoFtraceEventReader.init(buf);
        }
        return try kmem.MmAllocContigMigrateRangeInfoFtraceEventReader.init(&[_]u8{});
    }
    pub fn getHostFfaCall(self: *const FtraceEventReader) gremlin.Error!hyp.HostFfaCallFtraceEventReader {
        if (self._host_ffa_call_buf) |buf| {
            return try hyp.HostFfaCallFtraceEventReader.init(buf);
        }
        return try hyp.HostFfaCallFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDmabufRssStat(self: *const FtraceEventReader) gremlin.Error!kmem.DmabufRssStatFtraceEventReader {
        if (self._dmabuf_rss_stat_buf) |buf| {
            return try kmem.DmabufRssStatFtraceEventReader.init(buf);
        }
        return try kmem.DmabufRssStatFtraceEventReader.init(&[_]u8{});
    }
    pub fn getIommuIdmap(self: *const FtraceEventReader) gremlin.Error!hyp.IommuIdmapFtraceEventReader {
        if (self._iommu_idmap_buf) |buf| {
            return try hyp.IommuIdmapFtraceEventReader.init(buf);
        }
        return try hyp.IommuIdmapFtraceEventReader.init(&[_]u8{});
    }
    pub fn getPsciMemProtect(self: *const FtraceEventReader) gremlin.Error!hyp.PsciMemProtectFtraceEventReader {
        if (self._psci_mem_protect_buf) |buf| {
            return try hyp.PsciMemProtectFtraceEventReader.init(buf);
        }
        return try hyp.PsciMemProtectFtraceEventReader.init(&[_]u8{});
    }
    pub fn getHypervisorHostHcall(self: *const FtraceEventReader) gremlin.Error!hypervisor.HypervisorHostHcallFtraceEventReader {
        if (self._hypervisor_host_hcall_buf) |buf| {
            return try hypervisor.HypervisorHostHcallFtraceEventReader.init(buf);
        }
        return try hypervisor.HypervisorHostHcallFtraceEventReader.init(&[_]u8{});
    }
    pub fn getHypervisorHostSmc(self: *const FtraceEventReader) gremlin.Error!hypervisor.HypervisorHostSmcFtraceEventReader {
        if (self._hypervisor_host_smc_buf) |buf| {
            return try hypervisor.HypervisorHostSmcFtraceEventReader.init(buf);
        }
        return try hypervisor.HypervisorHostSmcFtraceEventReader.init(&[_]u8{});
    }
    pub fn getHypervisorHypExit(self: *const FtraceEventReader) gremlin.Error!hypervisor.HypervisorHypExitFtraceEventReader {
        if (self._hypervisor_hyp_exit_buf) |buf| {
            return try hypervisor.HypervisorHypExitFtraceEventReader.init(buf);
        }
        return try hypervisor.HypervisorHypExitFtraceEventReader.init(&[_]u8{});
    }
    pub fn getHypervisorIommuIdmap(self: *const FtraceEventReader) gremlin.Error!hypervisor.HypervisorIommuIdmapFtraceEventReader {
        if (self._hypervisor_iommu_idmap_buf) |buf| {
            return try hypervisor.HypervisorIommuIdmapFtraceEventReader.init(buf);
        }
        return try hypervisor.HypervisorIommuIdmapFtraceEventReader.init(&[_]u8{});
    }
    pub fn getHypervisorPsciMemProtect(self: *const FtraceEventReader) gremlin.Error!hypervisor.HypervisorPsciMemProtectFtraceEventReader {
        if (self._hypervisor_psci_mem_protect_buf) |buf| {
            return try hypervisor.HypervisorPsciMemProtectFtraceEventReader.init(buf);
        }
        return try hypervisor.HypervisorPsciMemProtectFtraceEventReader.init(&[_]u8{});
    }
    pub fn getHypervisorHostMemAbort(self: *const FtraceEventReader) gremlin.Error!hypervisor.HypervisorHostMemAbortFtraceEventReader {
        if (self._hypervisor_host_mem_abort_buf) |buf| {
            return try hypervisor.HypervisorHostMemAbortFtraceEventReader.init(buf);
        }
        return try hypervisor.HypervisorHostMemAbortFtraceEventReader.init(&[_]u8{});
    }
    pub fn getHypervisorHypEnter(self: *const FtraceEventReader) gremlin.Error!hypervisor.HypervisorHypEnterFtraceEventReader {
        if (self._hypervisor_hyp_enter_buf) |buf| {
            return try hypervisor.HypervisorHypEnterFtraceEventReader.init(buf);
        }
        return try hypervisor.HypervisorHypEnterFtraceEventReader.init(&[_]u8{});
    }
    pub fn getHypervisorIommuIdmapComplete(self: *const FtraceEventReader) gremlin.Error!hypervisor.HypervisorIommuIdmapCompleteFtraceEventReader {
        if (self._hypervisor_iommu_idmap_complete_buf) |buf| {
            return try hypervisor.HypervisorIommuIdmapCompleteFtraceEventReader.init(buf);
        }
        return try hypervisor.HypervisorIommuIdmapCompleteFtraceEventReader.init(&[_]u8{});
    }
    pub fn getHypervisorVcpuIllegalTrap(self: *const FtraceEventReader) gremlin.Error!hypervisor.HypervisorVcpuIllegalTrapFtraceEventReader {
        if (self._hypervisor_vcpu_illegal_trap_buf) |buf| {
            return try hypervisor.HypervisorVcpuIllegalTrapFtraceEventReader.init(buf);
        }
        return try hypervisor.HypervisorVcpuIllegalTrapFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDrmSchedJobAddDep(self: *const FtraceEventReader) gremlin.Error!gpu_scheduler.DrmSchedJobAddDepFtraceEventReader {
        if (self._drm_sched_job_add_dep_buf) |buf| {
            return try gpu_scheduler.DrmSchedJobAddDepFtraceEventReader.init(buf);
        }
        return try gpu_scheduler.DrmSchedJobAddDepFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDrmSchedJobDone(self: *const FtraceEventReader) gremlin.Error!gpu_scheduler.DrmSchedJobDoneFtraceEventReader {
        if (self._drm_sched_job_done_buf) |buf| {
            return try gpu_scheduler.DrmSchedJobDoneFtraceEventReader.init(buf);
        }
        return try gpu_scheduler.DrmSchedJobDoneFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDrmSchedJobQueue(self: *const FtraceEventReader) gremlin.Error!gpu_scheduler.DrmSchedJobQueueFtraceEventReader {
        if (self._drm_sched_job_queue_buf) |buf| {
            return try gpu_scheduler.DrmSchedJobQueueFtraceEventReader.init(buf);
        }
        return try gpu_scheduler.DrmSchedJobQueueFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDrmSchedJobRun(self: *const FtraceEventReader) gremlin.Error!gpu_scheduler.DrmSchedJobRunFtraceEventReader {
        if (self._drm_sched_job_run_buf) |buf| {
            return try gpu_scheduler.DrmSchedJobRunFtraceEventReader.init(buf);
        }
        return try gpu_scheduler.DrmSchedJobRunFtraceEventReader.init(&[_]u8{});
    }
    pub fn getDrmSchedJobUnschedulable(self: *const FtraceEventReader) gremlin.Error!gpu_scheduler.DrmSchedJobUnschedulableFtraceEventReader {
        if (self._drm_sched_job_unschedulable_buf) |buf| {
            return try gpu_scheduler.DrmSchedJobUnschedulableFtraceEventReader.init(buf);
        }
        return try gpu_scheduler.DrmSchedJobUnschedulableFtraceEventReader.init(&[_]u8{});
    }
    pub fn getFwtpPerfettoCounter(self: *const FtraceEventReader) gremlin.Error!fwtp_ftrace.FwtpPerfettoCounterFtraceEventReader {
        if (self._fwtp_perfetto_counter_buf) |buf| {
            return try fwtp_ftrace.FwtpPerfettoCounterFtraceEventReader.init(buf);
        }
        return try fwtp_ftrace.FwtpPerfettoCounterFtraceEventReader.init(&[_]u8{});
    }
};
