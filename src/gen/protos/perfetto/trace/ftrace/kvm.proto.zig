// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const KvmAccessFaultFtraceEventWire = struct {
    const IPA_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const KvmAccessFaultFtraceEvent = struct {
    // fields
    ipa: u64 = 0,
    pub fn calcProtobufSize(self: *const KvmAccessFaultFtraceEvent) usize {
        var res: usize = 0;
        if (self.ipa != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmAccessFaultFtraceEventWire.IPA_WIRE) + gremlin.sizes.sizeU64(self.ipa);
        }
        return res;
    }
    pub fn encode(self: *const KvmAccessFaultFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const KvmAccessFaultFtraceEvent, target: *gremlin.Writer) void {
        if (self.ipa != 0) {
            target.appendUint64(KvmAccessFaultFtraceEventWire.IPA_WIRE, self.ipa);
        }
    }
};
pub const KvmAccessFaultFtraceEventReader = struct {
    buf: gremlin.Reader,
    _ipa: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!KvmAccessFaultFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = KvmAccessFaultFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                KvmAccessFaultFtraceEventWire.IPA_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ipa = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getIpa(self: *const KvmAccessFaultFtraceEventReader) u64 {
        return self._ipa;
    }
};
const KvmAckIrqFtraceEventWire = struct {
    const IRQCHIP_WIRE: gremlin.ProtoWireNumber = 1;
    const PIN_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const KvmAckIrqFtraceEvent = struct {
    // fields
    irqchip: u32 = 0,
    pin: u32 = 0,
    pub fn calcProtobufSize(self: *const KvmAckIrqFtraceEvent) usize {
        var res: usize = 0;
        if (self.irqchip != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmAckIrqFtraceEventWire.IRQCHIP_WIRE) + gremlin.sizes.sizeU32(self.irqchip);
        }
        if (self.pin != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmAckIrqFtraceEventWire.PIN_WIRE) + gremlin.sizes.sizeU32(self.pin);
        }
        return res;
    }
    pub fn encode(self: *const KvmAckIrqFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const KvmAckIrqFtraceEvent, target: *gremlin.Writer) void {
        if (self.irqchip != 0) {
            target.appendUint32(KvmAckIrqFtraceEventWire.IRQCHIP_WIRE, self.irqchip);
        }
        if (self.pin != 0) {
            target.appendUint32(KvmAckIrqFtraceEventWire.PIN_WIRE, self.pin);
        }
    }
};
pub const KvmAckIrqFtraceEventReader = struct {
    buf: gremlin.Reader,
    _irqchip: u32 = 0,
    _pin: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!KvmAckIrqFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = KvmAckIrqFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                KvmAckIrqFtraceEventWire.IRQCHIP_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._irqchip = result.value;
                },
                KvmAckIrqFtraceEventWire.PIN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._pin = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getIrqchip(self: *const KvmAckIrqFtraceEventReader) u32 {
        return self._irqchip;
    }
    pub inline fn getPin(self: *const KvmAckIrqFtraceEventReader) u32 {
        return self._pin;
    }
};
const KvmAgeHvaFtraceEventWire = struct {
    const END_WIRE: gremlin.ProtoWireNumber = 1;
    const START_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const KvmAgeHvaFtraceEvent = struct {
    // fields
    end: u64 = 0,
    start: u64 = 0,
    pub fn calcProtobufSize(self: *const KvmAgeHvaFtraceEvent) usize {
        var res: usize = 0;
        if (self.end != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmAgeHvaFtraceEventWire.END_WIRE) + gremlin.sizes.sizeU64(self.end);
        }
        if (self.start != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmAgeHvaFtraceEventWire.START_WIRE) + gremlin.sizes.sizeU64(self.start);
        }
        return res;
    }
    pub fn encode(self: *const KvmAgeHvaFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const KvmAgeHvaFtraceEvent, target: *gremlin.Writer) void {
        if (self.end != 0) {
            target.appendUint64(KvmAgeHvaFtraceEventWire.END_WIRE, self.end);
        }
        if (self.start != 0) {
            target.appendUint64(KvmAgeHvaFtraceEventWire.START_WIRE, self.start);
        }
    }
};
pub const KvmAgeHvaFtraceEventReader = struct {
    buf: gremlin.Reader,
    _end: u64 = 0,
    _start: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!KvmAgeHvaFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = KvmAgeHvaFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                KvmAgeHvaFtraceEventWire.END_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._end = result.value;
                },
                KvmAgeHvaFtraceEventWire.START_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._start = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getEnd(self: *const KvmAgeHvaFtraceEventReader) u64 {
        return self._end;
    }
    pub inline fn getStart(self: *const KvmAgeHvaFtraceEventReader) u64 {
        return self._start;
    }
};
const KvmAgePageFtraceEventWire = struct {
    const GFN_WIRE: gremlin.ProtoWireNumber = 1;
    const HVA_WIRE: gremlin.ProtoWireNumber = 2;
    const LEVEL_WIRE: gremlin.ProtoWireNumber = 3;
    const REFERENCED_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const KvmAgePageFtraceEvent = struct {
    // fields
    gfn: u64 = 0,
    hva: u64 = 0,
    level: u32 = 0,
    referenced: u32 = 0,
    pub fn calcProtobufSize(self: *const KvmAgePageFtraceEvent) usize {
        var res: usize = 0;
        if (self.gfn != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmAgePageFtraceEventWire.GFN_WIRE) + gremlin.sizes.sizeU64(self.gfn);
        }
        if (self.hva != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmAgePageFtraceEventWire.HVA_WIRE) + gremlin.sizes.sizeU64(self.hva);
        }
        if (self.level != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmAgePageFtraceEventWire.LEVEL_WIRE) + gremlin.sizes.sizeU32(self.level);
        }
        if (self.referenced != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmAgePageFtraceEventWire.REFERENCED_WIRE) + gremlin.sizes.sizeU32(self.referenced);
        }
        return res;
    }
    pub fn encode(self: *const KvmAgePageFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const KvmAgePageFtraceEvent, target: *gremlin.Writer) void {
        if (self.gfn != 0) {
            target.appendUint64(KvmAgePageFtraceEventWire.GFN_WIRE, self.gfn);
        }
        if (self.hva != 0) {
            target.appendUint64(KvmAgePageFtraceEventWire.HVA_WIRE, self.hva);
        }
        if (self.level != 0) {
            target.appendUint32(KvmAgePageFtraceEventWire.LEVEL_WIRE, self.level);
        }
        if (self.referenced != 0) {
            target.appendUint32(KvmAgePageFtraceEventWire.REFERENCED_WIRE, self.referenced);
        }
    }
};
pub const KvmAgePageFtraceEventReader = struct {
    buf: gremlin.Reader,
    _gfn: u64 = 0,
    _hva: u64 = 0,
    _level: u32 = 0,
    _referenced: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!KvmAgePageFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = KvmAgePageFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                KvmAgePageFtraceEventWire.GFN_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._gfn = result.value;
                },
                KvmAgePageFtraceEventWire.HVA_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._hva = result.value;
                },
                KvmAgePageFtraceEventWire.LEVEL_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._level = result.value;
                },
                KvmAgePageFtraceEventWire.REFERENCED_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._referenced = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getGfn(self: *const KvmAgePageFtraceEventReader) u64 {
        return self._gfn;
    }
    pub inline fn getHva(self: *const KvmAgePageFtraceEventReader) u64 {
        return self._hva;
    }
    pub inline fn getLevel(self: *const KvmAgePageFtraceEventReader) u32 {
        return self._level;
    }
    pub inline fn getReferenced(self: *const KvmAgePageFtraceEventReader) u32 {
        return self._referenced;
    }
};
const KvmArmClearDebugFtraceEventWire = struct {
    const GUEST_DEBUG_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const KvmArmClearDebugFtraceEvent = struct {
    // fields
    guest_debug: u32 = 0,
    pub fn calcProtobufSize(self: *const KvmArmClearDebugFtraceEvent) usize {
        var res: usize = 0;
        if (self.guest_debug != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmArmClearDebugFtraceEventWire.GUEST_DEBUG_WIRE) + gremlin.sizes.sizeU32(self.guest_debug);
        }
        return res;
    }
    pub fn encode(self: *const KvmArmClearDebugFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const KvmArmClearDebugFtraceEvent, target: *gremlin.Writer) void {
        if (self.guest_debug != 0) {
            target.appendUint32(KvmArmClearDebugFtraceEventWire.GUEST_DEBUG_WIRE, self.guest_debug);
        }
    }
};
pub const KvmArmClearDebugFtraceEventReader = struct {
    buf: gremlin.Reader,
    _guest_debug: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!KvmArmClearDebugFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = KvmArmClearDebugFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                KvmArmClearDebugFtraceEventWire.GUEST_DEBUG_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._guest_debug = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getGuestDebug(self: *const KvmArmClearDebugFtraceEventReader) u32 {
        return self._guest_debug;
    }
};
const KvmArmSetDreg32FtraceEventWire = struct {
    const NAME_WIRE: gremlin.ProtoWireNumber = 1;
    const VALUE_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const KvmArmSetDreg32FtraceEvent = struct {
    // fields
    name: ?[]const u8 = null,
    value: u32 = 0,
    pub fn calcProtobufSize(self: *const KvmArmSetDreg32FtraceEvent) usize {
        var res: usize = 0;
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(KvmArmSetDreg32FtraceEventWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.value != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmArmSetDreg32FtraceEventWire.VALUE_WIRE) + gremlin.sizes.sizeU32(self.value);
        }
        return res;
    }
    pub fn encode(self: *const KvmArmSetDreg32FtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const KvmArmSetDreg32FtraceEvent, target: *gremlin.Writer) void {
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(KvmArmSetDreg32FtraceEventWire.NAME_WIRE, v);
            }
        }
        if (self.value != 0) {
            target.appendUint32(KvmArmSetDreg32FtraceEventWire.VALUE_WIRE, self.value);
        }
    }
};
pub const KvmArmSetDreg32FtraceEventReader = struct {
    buf: gremlin.Reader,
    _name: ?[]const u8 = null,
    _value: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!KvmArmSetDreg32FtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = KvmArmSetDreg32FtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                KvmArmSetDreg32FtraceEventWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                KvmArmSetDreg32FtraceEventWire.VALUE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._value = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getName(self: *const KvmArmSetDreg32FtraceEventReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub inline fn getValue(self: *const KvmArmSetDreg32FtraceEventReader) u32 {
        return self._value;
    }
};
const KvmArmSetRegsetFtraceEventWire = struct {
    const LEN_WIRE: gremlin.ProtoWireNumber = 1;
    const NAME_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const KvmArmSetRegsetFtraceEvent = struct {
    // fields
    len: i32 = 0,
    name: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const KvmArmSetRegsetFtraceEvent) usize {
        var res: usize = 0;
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmArmSetRegsetFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeI32(self.len);
        }
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(KvmArmSetRegsetFtraceEventWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const KvmArmSetRegsetFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const KvmArmSetRegsetFtraceEvent, target: *gremlin.Writer) void {
        if (self.len != 0) {
            target.appendInt32(KvmArmSetRegsetFtraceEventWire.LEN_WIRE, self.len);
        }
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(KvmArmSetRegsetFtraceEventWire.NAME_WIRE, v);
            }
        }
    }
};
pub const KvmArmSetRegsetFtraceEventReader = struct {
    buf: gremlin.Reader,
    _len: i32 = 0,
    _name: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!KvmArmSetRegsetFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = KvmArmSetRegsetFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                KvmArmSetRegsetFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                KvmArmSetRegsetFtraceEventWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getLen(self: *const KvmArmSetRegsetFtraceEventReader) i32 {
        return self._len;
    }
    pub inline fn getName(self: *const KvmArmSetRegsetFtraceEventReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
};
const KvmArmSetupDebugFtraceEventWire = struct {
    const GUEST_DEBUG_WIRE: gremlin.ProtoWireNumber = 1;
    const VCPU_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const KvmArmSetupDebugFtraceEvent = struct {
    // fields
    guest_debug: u32 = 0,
    vcpu: u64 = 0,
    pub fn calcProtobufSize(self: *const KvmArmSetupDebugFtraceEvent) usize {
        var res: usize = 0;
        if (self.guest_debug != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmArmSetupDebugFtraceEventWire.GUEST_DEBUG_WIRE) + gremlin.sizes.sizeU32(self.guest_debug);
        }
        if (self.vcpu != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmArmSetupDebugFtraceEventWire.VCPU_WIRE) + gremlin.sizes.sizeU64(self.vcpu);
        }
        return res;
    }
    pub fn encode(self: *const KvmArmSetupDebugFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const KvmArmSetupDebugFtraceEvent, target: *gremlin.Writer) void {
        if (self.guest_debug != 0) {
            target.appendUint32(KvmArmSetupDebugFtraceEventWire.GUEST_DEBUG_WIRE, self.guest_debug);
        }
        if (self.vcpu != 0) {
            target.appendUint64(KvmArmSetupDebugFtraceEventWire.VCPU_WIRE, self.vcpu);
        }
    }
};
pub const KvmArmSetupDebugFtraceEventReader = struct {
    buf: gremlin.Reader,
    _guest_debug: u32 = 0,
    _vcpu: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!KvmArmSetupDebugFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = KvmArmSetupDebugFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                KvmArmSetupDebugFtraceEventWire.GUEST_DEBUG_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._guest_debug = result.value;
                },
                KvmArmSetupDebugFtraceEventWire.VCPU_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._vcpu = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getGuestDebug(self: *const KvmArmSetupDebugFtraceEventReader) u32 {
        return self._guest_debug;
    }
    pub inline fn getVcpu(self: *const KvmArmSetupDebugFtraceEventReader) u64 {
        return self._vcpu;
    }
};
const KvmEntryFtraceEventWire = struct {
    const VCPU_PC_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const KvmEntryFtraceEvent = struct {
    // fields
    vcpu_pc: u64 = 0,
    pub fn calcProtobufSize(self: *const KvmEntryFtraceEvent) usize {
        var res: usize = 0;
        if (self.vcpu_pc != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmEntryFtraceEventWire.VCPU_PC_WIRE) + gremlin.sizes.sizeU64(self.vcpu_pc);
        }
        return res;
    }
    pub fn encode(self: *const KvmEntryFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const KvmEntryFtraceEvent, target: *gremlin.Writer) void {
        if (self.vcpu_pc != 0) {
            target.appendUint64(KvmEntryFtraceEventWire.VCPU_PC_WIRE, self.vcpu_pc);
        }
    }
};
pub const KvmEntryFtraceEventReader = struct {
    buf: gremlin.Reader,
    _vcpu_pc: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!KvmEntryFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = KvmEntryFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                KvmEntryFtraceEventWire.VCPU_PC_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._vcpu_pc = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getVcpuPc(self: *const KvmEntryFtraceEventReader) u64 {
        return self._vcpu_pc;
    }
};
const KvmExitFtraceEventWire = struct {
    const ESR_EC_WIRE: gremlin.ProtoWireNumber = 1;
    const RET_WIRE: gremlin.ProtoWireNumber = 2;
    const VCPU_PC_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const KvmExitFtraceEvent = struct {
    // fields
    esr_ec: u32 = 0,
    ret: i32 = 0,
    vcpu_pc: u64 = 0,
    pub fn calcProtobufSize(self: *const KvmExitFtraceEvent) usize {
        var res: usize = 0;
        if (self.esr_ec != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmExitFtraceEventWire.ESR_EC_WIRE) + gremlin.sizes.sizeU32(self.esr_ec);
        }
        if (self.ret != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmExitFtraceEventWire.RET_WIRE) + gremlin.sizes.sizeI32(self.ret);
        }
        if (self.vcpu_pc != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmExitFtraceEventWire.VCPU_PC_WIRE) + gremlin.sizes.sizeU64(self.vcpu_pc);
        }
        return res;
    }
    pub fn encode(self: *const KvmExitFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const KvmExitFtraceEvent, target: *gremlin.Writer) void {
        if (self.esr_ec != 0) {
            target.appendUint32(KvmExitFtraceEventWire.ESR_EC_WIRE, self.esr_ec);
        }
        if (self.ret != 0) {
            target.appendInt32(KvmExitFtraceEventWire.RET_WIRE, self.ret);
        }
        if (self.vcpu_pc != 0) {
            target.appendUint64(KvmExitFtraceEventWire.VCPU_PC_WIRE, self.vcpu_pc);
        }
    }
};
pub const KvmExitFtraceEventReader = struct {
    buf: gremlin.Reader,
    _esr_ec: u32 = 0,
    _ret: i32 = 0,
    _vcpu_pc: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!KvmExitFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = KvmExitFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                KvmExitFtraceEventWire.ESR_EC_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._esr_ec = result.value;
                },
                KvmExitFtraceEventWire.RET_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._ret = result.value;
                },
                KvmExitFtraceEventWire.VCPU_PC_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._vcpu_pc = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getEsrEc(self: *const KvmExitFtraceEventReader) u32 {
        return self._esr_ec;
    }
    pub inline fn getRet(self: *const KvmExitFtraceEventReader) i32 {
        return self._ret;
    }
    pub inline fn getVcpuPc(self: *const KvmExitFtraceEventReader) u64 {
        return self._vcpu_pc;
    }
};
const KvmFpuFtraceEventWire = struct {
    const LOAD_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const KvmFpuFtraceEvent = struct {
    // fields
    load: u32 = 0,
    pub fn calcProtobufSize(self: *const KvmFpuFtraceEvent) usize {
        var res: usize = 0;
        if (self.load != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmFpuFtraceEventWire.LOAD_WIRE) + gremlin.sizes.sizeU32(self.load);
        }
        return res;
    }
    pub fn encode(self: *const KvmFpuFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const KvmFpuFtraceEvent, target: *gremlin.Writer) void {
        if (self.load != 0) {
            target.appendUint32(KvmFpuFtraceEventWire.LOAD_WIRE, self.load);
        }
    }
};
pub const KvmFpuFtraceEventReader = struct {
    buf: gremlin.Reader,
    _load: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!KvmFpuFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = KvmFpuFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                KvmFpuFtraceEventWire.LOAD_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._load = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getLoad(self: *const KvmFpuFtraceEventReader) u32 {
        return self._load;
    }
};
const KvmGetTimerMapFtraceEventWire = struct {
    const DIRECT_PTIMER_WIRE: gremlin.ProtoWireNumber = 1;
    const DIRECT_VTIMER_WIRE: gremlin.ProtoWireNumber = 2;
    const EMUL_PTIMER_WIRE: gremlin.ProtoWireNumber = 3;
    const VCPU_ID_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const KvmGetTimerMapFtraceEvent = struct {
    // fields
    direct_ptimer: i32 = 0,
    direct_vtimer: i32 = 0,
    emul_ptimer: i32 = 0,
    vcpu_id: u64 = 0,
    pub fn calcProtobufSize(self: *const KvmGetTimerMapFtraceEvent) usize {
        var res: usize = 0;
        if (self.direct_ptimer != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmGetTimerMapFtraceEventWire.DIRECT_PTIMER_WIRE) + gremlin.sizes.sizeI32(self.direct_ptimer);
        }
        if (self.direct_vtimer != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmGetTimerMapFtraceEventWire.DIRECT_VTIMER_WIRE) + gremlin.sizes.sizeI32(self.direct_vtimer);
        }
        if (self.emul_ptimer != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmGetTimerMapFtraceEventWire.EMUL_PTIMER_WIRE) + gremlin.sizes.sizeI32(self.emul_ptimer);
        }
        if (self.vcpu_id != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmGetTimerMapFtraceEventWire.VCPU_ID_WIRE) + gremlin.sizes.sizeU64(self.vcpu_id);
        }
        return res;
    }
    pub fn encode(self: *const KvmGetTimerMapFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const KvmGetTimerMapFtraceEvent, target: *gremlin.Writer) void {
        if (self.direct_ptimer != 0) {
            target.appendInt32(KvmGetTimerMapFtraceEventWire.DIRECT_PTIMER_WIRE, self.direct_ptimer);
        }
        if (self.direct_vtimer != 0) {
            target.appendInt32(KvmGetTimerMapFtraceEventWire.DIRECT_VTIMER_WIRE, self.direct_vtimer);
        }
        if (self.emul_ptimer != 0) {
            target.appendInt32(KvmGetTimerMapFtraceEventWire.EMUL_PTIMER_WIRE, self.emul_ptimer);
        }
        if (self.vcpu_id != 0) {
            target.appendUint64(KvmGetTimerMapFtraceEventWire.VCPU_ID_WIRE, self.vcpu_id);
        }
    }
};
pub const KvmGetTimerMapFtraceEventReader = struct {
    buf: gremlin.Reader,
    _direct_ptimer: i32 = 0,
    _direct_vtimer: i32 = 0,
    _emul_ptimer: i32 = 0,
    _vcpu_id: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!KvmGetTimerMapFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = KvmGetTimerMapFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                KvmGetTimerMapFtraceEventWire.DIRECT_PTIMER_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._direct_ptimer = result.value;
                },
                KvmGetTimerMapFtraceEventWire.DIRECT_VTIMER_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._direct_vtimer = result.value;
                },
                KvmGetTimerMapFtraceEventWire.EMUL_PTIMER_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._emul_ptimer = result.value;
                },
                KvmGetTimerMapFtraceEventWire.VCPU_ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._vcpu_id = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDirectPtimer(self: *const KvmGetTimerMapFtraceEventReader) i32 {
        return self._direct_ptimer;
    }
    pub inline fn getDirectVtimer(self: *const KvmGetTimerMapFtraceEventReader) i32 {
        return self._direct_vtimer;
    }
    pub inline fn getEmulPtimer(self: *const KvmGetTimerMapFtraceEventReader) i32 {
        return self._emul_ptimer;
    }
    pub inline fn getVcpuId(self: *const KvmGetTimerMapFtraceEventReader) u64 {
        return self._vcpu_id;
    }
};
const KvmGuestFaultFtraceEventWire = struct {
    const HSR_WIRE: gremlin.ProtoWireNumber = 1;
    const HXFAR_WIRE: gremlin.ProtoWireNumber = 2;
    const IPA_WIRE: gremlin.ProtoWireNumber = 3;
    const VCPU_PC_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const KvmGuestFaultFtraceEvent = struct {
    // fields
    hsr: u64 = 0,
    hxfar: u64 = 0,
    ipa: u64 = 0,
    vcpu_pc: u64 = 0,
    pub fn calcProtobufSize(self: *const KvmGuestFaultFtraceEvent) usize {
        var res: usize = 0;
        if (self.hsr != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmGuestFaultFtraceEventWire.HSR_WIRE) + gremlin.sizes.sizeU64(self.hsr);
        }
        if (self.hxfar != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmGuestFaultFtraceEventWire.HXFAR_WIRE) + gremlin.sizes.sizeU64(self.hxfar);
        }
        if (self.ipa != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmGuestFaultFtraceEventWire.IPA_WIRE) + gremlin.sizes.sizeU64(self.ipa);
        }
        if (self.vcpu_pc != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmGuestFaultFtraceEventWire.VCPU_PC_WIRE) + gremlin.sizes.sizeU64(self.vcpu_pc);
        }
        return res;
    }
    pub fn encode(self: *const KvmGuestFaultFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const KvmGuestFaultFtraceEvent, target: *gremlin.Writer) void {
        if (self.hsr != 0) {
            target.appendUint64(KvmGuestFaultFtraceEventWire.HSR_WIRE, self.hsr);
        }
        if (self.hxfar != 0) {
            target.appendUint64(KvmGuestFaultFtraceEventWire.HXFAR_WIRE, self.hxfar);
        }
        if (self.ipa != 0) {
            target.appendUint64(KvmGuestFaultFtraceEventWire.IPA_WIRE, self.ipa);
        }
        if (self.vcpu_pc != 0) {
            target.appendUint64(KvmGuestFaultFtraceEventWire.VCPU_PC_WIRE, self.vcpu_pc);
        }
    }
};
pub const KvmGuestFaultFtraceEventReader = struct {
    buf: gremlin.Reader,
    _hsr: u64 = 0,
    _hxfar: u64 = 0,
    _ipa: u64 = 0,
    _vcpu_pc: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!KvmGuestFaultFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = KvmGuestFaultFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                KvmGuestFaultFtraceEventWire.HSR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._hsr = result.value;
                },
                KvmGuestFaultFtraceEventWire.HXFAR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._hxfar = result.value;
                },
                KvmGuestFaultFtraceEventWire.IPA_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ipa = result.value;
                },
                KvmGuestFaultFtraceEventWire.VCPU_PC_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._vcpu_pc = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getHsr(self: *const KvmGuestFaultFtraceEventReader) u64 {
        return self._hsr;
    }
    pub inline fn getHxfar(self: *const KvmGuestFaultFtraceEventReader) u64 {
        return self._hxfar;
    }
    pub inline fn getIpa(self: *const KvmGuestFaultFtraceEventReader) u64 {
        return self._ipa;
    }
    pub inline fn getVcpuPc(self: *const KvmGuestFaultFtraceEventReader) u64 {
        return self._vcpu_pc;
    }
};
const KvmHandleSysRegFtraceEventWire = struct {
    const HSR_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const KvmHandleSysRegFtraceEvent = struct {
    // fields
    hsr: u64 = 0,
    pub fn calcProtobufSize(self: *const KvmHandleSysRegFtraceEvent) usize {
        var res: usize = 0;
        if (self.hsr != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmHandleSysRegFtraceEventWire.HSR_WIRE) + gremlin.sizes.sizeU64(self.hsr);
        }
        return res;
    }
    pub fn encode(self: *const KvmHandleSysRegFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const KvmHandleSysRegFtraceEvent, target: *gremlin.Writer) void {
        if (self.hsr != 0) {
            target.appendUint64(KvmHandleSysRegFtraceEventWire.HSR_WIRE, self.hsr);
        }
    }
};
pub const KvmHandleSysRegFtraceEventReader = struct {
    buf: gremlin.Reader,
    _hsr: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!KvmHandleSysRegFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = KvmHandleSysRegFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                KvmHandleSysRegFtraceEventWire.HSR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._hsr = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getHsr(self: *const KvmHandleSysRegFtraceEventReader) u64 {
        return self._hsr;
    }
};
const KvmHvcArm64FtraceEventWire = struct {
    const IMM_WIRE: gremlin.ProtoWireNumber = 1;
    const R0_WIRE: gremlin.ProtoWireNumber = 2;
    const VCPU_PC_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const KvmHvcArm64FtraceEvent = struct {
    // fields
    imm: u64 = 0,
    r0: u64 = 0,
    vcpu_pc: u64 = 0,
    pub fn calcProtobufSize(self: *const KvmHvcArm64FtraceEvent) usize {
        var res: usize = 0;
        if (self.imm != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmHvcArm64FtraceEventWire.IMM_WIRE) + gremlin.sizes.sizeU64(self.imm);
        }
        if (self.r0 != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmHvcArm64FtraceEventWire.R0_WIRE) + gremlin.sizes.sizeU64(self.r0);
        }
        if (self.vcpu_pc != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmHvcArm64FtraceEventWire.VCPU_PC_WIRE) + gremlin.sizes.sizeU64(self.vcpu_pc);
        }
        return res;
    }
    pub fn encode(self: *const KvmHvcArm64FtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const KvmHvcArm64FtraceEvent, target: *gremlin.Writer) void {
        if (self.imm != 0) {
            target.appendUint64(KvmHvcArm64FtraceEventWire.IMM_WIRE, self.imm);
        }
        if (self.r0 != 0) {
            target.appendUint64(KvmHvcArm64FtraceEventWire.R0_WIRE, self.r0);
        }
        if (self.vcpu_pc != 0) {
            target.appendUint64(KvmHvcArm64FtraceEventWire.VCPU_PC_WIRE, self.vcpu_pc);
        }
    }
};
pub const KvmHvcArm64FtraceEventReader = struct {
    buf: gremlin.Reader,
    _imm: u64 = 0,
    _r0: u64 = 0,
    _vcpu_pc: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!KvmHvcArm64FtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = KvmHvcArm64FtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                KvmHvcArm64FtraceEventWire.IMM_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._imm = result.value;
                },
                KvmHvcArm64FtraceEventWire.R0_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._r0 = result.value;
                },
                KvmHvcArm64FtraceEventWire.VCPU_PC_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._vcpu_pc = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getImm(self: *const KvmHvcArm64FtraceEventReader) u64 {
        return self._imm;
    }
    pub inline fn getR0(self: *const KvmHvcArm64FtraceEventReader) u64 {
        return self._r0;
    }
    pub inline fn getVcpuPc(self: *const KvmHvcArm64FtraceEventReader) u64 {
        return self._vcpu_pc;
    }
};
const KvmIrqLineFtraceEventWire = struct {
    const IRQ_NUM_WIRE: gremlin.ProtoWireNumber = 1;
    const LEVEL_WIRE: gremlin.ProtoWireNumber = 2;
    const TYPE_WIRE: gremlin.ProtoWireNumber = 3;
    const VCPU_IDX_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const KvmIrqLineFtraceEvent = struct {
    // fields
    irq_num: i32 = 0,
    level: i32 = 0,
    type: u32 = 0,
    vcpu_idx: i32 = 0,
    pub fn calcProtobufSize(self: *const KvmIrqLineFtraceEvent) usize {
        var res: usize = 0;
        if (self.irq_num != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmIrqLineFtraceEventWire.IRQ_NUM_WIRE) + gremlin.sizes.sizeI32(self.irq_num);
        }
        if (self.level != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmIrqLineFtraceEventWire.LEVEL_WIRE) + gremlin.sizes.sizeI32(self.level);
        }
        if (self.type != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmIrqLineFtraceEventWire.TYPE_WIRE) + gremlin.sizes.sizeU32(self.type);
        }
        if (self.vcpu_idx != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmIrqLineFtraceEventWire.VCPU_IDX_WIRE) + gremlin.sizes.sizeI32(self.vcpu_idx);
        }
        return res;
    }
    pub fn encode(self: *const KvmIrqLineFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const KvmIrqLineFtraceEvent, target: *gremlin.Writer) void {
        if (self.irq_num != 0) {
            target.appendInt32(KvmIrqLineFtraceEventWire.IRQ_NUM_WIRE, self.irq_num);
        }
        if (self.level != 0) {
            target.appendInt32(KvmIrqLineFtraceEventWire.LEVEL_WIRE, self.level);
        }
        if (self.type != 0) {
            target.appendUint32(KvmIrqLineFtraceEventWire.TYPE_WIRE, self.type);
        }
        if (self.vcpu_idx != 0) {
            target.appendInt32(KvmIrqLineFtraceEventWire.VCPU_IDX_WIRE, self.vcpu_idx);
        }
    }
};
pub const KvmIrqLineFtraceEventReader = struct {
    buf: gremlin.Reader,
    _irq_num: i32 = 0,
    _level: i32 = 0,
    _type: u32 = 0,
    _vcpu_idx: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!KvmIrqLineFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = KvmIrqLineFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                KvmIrqLineFtraceEventWire.IRQ_NUM_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._irq_num = result.value;
                },
                KvmIrqLineFtraceEventWire.LEVEL_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._level = result.value;
                },
                KvmIrqLineFtraceEventWire.TYPE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._type = result.value;
                },
                KvmIrqLineFtraceEventWire.VCPU_IDX_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._vcpu_idx = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getIrqNum(self: *const KvmIrqLineFtraceEventReader) i32 {
        return self._irq_num;
    }
    pub inline fn getLevel(self: *const KvmIrqLineFtraceEventReader) i32 {
        return self._level;
    }
    pub inline fn getType(self: *const KvmIrqLineFtraceEventReader) u32 {
        return self._type;
    }
    pub inline fn getVcpuIdx(self: *const KvmIrqLineFtraceEventReader) i32 {
        return self._vcpu_idx;
    }
};
const KvmMmioFtraceEventWire = struct {
    const GPA_WIRE: gremlin.ProtoWireNumber = 1;
    const LEN_WIRE: gremlin.ProtoWireNumber = 2;
    const TYPE_WIRE: gremlin.ProtoWireNumber = 3;
    const VAL_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const KvmMmioFtraceEvent = struct {
    // fields
    gpa: u64 = 0,
    len: u32 = 0,
    type: u32 = 0,
    val: u64 = 0,
    pub fn calcProtobufSize(self: *const KvmMmioFtraceEvent) usize {
        var res: usize = 0;
        if (self.gpa != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmMmioFtraceEventWire.GPA_WIRE) + gremlin.sizes.sizeU64(self.gpa);
        }
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmMmioFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeU32(self.len);
        }
        if (self.type != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmMmioFtraceEventWire.TYPE_WIRE) + gremlin.sizes.sizeU32(self.type);
        }
        if (self.val != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmMmioFtraceEventWire.VAL_WIRE) + gremlin.sizes.sizeU64(self.val);
        }
        return res;
    }
    pub fn encode(self: *const KvmMmioFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const KvmMmioFtraceEvent, target: *gremlin.Writer) void {
        if (self.gpa != 0) {
            target.appendUint64(KvmMmioFtraceEventWire.GPA_WIRE, self.gpa);
        }
        if (self.len != 0) {
            target.appendUint32(KvmMmioFtraceEventWire.LEN_WIRE, self.len);
        }
        if (self.type != 0) {
            target.appendUint32(KvmMmioFtraceEventWire.TYPE_WIRE, self.type);
        }
        if (self.val != 0) {
            target.appendUint64(KvmMmioFtraceEventWire.VAL_WIRE, self.val);
        }
    }
};
pub const KvmMmioFtraceEventReader = struct {
    buf: gremlin.Reader,
    _gpa: u64 = 0,
    _len: u32 = 0,
    _type: u32 = 0,
    _val: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!KvmMmioFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = KvmMmioFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                KvmMmioFtraceEventWire.GPA_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._gpa = result.value;
                },
                KvmMmioFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                KvmMmioFtraceEventWire.TYPE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._type = result.value;
                },
                KvmMmioFtraceEventWire.VAL_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._val = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getGpa(self: *const KvmMmioFtraceEventReader) u64 {
        return self._gpa;
    }
    pub inline fn getLen(self: *const KvmMmioFtraceEventReader) u32 {
        return self._len;
    }
    pub inline fn getType(self: *const KvmMmioFtraceEventReader) u32 {
        return self._type;
    }
    pub inline fn getVal(self: *const KvmMmioFtraceEventReader) u64 {
        return self._val;
    }
};
const KvmMmioEmulateFtraceEventWire = struct {
    const CPSR_WIRE: gremlin.ProtoWireNumber = 1;
    const INSTR_WIRE: gremlin.ProtoWireNumber = 2;
    const VCPU_PC_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const KvmMmioEmulateFtraceEvent = struct {
    // fields
    cpsr: u64 = 0,
    instr: u64 = 0,
    vcpu_pc: u64 = 0,
    pub fn calcProtobufSize(self: *const KvmMmioEmulateFtraceEvent) usize {
        var res: usize = 0;
        if (self.cpsr != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmMmioEmulateFtraceEventWire.CPSR_WIRE) + gremlin.sizes.sizeU64(self.cpsr);
        }
        if (self.instr != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmMmioEmulateFtraceEventWire.INSTR_WIRE) + gremlin.sizes.sizeU64(self.instr);
        }
        if (self.vcpu_pc != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmMmioEmulateFtraceEventWire.VCPU_PC_WIRE) + gremlin.sizes.sizeU64(self.vcpu_pc);
        }
        return res;
    }
    pub fn encode(self: *const KvmMmioEmulateFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const KvmMmioEmulateFtraceEvent, target: *gremlin.Writer) void {
        if (self.cpsr != 0) {
            target.appendUint64(KvmMmioEmulateFtraceEventWire.CPSR_WIRE, self.cpsr);
        }
        if (self.instr != 0) {
            target.appendUint64(KvmMmioEmulateFtraceEventWire.INSTR_WIRE, self.instr);
        }
        if (self.vcpu_pc != 0) {
            target.appendUint64(KvmMmioEmulateFtraceEventWire.VCPU_PC_WIRE, self.vcpu_pc);
        }
    }
};
pub const KvmMmioEmulateFtraceEventReader = struct {
    buf: gremlin.Reader,
    _cpsr: u64 = 0,
    _instr: u64 = 0,
    _vcpu_pc: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!KvmMmioEmulateFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = KvmMmioEmulateFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                KvmMmioEmulateFtraceEventWire.CPSR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._cpsr = result.value;
                },
                KvmMmioEmulateFtraceEventWire.INSTR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._instr = result.value;
                },
                KvmMmioEmulateFtraceEventWire.VCPU_PC_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._vcpu_pc = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getCpsr(self: *const KvmMmioEmulateFtraceEventReader) u64 {
        return self._cpsr;
    }
    pub inline fn getInstr(self: *const KvmMmioEmulateFtraceEventReader) u64 {
        return self._instr;
    }
    pub inline fn getVcpuPc(self: *const KvmMmioEmulateFtraceEventReader) u64 {
        return self._vcpu_pc;
    }
};
const KvmSetGuestDebugFtraceEventWire = struct {
    const GUEST_DEBUG_WIRE: gremlin.ProtoWireNumber = 1;
    const VCPU_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const KvmSetGuestDebugFtraceEvent = struct {
    // fields
    guest_debug: u32 = 0,
    vcpu: u64 = 0,
    pub fn calcProtobufSize(self: *const KvmSetGuestDebugFtraceEvent) usize {
        var res: usize = 0;
        if (self.guest_debug != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmSetGuestDebugFtraceEventWire.GUEST_DEBUG_WIRE) + gremlin.sizes.sizeU32(self.guest_debug);
        }
        if (self.vcpu != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmSetGuestDebugFtraceEventWire.VCPU_WIRE) + gremlin.sizes.sizeU64(self.vcpu);
        }
        return res;
    }
    pub fn encode(self: *const KvmSetGuestDebugFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const KvmSetGuestDebugFtraceEvent, target: *gremlin.Writer) void {
        if (self.guest_debug != 0) {
            target.appendUint32(KvmSetGuestDebugFtraceEventWire.GUEST_DEBUG_WIRE, self.guest_debug);
        }
        if (self.vcpu != 0) {
            target.appendUint64(KvmSetGuestDebugFtraceEventWire.VCPU_WIRE, self.vcpu);
        }
    }
};
pub const KvmSetGuestDebugFtraceEventReader = struct {
    buf: gremlin.Reader,
    _guest_debug: u32 = 0,
    _vcpu: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!KvmSetGuestDebugFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = KvmSetGuestDebugFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                KvmSetGuestDebugFtraceEventWire.GUEST_DEBUG_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._guest_debug = result.value;
                },
                KvmSetGuestDebugFtraceEventWire.VCPU_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._vcpu = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getGuestDebug(self: *const KvmSetGuestDebugFtraceEventReader) u32 {
        return self._guest_debug;
    }
    pub inline fn getVcpu(self: *const KvmSetGuestDebugFtraceEventReader) u64 {
        return self._vcpu;
    }
};
const KvmSetIrqFtraceEventWire = struct {
    const GSI_WIRE: gremlin.ProtoWireNumber = 1;
    const IRQ_SOURCE_ID_WIRE: gremlin.ProtoWireNumber = 2;
    const LEVEL_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const KvmSetIrqFtraceEvent = struct {
    // fields
    gsi: u32 = 0,
    irq_source_id: i32 = 0,
    level: i32 = 0,
    pub fn calcProtobufSize(self: *const KvmSetIrqFtraceEvent) usize {
        var res: usize = 0;
        if (self.gsi != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmSetIrqFtraceEventWire.GSI_WIRE) + gremlin.sizes.sizeU32(self.gsi);
        }
        if (self.irq_source_id != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmSetIrqFtraceEventWire.IRQ_SOURCE_ID_WIRE) + gremlin.sizes.sizeI32(self.irq_source_id);
        }
        if (self.level != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmSetIrqFtraceEventWire.LEVEL_WIRE) + gremlin.sizes.sizeI32(self.level);
        }
        return res;
    }
    pub fn encode(self: *const KvmSetIrqFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const KvmSetIrqFtraceEvent, target: *gremlin.Writer) void {
        if (self.gsi != 0) {
            target.appendUint32(KvmSetIrqFtraceEventWire.GSI_WIRE, self.gsi);
        }
        if (self.irq_source_id != 0) {
            target.appendInt32(KvmSetIrqFtraceEventWire.IRQ_SOURCE_ID_WIRE, self.irq_source_id);
        }
        if (self.level != 0) {
            target.appendInt32(KvmSetIrqFtraceEventWire.LEVEL_WIRE, self.level);
        }
    }
};
pub const KvmSetIrqFtraceEventReader = struct {
    buf: gremlin.Reader,
    _gsi: u32 = 0,
    _irq_source_id: i32 = 0,
    _level: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!KvmSetIrqFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = KvmSetIrqFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                KvmSetIrqFtraceEventWire.GSI_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._gsi = result.value;
                },
                KvmSetIrqFtraceEventWire.IRQ_SOURCE_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._irq_source_id = result.value;
                },
                KvmSetIrqFtraceEventWire.LEVEL_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._level = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getGsi(self: *const KvmSetIrqFtraceEventReader) u32 {
        return self._gsi;
    }
    pub inline fn getIrqSourceId(self: *const KvmSetIrqFtraceEventReader) i32 {
        return self._irq_source_id;
    }
    pub inline fn getLevel(self: *const KvmSetIrqFtraceEventReader) i32 {
        return self._level;
    }
};
const KvmSetSpteHvaFtraceEventWire = struct {
    const HVA_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const KvmSetSpteHvaFtraceEvent = struct {
    // fields
    hva: u64 = 0,
    pub fn calcProtobufSize(self: *const KvmSetSpteHvaFtraceEvent) usize {
        var res: usize = 0;
        if (self.hva != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmSetSpteHvaFtraceEventWire.HVA_WIRE) + gremlin.sizes.sizeU64(self.hva);
        }
        return res;
    }
    pub fn encode(self: *const KvmSetSpteHvaFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const KvmSetSpteHvaFtraceEvent, target: *gremlin.Writer) void {
        if (self.hva != 0) {
            target.appendUint64(KvmSetSpteHvaFtraceEventWire.HVA_WIRE, self.hva);
        }
    }
};
pub const KvmSetSpteHvaFtraceEventReader = struct {
    buf: gremlin.Reader,
    _hva: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!KvmSetSpteHvaFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = KvmSetSpteHvaFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                KvmSetSpteHvaFtraceEventWire.HVA_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._hva = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getHva(self: *const KvmSetSpteHvaFtraceEventReader) u64 {
        return self._hva;
    }
};
const KvmSetWayFlushFtraceEventWire = struct {
    const CACHE_WIRE: gremlin.ProtoWireNumber = 1;
    const VCPU_PC_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const KvmSetWayFlushFtraceEvent = struct {
    // fields
    cache: u32 = 0,
    vcpu_pc: u64 = 0,
    pub fn calcProtobufSize(self: *const KvmSetWayFlushFtraceEvent) usize {
        var res: usize = 0;
        if (self.cache != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmSetWayFlushFtraceEventWire.CACHE_WIRE) + gremlin.sizes.sizeU32(self.cache);
        }
        if (self.vcpu_pc != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmSetWayFlushFtraceEventWire.VCPU_PC_WIRE) + gremlin.sizes.sizeU64(self.vcpu_pc);
        }
        return res;
    }
    pub fn encode(self: *const KvmSetWayFlushFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const KvmSetWayFlushFtraceEvent, target: *gremlin.Writer) void {
        if (self.cache != 0) {
            target.appendUint32(KvmSetWayFlushFtraceEventWire.CACHE_WIRE, self.cache);
        }
        if (self.vcpu_pc != 0) {
            target.appendUint64(KvmSetWayFlushFtraceEventWire.VCPU_PC_WIRE, self.vcpu_pc);
        }
    }
};
pub const KvmSetWayFlushFtraceEventReader = struct {
    buf: gremlin.Reader,
    _cache: u32 = 0,
    _vcpu_pc: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!KvmSetWayFlushFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = KvmSetWayFlushFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                KvmSetWayFlushFtraceEventWire.CACHE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._cache = result.value;
                },
                KvmSetWayFlushFtraceEventWire.VCPU_PC_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._vcpu_pc = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getCache(self: *const KvmSetWayFlushFtraceEventReader) u32 {
        return self._cache;
    }
    pub inline fn getVcpuPc(self: *const KvmSetWayFlushFtraceEventReader) u64 {
        return self._vcpu_pc;
    }
};
const KvmSysAccessFtraceEventWire = struct {
    const CRM_WIRE: gremlin.ProtoWireNumber = 1;
    const CRN_WIRE: gremlin.ProtoWireNumber = 2;
    const OP0_WIRE: gremlin.ProtoWireNumber = 3;
    const OP1_WIRE: gremlin.ProtoWireNumber = 4;
    const OP2_WIRE: gremlin.ProtoWireNumber = 5;
    const IS_WRITE_WIRE: gremlin.ProtoWireNumber = 6;
    const NAME_WIRE: gremlin.ProtoWireNumber = 7;
    const VCPU_PC_WIRE: gremlin.ProtoWireNumber = 8;
};
pub const KvmSysAccessFtraceEvent = struct {
    // fields
    c_rm: u32 = 0,
    c_rn: u32 = 0,
    op0: u32 = 0,
    op1: u32 = 0,
    op2: u32 = 0,
    is_write: u32 = 0,
    name: ?[]const u8 = null,
    vcpu_pc: u64 = 0,
    pub fn calcProtobufSize(self: *const KvmSysAccessFtraceEvent) usize {
        var res: usize = 0;
        if (self.c_rm != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmSysAccessFtraceEventWire.CRM_WIRE) + gremlin.sizes.sizeU32(self.c_rm);
        }
        if (self.c_rn != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmSysAccessFtraceEventWire.CRN_WIRE) + gremlin.sizes.sizeU32(self.c_rn);
        }
        if (self.op0 != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmSysAccessFtraceEventWire.OP0_WIRE) + gremlin.sizes.sizeU32(self.op0);
        }
        if (self.op1 != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmSysAccessFtraceEventWire.OP1_WIRE) + gremlin.sizes.sizeU32(self.op1);
        }
        if (self.op2 != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmSysAccessFtraceEventWire.OP2_WIRE) + gremlin.sizes.sizeU32(self.op2);
        }
        if (self.is_write != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmSysAccessFtraceEventWire.IS_WRITE_WIRE) + gremlin.sizes.sizeU32(self.is_write);
        }
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(KvmSysAccessFtraceEventWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.vcpu_pc != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmSysAccessFtraceEventWire.VCPU_PC_WIRE) + gremlin.sizes.sizeU64(self.vcpu_pc);
        }
        return res;
    }
    pub fn encode(self: *const KvmSysAccessFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const KvmSysAccessFtraceEvent, target: *gremlin.Writer) void {
        if (self.c_rm != 0) {
            target.appendUint32(KvmSysAccessFtraceEventWire.CRM_WIRE, self.c_rm);
        }
        if (self.c_rn != 0) {
            target.appendUint32(KvmSysAccessFtraceEventWire.CRN_WIRE, self.c_rn);
        }
        if (self.op0 != 0) {
            target.appendUint32(KvmSysAccessFtraceEventWire.OP0_WIRE, self.op0);
        }
        if (self.op1 != 0) {
            target.appendUint32(KvmSysAccessFtraceEventWire.OP1_WIRE, self.op1);
        }
        if (self.op2 != 0) {
            target.appendUint32(KvmSysAccessFtraceEventWire.OP2_WIRE, self.op2);
        }
        if (self.is_write != 0) {
            target.appendUint32(KvmSysAccessFtraceEventWire.IS_WRITE_WIRE, self.is_write);
        }
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(KvmSysAccessFtraceEventWire.NAME_WIRE, v);
            }
        }
        if (self.vcpu_pc != 0) {
            target.appendUint64(KvmSysAccessFtraceEventWire.VCPU_PC_WIRE, self.vcpu_pc);
        }
    }
};
pub const KvmSysAccessFtraceEventReader = struct {
    buf: gremlin.Reader,
    _c_rm: u32 = 0,
    _c_rn: u32 = 0,
    _op0: u32 = 0,
    _op1: u32 = 0,
    _op2: u32 = 0,
    _is_write: u32 = 0,
    _name: ?[]const u8 = null,
    _vcpu_pc: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!KvmSysAccessFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = KvmSysAccessFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                KvmSysAccessFtraceEventWire.CRM_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._c_rm = result.value;
                },
                KvmSysAccessFtraceEventWire.CRN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._c_rn = result.value;
                },
                KvmSysAccessFtraceEventWire.OP0_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._op0 = result.value;
                },
                KvmSysAccessFtraceEventWire.OP1_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._op1 = result.value;
                },
                KvmSysAccessFtraceEventWire.OP2_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._op2 = result.value;
                },
                KvmSysAccessFtraceEventWire.IS_WRITE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._is_write = result.value;
                },
                KvmSysAccessFtraceEventWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                KvmSysAccessFtraceEventWire.VCPU_PC_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._vcpu_pc = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getCRm(self: *const KvmSysAccessFtraceEventReader) u32 {
        return self._c_rm;
    }
    pub inline fn getCRn(self: *const KvmSysAccessFtraceEventReader) u32 {
        return self._c_rn;
    }
    pub inline fn getOp0(self: *const KvmSysAccessFtraceEventReader) u32 {
        return self._op0;
    }
    pub inline fn getOp1(self: *const KvmSysAccessFtraceEventReader) u32 {
        return self._op1;
    }
    pub inline fn getOp2(self: *const KvmSysAccessFtraceEventReader) u32 {
        return self._op2;
    }
    pub inline fn getIsWrite(self: *const KvmSysAccessFtraceEventReader) u32 {
        return self._is_write;
    }
    pub inline fn getName(self: *const KvmSysAccessFtraceEventReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub inline fn getVcpuPc(self: *const KvmSysAccessFtraceEventReader) u64 {
        return self._vcpu_pc;
    }
};
const KvmTestAgeHvaFtraceEventWire = struct {
    const HVA_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const KvmTestAgeHvaFtraceEvent = struct {
    // fields
    hva: u64 = 0,
    pub fn calcProtobufSize(self: *const KvmTestAgeHvaFtraceEvent) usize {
        var res: usize = 0;
        if (self.hva != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmTestAgeHvaFtraceEventWire.HVA_WIRE) + gremlin.sizes.sizeU64(self.hva);
        }
        return res;
    }
    pub fn encode(self: *const KvmTestAgeHvaFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const KvmTestAgeHvaFtraceEvent, target: *gremlin.Writer) void {
        if (self.hva != 0) {
            target.appendUint64(KvmTestAgeHvaFtraceEventWire.HVA_WIRE, self.hva);
        }
    }
};
pub const KvmTestAgeHvaFtraceEventReader = struct {
    buf: gremlin.Reader,
    _hva: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!KvmTestAgeHvaFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = KvmTestAgeHvaFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                KvmTestAgeHvaFtraceEventWire.HVA_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._hva = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getHva(self: *const KvmTestAgeHvaFtraceEventReader) u64 {
        return self._hva;
    }
};
const KvmTimerEmulateFtraceEventWire = struct {
    const SHOULD_FIRE_WIRE: gremlin.ProtoWireNumber = 1;
    const TIMER_IDX_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const KvmTimerEmulateFtraceEvent = struct {
    // fields
    should_fire: u32 = 0,
    timer_idx: i32 = 0,
    pub fn calcProtobufSize(self: *const KvmTimerEmulateFtraceEvent) usize {
        var res: usize = 0;
        if (self.should_fire != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmTimerEmulateFtraceEventWire.SHOULD_FIRE_WIRE) + gremlin.sizes.sizeU32(self.should_fire);
        }
        if (self.timer_idx != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmTimerEmulateFtraceEventWire.TIMER_IDX_WIRE) + gremlin.sizes.sizeI32(self.timer_idx);
        }
        return res;
    }
    pub fn encode(self: *const KvmTimerEmulateFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const KvmTimerEmulateFtraceEvent, target: *gremlin.Writer) void {
        if (self.should_fire != 0) {
            target.appendUint32(KvmTimerEmulateFtraceEventWire.SHOULD_FIRE_WIRE, self.should_fire);
        }
        if (self.timer_idx != 0) {
            target.appendInt32(KvmTimerEmulateFtraceEventWire.TIMER_IDX_WIRE, self.timer_idx);
        }
    }
};
pub const KvmTimerEmulateFtraceEventReader = struct {
    buf: gremlin.Reader,
    _should_fire: u32 = 0,
    _timer_idx: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!KvmTimerEmulateFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = KvmTimerEmulateFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                KvmTimerEmulateFtraceEventWire.SHOULD_FIRE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._should_fire = result.value;
                },
                KvmTimerEmulateFtraceEventWire.TIMER_IDX_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._timer_idx = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getShouldFire(self: *const KvmTimerEmulateFtraceEventReader) u32 {
        return self._should_fire;
    }
    pub inline fn getTimerIdx(self: *const KvmTimerEmulateFtraceEventReader) i32 {
        return self._timer_idx;
    }
};
const KvmTimerHrtimerExpireFtraceEventWire = struct {
    const TIMER_IDX_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const KvmTimerHrtimerExpireFtraceEvent = struct {
    // fields
    timer_idx: i32 = 0,
    pub fn calcProtobufSize(self: *const KvmTimerHrtimerExpireFtraceEvent) usize {
        var res: usize = 0;
        if (self.timer_idx != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmTimerHrtimerExpireFtraceEventWire.TIMER_IDX_WIRE) + gremlin.sizes.sizeI32(self.timer_idx);
        }
        return res;
    }
    pub fn encode(self: *const KvmTimerHrtimerExpireFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const KvmTimerHrtimerExpireFtraceEvent, target: *gremlin.Writer) void {
        if (self.timer_idx != 0) {
            target.appendInt32(KvmTimerHrtimerExpireFtraceEventWire.TIMER_IDX_WIRE, self.timer_idx);
        }
    }
};
pub const KvmTimerHrtimerExpireFtraceEventReader = struct {
    buf: gremlin.Reader,
    _timer_idx: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!KvmTimerHrtimerExpireFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = KvmTimerHrtimerExpireFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                KvmTimerHrtimerExpireFtraceEventWire.TIMER_IDX_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._timer_idx = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getTimerIdx(self: *const KvmTimerHrtimerExpireFtraceEventReader) i32 {
        return self._timer_idx;
    }
};
const KvmTimerRestoreStateFtraceEventWire = struct {
    const CTL_WIRE: gremlin.ProtoWireNumber = 1;
    const CVAL_WIRE: gremlin.ProtoWireNumber = 2;
    const TIMER_IDX_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const KvmTimerRestoreStateFtraceEvent = struct {
    // fields
    ctl: u64 = 0,
    cval: u64 = 0,
    timer_idx: i32 = 0,
    pub fn calcProtobufSize(self: *const KvmTimerRestoreStateFtraceEvent) usize {
        var res: usize = 0;
        if (self.ctl != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmTimerRestoreStateFtraceEventWire.CTL_WIRE) + gremlin.sizes.sizeU64(self.ctl);
        }
        if (self.cval != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmTimerRestoreStateFtraceEventWire.CVAL_WIRE) + gremlin.sizes.sizeU64(self.cval);
        }
        if (self.timer_idx != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmTimerRestoreStateFtraceEventWire.TIMER_IDX_WIRE) + gremlin.sizes.sizeI32(self.timer_idx);
        }
        return res;
    }
    pub fn encode(self: *const KvmTimerRestoreStateFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const KvmTimerRestoreStateFtraceEvent, target: *gremlin.Writer) void {
        if (self.ctl != 0) {
            target.appendUint64(KvmTimerRestoreStateFtraceEventWire.CTL_WIRE, self.ctl);
        }
        if (self.cval != 0) {
            target.appendUint64(KvmTimerRestoreStateFtraceEventWire.CVAL_WIRE, self.cval);
        }
        if (self.timer_idx != 0) {
            target.appendInt32(KvmTimerRestoreStateFtraceEventWire.TIMER_IDX_WIRE, self.timer_idx);
        }
    }
};
pub const KvmTimerRestoreStateFtraceEventReader = struct {
    buf: gremlin.Reader,
    _ctl: u64 = 0,
    _cval: u64 = 0,
    _timer_idx: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!KvmTimerRestoreStateFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = KvmTimerRestoreStateFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                KvmTimerRestoreStateFtraceEventWire.CTL_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ctl = result.value;
                },
                KvmTimerRestoreStateFtraceEventWire.CVAL_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._cval = result.value;
                },
                KvmTimerRestoreStateFtraceEventWire.TIMER_IDX_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._timer_idx = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getCtl(self: *const KvmTimerRestoreStateFtraceEventReader) u64 {
        return self._ctl;
    }
    pub inline fn getCval(self: *const KvmTimerRestoreStateFtraceEventReader) u64 {
        return self._cval;
    }
    pub inline fn getTimerIdx(self: *const KvmTimerRestoreStateFtraceEventReader) i32 {
        return self._timer_idx;
    }
};
const KvmTimerSaveStateFtraceEventWire = struct {
    const CTL_WIRE: gremlin.ProtoWireNumber = 1;
    const CVAL_WIRE: gremlin.ProtoWireNumber = 2;
    const TIMER_IDX_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const KvmTimerSaveStateFtraceEvent = struct {
    // fields
    ctl: u64 = 0,
    cval: u64 = 0,
    timer_idx: i32 = 0,
    pub fn calcProtobufSize(self: *const KvmTimerSaveStateFtraceEvent) usize {
        var res: usize = 0;
        if (self.ctl != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmTimerSaveStateFtraceEventWire.CTL_WIRE) + gremlin.sizes.sizeU64(self.ctl);
        }
        if (self.cval != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmTimerSaveStateFtraceEventWire.CVAL_WIRE) + gremlin.sizes.sizeU64(self.cval);
        }
        if (self.timer_idx != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmTimerSaveStateFtraceEventWire.TIMER_IDX_WIRE) + gremlin.sizes.sizeI32(self.timer_idx);
        }
        return res;
    }
    pub fn encode(self: *const KvmTimerSaveStateFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const KvmTimerSaveStateFtraceEvent, target: *gremlin.Writer) void {
        if (self.ctl != 0) {
            target.appendUint64(KvmTimerSaveStateFtraceEventWire.CTL_WIRE, self.ctl);
        }
        if (self.cval != 0) {
            target.appendUint64(KvmTimerSaveStateFtraceEventWire.CVAL_WIRE, self.cval);
        }
        if (self.timer_idx != 0) {
            target.appendInt32(KvmTimerSaveStateFtraceEventWire.TIMER_IDX_WIRE, self.timer_idx);
        }
    }
};
pub const KvmTimerSaveStateFtraceEventReader = struct {
    buf: gremlin.Reader,
    _ctl: u64 = 0,
    _cval: u64 = 0,
    _timer_idx: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!KvmTimerSaveStateFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = KvmTimerSaveStateFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                KvmTimerSaveStateFtraceEventWire.CTL_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ctl = result.value;
                },
                KvmTimerSaveStateFtraceEventWire.CVAL_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._cval = result.value;
                },
                KvmTimerSaveStateFtraceEventWire.TIMER_IDX_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._timer_idx = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getCtl(self: *const KvmTimerSaveStateFtraceEventReader) u64 {
        return self._ctl;
    }
    pub inline fn getCval(self: *const KvmTimerSaveStateFtraceEventReader) u64 {
        return self._cval;
    }
    pub inline fn getTimerIdx(self: *const KvmTimerSaveStateFtraceEventReader) i32 {
        return self._timer_idx;
    }
};
const KvmTimerUpdateIrqFtraceEventWire = struct {
    const IRQ_WIRE: gremlin.ProtoWireNumber = 1;
    const LEVEL_WIRE: gremlin.ProtoWireNumber = 2;
    const VCPU_ID_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const KvmTimerUpdateIrqFtraceEvent = struct {
    // fields
    irq: u32 = 0,
    level: i32 = 0,
    vcpu_id: u64 = 0,
    pub fn calcProtobufSize(self: *const KvmTimerUpdateIrqFtraceEvent) usize {
        var res: usize = 0;
        if (self.irq != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmTimerUpdateIrqFtraceEventWire.IRQ_WIRE) + gremlin.sizes.sizeU32(self.irq);
        }
        if (self.level != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmTimerUpdateIrqFtraceEventWire.LEVEL_WIRE) + gremlin.sizes.sizeI32(self.level);
        }
        if (self.vcpu_id != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmTimerUpdateIrqFtraceEventWire.VCPU_ID_WIRE) + gremlin.sizes.sizeU64(self.vcpu_id);
        }
        return res;
    }
    pub fn encode(self: *const KvmTimerUpdateIrqFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const KvmTimerUpdateIrqFtraceEvent, target: *gremlin.Writer) void {
        if (self.irq != 0) {
            target.appendUint32(KvmTimerUpdateIrqFtraceEventWire.IRQ_WIRE, self.irq);
        }
        if (self.level != 0) {
            target.appendInt32(KvmTimerUpdateIrqFtraceEventWire.LEVEL_WIRE, self.level);
        }
        if (self.vcpu_id != 0) {
            target.appendUint64(KvmTimerUpdateIrqFtraceEventWire.VCPU_ID_WIRE, self.vcpu_id);
        }
    }
};
pub const KvmTimerUpdateIrqFtraceEventReader = struct {
    buf: gremlin.Reader,
    _irq: u32 = 0,
    _level: i32 = 0,
    _vcpu_id: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!KvmTimerUpdateIrqFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = KvmTimerUpdateIrqFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                KvmTimerUpdateIrqFtraceEventWire.IRQ_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._irq = result.value;
                },
                KvmTimerUpdateIrqFtraceEventWire.LEVEL_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._level = result.value;
                },
                KvmTimerUpdateIrqFtraceEventWire.VCPU_ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._vcpu_id = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getIrq(self: *const KvmTimerUpdateIrqFtraceEventReader) u32 {
        return self._irq;
    }
    pub inline fn getLevel(self: *const KvmTimerUpdateIrqFtraceEventReader) i32 {
        return self._level;
    }
    pub inline fn getVcpuId(self: *const KvmTimerUpdateIrqFtraceEventReader) u64 {
        return self._vcpu_id;
    }
};
const KvmToggleCacheFtraceEventWire = struct {
    const NOW_WIRE: gremlin.ProtoWireNumber = 1;
    const VCPU_PC_WIRE: gremlin.ProtoWireNumber = 2;
    const WAS_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const KvmToggleCacheFtraceEvent = struct {
    // fields
    now: u32 = 0,
    vcpu_pc: u64 = 0,
    was: u32 = 0,
    pub fn calcProtobufSize(self: *const KvmToggleCacheFtraceEvent) usize {
        var res: usize = 0;
        if (self.now != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmToggleCacheFtraceEventWire.NOW_WIRE) + gremlin.sizes.sizeU32(self.now);
        }
        if (self.vcpu_pc != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmToggleCacheFtraceEventWire.VCPU_PC_WIRE) + gremlin.sizes.sizeU64(self.vcpu_pc);
        }
        if (self.was != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmToggleCacheFtraceEventWire.WAS_WIRE) + gremlin.sizes.sizeU32(self.was);
        }
        return res;
    }
    pub fn encode(self: *const KvmToggleCacheFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const KvmToggleCacheFtraceEvent, target: *gremlin.Writer) void {
        if (self.now != 0) {
            target.appendUint32(KvmToggleCacheFtraceEventWire.NOW_WIRE, self.now);
        }
        if (self.vcpu_pc != 0) {
            target.appendUint64(KvmToggleCacheFtraceEventWire.VCPU_PC_WIRE, self.vcpu_pc);
        }
        if (self.was != 0) {
            target.appendUint32(KvmToggleCacheFtraceEventWire.WAS_WIRE, self.was);
        }
    }
};
pub const KvmToggleCacheFtraceEventReader = struct {
    buf: gremlin.Reader,
    _now: u32 = 0,
    _vcpu_pc: u64 = 0,
    _was: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!KvmToggleCacheFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = KvmToggleCacheFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                KvmToggleCacheFtraceEventWire.NOW_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._now = result.value;
                },
                KvmToggleCacheFtraceEventWire.VCPU_PC_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._vcpu_pc = result.value;
                },
                KvmToggleCacheFtraceEventWire.WAS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._was = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getNow(self: *const KvmToggleCacheFtraceEventReader) u32 {
        return self._now;
    }
    pub inline fn getVcpuPc(self: *const KvmToggleCacheFtraceEventReader) u64 {
        return self._vcpu_pc;
    }
    pub inline fn getWas(self: *const KvmToggleCacheFtraceEventReader) u32 {
        return self._was;
    }
};
const KvmUnmapHvaRangeFtraceEventWire = struct {
    const END_WIRE: gremlin.ProtoWireNumber = 1;
    const START_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const KvmUnmapHvaRangeFtraceEvent = struct {
    // fields
    end: u64 = 0,
    start: u64 = 0,
    pub fn calcProtobufSize(self: *const KvmUnmapHvaRangeFtraceEvent) usize {
        var res: usize = 0;
        if (self.end != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmUnmapHvaRangeFtraceEventWire.END_WIRE) + gremlin.sizes.sizeU64(self.end);
        }
        if (self.start != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmUnmapHvaRangeFtraceEventWire.START_WIRE) + gremlin.sizes.sizeU64(self.start);
        }
        return res;
    }
    pub fn encode(self: *const KvmUnmapHvaRangeFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const KvmUnmapHvaRangeFtraceEvent, target: *gremlin.Writer) void {
        if (self.end != 0) {
            target.appendUint64(KvmUnmapHvaRangeFtraceEventWire.END_WIRE, self.end);
        }
        if (self.start != 0) {
            target.appendUint64(KvmUnmapHvaRangeFtraceEventWire.START_WIRE, self.start);
        }
    }
};
pub const KvmUnmapHvaRangeFtraceEventReader = struct {
    buf: gremlin.Reader,
    _end: u64 = 0,
    _start: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!KvmUnmapHvaRangeFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = KvmUnmapHvaRangeFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                KvmUnmapHvaRangeFtraceEventWire.END_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._end = result.value;
                },
                KvmUnmapHvaRangeFtraceEventWire.START_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._start = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getEnd(self: *const KvmUnmapHvaRangeFtraceEventReader) u64 {
        return self._end;
    }
    pub inline fn getStart(self: *const KvmUnmapHvaRangeFtraceEventReader) u64 {
        return self._start;
    }
};
const KvmUserspaceExitFtraceEventWire = struct {
    const REASON_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const KvmUserspaceExitFtraceEvent = struct {
    // fields
    reason: u32 = 0,
    pub fn calcProtobufSize(self: *const KvmUserspaceExitFtraceEvent) usize {
        var res: usize = 0;
        if (self.reason != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmUserspaceExitFtraceEventWire.REASON_WIRE) + gremlin.sizes.sizeU32(self.reason);
        }
        return res;
    }
    pub fn encode(self: *const KvmUserspaceExitFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const KvmUserspaceExitFtraceEvent, target: *gremlin.Writer) void {
        if (self.reason != 0) {
            target.appendUint32(KvmUserspaceExitFtraceEventWire.REASON_WIRE, self.reason);
        }
    }
};
pub const KvmUserspaceExitFtraceEventReader = struct {
    buf: gremlin.Reader,
    _reason: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!KvmUserspaceExitFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = KvmUserspaceExitFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                KvmUserspaceExitFtraceEventWire.REASON_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._reason = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getReason(self: *const KvmUserspaceExitFtraceEventReader) u32 {
        return self._reason;
    }
};
const KvmVcpuWakeupFtraceEventWire = struct {
    const NS_WIRE: gremlin.ProtoWireNumber = 1;
    const VALID_WIRE: gremlin.ProtoWireNumber = 2;
    const WAITED_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const KvmVcpuWakeupFtraceEvent = struct {
    // fields
    ns: u64 = 0,
    valid: u32 = 0,
    waited: u32 = 0,
    pub fn calcProtobufSize(self: *const KvmVcpuWakeupFtraceEvent) usize {
        var res: usize = 0;
        if (self.ns != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmVcpuWakeupFtraceEventWire.NS_WIRE) + gremlin.sizes.sizeU64(self.ns);
        }
        if (self.valid != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmVcpuWakeupFtraceEventWire.VALID_WIRE) + gremlin.sizes.sizeU32(self.valid);
        }
        if (self.waited != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmVcpuWakeupFtraceEventWire.WAITED_WIRE) + gremlin.sizes.sizeU32(self.waited);
        }
        return res;
    }
    pub fn encode(self: *const KvmVcpuWakeupFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const KvmVcpuWakeupFtraceEvent, target: *gremlin.Writer) void {
        if (self.ns != 0) {
            target.appendUint64(KvmVcpuWakeupFtraceEventWire.NS_WIRE, self.ns);
        }
        if (self.valid != 0) {
            target.appendUint32(KvmVcpuWakeupFtraceEventWire.VALID_WIRE, self.valid);
        }
        if (self.waited != 0) {
            target.appendUint32(KvmVcpuWakeupFtraceEventWire.WAITED_WIRE, self.waited);
        }
    }
};
pub const KvmVcpuWakeupFtraceEventReader = struct {
    buf: gremlin.Reader,
    _ns: u64 = 0,
    _valid: u32 = 0,
    _waited: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!KvmVcpuWakeupFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = KvmVcpuWakeupFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                KvmVcpuWakeupFtraceEventWire.NS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ns = result.value;
                },
                KvmVcpuWakeupFtraceEventWire.VALID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._valid = result.value;
                },
                KvmVcpuWakeupFtraceEventWire.WAITED_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._waited = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getNs(self: *const KvmVcpuWakeupFtraceEventReader) u64 {
        return self._ns;
    }
    pub inline fn getValid(self: *const KvmVcpuWakeupFtraceEventReader) u32 {
        return self._valid;
    }
    pub inline fn getWaited(self: *const KvmVcpuWakeupFtraceEventReader) u32 {
        return self._waited;
    }
};
const KvmWfxArm64FtraceEventWire = struct {
    const IS_WFE_WIRE: gremlin.ProtoWireNumber = 1;
    const VCPU_PC_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const KvmWfxArm64FtraceEvent = struct {
    // fields
    is_wfe: u32 = 0,
    vcpu_pc: u64 = 0,
    pub fn calcProtobufSize(self: *const KvmWfxArm64FtraceEvent) usize {
        var res: usize = 0;
        if (self.is_wfe != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmWfxArm64FtraceEventWire.IS_WFE_WIRE) + gremlin.sizes.sizeU32(self.is_wfe);
        }
        if (self.vcpu_pc != 0) {
            res += gremlin.sizes.sizeWireNumber(KvmWfxArm64FtraceEventWire.VCPU_PC_WIRE) + gremlin.sizes.sizeU64(self.vcpu_pc);
        }
        return res;
    }
    pub fn encode(self: *const KvmWfxArm64FtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const KvmWfxArm64FtraceEvent, target: *gremlin.Writer) void {
        if (self.is_wfe != 0) {
            target.appendUint32(KvmWfxArm64FtraceEventWire.IS_WFE_WIRE, self.is_wfe);
        }
        if (self.vcpu_pc != 0) {
            target.appendUint64(KvmWfxArm64FtraceEventWire.VCPU_PC_WIRE, self.vcpu_pc);
        }
    }
};
pub const KvmWfxArm64FtraceEventReader = struct {
    buf: gremlin.Reader,
    _is_wfe: u32 = 0,
    _vcpu_pc: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!KvmWfxArm64FtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = KvmWfxArm64FtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                KvmWfxArm64FtraceEventWire.IS_WFE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._is_wfe = result.value;
                },
                KvmWfxArm64FtraceEventWire.VCPU_PC_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._vcpu_pc = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getIsWfe(self: *const KvmWfxArm64FtraceEventReader) u32 {
        return self._is_wfe;
    }
    pub inline fn getVcpuPc(self: *const KvmWfxArm64FtraceEventReader) u64 {
        return self._vcpu_pc;
    }
};
const TrapRegFtraceEventWire = struct {
    const FN_WIRE: gremlin.ProtoWireNumber = 1;
    const IS_WRITE_WIRE: gremlin.ProtoWireNumber = 2;
    const REG_WIRE: gremlin.ProtoWireNumber = 3;
    const WRITE_VALUE_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const TrapRegFtraceEvent = struct {
    // fields
    fn_: ?[]const u8 = null,
    is_write: u32 = 0,
    reg: i32 = 0,
    write_value: u64 = 0,
    pub fn calcProtobufSize(self: *const TrapRegFtraceEvent) usize {
        var res: usize = 0;
        if (self.fn_) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TrapRegFtraceEventWire.FN_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.is_write != 0) {
            res += gremlin.sizes.sizeWireNumber(TrapRegFtraceEventWire.IS_WRITE_WIRE) + gremlin.sizes.sizeU32(self.is_write);
        }
        if (self.reg != 0) {
            res += gremlin.sizes.sizeWireNumber(TrapRegFtraceEventWire.REG_WIRE) + gremlin.sizes.sizeI32(self.reg);
        }
        if (self.write_value != 0) {
            res += gremlin.sizes.sizeWireNumber(TrapRegFtraceEventWire.WRITE_VALUE_WIRE) + gremlin.sizes.sizeU64(self.write_value);
        }
        return res;
    }
    pub fn encode(self: *const TrapRegFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TrapRegFtraceEvent, target: *gremlin.Writer) void {
        if (self.fn_) |v| {
            if (v.len > 0) {
                target.appendBytes(TrapRegFtraceEventWire.FN_WIRE, v);
            }
        }
        if (self.is_write != 0) {
            target.appendUint32(TrapRegFtraceEventWire.IS_WRITE_WIRE, self.is_write);
        }
        if (self.reg != 0) {
            target.appendInt32(TrapRegFtraceEventWire.REG_WIRE, self.reg);
        }
        if (self.write_value != 0) {
            target.appendUint64(TrapRegFtraceEventWire.WRITE_VALUE_WIRE, self.write_value);
        }
    }
};
pub const TrapRegFtraceEventReader = struct {
    buf: gremlin.Reader,
    _fn_: ?[]const u8 = null,
    _is_write: u32 = 0,
    _reg: i32 = 0,
    _write_value: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!TrapRegFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = TrapRegFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TrapRegFtraceEventWire.FN_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._fn_ = result.value;
                },
                TrapRegFtraceEventWire.IS_WRITE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._is_write = result.value;
                },
                TrapRegFtraceEventWire.REG_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._reg = result.value;
                },
                TrapRegFtraceEventWire.WRITE_VALUE_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._write_value = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getFn(self: *const TrapRegFtraceEventReader) []const u8 {
        return self._fn_ orelse &[_]u8{};
    }
    pub inline fn getIsWrite(self: *const TrapRegFtraceEventReader) u32 {
        return self._is_write;
    }
    pub inline fn getReg(self: *const TrapRegFtraceEventReader) i32 {
        return self._reg;
    }
    pub inline fn getWriteValue(self: *const TrapRegFtraceEventReader) u64 {
        return self._write_value;
    }
};
const VgicUpdateIrqPendingFtraceEventWire = struct {
    const IRQ_WIRE: gremlin.ProtoWireNumber = 1;
    const LEVEL_WIRE: gremlin.ProtoWireNumber = 2;
    const VCPU_ID_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const VgicUpdateIrqPendingFtraceEvent = struct {
    // fields
    irq: u32 = 0,
    level: u32 = 0,
    vcpu_id: u64 = 0,
    pub fn calcProtobufSize(self: *const VgicUpdateIrqPendingFtraceEvent) usize {
        var res: usize = 0;
        if (self.irq != 0) {
            res += gremlin.sizes.sizeWireNumber(VgicUpdateIrqPendingFtraceEventWire.IRQ_WIRE) + gremlin.sizes.sizeU32(self.irq);
        }
        if (self.level != 0) {
            res += gremlin.sizes.sizeWireNumber(VgicUpdateIrqPendingFtraceEventWire.LEVEL_WIRE) + gremlin.sizes.sizeU32(self.level);
        }
        if (self.vcpu_id != 0) {
            res += gremlin.sizes.sizeWireNumber(VgicUpdateIrqPendingFtraceEventWire.VCPU_ID_WIRE) + gremlin.sizes.sizeU64(self.vcpu_id);
        }
        return res;
    }
    pub fn encode(self: *const VgicUpdateIrqPendingFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const VgicUpdateIrqPendingFtraceEvent, target: *gremlin.Writer) void {
        if (self.irq != 0) {
            target.appendUint32(VgicUpdateIrqPendingFtraceEventWire.IRQ_WIRE, self.irq);
        }
        if (self.level != 0) {
            target.appendUint32(VgicUpdateIrqPendingFtraceEventWire.LEVEL_WIRE, self.level);
        }
        if (self.vcpu_id != 0) {
            target.appendUint64(VgicUpdateIrqPendingFtraceEventWire.VCPU_ID_WIRE, self.vcpu_id);
        }
    }
};
pub const VgicUpdateIrqPendingFtraceEventReader = struct {
    buf: gremlin.Reader,
    _irq: u32 = 0,
    _level: u32 = 0,
    _vcpu_id: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!VgicUpdateIrqPendingFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = VgicUpdateIrqPendingFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                VgicUpdateIrqPendingFtraceEventWire.IRQ_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._irq = result.value;
                },
                VgicUpdateIrqPendingFtraceEventWire.LEVEL_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._level = result.value;
                },
                VgicUpdateIrqPendingFtraceEventWire.VCPU_ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._vcpu_id = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getIrq(self: *const VgicUpdateIrqPendingFtraceEventReader) u32 {
        return self._irq;
    }
    pub inline fn getLevel(self: *const VgicUpdateIrqPendingFtraceEventReader) u32 {
        return self._level;
    }
    pub inline fn getVcpuId(self: *const VgicUpdateIrqPendingFtraceEventReader) u64 {
        return self._vcpu_id;
    }
};
