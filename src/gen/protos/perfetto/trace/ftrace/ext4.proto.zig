// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const Ext4DaWriteBeginFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const POS_WIRE: gremlin.ProtoWireNumber = 3;
    const LEN_WIRE: gremlin.ProtoWireNumber = 4;
    const FLAGS_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const Ext4DaWriteBeginFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    pos: i64 = 0,
    len: u32 = 0,
    flags: u32 = 0,
    pub fn calcProtobufSize(self: *const Ext4DaWriteBeginFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaWriteBeginFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaWriteBeginFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.pos != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaWriteBeginFtraceEventWire.POS_WIRE) + gremlin.sizes.sizeI64(self.pos);
        }
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaWriteBeginFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeU32(self.len);
        }
        if (self.flags != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaWriteBeginFtraceEventWire.FLAGS_WIRE) + gremlin.sizes.sizeU32(self.flags);
        }
        return res;
    }
    pub fn encode(self: *const Ext4DaWriteBeginFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4DaWriteBeginFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4DaWriteBeginFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4DaWriteBeginFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.pos != 0) {
            target.appendInt64(Ext4DaWriteBeginFtraceEventWire.POS_WIRE, self.pos);
        }
        if (self.len != 0) {
            target.appendUint32(Ext4DaWriteBeginFtraceEventWire.LEN_WIRE, self.len);
        }
        if (self.flags != 0) {
            target.appendUint32(Ext4DaWriteBeginFtraceEventWire.FLAGS_WIRE, self.flags);
        }
    }
};
pub const Ext4DaWriteBeginFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _pos: i64 = 0,
    _len: u32 = 0,
    _flags: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4DaWriteBeginFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4DaWriteBeginFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4DaWriteBeginFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4DaWriteBeginFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4DaWriteBeginFtraceEventWire.POS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._pos = result.value;
                },
                Ext4DaWriteBeginFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                Ext4DaWriteBeginFtraceEventWire.FLAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._flags = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4DaWriteBeginFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4DaWriteBeginFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getPos(self: *const Ext4DaWriteBeginFtraceEventReader) i64 {
        return self._pos;
    }
    pub inline fn getLen(self: *const Ext4DaWriteBeginFtraceEventReader) u32 {
        return self._len;
    }
    pub inline fn getFlags(self: *const Ext4DaWriteBeginFtraceEventReader) u32 {
        return self._flags;
    }
};
const Ext4DaWriteEndFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const POS_WIRE: gremlin.ProtoWireNumber = 3;
    const LEN_WIRE: gremlin.ProtoWireNumber = 4;
    const COPIED_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const Ext4DaWriteEndFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    pos: i64 = 0,
    len: u32 = 0,
    copied: u32 = 0,
    pub fn calcProtobufSize(self: *const Ext4DaWriteEndFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaWriteEndFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaWriteEndFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.pos != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaWriteEndFtraceEventWire.POS_WIRE) + gremlin.sizes.sizeI64(self.pos);
        }
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaWriteEndFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeU32(self.len);
        }
        if (self.copied != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaWriteEndFtraceEventWire.COPIED_WIRE) + gremlin.sizes.sizeU32(self.copied);
        }
        return res;
    }
    pub fn encode(self: *const Ext4DaWriteEndFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4DaWriteEndFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4DaWriteEndFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4DaWriteEndFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.pos != 0) {
            target.appendInt64(Ext4DaWriteEndFtraceEventWire.POS_WIRE, self.pos);
        }
        if (self.len != 0) {
            target.appendUint32(Ext4DaWriteEndFtraceEventWire.LEN_WIRE, self.len);
        }
        if (self.copied != 0) {
            target.appendUint32(Ext4DaWriteEndFtraceEventWire.COPIED_WIRE, self.copied);
        }
    }
};
pub const Ext4DaWriteEndFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _pos: i64 = 0,
    _len: u32 = 0,
    _copied: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4DaWriteEndFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4DaWriteEndFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4DaWriteEndFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4DaWriteEndFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4DaWriteEndFtraceEventWire.POS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._pos = result.value;
                },
                Ext4DaWriteEndFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                Ext4DaWriteEndFtraceEventWire.COPIED_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._copied = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4DaWriteEndFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4DaWriteEndFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getPos(self: *const Ext4DaWriteEndFtraceEventReader) i64 {
        return self._pos;
    }
    pub inline fn getLen(self: *const Ext4DaWriteEndFtraceEventReader) u32 {
        return self._len;
    }
    pub inline fn getCopied(self: *const Ext4DaWriteEndFtraceEventReader) u32 {
        return self._copied;
    }
};
const Ext4SyncFileEnterFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const PARENT_WIRE: gremlin.ProtoWireNumber = 3;
    const DATASYNC_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const Ext4SyncFileEnterFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    parent: u64 = 0,
    datasync: i32 = 0,
    pub fn calcProtobufSize(self: *const Ext4SyncFileEnterFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4SyncFileEnterFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4SyncFileEnterFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.parent != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4SyncFileEnterFtraceEventWire.PARENT_WIRE) + gremlin.sizes.sizeU64(self.parent);
        }
        if (self.datasync != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4SyncFileEnterFtraceEventWire.DATASYNC_WIRE) + gremlin.sizes.sizeI32(self.datasync);
        }
        return res;
    }
    pub fn encode(self: *const Ext4SyncFileEnterFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4SyncFileEnterFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4SyncFileEnterFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4SyncFileEnterFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.parent != 0) {
            target.appendUint64(Ext4SyncFileEnterFtraceEventWire.PARENT_WIRE, self.parent);
        }
        if (self.datasync != 0) {
            target.appendInt32(Ext4SyncFileEnterFtraceEventWire.DATASYNC_WIRE, self.datasync);
        }
    }
};
pub const Ext4SyncFileEnterFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _parent: u64 = 0,
    _datasync: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4SyncFileEnterFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4SyncFileEnterFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4SyncFileEnterFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4SyncFileEnterFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4SyncFileEnterFtraceEventWire.PARENT_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._parent = result.value;
                },
                Ext4SyncFileEnterFtraceEventWire.DATASYNC_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._datasync = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4SyncFileEnterFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4SyncFileEnterFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getParent(self: *const Ext4SyncFileEnterFtraceEventReader) u64 {
        return self._parent;
    }
    pub inline fn getDatasync(self: *const Ext4SyncFileEnterFtraceEventReader) i32 {
        return self._datasync;
    }
};
const Ext4SyncFileExitFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const RET_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const Ext4SyncFileExitFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    ret: i32 = 0,
    pub fn calcProtobufSize(self: *const Ext4SyncFileExitFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4SyncFileExitFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4SyncFileExitFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.ret != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4SyncFileExitFtraceEventWire.RET_WIRE) + gremlin.sizes.sizeI32(self.ret);
        }
        return res;
    }
    pub fn encode(self: *const Ext4SyncFileExitFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4SyncFileExitFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4SyncFileExitFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4SyncFileExitFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.ret != 0) {
            target.appendInt32(Ext4SyncFileExitFtraceEventWire.RET_WIRE, self.ret);
        }
    }
};
pub const Ext4SyncFileExitFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _ret: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4SyncFileExitFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4SyncFileExitFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4SyncFileExitFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4SyncFileExitFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4SyncFileExitFtraceEventWire.RET_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._ret = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4SyncFileExitFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4SyncFileExitFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getRet(self: *const Ext4SyncFileExitFtraceEventReader) i32 {
        return self._ret;
    }
};
const Ext4AllocDaBlocksFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const DATA_BLOCKS_WIRE: gremlin.ProtoWireNumber = 3;
    const META_BLOCKS_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const Ext4AllocDaBlocksFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    data_blocks: u32 = 0,
    meta_blocks: u32 = 0,
    pub fn calcProtobufSize(self: *const Ext4AllocDaBlocksFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4AllocDaBlocksFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4AllocDaBlocksFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.data_blocks != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4AllocDaBlocksFtraceEventWire.DATA_BLOCKS_WIRE) + gremlin.sizes.sizeU32(self.data_blocks);
        }
        if (self.meta_blocks != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4AllocDaBlocksFtraceEventWire.META_BLOCKS_WIRE) + gremlin.sizes.sizeU32(self.meta_blocks);
        }
        return res;
    }
    pub fn encode(self: *const Ext4AllocDaBlocksFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4AllocDaBlocksFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4AllocDaBlocksFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4AllocDaBlocksFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.data_blocks != 0) {
            target.appendUint32(Ext4AllocDaBlocksFtraceEventWire.DATA_BLOCKS_WIRE, self.data_blocks);
        }
        if (self.meta_blocks != 0) {
            target.appendUint32(Ext4AllocDaBlocksFtraceEventWire.META_BLOCKS_WIRE, self.meta_blocks);
        }
    }
};
pub const Ext4AllocDaBlocksFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _data_blocks: u32 = 0,
    _meta_blocks: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4AllocDaBlocksFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4AllocDaBlocksFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4AllocDaBlocksFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4AllocDaBlocksFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4AllocDaBlocksFtraceEventWire.DATA_BLOCKS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._data_blocks = result.value;
                },
                Ext4AllocDaBlocksFtraceEventWire.META_BLOCKS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._meta_blocks = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4AllocDaBlocksFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4AllocDaBlocksFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getDataBlocks(self: *const Ext4AllocDaBlocksFtraceEventReader) u32 {
        return self._data_blocks;
    }
    pub inline fn getMetaBlocks(self: *const Ext4AllocDaBlocksFtraceEventReader) u32 {
        return self._meta_blocks;
    }
};
const Ext4AllocateBlocksFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const BLOCK_WIRE: gremlin.ProtoWireNumber = 3;
    const LEN_WIRE: gremlin.ProtoWireNumber = 4;
    const LOGICAL_WIRE: gremlin.ProtoWireNumber = 5;
    const LLEFT_WIRE: gremlin.ProtoWireNumber = 6;
    const LRIGHT_WIRE: gremlin.ProtoWireNumber = 7;
    const GOAL_WIRE: gremlin.ProtoWireNumber = 8;
    const PLEFT_WIRE: gremlin.ProtoWireNumber = 9;
    const PRIGHT_WIRE: gremlin.ProtoWireNumber = 10;
    const FLAGS_WIRE: gremlin.ProtoWireNumber = 11;
};
pub const Ext4AllocateBlocksFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    block: u64 = 0,
    len: u32 = 0,
    logical: u32 = 0,
    lleft: u32 = 0,
    lright: u32 = 0,
    goal: u64 = 0,
    pleft: u64 = 0,
    pright: u64 = 0,
    flags: u32 = 0,
    pub fn calcProtobufSize(self: *const Ext4AllocateBlocksFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4AllocateBlocksFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4AllocateBlocksFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.block != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4AllocateBlocksFtraceEventWire.BLOCK_WIRE) + gremlin.sizes.sizeU64(self.block);
        }
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4AllocateBlocksFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeU32(self.len);
        }
        if (self.logical != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4AllocateBlocksFtraceEventWire.LOGICAL_WIRE) + gremlin.sizes.sizeU32(self.logical);
        }
        if (self.lleft != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4AllocateBlocksFtraceEventWire.LLEFT_WIRE) + gremlin.sizes.sizeU32(self.lleft);
        }
        if (self.lright != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4AllocateBlocksFtraceEventWire.LRIGHT_WIRE) + gremlin.sizes.sizeU32(self.lright);
        }
        if (self.goal != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4AllocateBlocksFtraceEventWire.GOAL_WIRE) + gremlin.sizes.sizeU64(self.goal);
        }
        if (self.pleft != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4AllocateBlocksFtraceEventWire.PLEFT_WIRE) + gremlin.sizes.sizeU64(self.pleft);
        }
        if (self.pright != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4AllocateBlocksFtraceEventWire.PRIGHT_WIRE) + gremlin.sizes.sizeU64(self.pright);
        }
        if (self.flags != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4AllocateBlocksFtraceEventWire.FLAGS_WIRE) + gremlin.sizes.sizeU32(self.flags);
        }
        return res;
    }
    pub fn encode(self: *const Ext4AllocateBlocksFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4AllocateBlocksFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4AllocateBlocksFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4AllocateBlocksFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.block != 0) {
            target.appendUint64(Ext4AllocateBlocksFtraceEventWire.BLOCK_WIRE, self.block);
        }
        if (self.len != 0) {
            target.appendUint32(Ext4AllocateBlocksFtraceEventWire.LEN_WIRE, self.len);
        }
        if (self.logical != 0) {
            target.appendUint32(Ext4AllocateBlocksFtraceEventWire.LOGICAL_WIRE, self.logical);
        }
        if (self.lleft != 0) {
            target.appendUint32(Ext4AllocateBlocksFtraceEventWire.LLEFT_WIRE, self.lleft);
        }
        if (self.lright != 0) {
            target.appendUint32(Ext4AllocateBlocksFtraceEventWire.LRIGHT_WIRE, self.lright);
        }
        if (self.goal != 0) {
            target.appendUint64(Ext4AllocateBlocksFtraceEventWire.GOAL_WIRE, self.goal);
        }
        if (self.pleft != 0) {
            target.appendUint64(Ext4AllocateBlocksFtraceEventWire.PLEFT_WIRE, self.pleft);
        }
        if (self.pright != 0) {
            target.appendUint64(Ext4AllocateBlocksFtraceEventWire.PRIGHT_WIRE, self.pright);
        }
        if (self.flags != 0) {
            target.appendUint32(Ext4AllocateBlocksFtraceEventWire.FLAGS_WIRE, self.flags);
        }
    }
};
pub const Ext4AllocateBlocksFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _block: u64 = 0,
    _len: u32 = 0,
    _logical: u32 = 0,
    _lleft: u32 = 0,
    _lright: u32 = 0,
    _goal: u64 = 0,
    _pleft: u64 = 0,
    _pright: u64 = 0,
    _flags: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4AllocateBlocksFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4AllocateBlocksFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4AllocateBlocksFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4AllocateBlocksFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4AllocateBlocksFtraceEventWire.BLOCK_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._block = result.value;
                },
                Ext4AllocateBlocksFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                Ext4AllocateBlocksFtraceEventWire.LOGICAL_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._logical = result.value;
                },
                Ext4AllocateBlocksFtraceEventWire.LLEFT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._lleft = result.value;
                },
                Ext4AllocateBlocksFtraceEventWire.LRIGHT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._lright = result.value;
                },
                Ext4AllocateBlocksFtraceEventWire.GOAL_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._goal = result.value;
                },
                Ext4AllocateBlocksFtraceEventWire.PLEFT_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._pleft = result.value;
                },
                Ext4AllocateBlocksFtraceEventWire.PRIGHT_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._pright = result.value;
                },
                Ext4AllocateBlocksFtraceEventWire.FLAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._flags = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4AllocateBlocksFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4AllocateBlocksFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getBlock(self: *const Ext4AllocateBlocksFtraceEventReader) u64 {
        return self._block;
    }
    pub inline fn getLen(self: *const Ext4AllocateBlocksFtraceEventReader) u32 {
        return self._len;
    }
    pub inline fn getLogical(self: *const Ext4AllocateBlocksFtraceEventReader) u32 {
        return self._logical;
    }
    pub inline fn getLleft(self: *const Ext4AllocateBlocksFtraceEventReader) u32 {
        return self._lleft;
    }
    pub inline fn getLright(self: *const Ext4AllocateBlocksFtraceEventReader) u32 {
        return self._lright;
    }
    pub inline fn getGoal(self: *const Ext4AllocateBlocksFtraceEventReader) u64 {
        return self._goal;
    }
    pub inline fn getPleft(self: *const Ext4AllocateBlocksFtraceEventReader) u64 {
        return self._pleft;
    }
    pub inline fn getPright(self: *const Ext4AllocateBlocksFtraceEventReader) u64 {
        return self._pright;
    }
    pub inline fn getFlags(self: *const Ext4AllocateBlocksFtraceEventReader) u32 {
        return self._flags;
    }
};
const Ext4AllocateInodeFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const DIR_WIRE: gremlin.ProtoWireNumber = 3;
    const MODE_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const Ext4AllocateInodeFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    dir: u64 = 0,
    mode: u32 = 0,
    pub fn calcProtobufSize(self: *const Ext4AllocateInodeFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4AllocateInodeFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4AllocateInodeFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.dir != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4AllocateInodeFtraceEventWire.DIR_WIRE) + gremlin.sizes.sizeU64(self.dir);
        }
        if (self.mode != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4AllocateInodeFtraceEventWire.MODE_WIRE) + gremlin.sizes.sizeU32(self.mode);
        }
        return res;
    }
    pub fn encode(self: *const Ext4AllocateInodeFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4AllocateInodeFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4AllocateInodeFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4AllocateInodeFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.dir != 0) {
            target.appendUint64(Ext4AllocateInodeFtraceEventWire.DIR_WIRE, self.dir);
        }
        if (self.mode != 0) {
            target.appendUint32(Ext4AllocateInodeFtraceEventWire.MODE_WIRE, self.mode);
        }
    }
};
pub const Ext4AllocateInodeFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _dir: u64 = 0,
    _mode: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4AllocateInodeFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4AllocateInodeFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4AllocateInodeFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4AllocateInodeFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4AllocateInodeFtraceEventWire.DIR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dir = result.value;
                },
                Ext4AllocateInodeFtraceEventWire.MODE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._mode = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4AllocateInodeFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4AllocateInodeFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getDir(self: *const Ext4AllocateInodeFtraceEventReader) u64 {
        return self._dir;
    }
    pub inline fn getMode(self: *const Ext4AllocateInodeFtraceEventReader) u32 {
        return self._mode;
    }
};
const Ext4BeginOrderedTruncateFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const NEW_SIZE_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const Ext4BeginOrderedTruncateFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    new_size: i64 = 0,
    pub fn calcProtobufSize(self: *const Ext4BeginOrderedTruncateFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4BeginOrderedTruncateFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4BeginOrderedTruncateFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.new_size != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4BeginOrderedTruncateFtraceEventWire.NEW_SIZE_WIRE) + gremlin.sizes.sizeI64(self.new_size);
        }
        return res;
    }
    pub fn encode(self: *const Ext4BeginOrderedTruncateFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4BeginOrderedTruncateFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4BeginOrderedTruncateFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4BeginOrderedTruncateFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.new_size != 0) {
            target.appendInt64(Ext4BeginOrderedTruncateFtraceEventWire.NEW_SIZE_WIRE, self.new_size);
        }
    }
};
pub const Ext4BeginOrderedTruncateFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _new_size: i64 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4BeginOrderedTruncateFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4BeginOrderedTruncateFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4BeginOrderedTruncateFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4BeginOrderedTruncateFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4BeginOrderedTruncateFtraceEventWire.NEW_SIZE_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._new_size = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4BeginOrderedTruncateFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4BeginOrderedTruncateFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getNewSize(self: *const Ext4BeginOrderedTruncateFtraceEventReader) i64 {
        return self._new_size;
    }
};
const Ext4CollapseRangeFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const OFFSET_WIRE: gremlin.ProtoWireNumber = 3;
    const LEN_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const Ext4CollapseRangeFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    offset: i64 = 0,
    len: i64 = 0,
    pub fn calcProtobufSize(self: *const Ext4CollapseRangeFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4CollapseRangeFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4CollapseRangeFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.offset != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4CollapseRangeFtraceEventWire.OFFSET_WIRE) + gremlin.sizes.sizeI64(self.offset);
        }
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4CollapseRangeFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeI64(self.len);
        }
        return res;
    }
    pub fn encode(self: *const Ext4CollapseRangeFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4CollapseRangeFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4CollapseRangeFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4CollapseRangeFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.offset != 0) {
            target.appendInt64(Ext4CollapseRangeFtraceEventWire.OFFSET_WIRE, self.offset);
        }
        if (self.len != 0) {
            target.appendInt64(Ext4CollapseRangeFtraceEventWire.LEN_WIRE, self.len);
        }
    }
};
pub const Ext4CollapseRangeFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _offset: i64 = 0,
    _len: i64 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4CollapseRangeFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4CollapseRangeFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4CollapseRangeFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4CollapseRangeFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4CollapseRangeFtraceEventWire.OFFSET_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._offset = result.value;
                },
                Ext4CollapseRangeFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4CollapseRangeFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4CollapseRangeFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getOffset(self: *const Ext4CollapseRangeFtraceEventReader) i64 {
        return self._offset;
    }
    pub inline fn getLen(self: *const Ext4CollapseRangeFtraceEventReader) i64 {
        return self._len;
    }
};
const Ext4DaReleaseSpaceFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const I_BLOCKS_WIRE: gremlin.ProtoWireNumber = 3;
    const FREED_BLOCKS_WIRE: gremlin.ProtoWireNumber = 4;
    const RESERVED_DATA_BLOCKS_WIRE: gremlin.ProtoWireNumber = 5;
    const RESERVED_META_BLOCKS_WIRE: gremlin.ProtoWireNumber = 6;
    const ALLOCATED_META_BLOCKS_WIRE: gremlin.ProtoWireNumber = 7;
    const MODE_WIRE: gremlin.ProtoWireNumber = 8;
};
pub const Ext4DaReleaseSpaceFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    i_blocks: u64 = 0,
    freed_blocks: i32 = 0,
    reserved_data_blocks: i32 = 0,
    reserved_meta_blocks: i32 = 0,
    allocated_meta_blocks: i32 = 0,
    mode: u32 = 0,
    pub fn calcProtobufSize(self: *const Ext4DaReleaseSpaceFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaReleaseSpaceFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaReleaseSpaceFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.i_blocks != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaReleaseSpaceFtraceEventWire.I_BLOCKS_WIRE) + gremlin.sizes.sizeU64(self.i_blocks);
        }
        if (self.freed_blocks != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaReleaseSpaceFtraceEventWire.FREED_BLOCKS_WIRE) + gremlin.sizes.sizeI32(self.freed_blocks);
        }
        if (self.reserved_data_blocks != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaReleaseSpaceFtraceEventWire.RESERVED_DATA_BLOCKS_WIRE) + gremlin.sizes.sizeI32(self.reserved_data_blocks);
        }
        if (self.reserved_meta_blocks != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaReleaseSpaceFtraceEventWire.RESERVED_META_BLOCKS_WIRE) + gremlin.sizes.sizeI32(self.reserved_meta_blocks);
        }
        if (self.allocated_meta_blocks != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaReleaseSpaceFtraceEventWire.ALLOCATED_META_BLOCKS_WIRE) + gremlin.sizes.sizeI32(self.allocated_meta_blocks);
        }
        if (self.mode != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaReleaseSpaceFtraceEventWire.MODE_WIRE) + gremlin.sizes.sizeU32(self.mode);
        }
        return res;
    }
    pub fn encode(self: *const Ext4DaReleaseSpaceFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4DaReleaseSpaceFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4DaReleaseSpaceFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4DaReleaseSpaceFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.i_blocks != 0) {
            target.appendUint64(Ext4DaReleaseSpaceFtraceEventWire.I_BLOCKS_WIRE, self.i_blocks);
        }
        if (self.freed_blocks != 0) {
            target.appendInt32(Ext4DaReleaseSpaceFtraceEventWire.FREED_BLOCKS_WIRE, self.freed_blocks);
        }
        if (self.reserved_data_blocks != 0) {
            target.appendInt32(Ext4DaReleaseSpaceFtraceEventWire.RESERVED_DATA_BLOCKS_WIRE, self.reserved_data_blocks);
        }
        if (self.reserved_meta_blocks != 0) {
            target.appendInt32(Ext4DaReleaseSpaceFtraceEventWire.RESERVED_META_BLOCKS_WIRE, self.reserved_meta_blocks);
        }
        if (self.allocated_meta_blocks != 0) {
            target.appendInt32(Ext4DaReleaseSpaceFtraceEventWire.ALLOCATED_META_BLOCKS_WIRE, self.allocated_meta_blocks);
        }
        if (self.mode != 0) {
            target.appendUint32(Ext4DaReleaseSpaceFtraceEventWire.MODE_WIRE, self.mode);
        }
    }
};
pub const Ext4DaReleaseSpaceFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _i_blocks: u64 = 0,
    _freed_blocks: i32 = 0,
    _reserved_data_blocks: i32 = 0,
    _reserved_meta_blocks: i32 = 0,
    _allocated_meta_blocks: i32 = 0,
    _mode: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4DaReleaseSpaceFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4DaReleaseSpaceFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4DaReleaseSpaceFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4DaReleaseSpaceFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4DaReleaseSpaceFtraceEventWire.I_BLOCKS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._i_blocks = result.value;
                },
                Ext4DaReleaseSpaceFtraceEventWire.FREED_BLOCKS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._freed_blocks = result.value;
                },
                Ext4DaReleaseSpaceFtraceEventWire.RESERVED_DATA_BLOCKS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._reserved_data_blocks = result.value;
                },
                Ext4DaReleaseSpaceFtraceEventWire.RESERVED_META_BLOCKS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._reserved_meta_blocks = result.value;
                },
                Ext4DaReleaseSpaceFtraceEventWire.ALLOCATED_META_BLOCKS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._allocated_meta_blocks = result.value;
                },
                Ext4DaReleaseSpaceFtraceEventWire.MODE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._mode = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4DaReleaseSpaceFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4DaReleaseSpaceFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getIBlocks(self: *const Ext4DaReleaseSpaceFtraceEventReader) u64 {
        return self._i_blocks;
    }
    pub inline fn getFreedBlocks(self: *const Ext4DaReleaseSpaceFtraceEventReader) i32 {
        return self._freed_blocks;
    }
    pub inline fn getReservedDataBlocks(self: *const Ext4DaReleaseSpaceFtraceEventReader) i32 {
        return self._reserved_data_blocks;
    }
    pub inline fn getReservedMetaBlocks(self: *const Ext4DaReleaseSpaceFtraceEventReader) i32 {
        return self._reserved_meta_blocks;
    }
    pub inline fn getAllocatedMetaBlocks(self: *const Ext4DaReleaseSpaceFtraceEventReader) i32 {
        return self._allocated_meta_blocks;
    }
    pub inline fn getMode(self: *const Ext4DaReleaseSpaceFtraceEventReader) u32 {
        return self._mode;
    }
};
const Ext4DaReserveSpaceFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const I_BLOCKS_WIRE: gremlin.ProtoWireNumber = 3;
    const RESERVED_DATA_BLOCKS_WIRE: gremlin.ProtoWireNumber = 4;
    const RESERVED_META_BLOCKS_WIRE: gremlin.ProtoWireNumber = 5;
    const MODE_WIRE: gremlin.ProtoWireNumber = 6;
    const MD_NEEDED_WIRE: gremlin.ProtoWireNumber = 7;
};
pub const Ext4DaReserveSpaceFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    i_blocks: u64 = 0,
    reserved_data_blocks: i32 = 0,
    reserved_meta_blocks: i32 = 0,
    mode: u32 = 0,
    md_needed: i32 = 0,
    pub fn calcProtobufSize(self: *const Ext4DaReserveSpaceFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaReserveSpaceFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaReserveSpaceFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.i_blocks != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaReserveSpaceFtraceEventWire.I_BLOCKS_WIRE) + gremlin.sizes.sizeU64(self.i_blocks);
        }
        if (self.reserved_data_blocks != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaReserveSpaceFtraceEventWire.RESERVED_DATA_BLOCKS_WIRE) + gremlin.sizes.sizeI32(self.reserved_data_blocks);
        }
        if (self.reserved_meta_blocks != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaReserveSpaceFtraceEventWire.RESERVED_META_BLOCKS_WIRE) + gremlin.sizes.sizeI32(self.reserved_meta_blocks);
        }
        if (self.mode != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaReserveSpaceFtraceEventWire.MODE_WIRE) + gremlin.sizes.sizeU32(self.mode);
        }
        if (self.md_needed != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaReserveSpaceFtraceEventWire.MD_NEEDED_WIRE) + gremlin.sizes.sizeI32(self.md_needed);
        }
        return res;
    }
    pub fn encode(self: *const Ext4DaReserveSpaceFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4DaReserveSpaceFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4DaReserveSpaceFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4DaReserveSpaceFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.i_blocks != 0) {
            target.appendUint64(Ext4DaReserveSpaceFtraceEventWire.I_BLOCKS_WIRE, self.i_blocks);
        }
        if (self.reserved_data_blocks != 0) {
            target.appendInt32(Ext4DaReserveSpaceFtraceEventWire.RESERVED_DATA_BLOCKS_WIRE, self.reserved_data_blocks);
        }
        if (self.reserved_meta_blocks != 0) {
            target.appendInt32(Ext4DaReserveSpaceFtraceEventWire.RESERVED_META_BLOCKS_WIRE, self.reserved_meta_blocks);
        }
        if (self.mode != 0) {
            target.appendUint32(Ext4DaReserveSpaceFtraceEventWire.MODE_WIRE, self.mode);
        }
        if (self.md_needed != 0) {
            target.appendInt32(Ext4DaReserveSpaceFtraceEventWire.MD_NEEDED_WIRE, self.md_needed);
        }
    }
};
pub const Ext4DaReserveSpaceFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _i_blocks: u64 = 0,
    _reserved_data_blocks: i32 = 0,
    _reserved_meta_blocks: i32 = 0,
    _mode: u32 = 0,
    _md_needed: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4DaReserveSpaceFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4DaReserveSpaceFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4DaReserveSpaceFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4DaReserveSpaceFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4DaReserveSpaceFtraceEventWire.I_BLOCKS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._i_blocks = result.value;
                },
                Ext4DaReserveSpaceFtraceEventWire.RESERVED_DATA_BLOCKS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._reserved_data_blocks = result.value;
                },
                Ext4DaReserveSpaceFtraceEventWire.RESERVED_META_BLOCKS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._reserved_meta_blocks = result.value;
                },
                Ext4DaReserveSpaceFtraceEventWire.MODE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._mode = result.value;
                },
                Ext4DaReserveSpaceFtraceEventWire.MD_NEEDED_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._md_needed = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4DaReserveSpaceFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4DaReserveSpaceFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getIBlocks(self: *const Ext4DaReserveSpaceFtraceEventReader) u64 {
        return self._i_blocks;
    }
    pub inline fn getReservedDataBlocks(self: *const Ext4DaReserveSpaceFtraceEventReader) i32 {
        return self._reserved_data_blocks;
    }
    pub inline fn getReservedMetaBlocks(self: *const Ext4DaReserveSpaceFtraceEventReader) i32 {
        return self._reserved_meta_blocks;
    }
    pub inline fn getMode(self: *const Ext4DaReserveSpaceFtraceEventReader) u32 {
        return self._mode;
    }
    pub inline fn getMdNeeded(self: *const Ext4DaReserveSpaceFtraceEventReader) i32 {
        return self._md_needed;
    }
};
const Ext4DaUpdateReserveSpaceFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const I_BLOCKS_WIRE: gremlin.ProtoWireNumber = 3;
    const USED_BLOCKS_WIRE: gremlin.ProtoWireNumber = 4;
    const RESERVED_DATA_BLOCKS_WIRE: gremlin.ProtoWireNumber = 5;
    const RESERVED_META_BLOCKS_WIRE: gremlin.ProtoWireNumber = 6;
    const ALLOCATED_META_BLOCKS_WIRE: gremlin.ProtoWireNumber = 7;
    const QUOTA_CLAIM_WIRE: gremlin.ProtoWireNumber = 8;
    const MODE_WIRE: gremlin.ProtoWireNumber = 9;
};
pub const Ext4DaUpdateReserveSpaceFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    i_blocks: u64 = 0,
    used_blocks: i32 = 0,
    reserved_data_blocks: i32 = 0,
    reserved_meta_blocks: i32 = 0,
    allocated_meta_blocks: i32 = 0,
    quota_claim: i32 = 0,
    mode: u32 = 0,
    pub fn calcProtobufSize(self: *const Ext4DaUpdateReserveSpaceFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaUpdateReserveSpaceFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaUpdateReserveSpaceFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.i_blocks != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaUpdateReserveSpaceFtraceEventWire.I_BLOCKS_WIRE) + gremlin.sizes.sizeU64(self.i_blocks);
        }
        if (self.used_blocks != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaUpdateReserveSpaceFtraceEventWire.USED_BLOCKS_WIRE) + gremlin.sizes.sizeI32(self.used_blocks);
        }
        if (self.reserved_data_blocks != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaUpdateReserveSpaceFtraceEventWire.RESERVED_DATA_BLOCKS_WIRE) + gremlin.sizes.sizeI32(self.reserved_data_blocks);
        }
        if (self.reserved_meta_blocks != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaUpdateReserveSpaceFtraceEventWire.RESERVED_META_BLOCKS_WIRE) + gremlin.sizes.sizeI32(self.reserved_meta_blocks);
        }
        if (self.allocated_meta_blocks != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaUpdateReserveSpaceFtraceEventWire.ALLOCATED_META_BLOCKS_WIRE) + gremlin.sizes.sizeI32(self.allocated_meta_blocks);
        }
        if (self.quota_claim != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaUpdateReserveSpaceFtraceEventWire.QUOTA_CLAIM_WIRE) + gremlin.sizes.sizeI32(self.quota_claim);
        }
        if (self.mode != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaUpdateReserveSpaceFtraceEventWire.MODE_WIRE) + gremlin.sizes.sizeU32(self.mode);
        }
        return res;
    }
    pub fn encode(self: *const Ext4DaUpdateReserveSpaceFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4DaUpdateReserveSpaceFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4DaUpdateReserveSpaceFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4DaUpdateReserveSpaceFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.i_blocks != 0) {
            target.appendUint64(Ext4DaUpdateReserveSpaceFtraceEventWire.I_BLOCKS_WIRE, self.i_blocks);
        }
        if (self.used_blocks != 0) {
            target.appendInt32(Ext4DaUpdateReserveSpaceFtraceEventWire.USED_BLOCKS_WIRE, self.used_blocks);
        }
        if (self.reserved_data_blocks != 0) {
            target.appendInt32(Ext4DaUpdateReserveSpaceFtraceEventWire.RESERVED_DATA_BLOCKS_WIRE, self.reserved_data_blocks);
        }
        if (self.reserved_meta_blocks != 0) {
            target.appendInt32(Ext4DaUpdateReserveSpaceFtraceEventWire.RESERVED_META_BLOCKS_WIRE, self.reserved_meta_blocks);
        }
        if (self.allocated_meta_blocks != 0) {
            target.appendInt32(Ext4DaUpdateReserveSpaceFtraceEventWire.ALLOCATED_META_BLOCKS_WIRE, self.allocated_meta_blocks);
        }
        if (self.quota_claim != 0) {
            target.appendInt32(Ext4DaUpdateReserveSpaceFtraceEventWire.QUOTA_CLAIM_WIRE, self.quota_claim);
        }
        if (self.mode != 0) {
            target.appendUint32(Ext4DaUpdateReserveSpaceFtraceEventWire.MODE_WIRE, self.mode);
        }
    }
};
pub const Ext4DaUpdateReserveSpaceFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _i_blocks: u64 = 0,
    _used_blocks: i32 = 0,
    _reserved_data_blocks: i32 = 0,
    _reserved_meta_blocks: i32 = 0,
    _allocated_meta_blocks: i32 = 0,
    _quota_claim: i32 = 0,
    _mode: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4DaUpdateReserveSpaceFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4DaUpdateReserveSpaceFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4DaUpdateReserveSpaceFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4DaUpdateReserveSpaceFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4DaUpdateReserveSpaceFtraceEventWire.I_BLOCKS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._i_blocks = result.value;
                },
                Ext4DaUpdateReserveSpaceFtraceEventWire.USED_BLOCKS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._used_blocks = result.value;
                },
                Ext4DaUpdateReserveSpaceFtraceEventWire.RESERVED_DATA_BLOCKS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._reserved_data_blocks = result.value;
                },
                Ext4DaUpdateReserveSpaceFtraceEventWire.RESERVED_META_BLOCKS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._reserved_meta_blocks = result.value;
                },
                Ext4DaUpdateReserveSpaceFtraceEventWire.ALLOCATED_META_BLOCKS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._allocated_meta_blocks = result.value;
                },
                Ext4DaUpdateReserveSpaceFtraceEventWire.QUOTA_CLAIM_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._quota_claim = result.value;
                },
                Ext4DaUpdateReserveSpaceFtraceEventWire.MODE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._mode = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4DaUpdateReserveSpaceFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4DaUpdateReserveSpaceFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getIBlocks(self: *const Ext4DaUpdateReserveSpaceFtraceEventReader) u64 {
        return self._i_blocks;
    }
    pub inline fn getUsedBlocks(self: *const Ext4DaUpdateReserveSpaceFtraceEventReader) i32 {
        return self._used_blocks;
    }
    pub inline fn getReservedDataBlocks(self: *const Ext4DaUpdateReserveSpaceFtraceEventReader) i32 {
        return self._reserved_data_blocks;
    }
    pub inline fn getReservedMetaBlocks(self: *const Ext4DaUpdateReserveSpaceFtraceEventReader) i32 {
        return self._reserved_meta_blocks;
    }
    pub inline fn getAllocatedMetaBlocks(self: *const Ext4DaUpdateReserveSpaceFtraceEventReader) i32 {
        return self._allocated_meta_blocks;
    }
    pub inline fn getQuotaClaim(self: *const Ext4DaUpdateReserveSpaceFtraceEventReader) i32 {
        return self._quota_claim;
    }
    pub inline fn getMode(self: *const Ext4DaUpdateReserveSpaceFtraceEventReader) u32 {
        return self._mode;
    }
};
const Ext4DaWritePagesFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const FIRST_PAGE_WIRE: gremlin.ProtoWireNumber = 3;
    const NR_TO_WRITE_WIRE: gremlin.ProtoWireNumber = 4;
    const SYNC_MODE_WIRE: gremlin.ProtoWireNumber = 5;
    const B_BLOCKNR_WIRE: gremlin.ProtoWireNumber = 6;
    const B_SIZE_WIRE: gremlin.ProtoWireNumber = 7;
    const B_STATE_WIRE: gremlin.ProtoWireNumber = 8;
    const IO_DONE_WIRE: gremlin.ProtoWireNumber = 9;
    const PAGES_WRITTEN_WIRE: gremlin.ProtoWireNumber = 10;
};
pub const Ext4DaWritePagesFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    first_page: u64 = 0,
    nr_to_write: i64 = 0,
    sync_mode: i32 = 0,
    b_blocknr: u64 = 0,
    b_size: u32 = 0,
    b_state: u32 = 0,
    io_done: i32 = 0,
    pages_written: i32 = 0,
    pub fn calcProtobufSize(self: *const Ext4DaWritePagesFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaWritePagesFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaWritePagesFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.first_page != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaWritePagesFtraceEventWire.FIRST_PAGE_WIRE) + gremlin.sizes.sizeU64(self.first_page);
        }
        if (self.nr_to_write != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaWritePagesFtraceEventWire.NR_TO_WRITE_WIRE) + gremlin.sizes.sizeI64(self.nr_to_write);
        }
        if (self.sync_mode != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaWritePagesFtraceEventWire.SYNC_MODE_WIRE) + gremlin.sizes.sizeI32(self.sync_mode);
        }
        if (self.b_blocknr != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaWritePagesFtraceEventWire.B_BLOCKNR_WIRE) + gremlin.sizes.sizeU64(self.b_blocknr);
        }
        if (self.b_size != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaWritePagesFtraceEventWire.B_SIZE_WIRE) + gremlin.sizes.sizeU32(self.b_size);
        }
        if (self.b_state != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaWritePagesFtraceEventWire.B_STATE_WIRE) + gremlin.sizes.sizeU32(self.b_state);
        }
        if (self.io_done != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaWritePagesFtraceEventWire.IO_DONE_WIRE) + gremlin.sizes.sizeI32(self.io_done);
        }
        if (self.pages_written != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaWritePagesFtraceEventWire.PAGES_WRITTEN_WIRE) + gremlin.sizes.sizeI32(self.pages_written);
        }
        return res;
    }
    pub fn encode(self: *const Ext4DaWritePagesFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4DaWritePagesFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4DaWritePagesFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4DaWritePagesFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.first_page != 0) {
            target.appendUint64(Ext4DaWritePagesFtraceEventWire.FIRST_PAGE_WIRE, self.first_page);
        }
        if (self.nr_to_write != 0) {
            target.appendInt64(Ext4DaWritePagesFtraceEventWire.NR_TO_WRITE_WIRE, self.nr_to_write);
        }
        if (self.sync_mode != 0) {
            target.appendInt32(Ext4DaWritePagesFtraceEventWire.SYNC_MODE_WIRE, self.sync_mode);
        }
        if (self.b_blocknr != 0) {
            target.appendUint64(Ext4DaWritePagesFtraceEventWire.B_BLOCKNR_WIRE, self.b_blocknr);
        }
        if (self.b_size != 0) {
            target.appendUint32(Ext4DaWritePagesFtraceEventWire.B_SIZE_WIRE, self.b_size);
        }
        if (self.b_state != 0) {
            target.appendUint32(Ext4DaWritePagesFtraceEventWire.B_STATE_WIRE, self.b_state);
        }
        if (self.io_done != 0) {
            target.appendInt32(Ext4DaWritePagesFtraceEventWire.IO_DONE_WIRE, self.io_done);
        }
        if (self.pages_written != 0) {
            target.appendInt32(Ext4DaWritePagesFtraceEventWire.PAGES_WRITTEN_WIRE, self.pages_written);
        }
    }
};
pub const Ext4DaWritePagesFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _first_page: u64 = 0,
    _nr_to_write: i64 = 0,
    _sync_mode: i32 = 0,
    _b_blocknr: u64 = 0,
    _b_size: u32 = 0,
    _b_state: u32 = 0,
    _io_done: i32 = 0,
    _pages_written: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4DaWritePagesFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4DaWritePagesFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4DaWritePagesFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4DaWritePagesFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4DaWritePagesFtraceEventWire.FIRST_PAGE_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._first_page = result.value;
                },
                Ext4DaWritePagesFtraceEventWire.NR_TO_WRITE_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._nr_to_write = result.value;
                },
                Ext4DaWritePagesFtraceEventWire.SYNC_MODE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._sync_mode = result.value;
                },
                Ext4DaWritePagesFtraceEventWire.B_BLOCKNR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._b_blocknr = result.value;
                },
                Ext4DaWritePagesFtraceEventWire.B_SIZE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._b_size = result.value;
                },
                Ext4DaWritePagesFtraceEventWire.B_STATE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._b_state = result.value;
                },
                Ext4DaWritePagesFtraceEventWire.IO_DONE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._io_done = result.value;
                },
                Ext4DaWritePagesFtraceEventWire.PAGES_WRITTEN_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._pages_written = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4DaWritePagesFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4DaWritePagesFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getFirstPage(self: *const Ext4DaWritePagesFtraceEventReader) u64 {
        return self._first_page;
    }
    pub inline fn getNrToWrite(self: *const Ext4DaWritePagesFtraceEventReader) i64 {
        return self._nr_to_write;
    }
    pub inline fn getSyncMode(self: *const Ext4DaWritePagesFtraceEventReader) i32 {
        return self._sync_mode;
    }
    pub inline fn getBBlocknr(self: *const Ext4DaWritePagesFtraceEventReader) u64 {
        return self._b_blocknr;
    }
    pub inline fn getBSize(self: *const Ext4DaWritePagesFtraceEventReader) u32 {
        return self._b_size;
    }
    pub inline fn getBState(self: *const Ext4DaWritePagesFtraceEventReader) u32 {
        return self._b_state;
    }
    pub inline fn getIoDone(self: *const Ext4DaWritePagesFtraceEventReader) i32 {
        return self._io_done;
    }
    pub inline fn getPagesWritten(self: *const Ext4DaWritePagesFtraceEventReader) i32 {
        return self._pages_written;
    }
};
const Ext4DaWritePagesExtentFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const LBLK_WIRE: gremlin.ProtoWireNumber = 3;
    const LEN_WIRE: gremlin.ProtoWireNumber = 4;
    const FLAGS_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const Ext4DaWritePagesExtentFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    lblk: u64 = 0,
    len: u32 = 0,
    flags: u32 = 0,
    pub fn calcProtobufSize(self: *const Ext4DaWritePagesExtentFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaWritePagesExtentFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaWritePagesExtentFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.lblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaWritePagesExtentFtraceEventWire.LBLK_WIRE) + gremlin.sizes.sizeU64(self.lblk);
        }
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaWritePagesExtentFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeU32(self.len);
        }
        if (self.flags != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DaWritePagesExtentFtraceEventWire.FLAGS_WIRE) + gremlin.sizes.sizeU32(self.flags);
        }
        return res;
    }
    pub fn encode(self: *const Ext4DaWritePagesExtentFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4DaWritePagesExtentFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4DaWritePagesExtentFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4DaWritePagesExtentFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.lblk != 0) {
            target.appendUint64(Ext4DaWritePagesExtentFtraceEventWire.LBLK_WIRE, self.lblk);
        }
        if (self.len != 0) {
            target.appendUint32(Ext4DaWritePagesExtentFtraceEventWire.LEN_WIRE, self.len);
        }
        if (self.flags != 0) {
            target.appendUint32(Ext4DaWritePagesExtentFtraceEventWire.FLAGS_WIRE, self.flags);
        }
    }
};
pub const Ext4DaWritePagesExtentFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _lblk: u64 = 0,
    _len: u32 = 0,
    _flags: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4DaWritePagesExtentFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4DaWritePagesExtentFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4DaWritePagesExtentFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4DaWritePagesExtentFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4DaWritePagesExtentFtraceEventWire.LBLK_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._lblk = result.value;
                },
                Ext4DaWritePagesExtentFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                Ext4DaWritePagesExtentFtraceEventWire.FLAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._flags = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4DaWritePagesExtentFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4DaWritePagesExtentFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getLblk(self: *const Ext4DaWritePagesExtentFtraceEventReader) u64 {
        return self._lblk;
    }
    pub inline fn getLen(self: *const Ext4DaWritePagesExtentFtraceEventReader) u32 {
        return self._len;
    }
    pub inline fn getFlags(self: *const Ext4DaWritePagesExtentFtraceEventReader) u32 {
        return self._flags;
    }
};
const Ext4DirectIOEnterFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const POS_WIRE: gremlin.ProtoWireNumber = 3;
    const LEN_WIRE: gremlin.ProtoWireNumber = 4;
    const RW_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const Ext4DirectIOEnterFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    pos: i64 = 0,
    len: u64 = 0,
    rw: i32 = 0,
    pub fn calcProtobufSize(self: *const Ext4DirectIOEnterFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DirectIOEnterFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DirectIOEnterFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.pos != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DirectIOEnterFtraceEventWire.POS_WIRE) + gremlin.sizes.sizeI64(self.pos);
        }
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DirectIOEnterFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeU64(self.len);
        }
        if (self.rw != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DirectIOEnterFtraceEventWire.RW_WIRE) + gremlin.sizes.sizeI32(self.rw);
        }
        return res;
    }
    pub fn encode(self: *const Ext4DirectIOEnterFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4DirectIOEnterFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4DirectIOEnterFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4DirectIOEnterFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.pos != 0) {
            target.appendInt64(Ext4DirectIOEnterFtraceEventWire.POS_WIRE, self.pos);
        }
        if (self.len != 0) {
            target.appendUint64(Ext4DirectIOEnterFtraceEventWire.LEN_WIRE, self.len);
        }
        if (self.rw != 0) {
            target.appendInt32(Ext4DirectIOEnterFtraceEventWire.RW_WIRE, self.rw);
        }
    }
};
pub const Ext4DirectIOEnterFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _pos: i64 = 0,
    _len: u64 = 0,
    _rw: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4DirectIOEnterFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4DirectIOEnterFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4DirectIOEnterFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4DirectIOEnterFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4DirectIOEnterFtraceEventWire.POS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._pos = result.value;
                },
                Ext4DirectIOEnterFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                Ext4DirectIOEnterFtraceEventWire.RW_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._rw = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4DirectIOEnterFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4DirectIOEnterFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getPos(self: *const Ext4DirectIOEnterFtraceEventReader) i64 {
        return self._pos;
    }
    pub inline fn getLen(self: *const Ext4DirectIOEnterFtraceEventReader) u64 {
        return self._len;
    }
    pub inline fn getRw(self: *const Ext4DirectIOEnterFtraceEventReader) i32 {
        return self._rw;
    }
};
const Ext4DirectIOExitFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const POS_WIRE: gremlin.ProtoWireNumber = 3;
    const LEN_WIRE: gremlin.ProtoWireNumber = 4;
    const RW_WIRE: gremlin.ProtoWireNumber = 5;
    const RET_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const Ext4DirectIOExitFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    pos: i64 = 0,
    len: u64 = 0,
    rw: i32 = 0,
    ret: i32 = 0,
    pub fn calcProtobufSize(self: *const Ext4DirectIOExitFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DirectIOExitFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DirectIOExitFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.pos != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DirectIOExitFtraceEventWire.POS_WIRE) + gremlin.sizes.sizeI64(self.pos);
        }
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DirectIOExitFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeU64(self.len);
        }
        if (self.rw != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DirectIOExitFtraceEventWire.RW_WIRE) + gremlin.sizes.sizeI32(self.rw);
        }
        if (self.ret != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DirectIOExitFtraceEventWire.RET_WIRE) + gremlin.sizes.sizeI32(self.ret);
        }
        return res;
    }
    pub fn encode(self: *const Ext4DirectIOExitFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4DirectIOExitFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4DirectIOExitFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4DirectIOExitFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.pos != 0) {
            target.appendInt64(Ext4DirectIOExitFtraceEventWire.POS_WIRE, self.pos);
        }
        if (self.len != 0) {
            target.appendUint64(Ext4DirectIOExitFtraceEventWire.LEN_WIRE, self.len);
        }
        if (self.rw != 0) {
            target.appendInt32(Ext4DirectIOExitFtraceEventWire.RW_WIRE, self.rw);
        }
        if (self.ret != 0) {
            target.appendInt32(Ext4DirectIOExitFtraceEventWire.RET_WIRE, self.ret);
        }
    }
};
pub const Ext4DirectIOExitFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _pos: i64 = 0,
    _len: u64 = 0,
    _rw: i32 = 0,
    _ret: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4DirectIOExitFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4DirectIOExitFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4DirectIOExitFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4DirectIOExitFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4DirectIOExitFtraceEventWire.POS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._pos = result.value;
                },
                Ext4DirectIOExitFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                Ext4DirectIOExitFtraceEventWire.RW_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._rw = result.value;
                },
                Ext4DirectIOExitFtraceEventWire.RET_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._ret = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4DirectIOExitFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4DirectIOExitFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getPos(self: *const Ext4DirectIOExitFtraceEventReader) i64 {
        return self._pos;
    }
    pub inline fn getLen(self: *const Ext4DirectIOExitFtraceEventReader) u64 {
        return self._len;
    }
    pub inline fn getRw(self: *const Ext4DirectIOExitFtraceEventReader) i32 {
        return self._rw;
    }
    pub inline fn getRet(self: *const Ext4DirectIOExitFtraceEventReader) i32 {
        return self._ret;
    }
};
const Ext4DiscardBlocksFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const BLK_WIRE: gremlin.ProtoWireNumber = 2;
    const COUNT_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const Ext4DiscardBlocksFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    blk: u64 = 0,
    count: u64 = 0,
    pub fn calcProtobufSize(self: *const Ext4DiscardBlocksFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DiscardBlocksFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.blk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DiscardBlocksFtraceEventWire.BLK_WIRE) + gremlin.sizes.sizeU64(self.blk);
        }
        if (self.count != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DiscardBlocksFtraceEventWire.COUNT_WIRE) + gremlin.sizes.sizeU64(self.count);
        }
        return res;
    }
    pub fn encode(self: *const Ext4DiscardBlocksFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4DiscardBlocksFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4DiscardBlocksFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.blk != 0) {
            target.appendUint64(Ext4DiscardBlocksFtraceEventWire.BLK_WIRE, self.blk);
        }
        if (self.count != 0) {
            target.appendUint64(Ext4DiscardBlocksFtraceEventWire.COUNT_WIRE, self.count);
        }
    }
};
pub const Ext4DiscardBlocksFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _blk: u64 = 0,
    _count: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4DiscardBlocksFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4DiscardBlocksFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4DiscardBlocksFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4DiscardBlocksFtraceEventWire.BLK_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._blk = result.value;
                },
                Ext4DiscardBlocksFtraceEventWire.COUNT_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._count = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4DiscardBlocksFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getBlk(self: *const Ext4DiscardBlocksFtraceEventReader) u64 {
        return self._blk;
    }
    pub inline fn getCount(self: *const Ext4DiscardBlocksFtraceEventReader) u64 {
        return self._count;
    }
};
const Ext4DiscardPreallocationsFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const LEN_WIRE: gremlin.ProtoWireNumber = 3;
    const NEEDED_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const Ext4DiscardPreallocationsFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    len: u32 = 0,
    needed: u32 = 0,
    pub fn calcProtobufSize(self: *const Ext4DiscardPreallocationsFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DiscardPreallocationsFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DiscardPreallocationsFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DiscardPreallocationsFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeU32(self.len);
        }
        if (self.needed != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DiscardPreallocationsFtraceEventWire.NEEDED_WIRE) + gremlin.sizes.sizeU32(self.needed);
        }
        return res;
    }
    pub fn encode(self: *const Ext4DiscardPreallocationsFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4DiscardPreallocationsFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4DiscardPreallocationsFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4DiscardPreallocationsFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.len != 0) {
            target.appendUint32(Ext4DiscardPreallocationsFtraceEventWire.LEN_WIRE, self.len);
        }
        if (self.needed != 0) {
            target.appendUint32(Ext4DiscardPreallocationsFtraceEventWire.NEEDED_WIRE, self.needed);
        }
    }
};
pub const Ext4DiscardPreallocationsFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _len: u32 = 0,
    _needed: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4DiscardPreallocationsFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4DiscardPreallocationsFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4DiscardPreallocationsFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4DiscardPreallocationsFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4DiscardPreallocationsFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                Ext4DiscardPreallocationsFtraceEventWire.NEEDED_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._needed = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4DiscardPreallocationsFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4DiscardPreallocationsFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getLen(self: *const Ext4DiscardPreallocationsFtraceEventReader) u32 {
        return self._len;
    }
    pub inline fn getNeeded(self: *const Ext4DiscardPreallocationsFtraceEventReader) u32 {
        return self._needed;
    }
};
const Ext4DropInodeFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const DROP_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const Ext4DropInodeFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    drop: i32 = 0,
    pub fn calcProtobufSize(self: *const Ext4DropInodeFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DropInodeFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DropInodeFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.drop != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4DropInodeFtraceEventWire.DROP_WIRE) + gremlin.sizes.sizeI32(self.drop);
        }
        return res;
    }
    pub fn encode(self: *const Ext4DropInodeFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4DropInodeFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4DropInodeFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4DropInodeFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.drop != 0) {
            target.appendInt32(Ext4DropInodeFtraceEventWire.DROP_WIRE, self.drop);
        }
    }
};
pub const Ext4DropInodeFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _drop: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4DropInodeFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4DropInodeFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4DropInodeFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4DropInodeFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4DropInodeFtraceEventWire.DROP_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._drop = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4DropInodeFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4DropInodeFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getDrop(self: *const Ext4DropInodeFtraceEventReader) i32 {
        return self._drop;
    }
};
const Ext4EsCacheExtentFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const LBLK_WIRE: gremlin.ProtoWireNumber = 3;
    const LEN_WIRE: gremlin.ProtoWireNumber = 4;
    const PBLK_WIRE: gremlin.ProtoWireNumber = 5;
    const STATUS_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const Ext4EsCacheExtentFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    lblk: u32 = 0,
    len: u32 = 0,
    pblk: u64 = 0,
    status: u32 = 0,
    pub fn calcProtobufSize(self: *const Ext4EsCacheExtentFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsCacheExtentFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsCacheExtentFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.lblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsCacheExtentFtraceEventWire.LBLK_WIRE) + gremlin.sizes.sizeU32(self.lblk);
        }
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsCacheExtentFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeU32(self.len);
        }
        if (self.pblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsCacheExtentFtraceEventWire.PBLK_WIRE) + gremlin.sizes.sizeU64(self.pblk);
        }
        if (self.status != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsCacheExtentFtraceEventWire.STATUS_WIRE) + gremlin.sizes.sizeU32(self.status);
        }
        return res;
    }
    pub fn encode(self: *const Ext4EsCacheExtentFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4EsCacheExtentFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4EsCacheExtentFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4EsCacheExtentFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.lblk != 0) {
            target.appendUint32(Ext4EsCacheExtentFtraceEventWire.LBLK_WIRE, self.lblk);
        }
        if (self.len != 0) {
            target.appendUint32(Ext4EsCacheExtentFtraceEventWire.LEN_WIRE, self.len);
        }
        if (self.pblk != 0) {
            target.appendUint64(Ext4EsCacheExtentFtraceEventWire.PBLK_WIRE, self.pblk);
        }
        if (self.status != 0) {
            target.appendUint32(Ext4EsCacheExtentFtraceEventWire.STATUS_WIRE, self.status);
        }
    }
};
pub const Ext4EsCacheExtentFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _lblk: u32 = 0,
    _len: u32 = 0,
    _pblk: u64 = 0,
    _status: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4EsCacheExtentFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4EsCacheExtentFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4EsCacheExtentFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4EsCacheExtentFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4EsCacheExtentFtraceEventWire.LBLK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._lblk = result.value;
                },
                Ext4EsCacheExtentFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                Ext4EsCacheExtentFtraceEventWire.PBLK_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._pblk = result.value;
                },
                Ext4EsCacheExtentFtraceEventWire.STATUS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._status = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4EsCacheExtentFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4EsCacheExtentFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getLblk(self: *const Ext4EsCacheExtentFtraceEventReader) u32 {
        return self._lblk;
    }
    pub inline fn getLen(self: *const Ext4EsCacheExtentFtraceEventReader) u32 {
        return self._len;
    }
    pub inline fn getPblk(self: *const Ext4EsCacheExtentFtraceEventReader) u64 {
        return self._pblk;
    }
    pub inline fn getStatus(self: *const Ext4EsCacheExtentFtraceEventReader) u32 {
        return self._status;
    }
};
const Ext4EsFindDelayedExtentRangeEnterFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const LBLK_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const Ext4EsFindDelayedExtentRangeEnterFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    lblk: u32 = 0,
    pub fn calcProtobufSize(self: *const Ext4EsFindDelayedExtentRangeEnterFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsFindDelayedExtentRangeEnterFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsFindDelayedExtentRangeEnterFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.lblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsFindDelayedExtentRangeEnterFtraceEventWire.LBLK_WIRE) + gremlin.sizes.sizeU32(self.lblk);
        }
        return res;
    }
    pub fn encode(self: *const Ext4EsFindDelayedExtentRangeEnterFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4EsFindDelayedExtentRangeEnterFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4EsFindDelayedExtentRangeEnterFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4EsFindDelayedExtentRangeEnterFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.lblk != 0) {
            target.appendUint32(Ext4EsFindDelayedExtentRangeEnterFtraceEventWire.LBLK_WIRE, self.lblk);
        }
    }
};
pub const Ext4EsFindDelayedExtentRangeEnterFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _lblk: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4EsFindDelayedExtentRangeEnterFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4EsFindDelayedExtentRangeEnterFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4EsFindDelayedExtentRangeEnterFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4EsFindDelayedExtentRangeEnterFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4EsFindDelayedExtentRangeEnterFtraceEventWire.LBLK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._lblk = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4EsFindDelayedExtentRangeEnterFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4EsFindDelayedExtentRangeEnterFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getLblk(self: *const Ext4EsFindDelayedExtentRangeEnterFtraceEventReader) u32 {
        return self._lblk;
    }
};
const Ext4EsFindDelayedExtentRangeExitFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const LBLK_WIRE: gremlin.ProtoWireNumber = 3;
    const LEN_WIRE: gremlin.ProtoWireNumber = 4;
    const PBLK_WIRE: gremlin.ProtoWireNumber = 5;
    const STATUS_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const Ext4EsFindDelayedExtentRangeExitFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    lblk: u32 = 0,
    len: u32 = 0,
    pblk: u64 = 0,
    status: u64 = 0,
    pub fn calcProtobufSize(self: *const Ext4EsFindDelayedExtentRangeExitFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsFindDelayedExtentRangeExitFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsFindDelayedExtentRangeExitFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.lblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsFindDelayedExtentRangeExitFtraceEventWire.LBLK_WIRE) + gremlin.sizes.sizeU32(self.lblk);
        }
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsFindDelayedExtentRangeExitFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeU32(self.len);
        }
        if (self.pblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsFindDelayedExtentRangeExitFtraceEventWire.PBLK_WIRE) + gremlin.sizes.sizeU64(self.pblk);
        }
        if (self.status != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsFindDelayedExtentRangeExitFtraceEventWire.STATUS_WIRE) + gremlin.sizes.sizeU64(self.status);
        }
        return res;
    }
    pub fn encode(self: *const Ext4EsFindDelayedExtentRangeExitFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4EsFindDelayedExtentRangeExitFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4EsFindDelayedExtentRangeExitFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4EsFindDelayedExtentRangeExitFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.lblk != 0) {
            target.appendUint32(Ext4EsFindDelayedExtentRangeExitFtraceEventWire.LBLK_WIRE, self.lblk);
        }
        if (self.len != 0) {
            target.appendUint32(Ext4EsFindDelayedExtentRangeExitFtraceEventWire.LEN_WIRE, self.len);
        }
        if (self.pblk != 0) {
            target.appendUint64(Ext4EsFindDelayedExtentRangeExitFtraceEventWire.PBLK_WIRE, self.pblk);
        }
        if (self.status != 0) {
            target.appendUint64(Ext4EsFindDelayedExtentRangeExitFtraceEventWire.STATUS_WIRE, self.status);
        }
    }
};
pub const Ext4EsFindDelayedExtentRangeExitFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _lblk: u32 = 0,
    _len: u32 = 0,
    _pblk: u64 = 0,
    _status: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4EsFindDelayedExtentRangeExitFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4EsFindDelayedExtentRangeExitFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4EsFindDelayedExtentRangeExitFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4EsFindDelayedExtentRangeExitFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4EsFindDelayedExtentRangeExitFtraceEventWire.LBLK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._lblk = result.value;
                },
                Ext4EsFindDelayedExtentRangeExitFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                Ext4EsFindDelayedExtentRangeExitFtraceEventWire.PBLK_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._pblk = result.value;
                },
                Ext4EsFindDelayedExtentRangeExitFtraceEventWire.STATUS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._status = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4EsFindDelayedExtentRangeExitFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4EsFindDelayedExtentRangeExitFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getLblk(self: *const Ext4EsFindDelayedExtentRangeExitFtraceEventReader) u32 {
        return self._lblk;
    }
    pub inline fn getLen(self: *const Ext4EsFindDelayedExtentRangeExitFtraceEventReader) u32 {
        return self._len;
    }
    pub inline fn getPblk(self: *const Ext4EsFindDelayedExtentRangeExitFtraceEventReader) u64 {
        return self._pblk;
    }
    pub inline fn getStatus(self: *const Ext4EsFindDelayedExtentRangeExitFtraceEventReader) u64 {
        return self._status;
    }
};
const Ext4EsInsertExtentFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const LBLK_WIRE: gremlin.ProtoWireNumber = 3;
    const LEN_WIRE: gremlin.ProtoWireNumber = 4;
    const PBLK_WIRE: gremlin.ProtoWireNumber = 5;
    const STATUS_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const Ext4EsInsertExtentFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    lblk: u32 = 0,
    len: u32 = 0,
    pblk: u64 = 0,
    status: u64 = 0,
    pub fn calcProtobufSize(self: *const Ext4EsInsertExtentFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsInsertExtentFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsInsertExtentFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.lblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsInsertExtentFtraceEventWire.LBLK_WIRE) + gremlin.sizes.sizeU32(self.lblk);
        }
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsInsertExtentFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeU32(self.len);
        }
        if (self.pblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsInsertExtentFtraceEventWire.PBLK_WIRE) + gremlin.sizes.sizeU64(self.pblk);
        }
        if (self.status != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsInsertExtentFtraceEventWire.STATUS_WIRE) + gremlin.sizes.sizeU64(self.status);
        }
        return res;
    }
    pub fn encode(self: *const Ext4EsInsertExtentFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4EsInsertExtentFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4EsInsertExtentFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4EsInsertExtentFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.lblk != 0) {
            target.appendUint32(Ext4EsInsertExtentFtraceEventWire.LBLK_WIRE, self.lblk);
        }
        if (self.len != 0) {
            target.appendUint32(Ext4EsInsertExtentFtraceEventWire.LEN_WIRE, self.len);
        }
        if (self.pblk != 0) {
            target.appendUint64(Ext4EsInsertExtentFtraceEventWire.PBLK_WIRE, self.pblk);
        }
        if (self.status != 0) {
            target.appendUint64(Ext4EsInsertExtentFtraceEventWire.STATUS_WIRE, self.status);
        }
    }
};
pub const Ext4EsInsertExtentFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _lblk: u32 = 0,
    _len: u32 = 0,
    _pblk: u64 = 0,
    _status: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4EsInsertExtentFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4EsInsertExtentFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4EsInsertExtentFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4EsInsertExtentFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4EsInsertExtentFtraceEventWire.LBLK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._lblk = result.value;
                },
                Ext4EsInsertExtentFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                Ext4EsInsertExtentFtraceEventWire.PBLK_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._pblk = result.value;
                },
                Ext4EsInsertExtentFtraceEventWire.STATUS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._status = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4EsInsertExtentFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4EsInsertExtentFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getLblk(self: *const Ext4EsInsertExtentFtraceEventReader) u32 {
        return self._lblk;
    }
    pub inline fn getLen(self: *const Ext4EsInsertExtentFtraceEventReader) u32 {
        return self._len;
    }
    pub inline fn getPblk(self: *const Ext4EsInsertExtentFtraceEventReader) u64 {
        return self._pblk;
    }
    pub inline fn getStatus(self: *const Ext4EsInsertExtentFtraceEventReader) u64 {
        return self._status;
    }
};
const Ext4EsLookupExtentEnterFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const LBLK_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const Ext4EsLookupExtentEnterFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    lblk: u32 = 0,
    pub fn calcProtobufSize(self: *const Ext4EsLookupExtentEnterFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsLookupExtentEnterFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsLookupExtentEnterFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.lblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsLookupExtentEnterFtraceEventWire.LBLK_WIRE) + gremlin.sizes.sizeU32(self.lblk);
        }
        return res;
    }
    pub fn encode(self: *const Ext4EsLookupExtentEnterFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4EsLookupExtentEnterFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4EsLookupExtentEnterFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4EsLookupExtentEnterFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.lblk != 0) {
            target.appendUint32(Ext4EsLookupExtentEnterFtraceEventWire.LBLK_WIRE, self.lblk);
        }
    }
};
pub const Ext4EsLookupExtentEnterFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _lblk: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4EsLookupExtentEnterFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4EsLookupExtentEnterFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4EsLookupExtentEnterFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4EsLookupExtentEnterFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4EsLookupExtentEnterFtraceEventWire.LBLK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._lblk = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4EsLookupExtentEnterFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4EsLookupExtentEnterFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getLblk(self: *const Ext4EsLookupExtentEnterFtraceEventReader) u32 {
        return self._lblk;
    }
};
const Ext4EsLookupExtentExitFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const LBLK_WIRE: gremlin.ProtoWireNumber = 3;
    const LEN_WIRE: gremlin.ProtoWireNumber = 4;
    const PBLK_WIRE: gremlin.ProtoWireNumber = 5;
    const STATUS_WIRE: gremlin.ProtoWireNumber = 6;
    const FOUND_WIRE: gremlin.ProtoWireNumber = 7;
};
pub const Ext4EsLookupExtentExitFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    lblk: u32 = 0,
    len: u32 = 0,
    pblk: u64 = 0,
    status: u64 = 0,
    found: i32 = 0,
    pub fn calcProtobufSize(self: *const Ext4EsLookupExtentExitFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsLookupExtentExitFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsLookupExtentExitFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.lblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsLookupExtentExitFtraceEventWire.LBLK_WIRE) + gremlin.sizes.sizeU32(self.lblk);
        }
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsLookupExtentExitFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeU32(self.len);
        }
        if (self.pblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsLookupExtentExitFtraceEventWire.PBLK_WIRE) + gremlin.sizes.sizeU64(self.pblk);
        }
        if (self.status != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsLookupExtentExitFtraceEventWire.STATUS_WIRE) + gremlin.sizes.sizeU64(self.status);
        }
        if (self.found != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsLookupExtentExitFtraceEventWire.FOUND_WIRE) + gremlin.sizes.sizeI32(self.found);
        }
        return res;
    }
    pub fn encode(self: *const Ext4EsLookupExtentExitFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4EsLookupExtentExitFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4EsLookupExtentExitFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4EsLookupExtentExitFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.lblk != 0) {
            target.appendUint32(Ext4EsLookupExtentExitFtraceEventWire.LBLK_WIRE, self.lblk);
        }
        if (self.len != 0) {
            target.appendUint32(Ext4EsLookupExtentExitFtraceEventWire.LEN_WIRE, self.len);
        }
        if (self.pblk != 0) {
            target.appendUint64(Ext4EsLookupExtentExitFtraceEventWire.PBLK_WIRE, self.pblk);
        }
        if (self.status != 0) {
            target.appendUint64(Ext4EsLookupExtentExitFtraceEventWire.STATUS_WIRE, self.status);
        }
        if (self.found != 0) {
            target.appendInt32(Ext4EsLookupExtentExitFtraceEventWire.FOUND_WIRE, self.found);
        }
    }
};
pub const Ext4EsLookupExtentExitFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _lblk: u32 = 0,
    _len: u32 = 0,
    _pblk: u64 = 0,
    _status: u64 = 0,
    _found: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4EsLookupExtentExitFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4EsLookupExtentExitFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4EsLookupExtentExitFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4EsLookupExtentExitFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4EsLookupExtentExitFtraceEventWire.LBLK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._lblk = result.value;
                },
                Ext4EsLookupExtentExitFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                Ext4EsLookupExtentExitFtraceEventWire.PBLK_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._pblk = result.value;
                },
                Ext4EsLookupExtentExitFtraceEventWire.STATUS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._status = result.value;
                },
                Ext4EsLookupExtentExitFtraceEventWire.FOUND_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._found = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4EsLookupExtentExitFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4EsLookupExtentExitFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getLblk(self: *const Ext4EsLookupExtentExitFtraceEventReader) u32 {
        return self._lblk;
    }
    pub inline fn getLen(self: *const Ext4EsLookupExtentExitFtraceEventReader) u32 {
        return self._len;
    }
    pub inline fn getPblk(self: *const Ext4EsLookupExtentExitFtraceEventReader) u64 {
        return self._pblk;
    }
    pub inline fn getStatus(self: *const Ext4EsLookupExtentExitFtraceEventReader) u64 {
        return self._status;
    }
    pub inline fn getFound(self: *const Ext4EsLookupExtentExitFtraceEventReader) i32 {
        return self._found;
    }
};
const Ext4EsRemoveExtentFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const LBLK_WIRE: gremlin.ProtoWireNumber = 3;
    const LEN_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const Ext4EsRemoveExtentFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    lblk: i64 = 0,
    len: i64 = 0,
    pub fn calcProtobufSize(self: *const Ext4EsRemoveExtentFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsRemoveExtentFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsRemoveExtentFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.lblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsRemoveExtentFtraceEventWire.LBLK_WIRE) + gremlin.sizes.sizeI64(self.lblk);
        }
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsRemoveExtentFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeI64(self.len);
        }
        return res;
    }
    pub fn encode(self: *const Ext4EsRemoveExtentFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4EsRemoveExtentFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4EsRemoveExtentFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4EsRemoveExtentFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.lblk != 0) {
            target.appendInt64(Ext4EsRemoveExtentFtraceEventWire.LBLK_WIRE, self.lblk);
        }
        if (self.len != 0) {
            target.appendInt64(Ext4EsRemoveExtentFtraceEventWire.LEN_WIRE, self.len);
        }
    }
};
pub const Ext4EsRemoveExtentFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _lblk: i64 = 0,
    _len: i64 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4EsRemoveExtentFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4EsRemoveExtentFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4EsRemoveExtentFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4EsRemoveExtentFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4EsRemoveExtentFtraceEventWire.LBLK_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._lblk = result.value;
                },
                Ext4EsRemoveExtentFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4EsRemoveExtentFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4EsRemoveExtentFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getLblk(self: *const Ext4EsRemoveExtentFtraceEventReader) i64 {
        return self._lblk;
    }
    pub inline fn getLen(self: *const Ext4EsRemoveExtentFtraceEventReader) i64 {
        return self._len;
    }
};
const Ext4EsShrinkFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const NR_SHRUNK_WIRE: gremlin.ProtoWireNumber = 2;
    const SCAN_TIME_WIRE: gremlin.ProtoWireNumber = 3;
    const NR_SKIPPED_WIRE: gremlin.ProtoWireNumber = 4;
    const RETRIED_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const Ext4EsShrinkFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    nr_shrunk: i32 = 0,
    scan_time: u64 = 0,
    nr_skipped: i32 = 0,
    retried: i32 = 0,
    pub fn calcProtobufSize(self: *const Ext4EsShrinkFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsShrinkFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.nr_shrunk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsShrinkFtraceEventWire.NR_SHRUNK_WIRE) + gremlin.sizes.sizeI32(self.nr_shrunk);
        }
        if (self.scan_time != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsShrinkFtraceEventWire.SCAN_TIME_WIRE) + gremlin.sizes.sizeU64(self.scan_time);
        }
        if (self.nr_skipped != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsShrinkFtraceEventWire.NR_SKIPPED_WIRE) + gremlin.sizes.sizeI32(self.nr_skipped);
        }
        if (self.retried != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsShrinkFtraceEventWire.RETRIED_WIRE) + gremlin.sizes.sizeI32(self.retried);
        }
        return res;
    }
    pub fn encode(self: *const Ext4EsShrinkFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4EsShrinkFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4EsShrinkFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.nr_shrunk != 0) {
            target.appendInt32(Ext4EsShrinkFtraceEventWire.NR_SHRUNK_WIRE, self.nr_shrunk);
        }
        if (self.scan_time != 0) {
            target.appendUint64(Ext4EsShrinkFtraceEventWire.SCAN_TIME_WIRE, self.scan_time);
        }
        if (self.nr_skipped != 0) {
            target.appendInt32(Ext4EsShrinkFtraceEventWire.NR_SKIPPED_WIRE, self.nr_skipped);
        }
        if (self.retried != 0) {
            target.appendInt32(Ext4EsShrinkFtraceEventWire.RETRIED_WIRE, self.retried);
        }
    }
};
pub const Ext4EsShrinkFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _nr_shrunk: i32 = 0,
    _scan_time: u64 = 0,
    _nr_skipped: i32 = 0,
    _retried: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4EsShrinkFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4EsShrinkFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4EsShrinkFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4EsShrinkFtraceEventWire.NR_SHRUNK_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._nr_shrunk = result.value;
                },
                Ext4EsShrinkFtraceEventWire.SCAN_TIME_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._scan_time = result.value;
                },
                Ext4EsShrinkFtraceEventWire.NR_SKIPPED_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._nr_skipped = result.value;
                },
                Ext4EsShrinkFtraceEventWire.RETRIED_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._retried = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4EsShrinkFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getNrShrunk(self: *const Ext4EsShrinkFtraceEventReader) i32 {
        return self._nr_shrunk;
    }
    pub inline fn getScanTime(self: *const Ext4EsShrinkFtraceEventReader) u64 {
        return self._scan_time;
    }
    pub inline fn getNrSkipped(self: *const Ext4EsShrinkFtraceEventReader) i32 {
        return self._nr_skipped;
    }
    pub inline fn getRetried(self: *const Ext4EsShrinkFtraceEventReader) i32 {
        return self._retried;
    }
};
const Ext4EsShrinkCountFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const NR_TO_SCAN_WIRE: gremlin.ProtoWireNumber = 2;
    const CACHE_CNT_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const Ext4EsShrinkCountFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    nr_to_scan: i32 = 0,
    cache_cnt: i32 = 0,
    pub fn calcProtobufSize(self: *const Ext4EsShrinkCountFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsShrinkCountFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.nr_to_scan != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsShrinkCountFtraceEventWire.NR_TO_SCAN_WIRE) + gremlin.sizes.sizeI32(self.nr_to_scan);
        }
        if (self.cache_cnt != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsShrinkCountFtraceEventWire.CACHE_CNT_WIRE) + gremlin.sizes.sizeI32(self.cache_cnt);
        }
        return res;
    }
    pub fn encode(self: *const Ext4EsShrinkCountFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4EsShrinkCountFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4EsShrinkCountFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.nr_to_scan != 0) {
            target.appendInt32(Ext4EsShrinkCountFtraceEventWire.NR_TO_SCAN_WIRE, self.nr_to_scan);
        }
        if (self.cache_cnt != 0) {
            target.appendInt32(Ext4EsShrinkCountFtraceEventWire.CACHE_CNT_WIRE, self.cache_cnt);
        }
    }
};
pub const Ext4EsShrinkCountFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _nr_to_scan: i32 = 0,
    _cache_cnt: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4EsShrinkCountFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4EsShrinkCountFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4EsShrinkCountFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4EsShrinkCountFtraceEventWire.NR_TO_SCAN_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._nr_to_scan = result.value;
                },
                Ext4EsShrinkCountFtraceEventWire.CACHE_CNT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._cache_cnt = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4EsShrinkCountFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getNrToScan(self: *const Ext4EsShrinkCountFtraceEventReader) i32 {
        return self._nr_to_scan;
    }
    pub inline fn getCacheCnt(self: *const Ext4EsShrinkCountFtraceEventReader) i32 {
        return self._cache_cnt;
    }
};
const Ext4EsShrinkScanEnterFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const NR_TO_SCAN_WIRE: gremlin.ProtoWireNumber = 2;
    const CACHE_CNT_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const Ext4EsShrinkScanEnterFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    nr_to_scan: i32 = 0,
    cache_cnt: i32 = 0,
    pub fn calcProtobufSize(self: *const Ext4EsShrinkScanEnterFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsShrinkScanEnterFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.nr_to_scan != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsShrinkScanEnterFtraceEventWire.NR_TO_SCAN_WIRE) + gremlin.sizes.sizeI32(self.nr_to_scan);
        }
        if (self.cache_cnt != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsShrinkScanEnterFtraceEventWire.CACHE_CNT_WIRE) + gremlin.sizes.sizeI32(self.cache_cnt);
        }
        return res;
    }
    pub fn encode(self: *const Ext4EsShrinkScanEnterFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4EsShrinkScanEnterFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4EsShrinkScanEnterFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.nr_to_scan != 0) {
            target.appendInt32(Ext4EsShrinkScanEnterFtraceEventWire.NR_TO_SCAN_WIRE, self.nr_to_scan);
        }
        if (self.cache_cnt != 0) {
            target.appendInt32(Ext4EsShrinkScanEnterFtraceEventWire.CACHE_CNT_WIRE, self.cache_cnt);
        }
    }
};
pub const Ext4EsShrinkScanEnterFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _nr_to_scan: i32 = 0,
    _cache_cnt: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4EsShrinkScanEnterFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4EsShrinkScanEnterFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4EsShrinkScanEnterFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4EsShrinkScanEnterFtraceEventWire.NR_TO_SCAN_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._nr_to_scan = result.value;
                },
                Ext4EsShrinkScanEnterFtraceEventWire.CACHE_CNT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._cache_cnt = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4EsShrinkScanEnterFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getNrToScan(self: *const Ext4EsShrinkScanEnterFtraceEventReader) i32 {
        return self._nr_to_scan;
    }
    pub inline fn getCacheCnt(self: *const Ext4EsShrinkScanEnterFtraceEventReader) i32 {
        return self._cache_cnt;
    }
};
const Ext4EsShrinkScanExitFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const NR_SHRUNK_WIRE: gremlin.ProtoWireNumber = 2;
    const CACHE_CNT_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const Ext4EsShrinkScanExitFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    nr_shrunk: i32 = 0,
    cache_cnt: i32 = 0,
    pub fn calcProtobufSize(self: *const Ext4EsShrinkScanExitFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsShrinkScanExitFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.nr_shrunk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsShrinkScanExitFtraceEventWire.NR_SHRUNK_WIRE) + gremlin.sizes.sizeI32(self.nr_shrunk);
        }
        if (self.cache_cnt != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EsShrinkScanExitFtraceEventWire.CACHE_CNT_WIRE) + gremlin.sizes.sizeI32(self.cache_cnt);
        }
        return res;
    }
    pub fn encode(self: *const Ext4EsShrinkScanExitFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4EsShrinkScanExitFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4EsShrinkScanExitFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.nr_shrunk != 0) {
            target.appendInt32(Ext4EsShrinkScanExitFtraceEventWire.NR_SHRUNK_WIRE, self.nr_shrunk);
        }
        if (self.cache_cnt != 0) {
            target.appendInt32(Ext4EsShrinkScanExitFtraceEventWire.CACHE_CNT_WIRE, self.cache_cnt);
        }
    }
};
pub const Ext4EsShrinkScanExitFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _nr_shrunk: i32 = 0,
    _cache_cnt: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4EsShrinkScanExitFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4EsShrinkScanExitFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4EsShrinkScanExitFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4EsShrinkScanExitFtraceEventWire.NR_SHRUNK_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._nr_shrunk = result.value;
                },
                Ext4EsShrinkScanExitFtraceEventWire.CACHE_CNT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._cache_cnt = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4EsShrinkScanExitFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getNrShrunk(self: *const Ext4EsShrinkScanExitFtraceEventReader) i32 {
        return self._nr_shrunk;
    }
    pub inline fn getCacheCnt(self: *const Ext4EsShrinkScanExitFtraceEventReader) i32 {
        return self._cache_cnt;
    }
};
const Ext4EvictInodeFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const NLINK_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const Ext4EvictInodeFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    nlink: i32 = 0,
    pub fn calcProtobufSize(self: *const Ext4EvictInodeFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EvictInodeFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EvictInodeFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.nlink != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4EvictInodeFtraceEventWire.NLINK_WIRE) + gremlin.sizes.sizeI32(self.nlink);
        }
        return res;
    }
    pub fn encode(self: *const Ext4EvictInodeFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4EvictInodeFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4EvictInodeFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4EvictInodeFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.nlink != 0) {
            target.appendInt32(Ext4EvictInodeFtraceEventWire.NLINK_WIRE, self.nlink);
        }
    }
};
pub const Ext4EvictInodeFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _nlink: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4EvictInodeFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4EvictInodeFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4EvictInodeFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4EvictInodeFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4EvictInodeFtraceEventWire.NLINK_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._nlink = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4EvictInodeFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4EvictInodeFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getNlink(self: *const Ext4EvictInodeFtraceEventReader) i32 {
        return self._nlink;
    }
};
const Ext4ExtConvertToInitializedEnterFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const M_LBLK_WIRE: gremlin.ProtoWireNumber = 3;
    const M_LEN_WIRE: gremlin.ProtoWireNumber = 4;
    const U_LBLK_WIRE: gremlin.ProtoWireNumber = 5;
    const U_LEN_WIRE: gremlin.ProtoWireNumber = 6;
    const U_PBLK_WIRE: gremlin.ProtoWireNumber = 7;
};
pub const Ext4ExtConvertToInitializedEnterFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    m_lblk: u32 = 0,
    m_len: u32 = 0,
    u_lblk: u32 = 0,
    u_len: u32 = 0,
    u_pblk: u64 = 0,
    pub fn calcProtobufSize(self: *const Ext4ExtConvertToInitializedEnterFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtConvertToInitializedEnterFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtConvertToInitializedEnterFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.m_lblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtConvertToInitializedEnterFtraceEventWire.M_LBLK_WIRE) + gremlin.sizes.sizeU32(self.m_lblk);
        }
        if (self.m_len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtConvertToInitializedEnterFtraceEventWire.M_LEN_WIRE) + gremlin.sizes.sizeU32(self.m_len);
        }
        if (self.u_lblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtConvertToInitializedEnterFtraceEventWire.U_LBLK_WIRE) + gremlin.sizes.sizeU32(self.u_lblk);
        }
        if (self.u_len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtConvertToInitializedEnterFtraceEventWire.U_LEN_WIRE) + gremlin.sizes.sizeU32(self.u_len);
        }
        if (self.u_pblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtConvertToInitializedEnterFtraceEventWire.U_PBLK_WIRE) + gremlin.sizes.sizeU64(self.u_pblk);
        }
        return res;
    }
    pub fn encode(self: *const Ext4ExtConvertToInitializedEnterFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4ExtConvertToInitializedEnterFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4ExtConvertToInitializedEnterFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4ExtConvertToInitializedEnterFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.m_lblk != 0) {
            target.appendUint32(Ext4ExtConvertToInitializedEnterFtraceEventWire.M_LBLK_WIRE, self.m_lblk);
        }
        if (self.m_len != 0) {
            target.appendUint32(Ext4ExtConvertToInitializedEnterFtraceEventWire.M_LEN_WIRE, self.m_len);
        }
        if (self.u_lblk != 0) {
            target.appendUint32(Ext4ExtConvertToInitializedEnterFtraceEventWire.U_LBLK_WIRE, self.u_lblk);
        }
        if (self.u_len != 0) {
            target.appendUint32(Ext4ExtConvertToInitializedEnterFtraceEventWire.U_LEN_WIRE, self.u_len);
        }
        if (self.u_pblk != 0) {
            target.appendUint64(Ext4ExtConvertToInitializedEnterFtraceEventWire.U_PBLK_WIRE, self.u_pblk);
        }
    }
};
pub const Ext4ExtConvertToInitializedEnterFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _m_lblk: u32 = 0,
    _m_len: u32 = 0,
    _u_lblk: u32 = 0,
    _u_len: u32 = 0,
    _u_pblk: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4ExtConvertToInitializedEnterFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4ExtConvertToInitializedEnterFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4ExtConvertToInitializedEnterFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4ExtConvertToInitializedEnterFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4ExtConvertToInitializedEnterFtraceEventWire.M_LBLK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._m_lblk = result.value;
                },
                Ext4ExtConvertToInitializedEnterFtraceEventWire.M_LEN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._m_len = result.value;
                },
                Ext4ExtConvertToInitializedEnterFtraceEventWire.U_LBLK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._u_lblk = result.value;
                },
                Ext4ExtConvertToInitializedEnterFtraceEventWire.U_LEN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._u_len = result.value;
                },
                Ext4ExtConvertToInitializedEnterFtraceEventWire.U_PBLK_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._u_pblk = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4ExtConvertToInitializedEnterFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4ExtConvertToInitializedEnterFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getMLblk(self: *const Ext4ExtConvertToInitializedEnterFtraceEventReader) u32 {
        return self._m_lblk;
    }
    pub inline fn getMLen(self: *const Ext4ExtConvertToInitializedEnterFtraceEventReader) u32 {
        return self._m_len;
    }
    pub inline fn getULblk(self: *const Ext4ExtConvertToInitializedEnterFtraceEventReader) u32 {
        return self._u_lblk;
    }
    pub inline fn getULen(self: *const Ext4ExtConvertToInitializedEnterFtraceEventReader) u32 {
        return self._u_len;
    }
    pub inline fn getUPblk(self: *const Ext4ExtConvertToInitializedEnterFtraceEventReader) u64 {
        return self._u_pblk;
    }
};
const Ext4ExtConvertToInitializedFastpathFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const M_LBLK_WIRE: gremlin.ProtoWireNumber = 3;
    const M_LEN_WIRE: gremlin.ProtoWireNumber = 4;
    const U_LBLK_WIRE: gremlin.ProtoWireNumber = 5;
    const U_LEN_WIRE: gremlin.ProtoWireNumber = 6;
    const U_PBLK_WIRE: gremlin.ProtoWireNumber = 7;
    const I_LBLK_WIRE: gremlin.ProtoWireNumber = 8;
    const I_LEN_WIRE: gremlin.ProtoWireNumber = 9;
    const I_PBLK_WIRE: gremlin.ProtoWireNumber = 10;
};
pub const Ext4ExtConvertToInitializedFastpathFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    m_lblk: u32 = 0,
    m_len: u32 = 0,
    u_lblk: u32 = 0,
    u_len: u32 = 0,
    u_pblk: u64 = 0,
    i_lblk: u32 = 0,
    i_len: u32 = 0,
    i_pblk: u64 = 0,
    pub fn calcProtobufSize(self: *const Ext4ExtConvertToInitializedFastpathFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtConvertToInitializedFastpathFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtConvertToInitializedFastpathFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.m_lblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtConvertToInitializedFastpathFtraceEventWire.M_LBLK_WIRE) + gremlin.sizes.sizeU32(self.m_lblk);
        }
        if (self.m_len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtConvertToInitializedFastpathFtraceEventWire.M_LEN_WIRE) + gremlin.sizes.sizeU32(self.m_len);
        }
        if (self.u_lblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtConvertToInitializedFastpathFtraceEventWire.U_LBLK_WIRE) + gremlin.sizes.sizeU32(self.u_lblk);
        }
        if (self.u_len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtConvertToInitializedFastpathFtraceEventWire.U_LEN_WIRE) + gremlin.sizes.sizeU32(self.u_len);
        }
        if (self.u_pblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtConvertToInitializedFastpathFtraceEventWire.U_PBLK_WIRE) + gremlin.sizes.sizeU64(self.u_pblk);
        }
        if (self.i_lblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtConvertToInitializedFastpathFtraceEventWire.I_LBLK_WIRE) + gremlin.sizes.sizeU32(self.i_lblk);
        }
        if (self.i_len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtConvertToInitializedFastpathFtraceEventWire.I_LEN_WIRE) + gremlin.sizes.sizeU32(self.i_len);
        }
        if (self.i_pblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtConvertToInitializedFastpathFtraceEventWire.I_PBLK_WIRE) + gremlin.sizes.sizeU64(self.i_pblk);
        }
        return res;
    }
    pub fn encode(self: *const Ext4ExtConvertToInitializedFastpathFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4ExtConvertToInitializedFastpathFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4ExtConvertToInitializedFastpathFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4ExtConvertToInitializedFastpathFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.m_lblk != 0) {
            target.appendUint32(Ext4ExtConvertToInitializedFastpathFtraceEventWire.M_LBLK_WIRE, self.m_lblk);
        }
        if (self.m_len != 0) {
            target.appendUint32(Ext4ExtConvertToInitializedFastpathFtraceEventWire.M_LEN_WIRE, self.m_len);
        }
        if (self.u_lblk != 0) {
            target.appendUint32(Ext4ExtConvertToInitializedFastpathFtraceEventWire.U_LBLK_WIRE, self.u_lblk);
        }
        if (self.u_len != 0) {
            target.appendUint32(Ext4ExtConvertToInitializedFastpathFtraceEventWire.U_LEN_WIRE, self.u_len);
        }
        if (self.u_pblk != 0) {
            target.appendUint64(Ext4ExtConvertToInitializedFastpathFtraceEventWire.U_PBLK_WIRE, self.u_pblk);
        }
        if (self.i_lblk != 0) {
            target.appendUint32(Ext4ExtConvertToInitializedFastpathFtraceEventWire.I_LBLK_WIRE, self.i_lblk);
        }
        if (self.i_len != 0) {
            target.appendUint32(Ext4ExtConvertToInitializedFastpathFtraceEventWire.I_LEN_WIRE, self.i_len);
        }
        if (self.i_pblk != 0) {
            target.appendUint64(Ext4ExtConvertToInitializedFastpathFtraceEventWire.I_PBLK_WIRE, self.i_pblk);
        }
    }
};
pub const Ext4ExtConvertToInitializedFastpathFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _m_lblk: u32 = 0,
    _m_len: u32 = 0,
    _u_lblk: u32 = 0,
    _u_len: u32 = 0,
    _u_pblk: u64 = 0,
    _i_lblk: u32 = 0,
    _i_len: u32 = 0,
    _i_pblk: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4ExtConvertToInitializedFastpathFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4ExtConvertToInitializedFastpathFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4ExtConvertToInitializedFastpathFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4ExtConvertToInitializedFastpathFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4ExtConvertToInitializedFastpathFtraceEventWire.M_LBLK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._m_lblk = result.value;
                },
                Ext4ExtConvertToInitializedFastpathFtraceEventWire.M_LEN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._m_len = result.value;
                },
                Ext4ExtConvertToInitializedFastpathFtraceEventWire.U_LBLK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._u_lblk = result.value;
                },
                Ext4ExtConvertToInitializedFastpathFtraceEventWire.U_LEN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._u_len = result.value;
                },
                Ext4ExtConvertToInitializedFastpathFtraceEventWire.U_PBLK_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._u_pblk = result.value;
                },
                Ext4ExtConvertToInitializedFastpathFtraceEventWire.I_LBLK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._i_lblk = result.value;
                },
                Ext4ExtConvertToInitializedFastpathFtraceEventWire.I_LEN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._i_len = result.value;
                },
                Ext4ExtConvertToInitializedFastpathFtraceEventWire.I_PBLK_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._i_pblk = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4ExtConvertToInitializedFastpathFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4ExtConvertToInitializedFastpathFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getMLblk(self: *const Ext4ExtConvertToInitializedFastpathFtraceEventReader) u32 {
        return self._m_lblk;
    }
    pub inline fn getMLen(self: *const Ext4ExtConvertToInitializedFastpathFtraceEventReader) u32 {
        return self._m_len;
    }
    pub inline fn getULblk(self: *const Ext4ExtConvertToInitializedFastpathFtraceEventReader) u32 {
        return self._u_lblk;
    }
    pub inline fn getULen(self: *const Ext4ExtConvertToInitializedFastpathFtraceEventReader) u32 {
        return self._u_len;
    }
    pub inline fn getUPblk(self: *const Ext4ExtConvertToInitializedFastpathFtraceEventReader) u64 {
        return self._u_pblk;
    }
    pub inline fn getILblk(self: *const Ext4ExtConvertToInitializedFastpathFtraceEventReader) u32 {
        return self._i_lblk;
    }
    pub inline fn getILen(self: *const Ext4ExtConvertToInitializedFastpathFtraceEventReader) u32 {
        return self._i_len;
    }
    pub inline fn getIPblk(self: *const Ext4ExtConvertToInitializedFastpathFtraceEventReader) u64 {
        return self._i_pblk;
    }
};
const Ext4ExtHandleUnwrittenExtentsFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const FLAGS_WIRE: gremlin.ProtoWireNumber = 3;
    const LBLK_WIRE: gremlin.ProtoWireNumber = 4;
    const PBLK_WIRE: gremlin.ProtoWireNumber = 5;
    const LEN_WIRE: gremlin.ProtoWireNumber = 6;
    const ALLOCATED_WIRE: gremlin.ProtoWireNumber = 7;
    const NEWBLK_WIRE: gremlin.ProtoWireNumber = 8;
};
pub const Ext4ExtHandleUnwrittenExtentsFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    flags: i32 = 0,
    lblk: u32 = 0,
    pblk: u64 = 0,
    len: u32 = 0,
    allocated: u32 = 0,
    newblk: u64 = 0,
    pub fn calcProtobufSize(self: *const Ext4ExtHandleUnwrittenExtentsFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtHandleUnwrittenExtentsFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtHandleUnwrittenExtentsFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.flags != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtHandleUnwrittenExtentsFtraceEventWire.FLAGS_WIRE) + gremlin.sizes.sizeI32(self.flags);
        }
        if (self.lblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtHandleUnwrittenExtentsFtraceEventWire.LBLK_WIRE) + gremlin.sizes.sizeU32(self.lblk);
        }
        if (self.pblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtHandleUnwrittenExtentsFtraceEventWire.PBLK_WIRE) + gremlin.sizes.sizeU64(self.pblk);
        }
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtHandleUnwrittenExtentsFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeU32(self.len);
        }
        if (self.allocated != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtHandleUnwrittenExtentsFtraceEventWire.ALLOCATED_WIRE) + gremlin.sizes.sizeU32(self.allocated);
        }
        if (self.newblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtHandleUnwrittenExtentsFtraceEventWire.NEWBLK_WIRE) + gremlin.sizes.sizeU64(self.newblk);
        }
        return res;
    }
    pub fn encode(self: *const Ext4ExtHandleUnwrittenExtentsFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4ExtHandleUnwrittenExtentsFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4ExtHandleUnwrittenExtentsFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4ExtHandleUnwrittenExtentsFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.flags != 0) {
            target.appendInt32(Ext4ExtHandleUnwrittenExtentsFtraceEventWire.FLAGS_WIRE, self.flags);
        }
        if (self.lblk != 0) {
            target.appendUint32(Ext4ExtHandleUnwrittenExtentsFtraceEventWire.LBLK_WIRE, self.lblk);
        }
        if (self.pblk != 0) {
            target.appendUint64(Ext4ExtHandleUnwrittenExtentsFtraceEventWire.PBLK_WIRE, self.pblk);
        }
        if (self.len != 0) {
            target.appendUint32(Ext4ExtHandleUnwrittenExtentsFtraceEventWire.LEN_WIRE, self.len);
        }
        if (self.allocated != 0) {
            target.appendUint32(Ext4ExtHandleUnwrittenExtentsFtraceEventWire.ALLOCATED_WIRE, self.allocated);
        }
        if (self.newblk != 0) {
            target.appendUint64(Ext4ExtHandleUnwrittenExtentsFtraceEventWire.NEWBLK_WIRE, self.newblk);
        }
    }
};
pub const Ext4ExtHandleUnwrittenExtentsFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _flags: i32 = 0,
    _lblk: u32 = 0,
    _pblk: u64 = 0,
    _len: u32 = 0,
    _allocated: u32 = 0,
    _newblk: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4ExtHandleUnwrittenExtentsFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4ExtHandleUnwrittenExtentsFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4ExtHandleUnwrittenExtentsFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4ExtHandleUnwrittenExtentsFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4ExtHandleUnwrittenExtentsFtraceEventWire.FLAGS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._flags = result.value;
                },
                Ext4ExtHandleUnwrittenExtentsFtraceEventWire.LBLK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._lblk = result.value;
                },
                Ext4ExtHandleUnwrittenExtentsFtraceEventWire.PBLK_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._pblk = result.value;
                },
                Ext4ExtHandleUnwrittenExtentsFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                Ext4ExtHandleUnwrittenExtentsFtraceEventWire.ALLOCATED_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._allocated = result.value;
                },
                Ext4ExtHandleUnwrittenExtentsFtraceEventWire.NEWBLK_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._newblk = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4ExtHandleUnwrittenExtentsFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4ExtHandleUnwrittenExtentsFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getFlags(self: *const Ext4ExtHandleUnwrittenExtentsFtraceEventReader) i32 {
        return self._flags;
    }
    pub inline fn getLblk(self: *const Ext4ExtHandleUnwrittenExtentsFtraceEventReader) u32 {
        return self._lblk;
    }
    pub inline fn getPblk(self: *const Ext4ExtHandleUnwrittenExtentsFtraceEventReader) u64 {
        return self._pblk;
    }
    pub inline fn getLen(self: *const Ext4ExtHandleUnwrittenExtentsFtraceEventReader) u32 {
        return self._len;
    }
    pub inline fn getAllocated(self: *const Ext4ExtHandleUnwrittenExtentsFtraceEventReader) u32 {
        return self._allocated;
    }
    pub inline fn getNewblk(self: *const Ext4ExtHandleUnwrittenExtentsFtraceEventReader) u64 {
        return self._newblk;
    }
};
const Ext4ExtInCacheFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const LBLK_WIRE: gremlin.ProtoWireNumber = 3;
    const RET_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const Ext4ExtInCacheFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    lblk: u32 = 0,
    ret: i32 = 0,
    pub fn calcProtobufSize(self: *const Ext4ExtInCacheFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtInCacheFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtInCacheFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.lblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtInCacheFtraceEventWire.LBLK_WIRE) + gremlin.sizes.sizeU32(self.lblk);
        }
        if (self.ret != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtInCacheFtraceEventWire.RET_WIRE) + gremlin.sizes.sizeI32(self.ret);
        }
        return res;
    }
    pub fn encode(self: *const Ext4ExtInCacheFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4ExtInCacheFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4ExtInCacheFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4ExtInCacheFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.lblk != 0) {
            target.appendUint32(Ext4ExtInCacheFtraceEventWire.LBLK_WIRE, self.lblk);
        }
        if (self.ret != 0) {
            target.appendInt32(Ext4ExtInCacheFtraceEventWire.RET_WIRE, self.ret);
        }
    }
};
pub const Ext4ExtInCacheFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _lblk: u32 = 0,
    _ret: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4ExtInCacheFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4ExtInCacheFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4ExtInCacheFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4ExtInCacheFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4ExtInCacheFtraceEventWire.LBLK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._lblk = result.value;
                },
                Ext4ExtInCacheFtraceEventWire.RET_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._ret = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4ExtInCacheFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4ExtInCacheFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getLblk(self: *const Ext4ExtInCacheFtraceEventReader) u32 {
        return self._lblk;
    }
    pub inline fn getRet(self: *const Ext4ExtInCacheFtraceEventReader) i32 {
        return self._ret;
    }
};
const Ext4ExtLoadExtentFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const PBLK_WIRE: gremlin.ProtoWireNumber = 3;
    const LBLK_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const Ext4ExtLoadExtentFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    pblk: u64 = 0,
    lblk: u32 = 0,
    pub fn calcProtobufSize(self: *const Ext4ExtLoadExtentFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtLoadExtentFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtLoadExtentFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.pblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtLoadExtentFtraceEventWire.PBLK_WIRE) + gremlin.sizes.sizeU64(self.pblk);
        }
        if (self.lblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtLoadExtentFtraceEventWire.LBLK_WIRE) + gremlin.sizes.sizeU32(self.lblk);
        }
        return res;
    }
    pub fn encode(self: *const Ext4ExtLoadExtentFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4ExtLoadExtentFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4ExtLoadExtentFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4ExtLoadExtentFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.pblk != 0) {
            target.appendUint64(Ext4ExtLoadExtentFtraceEventWire.PBLK_WIRE, self.pblk);
        }
        if (self.lblk != 0) {
            target.appendUint32(Ext4ExtLoadExtentFtraceEventWire.LBLK_WIRE, self.lblk);
        }
    }
};
pub const Ext4ExtLoadExtentFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _pblk: u64 = 0,
    _lblk: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4ExtLoadExtentFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4ExtLoadExtentFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4ExtLoadExtentFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4ExtLoadExtentFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4ExtLoadExtentFtraceEventWire.PBLK_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._pblk = result.value;
                },
                Ext4ExtLoadExtentFtraceEventWire.LBLK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._lblk = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4ExtLoadExtentFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4ExtLoadExtentFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getPblk(self: *const Ext4ExtLoadExtentFtraceEventReader) u64 {
        return self._pblk;
    }
    pub inline fn getLblk(self: *const Ext4ExtLoadExtentFtraceEventReader) u32 {
        return self._lblk;
    }
};
const Ext4ExtMapBlocksEnterFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const LBLK_WIRE: gremlin.ProtoWireNumber = 3;
    const LEN_WIRE: gremlin.ProtoWireNumber = 4;
    const FLAGS_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const Ext4ExtMapBlocksEnterFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    lblk: u32 = 0,
    len: u32 = 0,
    flags: u32 = 0,
    pub fn calcProtobufSize(self: *const Ext4ExtMapBlocksEnterFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtMapBlocksEnterFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtMapBlocksEnterFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.lblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtMapBlocksEnterFtraceEventWire.LBLK_WIRE) + gremlin.sizes.sizeU32(self.lblk);
        }
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtMapBlocksEnterFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeU32(self.len);
        }
        if (self.flags != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtMapBlocksEnterFtraceEventWire.FLAGS_WIRE) + gremlin.sizes.sizeU32(self.flags);
        }
        return res;
    }
    pub fn encode(self: *const Ext4ExtMapBlocksEnterFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4ExtMapBlocksEnterFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4ExtMapBlocksEnterFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4ExtMapBlocksEnterFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.lblk != 0) {
            target.appendUint32(Ext4ExtMapBlocksEnterFtraceEventWire.LBLK_WIRE, self.lblk);
        }
        if (self.len != 0) {
            target.appendUint32(Ext4ExtMapBlocksEnterFtraceEventWire.LEN_WIRE, self.len);
        }
        if (self.flags != 0) {
            target.appendUint32(Ext4ExtMapBlocksEnterFtraceEventWire.FLAGS_WIRE, self.flags);
        }
    }
};
pub const Ext4ExtMapBlocksEnterFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _lblk: u32 = 0,
    _len: u32 = 0,
    _flags: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4ExtMapBlocksEnterFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4ExtMapBlocksEnterFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4ExtMapBlocksEnterFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4ExtMapBlocksEnterFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4ExtMapBlocksEnterFtraceEventWire.LBLK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._lblk = result.value;
                },
                Ext4ExtMapBlocksEnterFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                Ext4ExtMapBlocksEnterFtraceEventWire.FLAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._flags = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4ExtMapBlocksEnterFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4ExtMapBlocksEnterFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getLblk(self: *const Ext4ExtMapBlocksEnterFtraceEventReader) u32 {
        return self._lblk;
    }
    pub inline fn getLen(self: *const Ext4ExtMapBlocksEnterFtraceEventReader) u32 {
        return self._len;
    }
    pub inline fn getFlags(self: *const Ext4ExtMapBlocksEnterFtraceEventReader) u32 {
        return self._flags;
    }
};
const Ext4ExtMapBlocksExitFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const FLAGS_WIRE: gremlin.ProtoWireNumber = 3;
    const PBLK_WIRE: gremlin.ProtoWireNumber = 4;
    const LBLK_WIRE: gremlin.ProtoWireNumber = 5;
    const LEN_WIRE: gremlin.ProtoWireNumber = 6;
    const MFLAGS_WIRE: gremlin.ProtoWireNumber = 7;
    const RET_WIRE: gremlin.ProtoWireNumber = 8;
};
pub const Ext4ExtMapBlocksExitFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    flags: u32 = 0,
    pblk: u64 = 0,
    lblk: u32 = 0,
    len: u32 = 0,
    mflags: u32 = 0,
    ret: i32 = 0,
    pub fn calcProtobufSize(self: *const Ext4ExtMapBlocksExitFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtMapBlocksExitFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtMapBlocksExitFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.flags != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtMapBlocksExitFtraceEventWire.FLAGS_WIRE) + gremlin.sizes.sizeU32(self.flags);
        }
        if (self.pblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtMapBlocksExitFtraceEventWire.PBLK_WIRE) + gremlin.sizes.sizeU64(self.pblk);
        }
        if (self.lblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtMapBlocksExitFtraceEventWire.LBLK_WIRE) + gremlin.sizes.sizeU32(self.lblk);
        }
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtMapBlocksExitFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeU32(self.len);
        }
        if (self.mflags != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtMapBlocksExitFtraceEventWire.MFLAGS_WIRE) + gremlin.sizes.sizeU32(self.mflags);
        }
        if (self.ret != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtMapBlocksExitFtraceEventWire.RET_WIRE) + gremlin.sizes.sizeI32(self.ret);
        }
        return res;
    }
    pub fn encode(self: *const Ext4ExtMapBlocksExitFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4ExtMapBlocksExitFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4ExtMapBlocksExitFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4ExtMapBlocksExitFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.flags != 0) {
            target.appendUint32(Ext4ExtMapBlocksExitFtraceEventWire.FLAGS_WIRE, self.flags);
        }
        if (self.pblk != 0) {
            target.appendUint64(Ext4ExtMapBlocksExitFtraceEventWire.PBLK_WIRE, self.pblk);
        }
        if (self.lblk != 0) {
            target.appendUint32(Ext4ExtMapBlocksExitFtraceEventWire.LBLK_WIRE, self.lblk);
        }
        if (self.len != 0) {
            target.appendUint32(Ext4ExtMapBlocksExitFtraceEventWire.LEN_WIRE, self.len);
        }
        if (self.mflags != 0) {
            target.appendUint32(Ext4ExtMapBlocksExitFtraceEventWire.MFLAGS_WIRE, self.mflags);
        }
        if (self.ret != 0) {
            target.appendInt32(Ext4ExtMapBlocksExitFtraceEventWire.RET_WIRE, self.ret);
        }
    }
};
pub const Ext4ExtMapBlocksExitFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _flags: u32 = 0,
    _pblk: u64 = 0,
    _lblk: u32 = 0,
    _len: u32 = 0,
    _mflags: u32 = 0,
    _ret: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4ExtMapBlocksExitFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4ExtMapBlocksExitFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4ExtMapBlocksExitFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4ExtMapBlocksExitFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4ExtMapBlocksExitFtraceEventWire.FLAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._flags = result.value;
                },
                Ext4ExtMapBlocksExitFtraceEventWire.PBLK_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._pblk = result.value;
                },
                Ext4ExtMapBlocksExitFtraceEventWire.LBLK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._lblk = result.value;
                },
                Ext4ExtMapBlocksExitFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                Ext4ExtMapBlocksExitFtraceEventWire.MFLAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._mflags = result.value;
                },
                Ext4ExtMapBlocksExitFtraceEventWire.RET_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._ret = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4ExtMapBlocksExitFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4ExtMapBlocksExitFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getFlags(self: *const Ext4ExtMapBlocksExitFtraceEventReader) u32 {
        return self._flags;
    }
    pub inline fn getPblk(self: *const Ext4ExtMapBlocksExitFtraceEventReader) u64 {
        return self._pblk;
    }
    pub inline fn getLblk(self: *const Ext4ExtMapBlocksExitFtraceEventReader) u32 {
        return self._lblk;
    }
    pub inline fn getLen(self: *const Ext4ExtMapBlocksExitFtraceEventReader) u32 {
        return self._len;
    }
    pub inline fn getMflags(self: *const Ext4ExtMapBlocksExitFtraceEventReader) u32 {
        return self._mflags;
    }
    pub inline fn getRet(self: *const Ext4ExtMapBlocksExitFtraceEventReader) i32 {
        return self._ret;
    }
};
const Ext4ExtPutInCacheFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const LBLK_WIRE: gremlin.ProtoWireNumber = 3;
    const LEN_WIRE: gremlin.ProtoWireNumber = 4;
    const START_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const Ext4ExtPutInCacheFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    lblk: u32 = 0,
    len: u32 = 0,
    start: u64 = 0,
    pub fn calcProtobufSize(self: *const Ext4ExtPutInCacheFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtPutInCacheFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtPutInCacheFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.lblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtPutInCacheFtraceEventWire.LBLK_WIRE) + gremlin.sizes.sizeU32(self.lblk);
        }
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtPutInCacheFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeU32(self.len);
        }
        if (self.start != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtPutInCacheFtraceEventWire.START_WIRE) + gremlin.sizes.sizeU64(self.start);
        }
        return res;
    }
    pub fn encode(self: *const Ext4ExtPutInCacheFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4ExtPutInCacheFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4ExtPutInCacheFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4ExtPutInCacheFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.lblk != 0) {
            target.appendUint32(Ext4ExtPutInCacheFtraceEventWire.LBLK_WIRE, self.lblk);
        }
        if (self.len != 0) {
            target.appendUint32(Ext4ExtPutInCacheFtraceEventWire.LEN_WIRE, self.len);
        }
        if (self.start != 0) {
            target.appendUint64(Ext4ExtPutInCacheFtraceEventWire.START_WIRE, self.start);
        }
    }
};
pub const Ext4ExtPutInCacheFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _lblk: u32 = 0,
    _len: u32 = 0,
    _start: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4ExtPutInCacheFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4ExtPutInCacheFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4ExtPutInCacheFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4ExtPutInCacheFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4ExtPutInCacheFtraceEventWire.LBLK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._lblk = result.value;
                },
                Ext4ExtPutInCacheFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                Ext4ExtPutInCacheFtraceEventWire.START_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._start = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4ExtPutInCacheFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4ExtPutInCacheFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getLblk(self: *const Ext4ExtPutInCacheFtraceEventReader) u32 {
        return self._lblk;
    }
    pub inline fn getLen(self: *const Ext4ExtPutInCacheFtraceEventReader) u32 {
        return self._len;
    }
    pub inline fn getStart(self: *const Ext4ExtPutInCacheFtraceEventReader) u64 {
        return self._start;
    }
};
const Ext4ExtRemoveSpaceFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const START_WIRE: gremlin.ProtoWireNumber = 3;
    const END_WIRE: gremlin.ProtoWireNumber = 4;
    const DEPTH_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const Ext4ExtRemoveSpaceFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    start: u32 = 0,
    end: u32 = 0,
    depth: i32 = 0,
    pub fn calcProtobufSize(self: *const Ext4ExtRemoveSpaceFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtRemoveSpaceFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtRemoveSpaceFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.start != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtRemoveSpaceFtraceEventWire.START_WIRE) + gremlin.sizes.sizeU32(self.start);
        }
        if (self.end != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtRemoveSpaceFtraceEventWire.END_WIRE) + gremlin.sizes.sizeU32(self.end);
        }
        if (self.depth != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtRemoveSpaceFtraceEventWire.DEPTH_WIRE) + gremlin.sizes.sizeI32(self.depth);
        }
        return res;
    }
    pub fn encode(self: *const Ext4ExtRemoveSpaceFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4ExtRemoveSpaceFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4ExtRemoveSpaceFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4ExtRemoveSpaceFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.start != 0) {
            target.appendUint32(Ext4ExtRemoveSpaceFtraceEventWire.START_WIRE, self.start);
        }
        if (self.end != 0) {
            target.appendUint32(Ext4ExtRemoveSpaceFtraceEventWire.END_WIRE, self.end);
        }
        if (self.depth != 0) {
            target.appendInt32(Ext4ExtRemoveSpaceFtraceEventWire.DEPTH_WIRE, self.depth);
        }
    }
};
pub const Ext4ExtRemoveSpaceFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _start: u32 = 0,
    _end: u32 = 0,
    _depth: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4ExtRemoveSpaceFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4ExtRemoveSpaceFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4ExtRemoveSpaceFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4ExtRemoveSpaceFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4ExtRemoveSpaceFtraceEventWire.START_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._start = result.value;
                },
                Ext4ExtRemoveSpaceFtraceEventWire.END_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._end = result.value;
                },
                Ext4ExtRemoveSpaceFtraceEventWire.DEPTH_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._depth = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4ExtRemoveSpaceFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4ExtRemoveSpaceFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getStart(self: *const Ext4ExtRemoveSpaceFtraceEventReader) u32 {
        return self._start;
    }
    pub inline fn getEnd(self: *const Ext4ExtRemoveSpaceFtraceEventReader) u32 {
        return self._end;
    }
    pub inline fn getDepth(self: *const Ext4ExtRemoveSpaceFtraceEventReader) i32 {
        return self._depth;
    }
};
const Ext4ExtRemoveSpaceDoneFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const START_WIRE: gremlin.ProtoWireNumber = 3;
    const END_WIRE: gremlin.ProtoWireNumber = 4;
    const DEPTH_WIRE: gremlin.ProtoWireNumber = 5;
    const PARTIAL_WIRE: gremlin.ProtoWireNumber = 6;
    const EH_ENTRIES_WIRE: gremlin.ProtoWireNumber = 7;
    const PC_LBLK_WIRE: gremlin.ProtoWireNumber = 8;
    const PC_PCLU_WIRE: gremlin.ProtoWireNumber = 9;
    const PC_STATE_WIRE: gremlin.ProtoWireNumber = 10;
};
pub const Ext4ExtRemoveSpaceDoneFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    start: u32 = 0,
    end: u32 = 0,
    depth: i32 = 0,
    partial: i64 = 0,
    eh_entries: u32 = 0,
    pc_lblk: u32 = 0,
    pc_pclu: u64 = 0,
    pc_state: i32 = 0,
    pub fn calcProtobufSize(self: *const Ext4ExtRemoveSpaceDoneFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtRemoveSpaceDoneFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtRemoveSpaceDoneFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.start != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtRemoveSpaceDoneFtraceEventWire.START_WIRE) + gremlin.sizes.sizeU32(self.start);
        }
        if (self.end != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtRemoveSpaceDoneFtraceEventWire.END_WIRE) + gremlin.sizes.sizeU32(self.end);
        }
        if (self.depth != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtRemoveSpaceDoneFtraceEventWire.DEPTH_WIRE) + gremlin.sizes.sizeI32(self.depth);
        }
        if (self.partial != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtRemoveSpaceDoneFtraceEventWire.PARTIAL_WIRE) + gremlin.sizes.sizeI64(self.partial);
        }
        if (self.eh_entries != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtRemoveSpaceDoneFtraceEventWire.EH_ENTRIES_WIRE) + gremlin.sizes.sizeU32(self.eh_entries);
        }
        if (self.pc_lblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtRemoveSpaceDoneFtraceEventWire.PC_LBLK_WIRE) + gremlin.sizes.sizeU32(self.pc_lblk);
        }
        if (self.pc_pclu != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtRemoveSpaceDoneFtraceEventWire.PC_PCLU_WIRE) + gremlin.sizes.sizeU64(self.pc_pclu);
        }
        if (self.pc_state != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtRemoveSpaceDoneFtraceEventWire.PC_STATE_WIRE) + gremlin.sizes.sizeI32(self.pc_state);
        }
        return res;
    }
    pub fn encode(self: *const Ext4ExtRemoveSpaceDoneFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4ExtRemoveSpaceDoneFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4ExtRemoveSpaceDoneFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4ExtRemoveSpaceDoneFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.start != 0) {
            target.appendUint32(Ext4ExtRemoveSpaceDoneFtraceEventWire.START_WIRE, self.start);
        }
        if (self.end != 0) {
            target.appendUint32(Ext4ExtRemoveSpaceDoneFtraceEventWire.END_WIRE, self.end);
        }
        if (self.depth != 0) {
            target.appendInt32(Ext4ExtRemoveSpaceDoneFtraceEventWire.DEPTH_WIRE, self.depth);
        }
        if (self.partial != 0) {
            target.appendInt64(Ext4ExtRemoveSpaceDoneFtraceEventWire.PARTIAL_WIRE, self.partial);
        }
        if (self.eh_entries != 0) {
            target.appendUint32(Ext4ExtRemoveSpaceDoneFtraceEventWire.EH_ENTRIES_WIRE, self.eh_entries);
        }
        if (self.pc_lblk != 0) {
            target.appendUint32(Ext4ExtRemoveSpaceDoneFtraceEventWire.PC_LBLK_WIRE, self.pc_lblk);
        }
        if (self.pc_pclu != 0) {
            target.appendUint64(Ext4ExtRemoveSpaceDoneFtraceEventWire.PC_PCLU_WIRE, self.pc_pclu);
        }
        if (self.pc_state != 0) {
            target.appendInt32(Ext4ExtRemoveSpaceDoneFtraceEventWire.PC_STATE_WIRE, self.pc_state);
        }
    }
};
pub const Ext4ExtRemoveSpaceDoneFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _start: u32 = 0,
    _end: u32 = 0,
    _depth: i32 = 0,
    _partial: i64 = 0,
    _eh_entries: u32 = 0,
    _pc_lblk: u32 = 0,
    _pc_pclu: u64 = 0,
    _pc_state: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4ExtRemoveSpaceDoneFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4ExtRemoveSpaceDoneFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4ExtRemoveSpaceDoneFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4ExtRemoveSpaceDoneFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4ExtRemoveSpaceDoneFtraceEventWire.START_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._start = result.value;
                },
                Ext4ExtRemoveSpaceDoneFtraceEventWire.END_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._end = result.value;
                },
                Ext4ExtRemoveSpaceDoneFtraceEventWire.DEPTH_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._depth = result.value;
                },
                Ext4ExtRemoveSpaceDoneFtraceEventWire.PARTIAL_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._partial = result.value;
                },
                Ext4ExtRemoveSpaceDoneFtraceEventWire.EH_ENTRIES_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._eh_entries = result.value;
                },
                Ext4ExtRemoveSpaceDoneFtraceEventWire.PC_LBLK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._pc_lblk = result.value;
                },
                Ext4ExtRemoveSpaceDoneFtraceEventWire.PC_PCLU_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._pc_pclu = result.value;
                },
                Ext4ExtRemoveSpaceDoneFtraceEventWire.PC_STATE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._pc_state = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4ExtRemoveSpaceDoneFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4ExtRemoveSpaceDoneFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getStart(self: *const Ext4ExtRemoveSpaceDoneFtraceEventReader) u32 {
        return self._start;
    }
    pub inline fn getEnd(self: *const Ext4ExtRemoveSpaceDoneFtraceEventReader) u32 {
        return self._end;
    }
    pub inline fn getDepth(self: *const Ext4ExtRemoveSpaceDoneFtraceEventReader) i32 {
        return self._depth;
    }
    pub inline fn getPartial(self: *const Ext4ExtRemoveSpaceDoneFtraceEventReader) i64 {
        return self._partial;
    }
    pub inline fn getEhEntries(self: *const Ext4ExtRemoveSpaceDoneFtraceEventReader) u32 {
        return self._eh_entries;
    }
    pub inline fn getPcLblk(self: *const Ext4ExtRemoveSpaceDoneFtraceEventReader) u32 {
        return self._pc_lblk;
    }
    pub inline fn getPcPclu(self: *const Ext4ExtRemoveSpaceDoneFtraceEventReader) u64 {
        return self._pc_pclu;
    }
    pub inline fn getPcState(self: *const Ext4ExtRemoveSpaceDoneFtraceEventReader) i32 {
        return self._pc_state;
    }
};
const Ext4ExtRmIdxFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const PBLK_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const Ext4ExtRmIdxFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    pblk: u64 = 0,
    pub fn calcProtobufSize(self: *const Ext4ExtRmIdxFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtRmIdxFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtRmIdxFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.pblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtRmIdxFtraceEventWire.PBLK_WIRE) + gremlin.sizes.sizeU64(self.pblk);
        }
        return res;
    }
    pub fn encode(self: *const Ext4ExtRmIdxFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4ExtRmIdxFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4ExtRmIdxFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4ExtRmIdxFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.pblk != 0) {
            target.appendUint64(Ext4ExtRmIdxFtraceEventWire.PBLK_WIRE, self.pblk);
        }
    }
};
pub const Ext4ExtRmIdxFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _pblk: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4ExtRmIdxFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4ExtRmIdxFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4ExtRmIdxFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4ExtRmIdxFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4ExtRmIdxFtraceEventWire.PBLK_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._pblk = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4ExtRmIdxFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4ExtRmIdxFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getPblk(self: *const Ext4ExtRmIdxFtraceEventReader) u64 {
        return self._pblk;
    }
};
const Ext4ExtRmLeafFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const PARTIAL_WIRE: gremlin.ProtoWireNumber = 3;
    const START_WIRE: gremlin.ProtoWireNumber = 4;
    const EE_LBLK_WIRE: gremlin.ProtoWireNumber = 5;
    const EE_PBLK_WIRE: gremlin.ProtoWireNumber = 6;
    const EE_LEN_WIRE: gremlin.ProtoWireNumber = 7;
    const PC_LBLK_WIRE: gremlin.ProtoWireNumber = 8;
    const PC_PCLU_WIRE: gremlin.ProtoWireNumber = 9;
    const PC_STATE_WIRE: gremlin.ProtoWireNumber = 10;
};
pub const Ext4ExtRmLeafFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    partial: i64 = 0,
    start: u32 = 0,
    ee_lblk: u32 = 0,
    ee_pblk: u64 = 0,
    ee_len: i32 = 0,
    pc_lblk: u32 = 0,
    pc_pclu: u64 = 0,
    pc_state: i32 = 0,
    pub fn calcProtobufSize(self: *const Ext4ExtRmLeafFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtRmLeafFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtRmLeafFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.partial != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtRmLeafFtraceEventWire.PARTIAL_WIRE) + gremlin.sizes.sizeI64(self.partial);
        }
        if (self.start != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtRmLeafFtraceEventWire.START_WIRE) + gremlin.sizes.sizeU32(self.start);
        }
        if (self.ee_lblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtRmLeafFtraceEventWire.EE_LBLK_WIRE) + gremlin.sizes.sizeU32(self.ee_lblk);
        }
        if (self.ee_pblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtRmLeafFtraceEventWire.EE_PBLK_WIRE) + gremlin.sizes.sizeU64(self.ee_pblk);
        }
        if (self.ee_len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtRmLeafFtraceEventWire.EE_LEN_WIRE) + gremlin.sizes.sizeI32(self.ee_len);
        }
        if (self.pc_lblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtRmLeafFtraceEventWire.PC_LBLK_WIRE) + gremlin.sizes.sizeU32(self.pc_lblk);
        }
        if (self.pc_pclu != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtRmLeafFtraceEventWire.PC_PCLU_WIRE) + gremlin.sizes.sizeU64(self.pc_pclu);
        }
        if (self.pc_state != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtRmLeafFtraceEventWire.PC_STATE_WIRE) + gremlin.sizes.sizeI32(self.pc_state);
        }
        return res;
    }
    pub fn encode(self: *const Ext4ExtRmLeafFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4ExtRmLeafFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4ExtRmLeafFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4ExtRmLeafFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.partial != 0) {
            target.appendInt64(Ext4ExtRmLeafFtraceEventWire.PARTIAL_WIRE, self.partial);
        }
        if (self.start != 0) {
            target.appendUint32(Ext4ExtRmLeafFtraceEventWire.START_WIRE, self.start);
        }
        if (self.ee_lblk != 0) {
            target.appendUint32(Ext4ExtRmLeafFtraceEventWire.EE_LBLK_WIRE, self.ee_lblk);
        }
        if (self.ee_pblk != 0) {
            target.appendUint64(Ext4ExtRmLeafFtraceEventWire.EE_PBLK_WIRE, self.ee_pblk);
        }
        if (self.ee_len != 0) {
            target.appendInt32(Ext4ExtRmLeafFtraceEventWire.EE_LEN_WIRE, self.ee_len);
        }
        if (self.pc_lblk != 0) {
            target.appendUint32(Ext4ExtRmLeafFtraceEventWire.PC_LBLK_WIRE, self.pc_lblk);
        }
        if (self.pc_pclu != 0) {
            target.appendUint64(Ext4ExtRmLeafFtraceEventWire.PC_PCLU_WIRE, self.pc_pclu);
        }
        if (self.pc_state != 0) {
            target.appendInt32(Ext4ExtRmLeafFtraceEventWire.PC_STATE_WIRE, self.pc_state);
        }
    }
};
pub const Ext4ExtRmLeafFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _partial: i64 = 0,
    _start: u32 = 0,
    _ee_lblk: u32 = 0,
    _ee_pblk: u64 = 0,
    _ee_len: i32 = 0,
    _pc_lblk: u32 = 0,
    _pc_pclu: u64 = 0,
    _pc_state: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4ExtRmLeafFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4ExtRmLeafFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4ExtRmLeafFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4ExtRmLeafFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4ExtRmLeafFtraceEventWire.PARTIAL_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._partial = result.value;
                },
                Ext4ExtRmLeafFtraceEventWire.START_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._start = result.value;
                },
                Ext4ExtRmLeafFtraceEventWire.EE_LBLK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._ee_lblk = result.value;
                },
                Ext4ExtRmLeafFtraceEventWire.EE_PBLK_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ee_pblk = result.value;
                },
                Ext4ExtRmLeafFtraceEventWire.EE_LEN_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._ee_len = result.value;
                },
                Ext4ExtRmLeafFtraceEventWire.PC_LBLK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._pc_lblk = result.value;
                },
                Ext4ExtRmLeafFtraceEventWire.PC_PCLU_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._pc_pclu = result.value;
                },
                Ext4ExtRmLeafFtraceEventWire.PC_STATE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._pc_state = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4ExtRmLeafFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4ExtRmLeafFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getPartial(self: *const Ext4ExtRmLeafFtraceEventReader) i64 {
        return self._partial;
    }
    pub inline fn getStart(self: *const Ext4ExtRmLeafFtraceEventReader) u32 {
        return self._start;
    }
    pub inline fn getEeLblk(self: *const Ext4ExtRmLeafFtraceEventReader) u32 {
        return self._ee_lblk;
    }
    pub inline fn getEePblk(self: *const Ext4ExtRmLeafFtraceEventReader) u64 {
        return self._ee_pblk;
    }
    pub inline fn getEeLen(self: *const Ext4ExtRmLeafFtraceEventReader) i32 {
        return self._ee_len;
    }
    pub inline fn getPcLblk(self: *const Ext4ExtRmLeafFtraceEventReader) u32 {
        return self._pc_lblk;
    }
    pub inline fn getPcPclu(self: *const Ext4ExtRmLeafFtraceEventReader) u64 {
        return self._pc_pclu;
    }
    pub inline fn getPcState(self: *const Ext4ExtRmLeafFtraceEventReader) i32 {
        return self._pc_state;
    }
};
const Ext4ExtShowExtentFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const PBLK_WIRE: gremlin.ProtoWireNumber = 3;
    const LBLK_WIRE: gremlin.ProtoWireNumber = 4;
    const LEN_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const Ext4ExtShowExtentFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    pblk: u64 = 0,
    lblk: u32 = 0,
    len: u32 = 0,
    pub fn calcProtobufSize(self: *const Ext4ExtShowExtentFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtShowExtentFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtShowExtentFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.pblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtShowExtentFtraceEventWire.PBLK_WIRE) + gremlin.sizes.sizeU64(self.pblk);
        }
        if (self.lblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtShowExtentFtraceEventWire.LBLK_WIRE) + gremlin.sizes.sizeU32(self.lblk);
        }
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ExtShowExtentFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeU32(self.len);
        }
        return res;
    }
    pub fn encode(self: *const Ext4ExtShowExtentFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4ExtShowExtentFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4ExtShowExtentFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4ExtShowExtentFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.pblk != 0) {
            target.appendUint64(Ext4ExtShowExtentFtraceEventWire.PBLK_WIRE, self.pblk);
        }
        if (self.lblk != 0) {
            target.appendUint32(Ext4ExtShowExtentFtraceEventWire.LBLK_WIRE, self.lblk);
        }
        if (self.len != 0) {
            target.appendUint32(Ext4ExtShowExtentFtraceEventWire.LEN_WIRE, self.len);
        }
    }
};
pub const Ext4ExtShowExtentFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _pblk: u64 = 0,
    _lblk: u32 = 0,
    _len: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4ExtShowExtentFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4ExtShowExtentFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4ExtShowExtentFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4ExtShowExtentFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4ExtShowExtentFtraceEventWire.PBLK_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._pblk = result.value;
                },
                Ext4ExtShowExtentFtraceEventWire.LBLK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._lblk = result.value;
                },
                Ext4ExtShowExtentFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4ExtShowExtentFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4ExtShowExtentFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getPblk(self: *const Ext4ExtShowExtentFtraceEventReader) u64 {
        return self._pblk;
    }
    pub inline fn getLblk(self: *const Ext4ExtShowExtentFtraceEventReader) u32 {
        return self._lblk;
    }
    pub inline fn getLen(self: *const Ext4ExtShowExtentFtraceEventReader) u32 {
        return self._len;
    }
};
const Ext4FallocateEnterFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const OFFSET_WIRE: gremlin.ProtoWireNumber = 3;
    const LEN_WIRE: gremlin.ProtoWireNumber = 4;
    const MODE_WIRE: gremlin.ProtoWireNumber = 5;
    const POS_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const Ext4FallocateEnterFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    offset: i64 = 0,
    len: i64 = 0,
    mode: i32 = 0,
    pos: i64 = 0,
    pub fn calcProtobufSize(self: *const Ext4FallocateEnterFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4FallocateEnterFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4FallocateEnterFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.offset != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4FallocateEnterFtraceEventWire.OFFSET_WIRE) + gremlin.sizes.sizeI64(self.offset);
        }
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4FallocateEnterFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeI64(self.len);
        }
        if (self.mode != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4FallocateEnterFtraceEventWire.MODE_WIRE) + gremlin.sizes.sizeI32(self.mode);
        }
        if (self.pos != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4FallocateEnterFtraceEventWire.POS_WIRE) + gremlin.sizes.sizeI64(self.pos);
        }
        return res;
    }
    pub fn encode(self: *const Ext4FallocateEnterFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4FallocateEnterFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4FallocateEnterFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4FallocateEnterFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.offset != 0) {
            target.appendInt64(Ext4FallocateEnterFtraceEventWire.OFFSET_WIRE, self.offset);
        }
        if (self.len != 0) {
            target.appendInt64(Ext4FallocateEnterFtraceEventWire.LEN_WIRE, self.len);
        }
        if (self.mode != 0) {
            target.appendInt32(Ext4FallocateEnterFtraceEventWire.MODE_WIRE, self.mode);
        }
        if (self.pos != 0) {
            target.appendInt64(Ext4FallocateEnterFtraceEventWire.POS_WIRE, self.pos);
        }
    }
};
pub const Ext4FallocateEnterFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _offset: i64 = 0,
    _len: i64 = 0,
    _mode: i32 = 0,
    _pos: i64 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4FallocateEnterFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4FallocateEnterFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4FallocateEnterFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4FallocateEnterFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4FallocateEnterFtraceEventWire.OFFSET_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._offset = result.value;
                },
                Ext4FallocateEnterFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                Ext4FallocateEnterFtraceEventWire.MODE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._mode = result.value;
                },
                Ext4FallocateEnterFtraceEventWire.POS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._pos = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4FallocateEnterFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4FallocateEnterFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getOffset(self: *const Ext4FallocateEnterFtraceEventReader) i64 {
        return self._offset;
    }
    pub inline fn getLen(self: *const Ext4FallocateEnterFtraceEventReader) i64 {
        return self._len;
    }
    pub inline fn getMode(self: *const Ext4FallocateEnterFtraceEventReader) i32 {
        return self._mode;
    }
    pub inline fn getPos(self: *const Ext4FallocateEnterFtraceEventReader) i64 {
        return self._pos;
    }
};
const Ext4FallocateExitFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const POS_WIRE: gremlin.ProtoWireNumber = 3;
    const BLOCKS_WIRE: gremlin.ProtoWireNumber = 4;
    const RET_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const Ext4FallocateExitFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    pos: i64 = 0,
    blocks: u32 = 0,
    ret: i32 = 0,
    pub fn calcProtobufSize(self: *const Ext4FallocateExitFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4FallocateExitFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4FallocateExitFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.pos != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4FallocateExitFtraceEventWire.POS_WIRE) + gremlin.sizes.sizeI64(self.pos);
        }
        if (self.blocks != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4FallocateExitFtraceEventWire.BLOCKS_WIRE) + gremlin.sizes.sizeU32(self.blocks);
        }
        if (self.ret != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4FallocateExitFtraceEventWire.RET_WIRE) + gremlin.sizes.sizeI32(self.ret);
        }
        return res;
    }
    pub fn encode(self: *const Ext4FallocateExitFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4FallocateExitFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4FallocateExitFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4FallocateExitFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.pos != 0) {
            target.appendInt64(Ext4FallocateExitFtraceEventWire.POS_WIRE, self.pos);
        }
        if (self.blocks != 0) {
            target.appendUint32(Ext4FallocateExitFtraceEventWire.BLOCKS_WIRE, self.blocks);
        }
        if (self.ret != 0) {
            target.appendInt32(Ext4FallocateExitFtraceEventWire.RET_WIRE, self.ret);
        }
    }
};
pub const Ext4FallocateExitFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _pos: i64 = 0,
    _blocks: u32 = 0,
    _ret: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4FallocateExitFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4FallocateExitFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4FallocateExitFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4FallocateExitFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4FallocateExitFtraceEventWire.POS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._pos = result.value;
                },
                Ext4FallocateExitFtraceEventWire.BLOCKS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._blocks = result.value;
                },
                Ext4FallocateExitFtraceEventWire.RET_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._ret = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4FallocateExitFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4FallocateExitFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getPos(self: *const Ext4FallocateExitFtraceEventReader) i64 {
        return self._pos;
    }
    pub inline fn getBlocks(self: *const Ext4FallocateExitFtraceEventReader) u32 {
        return self._blocks;
    }
    pub inline fn getRet(self: *const Ext4FallocateExitFtraceEventReader) i32 {
        return self._ret;
    }
};
const Ext4FindDelallocRangeFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const FROM_WIRE: gremlin.ProtoWireNumber = 3;
    const TO_WIRE: gremlin.ProtoWireNumber = 4;
    const REVERSE_WIRE: gremlin.ProtoWireNumber = 5;
    const FOUND_WIRE: gremlin.ProtoWireNumber = 6;
    const FOUND_BLK_WIRE: gremlin.ProtoWireNumber = 7;
};
pub const Ext4FindDelallocRangeFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    from: u32 = 0,
    to: u32 = 0,
    reverse: i32 = 0,
    found: i32 = 0,
    found_blk: u32 = 0,
    pub fn calcProtobufSize(self: *const Ext4FindDelallocRangeFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4FindDelallocRangeFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4FindDelallocRangeFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.from != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4FindDelallocRangeFtraceEventWire.FROM_WIRE) + gremlin.sizes.sizeU32(self.from);
        }
        if (self.to != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4FindDelallocRangeFtraceEventWire.TO_WIRE) + gremlin.sizes.sizeU32(self.to);
        }
        if (self.reverse != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4FindDelallocRangeFtraceEventWire.REVERSE_WIRE) + gremlin.sizes.sizeI32(self.reverse);
        }
        if (self.found != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4FindDelallocRangeFtraceEventWire.FOUND_WIRE) + gremlin.sizes.sizeI32(self.found);
        }
        if (self.found_blk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4FindDelallocRangeFtraceEventWire.FOUND_BLK_WIRE) + gremlin.sizes.sizeU32(self.found_blk);
        }
        return res;
    }
    pub fn encode(self: *const Ext4FindDelallocRangeFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4FindDelallocRangeFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4FindDelallocRangeFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4FindDelallocRangeFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.from != 0) {
            target.appendUint32(Ext4FindDelallocRangeFtraceEventWire.FROM_WIRE, self.from);
        }
        if (self.to != 0) {
            target.appendUint32(Ext4FindDelallocRangeFtraceEventWire.TO_WIRE, self.to);
        }
        if (self.reverse != 0) {
            target.appendInt32(Ext4FindDelallocRangeFtraceEventWire.REVERSE_WIRE, self.reverse);
        }
        if (self.found != 0) {
            target.appendInt32(Ext4FindDelallocRangeFtraceEventWire.FOUND_WIRE, self.found);
        }
        if (self.found_blk != 0) {
            target.appendUint32(Ext4FindDelallocRangeFtraceEventWire.FOUND_BLK_WIRE, self.found_blk);
        }
    }
};
pub const Ext4FindDelallocRangeFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _from: u32 = 0,
    _to: u32 = 0,
    _reverse: i32 = 0,
    _found: i32 = 0,
    _found_blk: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4FindDelallocRangeFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4FindDelallocRangeFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4FindDelallocRangeFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4FindDelallocRangeFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4FindDelallocRangeFtraceEventWire.FROM_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._from = result.value;
                },
                Ext4FindDelallocRangeFtraceEventWire.TO_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._to = result.value;
                },
                Ext4FindDelallocRangeFtraceEventWire.REVERSE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._reverse = result.value;
                },
                Ext4FindDelallocRangeFtraceEventWire.FOUND_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._found = result.value;
                },
                Ext4FindDelallocRangeFtraceEventWire.FOUND_BLK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._found_blk = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4FindDelallocRangeFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4FindDelallocRangeFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getFrom(self: *const Ext4FindDelallocRangeFtraceEventReader) u32 {
        return self._from;
    }
    pub inline fn getTo(self: *const Ext4FindDelallocRangeFtraceEventReader) u32 {
        return self._to;
    }
    pub inline fn getReverse(self: *const Ext4FindDelallocRangeFtraceEventReader) i32 {
        return self._reverse;
    }
    pub inline fn getFound(self: *const Ext4FindDelallocRangeFtraceEventReader) i32 {
        return self._found;
    }
    pub inline fn getFoundBlk(self: *const Ext4FindDelallocRangeFtraceEventReader) u32 {
        return self._found_blk;
    }
};
const Ext4ForgetFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const BLOCK_WIRE: gremlin.ProtoWireNumber = 3;
    const IS_METADATA_WIRE: gremlin.ProtoWireNumber = 4;
    const MODE_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const Ext4ForgetFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    block: u64 = 0,
    is_metadata: i32 = 0,
    mode: u32 = 0,
    pub fn calcProtobufSize(self: *const Ext4ForgetFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ForgetFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ForgetFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.block != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ForgetFtraceEventWire.BLOCK_WIRE) + gremlin.sizes.sizeU64(self.block);
        }
        if (self.is_metadata != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ForgetFtraceEventWire.IS_METADATA_WIRE) + gremlin.sizes.sizeI32(self.is_metadata);
        }
        if (self.mode != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ForgetFtraceEventWire.MODE_WIRE) + gremlin.sizes.sizeU32(self.mode);
        }
        return res;
    }
    pub fn encode(self: *const Ext4ForgetFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4ForgetFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4ForgetFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4ForgetFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.block != 0) {
            target.appendUint64(Ext4ForgetFtraceEventWire.BLOCK_WIRE, self.block);
        }
        if (self.is_metadata != 0) {
            target.appendInt32(Ext4ForgetFtraceEventWire.IS_METADATA_WIRE, self.is_metadata);
        }
        if (self.mode != 0) {
            target.appendUint32(Ext4ForgetFtraceEventWire.MODE_WIRE, self.mode);
        }
    }
};
pub const Ext4ForgetFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _block: u64 = 0,
    _is_metadata: i32 = 0,
    _mode: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4ForgetFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4ForgetFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4ForgetFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4ForgetFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4ForgetFtraceEventWire.BLOCK_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._block = result.value;
                },
                Ext4ForgetFtraceEventWire.IS_METADATA_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._is_metadata = result.value;
                },
                Ext4ForgetFtraceEventWire.MODE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._mode = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4ForgetFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4ForgetFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getBlock(self: *const Ext4ForgetFtraceEventReader) u64 {
        return self._block;
    }
    pub inline fn getIsMetadata(self: *const Ext4ForgetFtraceEventReader) i32 {
        return self._is_metadata;
    }
    pub inline fn getMode(self: *const Ext4ForgetFtraceEventReader) u32 {
        return self._mode;
    }
};
const Ext4FreeBlocksFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const BLOCK_WIRE: gremlin.ProtoWireNumber = 3;
    const COUNT_WIRE: gremlin.ProtoWireNumber = 4;
    const FLAGS_WIRE: gremlin.ProtoWireNumber = 5;
    const MODE_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const Ext4FreeBlocksFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    block: u64 = 0,
    count: u64 = 0,
    flags: i32 = 0,
    mode: u32 = 0,
    pub fn calcProtobufSize(self: *const Ext4FreeBlocksFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4FreeBlocksFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4FreeBlocksFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.block != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4FreeBlocksFtraceEventWire.BLOCK_WIRE) + gremlin.sizes.sizeU64(self.block);
        }
        if (self.count != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4FreeBlocksFtraceEventWire.COUNT_WIRE) + gremlin.sizes.sizeU64(self.count);
        }
        if (self.flags != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4FreeBlocksFtraceEventWire.FLAGS_WIRE) + gremlin.sizes.sizeI32(self.flags);
        }
        if (self.mode != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4FreeBlocksFtraceEventWire.MODE_WIRE) + gremlin.sizes.sizeU32(self.mode);
        }
        return res;
    }
    pub fn encode(self: *const Ext4FreeBlocksFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4FreeBlocksFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4FreeBlocksFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4FreeBlocksFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.block != 0) {
            target.appendUint64(Ext4FreeBlocksFtraceEventWire.BLOCK_WIRE, self.block);
        }
        if (self.count != 0) {
            target.appendUint64(Ext4FreeBlocksFtraceEventWire.COUNT_WIRE, self.count);
        }
        if (self.flags != 0) {
            target.appendInt32(Ext4FreeBlocksFtraceEventWire.FLAGS_WIRE, self.flags);
        }
        if (self.mode != 0) {
            target.appendUint32(Ext4FreeBlocksFtraceEventWire.MODE_WIRE, self.mode);
        }
    }
};
pub const Ext4FreeBlocksFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _block: u64 = 0,
    _count: u64 = 0,
    _flags: i32 = 0,
    _mode: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4FreeBlocksFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4FreeBlocksFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4FreeBlocksFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4FreeBlocksFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4FreeBlocksFtraceEventWire.BLOCK_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._block = result.value;
                },
                Ext4FreeBlocksFtraceEventWire.COUNT_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._count = result.value;
                },
                Ext4FreeBlocksFtraceEventWire.FLAGS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._flags = result.value;
                },
                Ext4FreeBlocksFtraceEventWire.MODE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._mode = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4FreeBlocksFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4FreeBlocksFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getBlock(self: *const Ext4FreeBlocksFtraceEventReader) u64 {
        return self._block;
    }
    pub inline fn getCount(self: *const Ext4FreeBlocksFtraceEventReader) u64 {
        return self._count;
    }
    pub inline fn getFlags(self: *const Ext4FreeBlocksFtraceEventReader) i32 {
        return self._flags;
    }
    pub inline fn getMode(self: *const Ext4FreeBlocksFtraceEventReader) u32 {
        return self._mode;
    }
};
const Ext4FreeInodeFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const UID_WIRE: gremlin.ProtoWireNumber = 3;
    const GID_WIRE: gremlin.ProtoWireNumber = 4;
    const BLOCKS_WIRE: gremlin.ProtoWireNumber = 5;
    const MODE_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const Ext4FreeInodeFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    uid: u32 = 0,
    gid: u32 = 0,
    blocks: u64 = 0,
    mode: u32 = 0,
    pub fn calcProtobufSize(self: *const Ext4FreeInodeFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4FreeInodeFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4FreeInodeFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.uid != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4FreeInodeFtraceEventWire.UID_WIRE) + gremlin.sizes.sizeU32(self.uid);
        }
        if (self.gid != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4FreeInodeFtraceEventWire.GID_WIRE) + gremlin.sizes.sizeU32(self.gid);
        }
        if (self.blocks != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4FreeInodeFtraceEventWire.BLOCKS_WIRE) + gremlin.sizes.sizeU64(self.blocks);
        }
        if (self.mode != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4FreeInodeFtraceEventWire.MODE_WIRE) + gremlin.sizes.sizeU32(self.mode);
        }
        return res;
    }
    pub fn encode(self: *const Ext4FreeInodeFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4FreeInodeFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4FreeInodeFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4FreeInodeFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.uid != 0) {
            target.appendUint32(Ext4FreeInodeFtraceEventWire.UID_WIRE, self.uid);
        }
        if (self.gid != 0) {
            target.appendUint32(Ext4FreeInodeFtraceEventWire.GID_WIRE, self.gid);
        }
        if (self.blocks != 0) {
            target.appendUint64(Ext4FreeInodeFtraceEventWire.BLOCKS_WIRE, self.blocks);
        }
        if (self.mode != 0) {
            target.appendUint32(Ext4FreeInodeFtraceEventWire.MODE_WIRE, self.mode);
        }
    }
};
pub const Ext4FreeInodeFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _uid: u32 = 0,
    _gid: u32 = 0,
    _blocks: u64 = 0,
    _mode: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4FreeInodeFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4FreeInodeFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4FreeInodeFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4FreeInodeFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4FreeInodeFtraceEventWire.UID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._uid = result.value;
                },
                Ext4FreeInodeFtraceEventWire.GID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._gid = result.value;
                },
                Ext4FreeInodeFtraceEventWire.BLOCKS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._blocks = result.value;
                },
                Ext4FreeInodeFtraceEventWire.MODE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._mode = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4FreeInodeFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4FreeInodeFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getUid(self: *const Ext4FreeInodeFtraceEventReader) u32 {
        return self._uid;
    }
    pub inline fn getGid(self: *const Ext4FreeInodeFtraceEventReader) u32 {
        return self._gid;
    }
    pub inline fn getBlocks(self: *const Ext4FreeInodeFtraceEventReader) u64 {
        return self._blocks;
    }
    pub inline fn getMode(self: *const Ext4FreeInodeFtraceEventReader) u32 {
        return self._mode;
    }
};
const Ext4GetImpliedClusterAllocExitFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const FLAGS_WIRE: gremlin.ProtoWireNumber = 2;
    const LBLK_WIRE: gremlin.ProtoWireNumber = 3;
    const PBLK_WIRE: gremlin.ProtoWireNumber = 4;
    const LEN_WIRE: gremlin.ProtoWireNumber = 5;
    const RET_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const Ext4GetImpliedClusterAllocExitFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    flags: u32 = 0,
    lblk: u32 = 0,
    pblk: u64 = 0,
    len: u32 = 0,
    ret: i32 = 0,
    pub fn calcProtobufSize(self: *const Ext4GetImpliedClusterAllocExitFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4GetImpliedClusterAllocExitFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.flags != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4GetImpliedClusterAllocExitFtraceEventWire.FLAGS_WIRE) + gremlin.sizes.sizeU32(self.flags);
        }
        if (self.lblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4GetImpliedClusterAllocExitFtraceEventWire.LBLK_WIRE) + gremlin.sizes.sizeU32(self.lblk);
        }
        if (self.pblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4GetImpliedClusterAllocExitFtraceEventWire.PBLK_WIRE) + gremlin.sizes.sizeU64(self.pblk);
        }
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4GetImpliedClusterAllocExitFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeU32(self.len);
        }
        if (self.ret != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4GetImpliedClusterAllocExitFtraceEventWire.RET_WIRE) + gremlin.sizes.sizeI32(self.ret);
        }
        return res;
    }
    pub fn encode(self: *const Ext4GetImpliedClusterAllocExitFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4GetImpliedClusterAllocExitFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4GetImpliedClusterAllocExitFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.flags != 0) {
            target.appendUint32(Ext4GetImpliedClusterAllocExitFtraceEventWire.FLAGS_WIRE, self.flags);
        }
        if (self.lblk != 0) {
            target.appendUint32(Ext4GetImpliedClusterAllocExitFtraceEventWire.LBLK_WIRE, self.lblk);
        }
        if (self.pblk != 0) {
            target.appendUint64(Ext4GetImpliedClusterAllocExitFtraceEventWire.PBLK_WIRE, self.pblk);
        }
        if (self.len != 0) {
            target.appendUint32(Ext4GetImpliedClusterAllocExitFtraceEventWire.LEN_WIRE, self.len);
        }
        if (self.ret != 0) {
            target.appendInt32(Ext4GetImpliedClusterAllocExitFtraceEventWire.RET_WIRE, self.ret);
        }
    }
};
pub const Ext4GetImpliedClusterAllocExitFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _flags: u32 = 0,
    _lblk: u32 = 0,
    _pblk: u64 = 0,
    _len: u32 = 0,
    _ret: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4GetImpliedClusterAllocExitFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4GetImpliedClusterAllocExitFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4GetImpliedClusterAllocExitFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4GetImpliedClusterAllocExitFtraceEventWire.FLAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._flags = result.value;
                },
                Ext4GetImpliedClusterAllocExitFtraceEventWire.LBLK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._lblk = result.value;
                },
                Ext4GetImpliedClusterAllocExitFtraceEventWire.PBLK_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._pblk = result.value;
                },
                Ext4GetImpliedClusterAllocExitFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                Ext4GetImpliedClusterAllocExitFtraceEventWire.RET_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._ret = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4GetImpliedClusterAllocExitFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getFlags(self: *const Ext4GetImpliedClusterAllocExitFtraceEventReader) u32 {
        return self._flags;
    }
    pub inline fn getLblk(self: *const Ext4GetImpliedClusterAllocExitFtraceEventReader) u32 {
        return self._lblk;
    }
    pub inline fn getPblk(self: *const Ext4GetImpliedClusterAllocExitFtraceEventReader) u64 {
        return self._pblk;
    }
    pub inline fn getLen(self: *const Ext4GetImpliedClusterAllocExitFtraceEventReader) u32 {
        return self._len;
    }
    pub inline fn getRet(self: *const Ext4GetImpliedClusterAllocExitFtraceEventReader) i32 {
        return self._ret;
    }
};
const Ext4GetReservedClusterAllocFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const LBLK_WIRE: gremlin.ProtoWireNumber = 3;
    const LEN_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const Ext4GetReservedClusterAllocFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    lblk: u32 = 0,
    len: u32 = 0,
    pub fn calcProtobufSize(self: *const Ext4GetReservedClusterAllocFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4GetReservedClusterAllocFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4GetReservedClusterAllocFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.lblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4GetReservedClusterAllocFtraceEventWire.LBLK_WIRE) + gremlin.sizes.sizeU32(self.lblk);
        }
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4GetReservedClusterAllocFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeU32(self.len);
        }
        return res;
    }
    pub fn encode(self: *const Ext4GetReservedClusterAllocFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4GetReservedClusterAllocFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4GetReservedClusterAllocFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4GetReservedClusterAllocFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.lblk != 0) {
            target.appendUint32(Ext4GetReservedClusterAllocFtraceEventWire.LBLK_WIRE, self.lblk);
        }
        if (self.len != 0) {
            target.appendUint32(Ext4GetReservedClusterAllocFtraceEventWire.LEN_WIRE, self.len);
        }
    }
};
pub const Ext4GetReservedClusterAllocFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _lblk: u32 = 0,
    _len: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4GetReservedClusterAllocFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4GetReservedClusterAllocFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4GetReservedClusterAllocFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4GetReservedClusterAllocFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4GetReservedClusterAllocFtraceEventWire.LBLK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._lblk = result.value;
                },
                Ext4GetReservedClusterAllocFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4GetReservedClusterAllocFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4GetReservedClusterAllocFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getLblk(self: *const Ext4GetReservedClusterAllocFtraceEventReader) u32 {
        return self._lblk;
    }
    pub inline fn getLen(self: *const Ext4GetReservedClusterAllocFtraceEventReader) u32 {
        return self._len;
    }
};
const Ext4IndMapBlocksEnterFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const LBLK_WIRE: gremlin.ProtoWireNumber = 3;
    const LEN_WIRE: gremlin.ProtoWireNumber = 4;
    const FLAGS_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const Ext4IndMapBlocksEnterFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    lblk: u32 = 0,
    len: u32 = 0,
    flags: u32 = 0,
    pub fn calcProtobufSize(self: *const Ext4IndMapBlocksEnterFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4IndMapBlocksEnterFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4IndMapBlocksEnterFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.lblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4IndMapBlocksEnterFtraceEventWire.LBLK_WIRE) + gremlin.sizes.sizeU32(self.lblk);
        }
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4IndMapBlocksEnterFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeU32(self.len);
        }
        if (self.flags != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4IndMapBlocksEnterFtraceEventWire.FLAGS_WIRE) + gremlin.sizes.sizeU32(self.flags);
        }
        return res;
    }
    pub fn encode(self: *const Ext4IndMapBlocksEnterFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4IndMapBlocksEnterFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4IndMapBlocksEnterFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4IndMapBlocksEnterFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.lblk != 0) {
            target.appendUint32(Ext4IndMapBlocksEnterFtraceEventWire.LBLK_WIRE, self.lblk);
        }
        if (self.len != 0) {
            target.appendUint32(Ext4IndMapBlocksEnterFtraceEventWire.LEN_WIRE, self.len);
        }
        if (self.flags != 0) {
            target.appendUint32(Ext4IndMapBlocksEnterFtraceEventWire.FLAGS_WIRE, self.flags);
        }
    }
};
pub const Ext4IndMapBlocksEnterFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _lblk: u32 = 0,
    _len: u32 = 0,
    _flags: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4IndMapBlocksEnterFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4IndMapBlocksEnterFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4IndMapBlocksEnterFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4IndMapBlocksEnterFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4IndMapBlocksEnterFtraceEventWire.LBLK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._lblk = result.value;
                },
                Ext4IndMapBlocksEnterFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                Ext4IndMapBlocksEnterFtraceEventWire.FLAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._flags = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4IndMapBlocksEnterFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4IndMapBlocksEnterFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getLblk(self: *const Ext4IndMapBlocksEnterFtraceEventReader) u32 {
        return self._lblk;
    }
    pub inline fn getLen(self: *const Ext4IndMapBlocksEnterFtraceEventReader) u32 {
        return self._len;
    }
    pub inline fn getFlags(self: *const Ext4IndMapBlocksEnterFtraceEventReader) u32 {
        return self._flags;
    }
};
const Ext4IndMapBlocksExitFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const FLAGS_WIRE: gremlin.ProtoWireNumber = 3;
    const PBLK_WIRE: gremlin.ProtoWireNumber = 4;
    const LBLK_WIRE: gremlin.ProtoWireNumber = 5;
    const LEN_WIRE: gremlin.ProtoWireNumber = 6;
    const MFLAGS_WIRE: gremlin.ProtoWireNumber = 7;
    const RET_WIRE: gremlin.ProtoWireNumber = 8;
};
pub const Ext4IndMapBlocksExitFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    flags: u32 = 0,
    pblk: u64 = 0,
    lblk: u32 = 0,
    len: u32 = 0,
    mflags: u32 = 0,
    ret: i32 = 0,
    pub fn calcProtobufSize(self: *const Ext4IndMapBlocksExitFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4IndMapBlocksExitFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4IndMapBlocksExitFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.flags != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4IndMapBlocksExitFtraceEventWire.FLAGS_WIRE) + gremlin.sizes.sizeU32(self.flags);
        }
        if (self.pblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4IndMapBlocksExitFtraceEventWire.PBLK_WIRE) + gremlin.sizes.sizeU64(self.pblk);
        }
        if (self.lblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4IndMapBlocksExitFtraceEventWire.LBLK_WIRE) + gremlin.sizes.sizeU32(self.lblk);
        }
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4IndMapBlocksExitFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeU32(self.len);
        }
        if (self.mflags != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4IndMapBlocksExitFtraceEventWire.MFLAGS_WIRE) + gremlin.sizes.sizeU32(self.mflags);
        }
        if (self.ret != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4IndMapBlocksExitFtraceEventWire.RET_WIRE) + gremlin.sizes.sizeI32(self.ret);
        }
        return res;
    }
    pub fn encode(self: *const Ext4IndMapBlocksExitFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4IndMapBlocksExitFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4IndMapBlocksExitFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4IndMapBlocksExitFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.flags != 0) {
            target.appendUint32(Ext4IndMapBlocksExitFtraceEventWire.FLAGS_WIRE, self.flags);
        }
        if (self.pblk != 0) {
            target.appendUint64(Ext4IndMapBlocksExitFtraceEventWire.PBLK_WIRE, self.pblk);
        }
        if (self.lblk != 0) {
            target.appendUint32(Ext4IndMapBlocksExitFtraceEventWire.LBLK_WIRE, self.lblk);
        }
        if (self.len != 0) {
            target.appendUint32(Ext4IndMapBlocksExitFtraceEventWire.LEN_WIRE, self.len);
        }
        if (self.mflags != 0) {
            target.appendUint32(Ext4IndMapBlocksExitFtraceEventWire.MFLAGS_WIRE, self.mflags);
        }
        if (self.ret != 0) {
            target.appendInt32(Ext4IndMapBlocksExitFtraceEventWire.RET_WIRE, self.ret);
        }
    }
};
pub const Ext4IndMapBlocksExitFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _flags: u32 = 0,
    _pblk: u64 = 0,
    _lblk: u32 = 0,
    _len: u32 = 0,
    _mflags: u32 = 0,
    _ret: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4IndMapBlocksExitFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4IndMapBlocksExitFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4IndMapBlocksExitFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4IndMapBlocksExitFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4IndMapBlocksExitFtraceEventWire.FLAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._flags = result.value;
                },
                Ext4IndMapBlocksExitFtraceEventWire.PBLK_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._pblk = result.value;
                },
                Ext4IndMapBlocksExitFtraceEventWire.LBLK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._lblk = result.value;
                },
                Ext4IndMapBlocksExitFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                Ext4IndMapBlocksExitFtraceEventWire.MFLAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._mflags = result.value;
                },
                Ext4IndMapBlocksExitFtraceEventWire.RET_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._ret = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4IndMapBlocksExitFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4IndMapBlocksExitFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getFlags(self: *const Ext4IndMapBlocksExitFtraceEventReader) u32 {
        return self._flags;
    }
    pub inline fn getPblk(self: *const Ext4IndMapBlocksExitFtraceEventReader) u64 {
        return self._pblk;
    }
    pub inline fn getLblk(self: *const Ext4IndMapBlocksExitFtraceEventReader) u32 {
        return self._lblk;
    }
    pub inline fn getLen(self: *const Ext4IndMapBlocksExitFtraceEventReader) u32 {
        return self._len;
    }
    pub inline fn getMflags(self: *const Ext4IndMapBlocksExitFtraceEventReader) u32 {
        return self._mflags;
    }
    pub inline fn getRet(self: *const Ext4IndMapBlocksExitFtraceEventReader) i32 {
        return self._ret;
    }
};
const Ext4InsertRangeFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const OFFSET_WIRE: gremlin.ProtoWireNumber = 3;
    const LEN_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const Ext4InsertRangeFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    offset: i64 = 0,
    len: i64 = 0,
    pub fn calcProtobufSize(self: *const Ext4InsertRangeFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4InsertRangeFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4InsertRangeFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.offset != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4InsertRangeFtraceEventWire.OFFSET_WIRE) + gremlin.sizes.sizeI64(self.offset);
        }
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4InsertRangeFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeI64(self.len);
        }
        return res;
    }
    pub fn encode(self: *const Ext4InsertRangeFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4InsertRangeFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4InsertRangeFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4InsertRangeFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.offset != 0) {
            target.appendInt64(Ext4InsertRangeFtraceEventWire.OFFSET_WIRE, self.offset);
        }
        if (self.len != 0) {
            target.appendInt64(Ext4InsertRangeFtraceEventWire.LEN_WIRE, self.len);
        }
    }
};
pub const Ext4InsertRangeFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _offset: i64 = 0,
    _len: i64 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4InsertRangeFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4InsertRangeFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4InsertRangeFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4InsertRangeFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4InsertRangeFtraceEventWire.OFFSET_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._offset = result.value;
                },
                Ext4InsertRangeFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4InsertRangeFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4InsertRangeFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getOffset(self: *const Ext4InsertRangeFtraceEventReader) i64 {
        return self._offset;
    }
    pub inline fn getLen(self: *const Ext4InsertRangeFtraceEventReader) i64 {
        return self._len;
    }
};
const Ext4InvalidatepageFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const INDEX_WIRE: gremlin.ProtoWireNumber = 3;
    const OFFSET_WIRE: gremlin.ProtoWireNumber = 4;
    const LENGTH_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const Ext4InvalidatepageFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    index: u64 = 0,
    offset: u64 = 0,
    length: u32 = 0,
    pub fn calcProtobufSize(self: *const Ext4InvalidatepageFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4InvalidatepageFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4InvalidatepageFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.index != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4InvalidatepageFtraceEventWire.INDEX_WIRE) + gremlin.sizes.sizeU64(self.index);
        }
        if (self.offset != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4InvalidatepageFtraceEventWire.OFFSET_WIRE) + gremlin.sizes.sizeU64(self.offset);
        }
        if (self.length != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4InvalidatepageFtraceEventWire.LENGTH_WIRE) + gremlin.sizes.sizeU32(self.length);
        }
        return res;
    }
    pub fn encode(self: *const Ext4InvalidatepageFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4InvalidatepageFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4InvalidatepageFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4InvalidatepageFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.index != 0) {
            target.appendUint64(Ext4InvalidatepageFtraceEventWire.INDEX_WIRE, self.index);
        }
        if (self.offset != 0) {
            target.appendUint64(Ext4InvalidatepageFtraceEventWire.OFFSET_WIRE, self.offset);
        }
        if (self.length != 0) {
            target.appendUint32(Ext4InvalidatepageFtraceEventWire.LENGTH_WIRE, self.length);
        }
    }
};
pub const Ext4InvalidatepageFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _index: u64 = 0,
    _offset: u64 = 0,
    _length: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4InvalidatepageFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4InvalidatepageFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4InvalidatepageFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4InvalidatepageFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4InvalidatepageFtraceEventWire.INDEX_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._index = result.value;
                },
                Ext4InvalidatepageFtraceEventWire.OFFSET_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._offset = result.value;
                },
                Ext4InvalidatepageFtraceEventWire.LENGTH_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._length = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4InvalidatepageFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4InvalidatepageFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getIndex(self: *const Ext4InvalidatepageFtraceEventReader) u64 {
        return self._index;
    }
    pub inline fn getOffset(self: *const Ext4InvalidatepageFtraceEventReader) u64 {
        return self._offset;
    }
    pub inline fn getLength(self: *const Ext4InvalidatepageFtraceEventReader) u32 {
        return self._length;
    }
};
const Ext4JournalStartFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const IP_WIRE: gremlin.ProtoWireNumber = 2;
    const BLOCKS_WIRE: gremlin.ProtoWireNumber = 3;
    const RSV_BLOCKS_WIRE: gremlin.ProtoWireNumber = 4;
    const NBLOCKS_WIRE: gremlin.ProtoWireNumber = 5;
    const REVOKE_CREDS_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const Ext4JournalStartFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ip: u64 = 0,
    blocks: i32 = 0,
    rsv_blocks: i32 = 0,
    nblocks: i32 = 0,
    revoke_creds: i32 = 0,
    pub fn calcProtobufSize(self: *const Ext4JournalStartFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4JournalStartFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ip != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4JournalStartFtraceEventWire.IP_WIRE) + gremlin.sizes.sizeU64(self.ip);
        }
        if (self.blocks != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4JournalStartFtraceEventWire.BLOCKS_WIRE) + gremlin.sizes.sizeI32(self.blocks);
        }
        if (self.rsv_blocks != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4JournalStartFtraceEventWire.RSV_BLOCKS_WIRE) + gremlin.sizes.sizeI32(self.rsv_blocks);
        }
        if (self.nblocks != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4JournalStartFtraceEventWire.NBLOCKS_WIRE) + gremlin.sizes.sizeI32(self.nblocks);
        }
        if (self.revoke_creds != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4JournalStartFtraceEventWire.REVOKE_CREDS_WIRE) + gremlin.sizes.sizeI32(self.revoke_creds);
        }
        return res;
    }
    pub fn encode(self: *const Ext4JournalStartFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4JournalStartFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4JournalStartFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ip != 0) {
            target.appendUint64(Ext4JournalStartFtraceEventWire.IP_WIRE, self.ip);
        }
        if (self.blocks != 0) {
            target.appendInt32(Ext4JournalStartFtraceEventWire.BLOCKS_WIRE, self.blocks);
        }
        if (self.rsv_blocks != 0) {
            target.appendInt32(Ext4JournalStartFtraceEventWire.RSV_BLOCKS_WIRE, self.rsv_blocks);
        }
        if (self.nblocks != 0) {
            target.appendInt32(Ext4JournalStartFtraceEventWire.NBLOCKS_WIRE, self.nblocks);
        }
        if (self.revoke_creds != 0) {
            target.appendInt32(Ext4JournalStartFtraceEventWire.REVOKE_CREDS_WIRE, self.revoke_creds);
        }
    }
};
pub const Ext4JournalStartFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ip: u64 = 0,
    _blocks: i32 = 0,
    _rsv_blocks: i32 = 0,
    _nblocks: i32 = 0,
    _revoke_creds: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4JournalStartFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4JournalStartFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4JournalStartFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4JournalStartFtraceEventWire.IP_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ip = result.value;
                },
                Ext4JournalStartFtraceEventWire.BLOCKS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._blocks = result.value;
                },
                Ext4JournalStartFtraceEventWire.RSV_BLOCKS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._rsv_blocks = result.value;
                },
                Ext4JournalStartFtraceEventWire.NBLOCKS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._nblocks = result.value;
                },
                Ext4JournalStartFtraceEventWire.REVOKE_CREDS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._revoke_creds = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4JournalStartFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIp(self: *const Ext4JournalStartFtraceEventReader) u64 {
        return self._ip;
    }
    pub inline fn getBlocks(self: *const Ext4JournalStartFtraceEventReader) i32 {
        return self._blocks;
    }
    pub inline fn getRsvBlocks(self: *const Ext4JournalStartFtraceEventReader) i32 {
        return self._rsv_blocks;
    }
    pub inline fn getNblocks(self: *const Ext4JournalStartFtraceEventReader) i32 {
        return self._nblocks;
    }
    pub inline fn getRevokeCreds(self: *const Ext4JournalStartFtraceEventReader) i32 {
        return self._revoke_creds;
    }
};
const Ext4JournalStartReservedFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const IP_WIRE: gremlin.ProtoWireNumber = 2;
    const BLOCKS_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const Ext4JournalStartReservedFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ip: u64 = 0,
    blocks: i32 = 0,
    pub fn calcProtobufSize(self: *const Ext4JournalStartReservedFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4JournalStartReservedFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ip != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4JournalStartReservedFtraceEventWire.IP_WIRE) + gremlin.sizes.sizeU64(self.ip);
        }
        if (self.blocks != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4JournalStartReservedFtraceEventWire.BLOCKS_WIRE) + gremlin.sizes.sizeI32(self.blocks);
        }
        return res;
    }
    pub fn encode(self: *const Ext4JournalStartReservedFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4JournalStartReservedFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4JournalStartReservedFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ip != 0) {
            target.appendUint64(Ext4JournalStartReservedFtraceEventWire.IP_WIRE, self.ip);
        }
        if (self.blocks != 0) {
            target.appendInt32(Ext4JournalStartReservedFtraceEventWire.BLOCKS_WIRE, self.blocks);
        }
    }
};
pub const Ext4JournalStartReservedFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ip: u64 = 0,
    _blocks: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4JournalStartReservedFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4JournalStartReservedFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4JournalStartReservedFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4JournalStartReservedFtraceEventWire.IP_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ip = result.value;
                },
                Ext4JournalStartReservedFtraceEventWire.BLOCKS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._blocks = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4JournalStartReservedFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIp(self: *const Ext4JournalStartReservedFtraceEventReader) u64 {
        return self._ip;
    }
    pub inline fn getBlocks(self: *const Ext4JournalStartReservedFtraceEventReader) i32 {
        return self._blocks;
    }
};
const Ext4JournalledInvalidatepageFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const INDEX_WIRE: gremlin.ProtoWireNumber = 3;
    const OFFSET_WIRE: gremlin.ProtoWireNumber = 4;
    const LENGTH_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const Ext4JournalledInvalidatepageFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    index: u64 = 0,
    offset: u64 = 0,
    length: u32 = 0,
    pub fn calcProtobufSize(self: *const Ext4JournalledInvalidatepageFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4JournalledInvalidatepageFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4JournalledInvalidatepageFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.index != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4JournalledInvalidatepageFtraceEventWire.INDEX_WIRE) + gremlin.sizes.sizeU64(self.index);
        }
        if (self.offset != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4JournalledInvalidatepageFtraceEventWire.OFFSET_WIRE) + gremlin.sizes.sizeU64(self.offset);
        }
        if (self.length != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4JournalledInvalidatepageFtraceEventWire.LENGTH_WIRE) + gremlin.sizes.sizeU32(self.length);
        }
        return res;
    }
    pub fn encode(self: *const Ext4JournalledInvalidatepageFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4JournalledInvalidatepageFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4JournalledInvalidatepageFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4JournalledInvalidatepageFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.index != 0) {
            target.appendUint64(Ext4JournalledInvalidatepageFtraceEventWire.INDEX_WIRE, self.index);
        }
        if (self.offset != 0) {
            target.appendUint64(Ext4JournalledInvalidatepageFtraceEventWire.OFFSET_WIRE, self.offset);
        }
        if (self.length != 0) {
            target.appendUint32(Ext4JournalledInvalidatepageFtraceEventWire.LENGTH_WIRE, self.length);
        }
    }
};
pub const Ext4JournalledInvalidatepageFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _index: u64 = 0,
    _offset: u64 = 0,
    _length: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4JournalledInvalidatepageFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4JournalledInvalidatepageFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4JournalledInvalidatepageFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4JournalledInvalidatepageFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4JournalledInvalidatepageFtraceEventWire.INDEX_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._index = result.value;
                },
                Ext4JournalledInvalidatepageFtraceEventWire.OFFSET_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._offset = result.value;
                },
                Ext4JournalledInvalidatepageFtraceEventWire.LENGTH_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._length = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4JournalledInvalidatepageFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4JournalledInvalidatepageFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getIndex(self: *const Ext4JournalledInvalidatepageFtraceEventReader) u64 {
        return self._index;
    }
    pub inline fn getOffset(self: *const Ext4JournalledInvalidatepageFtraceEventReader) u64 {
        return self._offset;
    }
    pub inline fn getLength(self: *const Ext4JournalledInvalidatepageFtraceEventReader) u32 {
        return self._length;
    }
};
const Ext4JournalledWriteEndFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const POS_WIRE: gremlin.ProtoWireNumber = 3;
    const LEN_WIRE: gremlin.ProtoWireNumber = 4;
    const COPIED_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const Ext4JournalledWriteEndFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    pos: i64 = 0,
    len: u32 = 0,
    copied: u32 = 0,
    pub fn calcProtobufSize(self: *const Ext4JournalledWriteEndFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4JournalledWriteEndFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4JournalledWriteEndFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.pos != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4JournalledWriteEndFtraceEventWire.POS_WIRE) + gremlin.sizes.sizeI64(self.pos);
        }
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4JournalledWriteEndFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeU32(self.len);
        }
        if (self.copied != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4JournalledWriteEndFtraceEventWire.COPIED_WIRE) + gremlin.sizes.sizeU32(self.copied);
        }
        return res;
    }
    pub fn encode(self: *const Ext4JournalledWriteEndFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4JournalledWriteEndFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4JournalledWriteEndFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4JournalledWriteEndFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.pos != 0) {
            target.appendInt64(Ext4JournalledWriteEndFtraceEventWire.POS_WIRE, self.pos);
        }
        if (self.len != 0) {
            target.appendUint32(Ext4JournalledWriteEndFtraceEventWire.LEN_WIRE, self.len);
        }
        if (self.copied != 0) {
            target.appendUint32(Ext4JournalledWriteEndFtraceEventWire.COPIED_WIRE, self.copied);
        }
    }
};
pub const Ext4JournalledWriteEndFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _pos: i64 = 0,
    _len: u32 = 0,
    _copied: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4JournalledWriteEndFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4JournalledWriteEndFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4JournalledWriteEndFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4JournalledWriteEndFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4JournalledWriteEndFtraceEventWire.POS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._pos = result.value;
                },
                Ext4JournalledWriteEndFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                Ext4JournalledWriteEndFtraceEventWire.COPIED_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._copied = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4JournalledWriteEndFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4JournalledWriteEndFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getPos(self: *const Ext4JournalledWriteEndFtraceEventReader) i64 {
        return self._pos;
    }
    pub inline fn getLen(self: *const Ext4JournalledWriteEndFtraceEventReader) u32 {
        return self._len;
    }
    pub inline fn getCopied(self: *const Ext4JournalledWriteEndFtraceEventReader) u32 {
        return self._copied;
    }
};
const Ext4LoadInodeFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const Ext4LoadInodeFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    pub fn calcProtobufSize(self: *const Ext4LoadInodeFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4LoadInodeFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4LoadInodeFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        return res;
    }
    pub fn encode(self: *const Ext4LoadInodeFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4LoadInodeFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4LoadInodeFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4LoadInodeFtraceEventWire.INO_WIRE, self.ino);
        }
    }
};
pub const Ext4LoadInodeFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4LoadInodeFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4LoadInodeFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4LoadInodeFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4LoadInodeFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4LoadInodeFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4LoadInodeFtraceEventReader) u64 {
        return self._ino;
    }
};
const Ext4LoadInodeBitmapFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const GROUP_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const Ext4LoadInodeBitmapFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    group: u32 = 0,
    pub fn calcProtobufSize(self: *const Ext4LoadInodeBitmapFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4LoadInodeBitmapFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.group != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4LoadInodeBitmapFtraceEventWire.GROUP_WIRE) + gremlin.sizes.sizeU32(self.group);
        }
        return res;
    }
    pub fn encode(self: *const Ext4LoadInodeBitmapFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4LoadInodeBitmapFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4LoadInodeBitmapFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.group != 0) {
            target.appendUint32(Ext4LoadInodeBitmapFtraceEventWire.GROUP_WIRE, self.group);
        }
    }
};
pub const Ext4LoadInodeBitmapFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _group: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4LoadInodeBitmapFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4LoadInodeBitmapFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4LoadInodeBitmapFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4LoadInodeBitmapFtraceEventWire.GROUP_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._group = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4LoadInodeBitmapFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getGroup(self: *const Ext4LoadInodeBitmapFtraceEventReader) u32 {
        return self._group;
    }
};
const Ext4MarkInodeDirtyFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const IP_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const Ext4MarkInodeDirtyFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    ip: u64 = 0,
    pub fn calcProtobufSize(self: *const Ext4MarkInodeDirtyFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MarkInodeDirtyFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MarkInodeDirtyFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.ip != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MarkInodeDirtyFtraceEventWire.IP_WIRE) + gremlin.sizes.sizeU64(self.ip);
        }
        return res;
    }
    pub fn encode(self: *const Ext4MarkInodeDirtyFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4MarkInodeDirtyFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4MarkInodeDirtyFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4MarkInodeDirtyFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.ip != 0) {
            target.appendUint64(Ext4MarkInodeDirtyFtraceEventWire.IP_WIRE, self.ip);
        }
    }
};
pub const Ext4MarkInodeDirtyFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _ip: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4MarkInodeDirtyFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4MarkInodeDirtyFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4MarkInodeDirtyFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4MarkInodeDirtyFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4MarkInodeDirtyFtraceEventWire.IP_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ip = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4MarkInodeDirtyFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4MarkInodeDirtyFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getIp(self: *const Ext4MarkInodeDirtyFtraceEventReader) u64 {
        return self._ip;
    }
};
const Ext4MbBitmapLoadFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const GROUP_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const Ext4MbBitmapLoadFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    group: u32 = 0,
    pub fn calcProtobufSize(self: *const Ext4MbBitmapLoadFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MbBitmapLoadFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.group != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MbBitmapLoadFtraceEventWire.GROUP_WIRE) + gremlin.sizes.sizeU32(self.group);
        }
        return res;
    }
    pub fn encode(self: *const Ext4MbBitmapLoadFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4MbBitmapLoadFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4MbBitmapLoadFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.group != 0) {
            target.appendUint32(Ext4MbBitmapLoadFtraceEventWire.GROUP_WIRE, self.group);
        }
    }
};
pub const Ext4MbBitmapLoadFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _group: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4MbBitmapLoadFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4MbBitmapLoadFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4MbBitmapLoadFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4MbBitmapLoadFtraceEventWire.GROUP_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._group = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4MbBitmapLoadFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getGroup(self: *const Ext4MbBitmapLoadFtraceEventReader) u32 {
        return self._group;
    }
};
const Ext4MbBuddyBitmapLoadFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const GROUP_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const Ext4MbBuddyBitmapLoadFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    group: u32 = 0,
    pub fn calcProtobufSize(self: *const Ext4MbBuddyBitmapLoadFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MbBuddyBitmapLoadFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.group != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MbBuddyBitmapLoadFtraceEventWire.GROUP_WIRE) + gremlin.sizes.sizeU32(self.group);
        }
        return res;
    }
    pub fn encode(self: *const Ext4MbBuddyBitmapLoadFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4MbBuddyBitmapLoadFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4MbBuddyBitmapLoadFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.group != 0) {
            target.appendUint32(Ext4MbBuddyBitmapLoadFtraceEventWire.GROUP_WIRE, self.group);
        }
    }
};
pub const Ext4MbBuddyBitmapLoadFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _group: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4MbBuddyBitmapLoadFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4MbBuddyBitmapLoadFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4MbBuddyBitmapLoadFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4MbBuddyBitmapLoadFtraceEventWire.GROUP_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._group = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4MbBuddyBitmapLoadFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getGroup(self: *const Ext4MbBuddyBitmapLoadFtraceEventReader) u32 {
        return self._group;
    }
};
const Ext4MbDiscardPreallocationsFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const NEEDED_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const Ext4MbDiscardPreallocationsFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    needed: i32 = 0,
    pub fn calcProtobufSize(self: *const Ext4MbDiscardPreallocationsFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MbDiscardPreallocationsFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.needed != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MbDiscardPreallocationsFtraceEventWire.NEEDED_WIRE) + gremlin.sizes.sizeI32(self.needed);
        }
        return res;
    }
    pub fn encode(self: *const Ext4MbDiscardPreallocationsFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4MbDiscardPreallocationsFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4MbDiscardPreallocationsFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.needed != 0) {
            target.appendInt32(Ext4MbDiscardPreallocationsFtraceEventWire.NEEDED_WIRE, self.needed);
        }
    }
};
pub const Ext4MbDiscardPreallocationsFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _needed: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4MbDiscardPreallocationsFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4MbDiscardPreallocationsFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4MbDiscardPreallocationsFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4MbDiscardPreallocationsFtraceEventWire.NEEDED_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._needed = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4MbDiscardPreallocationsFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getNeeded(self: *const Ext4MbDiscardPreallocationsFtraceEventReader) i32 {
        return self._needed;
    }
};
const Ext4MbNewGroupPaFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const PA_PSTART_WIRE: gremlin.ProtoWireNumber = 3;
    const PA_LSTART_WIRE: gremlin.ProtoWireNumber = 4;
    const PA_LEN_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const Ext4MbNewGroupPaFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    pa_pstart: u64 = 0,
    pa_lstart: u64 = 0,
    pa_len: u32 = 0,
    pub fn calcProtobufSize(self: *const Ext4MbNewGroupPaFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MbNewGroupPaFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MbNewGroupPaFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.pa_pstart != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MbNewGroupPaFtraceEventWire.PA_PSTART_WIRE) + gremlin.sizes.sizeU64(self.pa_pstart);
        }
        if (self.pa_lstart != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MbNewGroupPaFtraceEventWire.PA_LSTART_WIRE) + gremlin.sizes.sizeU64(self.pa_lstart);
        }
        if (self.pa_len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MbNewGroupPaFtraceEventWire.PA_LEN_WIRE) + gremlin.sizes.sizeU32(self.pa_len);
        }
        return res;
    }
    pub fn encode(self: *const Ext4MbNewGroupPaFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4MbNewGroupPaFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4MbNewGroupPaFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4MbNewGroupPaFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.pa_pstart != 0) {
            target.appendUint64(Ext4MbNewGroupPaFtraceEventWire.PA_PSTART_WIRE, self.pa_pstart);
        }
        if (self.pa_lstart != 0) {
            target.appendUint64(Ext4MbNewGroupPaFtraceEventWire.PA_LSTART_WIRE, self.pa_lstart);
        }
        if (self.pa_len != 0) {
            target.appendUint32(Ext4MbNewGroupPaFtraceEventWire.PA_LEN_WIRE, self.pa_len);
        }
    }
};
pub const Ext4MbNewGroupPaFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _pa_pstart: u64 = 0,
    _pa_lstart: u64 = 0,
    _pa_len: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4MbNewGroupPaFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4MbNewGroupPaFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4MbNewGroupPaFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4MbNewGroupPaFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4MbNewGroupPaFtraceEventWire.PA_PSTART_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._pa_pstart = result.value;
                },
                Ext4MbNewGroupPaFtraceEventWire.PA_LSTART_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._pa_lstart = result.value;
                },
                Ext4MbNewGroupPaFtraceEventWire.PA_LEN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._pa_len = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4MbNewGroupPaFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4MbNewGroupPaFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getPaPstart(self: *const Ext4MbNewGroupPaFtraceEventReader) u64 {
        return self._pa_pstart;
    }
    pub inline fn getPaLstart(self: *const Ext4MbNewGroupPaFtraceEventReader) u64 {
        return self._pa_lstart;
    }
    pub inline fn getPaLen(self: *const Ext4MbNewGroupPaFtraceEventReader) u32 {
        return self._pa_len;
    }
};
const Ext4MbNewInodePaFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const PA_PSTART_WIRE: gremlin.ProtoWireNumber = 3;
    const PA_LSTART_WIRE: gremlin.ProtoWireNumber = 4;
    const PA_LEN_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const Ext4MbNewInodePaFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    pa_pstart: u64 = 0,
    pa_lstart: u64 = 0,
    pa_len: u32 = 0,
    pub fn calcProtobufSize(self: *const Ext4MbNewInodePaFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MbNewInodePaFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MbNewInodePaFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.pa_pstart != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MbNewInodePaFtraceEventWire.PA_PSTART_WIRE) + gremlin.sizes.sizeU64(self.pa_pstart);
        }
        if (self.pa_lstart != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MbNewInodePaFtraceEventWire.PA_LSTART_WIRE) + gremlin.sizes.sizeU64(self.pa_lstart);
        }
        if (self.pa_len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MbNewInodePaFtraceEventWire.PA_LEN_WIRE) + gremlin.sizes.sizeU32(self.pa_len);
        }
        return res;
    }
    pub fn encode(self: *const Ext4MbNewInodePaFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4MbNewInodePaFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4MbNewInodePaFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4MbNewInodePaFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.pa_pstart != 0) {
            target.appendUint64(Ext4MbNewInodePaFtraceEventWire.PA_PSTART_WIRE, self.pa_pstart);
        }
        if (self.pa_lstart != 0) {
            target.appendUint64(Ext4MbNewInodePaFtraceEventWire.PA_LSTART_WIRE, self.pa_lstart);
        }
        if (self.pa_len != 0) {
            target.appendUint32(Ext4MbNewInodePaFtraceEventWire.PA_LEN_WIRE, self.pa_len);
        }
    }
};
pub const Ext4MbNewInodePaFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _pa_pstart: u64 = 0,
    _pa_lstart: u64 = 0,
    _pa_len: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4MbNewInodePaFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4MbNewInodePaFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4MbNewInodePaFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4MbNewInodePaFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4MbNewInodePaFtraceEventWire.PA_PSTART_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._pa_pstart = result.value;
                },
                Ext4MbNewInodePaFtraceEventWire.PA_LSTART_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._pa_lstart = result.value;
                },
                Ext4MbNewInodePaFtraceEventWire.PA_LEN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._pa_len = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4MbNewInodePaFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4MbNewInodePaFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getPaPstart(self: *const Ext4MbNewInodePaFtraceEventReader) u64 {
        return self._pa_pstart;
    }
    pub inline fn getPaLstart(self: *const Ext4MbNewInodePaFtraceEventReader) u64 {
        return self._pa_lstart;
    }
    pub inline fn getPaLen(self: *const Ext4MbNewInodePaFtraceEventReader) u32 {
        return self._pa_len;
    }
};
const Ext4MbReleaseGroupPaFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const PA_PSTART_WIRE: gremlin.ProtoWireNumber = 2;
    const PA_LEN_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const Ext4MbReleaseGroupPaFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    pa_pstart: u64 = 0,
    pa_len: u32 = 0,
    pub fn calcProtobufSize(self: *const Ext4MbReleaseGroupPaFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MbReleaseGroupPaFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.pa_pstart != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MbReleaseGroupPaFtraceEventWire.PA_PSTART_WIRE) + gremlin.sizes.sizeU64(self.pa_pstart);
        }
        if (self.pa_len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MbReleaseGroupPaFtraceEventWire.PA_LEN_WIRE) + gremlin.sizes.sizeU32(self.pa_len);
        }
        return res;
    }
    pub fn encode(self: *const Ext4MbReleaseGroupPaFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4MbReleaseGroupPaFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4MbReleaseGroupPaFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.pa_pstart != 0) {
            target.appendUint64(Ext4MbReleaseGroupPaFtraceEventWire.PA_PSTART_WIRE, self.pa_pstart);
        }
        if (self.pa_len != 0) {
            target.appendUint32(Ext4MbReleaseGroupPaFtraceEventWire.PA_LEN_WIRE, self.pa_len);
        }
    }
};
pub const Ext4MbReleaseGroupPaFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _pa_pstart: u64 = 0,
    _pa_len: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4MbReleaseGroupPaFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4MbReleaseGroupPaFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4MbReleaseGroupPaFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4MbReleaseGroupPaFtraceEventWire.PA_PSTART_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._pa_pstart = result.value;
                },
                Ext4MbReleaseGroupPaFtraceEventWire.PA_LEN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._pa_len = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4MbReleaseGroupPaFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getPaPstart(self: *const Ext4MbReleaseGroupPaFtraceEventReader) u64 {
        return self._pa_pstart;
    }
    pub inline fn getPaLen(self: *const Ext4MbReleaseGroupPaFtraceEventReader) u32 {
        return self._pa_len;
    }
};
const Ext4MbReleaseInodePaFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const BLOCK_WIRE: gremlin.ProtoWireNumber = 3;
    const COUNT_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const Ext4MbReleaseInodePaFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    block: u64 = 0,
    count: u32 = 0,
    pub fn calcProtobufSize(self: *const Ext4MbReleaseInodePaFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MbReleaseInodePaFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MbReleaseInodePaFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.block != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MbReleaseInodePaFtraceEventWire.BLOCK_WIRE) + gremlin.sizes.sizeU64(self.block);
        }
        if (self.count != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MbReleaseInodePaFtraceEventWire.COUNT_WIRE) + gremlin.sizes.sizeU32(self.count);
        }
        return res;
    }
    pub fn encode(self: *const Ext4MbReleaseInodePaFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4MbReleaseInodePaFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4MbReleaseInodePaFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4MbReleaseInodePaFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.block != 0) {
            target.appendUint64(Ext4MbReleaseInodePaFtraceEventWire.BLOCK_WIRE, self.block);
        }
        if (self.count != 0) {
            target.appendUint32(Ext4MbReleaseInodePaFtraceEventWire.COUNT_WIRE, self.count);
        }
    }
};
pub const Ext4MbReleaseInodePaFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _block: u64 = 0,
    _count: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4MbReleaseInodePaFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4MbReleaseInodePaFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4MbReleaseInodePaFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4MbReleaseInodePaFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4MbReleaseInodePaFtraceEventWire.BLOCK_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._block = result.value;
                },
                Ext4MbReleaseInodePaFtraceEventWire.COUNT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._count = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4MbReleaseInodePaFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4MbReleaseInodePaFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getBlock(self: *const Ext4MbReleaseInodePaFtraceEventReader) u64 {
        return self._block;
    }
    pub inline fn getCount(self: *const Ext4MbReleaseInodePaFtraceEventReader) u32 {
        return self._count;
    }
};
const Ext4MballocAllocFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const ORIG_LOGICAL_WIRE: gremlin.ProtoWireNumber = 3;
    const ORIG_START_WIRE: gremlin.ProtoWireNumber = 4;
    const ORIG_GROUP_WIRE: gremlin.ProtoWireNumber = 5;
    const ORIG_LEN_WIRE: gremlin.ProtoWireNumber = 6;
    const GOAL_LOGICAL_WIRE: gremlin.ProtoWireNumber = 7;
    const GOAL_START_WIRE: gremlin.ProtoWireNumber = 8;
    const GOAL_GROUP_WIRE: gremlin.ProtoWireNumber = 9;
    const GOAL_LEN_WIRE: gremlin.ProtoWireNumber = 10;
    const RESULT_LOGICAL_WIRE: gremlin.ProtoWireNumber = 11;
    const RESULT_START_WIRE: gremlin.ProtoWireNumber = 12;
    const RESULT_GROUP_WIRE: gremlin.ProtoWireNumber = 13;
    const RESULT_LEN_WIRE: gremlin.ProtoWireNumber = 14;
    const FOUND_WIRE: gremlin.ProtoWireNumber = 15;
    const GROUPS_WIRE: gremlin.ProtoWireNumber = 16;
    const BUDDY_WIRE: gremlin.ProtoWireNumber = 17;
    const FLAGS_WIRE: gremlin.ProtoWireNumber = 18;
    const TAIL_WIRE: gremlin.ProtoWireNumber = 19;
    const CR_WIRE: gremlin.ProtoWireNumber = 20;
};
pub const Ext4MballocAllocFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    orig_logical: u32 = 0,
    orig_start: i32 = 0,
    orig_group: u32 = 0,
    orig_len: i32 = 0,
    goal_logical: u32 = 0,
    goal_start: i32 = 0,
    goal_group: u32 = 0,
    goal_len: i32 = 0,
    result_logical: u32 = 0,
    result_start: i32 = 0,
    result_group: u32 = 0,
    result_len: i32 = 0,
    found: u32 = 0,
    groups: u32 = 0,
    buddy: u32 = 0,
    flags: u32 = 0,
    tail: u32 = 0,
    cr: u32 = 0,
    pub fn calcProtobufSize(self: *const Ext4MballocAllocFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MballocAllocFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MballocAllocFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.orig_logical != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MballocAllocFtraceEventWire.ORIG_LOGICAL_WIRE) + gremlin.sizes.sizeU32(self.orig_logical);
        }
        if (self.orig_start != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MballocAllocFtraceEventWire.ORIG_START_WIRE) + gremlin.sizes.sizeI32(self.orig_start);
        }
        if (self.orig_group != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MballocAllocFtraceEventWire.ORIG_GROUP_WIRE) + gremlin.sizes.sizeU32(self.orig_group);
        }
        if (self.orig_len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MballocAllocFtraceEventWire.ORIG_LEN_WIRE) + gremlin.sizes.sizeI32(self.orig_len);
        }
        if (self.goal_logical != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MballocAllocFtraceEventWire.GOAL_LOGICAL_WIRE) + gremlin.sizes.sizeU32(self.goal_logical);
        }
        if (self.goal_start != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MballocAllocFtraceEventWire.GOAL_START_WIRE) + gremlin.sizes.sizeI32(self.goal_start);
        }
        if (self.goal_group != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MballocAllocFtraceEventWire.GOAL_GROUP_WIRE) + gremlin.sizes.sizeU32(self.goal_group);
        }
        if (self.goal_len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MballocAllocFtraceEventWire.GOAL_LEN_WIRE) + gremlin.sizes.sizeI32(self.goal_len);
        }
        if (self.result_logical != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MballocAllocFtraceEventWire.RESULT_LOGICAL_WIRE) + gremlin.sizes.sizeU32(self.result_logical);
        }
        if (self.result_start != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MballocAllocFtraceEventWire.RESULT_START_WIRE) + gremlin.sizes.sizeI32(self.result_start);
        }
        if (self.result_group != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MballocAllocFtraceEventWire.RESULT_GROUP_WIRE) + gremlin.sizes.sizeU32(self.result_group);
        }
        if (self.result_len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MballocAllocFtraceEventWire.RESULT_LEN_WIRE) + gremlin.sizes.sizeI32(self.result_len);
        }
        if (self.found != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MballocAllocFtraceEventWire.FOUND_WIRE) + gremlin.sizes.sizeU32(self.found);
        }
        if (self.groups != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MballocAllocFtraceEventWire.GROUPS_WIRE) + gremlin.sizes.sizeU32(self.groups);
        }
        if (self.buddy != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MballocAllocFtraceEventWire.BUDDY_WIRE) + gremlin.sizes.sizeU32(self.buddy);
        }
        if (self.flags != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MballocAllocFtraceEventWire.FLAGS_WIRE) + gremlin.sizes.sizeU32(self.flags);
        }
        if (self.tail != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MballocAllocFtraceEventWire.TAIL_WIRE) + gremlin.sizes.sizeU32(self.tail);
        }
        if (self.cr != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MballocAllocFtraceEventWire.CR_WIRE) + gremlin.sizes.sizeU32(self.cr);
        }
        return res;
    }
    pub fn encode(self: *const Ext4MballocAllocFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4MballocAllocFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4MballocAllocFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4MballocAllocFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.orig_logical != 0) {
            target.appendUint32(Ext4MballocAllocFtraceEventWire.ORIG_LOGICAL_WIRE, self.orig_logical);
        }
        if (self.orig_start != 0) {
            target.appendInt32(Ext4MballocAllocFtraceEventWire.ORIG_START_WIRE, self.orig_start);
        }
        if (self.orig_group != 0) {
            target.appendUint32(Ext4MballocAllocFtraceEventWire.ORIG_GROUP_WIRE, self.orig_group);
        }
        if (self.orig_len != 0) {
            target.appendInt32(Ext4MballocAllocFtraceEventWire.ORIG_LEN_WIRE, self.orig_len);
        }
        if (self.goal_logical != 0) {
            target.appendUint32(Ext4MballocAllocFtraceEventWire.GOAL_LOGICAL_WIRE, self.goal_logical);
        }
        if (self.goal_start != 0) {
            target.appendInt32(Ext4MballocAllocFtraceEventWire.GOAL_START_WIRE, self.goal_start);
        }
        if (self.goal_group != 0) {
            target.appendUint32(Ext4MballocAllocFtraceEventWire.GOAL_GROUP_WIRE, self.goal_group);
        }
        if (self.goal_len != 0) {
            target.appendInt32(Ext4MballocAllocFtraceEventWire.GOAL_LEN_WIRE, self.goal_len);
        }
        if (self.result_logical != 0) {
            target.appendUint32(Ext4MballocAllocFtraceEventWire.RESULT_LOGICAL_WIRE, self.result_logical);
        }
        if (self.result_start != 0) {
            target.appendInt32(Ext4MballocAllocFtraceEventWire.RESULT_START_WIRE, self.result_start);
        }
        if (self.result_group != 0) {
            target.appendUint32(Ext4MballocAllocFtraceEventWire.RESULT_GROUP_WIRE, self.result_group);
        }
        if (self.result_len != 0) {
            target.appendInt32(Ext4MballocAllocFtraceEventWire.RESULT_LEN_WIRE, self.result_len);
        }
        if (self.found != 0) {
            target.appendUint32(Ext4MballocAllocFtraceEventWire.FOUND_WIRE, self.found);
        }
        if (self.groups != 0) {
            target.appendUint32(Ext4MballocAllocFtraceEventWire.GROUPS_WIRE, self.groups);
        }
        if (self.buddy != 0) {
            target.appendUint32(Ext4MballocAllocFtraceEventWire.BUDDY_WIRE, self.buddy);
        }
        if (self.flags != 0) {
            target.appendUint32(Ext4MballocAllocFtraceEventWire.FLAGS_WIRE, self.flags);
        }
        if (self.tail != 0) {
            target.appendUint32(Ext4MballocAllocFtraceEventWire.TAIL_WIRE, self.tail);
        }
        if (self.cr != 0) {
            target.appendUint32(Ext4MballocAllocFtraceEventWire.CR_WIRE, self.cr);
        }
    }
};
pub const Ext4MballocAllocFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _orig_logical: u32 = 0,
    _orig_start: i32 = 0,
    _orig_group: u32 = 0,
    _orig_len: i32 = 0,
    _goal_logical: u32 = 0,
    _goal_start: i32 = 0,
    _goal_group: u32 = 0,
    _goal_len: i32 = 0,
    _result_logical: u32 = 0,
    _result_start: i32 = 0,
    _result_group: u32 = 0,
    _result_len: i32 = 0,
    _found: u32 = 0,
    _groups: u32 = 0,
    _buddy: u32 = 0,
    _flags: u32 = 0,
    _tail: u32 = 0,
    _cr: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4MballocAllocFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4MballocAllocFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4MballocAllocFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4MballocAllocFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4MballocAllocFtraceEventWire.ORIG_LOGICAL_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._orig_logical = result.value;
                },
                Ext4MballocAllocFtraceEventWire.ORIG_START_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._orig_start = result.value;
                },
                Ext4MballocAllocFtraceEventWire.ORIG_GROUP_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._orig_group = result.value;
                },
                Ext4MballocAllocFtraceEventWire.ORIG_LEN_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._orig_len = result.value;
                },
                Ext4MballocAllocFtraceEventWire.GOAL_LOGICAL_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._goal_logical = result.value;
                },
                Ext4MballocAllocFtraceEventWire.GOAL_START_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._goal_start = result.value;
                },
                Ext4MballocAllocFtraceEventWire.GOAL_GROUP_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._goal_group = result.value;
                },
                Ext4MballocAllocFtraceEventWire.GOAL_LEN_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._goal_len = result.value;
                },
                Ext4MballocAllocFtraceEventWire.RESULT_LOGICAL_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._result_logical = result.value;
                },
                Ext4MballocAllocFtraceEventWire.RESULT_START_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._result_start = result.value;
                },
                Ext4MballocAllocFtraceEventWire.RESULT_GROUP_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._result_group = result.value;
                },
                Ext4MballocAllocFtraceEventWire.RESULT_LEN_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._result_len = result.value;
                },
                Ext4MballocAllocFtraceEventWire.FOUND_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._found = result.value;
                },
                Ext4MballocAllocFtraceEventWire.GROUPS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._groups = result.value;
                },
                Ext4MballocAllocFtraceEventWire.BUDDY_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._buddy = result.value;
                },
                Ext4MballocAllocFtraceEventWire.FLAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._flags = result.value;
                },
                Ext4MballocAllocFtraceEventWire.TAIL_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._tail = result.value;
                },
                Ext4MballocAllocFtraceEventWire.CR_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._cr = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4MballocAllocFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4MballocAllocFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getOrigLogical(self: *const Ext4MballocAllocFtraceEventReader) u32 {
        return self._orig_logical;
    }
    pub inline fn getOrigStart(self: *const Ext4MballocAllocFtraceEventReader) i32 {
        return self._orig_start;
    }
    pub inline fn getOrigGroup(self: *const Ext4MballocAllocFtraceEventReader) u32 {
        return self._orig_group;
    }
    pub inline fn getOrigLen(self: *const Ext4MballocAllocFtraceEventReader) i32 {
        return self._orig_len;
    }
    pub inline fn getGoalLogical(self: *const Ext4MballocAllocFtraceEventReader) u32 {
        return self._goal_logical;
    }
    pub inline fn getGoalStart(self: *const Ext4MballocAllocFtraceEventReader) i32 {
        return self._goal_start;
    }
    pub inline fn getGoalGroup(self: *const Ext4MballocAllocFtraceEventReader) u32 {
        return self._goal_group;
    }
    pub inline fn getGoalLen(self: *const Ext4MballocAllocFtraceEventReader) i32 {
        return self._goal_len;
    }
    pub inline fn getResultLogical(self: *const Ext4MballocAllocFtraceEventReader) u32 {
        return self._result_logical;
    }
    pub inline fn getResultStart(self: *const Ext4MballocAllocFtraceEventReader) i32 {
        return self._result_start;
    }
    pub inline fn getResultGroup(self: *const Ext4MballocAllocFtraceEventReader) u32 {
        return self._result_group;
    }
    pub inline fn getResultLen(self: *const Ext4MballocAllocFtraceEventReader) i32 {
        return self._result_len;
    }
    pub inline fn getFound(self: *const Ext4MballocAllocFtraceEventReader) u32 {
        return self._found;
    }
    pub inline fn getGroups(self: *const Ext4MballocAllocFtraceEventReader) u32 {
        return self._groups;
    }
    pub inline fn getBuddy(self: *const Ext4MballocAllocFtraceEventReader) u32 {
        return self._buddy;
    }
    pub inline fn getFlags(self: *const Ext4MballocAllocFtraceEventReader) u32 {
        return self._flags;
    }
    pub inline fn getTail(self: *const Ext4MballocAllocFtraceEventReader) u32 {
        return self._tail;
    }
    pub inline fn getCr(self: *const Ext4MballocAllocFtraceEventReader) u32 {
        return self._cr;
    }
};
const Ext4MballocDiscardFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const RESULT_START_WIRE: gremlin.ProtoWireNumber = 3;
    const RESULT_GROUP_WIRE: gremlin.ProtoWireNumber = 4;
    const RESULT_LEN_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const Ext4MballocDiscardFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    result_start: i32 = 0,
    result_group: u32 = 0,
    result_len: i32 = 0,
    pub fn calcProtobufSize(self: *const Ext4MballocDiscardFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MballocDiscardFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MballocDiscardFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.result_start != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MballocDiscardFtraceEventWire.RESULT_START_WIRE) + gremlin.sizes.sizeI32(self.result_start);
        }
        if (self.result_group != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MballocDiscardFtraceEventWire.RESULT_GROUP_WIRE) + gremlin.sizes.sizeU32(self.result_group);
        }
        if (self.result_len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MballocDiscardFtraceEventWire.RESULT_LEN_WIRE) + gremlin.sizes.sizeI32(self.result_len);
        }
        return res;
    }
    pub fn encode(self: *const Ext4MballocDiscardFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4MballocDiscardFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4MballocDiscardFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4MballocDiscardFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.result_start != 0) {
            target.appendInt32(Ext4MballocDiscardFtraceEventWire.RESULT_START_WIRE, self.result_start);
        }
        if (self.result_group != 0) {
            target.appendUint32(Ext4MballocDiscardFtraceEventWire.RESULT_GROUP_WIRE, self.result_group);
        }
        if (self.result_len != 0) {
            target.appendInt32(Ext4MballocDiscardFtraceEventWire.RESULT_LEN_WIRE, self.result_len);
        }
    }
};
pub const Ext4MballocDiscardFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _result_start: i32 = 0,
    _result_group: u32 = 0,
    _result_len: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4MballocDiscardFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4MballocDiscardFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4MballocDiscardFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4MballocDiscardFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4MballocDiscardFtraceEventWire.RESULT_START_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._result_start = result.value;
                },
                Ext4MballocDiscardFtraceEventWire.RESULT_GROUP_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._result_group = result.value;
                },
                Ext4MballocDiscardFtraceEventWire.RESULT_LEN_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._result_len = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4MballocDiscardFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4MballocDiscardFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getResultStart(self: *const Ext4MballocDiscardFtraceEventReader) i32 {
        return self._result_start;
    }
    pub inline fn getResultGroup(self: *const Ext4MballocDiscardFtraceEventReader) u32 {
        return self._result_group;
    }
    pub inline fn getResultLen(self: *const Ext4MballocDiscardFtraceEventReader) i32 {
        return self._result_len;
    }
};
const Ext4MballocFreeFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const RESULT_START_WIRE: gremlin.ProtoWireNumber = 3;
    const RESULT_GROUP_WIRE: gremlin.ProtoWireNumber = 4;
    const RESULT_LEN_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const Ext4MballocFreeFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    result_start: i32 = 0,
    result_group: u32 = 0,
    result_len: i32 = 0,
    pub fn calcProtobufSize(self: *const Ext4MballocFreeFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MballocFreeFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MballocFreeFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.result_start != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MballocFreeFtraceEventWire.RESULT_START_WIRE) + gremlin.sizes.sizeI32(self.result_start);
        }
        if (self.result_group != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MballocFreeFtraceEventWire.RESULT_GROUP_WIRE) + gremlin.sizes.sizeU32(self.result_group);
        }
        if (self.result_len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MballocFreeFtraceEventWire.RESULT_LEN_WIRE) + gremlin.sizes.sizeI32(self.result_len);
        }
        return res;
    }
    pub fn encode(self: *const Ext4MballocFreeFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4MballocFreeFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4MballocFreeFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4MballocFreeFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.result_start != 0) {
            target.appendInt32(Ext4MballocFreeFtraceEventWire.RESULT_START_WIRE, self.result_start);
        }
        if (self.result_group != 0) {
            target.appendUint32(Ext4MballocFreeFtraceEventWire.RESULT_GROUP_WIRE, self.result_group);
        }
        if (self.result_len != 0) {
            target.appendInt32(Ext4MballocFreeFtraceEventWire.RESULT_LEN_WIRE, self.result_len);
        }
    }
};
pub const Ext4MballocFreeFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _result_start: i32 = 0,
    _result_group: u32 = 0,
    _result_len: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4MballocFreeFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4MballocFreeFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4MballocFreeFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4MballocFreeFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4MballocFreeFtraceEventWire.RESULT_START_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._result_start = result.value;
                },
                Ext4MballocFreeFtraceEventWire.RESULT_GROUP_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._result_group = result.value;
                },
                Ext4MballocFreeFtraceEventWire.RESULT_LEN_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._result_len = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4MballocFreeFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4MballocFreeFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getResultStart(self: *const Ext4MballocFreeFtraceEventReader) i32 {
        return self._result_start;
    }
    pub inline fn getResultGroup(self: *const Ext4MballocFreeFtraceEventReader) u32 {
        return self._result_group;
    }
    pub inline fn getResultLen(self: *const Ext4MballocFreeFtraceEventReader) i32 {
        return self._result_len;
    }
};
const Ext4MballocPreallocFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const ORIG_LOGICAL_WIRE: gremlin.ProtoWireNumber = 3;
    const ORIG_START_WIRE: gremlin.ProtoWireNumber = 4;
    const ORIG_GROUP_WIRE: gremlin.ProtoWireNumber = 5;
    const ORIG_LEN_WIRE: gremlin.ProtoWireNumber = 6;
    const RESULT_LOGICAL_WIRE: gremlin.ProtoWireNumber = 7;
    const RESULT_START_WIRE: gremlin.ProtoWireNumber = 8;
    const RESULT_GROUP_WIRE: gremlin.ProtoWireNumber = 9;
    const RESULT_LEN_WIRE: gremlin.ProtoWireNumber = 10;
};
pub const Ext4MballocPreallocFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    orig_logical: u32 = 0,
    orig_start: i32 = 0,
    orig_group: u32 = 0,
    orig_len: i32 = 0,
    result_logical: u32 = 0,
    result_start: i32 = 0,
    result_group: u32 = 0,
    result_len: i32 = 0,
    pub fn calcProtobufSize(self: *const Ext4MballocPreallocFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MballocPreallocFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MballocPreallocFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.orig_logical != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MballocPreallocFtraceEventWire.ORIG_LOGICAL_WIRE) + gremlin.sizes.sizeU32(self.orig_logical);
        }
        if (self.orig_start != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MballocPreallocFtraceEventWire.ORIG_START_WIRE) + gremlin.sizes.sizeI32(self.orig_start);
        }
        if (self.orig_group != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MballocPreallocFtraceEventWire.ORIG_GROUP_WIRE) + gremlin.sizes.sizeU32(self.orig_group);
        }
        if (self.orig_len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MballocPreallocFtraceEventWire.ORIG_LEN_WIRE) + gremlin.sizes.sizeI32(self.orig_len);
        }
        if (self.result_logical != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MballocPreallocFtraceEventWire.RESULT_LOGICAL_WIRE) + gremlin.sizes.sizeU32(self.result_logical);
        }
        if (self.result_start != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MballocPreallocFtraceEventWire.RESULT_START_WIRE) + gremlin.sizes.sizeI32(self.result_start);
        }
        if (self.result_group != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MballocPreallocFtraceEventWire.RESULT_GROUP_WIRE) + gremlin.sizes.sizeU32(self.result_group);
        }
        if (self.result_len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4MballocPreallocFtraceEventWire.RESULT_LEN_WIRE) + gremlin.sizes.sizeI32(self.result_len);
        }
        return res;
    }
    pub fn encode(self: *const Ext4MballocPreallocFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4MballocPreallocFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4MballocPreallocFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4MballocPreallocFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.orig_logical != 0) {
            target.appendUint32(Ext4MballocPreallocFtraceEventWire.ORIG_LOGICAL_WIRE, self.orig_logical);
        }
        if (self.orig_start != 0) {
            target.appendInt32(Ext4MballocPreallocFtraceEventWire.ORIG_START_WIRE, self.orig_start);
        }
        if (self.orig_group != 0) {
            target.appendUint32(Ext4MballocPreallocFtraceEventWire.ORIG_GROUP_WIRE, self.orig_group);
        }
        if (self.orig_len != 0) {
            target.appendInt32(Ext4MballocPreallocFtraceEventWire.ORIG_LEN_WIRE, self.orig_len);
        }
        if (self.result_logical != 0) {
            target.appendUint32(Ext4MballocPreallocFtraceEventWire.RESULT_LOGICAL_WIRE, self.result_logical);
        }
        if (self.result_start != 0) {
            target.appendInt32(Ext4MballocPreallocFtraceEventWire.RESULT_START_WIRE, self.result_start);
        }
        if (self.result_group != 0) {
            target.appendUint32(Ext4MballocPreallocFtraceEventWire.RESULT_GROUP_WIRE, self.result_group);
        }
        if (self.result_len != 0) {
            target.appendInt32(Ext4MballocPreallocFtraceEventWire.RESULT_LEN_WIRE, self.result_len);
        }
    }
};
pub const Ext4MballocPreallocFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _orig_logical: u32 = 0,
    _orig_start: i32 = 0,
    _orig_group: u32 = 0,
    _orig_len: i32 = 0,
    _result_logical: u32 = 0,
    _result_start: i32 = 0,
    _result_group: u32 = 0,
    _result_len: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4MballocPreallocFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4MballocPreallocFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4MballocPreallocFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4MballocPreallocFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4MballocPreallocFtraceEventWire.ORIG_LOGICAL_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._orig_logical = result.value;
                },
                Ext4MballocPreallocFtraceEventWire.ORIG_START_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._orig_start = result.value;
                },
                Ext4MballocPreallocFtraceEventWire.ORIG_GROUP_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._orig_group = result.value;
                },
                Ext4MballocPreallocFtraceEventWire.ORIG_LEN_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._orig_len = result.value;
                },
                Ext4MballocPreallocFtraceEventWire.RESULT_LOGICAL_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._result_logical = result.value;
                },
                Ext4MballocPreallocFtraceEventWire.RESULT_START_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._result_start = result.value;
                },
                Ext4MballocPreallocFtraceEventWire.RESULT_GROUP_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._result_group = result.value;
                },
                Ext4MballocPreallocFtraceEventWire.RESULT_LEN_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._result_len = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4MballocPreallocFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4MballocPreallocFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getOrigLogical(self: *const Ext4MballocPreallocFtraceEventReader) u32 {
        return self._orig_logical;
    }
    pub inline fn getOrigStart(self: *const Ext4MballocPreallocFtraceEventReader) i32 {
        return self._orig_start;
    }
    pub inline fn getOrigGroup(self: *const Ext4MballocPreallocFtraceEventReader) u32 {
        return self._orig_group;
    }
    pub inline fn getOrigLen(self: *const Ext4MballocPreallocFtraceEventReader) i32 {
        return self._orig_len;
    }
    pub inline fn getResultLogical(self: *const Ext4MballocPreallocFtraceEventReader) u32 {
        return self._result_logical;
    }
    pub inline fn getResultStart(self: *const Ext4MballocPreallocFtraceEventReader) i32 {
        return self._result_start;
    }
    pub inline fn getResultGroup(self: *const Ext4MballocPreallocFtraceEventReader) u32 {
        return self._result_group;
    }
    pub inline fn getResultLen(self: *const Ext4MballocPreallocFtraceEventReader) i32 {
        return self._result_len;
    }
};
const Ext4OtherInodeUpdateTimeFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const ORIG_INO_WIRE: gremlin.ProtoWireNumber = 3;
    const UID_WIRE: gremlin.ProtoWireNumber = 4;
    const GID_WIRE: gremlin.ProtoWireNumber = 5;
    const MODE_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const Ext4OtherInodeUpdateTimeFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    orig_ino: u64 = 0,
    uid: u32 = 0,
    gid: u32 = 0,
    mode: u32 = 0,
    pub fn calcProtobufSize(self: *const Ext4OtherInodeUpdateTimeFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4OtherInodeUpdateTimeFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4OtherInodeUpdateTimeFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.orig_ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4OtherInodeUpdateTimeFtraceEventWire.ORIG_INO_WIRE) + gremlin.sizes.sizeU64(self.orig_ino);
        }
        if (self.uid != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4OtherInodeUpdateTimeFtraceEventWire.UID_WIRE) + gremlin.sizes.sizeU32(self.uid);
        }
        if (self.gid != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4OtherInodeUpdateTimeFtraceEventWire.GID_WIRE) + gremlin.sizes.sizeU32(self.gid);
        }
        if (self.mode != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4OtherInodeUpdateTimeFtraceEventWire.MODE_WIRE) + gremlin.sizes.sizeU32(self.mode);
        }
        return res;
    }
    pub fn encode(self: *const Ext4OtherInodeUpdateTimeFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4OtherInodeUpdateTimeFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4OtherInodeUpdateTimeFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4OtherInodeUpdateTimeFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.orig_ino != 0) {
            target.appendUint64(Ext4OtherInodeUpdateTimeFtraceEventWire.ORIG_INO_WIRE, self.orig_ino);
        }
        if (self.uid != 0) {
            target.appendUint32(Ext4OtherInodeUpdateTimeFtraceEventWire.UID_WIRE, self.uid);
        }
        if (self.gid != 0) {
            target.appendUint32(Ext4OtherInodeUpdateTimeFtraceEventWire.GID_WIRE, self.gid);
        }
        if (self.mode != 0) {
            target.appendUint32(Ext4OtherInodeUpdateTimeFtraceEventWire.MODE_WIRE, self.mode);
        }
    }
};
pub const Ext4OtherInodeUpdateTimeFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _orig_ino: u64 = 0,
    _uid: u32 = 0,
    _gid: u32 = 0,
    _mode: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4OtherInodeUpdateTimeFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4OtherInodeUpdateTimeFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4OtherInodeUpdateTimeFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4OtherInodeUpdateTimeFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4OtherInodeUpdateTimeFtraceEventWire.ORIG_INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._orig_ino = result.value;
                },
                Ext4OtherInodeUpdateTimeFtraceEventWire.UID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._uid = result.value;
                },
                Ext4OtherInodeUpdateTimeFtraceEventWire.GID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._gid = result.value;
                },
                Ext4OtherInodeUpdateTimeFtraceEventWire.MODE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._mode = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4OtherInodeUpdateTimeFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4OtherInodeUpdateTimeFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getOrigIno(self: *const Ext4OtherInodeUpdateTimeFtraceEventReader) u64 {
        return self._orig_ino;
    }
    pub inline fn getUid(self: *const Ext4OtherInodeUpdateTimeFtraceEventReader) u32 {
        return self._uid;
    }
    pub inline fn getGid(self: *const Ext4OtherInodeUpdateTimeFtraceEventReader) u32 {
        return self._gid;
    }
    pub inline fn getMode(self: *const Ext4OtherInodeUpdateTimeFtraceEventReader) u32 {
        return self._mode;
    }
};
const Ext4PunchHoleFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const OFFSET_WIRE: gremlin.ProtoWireNumber = 3;
    const LEN_WIRE: gremlin.ProtoWireNumber = 4;
    const MODE_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const Ext4PunchHoleFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    offset: i64 = 0,
    len: i64 = 0,
    mode: i32 = 0,
    pub fn calcProtobufSize(self: *const Ext4PunchHoleFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4PunchHoleFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4PunchHoleFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.offset != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4PunchHoleFtraceEventWire.OFFSET_WIRE) + gremlin.sizes.sizeI64(self.offset);
        }
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4PunchHoleFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeI64(self.len);
        }
        if (self.mode != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4PunchHoleFtraceEventWire.MODE_WIRE) + gremlin.sizes.sizeI32(self.mode);
        }
        return res;
    }
    pub fn encode(self: *const Ext4PunchHoleFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4PunchHoleFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4PunchHoleFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4PunchHoleFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.offset != 0) {
            target.appendInt64(Ext4PunchHoleFtraceEventWire.OFFSET_WIRE, self.offset);
        }
        if (self.len != 0) {
            target.appendInt64(Ext4PunchHoleFtraceEventWire.LEN_WIRE, self.len);
        }
        if (self.mode != 0) {
            target.appendInt32(Ext4PunchHoleFtraceEventWire.MODE_WIRE, self.mode);
        }
    }
};
pub const Ext4PunchHoleFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _offset: i64 = 0,
    _len: i64 = 0,
    _mode: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4PunchHoleFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4PunchHoleFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4PunchHoleFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4PunchHoleFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4PunchHoleFtraceEventWire.OFFSET_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._offset = result.value;
                },
                Ext4PunchHoleFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                Ext4PunchHoleFtraceEventWire.MODE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._mode = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4PunchHoleFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4PunchHoleFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getOffset(self: *const Ext4PunchHoleFtraceEventReader) i64 {
        return self._offset;
    }
    pub inline fn getLen(self: *const Ext4PunchHoleFtraceEventReader) i64 {
        return self._len;
    }
    pub inline fn getMode(self: *const Ext4PunchHoleFtraceEventReader) i32 {
        return self._mode;
    }
};
const Ext4ReadBlockBitmapLoadFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const GROUP_WIRE: gremlin.ProtoWireNumber = 2;
    const PREFETCH_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const Ext4ReadBlockBitmapLoadFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    group: u32 = 0,
    prefetch: u32 = 0,
    pub fn calcProtobufSize(self: *const Ext4ReadBlockBitmapLoadFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ReadBlockBitmapLoadFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.group != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ReadBlockBitmapLoadFtraceEventWire.GROUP_WIRE) + gremlin.sizes.sizeU32(self.group);
        }
        if (self.prefetch != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ReadBlockBitmapLoadFtraceEventWire.PREFETCH_WIRE) + gremlin.sizes.sizeU32(self.prefetch);
        }
        return res;
    }
    pub fn encode(self: *const Ext4ReadBlockBitmapLoadFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4ReadBlockBitmapLoadFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4ReadBlockBitmapLoadFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.group != 0) {
            target.appendUint32(Ext4ReadBlockBitmapLoadFtraceEventWire.GROUP_WIRE, self.group);
        }
        if (self.prefetch != 0) {
            target.appendUint32(Ext4ReadBlockBitmapLoadFtraceEventWire.PREFETCH_WIRE, self.prefetch);
        }
    }
};
pub const Ext4ReadBlockBitmapLoadFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _group: u32 = 0,
    _prefetch: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4ReadBlockBitmapLoadFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4ReadBlockBitmapLoadFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4ReadBlockBitmapLoadFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4ReadBlockBitmapLoadFtraceEventWire.GROUP_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._group = result.value;
                },
                Ext4ReadBlockBitmapLoadFtraceEventWire.PREFETCH_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._prefetch = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4ReadBlockBitmapLoadFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getGroup(self: *const Ext4ReadBlockBitmapLoadFtraceEventReader) u32 {
        return self._group;
    }
    pub inline fn getPrefetch(self: *const Ext4ReadBlockBitmapLoadFtraceEventReader) u32 {
        return self._prefetch;
    }
};
const Ext4ReadpageFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const INDEX_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const Ext4ReadpageFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    index: u64 = 0,
    pub fn calcProtobufSize(self: *const Ext4ReadpageFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ReadpageFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ReadpageFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.index != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ReadpageFtraceEventWire.INDEX_WIRE) + gremlin.sizes.sizeU64(self.index);
        }
        return res;
    }
    pub fn encode(self: *const Ext4ReadpageFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4ReadpageFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4ReadpageFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4ReadpageFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.index != 0) {
            target.appendUint64(Ext4ReadpageFtraceEventWire.INDEX_WIRE, self.index);
        }
    }
};
pub const Ext4ReadpageFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _index: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4ReadpageFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4ReadpageFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4ReadpageFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4ReadpageFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4ReadpageFtraceEventWire.INDEX_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._index = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4ReadpageFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4ReadpageFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getIndex(self: *const Ext4ReadpageFtraceEventReader) u64 {
        return self._index;
    }
};
const Ext4ReleasepageFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const INDEX_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const Ext4ReleasepageFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    index: u64 = 0,
    pub fn calcProtobufSize(self: *const Ext4ReleasepageFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ReleasepageFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ReleasepageFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.index != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ReleasepageFtraceEventWire.INDEX_WIRE) + gremlin.sizes.sizeU64(self.index);
        }
        return res;
    }
    pub fn encode(self: *const Ext4ReleasepageFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4ReleasepageFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4ReleasepageFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4ReleasepageFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.index != 0) {
            target.appendUint64(Ext4ReleasepageFtraceEventWire.INDEX_WIRE, self.index);
        }
    }
};
pub const Ext4ReleasepageFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _index: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4ReleasepageFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4ReleasepageFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4ReleasepageFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4ReleasepageFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4ReleasepageFtraceEventWire.INDEX_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._index = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4ReleasepageFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4ReleasepageFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getIndex(self: *const Ext4ReleasepageFtraceEventReader) u64 {
        return self._index;
    }
};
const Ext4RemoveBlocksFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const FROM_WIRE: gremlin.ProtoWireNumber = 3;
    const TO_WIRE: gremlin.ProtoWireNumber = 4;
    const PARTIAL_WIRE: gremlin.ProtoWireNumber = 5;
    const EE_PBLK_WIRE: gremlin.ProtoWireNumber = 6;
    const EE_LBLK_WIRE: gremlin.ProtoWireNumber = 7;
    const EE_LEN_WIRE: gremlin.ProtoWireNumber = 8;
    const PC_LBLK_WIRE: gremlin.ProtoWireNumber = 9;
    const PC_PCLU_WIRE: gremlin.ProtoWireNumber = 10;
    const PC_STATE_WIRE: gremlin.ProtoWireNumber = 11;
};
pub const Ext4RemoveBlocksFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    from: u32 = 0,
    to: u32 = 0,
    partial: i64 = 0,
    ee_pblk: u64 = 0,
    ee_lblk: u32 = 0,
    ee_len: u32 = 0,
    pc_lblk: u32 = 0,
    pc_pclu: u64 = 0,
    pc_state: i32 = 0,
    pub fn calcProtobufSize(self: *const Ext4RemoveBlocksFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4RemoveBlocksFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4RemoveBlocksFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.from != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4RemoveBlocksFtraceEventWire.FROM_WIRE) + gremlin.sizes.sizeU32(self.from);
        }
        if (self.to != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4RemoveBlocksFtraceEventWire.TO_WIRE) + gremlin.sizes.sizeU32(self.to);
        }
        if (self.partial != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4RemoveBlocksFtraceEventWire.PARTIAL_WIRE) + gremlin.sizes.sizeI64(self.partial);
        }
        if (self.ee_pblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4RemoveBlocksFtraceEventWire.EE_PBLK_WIRE) + gremlin.sizes.sizeU64(self.ee_pblk);
        }
        if (self.ee_lblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4RemoveBlocksFtraceEventWire.EE_LBLK_WIRE) + gremlin.sizes.sizeU32(self.ee_lblk);
        }
        if (self.ee_len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4RemoveBlocksFtraceEventWire.EE_LEN_WIRE) + gremlin.sizes.sizeU32(self.ee_len);
        }
        if (self.pc_lblk != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4RemoveBlocksFtraceEventWire.PC_LBLK_WIRE) + gremlin.sizes.sizeU32(self.pc_lblk);
        }
        if (self.pc_pclu != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4RemoveBlocksFtraceEventWire.PC_PCLU_WIRE) + gremlin.sizes.sizeU64(self.pc_pclu);
        }
        if (self.pc_state != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4RemoveBlocksFtraceEventWire.PC_STATE_WIRE) + gremlin.sizes.sizeI32(self.pc_state);
        }
        return res;
    }
    pub fn encode(self: *const Ext4RemoveBlocksFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4RemoveBlocksFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4RemoveBlocksFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4RemoveBlocksFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.from != 0) {
            target.appendUint32(Ext4RemoveBlocksFtraceEventWire.FROM_WIRE, self.from);
        }
        if (self.to != 0) {
            target.appendUint32(Ext4RemoveBlocksFtraceEventWire.TO_WIRE, self.to);
        }
        if (self.partial != 0) {
            target.appendInt64(Ext4RemoveBlocksFtraceEventWire.PARTIAL_WIRE, self.partial);
        }
        if (self.ee_pblk != 0) {
            target.appendUint64(Ext4RemoveBlocksFtraceEventWire.EE_PBLK_WIRE, self.ee_pblk);
        }
        if (self.ee_lblk != 0) {
            target.appendUint32(Ext4RemoveBlocksFtraceEventWire.EE_LBLK_WIRE, self.ee_lblk);
        }
        if (self.ee_len != 0) {
            target.appendUint32(Ext4RemoveBlocksFtraceEventWire.EE_LEN_WIRE, self.ee_len);
        }
        if (self.pc_lblk != 0) {
            target.appendUint32(Ext4RemoveBlocksFtraceEventWire.PC_LBLK_WIRE, self.pc_lblk);
        }
        if (self.pc_pclu != 0) {
            target.appendUint64(Ext4RemoveBlocksFtraceEventWire.PC_PCLU_WIRE, self.pc_pclu);
        }
        if (self.pc_state != 0) {
            target.appendInt32(Ext4RemoveBlocksFtraceEventWire.PC_STATE_WIRE, self.pc_state);
        }
    }
};
pub const Ext4RemoveBlocksFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _from: u32 = 0,
    _to: u32 = 0,
    _partial: i64 = 0,
    _ee_pblk: u64 = 0,
    _ee_lblk: u32 = 0,
    _ee_len: u32 = 0,
    _pc_lblk: u32 = 0,
    _pc_pclu: u64 = 0,
    _pc_state: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4RemoveBlocksFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4RemoveBlocksFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4RemoveBlocksFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4RemoveBlocksFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4RemoveBlocksFtraceEventWire.FROM_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._from = result.value;
                },
                Ext4RemoveBlocksFtraceEventWire.TO_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._to = result.value;
                },
                Ext4RemoveBlocksFtraceEventWire.PARTIAL_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._partial = result.value;
                },
                Ext4RemoveBlocksFtraceEventWire.EE_PBLK_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ee_pblk = result.value;
                },
                Ext4RemoveBlocksFtraceEventWire.EE_LBLK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._ee_lblk = result.value;
                },
                Ext4RemoveBlocksFtraceEventWire.EE_LEN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._ee_len = result.value;
                },
                Ext4RemoveBlocksFtraceEventWire.PC_LBLK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._pc_lblk = result.value;
                },
                Ext4RemoveBlocksFtraceEventWire.PC_PCLU_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._pc_pclu = result.value;
                },
                Ext4RemoveBlocksFtraceEventWire.PC_STATE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._pc_state = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4RemoveBlocksFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4RemoveBlocksFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getFrom(self: *const Ext4RemoveBlocksFtraceEventReader) u32 {
        return self._from;
    }
    pub inline fn getTo(self: *const Ext4RemoveBlocksFtraceEventReader) u32 {
        return self._to;
    }
    pub inline fn getPartial(self: *const Ext4RemoveBlocksFtraceEventReader) i64 {
        return self._partial;
    }
    pub inline fn getEePblk(self: *const Ext4RemoveBlocksFtraceEventReader) u64 {
        return self._ee_pblk;
    }
    pub inline fn getEeLblk(self: *const Ext4RemoveBlocksFtraceEventReader) u32 {
        return self._ee_lblk;
    }
    pub inline fn getEeLen(self: *const Ext4RemoveBlocksFtraceEventReader) u32 {
        return self._ee_len;
    }
    pub inline fn getPcLblk(self: *const Ext4RemoveBlocksFtraceEventReader) u32 {
        return self._pc_lblk;
    }
    pub inline fn getPcPclu(self: *const Ext4RemoveBlocksFtraceEventReader) u64 {
        return self._pc_pclu;
    }
    pub inline fn getPcState(self: *const Ext4RemoveBlocksFtraceEventReader) i32 {
        return self._pc_state;
    }
};
const Ext4RequestBlocksFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const LEN_WIRE: gremlin.ProtoWireNumber = 3;
    const LOGICAL_WIRE: gremlin.ProtoWireNumber = 4;
    const LLEFT_WIRE: gremlin.ProtoWireNumber = 5;
    const LRIGHT_WIRE: gremlin.ProtoWireNumber = 6;
    const GOAL_WIRE: gremlin.ProtoWireNumber = 7;
    const PLEFT_WIRE: gremlin.ProtoWireNumber = 8;
    const PRIGHT_WIRE: gremlin.ProtoWireNumber = 9;
    const FLAGS_WIRE: gremlin.ProtoWireNumber = 10;
};
pub const Ext4RequestBlocksFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    len: u32 = 0,
    logical: u32 = 0,
    lleft: u32 = 0,
    lright: u32 = 0,
    goal: u64 = 0,
    pleft: u64 = 0,
    pright: u64 = 0,
    flags: u32 = 0,
    pub fn calcProtobufSize(self: *const Ext4RequestBlocksFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4RequestBlocksFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4RequestBlocksFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4RequestBlocksFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeU32(self.len);
        }
        if (self.logical != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4RequestBlocksFtraceEventWire.LOGICAL_WIRE) + gremlin.sizes.sizeU32(self.logical);
        }
        if (self.lleft != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4RequestBlocksFtraceEventWire.LLEFT_WIRE) + gremlin.sizes.sizeU32(self.lleft);
        }
        if (self.lright != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4RequestBlocksFtraceEventWire.LRIGHT_WIRE) + gremlin.sizes.sizeU32(self.lright);
        }
        if (self.goal != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4RequestBlocksFtraceEventWire.GOAL_WIRE) + gremlin.sizes.sizeU64(self.goal);
        }
        if (self.pleft != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4RequestBlocksFtraceEventWire.PLEFT_WIRE) + gremlin.sizes.sizeU64(self.pleft);
        }
        if (self.pright != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4RequestBlocksFtraceEventWire.PRIGHT_WIRE) + gremlin.sizes.sizeU64(self.pright);
        }
        if (self.flags != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4RequestBlocksFtraceEventWire.FLAGS_WIRE) + gremlin.sizes.sizeU32(self.flags);
        }
        return res;
    }
    pub fn encode(self: *const Ext4RequestBlocksFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4RequestBlocksFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4RequestBlocksFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4RequestBlocksFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.len != 0) {
            target.appendUint32(Ext4RequestBlocksFtraceEventWire.LEN_WIRE, self.len);
        }
        if (self.logical != 0) {
            target.appendUint32(Ext4RequestBlocksFtraceEventWire.LOGICAL_WIRE, self.logical);
        }
        if (self.lleft != 0) {
            target.appendUint32(Ext4RequestBlocksFtraceEventWire.LLEFT_WIRE, self.lleft);
        }
        if (self.lright != 0) {
            target.appendUint32(Ext4RequestBlocksFtraceEventWire.LRIGHT_WIRE, self.lright);
        }
        if (self.goal != 0) {
            target.appendUint64(Ext4RequestBlocksFtraceEventWire.GOAL_WIRE, self.goal);
        }
        if (self.pleft != 0) {
            target.appendUint64(Ext4RequestBlocksFtraceEventWire.PLEFT_WIRE, self.pleft);
        }
        if (self.pright != 0) {
            target.appendUint64(Ext4RequestBlocksFtraceEventWire.PRIGHT_WIRE, self.pright);
        }
        if (self.flags != 0) {
            target.appendUint32(Ext4RequestBlocksFtraceEventWire.FLAGS_WIRE, self.flags);
        }
    }
};
pub const Ext4RequestBlocksFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _len: u32 = 0,
    _logical: u32 = 0,
    _lleft: u32 = 0,
    _lright: u32 = 0,
    _goal: u64 = 0,
    _pleft: u64 = 0,
    _pright: u64 = 0,
    _flags: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4RequestBlocksFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4RequestBlocksFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4RequestBlocksFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4RequestBlocksFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4RequestBlocksFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                Ext4RequestBlocksFtraceEventWire.LOGICAL_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._logical = result.value;
                },
                Ext4RequestBlocksFtraceEventWire.LLEFT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._lleft = result.value;
                },
                Ext4RequestBlocksFtraceEventWire.LRIGHT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._lright = result.value;
                },
                Ext4RequestBlocksFtraceEventWire.GOAL_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._goal = result.value;
                },
                Ext4RequestBlocksFtraceEventWire.PLEFT_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._pleft = result.value;
                },
                Ext4RequestBlocksFtraceEventWire.PRIGHT_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._pright = result.value;
                },
                Ext4RequestBlocksFtraceEventWire.FLAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._flags = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4RequestBlocksFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4RequestBlocksFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getLen(self: *const Ext4RequestBlocksFtraceEventReader) u32 {
        return self._len;
    }
    pub inline fn getLogical(self: *const Ext4RequestBlocksFtraceEventReader) u32 {
        return self._logical;
    }
    pub inline fn getLleft(self: *const Ext4RequestBlocksFtraceEventReader) u32 {
        return self._lleft;
    }
    pub inline fn getLright(self: *const Ext4RequestBlocksFtraceEventReader) u32 {
        return self._lright;
    }
    pub inline fn getGoal(self: *const Ext4RequestBlocksFtraceEventReader) u64 {
        return self._goal;
    }
    pub inline fn getPleft(self: *const Ext4RequestBlocksFtraceEventReader) u64 {
        return self._pleft;
    }
    pub inline fn getPright(self: *const Ext4RequestBlocksFtraceEventReader) u64 {
        return self._pright;
    }
    pub inline fn getFlags(self: *const Ext4RequestBlocksFtraceEventReader) u32 {
        return self._flags;
    }
};
const Ext4RequestInodeFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const DIR_WIRE: gremlin.ProtoWireNumber = 2;
    const MODE_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const Ext4RequestInodeFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    dir: u64 = 0,
    mode: u32 = 0,
    pub fn calcProtobufSize(self: *const Ext4RequestInodeFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4RequestInodeFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.dir != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4RequestInodeFtraceEventWire.DIR_WIRE) + gremlin.sizes.sizeU64(self.dir);
        }
        if (self.mode != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4RequestInodeFtraceEventWire.MODE_WIRE) + gremlin.sizes.sizeU32(self.mode);
        }
        return res;
    }
    pub fn encode(self: *const Ext4RequestInodeFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4RequestInodeFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4RequestInodeFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.dir != 0) {
            target.appendUint64(Ext4RequestInodeFtraceEventWire.DIR_WIRE, self.dir);
        }
        if (self.mode != 0) {
            target.appendUint32(Ext4RequestInodeFtraceEventWire.MODE_WIRE, self.mode);
        }
    }
};
pub const Ext4RequestInodeFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _dir: u64 = 0,
    _mode: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4RequestInodeFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4RequestInodeFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4RequestInodeFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4RequestInodeFtraceEventWire.DIR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dir = result.value;
                },
                Ext4RequestInodeFtraceEventWire.MODE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._mode = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4RequestInodeFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getDir(self: *const Ext4RequestInodeFtraceEventReader) u64 {
        return self._dir;
    }
    pub inline fn getMode(self: *const Ext4RequestInodeFtraceEventReader) u32 {
        return self._mode;
    }
};
const Ext4SyncFsFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const WAIT_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const Ext4SyncFsFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    wait: i32 = 0,
    pub fn calcProtobufSize(self: *const Ext4SyncFsFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4SyncFsFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.wait != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4SyncFsFtraceEventWire.WAIT_WIRE) + gremlin.sizes.sizeI32(self.wait);
        }
        return res;
    }
    pub fn encode(self: *const Ext4SyncFsFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4SyncFsFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4SyncFsFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.wait != 0) {
            target.appendInt32(Ext4SyncFsFtraceEventWire.WAIT_WIRE, self.wait);
        }
    }
};
pub const Ext4SyncFsFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _wait: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4SyncFsFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4SyncFsFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4SyncFsFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4SyncFsFtraceEventWire.WAIT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._wait = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4SyncFsFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getWait(self: *const Ext4SyncFsFtraceEventReader) i32 {
        return self._wait;
    }
};
const Ext4TrimAllFreeFtraceEventWire = struct {
    const DEV_MAJOR_WIRE: gremlin.ProtoWireNumber = 1;
    const DEV_MINOR_WIRE: gremlin.ProtoWireNumber = 2;
    const GROUP_WIRE: gremlin.ProtoWireNumber = 3;
    const START_WIRE: gremlin.ProtoWireNumber = 4;
    const LEN_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const Ext4TrimAllFreeFtraceEvent = struct {
    // fields
    dev_major: i32 = 0,
    dev_minor: i32 = 0,
    group: u32 = 0,
    start: i32 = 0,
    len: i32 = 0,
    pub fn calcProtobufSize(self: *const Ext4TrimAllFreeFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev_major != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4TrimAllFreeFtraceEventWire.DEV_MAJOR_WIRE) + gremlin.sizes.sizeI32(self.dev_major);
        }
        if (self.dev_minor != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4TrimAllFreeFtraceEventWire.DEV_MINOR_WIRE) + gremlin.sizes.sizeI32(self.dev_minor);
        }
        if (self.group != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4TrimAllFreeFtraceEventWire.GROUP_WIRE) + gremlin.sizes.sizeU32(self.group);
        }
        if (self.start != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4TrimAllFreeFtraceEventWire.START_WIRE) + gremlin.sizes.sizeI32(self.start);
        }
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4TrimAllFreeFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeI32(self.len);
        }
        return res;
    }
    pub fn encode(self: *const Ext4TrimAllFreeFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4TrimAllFreeFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev_major != 0) {
            target.appendInt32(Ext4TrimAllFreeFtraceEventWire.DEV_MAJOR_WIRE, self.dev_major);
        }
        if (self.dev_minor != 0) {
            target.appendInt32(Ext4TrimAllFreeFtraceEventWire.DEV_MINOR_WIRE, self.dev_minor);
        }
        if (self.group != 0) {
            target.appendUint32(Ext4TrimAllFreeFtraceEventWire.GROUP_WIRE, self.group);
        }
        if (self.start != 0) {
            target.appendInt32(Ext4TrimAllFreeFtraceEventWire.START_WIRE, self.start);
        }
        if (self.len != 0) {
            target.appendInt32(Ext4TrimAllFreeFtraceEventWire.LEN_WIRE, self.len);
        }
    }
};
pub const Ext4TrimAllFreeFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev_major: i32 = 0,
    _dev_minor: i32 = 0,
    _group: u32 = 0,
    _start: i32 = 0,
    _len: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4TrimAllFreeFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4TrimAllFreeFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4TrimAllFreeFtraceEventWire.DEV_MAJOR_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._dev_major = result.value;
                },
                Ext4TrimAllFreeFtraceEventWire.DEV_MINOR_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._dev_minor = result.value;
                },
                Ext4TrimAllFreeFtraceEventWire.GROUP_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._group = result.value;
                },
                Ext4TrimAllFreeFtraceEventWire.START_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._start = result.value;
                },
                Ext4TrimAllFreeFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDevMajor(self: *const Ext4TrimAllFreeFtraceEventReader) i32 {
        return self._dev_major;
    }
    pub inline fn getDevMinor(self: *const Ext4TrimAllFreeFtraceEventReader) i32 {
        return self._dev_minor;
    }
    pub inline fn getGroup(self: *const Ext4TrimAllFreeFtraceEventReader) u32 {
        return self._group;
    }
    pub inline fn getStart(self: *const Ext4TrimAllFreeFtraceEventReader) i32 {
        return self._start;
    }
    pub inline fn getLen(self: *const Ext4TrimAllFreeFtraceEventReader) i32 {
        return self._len;
    }
};
const Ext4TrimExtentFtraceEventWire = struct {
    const DEV_MAJOR_WIRE: gremlin.ProtoWireNumber = 1;
    const DEV_MINOR_WIRE: gremlin.ProtoWireNumber = 2;
    const GROUP_WIRE: gremlin.ProtoWireNumber = 3;
    const START_WIRE: gremlin.ProtoWireNumber = 4;
    const LEN_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const Ext4TrimExtentFtraceEvent = struct {
    // fields
    dev_major: i32 = 0,
    dev_minor: i32 = 0,
    group: u32 = 0,
    start: i32 = 0,
    len: i32 = 0,
    pub fn calcProtobufSize(self: *const Ext4TrimExtentFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev_major != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4TrimExtentFtraceEventWire.DEV_MAJOR_WIRE) + gremlin.sizes.sizeI32(self.dev_major);
        }
        if (self.dev_minor != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4TrimExtentFtraceEventWire.DEV_MINOR_WIRE) + gremlin.sizes.sizeI32(self.dev_minor);
        }
        if (self.group != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4TrimExtentFtraceEventWire.GROUP_WIRE) + gremlin.sizes.sizeU32(self.group);
        }
        if (self.start != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4TrimExtentFtraceEventWire.START_WIRE) + gremlin.sizes.sizeI32(self.start);
        }
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4TrimExtentFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeI32(self.len);
        }
        return res;
    }
    pub fn encode(self: *const Ext4TrimExtentFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4TrimExtentFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev_major != 0) {
            target.appendInt32(Ext4TrimExtentFtraceEventWire.DEV_MAJOR_WIRE, self.dev_major);
        }
        if (self.dev_minor != 0) {
            target.appendInt32(Ext4TrimExtentFtraceEventWire.DEV_MINOR_WIRE, self.dev_minor);
        }
        if (self.group != 0) {
            target.appendUint32(Ext4TrimExtentFtraceEventWire.GROUP_WIRE, self.group);
        }
        if (self.start != 0) {
            target.appendInt32(Ext4TrimExtentFtraceEventWire.START_WIRE, self.start);
        }
        if (self.len != 0) {
            target.appendInt32(Ext4TrimExtentFtraceEventWire.LEN_WIRE, self.len);
        }
    }
};
pub const Ext4TrimExtentFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev_major: i32 = 0,
    _dev_minor: i32 = 0,
    _group: u32 = 0,
    _start: i32 = 0,
    _len: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4TrimExtentFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4TrimExtentFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4TrimExtentFtraceEventWire.DEV_MAJOR_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._dev_major = result.value;
                },
                Ext4TrimExtentFtraceEventWire.DEV_MINOR_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._dev_minor = result.value;
                },
                Ext4TrimExtentFtraceEventWire.GROUP_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._group = result.value;
                },
                Ext4TrimExtentFtraceEventWire.START_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._start = result.value;
                },
                Ext4TrimExtentFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDevMajor(self: *const Ext4TrimExtentFtraceEventReader) i32 {
        return self._dev_major;
    }
    pub inline fn getDevMinor(self: *const Ext4TrimExtentFtraceEventReader) i32 {
        return self._dev_minor;
    }
    pub inline fn getGroup(self: *const Ext4TrimExtentFtraceEventReader) u32 {
        return self._group;
    }
    pub inline fn getStart(self: *const Ext4TrimExtentFtraceEventReader) i32 {
        return self._start;
    }
    pub inline fn getLen(self: *const Ext4TrimExtentFtraceEventReader) i32 {
        return self._len;
    }
};
const Ext4TruncateEnterFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const BLOCKS_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const Ext4TruncateEnterFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    blocks: u64 = 0,
    pub fn calcProtobufSize(self: *const Ext4TruncateEnterFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4TruncateEnterFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4TruncateEnterFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.blocks != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4TruncateEnterFtraceEventWire.BLOCKS_WIRE) + gremlin.sizes.sizeU64(self.blocks);
        }
        return res;
    }
    pub fn encode(self: *const Ext4TruncateEnterFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4TruncateEnterFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4TruncateEnterFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4TruncateEnterFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.blocks != 0) {
            target.appendUint64(Ext4TruncateEnterFtraceEventWire.BLOCKS_WIRE, self.blocks);
        }
    }
};
pub const Ext4TruncateEnterFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _blocks: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4TruncateEnterFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4TruncateEnterFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4TruncateEnterFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4TruncateEnterFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4TruncateEnterFtraceEventWire.BLOCKS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._blocks = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4TruncateEnterFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4TruncateEnterFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getBlocks(self: *const Ext4TruncateEnterFtraceEventReader) u64 {
        return self._blocks;
    }
};
const Ext4TruncateExitFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const BLOCKS_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const Ext4TruncateExitFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    blocks: u64 = 0,
    pub fn calcProtobufSize(self: *const Ext4TruncateExitFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4TruncateExitFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4TruncateExitFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.blocks != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4TruncateExitFtraceEventWire.BLOCKS_WIRE) + gremlin.sizes.sizeU64(self.blocks);
        }
        return res;
    }
    pub fn encode(self: *const Ext4TruncateExitFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4TruncateExitFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4TruncateExitFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4TruncateExitFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.blocks != 0) {
            target.appendUint64(Ext4TruncateExitFtraceEventWire.BLOCKS_WIRE, self.blocks);
        }
    }
};
pub const Ext4TruncateExitFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _blocks: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4TruncateExitFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4TruncateExitFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4TruncateExitFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4TruncateExitFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4TruncateExitFtraceEventWire.BLOCKS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._blocks = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4TruncateExitFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4TruncateExitFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getBlocks(self: *const Ext4TruncateExitFtraceEventReader) u64 {
        return self._blocks;
    }
};
const Ext4UnlinkEnterFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const PARENT_WIRE: gremlin.ProtoWireNumber = 3;
    const SIZE_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const Ext4UnlinkEnterFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    parent: u64 = 0,
    size: i64 = 0,
    pub fn calcProtobufSize(self: *const Ext4UnlinkEnterFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4UnlinkEnterFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4UnlinkEnterFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.parent != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4UnlinkEnterFtraceEventWire.PARENT_WIRE) + gremlin.sizes.sizeU64(self.parent);
        }
        if (self.size != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4UnlinkEnterFtraceEventWire.SIZE_WIRE) + gremlin.sizes.sizeI64(self.size);
        }
        return res;
    }
    pub fn encode(self: *const Ext4UnlinkEnterFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4UnlinkEnterFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4UnlinkEnterFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4UnlinkEnterFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.parent != 0) {
            target.appendUint64(Ext4UnlinkEnterFtraceEventWire.PARENT_WIRE, self.parent);
        }
        if (self.size != 0) {
            target.appendInt64(Ext4UnlinkEnterFtraceEventWire.SIZE_WIRE, self.size);
        }
    }
};
pub const Ext4UnlinkEnterFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _parent: u64 = 0,
    _size: i64 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4UnlinkEnterFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4UnlinkEnterFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4UnlinkEnterFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4UnlinkEnterFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4UnlinkEnterFtraceEventWire.PARENT_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._parent = result.value;
                },
                Ext4UnlinkEnterFtraceEventWire.SIZE_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._size = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4UnlinkEnterFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4UnlinkEnterFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getParent(self: *const Ext4UnlinkEnterFtraceEventReader) u64 {
        return self._parent;
    }
    pub inline fn getSize(self: *const Ext4UnlinkEnterFtraceEventReader) i64 {
        return self._size;
    }
};
const Ext4UnlinkExitFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const RET_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const Ext4UnlinkExitFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    ret: i32 = 0,
    pub fn calcProtobufSize(self: *const Ext4UnlinkExitFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4UnlinkExitFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4UnlinkExitFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.ret != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4UnlinkExitFtraceEventWire.RET_WIRE) + gremlin.sizes.sizeI32(self.ret);
        }
        return res;
    }
    pub fn encode(self: *const Ext4UnlinkExitFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4UnlinkExitFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4UnlinkExitFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4UnlinkExitFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.ret != 0) {
            target.appendInt32(Ext4UnlinkExitFtraceEventWire.RET_WIRE, self.ret);
        }
    }
};
pub const Ext4UnlinkExitFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _ret: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4UnlinkExitFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4UnlinkExitFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4UnlinkExitFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4UnlinkExitFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4UnlinkExitFtraceEventWire.RET_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._ret = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4UnlinkExitFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4UnlinkExitFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getRet(self: *const Ext4UnlinkExitFtraceEventReader) i32 {
        return self._ret;
    }
};
const Ext4WriteBeginFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const POS_WIRE: gremlin.ProtoWireNumber = 3;
    const LEN_WIRE: gremlin.ProtoWireNumber = 4;
    const FLAGS_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const Ext4WriteBeginFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    pos: i64 = 0,
    len: u32 = 0,
    flags: u32 = 0,
    pub fn calcProtobufSize(self: *const Ext4WriteBeginFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4WriteBeginFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4WriteBeginFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.pos != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4WriteBeginFtraceEventWire.POS_WIRE) + gremlin.sizes.sizeI64(self.pos);
        }
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4WriteBeginFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeU32(self.len);
        }
        if (self.flags != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4WriteBeginFtraceEventWire.FLAGS_WIRE) + gremlin.sizes.sizeU32(self.flags);
        }
        return res;
    }
    pub fn encode(self: *const Ext4WriteBeginFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4WriteBeginFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4WriteBeginFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4WriteBeginFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.pos != 0) {
            target.appendInt64(Ext4WriteBeginFtraceEventWire.POS_WIRE, self.pos);
        }
        if (self.len != 0) {
            target.appendUint32(Ext4WriteBeginFtraceEventWire.LEN_WIRE, self.len);
        }
        if (self.flags != 0) {
            target.appendUint32(Ext4WriteBeginFtraceEventWire.FLAGS_WIRE, self.flags);
        }
    }
};
pub const Ext4WriteBeginFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _pos: i64 = 0,
    _len: u32 = 0,
    _flags: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4WriteBeginFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4WriteBeginFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4WriteBeginFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4WriteBeginFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4WriteBeginFtraceEventWire.POS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._pos = result.value;
                },
                Ext4WriteBeginFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                Ext4WriteBeginFtraceEventWire.FLAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._flags = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4WriteBeginFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4WriteBeginFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getPos(self: *const Ext4WriteBeginFtraceEventReader) i64 {
        return self._pos;
    }
    pub inline fn getLen(self: *const Ext4WriteBeginFtraceEventReader) u32 {
        return self._len;
    }
    pub inline fn getFlags(self: *const Ext4WriteBeginFtraceEventReader) u32 {
        return self._flags;
    }
};
const Ext4WriteEndFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const POS_WIRE: gremlin.ProtoWireNumber = 3;
    const LEN_WIRE: gremlin.ProtoWireNumber = 4;
    const COPIED_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const Ext4WriteEndFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    pos: i64 = 0,
    len: u32 = 0,
    copied: u32 = 0,
    pub fn calcProtobufSize(self: *const Ext4WriteEndFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4WriteEndFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4WriteEndFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.pos != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4WriteEndFtraceEventWire.POS_WIRE) + gremlin.sizes.sizeI64(self.pos);
        }
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4WriteEndFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeU32(self.len);
        }
        if (self.copied != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4WriteEndFtraceEventWire.COPIED_WIRE) + gremlin.sizes.sizeU32(self.copied);
        }
        return res;
    }
    pub fn encode(self: *const Ext4WriteEndFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4WriteEndFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4WriteEndFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4WriteEndFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.pos != 0) {
            target.appendInt64(Ext4WriteEndFtraceEventWire.POS_WIRE, self.pos);
        }
        if (self.len != 0) {
            target.appendUint32(Ext4WriteEndFtraceEventWire.LEN_WIRE, self.len);
        }
        if (self.copied != 0) {
            target.appendUint32(Ext4WriteEndFtraceEventWire.COPIED_WIRE, self.copied);
        }
    }
};
pub const Ext4WriteEndFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _pos: i64 = 0,
    _len: u32 = 0,
    _copied: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4WriteEndFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4WriteEndFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4WriteEndFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4WriteEndFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4WriteEndFtraceEventWire.POS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._pos = result.value;
                },
                Ext4WriteEndFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                Ext4WriteEndFtraceEventWire.COPIED_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._copied = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4WriteEndFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4WriteEndFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getPos(self: *const Ext4WriteEndFtraceEventReader) i64 {
        return self._pos;
    }
    pub inline fn getLen(self: *const Ext4WriteEndFtraceEventReader) u32 {
        return self._len;
    }
    pub inline fn getCopied(self: *const Ext4WriteEndFtraceEventReader) u32 {
        return self._copied;
    }
};
const Ext4WritepageFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const INDEX_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const Ext4WritepageFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    index: u64 = 0,
    pub fn calcProtobufSize(self: *const Ext4WritepageFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4WritepageFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4WritepageFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.index != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4WritepageFtraceEventWire.INDEX_WIRE) + gremlin.sizes.sizeU64(self.index);
        }
        return res;
    }
    pub fn encode(self: *const Ext4WritepageFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4WritepageFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4WritepageFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4WritepageFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.index != 0) {
            target.appendUint64(Ext4WritepageFtraceEventWire.INDEX_WIRE, self.index);
        }
    }
};
pub const Ext4WritepageFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _index: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4WritepageFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4WritepageFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4WritepageFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4WritepageFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4WritepageFtraceEventWire.INDEX_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._index = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4WritepageFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4WritepageFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getIndex(self: *const Ext4WritepageFtraceEventReader) u64 {
        return self._index;
    }
};
const Ext4WritepagesFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const NR_TO_WRITE_WIRE: gremlin.ProtoWireNumber = 3;
    const PAGES_SKIPPED_WIRE: gremlin.ProtoWireNumber = 4;
    const RANGE_START_WIRE: gremlin.ProtoWireNumber = 5;
    const RANGE_END_WIRE: gremlin.ProtoWireNumber = 6;
    const WRITEBACK_INDEX_WIRE: gremlin.ProtoWireNumber = 7;
    const SYNC_MODE_WIRE: gremlin.ProtoWireNumber = 8;
    const FOR_KUPDATE_WIRE: gremlin.ProtoWireNumber = 9;
    const RANGE_CYCLIC_WIRE: gremlin.ProtoWireNumber = 10;
};
pub const Ext4WritepagesFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    nr_to_write: i64 = 0,
    pages_skipped: i64 = 0,
    range_start: i64 = 0,
    range_end: i64 = 0,
    writeback_index: u64 = 0,
    sync_mode: i32 = 0,
    for_kupdate: u32 = 0,
    range_cyclic: u32 = 0,
    pub fn calcProtobufSize(self: *const Ext4WritepagesFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4WritepagesFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4WritepagesFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.nr_to_write != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4WritepagesFtraceEventWire.NR_TO_WRITE_WIRE) + gremlin.sizes.sizeI64(self.nr_to_write);
        }
        if (self.pages_skipped != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4WritepagesFtraceEventWire.PAGES_SKIPPED_WIRE) + gremlin.sizes.sizeI64(self.pages_skipped);
        }
        if (self.range_start != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4WritepagesFtraceEventWire.RANGE_START_WIRE) + gremlin.sizes.sizeI64(self.range_start);
        }
        if (self.range_end != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4WritepagesFtraceEventWire.RANGE_END_WIRE) + gremlin.sizes.sizeI64(self.range_end);
        }
        if (self.writeback_index != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4WritepagesFtraceEventWire.WRITEBACK_INDEX_WIRE) + gremlin.sizes.sizeU64(self.writeback_index);
        }
        if (self.sync_mode != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4WritepagesFtraceEventWire.SYNC_MODE_WIRE) + gremlin.sizes.sizeI32(self.sync_mode);
        }
        if (self.for_kupdate != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4WritepagesFtraceEventWire.FOR_KUPDATE_WIRE) + gremlin.sizes.sizeU32(self.for_kupdate);
        }
        if (self.range_cyclic != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4WritepagesFtraceEventWire.RANGE_CYCLIC_WIRE) + gremlin.sizes.sizeU32(self.range_cyclic);
        }
        return res;
    }
    pub fn encode(self: *const Ext4WritepagesFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4WritepagesFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4WritepagesFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4WritepagesFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.nr_to_write != 0) {
            target.appendInt64(Ext4WritepagesFtraceEventWire.NR_TO_WRITE_WIRE, self.nr_to_write);
        }
        if (self.pages_skipped != 0) {
            target.appendInt64(Ext4WritepagesFtraceEventWire.PAGES_SKIPPED_WIRE, self.pages_skipped);
        }
        if (self.range_start != 0) {
            target.appendInt64(Ext4WritepagesFtraceEventWire.RANGE_START_WIRE, self.range_start);
        }
        if (self.range_end != 0) {
            target.appendInt64(Ext4WritepagesFtraceEventWire.RANGE_END_WIRE, self.range_end);
        }
        if (self.writeback_index != 0) {
            target.appendUint64(Ext4WritepagesFtraceEventWire.WRITEBACK_INDEX_WIRE, self.writeback_index);
        }
        if (self.sync_mode != 0) {
            target.appendInt32(Ext4WritepagesFtraceEventWire.SYNC_MODE_WIRE, self.sync_mode);
        }
        if (self.for_kupdate != 0) {
            target.appendUint32(Ext4WritepagesFtraceEventWire.FOR_KUPDATE_WIRE, self.for_kupdate);
        }
        if (self.range_cyclic != 0) {
            target.appendUint32(Ext4WritepagesFtraceEventWire.RANGE_CYCLIC_WIRE, self.range_cyclic);
        }
    }
};
pub const Ext4WritepagesFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _nr_to_write: i64 = 0,
    _pages_skipped: i64 = 0,
    _range_start: i64 = 0,
    _range_end: i64 = 0,
    _writeback_index: u64 = 0,
    _sync_mode: i32 = 0,
    _for_kupdate: u32 = 0,
    _range_cyclic: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4WritepagesFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4WritepagesFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4WritepagesFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4WritepagesFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4WritepagesFtraceEventWire.NR_TO_WRITE_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._nr_to_write = result.value;
                },
                Ext4WritepagesFtraceEventWire.PAGES_SKIPPED_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._pages_skipped = result.value;
                },
                Ext4WritepagesFtraceEventWire.RANGE_START_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._range_start = result.value;
                },
                Ext4WritepagesFtraceEventWire.RANGE_END_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._range_end = result.value;
                },
                Ext4WritepagesFtraceEventWire.WRITEBACK_INDEX_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._writeback_index = result.value;
                },
                Ext4WritepagesFtraceEventWire.SYNC_MODE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._sync_mode = result.value;
                },
                Ext4WritepagesFtraceEventWire.FOR_KUPDATE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._for_kupdate = result.value;
                },
                Ext4WritepagesFtraceEventWire.RANGE_CYCLIC_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._range_cyclic = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4WritepagesFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4WritepagesFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getNrToWrite(self: *const Ext4WritepagesFtraceEventReader) i64 {
        return self._nr_to_write;
    }
    pub inline fn getPagesSkipped(self: *const Ext4WritepagesFtraceEventReader) i64 {
        return self._pages_skipped;
    }
    pub inline fn getRangeStart(self: *const Ext4WritepagesFtraceEventReader) i64 {
        return self._range_start;
    }
    pub inline fn getRangeEnd(self: *const Ext4WritepagesFtraceEventReader) i64 {
        return self._range_end;
    }
    pub inline fn getWritebackIndex(self: *const Ext4WritepagesFtraceEventReader) u64 {
        return self._writeback_index;
    }
    pub inline fn getSyncMode(self: *const Ext4WritepagesFtraceEventReader) i32 {
        return self._sync_mode;
    }
    pub inline fn getForKupdate(self: *const Ext4WritepagesFtraceEventReader) u32 {
        return self._for_kupdate;
    }
    pub inline fn getRangeCyclic(self: *const Ext4WritepagesFtraceEventReader) u32 {
        return self._range_cyclic;
    }
};
const Ext4WritepagesResultFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const RET_WIRE: gremlin.ProtoWireNumber = 3;
    const PAGES_WRITTEN_WIRE: gremlin.ProtoWireNumber = 4;
    const PAGES_SKIPPED_WIRE: gremlin.ProtoWireNumber = 5;
    const WRITEBACK_INDEX_WIRE: gremlin.ProtoWireNumber = 6;
    const SYNC_MODE_WIRE: gremlin.ProtoWireNumber = 7;
};
pub const Ext4WritepagesResultFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    ret: i32 = 0,
    pages_written: i32 = 0,
    pages_skipped: i64 = 0,
    writeback_index: u64 = 0,
    sync_mode: i32 = 0,
    pub fn calcProtobufSize(self: *const Ext4WritepagesResultFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4WritepagesResultFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4WritepagesResultFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.ret != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4WritepagesResultFtraceEventWire.RET_WIRE) + gremlin.sizes.sizeI32(self.ret);
        }
        if (self.pages_written != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4WritepagesResultFtraceEventWire.PAGES_WRITTEN_WIRE) + gremlin.sizes.sizeI32(self.pages_written);
        }
        if (self.pages_skipped != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4WritepagesResultFtraceEventWire.PAGES_SKIPPED_WIRE) + gremlin.sizes.sizeI64(self.pages_skipped);
        }
        if (self.writeback_index != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4WritepagesResultFtraceEventWire.WRITEBACK_INDEX_WIRE) + gremlin.sizes.sizeU64(self.writeback_index);
        }
        if (self.sync_mode != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4WritepagesResultFtraceEventWire.SYNC_MODE_WIRE) + gremlin.sizes.sizeI32(self.sync_mode);
        }
        return res;
    }
    pub fn encode(self: *const Ext4WritepagesResultFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4WritepagesResultFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4WritepagesResultFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4WritepagesResultFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.ret != 0) {
            target.appendInt32(Ext4WritepagesResultFtraceEventWire.RET_WIRE, self.ret);
        }
        if (self.pages_written != 0) {
            target.appendInt32(Ext4WritepagesResultFtraceEventWire.PAGES_WRITTEN_WIRE, self.pages_written);
        }
        if (self.pages_skipped != 0) {
            target.appendInt64(Ext4WritepagesResultFtraceEventWire.PAGES_SKIPPED_WIRE, self.pages_skipped);
        }
        if (self.writeback_index != 0) {
            target.appendUint64(Ext4WritepagesResultFtraceEventWire.WRITEBACK_INDEX_WIRE, self.writeback_index);
        }
        if (self.sync_mode != 0) {
            target.appendInt32(Ext4WritepagesResultFtraceEventWire.SYNC_MODE_WIRE, self.sync_mode);
        }
    }
};
pub const Ext4WritepagesResultFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _ret: i32 = 0,
    _pages_written: i32 = 0,
    _pages_skipped: i64 = 0,
    _writeback_index: u64 = 0,
    _sync_mode: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4WritepagesResultFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4WritepagesResultFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4WritepagesResultFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4WritepagesResultFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4WritepagesResultFtraceEventWire.RET_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._ret = result.value;
                },
                Ext4WritepagesResultFtraceEventWire.PAGES_WRITTEN_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._pages_written = result.value;
                },
                Ext4WritepagesResultFtraceEventWire.PAGES_SKIPPED_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._pages_skipped = result.value;
                },
                Ext4WritepagesResultFtraceEventWire.WRITEBACK_INDEX_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._writeback_index = result.value;
                },
                Ext4WritepagesResultFtraceEventWire.SYNC_MODE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._sync_mode = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4WritepagesResultFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4WritepagesResultFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getRet(self: *const Ext4WritepagesResultFtraceEventReader) i32 {
        return self._ret;
    }
    pub inline fn getPagesWritten(self: *const Ext4WritepagesResultFtraceEventReader) i32 {
        return self._pages_written;
    }
    pub inline fn getPagesSkipped(self: *const Ext4WritepagesResultFtraceEventReader) i64 {
        return self._pages_skipped;
    }
    pub inline fn getWritebackIndex(self: *const Ext4WritepagesResultFtraceEventReader) u64 {
        return self._writeback_index;
    }
    pub inline fn getSyncMode(self: *const Ext4WritepagesResultFtraceEventReader) i32 {
        return self._sync_mode;
    }
};
const Ext4ZeroRangeFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const OFFSET_WIRE: gremlin.ProtoWireNumber = 3;
    const LEN_WIRE: gremlin.ProtoWireNumber = 4;
    const MODE_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const Ext4ZeroRangeFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    offset: i64 = 0,
    len: i64 = 0,
    mode: i32 = 0,
    pub fn calcProtobufSize(self: *const Ext4ZeroRangeFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ZeroRangeFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ZeroRangeFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.offset != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ZeroRangeFtraceEventWire.OFFSET_WIRE) + gremlin.sizes.sizeI64(self.offset);
        }
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ZeroRangeFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeI64(self.len);
        }
        if (self.mode != 0) {
            res += gremlin.sizes.sizeWireNumber(Ext4ZeroRangeFtraceEventWire.MODE_WIRE) + gremlin.sizes.sizeI32(self.mode);
        }
        return res;
    }
    pub fn encode(self: *const Ext4ZeroRangeFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Ext4ZeroRangeFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(Ext4ZeroRangeFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(Ext4ZeroRangeFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.offset != 0) {
            target.appendInt64(Ext4ZeroRangeFtraceEventWire.OFFSET_WIRE, self.offset);
        }
        if (self.len != 0) {
            target.appendInt64(Ext4ZeroRangeFtraceEventWire.LEN_WIRE, self.len);
        }
        if (self.mode != 0) {
            target.appendInt32(Ext4ZeroRangeFtraceEventWire.MODE_WIRE, self.mode);
        }
    }
};
pub const Ext4ZeroRangeFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _offset: i64 = 0,
    _len: i64 = 0,
    _mode: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Ext4ZeroRangeFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Ext4ZeroRangeFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Ext4ZeroRangeFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                Ext4ZeroRangeFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                Ext4ZeroRangeFtraceEventWire.OFFSET_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._offset = result.value;
                },
                Ext4ZeroRangeFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                Ext4ZeroRangeFtraceEventWire.MODE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._mode = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const Ext4ZeroRangeFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const Ext4ZeroRangeFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getOffset(self: *const Ext4ZeroRangeFtraceEventReader) i64 {
        return self._offset;
    }
    pub inline fn getLen(self: *const Ext4ZeroRangeFtraceEventReader) i64 {
        return self._len;
    }
    pub inline fn getMode(self: *const Ext4ZeroRangeFtraceEventReader) i32 {
        return self._mode;
    }
};
