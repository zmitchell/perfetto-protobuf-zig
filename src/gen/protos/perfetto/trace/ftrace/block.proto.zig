// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const BlockRqIssueFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const SECTOR_WIRE: gremlin.ProtoWireNumber = 2;
    const NR_SECTOR_WIRE: gremlin.ProtoWireNumber = 3;
    const BYTES_WIRE: gremlin.ProtoWireNumber = 4;
    const RWBS_WIRE: gremlin.ProtoWireNumber = 5;
    const COMM_WIRE: gremlin.ProtoWireNumber = 6;
    const CMD_WIRE: gremlin.ProtoWireNumber = 7;
};
pub const BlockRqIssueFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    sector: u64 = 0,
    nr_sector: u32 = 0,
    bytes: u32 = 0,
    rwbs: ?[]const u8 = null,
    comm: ?[]const u8 = null,
    cmd: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const BlockRqIssueFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockRqIssueFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.sector != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockRqIssueFtraceEventWire.SECTOR_WIRE) + gremlin.sizes.sizeU64(self.sector);
        }
        if (self.nr_sector != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockRqIssueFtraceEventWire.NR_SECTOR_WIRE) + gremlin.sizes.sizeU32(self.nr_sector);
        }
        if (self.bytes != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockRqIssueFtraceEventWire.BYTES_WIRE) + gremlin.sizes.sizeU32(self.bytes);
        }
        if (self.rwbs) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(BlockRqIssueFtraceEventWire.RWBS_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.comm) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(BlockRqIssueFtraceEventWire.COMM_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.cmd) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(BlockRqIssueFtraceEventWire.CMD_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const BlockRqIssueFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const BlockRqIssueFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(BlockRqIssueFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.sector != 0) {
            target.appendUint64(BlockRqIssueFtraceEventWire.SECTOR_WIRE, self.sector);
        }
        if (self.nr_sector != 0) {
            target.appendUint32(BlockRqIssueFtraceEventWire.NR_SECTOR_WIRE, self.nr_sector);
        }
        if (self.bytes != 0) {
            target.appendUint32(BlockRqIssueFtraceEventWire.BYTES_WIRE, self.bytes);
        }
        if (self.rwbs) |v| {
            if (v.len > 0) {
                target.appendBytes(BlockRqIssueFtraceEventWire.RWBS_WIRE, v);
            }
        }
        if (self.comm) |v| {
            if (v.len > 0) {
                target.appendBytes(BlockRqIssueFtraceEventWire.COMM_WIRE, v);
            }
        }
        if (self.cmd) |v| {
            if (v.len > 0) {
                target.appendBytes(BlockRqIssueFtraceEventWire.CMD_WIRE, v);
            }
        }
    }
};
pub const BlockRqIssueFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _sector: u64 = 0,
    _nr_sector: u32 = 0,
    _bytes: u32 = 0,
    _rwbs: ?[]const u8 = null,
    _comm: ?[]const u8 = null,
    _cmd: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!BlockRqIssueFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = BlockRqIssueFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                BlockRqIssueFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                BlockRqIssueFtraceEventWire.SECTOR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._sector = result.value;
                },
                BlockRqIssueFtraceEventWire.NR_SECTOR_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._nr_sector = result.value;
                },
                BlockRqIssueFtraceEventWire.BYTES_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._bytes = result.value;
                },
                BlockRqIssueFtraceEventWire.RWBS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._rwbs = result.value;
                },
                BlockRqIssueFtraceEventWire.COMM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._comm = result.value;
                },
                BlockRqIssueFtraceEventWire.CMD_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cmd = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const BlockRqIssueFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getSector(self: *const BlockRqIssueFtraceEventReader) u64 {
        return self._sector;
    }
    pub inline fn getNrSector(self: *const BlockRqIssueFtraceEventReader) u32 {
        return self._nr_sector;
    }
    pub inline fn getBytes(self: *const BlockRqIssueFtraceEventReader) u32 {
        return self._bytes;
    }
    pub inline fn getRwbs(self: *const BlockRqIssueFtraceEventReader) []const u8 {
        return self._rwbs orelse &[_]u8{};
    }
    pub inline fn getComm(self: *const BlockRqIssueFtraceEventReader) []const u8 {
        return self._comm orelse &[_]u8{};
    }
    pub inline fn getCmd(self: *const BlockRqIssueFtraceEventReader) []const u8 {
        return self._cmd orelse &[_]u8{};
    }
};
const BlockBioBackmergeFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const SECTOR_WIRE: gremlin.ProtoWireNumber = 2;
    const NR_SECTOR_WIRE: gremlin.ProtoWireNumber = 3;
    const RWBS_WIRE: gremlin.ProtoWireNumber = 4;
    const COMM_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const BlockBioBackmergeFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    sector: u64 = 0,
    nr_sector: u32 = 0,
    rwbs: ?[]const u8 = null,
    comm: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const BlockBioBackmergeFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockBioBackmergeFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.sector != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockBioBackmergeFtraceEventWire.SECTOR_WIRE) + gremlin.sizes.sizeU64(self.sector);
        }
        if (self.nr_sector != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockBioBackmergeFtraceEventWire.NR_SECTOR_WIRE) + gremlin.sizes.sizeU32(self.nr_sector);
        }
        if (self.rwbs) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(BlockBioBackmergeFtraceEventWire.RWBS_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.comm) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(BlockBioBackmergeFtraceEventWire.COMM_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const BlockBioBackmergeFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const BlockBioBackmergeFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(BlockBioBackmergeFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.sector != 0) {
            target.appendUint64(BlockBioBackmergeFtraceEventWire.SECTOR_WIRE, self.sector);
        }
        if (self.nr_sector != 0) {
            target.appendUint32(BlockBioBackmergeFtraceEventWire.NR_SECTOR_WIRE, self.nr_sector);
        }
        if (self.rwbs) |v| {
            if (v.len > 0) {
                target.appendBytes(BlockBioBackmergeFtraceEventWire.RWBS_WIRE, v);
            }
        }
        if (self.comm) |v| {
            if (v.len > 0) {
                target.appendBytes(BlockBioBackmergeFtraceEventWire.COMM_WIRE, v);
            }
        }
    }
};
pub const BlockBioBackmergeFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _sector: u64 = 0,
    _nr_sector: u32 = 0,
    _rwbs: ?[]const u8 = null,
    _comm: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!BlockBioBackmergeFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = BlockBioBackmergeFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                BlockBioBackmergeFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                BlockBioBackmergeFtraceEventWire.SECTOR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._sector = result.value;
                },
                BlockBioBackmergeFtraceEventWire.NR_SECTOR_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._nr_sector = result.value;
                },
                BlockBioBackmergeFtraceEventWire.RWBS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._rwbs = result.value;
                },
                BlockBioBackmergeFtraceEventWire.COMM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._comm = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const BlockBioBackmergeFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getSector(self: *const BlockBioBackmergeFtraceEventReader) u64 {
        return self._sector;
    }
    pub inline fn getNrSector(self: *const BlockBioBackmergeFtraceEventReader) u32 {
        return self._nr_sector;
    }
    pub inline fn getRwbs(self: *const BlockBioBackmergeFtraceEventReader) []const u8 {
        return self._rwbs orelse &[_]u8{};
    }
    pub inline fn getComm(self: *const BlockBioBackmergeFtraceEventReader) []const u8 {
        return self._comm orelse &[_]u8{};
    }
};
const BlockBioBounceFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const SECTOR_WIRE: gremlin.ProtoWireNumber = 2;
    const NR_SECTOR_WIRE: gremlin.ProtoWireNumber = 3;
    const RWBS_WIRE: gremlin.ProtoWireNumber = 4;
    const COMM_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const BlockBioBounceFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    sector: u64 = 0,
    nr_sector: u32 = 0,
    rwbs: ?[]const u8 = null,
    comm: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const BlockBioBounceFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockBioBounceFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.sector != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockBioBounceFtraceEventWire.SECTOR_WIRE) + gremlin.sizes.sizeU64(self.sector);
        }
        if (self.nr_sector != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockBioBounceFtraceEventWire.NR_SECTOR_WIRE) + gremlin.sizes.sizeU32(self.nr_sector);
        }
        if (self.rwbs) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(BlockBioBounceFtraceEventWire.RWBS_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.comm) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(BlockBioBounceFtraceEventWire.COMM_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const BlockBioBounceFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const BlockBioBounceFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(BlockBioBounceFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.sector != 0) {
            target.appendUint64(BlockBioBounceFtraceEventWire.SECTOR_WIRE, self.sector);
        }
        if (self.nr_sector != 0) {
            target.appendUint32(BlockBioBounceFtraceEventWire.NR_SECTOR_WIRE, self.nr_sector);
        }
        if (self.rwbs) |v| {
            if (v.len > 0) {
                target.appendBytes(BlockBioBounceFtraceEventWire.RWBS_WIRE, v);
            }
        }
        if (self.comm) |v| {
            if (v.len > 0) {
                target.appendBytes(BlockBioBounceFtraceEventWire.COMM_WIRE, v);
            }
        }
    }
};
pub const BlockBioBounceFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _sector: u64 = 0,
    _nr_sector: u32 = 0,
    _rwbs: ?[]const u8 = null,
    _comm: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!BlockBioBounceFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = BlockBioBounceFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                BlockBioBounceFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                BlockBioBounceFtraceEventWire.SECTOR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._sector = result.value;
                },
                BlockBioBounceFtraceEventWire.NR_SECTOR_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._nr_sector = result.value;
                },
                BlockBioBounceFtraceEventWire.RWBS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._rwbs = result.value;
                },
                BlockBioBounceFtraceEventWire.COMM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._comm = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const BlockBioBounceFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getSector(self: *const BlockBioBounceFtraceEventReader) u64 {
        return self._sector;
    }
    pub inline fn getNrSector(self: *const BlockBioBounceFtraceEventReader) u32 {
        return self._nr_sector;
    }
    pub inline fn getRwbs(self: *const BlockBioBounceFtraceEventReader) []const u8 {
        return self._rwbs orelse &[_]u8{};
    }
    pub inline fn getComm(self: *const BlockBioBounceFtraceEventReader) []const u8 {
        return self._comm orelse &[_]u8{};
    }
};
const BlockBioCompleteFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const SECTOR_WIRE: gremlin.ProtoWireNumber = 2;
    const NR_SECTOR_WIRE: gremlin.ProtoWireNumber = 3;
    const ERROR_WIRE: gremlin.ProtoWireNumber = 4;
    const RWBS_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const BlockBioCompleteFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    sector: u64 = 0,
    nr_sector: u32 = 0,
    error_: i32 = 0,
    rwbs: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const BlockBioCompleteFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockBioCompleteFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.sector != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockBioCompleteFtraceEventWire.SECTOR_WIRE) + gremlin.sizes.sizeU64(self.sector);
        }
        if (self.nr_sector != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockBioCompleteFtraceEventWire.NR_SECTOR_WIRE) + gremlin.sizes.sizeU32(self.nr_sector);
        }
        if (self.error_ != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockBioCompleteFtraceEventWire.ERROR_WIRE) + gremlin.sizes.sizeI32(self.error_);
        }
        if (self.rwbs) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(BlockBioCompleteFtraceEventWire.RWBS_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const BlockBioCompleteFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const BlockBioCompleteFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(BlockBioCompleteFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.sector != 0) {
            target.appendUint64(BlockBioCompleteFtraceEventWire.SECTOR_WIRE, self.sector);
        }
        if (self.nr_sector != 0) {
            target.appendUint32(BlockBioCompleteFtraceEventWire.NR_SECTOR_WIRE, self.nr_sector);
        }
        if (self.error_ != 0) {
            target.appendInt32(BlockBioCompleteFtraceEventWire.ERROR_WIRE, self.error_);
        }
        if (self.rwbs) |v| {
            if (v.len > 0) {
                target.appendBytes(BlockBioCompleteFtraceEventWire.RWBS_WIRE, v);
            }
        }
    }
};
pub const BlockBioCompleteFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _sector: u64 = 0,
    _nr_sector: u32 = 0,
    _error_: i32 = 0,
    _rwbs: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!BlockBioCompleteFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = BlockBioCompleteFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                BlockBioCompleteFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                BlockBioCompleteFtraceEventWire.SECTOR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._sector = result.value;
                },
                BlockBioCompleteFtraceEventWire.NR_SECTOR_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._nr_sector = result.value;
                },
                BlockBioCompleteFtraceEventWire.ERROR_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._error_ = result.value;
                },
                BlockBioCompleteFtraceEventWire.RWBS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._rwbs = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const BlockBioCompleteFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getSector(self: *const BlockBioCompleteFtraceEventReader) u64 {
        return self._sector;
    }
    pub inline fn getNrSector(self: *const BlockBioCompleteFtraceEventReader) u32 {
        return self._nr_sector;
    }
    pub inline fn getError(self: *const BlockBioCompleteFtraceEventReader) i32 {
        return self._error_;
    }
    pub inline fn getRwbs(self: *const BlockBioCompleteFtraceEventReader) []const u8 {
        return self._rwbs orelse &[_]u8{};
    }
};
const BlockBioFrontmergeFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const SECTOR_WIRE: gremlin.ProtoWireNumber = 2;
    const NR_SECTOR_WIRE: gremlin.ProtoWireNumber = 3;
    const RWBS_WIRE: gremlin.ProtoWireNumber = 4;
    const COMM_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const BlockBioFrontmergeFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    sector: u64 = 0,
    nr_sector: u32 = 0,
    rwbs: ?[]const u8 = null,
    comm: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const BlockBioFrontmergeFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockBioFrontmergeFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.sector != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockBioFrontmergeFtraceEventWire.SECTOR_WIRE) + gremlin.sizes.sizeU64(self.sector);
        }
        if (self.nr_sector != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockBioFrontmergeFtraceEventWire.NR_SECTOR_WIRE) + gremlin.sizes.sizeU32(self.nr_sector);
        }
        if (self.rwbs) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(BlockBioFrontmergeFtraceEventWire.RWBS_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.comm) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(BlockBioFrontmergeFtraceEventWire.COMM_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const BlockBioFrontmergeFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const BlockBioFrontmergeFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(BlockBioFrontmergeFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.sector != 0) {
            target.appendUint64(BlockBioFrontmergeFtraceEventWire.SECTOR_WIRE, self.sector);
        }
        if (self.nr_sector != 0) {
            target.appendUint32(BlockBioFrontmergeFtraceEventWire.NR_SECTOR_WIRE, self.nr_sector);
        }
        if (self.rwbs) |v| {
            if (v.len > 0) {
                target.appendBytes(BlockBioFrontmergeFtraceEventWire.RWBS_WIRE, v);
            }
        }
        if (self.comm) |v| {
            if (v.len > 0) {
                target.appendBytes(BlockBioFrontmergeFtraceEventWire.COMM_WIRE, v);
            }
        }
    }
};
pub const BlockBioFrontmergeFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _sector: u64 = 0,
    _nr_sector: u32 = 0,
    _rwbs: ?[]const u8 = null,
    _comm: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!BlockBioFrontmergeFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = BlockBioFrontmergeFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                BlockBioFrontmergeFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                BlockBioFrontmergeFtraceEventWire.SECTOR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._sector = result.value;
                },
                BlockBioFrontmergeFtraceEventWire.NR_SECTOR_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._nr_sector = result.value;
                },
                BlockBioFrontmergeFtraceEventWire.RWBS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._rwbs = result.value;
                },
                BlockBioFrontmergeFtraceEventWire.COMM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._comm = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const BlockBioFrontmergeFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getSector(self: *const BlockBioFrontmergeFtraceEventReader) u64 {
        return self._sector;
    }
    pub inline fn getNrSector(self: *const BlockBioFrontmergeFtraceEventReader) u32 {
        return self._nr_sector;
    }
    pub inline fn getRwbs(self: *const BlockBioFrontmergeFtraceEventReader) []const u8 {
        return self._rwbs orelse &[_]u8{};
    }
    pub inline fn getComm(self: *const BlockBioFrontmergeFtraceEventReader) []const u8 {
        return self._comm orelse &[_]u8{};
    }
};
const BlockBioQueueFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const SECTOR_WIRE: gremlin.ProtoWireNumber = 2;
    const NR_SECTOR_WIRE: gremlin.ProtoWireNumber = 3;
    const RWBS_WIRE: gremlin.ProtoWireNumber = 4;
    const COMM_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const BlockBioQueueFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    sector: u64 = 0,
    nr_sector: u32 = 0,
    rwbs: ?[]const u8 = null,
    comm: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const BlockBioQueueFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockBioQueueFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.sector != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockBioQueueFtraceEventWire.SECTOR_WIRE) + gremlin.sizes.sizeU64(self.sector);
        }
        if (self.nr_sector != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockBioQueueFtraceEventWire.NR_SECTOR_WIRE) + gremlin.sizes.sizeU32(self.nr_sector);
        }
        if (self.rwbs) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(BlockBioQueueFtraceEventWire.RWBS_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.comm) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(BlockBioQueueFtraceEventWire.COMM_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const BlockBioQueueFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const BlockBioQueueFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(BlockBioQueueFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.sector != 0) {
            target.appendUint64(BlockBioQueueFtraceEventWire.SECTOR_WIRE, self.sector);
        }
        if (self.nr_sector != 0) {
            target.appendUint32(BlockBioQueueFtraceEventWire.NR_SECTOR_WIRE, self.nr_sector);
        }
        if (self.rwbs) |v| {
            if (v.len > 0) {
                target.appendBytes(BlockBioQueueFtraceEventWire.RWBS_WIRE, v);
            }
        }
        if (self.comm) |v| {
            if (v.len > 0) {
                target.appendBytes(BlockBioQueueFtraceEventWire.COMM_WIRE, v);
            }
        }
    }
};
pub const BlockBioQueueFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _sector: u64 = 0,
    _nr_sector: u32 = 0,
    _rwbs: ?[]const u8 = null,
    _comm: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!BlockBioQueueFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = BlockBioQueueFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                BlockBioQueueFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                BlockBioQueueFtraceEventWire.SECTOR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._sector = result.value;
                },
                BlockBioQueueFtraceEventWire.NR_SECTOR_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._nr_sector = result.value;
                },
                BlockBioQueueFtraceEventWire.RWBS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._rwbs = result.value;
                },
                BlockBioQueueFtraceEventWire.COMM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._comm = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const BlockBioQueueFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getSector(self: *const BlockBioQueueFtraceEventReader) u64 {
        return self._sector;
    }
    pub inline fn getNrSector(self: *const BlockBioQueueFtraceEventReader) u32 {
        return self._nr_sector;
    }
    pub inline fn getRwbs(self: *const BlockBioQueueFtraceEventReader) []const u8 {
        return self._rwbs orelse &[_]u8{};
    }
    pub inline fn getComm(self: *const BlockBioQueueFtraceEventReader) []const u8 {
        return self._comm orelse &[_]u8{};
    }
};
const BlockBioRemapFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const SECTOR_WIRE: gremlin.ProtoWireNumber = 2;
    const NR_SECTOR_WIRE: gremlin.ProtoWireNumber = 3;
    const OLD_DEV_WIRE: gremlin.ProtoWireNumber = 4;
    const OLD_SECTOR_WIRE: gremlin.ProtoWireNumber = 5;
    const RWBS_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const BlockBioRemapFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    sector: u64 = 0,
    nr_sector: u32 = 0,
    old_dev: u64 = 0,
    old_sector: u64 = 0,
    rwbs: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const BlockBioRemapFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockBioRemapFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.sector != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockBioRemapFtraceEventWire.SECTOR_WIRE) + gremlin.sizes.sizeU64(self.sector);
        }
        if (self.nr_sector != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockBioRemapFtraceEventWire.NR_SECTOR_WIRE) + gremlin.sizes.sizeU32(self.nr_sector);
        }
        if (self.old_dev != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockBioRemapFtraceEventWire.OLD_DEV_WIRE) + gremlin.sizes.sizeU64(self.old_dev);
        }
        if (self.old_sector != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockBioRemapFtraceEventWire.OLD_SECTOR_WIRE) + gremlin.sizes.sizeU64(self.old_sector);
        }
        if (self.rwbs) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(BlockBioRemapFtraceEventWire.RWBS_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const BlockBioRemapFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const BlockBioRemapFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(BlockBioRemapFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.sector != 0) {
            target.appendUint64(BlockBioRemapFtraceEventWire.SECTOR_WIRE, self.sector);
        }
        if (self.nr_sector != 0) {
            target.appendUint32(BlockBioRemapFtraceEventWire.NR_SECTOR_WIRE, self.nr_sector);
        }
        if (self.old_dev != 0) {
            target.appendUint64(BlockBioRemapFtraceEventWire.OLD_DEV_WIRE, self.old_dev);
        }
        if (self.old_sector != 0) {
            target.appendUint64(BlockBioRemapFtraceEventWire.OLD_SECTOR_WIRE, self.old_sector);
        }
        if (self.rwbs) |v| {
            if (v.len > 0) {
                target.appendBytes(BlockBioRemapFtraceEventWire.RWBS_WIRE, v);
            }
        }
    }
};
pub const BlockBioRemapFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _sector: u64 = 0,
    _nr_sector: u32 = 0,
    _old_dev: u64 = 0,
    _old_sector: u64 = 0,
    _rwbs: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!BlockBioRemapFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = BlockBioRemapFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                BlockBioRemapFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                BlockBioRemapFtraceEventWire.SECTOR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._sector = result.value;
                },
                BlockBioRemapFtraceEventWire.NR_SECTOR_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._nr_sector = result.value;
                },
                BlockBioRemapFtraceEventWire.OLD_DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._old_dev = result.value;
                },
                BlockBioRemapFtraceEventWire.OLD_SECTOR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._old_sector = result.value;
                },
                BlockBioRemapFtraceEventWire.RWBS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._rwbs = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const BlockBioRemapFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getSector(self: *const BlockBioRemapFtraceEventReader) u64 {
        return self._sector;
    }
    pub inline fn getNrSector(self: *const BlockBioRemapFtraceEventReader) u32 {
        return self._nr_sector;
    }
    pub inline fn getOldDev(self: *const BlockBioRemapFtraceEventReader) u64 {
        return self._old_dev;
    }
    pub inline fn getOldSector(self: *const BlockBioRemapFtraceEventReader) u64 {
        return self._old_sector;
    }
    pub inline fn getRwbs(self: *const BlockBioRemapFtraceEventReader) []const u8 {
        return self._rwbs orelse &[_]u8{};
    }
};
const BlockDirtyBufferFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const SECTOR_WIRE: gremlin.ProtoWireNumber = 2;
    const SIZE_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const BlockDirtyBufferFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    sector: u64 = 0,
    size: u64 = 0,
    pub fn calcProtobufSize(self: *const BlockDirtyBufferFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockDirtyBufferFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.sector != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockDirtyBufferFtraceEventWire.SECTOR_WIRE) + gremlin.sizes.sizeU64(self.sector);
        }
        if (self.size != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockDirtyBufferFtraceEventWire.SIZE_WIRE) + gremlin.sizes.sizeU64(self.size);
        }
        return res;
    }
    pub fn encode(self: *const BlockDirtyBufferFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const BlockDirtyBufferFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(BlockDirtyBufferFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.sector != 0) {
            target.appendUint64(BlockDirtyBufferFtraceEventWire.SECTOR_WIRE, self.sector);
        }
        if (self.size != 0) {
            target.appendUint64(BlockDirtyBufferFtraceEventWire.SIZE_WIRE, self.size);
        }
    }
};
pub const BlockDirtyBufferFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _sector: u64 = 0,
    _size: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!BlockDirtyBufferFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = BlockDirtyBufferFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                BlockDirtyBufferFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                BlockDirtyBufferFtraceEventWire.SECTOR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._sector = result.value;
                },
                BlockDirtyBufferFtraceEventWire.SIZE_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._size = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const BlockDirtyBufferFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getSector(self: *const BlockDirtyBufferFtraceEventReader) u64 {
        return self._sector;
    }
    pub inline fn getSize(self: *const BlockDirtyBufferFtraceEventReader) u64 {
        return self._size;
    }
};
const BlockGetrqFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const SECTOR_WIRE: gremlin.ProtoWireNumber = 2;
    const NR_SECTOR_WIRE: gremlin.ProtoWireNumber = 3;
    const RWBS_WIRE: gremlin.ProtoWireNumber = 4;
    const COMM_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const BlockGetrqFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    sector: u64 = 0,
    nr_sector: u32 = 0,
    rwbs: ?[]const u8 = null,
    comm: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const BlockGetrqFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockGetrqFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.sector != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockGetrqFtraceEventWire.SECTOR_WIRE) + gremlin.sizes.sizeU64(self.sector);
        }
        if (self.nr_sector != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockGetrqFtraceEventWire.NR_SECTOR_WIRE) + gremlin.sizes.sizeU32(self.nr_sector);
        }
        if (self.rwbs) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(BlockGetrqFtraceEventWire.RWBS_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.comm) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(BlockGetrqFtraceEventWire.COMM_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const BlockGetrqFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const BlockGetrqFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(BlockGetrqFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.sector != 0) {
            target.appendUint64(BlockGetrqFtraceEventWire.SECTOR_WIRE, self.sector);
        }
        if (self.nr_sector != 0) {
            target.appendUint32(BlockGetrqFtraceEventWire.NR_SECTOR_WIRE, self.nr_sector);
        }
        if (self.rwbs) |v| {
            if (v.len > 0) {
                target.appendBytes(BlockGetrqFtraceEventWire.RWBS_WIRE, v);
            }
        }
        if (self.comm) |v| {
            if (v.len > 0) {
                target.appendBytes(BlockGetrqFtraceEventWire.COMM_WIRE, v);
            }
        }
    }
};
pub const BlockGetrqFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _sector: u64 = 0,
    _nr_sector: u32 = 0,
    _rwbs: ?[]const u8 = null,
    _comm: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!BlockGetrqFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = BlockGetrqFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                BlockGetrqFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                BlockGetrqFtraceEventWire.SECTOR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._sector = result.value;
                },
                BlockGetrqFtraceEventWire.NR_SECTOR_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._nr_sector = result.value;
                },
                BlockGetrqFtraceEventWire.RWBS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._rwbs = result.value;
                },
                BlockGetrqFtraceEventWire.COMM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._comm = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const BlockGetrqFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getSector(self: *const BlockGetrqFtraceEventReader) u64 {
        return self._sector;
    }
    pub inline fn getNrSector(self: *const BlockGetrqFtraceEventReader) u32 {
        return self._nr_sector;
    }
    pub inline fn getRwbs(self: *const BlockGetrqFtraceEventReader) []const u8 {
        return self._rwbs orelse &[_]u8{};
    }
    pub inline fn getComm(self: *const BlockGetrqFtraceEventReader) []const u8 {
        return self._comm orelse &[_]u8{};
    }
};
const BlockPlugFtraceEventWire = struct {
    const COMM_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const BlockPlugFtraceEvent = struct {
    // fields
    comm: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const BlockPlugFtraceEvent) usize {
        var res: usize = 0;
        if (self.comm) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(BlockPlugFtraceEventWire.COMM_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const BlockPlugFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const BlockPlugFtraceEvent, target: *gremlin.Writer) void {
        if (self.comm) |v| {
            if (v.len > 0) {
                target.appendBytes(BlockPlugFtraceEventWire.COMM_WIRE, v);
            }
        }
    }
};
pub const BlockPlugFtraceEventReader = struct {
    buf: gremlin.Reader,
    _comm: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!BlockPlugFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = BlockPlugFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                BlockPlugFtraceEventWire.COMM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._comm = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getComm(self: *const BlockPlugFtraceEventReader) []const u8 {
        return self._comm orelse &[_]u8{};
    }
};
const BlockRqAbortFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const SECTOR_WIRE: gremlin.ProtoWireNumber = 2;
    const NR_SECTOR_WIRE: gremlin.ProtoWireNumber = 3;
    const ERRORS_WIRE: gremlin.ProtoWireNumber = 4;
    const RWBS_WIRE: gremlin.ProtoWireNumber = 5;
    const CMD_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const BlockRqAbortFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    sector: u64 = 0,
    nr_sector: u32 = 0,
    errors: i32 = 0,
    rwbs: ?[]const u8 = null,
    cmd: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const BlockRqAbortFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockRqAbortFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.sector != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockRqAbortFtraceEventWire.SECTOR_WIRE) + gremlin.sizes.sizeU64(self.sector);
        }
        if (self.nr_sector != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockRqAbortFtraceEventWire.NR_SECTOR_WIRE) + gremlin.sizes.sizeU32(self.nr_sector);
        }
        if (self.errors != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockRqAbortFtraceEventWire.ERRORS_WIRE) + gremlin.sizes.sizeI32(self.errors);
        }
        if (self.rwbs) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(BlockRqAbortFtraceEventWire.RWBS_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.cmd) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(BlockRqAbortFtraceEventWire.CMD_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const BlockRqAbortFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const BlockRqAbortFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(BlockRqAbortFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.sector != 0) {
            target.appendUint64(BlockRqAbortFtraceEventWire.SECTOR_WIRE, self.sector);
        }
        if (self.nr_sector != 0) {
            target.appendUint32(BlockRqAbortFtraceEventWire.NR_SECTOR_WIRE, self.nr_sector);
        }
        if (self.errors != 0) {
            target.appendInt32(BlockRqAbortFtraceEventWire.ERRORS_WIRE, self.errors);
        }
        if (self.rwbs) |v| {
            if (v.len > 0) {
                target.appendBytes(BlockRqAbortFtraceEventWire.RWBS_WIRE, v);
            }
        }
        if (self.cmd) |v| {
            if (v.len > 0) {
                target.appendBytes(BlockRqAbortFtraceEventWire.CMD_WIRE, v);
            }
        }
    }
};
pub const BlockRqAbortFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _sector: u64 = 0,
    _nr_sector: u32 = 0,
    _errors: i32 = 0,
    _rwbs: ?[]const u8 = null,
    _cmd: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!BlockRqAbortFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = BlockRqAbortFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                BlockRqAbortFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                BlockRqAbortFtraceEventWire.SECTOR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._sector = result.value;
                },
                BlockRqAbortFtraceEventWire.NR_SECTOR_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._nr_sector = result.value;
                },
                BlockRqAbortFtraceEventWire.ERRORS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._errors = result.value;
                },
                BlockRqAbortFtraceEventWire.RWBS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._rwbs = result.value;
                },
                BlockRqAbortFtraceEventWire.CMD_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cmd = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const BlockRqAbortFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getSector(self: *const BlockRqAbortFtraceEventReader) u64 {
        return self._sector;
    }
    pub inline fn getNrSector(self: *const BlockRqAbortFtraceEventReader) u32 {
        return self._nr_sector;
    }
    pub inline fn getErrors(self: *const BlockRqAbortFtraceEventReader) i32 {
        return self._errors;
    }
    pub inline fn getRwbs(self: *const BlockRqAbortFtraceEventReader) []const u8 {
        return self._rwbs orelse &[_]u8{};
    }
    pub inline fn getCmd(self: *const BlockRqAbortFtraceEventReader) []const u8 {
        return self._cmd orelse &[_]u8{};
    }
};
const BlockRqCompleteFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const SECTOR_WIRE: gremlin.ProtoWireNumber = 2;
    const NR_SECTOR_WIRE: gremlin.ProtoWireNumber = 3;
    const ERRORS_WIRE: gremlin.ProtoWireNumber = 4;
    const RWBS_WIRE: gremlin.ProtoWireNumber = 5;
    const CMD_WIRE: gremlin.ProtoWireNumber = 6;
    const ERROR_WIRE: gremlin.ProtoWireNumber = 7;
};
pub const BlockRqCompleteFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    sector: u64 = 0,
    nr_sector: u32 = 0,
    errors: i32 = 0,
    rwbs: ?[]const u8 = null,
    cmd: ?[]const u8 = null,
    error_: i32 = 0,
    pub fn calcProtobufSize(self: *const BlockRqCompleteFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockRqCompleteFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.sector != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockRqCompleteFtraceEventWire.SECTOR_WIRE) + gremlin.sizes.sizeU64(self.sector);
        }
        if (self.nr_sector != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockRqCompleteFtraceEventWire.NR_SECTOR_WIRE) + gremlin.sizes.sizeU32(self.nr_sector);
        }
        if (self.errors != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockRqCompleteFtraceEventWire.ERRORS_WIRE) + gremlin.sizes.sizeI32(self.errors);
        }
        if (self.rwbs) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(BlockRqCompleteFtraceEventWire.RWBS_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.cmd) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(BlockRqCompleteFtraceEventWire.CMD_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.error_ != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockRqCompleteFtraceEventWire.ERROR_WIRE) + gremlin.sizes.sizeI32(self.error_);
        }
        return res;
    }
    pub fn encode(self: *const BlockRqCompleteFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const BlockRqCompleteFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(BlockRqCompleteFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.sector != 0) {
            target.appendUint64(BlockRqCompleteFtraceEventWire.SECTOR_WIRE, self.sector);
        }
        if (self.nr_sector != 0) {
            target.appendUint32(BlockRqCompleteFtraceEventWire.NR_SECTOR_WIRE, self.nr_sector);
        }
        if (self.errors != 0) {
            target.appendInt32(BlockRqCompleteFtraceEventWire.ERRORS_WIRE, self.errors);
        }
        if (self.rwbs) |v| {
            if (v.len > 0) {
                target.appendBytes(BlockRqCompleteFtraceEventWire.RWBS_WIRE, v);
            }
        }
        if (self.cmd) |v| {
            if (v.len > 0) {
                target.appendBytes(BlockRqCompleteFtraceEventWire.CMD_WIRE, v);
            }
        }
        if (self.error_ != 0) {
            target.appendInt32(BlockRqCompleteFtraceEventWire.ERROR_WIRE, self.error_);
        }
    }
};
pub const BlockRqCompleteFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _sector: u64 = 0,
    _nr_sector: u32 = 0,
    _errors: i32 = 0,
    _rwbs: ?[]const u8 = null,
    _cmd: ?[]const u8 = null,
    _error_: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!BlockRqCompleteFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = BlockRqCompleteFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                BlockRqCompleteFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                BlockRqCompleteFtraceEventWire.SECTOR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._sector = result.value;
                },
                BlockRqCompleteFtraceEventWire.NR_SECTOR_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._nr_sector = result.value;
                },
                BlockRqCompleteFtraceEventWire.ERRORS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._errors = result.value;
                },
                BlockRqCompleteFtraceEventWire.RWBS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._rwbs = result.value;
                },
                BlockRqCompleteFtraceEventWire.CMD_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cmd = result.value;
                },
                BlockRqCompleteFtraceEventWire.ERROR_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._error_ = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const BlockRqCompleteFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getSector(self: *const BlockRqCompleteFtraceEventReader) u64 {
        return self._sector;
    }
    pub inline fn getNrSector(self: *const BlockRqCompleteFtraceEventReader) u32 {
        return self._nr_sector;
    }
    pub inline fn getErrors(self: *const BlockRqCompleteFtraceEventReader) i32 {
        return self._errors;
    }
    pub inline fn getRwbs(self: *const BlockRqCompleteFtraceEventReader) []const u8 {
        return self._rwbs orelse &[_]u8{};
    }
    pub inline fn getCmd(self: *const BlockRqCompleteFtraceEventReader) []const u8 {
        return self._cmd orelse &[_]u8{};
    }
    pub inline fn getError(self: *const BlockRqCompleteFtraceEventReader) i32 {
        return self._error_;
    }
};
const BlockRqInsertFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const SECTOR_WIRE: gremlin.ProtoWireNumber = 2;
    const NR_SECTOR_WIRE: gremlin.ProtoWireNumber = 3;
    const BYTES_WIRE: gremlin.ProtoWireNumber = 4;
    const RWBS_WIRE: gremlin.ProtoWireNumber = 5;
    const COMM_WIRE: gremlin.ProtoWireNumber = 6;
    const CMD_WIRE: gremlin.ProtoWireNumber = 7;
};
pub const BlockRqInsertFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    sector: u64 = 0,
    nr_sector: u32 = 0,
    bytes: u32 = 0,
    rwbs: ?[]const u8 = null,
    comm: ?[]const u8 = null,
    cmd: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const BlockRqInsertFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockRqInsertFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.sector != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockRqInsertFtraceEventWire.SECTOR_WIRE) + gremlin.sizes.sizeU64(self.sector);
        }
        if (self.nr_sector != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockRqInsertFtraceEventWire.NR_SECTOR_WIRE) + gremlin.sizes.sizeU32(self.nr_sector);
        }
        if (self.bytes != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockRqInsertFtraceEventWire.BYTES_WIRE) + gremlin.sizes.sizeU32(self.bytes);
        }
        if (self.rwbs) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(BlockRqInsertFtraceEventWire.RWBS_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.comm) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(BlockRqInsertFtraceEventWire.COMM_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.cmd) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(BlockRqInsertFtraceEventWire.CMD_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const BlockRqInsertFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const BlockRqInsertFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(BlockRqInsertFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.sector != 0) {
            target.appendUint64(BlockRqInsertFtraceEventWire.SECTOR_WIRE, self.sector);
        }
        if (self.nr_sector != 0) {
            target.appendUint32(BlockRqInsertFtraceEventWire.NR_SECTOR_WIRE, self.nr_sector);
        }
        if (self.bytes != 0) {
            target.appendUint32(BlockRqInsertFtraceEventWire.BYTES_WIRE, self.bytes);
        }
        if (self.rwbs) |v| {
            if (v.len > 0) {
                target.appendBytes(BlockRqInsertFtraceEventWire.RWBS_WIRE, v);
            }
        }
        if (self.comm) |v| {
            if (v.len > 0) {
                target.appendBytes(BlockRqInsertFtraceEventWire.COMM_WIRE, v);
            }
        }
        if (self.cmd) |v| {
            if (v.len > 0) {
                target.appendBytes(BlockRqInsertFtraceEventWire.CMD_WIRE, v);
            }
        }
    }
};
pub const BlockRqInsertFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _sector: u64 = 0,
    _nr_sector: u32 = 0,
    _bytes: u32 = 0,
    _rwbs: ?[]const u8 = null,
    _comm: ?[]const u8 = null,
    _cmd: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!BlockRqInsertFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = BlockRqInsertFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                BlockRqInsertFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                BlockRqInsertFtraceEventWire.SECTOR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._sector = result.value;
                },
                BlockRqInsertFtraceEventWire.NR_SECTOR_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._nr_sector = result.value;
                },
                BlockRqInsertFtraceEventWire.BYTES_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._bytes = result.value;
                },
                BlockRqInsertFtraceEventWire.RWBS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._rwbs = result.value;
                },
                BlockRqInsertFtraceEventWire.COMM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._comm = result.value;
                },
                BlockRqInsertFtraceEventWire.CMD_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cmd = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const BlockRqInsertFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getSector(self: *const BlockRqInsertFtraceEventReader) u64 {
        return self._sector;
    }
    pub inline fn getNrSector(self: *const BlockRqInsertFtraceEventReader) u32 {
        return self._nr_sector;
    }
    pub inline fn getBytes(self: *const BlockRqInsertFtraceEventReader) u32 {
        return self._bytes;
    }
    pub inline fn getRwbs(self: *const BlockRqInsertFtraceEventReader) []const u8 {
        return self._rwbs orelse &[_]u8{};
    }
    pub inline fn getComm(self: *const BlockRqInsertFtraceEventReader) []const u8 {
        return self._comm orelse &[_]u8{};
    }
    pub inline fn getCmd(self: *const BlockRqInsertFtraceEventReader) []const u8 {
        return self._cmd orelse &[_]u8{};
    }
};
const BlockRqRemapFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const SECTOR_WIRE: gremlin.ProtoWireNumber = 2;
    const NR_SECTOR_WIRE: gremlin.ProtoWireNumber = 3;
    const OLD_DEV_WIRE: gremlin.ProtoWireNumber = 4;
    const OLD_SECTOR_WIRE: gremlin.ProtoWireNumber = 5;
    const NR_BIOS_WIRE: gremlin.ProtoWireNumber = 6;
    const RWBS_WIRE: gremlin.ProtoWireNumber = 7;
};
pub const BlockRqRemapFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    sector: u64 = 0,
    nr_sector: u32 = 0,
    old_dev: u64 = 0,
    old_sector: u64 = 0,
    nr_bios: u32 = 0,
    rwbs: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const BlockRqRemapFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockRqRemapFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.sector != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockRqRemapFtraceEventWire.SECTOR_WIRE) + gremlin.sizes.sizeU64(self.sector);
        }
        if (self.nr_sector != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockRqRemapFtraceEventWire.NR_SECTOR_WIRE) + gremlin.sizes.sizeU32(self.nr_sector);
        }
        if (self.old_dev != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockRqRemapFtraceEventWire.OLD_DEV_WIRE) + gremlin.sizes.sizeU64(self.old_dev);
        }
        if (self.old_sector != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockRqRemapFtraceEventWire.OLD_SECTOR_WIRE) + gremlin.sizes.sizeU64(self.old_sector);
        }
        if (self.nr_bios != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockRqRemapFtraceEventWire.NR_BIOS_WIRE) + gremlin.sizes.sizeU32(self.nr_bios);
        }
        if (self.rwbs) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(BlockRqRemapFtraceEventWire.RWBS_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const BlockRqRemapFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const BlockRqRemapFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(BlockRqRemapFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.sector != 0) {
            target.appendUint64(BlockRqRemapFtraceEventWire.SECTOR_WIRE, self.sector);
        }
        if (self.nr_sector != 0) {
            target.appendUint32(BlockRqRemapFtraceEventWire.NR_SECTOR_WIRE, self.nr_sector);
        }
        if (self.old_dev != 0) {
            target.appendUint64(BlockRqRemapFtraceEventWire.OLD_DEV_WIRE, self.old_dev);
        }
        if (self.old_sector != 0) {
            target.appendUint64(BlockRqRemapFtraceEventWire.OLD_SECTOR_WIRE, self.old_sector);
        }
        if (self.nr_bios != 0) {
            target.appendUint32(BlockRqRemapFtraceEventWire.NR_BIOS_WIRE, self.nr_bios);
        }
        if (self.rwbs) |v| {
            if (v.len > 0) {
                target.appendBytes(BlockRqRemapFtraceEventWire.RWBS_WIRE, v);
            }
        }
    }
};
pub const BlockRqRemapFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _sector: u64 = 0,
    _nr_sector: u32 = 0,
    _old_dev: u64 = 0,
    _old_sector: u64 = 0,
    _nr_bios: u32 = 0,
    _rwbs: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!BlockRqRemapFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = BlockRqRemapFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                BlockRqRemapFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                BlockRqRemapFtraceEventWire.SECTOR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._sector = result.value;
                },
                BlockRqRemapFtraceEventWire.NR_SECTOR_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._nr_sector = result.value;
                },
                BlockRqRemapFtraceEventWire.OLD_DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._old_dev = result.value;
                },
                BlockRqRemapFtraceEventWire.OLD_SECTOR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._old_sector = result.value;
                },
                BlockRqRemapFtraceEventWire.NR_BIOS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._nr_bios = result.value;
                },
                BlockRqRemapFtraceEventWire.RWBS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._rwbs = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const BlockRqRemapFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getSector(self: *const BlockRqRemapFtraceEventReader) u64 {
        return self._sector;
    }
    pub inline fn getNrSector(self: *const BlockRqRemapFtraceEventReader) u32 {
        return self._nr_sector;
    }
    pub inline fn getOldDev(self: *const BlockRqRemapFtraceEventReader) u64 {
        return self._old_dev;
    }
    pub inline fn getOldSector(self: *const BlockRqRemapFtraceEventReader) u64 {
        return self._old_sector;
    }
    pub inline fn getNrBios(self: *const BlockRqRemapFtraceEventReader) u32 {
        return self._nr_bios;
    }
    pub inline fn getRwbs(self: *const BlockRqRemapFtraceEventReader) []const u8 {
        return self._rwbs orelse &[_]u8{};
    }
};
const BlockRqRequeueFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const SECTOR_WIRE: gremlin.ProtoWireNumber = 2;
    const NR_SECTOR_WIRE: gremlin.ProtoWireNumber = 3;
    const ERRORS_WIRE: gremlin.ProtoWireNumber = 4;
    const RWBS_WIRE: gremlin.ProtoWireNumber = 5;
    const CMD_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const BlockRqRequeueFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    sector: u64 = 0,
    nr_sector: u32 = 0,
    errors: i32 = 0,
    rwbs: ?[]const u8 = null,
    cmd: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const BlockRqRequeueFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockRqRequeueFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.sector != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockRqRequeueFtraceEventWire.SECTOR_WIRE) + gremlin.sizes.sizeU64(self.sector);
        }
        if (self.nr_sector != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockRqRequeueFtraceEventWire.NR_SECTOR_WIRE) + gremlin.sizes.sizeU32(self.nr_sector);
        }
        if (self.errors != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockRqRequeueFtraceEventWire.ERRORS_WIRE) + gremlin.sizes.sizeI32(self.errors);
        }
        if (self.rwbs) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(BlockRqRequeueFtraceEventWire.RWBS_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.cmd) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(BlockRqRequeueFtraceEventWire.CMD_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const BlockRqRequeueFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const BlockRqRequeueFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(BlockRqRequeueFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.sector != 0) {
            target.appendUint64(BlockRqRequeueFtraceEventWire.SECTOR_WIRE, self.sector);
        }
        if (self.nr_sector != 0) {
            target.appendUint32(BlockRqRequeueFtraceEventWire.NR_SECTOR_WIRE, self.nr_sector);
        }
        if (self.errors != 0) {
            target.appendInt32(BlockRqRequeueFtraceEventWire.ERRORS_WIRE, self.errors);
        }
        if (self.rwbs) |v| {
            if (v.len > 0) {
                target.appendBytes(BlockRqRequeueFtraceEventWire.RWBS_WIRE, v);
            }
        }
        if (self.cmd) |v| {
            if (v.len > 0) {
                target.appendBytes(BlockRqRequeueFtraceEventWire.CMD_WIRE, v);
            }
        }
    }
};
pub const BlockRqRequeueFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _sector: u64 = 0,
    _nr_sector: u32 = 0,
    _errors: i32 = 0,
    _rwbs: ?[]const u8 = null,
    _cmd: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!BlockRqRequeueFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = BlockRqRequeueFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                BlockRqRequeueFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                BlockRqRequeueFtraceEventWire.SECTOR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._sector = result.value;
                },
                BlockRqRequeueFtraceEventWire.NR_SECTOR_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._nr_sector = result.value;
                },
                BlockRqRequeueFtraceEventWire.ERRORS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._errors = result.value;
                },
                BlockRqRequeueFtraceEventWire.RWBS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._rwbs = result.value;
                },
                BlockRqRequeueFtraceEventWire.CMD_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cmd = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const BlockRqRequeueFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getSector(self: *const BlockRqRequeueFtraceEventReader) u64 {
        return self._sector;
    }
    pub inline fn getNrSector(self: *const BlockRqRequeueFtraceEventReader) u32 {
        return self._nr_sector;
    }
    pub inline fn getErrors(self: *const BlockRqRequeueFtraceEventReader) i32 {
        return self._errors;
    }
    pub inline fn getRwbs(self: *const BlockRqRequeueFtraceEventReader) []const u8 {
        return self._rwbs orelse &[_]u8{};
    }
    pub inline fn getCmd(self: *const BlockRqRequeueFtraceEventReader) []const u8 {
        return self._cmd orelse &[_]u8{};
    }
};
const BlockSleeprqFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const SECTOR_WIRE: gremlin.ProtoWireNumber = 2;
    const NR_SECTOR_WIRE: gremlin.ProtoWireNumber = 3;
    const RWBS_WIRE: gremlin.ProtoWireNumber = 4;
    const COMM_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const BlockSleeprqFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    sector: u64 = 0,
    nr_sector: u32 = 0,
    rwbs: ?[]const u8 = null,
    comm: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const BlockSleeprqFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockSleeprqFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.sector != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockSleeprqFtraceEventWire.SECTOR_WIRE) + gremlin.sizes.sizeU64(self.sector);
        }
        if (self.nr_sector != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockSleeprqFtraceEventWire.NR_SECTOR_WIRE) + gremlin.sizes.sizeU32(self.nr_sector);
        }
        if (self.rwbs) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(BlockSleeprqFtraceEventWire.RWBS_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.comm) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(BlockSleeprqFtraceEventWire.COMM_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const BlockSleeprqFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const BlockSleeprqFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(BlockSleeprqFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.sector != 0) {
            target.appendUint64(BlockSleeprqFtraceEventWire.SECTOR_WIRE, self.sector);
        }
        if (self.nr_sector != 0) {
            target.appendUint32(BlockSleeprqFtraceEventWire.NR_SECTOR_WIRE, self.nr_sector);
        }
        if (self.rwbs) |v| {
            if (v.len > 0) {
                target.appendBytes(BlockSleeprqFtraceEventWire.RWBS_WIRE, v);
            }
        }
        if (self.comm) |v| {
            if (v.len > 0) {
                target.appendBytes(BlockSleeprqFtraceEventWire.COMM_WIRE, v);
            }
        }
    }
};
pub const BlockSleeprqFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _sector: u64 = 0,
    _nr_sector: u32 = 0,
    _rwbs: ?[]const u8 = null,
    _comm: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!BlockSleeprqFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = BlockSleeprqFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                BlockSleeprqFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                BlockSleeprqFtraceEventWire.SECTOR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._sector = result.value;
                },
                BlockSleeprqFtraceEventWire.NR_SECTOR_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._nr_sector = result.value;
                },
                BlockSleeprqFtraceEventWire.RWBS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._rwbs = result.value;
                },
                BlockSleeprqFtraceEventWire.COMM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._comm = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const BlockSleeprqFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getSector(self: *const BlockSleeprqFtraceEventReader) u64 {
        return self._sector;
    }
    pub inline fn getNrSector(self: *const BlockSleeprqFtraceEventReader) u32 {
        return self._nr_sector;
    }
    pub inline fn getRwbs(self: *const BlockSleeprqFtraceEventReader) []const u8 {
        return self._rwbs orelse &[_]u8{};
    }
    pub inline fn getComm(self: *const BlockSleeprqFtraceEventReader) []const u8 {
        return self._comm orelse &[_]u8{};
    }
};
const BlockSplitFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const SECTOR_WIRE: gremlin.ProtoWireNumber = 2;
    const NEW_SECTOR_WIRE: gremlin.ProtoWireNumber = 3;
    const RWBS_WIRE: gremlin.ProtoWireNumber = 4;
    const COMM_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const BlockSplitFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    sector: u64 = 0,
    new_sector: u64 = 0,
    rwbs: ?[]const u8 = null,
    comm: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const BlockSplitFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockSplitFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.sector != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockSplitFtraceEventWire.SECTOR_WIRE) + gremlin.sizes.sizeU64(self.sector);
        }
        if (self.new_sector != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockSplitFtraceEventWire.NEW_SECTOR_WIRE) + gremlin.sizes.sizeU64(self.new_sector);
        }
        if (self.rwbs) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(BlockSplitFtraceEventWire.RWBS_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.comm) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(BlockSplitFtraceEventWire.COMM_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const BlockSplitFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const BlockSplitFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(BlockSplitFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.sector != 0) {
            target.appendUint64(BlockSplitFtraceEventWire.SECTOR_WIRE, self.sector);
        }
        if (self.new_sector != 0) {
            target.appendUint64(BlockSplitFtraceEventWire.NEW_SECTOR_WIRE, self.new_sector);
        }
        if (self.rwbs) |v| {
            if (v.len > 0) {
                target.appendBytes(BlockSplitFtraceEventWire.RWBS_WIRE, v);
            }
        }
        if (self.comm) |v| {
            if (v.len > 0) {
                target.appendBytes(BlockSplitFtraceEventWire.COMM_WIRE, v);
            }
        }
    }
};
pub const BlockSplitFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _sector: u64 = 0,
    _new_sector: u64 = 0,
    _rwbs: ?[]const u8 = null,
    _comm: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!BlockSplitFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = BlockSplitFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                BlockSplitFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                BlockSplitFtraceEventWire.SECTOR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._sector = result.value;
                },
                BlockSplitFtraceEventWire.NEW_SECTOR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._new_sector = result.value;
                },
                BlockSplitFtraceEventWire.RWBS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._rwbs = result.value;
                },
                BlockSplitFtraceEventWire.COMM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._comm = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const BlockSplitFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getSector(self: *const BlockSplitFtraceEventReader) u64 {
        return self._sector;
    }
    pub inline fn getNewSector(self: *const BlockSplitFtraceEventReader) u64 {
        return self._new_sector;
    }
    pub inline fn getRwbs(self: *const BlockSplitFtraceEventReader) []const u8 {
        return self._rwbs orelse &[_]u8{};
    }
    pub inline fn getComm(self: *const BlockSplitFtraceEventReader) []const u8 {
        return self._comm orelse &[_]u8{};
    }
};
const BlockTouchBufferFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const SECTOR_WIRE: gremlin.ProtoWireNumber = 2;
    const SIZE_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const BlockTouchBufferFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    sector: u64 = 0,
    size: u64 = 0,
    pub fn calcProtobufSize(self: *const BlockTouchBufferFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockTouchBufferFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.sector != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockTouchBufferFtraceEventWire.SECTOR_WIRE) + gremlin.sizes.sizeU64(self.sector);
        }
        if (self.size != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockTouchBufferFtraceEventWire.SIZE_WIRE) + gremlin.sizes.sizeU64(self.size);
        }
        return res;
    }
    pub fn encode(self: *const BlockTouchBufferFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const BlockTouchBufferFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(BlockTouchBufferFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.sector != 0) {
            target.appendUint64(BlockTouchBufferFtraceEventWire.SECTOR_WIRE, self.sector);
        }
        if (self.size != 0) {
            target.appendUint64(BlockTouchBufferFtraceEventWire.SIZE_WIRE, self.size);
        }
    }
};
pub const BlockTouchBufferFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _sector: u64 = 0,
    _size: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!BlockTouchBufferFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = BlockTouchBufferFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                BlockTouchBufferFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                BlockTouchBufferFtraceEventWire.SECTOR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._sector = result.value;
                },
                BlockTouchBufferFtraceEventWire.SIZE_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._size = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const BlockTouchBufferFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getSector(self: *const BlockTouchBufferFtraceEventReader) u64 {
        return self._sector;
    }
    pub inline fn getSize(self: *const BlockTouchBufferFtraceEventReader) u64 {
        return self._size;
    }
};
const BlockUnplugFtraceEventWire = struct {
    const NR_RQ_WIRE: gremlin.ProtoWireNumber = 1;
    const COMM_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const BlockUnplugFtraceEvent = struct {
    // fields
    nr_rq: i32 = 0,
    comm: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const BlockUnplugFtraceEvent) usize {
        var res: usize = 0;
        if (self.nr_rq != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockUnplugFtraceEventWire.NR_RQ_WIRE) + gremlin.sizes.sizeI32(self.nr_rq);
        }
        if (self.comm) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(BlockUnplugFtraceEventWire.COMM_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const BlockUnplugFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const BlockUnplugFtraceEvent, target: *gremlin.Writer) void {
        if (self.nr_rq != 0) {
            target.appendInt32(BlockUnplugFtraceEventWire.NR_RQ_WIRE, self.nr_rq);
        }
        if (self.comm) |v| {
            if (v.len > 0) {
                target.appendBytes(BlockUnplugFtraceEventWire.COMM_WIRE, v);
            }
        }
    }
};
pub const BlockUnplugFtraceEventReader = struct {
    buf: gremlin.Reader,
    _nr_rq: i32 = 0,
    _comm: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!BlockUnplugFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = BlockUnplugFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                BlockUnplugFtraceEventWire.NR_RQ_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._nr_rq = result.value;
                },
                BlockUnplugFtraceEventWire.COMM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._comm = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getNrRq(self: *const BlockUnplugFtraceEventReader) i32 {
        return self._nr_rq;
    }
    pub inline fn getComm(self: *const BlockUnplugFtraceEventReader) []const u8 {
        return self._comm orelse &[_]u8{};
    }
};
const BlockIoStartFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const SECTOR_WIRE: gremlin.ProtoWireNumber = 2;
    const NR_SECTOR_WIRE: gremlin.ProtoWireNumber = 3;
    const BYTES_WIRE: gremlin.ProtoWireNumber = 4;
    const IOPRIO_WIRE: gremlin.ProtoWireNumber = 5;
    const RWBS_WIRE: gremlin.ProtoWireNumber = 6;
    const COMM_WIRE: gremlin.ProtoWireNumber = 7;
    const CMD_WIRE: gremlin.ProtoWireNumber = 8;
};
pub const BlockIoStartFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    sector: u64 = 0,
    nr_sector: u32 = 0,
    bytes: u32 = 0,
    ioprio: u32 = 0,
    rwbs: ?[]const u8 = null,
    comm: ?[]const u8 = null,
    cmd: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const BlockIoStartFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockIoStartFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.sector != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockIoStartFtraceEventWire.SECTOR_WIRE) + gremlin.sizes.sizeU64(self.sector);
        }
        if (self.nr_sector != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockIoStartFtraceEventWire.NR_SECTOR_WIRE) + gremlin.sizes.sizeU32(self.nr_sector);
        }
        if (self.bytes != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockIoStartFtraceEventWire.BYTES_WIRE) + gremlin.sizes.sizeU32(self.bytes);
        }
        if (self.ioprio != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockIoStartFtraceEventWire.IOPRIO_WIRE) + gremlin.sizes.sizeU32(self.ioprio);
        }
        if (self.rwbs) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(BlockIoStartFtraceEventWire.RWBS_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.comm) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(BlockIoStartFtraceEventWire.COMM_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.cmd) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(BlockIoStartFtraceEventWire.CMD_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const BlockIoStartFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const BlockIoStartFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(BlockIoStartFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.sector != 0) {
            target.appendUint64(BlockIoStartFtraceEventWire.SECTOR_WIRE, self.sector);
        }
        if (self.nr_sector != 0) {
            target.appendUint32(BlockIoStartFtraceEventWire.NR_SECTOR_WIRE, self.nr_sector);
        }
        if (self.bytes != 0) {
            target.appendUint32(BlockIoStartFtraceEventWire.BYTES_WIRE, self.bytes);
        }
        if (self.ioprio != 0) {
            target.appendUint32(BlockIoStartFtraceEventWire.IOPRIO_WIRE, self.ioprio);
        }
        if (self.rwbs) |v| {
            if (v.len > 0) {
                target.appendBytes(BlockIoStartFtraceEventWire.RWBS_WIRE, v);
            }
        }
        if (self.comm) |v| {
            if (v.len > 0) {
                target.appendBytes(BlockIoStartFtraceEventWire.COMM_WIRE, v);
            }
        }
        if (self.cmd) |v| {
            if (v.len > 0) {
                target.appendBytes(BlockIoStartFtraceEventWire.CMD_WIRE, v);
            }
        }
    }
};
pub const BlockIoStartFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _sector: u64 = 0,
    _nr_sector: u32 = 0,
    _bytes: u32 = 0,
    _ioprio: u32 = 0,
    _rwbs: ?[]const u8 = null,
    _comm: ?[]const u8 = null,
    _cmd: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!BlockIoStartFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = BlockIoStartFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                BlockIoStartFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                BlockIoStartFtraceEventWire.SECTOR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._sector = result.value;
                },
                BlockIoStartFtraceEventWire.NR_SECTOR_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._nr_sector = result.value;
                },
                BlockIoStartFtraceEventWire.BYTES_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._bytes = result.value;
                },
                BlockIoStartFtraceEventWire.IOPRIO_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._ioprio = result.value;
                },
                BlockIoStartFtraceEventWire.RWBS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._rwbs = result.value;
                },
                BlockIoStartFtraceEventWire.COMM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._comm = result.value;
                },
                BlockIoStartFtraceEventWire.CMD_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cmd = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const BlockIoStartFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getSector(self: *const BlockIoStartFtraceEventReader) u64 {
        return self._sector;
    }
    pub inline fn getNrSector(self: *const BlockIoStartFtraceEventReader) u32 {
        return self._nr_sector;
    }
    pub inline fn getBytes(self: *const BlockIoStartFtraceEventReader) u32 {
        return self._bytes;
    }
    pub inline fn getIoprio(self: *const BlockIoStartFtraceEventReader) u32 {
        return self._ioprio;
    }
    pub inline fn getRwbs(self: *const BlockIoStartFtraceEventReader) []const u8 {
        return self._rwbs orelse &[_]u8{};
    }
    pub inline fn getComm(self: *const BlockIoStartFtraceEventReader) []const u8 {
        return self._comm orelse &[_]u8{};
    }
    pub inline fn getCmd(self: *const BlockIoStartFtraceEventReader) []const u8 {
        return self._cmd orelse &[_]u8{};
    }
};
const BlockIoDoneFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const SECTOR_WIRE: gremlin.ProtoWireNumber = 2;
    const NR_SECTOR_WIRE: gremlin.ProtoWireNumber = 3;
    const BYTES_WIRE: gremlin.ProtoWireNumber = 4;
    const IOPRIO_WIRE: gremlin.ProtoWireNumber = 5;
    const RWBS_WIRE: gremlin.ProtoWireNumber = 6;
    const COMM_WIRE: gremlin.ProtoWireNumber = 7;
    const CMD_WIRE: gremlin.ProtoWireNumber = 8;
};
pub const BlockIoDoneFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    sector: u64 = 0,
    nr_sector: u32 = 0,
    bytes: u32 = 0,
    ioprio: u32 = 0,
    rwbs: ?[]const u8 = null,
    comm: ?[]const u8 = null,
    cmd: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const BlockIoDoneFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockIoDoneFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.sector != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockIoDoneFtraceEventWire.SECTOR_WIRE) + gremlin.sizes.sizeU64(self.sector);
        }
        if (self.nr_sector != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockIoDoneFtraceEventWire.NR_SECTOR_WIRE) + gremlin.sizes.sizeU32(self.nr_sector);
        }
        if (self.bytes != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockIoDoneFtraceEventWire.BYTES_WIRE) + gremlin.sizes.sizeU32(self.bytes);
        }
        if (self.ioprio != 0) {
            res += gremlin.sizes.sizeWireNumber(BlockIoDoneFtraceEventWire.IOPRIO_WIRE) + gremlin.sizes.sizeU32(self.ioprio);
        }
        if (self.rwbs) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(BlockIoDoneFtraceEventWire.RWBS_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.comm) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(BlockIoDoneFtraceEventWire.COMM_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.cmd) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(BlockIoDoneFtraceEventWire.CMD_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const BlockIoDoneFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const BlockIoDoneFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(BlockIoDoneFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.sector != 0) {
            target.appendUint64(BlockIoDoneFtraceEventWire.SECTOR_WIRE, self.sector);
        }
        if (self.nr_sector != 0) {
            target.appendUint32(BlockIoDoneFtraceEventWire.NR_SECTOR_WIRE, self.nr_sector);
        }
        if (self.bytes != 0) {
            target.appendUint32(BlockIoDoneFtraceEventWire.BYTES_WIRE, self.bytes);
        }
        if (self.ioprio != 0) {
            target.appendUint32(BlockIoDoneFtraceEventWire.IOPRIO_WIRE, self.ioprio);
        }
        if (self.rwbs) |v| {
            if (v.len > 0) {
                target.appendBytes(BlockIoDoneFtraceEventWire.RWBS_WIRE, v);
            }
        }
        if (self.comm) |v| {
            if (v.len > 0) {
                target.appendBytes(BlockIoDoneFtraceEventWire.COMM_WIRE, v);
            }
        }
        if (self.cmd) |v| {
            if (v.len > 0) {
                target.appendBytes(BlockIoDoneFtraceEventWire.CMD_WIRE, v);
            }
        }
    }
};
pub const BlockIoDoneFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _sector: u64 = 0,
    _nr_sector: u32 = 0,
    _bytes: u32 = 0,
    _ioprio: u32 = 0,
    _rwbs: ?[]const u8 = null,
    _comm: ?[]const u8 = null,
    _cmd: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!BlockIoDoneFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = BlockIoDoneFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                BlockIoDoneFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                BlockIoDoneFtraceEventWire.SECTOR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._sector = result.value;
                },
                BlockIoDoneFtraceEventWire.NR_SECTOR_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._nr_sector = result.value;
                },
                BlockIoDoneFtraceEventWire.BYTES_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._bytes = result.value;
                },
                BlockIoDoneFtraceEventWire.IOPRIO_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._ioprio = result.value;
                },
                BlockIoDoneFtraceEventWire.RWBS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._rwbs = result.value;
                },
                BlockIoDoneFtraceEventWire.COMM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._comm = result.value;
                },
                BlockIoDoneFtraceEventWire.CMD_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cmd = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const BlockIoDoneFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getSector(self: *const BlockIoDoneFtraceEventReader) u64 {
        return self._sector;
    }
    pub inline fn getNrSector(self: *const BlockIoDoneFtraceEventReader) u32 {
        return self._nr_sector;
    }
    pub inline fn getBytes(self: *const BlockIoDoneFtraceEventReader) u32 {
        return self._bytes;
    }
    pub inline fn getIoprio(self: *const BlockIoDoneFtraceEventReader) u32 {
        return self._ioprio;
    }
    pub inline fn getRwbs(self: *const BlockIoDoneFtraceEventReader) []const u8 {
        return self._rwbs orelse &[_]u8{};
    }
    pub inline fn getComm(self: *const BlockIoDoneFtraceEventReader) []const u8 {
        return self._comm orelse &[_]u8{};
    }
    pub inline fn getCmd(self: *const BlockIoDoneFtraceEventReader) []const u8 {
        return self._cmd orelse &[_]u8{};
    }
};
