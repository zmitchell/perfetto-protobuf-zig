// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const MmVmscanDirectReclaimBeginFtraceEventWire = struct {
    const ORDER_WIRE: gremlin.ProtoWireNumber = 1;
    const MAY_WRITEPAGE_WIRE: gremlin.ProtoWireNumber = 2;
    const GFP_FLAGS_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const MmVmscanDirectReclaimBeginFtraceEvent = struct {
    // fields
    order: i32 = 0,
    may_writepage: i32 = 0,
    gfp_flags: u32 = 0,
    pub fn calcProtobufSize(self: *const MmVmscanDirectReclaimBeginFtraceEvent) usize {
        var res: usize = 0;
        if (self.order != 0) {
            res += gremlin.sizes.sizeWireNumber(MmVmscanDirectReclaimBeginFtraceEventWire.ORDER_WIRE) + gremlin.sizes.sizeI32(self.order);
        }
        if (self.may_writepage != 0) {
            res += gremlin.sizes.sizeWireNumber(MmVmscanDirectReclaimBeginFtraceEventWire.MAY_WRITEPAGE_WIRE) + gremlin.sizes.sizeI32(self.may_writepage);
        }
        if (self.gfp_flags != 0) {
            res += gremlin.sizes.sizeWireNumber(MmVmscanDirectReclaimBeginFtraceEventWire.GFP_FLAGS_WIRE) + gremlin.sizes.sizeU32(self.gfp_flags);
        }
        return res;
    }
    pub fn encode(self: *const MmVmscanDirectReclaimBeginFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const MmVmscanDirectReclaimBeginFtraceEvent, target: *gremlin.Writer) void {
        if (self.order != 0) {
            target.appendInt32(MmVmscanDirectReclaimBeginFtraceEventWire.ORDER_WIRE, self.order);
        }
        if (self.may_writepage != 0) {
            target.appendInt32(MmVmscanDirectReclaimBeginFtraceEventWire.MAY_WRITEPAGE_WIRE, self.may_writepage);
        }
        if (self.gfp_flags != 0) {
            target.appendUint32(MmVmscanDirectReclaimBeginFtraceEventWire.GFP_FLAGS_WIRE, self.gfp_flags);
        }
    }
};
pub const MmVmscanDirectReclaimBeginFtraceEventReader = struct {
    buf: gremlin.Reader,
    _order: i32 = 0,
    _may_writepage: i32 = 0,
    _gfp_flags: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!MmVmscanDirectReclaimBeginFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = MmVmscanDirectReclaimBeginFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MmVmscanDirectReclaimBeginFtraceEventWire.ORDER_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._order = result.value;
                },
                MmVmscanDirectReclaimBeginFtraceEventWire.MAY_WRITEPAGE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._may_writepage = result.value;
                },
                MmVmscanDirectReclaimBeginFtraceEventWire.GFP_FLAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._gfp_flags = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getOrder(self: *const MmVmscanDirectReclaimBeginFtraceEventReader) i32 {
        return self._order;
    }
    pub inline fn getMayWritepage(self: *const MmVmscanDirectReclaimBeginFtraceEventReader) i32 {
        return self._may_writepage;
    }
    pub inline fn getGfpFlags(self: *const MmVmscanDirectReclaimBeginFtraceEventReader) u32 {
        return self._gfp_flags;
    }
};
const MmVmscanDirectReclaimEndFtraceEventWire = struct {
    const NR_RECLAIMED_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const MmVmscanDirectReclaimEndFtraceEvent = struct {
    // fields
    nr_reclaimed: u64 = 0,
    pub fn calcProtobufSize(self: *const MmVmscanDirectReclaimEndFtraceEvent) usize {
        var res: usize = 0;
        if (self.nr_reclaimed != 0) {
            res += gremlin.sizes.sizeWireNumber(MmVmscanDirectReclaimEndFtraceEventWire.NR_RECLAIMED_WIRE) + gremlin.sizes.sizeU64(self.nr_reclaimed);
        }
        return res;
    }
    pub fn encode(self: *const MmVmscanDirectReclaimEndFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const MmVmscanDirectReclaimEndFtraceEvent, target: *gremlin.Writer) void {
        if (self.nr_reclaimed != 0) {
            target.appendUint64(MmVmscanDirectReclaimEndFtraceEventWire.NR_RECLAIMED_WIRE, self.nr_reclaimed);
        }
    }
};
pub const MmVmscanDirectReclaimEndFtraceEventReader = struct {
    buf: gremlin.Reader,
    _nr_reclaimed: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!MmVmscanDirectReclaimEndFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = MmVmscanDirectReclaimEndFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MmVmscanDirectReclaimEndFtraceEventWire.NR_RECLAIMED_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._nr_reclaimed = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getNrReclaimed(self: *const MmVmscanDirectReclaimEndFtraceEventReader) u64 {
        return self._nr_reclaimed;
    }
};
const MmVmscanKswapdWakeFtraceEventWire = struct {
    const NID_WIRE: gremlin.ProtoWireNumber = 1;
    const ORDER_WIRE: gremlin.ProtoWireNumber = 2;
    const ZID_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const MmVmscanKswapdWakeFtraceEvent = struct {
    // fields
    nid: i32 = 0,
    order: i32 = 0,
    zid: i32 = 0,
    pub fn calcProtobufSize(self: *const MmVmscanKswapdWakeFtraceEvent) usize {
        var res: usize = 0;
        if (self.nid != 0) {
            res += gremlin.sizes.sizeWireNumber(MmVmscanKswapdWakeFtraceEventWire.NID_WIRE) + gremlin.sizes.sizeI32(self.nid);
        }
        if (self.order != 0) {
            res += gremlin.sizes.sizeWireNumber(MmVmscanKswapdWakeFtraceEventWire.ORDER_WIRE) + gremlin.sizes.sizeI32(self.order);
        }
        if (self.zid != 0) {
            res += gremlin.sizes.sizeWireNumber(MmVmscanKswapdWakeFtraceEventWire.ZID_WIRE) + gremlin.sizes.sizeI32(self.zid);
        }
        return res;
    }
    pub fn encode(self: *const MmVmscanKswapdWakeFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const MmVmscanKswapdWakeFtraceEvent, target: *gremlin.Writer) void {
        if (self.nid != 0) {
            target.appendInt32(MmVmscanKswapdWakeFtraceEventWire.NID_WIRE, self.nid);
        }
        if (self.order != 0) {
            target.appendInt32(MmVmscanKswapdWakeFtraceEventWire.ORDER_WIRE, self.order);
        }
        if (self.zid != 0) {
            target.appendInt32(MmVmscanKswapdWakeFtraceEventWire.ZID_WIRE, self.zid);
        }
    }
};
pub const MmVmscanKswapdWakeFtraceEventReader = struct {
    buf: gremlin.Reader,
    _nid: i32 = 0,
    _order: i32 = 0,
    _zid: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!MmVmscanKswapdWakeFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = MmVmscanKswapdWakeFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MmVmscanKswapdWakeFtraceEventWire.NID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._nid = result.value;
                },
                MmVmscanKswapdWakeFtraceEventWire.ORDER_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._order = result.value;
                },
                MmVmscanKswapdWakeFtraceEventWire.ZID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._zid = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getNid(self: *const MmVmscanKswapdWakeFtraceEventReader) i32 {
        return self._nid;
    }
    pub inline fn getOrder(self: *const MmVmscanKswapdWakeFtraceEventReader) i32 {
        return self._order;
    }
    pub inline fn getZid(self: *const MmVmscanKswapdWakeFtraceEventReader) i32 {
        return self._zid;
    }
};
const MmVmscanKswapdSleepFtraceEventWire = struct {
    const NID_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const MmVmscanKswapdSleepFtraceEvent = struct {
    // fields
    nid: i32 = 0,
    pub fn calcProtobufSize(self: *const MmVmscanKswapdSleepFtraceEvent) usize {
        var res: usize = 0;
        if (self.nid != 0) {
            res += gremlin.sizes.sizeWireNumber(MmVmscanKswapdSleepFtraceEventWire.NID_WIRE) + gremlin.sizes.sizeI32(self.nid);
        }
        return res;
    }
    pub fn encode(self: *const MmVmscanKswapdSleepFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const MmVmscanKswapdSleepFtraceEvent, target: *gremlin.Writer) void {
        if (self.nid != 0) {
            target.appendInt32(MmVmscanKswapdSleepFtraceEventWire.NID_WIRE, self.nid);
        }
    }
};
pub const MmVmscanKswapdSleepFtraceEventReader = struct {
    buf: gremlin.Reader,
    _nid: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!MmVmscanKswapdSleepFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = MmVmscanKswapdSleepFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MmVmscanKswapdSleepFtraceEventWire.NID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._nid = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getNid(self: *const MmVmscanKswapdSleepFtraceEventReader) i32 {
        return self._nid;
    }
};
const MmShrinkSlabStartFtraceEventWire = struct {
    const CACHE_ITEMS_WIRE: gremlin.ProtoWireNumber = 1;
    const DELTA_WIRE: gremlin.ProtoWireNumber = 2;
    const GFP_FLAGS_WIRE: gremlin.ProtoWireNumber = 3;
    const LRU_PGS_WIRE: gremlin.ProtoWireNumber = 4;
    const NR_OBJECTS_TO_SHRINK_WIRE: gremlin.ProtoWireNumber = 5;
    const PGS_SCANNED_WIRE: gremlin.ProtoWireNumber = 6;
    const SHR_WIRE: gremlin.ProtoWireNumber = 7;
    const SHRINK_WIRE: gremlin.ProtoWireNumber = 8;
    const TOTAL_SCAN_WIRE: gremlin.ProtoWireNumber = 9;
    const NID_WIRE: gremlin.ProtoWireNumber = 10;
    const PRIORITY_WIRE: gremlin.ProtoWireNumber = 11;
};
pub const MmShrinkSlabStartFtraceEvent = struct {
    // fields
    cache_items: u64 = 0,
    delta: u64 = 0,
    gfp_flags: u32 = 0,
    lru_pgs: u64 = 0,
    nr_objects_to_shrink: i64 = 0,
    pgs_scanned: u64 = 0,
    shr: u64 = 0,
    shrink: u64 = 0,
    total_scan: u64 = 0,
    nid: i32 = 0,
    priority: i32 = 0,
    pub fn calcProtobufSize(self: *const MmShrinkSlabStartFtraceEvent) usize {
        var res: usize = 0;
        if (self.cache_items != 0) {
            res += gremlin.sizes.sizeWireNumber(MmShrinkSlabStartFtraceEventWire.CACHE_ITEMS_WIRE) + gremlin.sizes.sizeU64(self.cache_items);
        }
        if (self.delta != 0) {
            res += gremlin.sizes.sizeWireNumber(MmShrinkSlabStartFtraceEventWire.DELTA_WIRE) + gremlin.sizes.sizeU64(self.delta);
        }
        if (self.gfp_flags != 0) {
            res += gremlin.sizes.sizeWireNumber(MmShrinkSlabStartFtraceEventWire.GFP_FLAGS_WIRE) + gremlin.sizes.sizeU32(self.gfp_flags);
        }
        if (self.lru_pgs != 0) {
            res += gremlin.sizes.sizeWireNumber(MmShrinkSlabStartFtraceEventWire.LRU_PGS_WIRE) + gremlin.sizes.sizeU64(self.lru_pgs);
        }
        if (self.nr_objects_to_shrink != 0) {
            res += gremlin.sizes.sizeWireNumber(MmShrinkSlabStartFtraceEventWire.NR_OBJECTS_TO_SHRINK_WIRE) + gremlin.sizes.sizeI64(self.nr_objects_to_shrink);
        }
        if (self.pgs_scanned != 0) {
            res += gremlin.sizes.sizeWireNumber(MmShrinkSlabStartFtraceEventWire.PGS_SCANNED_WIRE) + gremlin.sizes.sizeU64(self.pgs_scanned);
        }
        if (self.shr != 0) {
            res += gremlin.sizes.sizeWireNumber(MmShrinkSlabStartFtraceEventWire.SHR_WIRE) + gremlin.sizes.sizeU64(self.shr);
        }
        if (self.shrink != 0) {
            res += gremlin.sizes.sizeWireNumber(MmShrinkSlabStartFtraceEventWire.SHRINK_WIRE) + gremlin.sizes.sizeU64(self.shrink);
        }
        if (self.total_scan != 0) {
            res += gremlin.sizes.sizeWireNumber(MmShrinkSlabStartFtraceEventWire.TOTAL_SCAN_WIRE) + gremlin.sizes.sizeU64(self.total_scan);
        }
        if (self.nid != 0) {
            res += gremlin.sizes.sizeWireNumber(MmShrinkSlabStartFtraceEventWire.NID_WIRE) + gremlin.sizes.sizeI32(self.nid);
        }
        if (self.priority != 0) {
            res += gremlin.sizes.sizeWireNumber(MmShrinkSlabStartFtraceEventWire.PRIORITY_WIRE) + gremlin.sizes.sizeI32(self.priority);
        }
        return res;
    }
    pub fn encode(self: *const MmShrinkSlabStartFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const MmShrinkSlabStartFtraceEvent, target: *gremlin.Writer) void {
        if (self.cache_items != 0) {
            target.appendUint64(MmShrinkSlabStartFtraceEventWire.CACHE_ITEMS_WIRE, self.cache_items);
        }
        if (self.delta != 0) {
            target.appendUint64(MmShrinkSlabStartFtraceEventWire.DELTA_WIRE, self.delta);
        }
        if (self.gfp_flags != 0) {
            target.appendUint32(MmShrinkSlabStartFtraceEventWire.GFP_FLAGS_WIRE, self.gfp_flags);
        }
        if (self.lru_pgs != 0) {
            target.appendUint64(MmShrinkSlabStartFtraceEventWire.LRU_PGS_WIRE, self.lru_pgs);
        }
        if (self.nr_objects_to_shrink != 0) {
            target.appendInt64(MmShrinkSlabStartFtraceEventWire.NR_OBJECTS_TO_SHRINK_WIRE, self.nr_objects_to_shrink);
        }
        if (self.pgs_scanned != 0) {
            target.appendUint64(MmShrinkSlabStartFtraceEventWire.PGS_SCANNED_WIRE, self.pgs_scanned);
        }
        if (self.shr != 0) {
            target.appendUint64(MmShrinkSlabStartFtraceEventWire.SHR_WIRE, self.shr);
        }
        if (self.shrink != 0) {
            target.appendUint64(MmShrinkSlabStartFtraceEventWire.SHRINK_WIRE, self.shrink);
        }
        if (self.total_scan != 0) {
            target.appendUint64(MmShrinkSlabStartFtraceEventWire.TOTAL_SCAN_WIRE, self.total_scan);
        }
        if (self.nid != 0) {
            target.appendInt32(MmShrinkSlabStartFtraceEventWire.NID_WIRE, self.nid);
        }
        if (self.priority != 0) {
            target.appendInt32(MmShrinkSlabStartFtraceEventWire.PRIORITY_WIRE, self.priority);
        }
    }
};
pub const MmShrinkSlabStartFtraceEventReader = struct {
    buf: gremlin.Reader,
    _cache_items: u64 = 0,
    _delta: u64 = 0,
    _gfp_flags: u32 = 0,
    _lru_pgs: u64 = 0,
    _nr_objects_to_shrink: i64 = 0,
    _pgs_scanned: u64 = 0,
    _shr: u64 = 0,
    _shrink: u64 = 0,
    _total_scan: u64 = 0,
    _nid: i32 = 0,
    _priority: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!MmShrinkSlabStartFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = MmShrinkSlabStartFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MmShrinkSlabStartFtraceEventWire.CACHE_ITEMS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._cache_items = result.value;
                },
                MmShrinkSlabStartFtraceEventWire.DELTA_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._delta = result.value;
                },
                MmShrinkSlabStartFtraceEventWire.GFP_FLAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._gfp_flags = result.value;
                },
                MmShrinkSlabStartFtraceEventWire.LRU_PGS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._lru_pgs = result.value;
                },
                MmShrinkSlabStartFtraceEventWire.NR_OBJECTS_TO_SHRINK_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._nr_objects_to_shrink = result.value;
                },
                MmShrinkSlabStartFtraceEventWire.PGS_SCANNED_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._pgs_scanned = result.value;
                },
                MmShrinkSlabStartFtraceEventWire.SHR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._shr = result.value;
                },
                MmShrinkSlabStartFtraceEventWire.SHRINK_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._shrink = result.value;
                },
                MmShrinkSlabStartFtraceEventWire.TOTAL_SCAN_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._total_scan = result.value;
                },
                MmShrinkSlabStartFtraceEventWire.NID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._nid = result.value;
                },
                MmShrinkSlabStartFtraceEventWire.PRIORITY_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._priority = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getCacheItems(self: *const MmShrinkSlabStartFtraceEventReader) u64 {
        return self._cache_items;
    }
    pub inline fn getDelta(self: *const MmShrinkSlabStartFtraceEventReader) u64 {
        return self._delta;
    }
    pub inline fn getGfpFlags(self: *const MmShrinkSlabStartFtraceEventReader) u32 {
        return self._gfp_flags;
    }
    pub inline fn getLruPgs(self: *const MmShrinkSlabStartFtraceEventReader) u64 {
        return self._lru_pgs;
    }
    pub inline fn getNrObjectsToShrink(self: *const MmShrinkSlabStartFtraceEventReader) i64 {
        return self._nr_objects_to_shrink;
    }
    pub inline fn getPgsScanned(self: *const MmShrinkSlabStartFtraceEventReader) u64 {
        return self._pgs_scanned;
    }
    pub inline fn getShr(self: *const MmShrinkSlabStartFtraceEventReader) u64 {
        return self._shr;
    }
    pub inline fn getShrink(self: *const MmShrinkSlabStartFtraceEventReader) u64 {
        return self._shrink;
    }
    pub inline fn getTotalScan(self: *const MmShrinkSlabStartFtraceEventReader) u64 {
        return self._total_scan;
    }
    pub inline fn getNid(self: *const MmShrinkSlabStartFtraceEventReader) i32 {
        return self._nid;
    }
    pub inline fn getPriority(self: *const MmShrinkSlabStartFtraceEventReader) i32 {
        return self._priority;
    }
};
const MmShrinkSlabEndFtraceEventWire = struct {
    const NEW_SCAN_WIRE: gremlin.ProtoWireNumber = 1;
    const RETVAL_WIRE: gremlin.ProtoWireNumber = 2;
    const SHR_WIRE: gremlin.ProtoWireNumber = 3;
    const SHRINK_WIRE: gremlin.ProtoWireNumber = 4;
    const TOTAL_SCAN_WIRE: gremlin.ProtoWireNumber = 5;
    const UNUSED_SCAN_WIRE: gremlin.ProtoWireNumber = 6;
    const NID_WIRE: gremlin.ProtoWireNumber = 7;
};
pub const MmShrinkSlabEndFtraceEvent = struct {
    // fields
    new_scan: i64 = 0,
    retval: i32 = 0,
    shr: u64 = 0,
    shrink: u64 = 0,
    total_scan: i64 = 0,
    unused_scan: i64 = 0,
    nid: i32 = 0,
    pub fn calcProtobufSize(self: *const MmShrinkSlabEndFtraceEvent) usize {
        var res: usize = 0;
        if (self.new_scan != 0) {
            res += gremlin.sizes.sizeWireNumber(MmShrinkSlabEndFtraceEventWire.NEW_SCAN_WIRE) + gremlin.sizes.sizeI64(self.new_scan);
        }
        if (self.retval != 0) {
            res += gremlin.sizes.sizeWireNumber(MmShrinkSlabEndFtraceEventWire.RETVAL_WIRE) + gremlin.sizes.sizeI32(self.retval);
        }
        if (self.shr != 0) {
            res += gremlin.sizes.sizeWireNumber(MmShrinkSlabEndFtraceEventWire.SHR_WIRE) + gremlin.sizes.sizeU64(self.shr);
        }
        if (self.shrink != 0) {
            res += gremlin.sizes.sizeWireNumber(MmShrinkSlabEndFtraceEventWire.SHRINK_WIRE) + gremlin.sizes.sizeU64(self.shrink);
        }
        if (self.total_scan != 0) {
            res += gremlin.sizes.sizeWireNumber(MmShrinkSlabEndFtraceEventWire.TOTAL_SCAN_WIRE) + gremlin.sizes.sizeI64(self.total_scan);
        }
        if (self.unused_scan != 0) {
            res += gremlin.sizes.sizeWireNumber(MmShrinkSlabEndFtraceEventWire.UNUSED_SCAN_WIRE) + gremlin.sizes.sizeI64(self.unused_scan);
        }
        if (self.nid != 0) {
            res += gremlin.sizes.sizeWireNumber(MmShrinkSlabEndFtraceEventWire.NID_WIRE) + gremlin.sizes.sizeI32(self.nid);
        }
        return res;
    }
    pub fn encode(self: *const MmShrinkSlabEndFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const MmShrinkSlabEndFtraceEvent, target: *gremlin.Writer) void {
        if (self.new_scan != 0) {
            target.appendInt64(MmShrinkSlabEndFtraceEventWire.NEW_SCAN_WIRE, self.new_scan);
        }
        if (self.retval != 0) {
            target.appendInt32(MmShrinkSlabEndFtraceEventWire.RETVAL_WIRE, self.retval);
        }
        if (self.shr != 0) {
            target.appendUint64(MmShrinkSlabEndFtraceEventWire.SHR_WIRE, self.shr);
        }
        if (self.shrink != 0) {
            target.appendUint64(MmShrinkSlabEndFtraceEventWire.SHRINK_WIRE, self.shrink);
        }
        if (self.total_scan != 0) {
            target.appendInt64(MmShrinkSlabEndFtraceEventWire.TOTAL_SCAN_WIRE, self.total_scan);
        }
        if (self.unused_scan != 0) {
            target.appendInt64(MmShrinkSlabEndFtraceEventWire.UNUSED_SCAN_WIRE, self.unused_scan);
        }
        if (self.nid != 0) {
            target.appendInt32(MmShrinkSlabEndFtraceEventWire.NID_WIRE, self.nid);
        }
    }
};
pub const MmShrinkSlabEndFtraceEventReader = struct {
    buf: gremlin.Reader,
    _new_scan: i64 = 0,
    _retval: i32 = 0,
    _shr: u64 = 0,
    _shrink: u64 = 0,
    _total_scan: i64 = 0,
    _unused_scan: i64 = 0,
    _nid: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!MmShrinkSlabEndFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = MmShrinkSlabEndFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MmShrinkSlabEndFtraceEventWire.NEW_SCAN_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._new_scan = result.value;
                },
                MmShrinkSlabEndFtraceEventWire.RETVAL_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._retval = result.value;
                },
                MmShrinkSlabEndFtraceEventWire.SHR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._shr = result.value;
                },
                MmShrinkSlabEndFtraceEventWire.SHRINK_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._shrink = result.value;
                },
                MmShrinkSlabEndFtraceEventWire.TOTAL_SCAN_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._total_scan = result.value;
                },
                MmShrinkSlabEndFtraceEventWire.UNUSED_SCAN_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._unused_scan = result.value;
                },
                MmShrinkSlabEndFtraceEventWire.NID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._nid = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getNewScan(self: *const MmShrinkSlabEndFtraceEventReader) i64 {
        return self._new_scan;
    }
    pub inline fn getRetval(self: *const MmShrinkSlabEndFtraceEventReader) i32 {
        return self._retval;
    }
    pub inline fn getShr(self: *const MmShrinkSlabEndFtraceEventReader) u64 {
        return self._shr;
    }
    pub inline fn getShrink(self: *const MmShrinkSlabEndFtraceEventReader) u64 {
        return self._shrink;
    }
    pub inline fn getTotalScan(self: *const MmShrinkSlabEndFtraceEventReader) i64 {
        return self._total_scan;
    }
    pub inline fn getUnusedScan(self: *const MmShrinkSlabEndFtraceEventReader) i64 {
        return self._unused_scan;
    }
    pub inline fn getNid(self: *const MmShrinkSlabEndFtraceEventReader) i32 {
        return self._nid;
    }
};
