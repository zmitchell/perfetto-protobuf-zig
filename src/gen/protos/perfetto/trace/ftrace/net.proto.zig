// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const NetifReceiveSkbFtraceEventWire = struct {
    const LEN_WIRE: gremlin.ProtoWireNumber = 1;
    const NAME_WIRE: gremlin.ProtoWireNumber = 2;
    const SKBADDR_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const NetifReceiveSkbFtraceEvent = struct {
    // fields
    len: u32 = 0,
    name: ?[]const u8 = null,
    skbaddr: u64 = 0,
    pub fn calcProtobufSize(self: *const NetifReceiveSkbFtraceEvent) usize {
        var res: usize = 0;
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(NetifReceiveSkbFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeU32(self.len);
        }
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(NetifReceiveSkbFtraceEventWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.skbaddr != 0) {
            res += gremlin.sizes.sizeWireNumber(NetifReceiveSkbFtraceEventWire.SKBADDR_WIRE) + gremlin.sizes.sizeU64(self.skbaddr);
        }
        return res;
    }
    pub fn encode(self: *const NetifReceiveSkbFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const NetifReceiveSkbFtraceEvent, target: *gremlin.Writer) void {
        if (self.len != 0) {
            target.appendUint32(NetifReceiveSkbFtraceEventWire.LEN_WIRE, self.len);
        }
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(NetifReceiveSkbFtraceEventWire.NAME_WIRE, v);
            }
        }
        if (self.skbaddr != 0) {
            target.appendUint64(NetifReceiveSkbFtraceEventWire.SKBADDR_WIRE, self.skbaddr);
        }
    }
};
pub const NetifReceiveSkbFtraceEventReader = struct {
    buf: gremlin.Reader,
    _len: u32 = 0,
    _name: ?[]const u8 = null,
    _skbaddr: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!NetifReceiveSkbFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = NetifReceiveSkbFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                NetifReceiveSkbFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                NetifReceiveSkbFtraceEventWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                NetifReceiveSkbFtraceEventWire.SKBADDR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._skbaddr = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getLen(self: *const NetifReceiveSkbFtraceEventReader) u32 {
        return self._len;
    }
    pub inline fn getName(self: *const NetifReceiveSkbFtraceEventReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub inline fn getSkbaddr(self: *const NetifReceiveSkbFtraceEventReader) u64 {
        return self._skbaddr;
    }
};
const NetDevXmitFtraceEventWire = struct {
    const LEN_WIRE: gremlin.ProtoWireNumber = 1;
    const NAME_WIRE: gremlin.ProtoWireNumber = 2;
    const RC_WIRE: gremlin.ProtoWireNumber = 3;
    const SKBADDR_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const NetDevXmitFtraceEvent = struct {
    // fields
    len: u32 = 0,
    name: ?[]const u8 = null,
    rc: i32 = 0,
    skbaddr: u64 = 0,
    pub fn calcProtobufSize(self: *const NetDevXmitFtraceEvent) usize {
        var res: usize = 0;
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(NetDevXmitFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeU32(self.len);
        }
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(NetDevXmitFtraceEventWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.rc != 0) {
            res += gremlin.sizes.sizeWireNumber(NetDevXmitFtraceEventWire.RC_WIRE) + gremlin.sizes.sizeI32(self.rc);
        }
        if (self.skbaddr != 0) {
            res += gremlin.sizes.sizeWireNumber(NetDevXmitFtraceEventWire.SKBADDR_WIRE) + gremlin.sizes.sizeU64(self.skbaddr);
        }
        return res;
    }
    pub fn encode(self: *const NetDevXmitFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const NetDevXmitFtraceEvent, target: *gremlin.Writer) void {
        if (self.len != 0) {
            target.appendUint32(NetDevXmitFtraceEventWire.LEN_WIRE, self.len);
        }
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(NetDevXmitFtraceEventWire.NAME_WIRE, v);
            }
        }
        if (self.rc != 0) {
            target.appendInt32(NetDevXmitFtraceEventWire.RC_WIRE, self.rc);
        }
        if (self.skbaddr != 0) {
            target.appendUint64(NetDevXmitFtraceEventWire.SKBADDR_WIRE, self.skbaddr);
        }
    }
};
pub const NetDevXmitFtraceEventReader = struct {
    buf: gremlin.Reader,
    _len: u32 = 0,
    _name: ?[]const u8 = null,
    _rc: i32 = 0,
    _skbaddr: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!NetDevXmitFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = NetDevXmitFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                NetDevXmitFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                NetDevXmitFtraceEventWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                NetDevXmitFtraceEventWire.RC_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._rc = result.value;
                },
                NetDevXmitFtraceEventWire.SKBADDR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._skbaddr = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getLen(self: *const NetDevXmitFtraceEventReader) u32 {
        return self._len;
    }
    pub inline fn getName(self: *const NetDevXmitFtraceEventReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub inline fn getRc(self: *const NetDevXmitFtraceEventReader) i32 {
        return self._rc;
    }
    pub inline fn getSkbaddr(self: *const NetDevXmitFtraceEventReader) u64 {
        return self._skbaddr;
    }
};
const NapiGroReceiveEntryFtraceEventWire = struct {
    const DATA_LEN_WIRE: gremlin.ProtoWireNumber = 1;
    const GSO_SIZE_WIRE: gremlin.ProtoWireNumber = 2;
    const GSO_TYPE_WIRE: gremlin.ProtoWireNumber = 3;
    const HASH_WIRE: gremlin.ProtoWireNumber = 4;
    const IP_SUMMED_WIRE: gremlin.ProtoWireNumber = 5;
    const L4_HASH_WIRE: gremlin.ProtoWireNumber = 6;
    const LEN_WIRE: gremlin.ProtoWireNumber = 7;
    const MAC_HEADER_WIRE: gremlin.ProtoWireNumber = 8;
    const MAC_HEADER_VALID_WIRE: gremlin.ProtoWireNumber = 9;
    const NAME_WIRE: gremlin.ProtoWireNumber = 10;
    const NAPI_ID_WIRE: gremlin.ProtoWireNumber = 11;
    const NR_FRAGS_WIRE: gremlin.ProtoWireNumber = 12;
    const PROTOCOL_WIRE: gremlin.ProtoWireNumber = 13;
    const QUEUE_MAPPING_WIRE: gremlin.ProtoWireNumber = 14;
    const SKBADDR_WIRE: gremlin.ProtoWireNumber = 15;
    const TRUESIZE_WIRE: gremlin.ProtoWireNumber = 16;
    const VLAN_PROTO_WIRE: gremlin.ProtoWireNumber = 17;
    const VLAN_TAGGED_WIRE: gremlin.ProtoWireNumber = 18;
    const VLAN_TCI_WIRE: gremlin.ProtoWireNumber = 19;
};
pub const NapiGroReceiveEntryFtraceEvent = struct {
    // fields
    data_len: u32 = 0,
    gso_size: u32 = 0,
    gso_type: u32 = 0,
    hash: u32 = 0,
    ip_summed: u32 = 0,
    l4_hash: u32 = 0,
    len: u32 = 0,
    mac_header: i32 = 0,
    mac_header_valid: u32 = 0,
    name: ?[]const u8 = null,
    napi_id: u32 = 0,
    nr_frags: u32 = 0,
    protocol: u32 = 0,
    queue_mapping: u32 = 0,
    skbaddr: u64 = 0,
    truesize: u32 = 0,
    vlan_proto: u32 = 0,
    vlan_tagged: u32 = 0,
    vlan_tci: u32 = 0,
    pub fn calcProtobufSize(self: *const NapiGroReceiveEntryFtraceEvent) usize {
        var res: usize = 0;
        if (self.data_len != 0) {
            res += gremlin.sizes.sizeWireNumber(NapiGroReceiveEntryFtraceEventWire.DATA_LEN_WIRE) + gremlin.sizes.sizeU32(self.data_len);
        }
        if (self.gso_size != 0) {
            res += gremlin.sizes.sizeWireNumber(NapiGroReceiveEntryFtraceEventWire.GSO_SIZE_WIRE) + gremlin.sizes.sizeU32(self.gso_size);
        }
        if (self.gso_type != 0) {
            res += gremlin.sizes.sizeWireNumber(NapiGroReceiveEntryFtraceEventWire.GSO_TYPE_WIRE) + gremlin.sizes.sizeU32(self.gso_type);
        }
        if (self.hash != 0) {
            res += gremlin.sizes.sizeWireNumber(NapiGroReceiveEntryFtraceEventWire.HASH_WIRE) + gremlin.sizes.sizeU32(self.hash);
        }
        if (self.ip_summed != 0) {
            res += gremlin.sizes.sizeWireNumber(NapiGroReceiveEntryFtraceEventWire.IP_SUMMED_WIRE) + gremlin.sizes.sizeU32(self.ip_summed);
        }
        if (self.l4_hash != 0) {
            res += gremlin.sizes.sizeWireNumber(NapiGroReceiveEntryFtraceEventWire.L4_HASH_WIRE) + gremlin.sizes.sizeU32(self.l4_hash);
        }
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(NapiGroReceiveEntryFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeU32(self.len);
        }
        if (self.mac_header != 0) {
            res += gremlin.sizes.sizeWireNumber(NapiGroReceiveEntryFtraceEventWire.MAC_HEADER_WIRE) + gremlin.sizes.sizeI32(self.mac_header);
        }
        if (self.mac_header_valid != 0) {
            res += gremlin.sizes.sizeWireNumber(NapiGroReceiveEntryFtraceEventWire.MAC_HEADER_VALID_WIRE) + gremlin.sizes.sizeU32(self.mac_header_valid);
        }
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(NapiGroReceiveEntryFtraceEventWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.napi_id != 0) {
            res += gremlin.sizes.sizeWireNumber(NapiGroReceiveEntryFtraceEventWire.NAPI_ID_WIRE) + gremlin.sizes.sizeU32(self.napi_id);
        }
        if (self.nr_frags != 0) {
            res += gremlin.sizes.sizeWireNumber(NapiGroReceiveEntryFtraceEventWire.NR_FRAGS_WIRE) + gremlin.sizes.sizeU32(self.nr_frags);
        }
        if (self.protocol != 0) {
            res += gremlin.sizes.sizeWireNumber(NapiGroReceiveEntryFtraceEventWire.PROTOCOL_WIRE) + gremlin.sizes.sizeU32(self.protocol);
        }
        if (self.queue_mapping != 0) {
            res += gremlin.sizes.sizeWireNumber(NapiGroReceiveEntryFtraceEventWire.QUEUE_MAPPING_WIRE) + gremlin.sizes.sizeU32(self.queue_mapping);
        }
        if (self.skbaddr != 0) {
            res += gremlin.sizes.sizeWireNumber(NapiGroReceiveEntryFtraceEventWire.SKBADDR_WIRE) + gremlin.sizes.sizeU64(self.skbaddr);
        }
        if (self.truesize != 0) {
            res += gremlin.sizes.sizeWireNumber(NapiGroReceiveEntryFtraceEventWire.TRUESIZE_WIRE) + gremlin.sizes.sizeU32(self.truesize);
        }
        if (self.vlan_proto != 0) {
            res += gremlin.sizes.sizeWireNumber(NapiGroReceiveEntryFtraceEventWire.VLAN_PROTO_WIRE) + gremlin.sizes.sizeU32(self.vlan_proto);
        }
        if (self.vlan_tagged != 0) {
            res += gremlin.sizes.sizeWireNumber(NapiGroReceiveEntryFtraceEventWire.VLAN_TAGGED_WIRE) + gremlin.sizes.sizeU32(self.vlan_tagged);
        }
        if (self.vlan_tci != 0) {
            res += gremlin.sizes.sizeWireNumber(NapiGroReceiveEntryFtraceEventWire.VLAN_TCI_WIRE) + gremlin.sizes.sizeU32(self.vlan_tci);
        }
        return res;
    }
    pub fn encode(self: *const NapiGroReceiveEntryFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const NapiGroReceiveEntryFtraceEvent, target: *gremlin.Writer) void {
        if (self.data_len != 0) {
            target.appendUint32(NapiGroReceiveEntryFtraceEventWire.DATA_LEN_WIRE, self.data_len);
        }
        if (self.gso_size != 0) {
            target.appendUint32(NapiGroReceiveEntryFtraceEventWire.GSO_SIZE_WIRE, self.gso_size);
        }
        if (self.gso_type != 0) {
            target.appendUint32(NapiGroReceiveEntryFtraceEventWire.GSO_TYPE_WIRE, self.gso_type);
        }
        if (self.hash != 0) {
            target.appendUint32(NapiGroReceiveEntryFtraceEventWire.HASH_WIRE, self.hash);
        }
        if (self.ip_summed != 0) {
            target.appendUint32(NapiGroReceiveEntryFtraceEventWire.IP_SUMMED_WIRE, self.ip_summed);
        }
        if (self.l4_hash != 0) {
            target.appendUint32(NapiGroReceiveEntryFtraceEventWire.L4_HASH_WIRE, self.l4_hash);
        }
        if (self.len != 0) {
            target.appendUint32(NapiGroReceiveEntryFtraceEventWire.LEN_WIRE, self.len);
        }
        if (self.mac_header != 0) {
            target.appendInt32(NapiGroReceiveEntryFtraceEventWire.MAC_HEADER_WIRE, self.mac_header);
        }
        if (self.mac_header_valid != 0) {
            target.appendUint32(NapiGroReceiveEntryFtraceEventWire.MAC_HEADER_VALID_WIRE, self.mac_header_valid);
        }
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(NapiGroReceiveEntryFtraceEventWire.NAME_WIRE, v);
            }
        }
        if (self.napi_id != 0) {
            target.appendUint32(NapiGroReceiveEntryFtraceEventWire.NAPI_ID_WIRE, self.napi_id);
        }
        if (self.nr_frags != 0) {
            target.appendUint32(NapiGroReceiveEntryFtraceEventWire.NR_FRAGS_WIRE, self.nr_frags);
        }
        if (self.protocol != 0) {
            target.appendUint32(NapiGroReceiveEntryFtraceEventWire.PROTOCOL_WIRE, self.protocol);
        }
        if (self.queue_mapping != 0) {
            target.appendUint32(NapiGroReceiveEntryFtraceEventWire.QUEUE_MAPPING_WIRE, self.queue_mapping);
        }
        if (self.skbaddr != 0) {
            target.appendUint64(NapiGroReceiveEntryFtraceEventWire.SKBADDR_WIRE, self.skbaddr);
        }
        if (self.truesize != 0) {
            target.appendUint32(NapiGroReceiveEntryFtraceEventWire.TRUESIZE_WIRE, self.truesize);
        }
        if (self.vlan_proto != 0) {
            target.appendUint32(NapiGroReceiveEntryFtraceEventWire.VLAN_PROTO_WIRE, self.vlan_proto);
        }
        if (self.vlan_tagged != 0) {
            target.appendUint32(NapiGroReceiveEntryFtraceEventWire.VLAN_TAGGED_WIRE, self.vlan_tagged);
        }
        if (self.vlan_tci != 0) {
            target.appendUint32(NapiGroReceiveEntryFtraceEventWire.VLAN_TCI_WIRE, self.vlan_tci);
        }
    }
};
pub const NapiGroReceiveEntryFtraceEventReader = struct {
    buf: gremlin.Reader,
    _data_len: u32 = 0,
    _gso_size: u32 = 0,
    _gso_type: u32 = 0,
    _hash: u32 = 0,
    _ip_summed: u32 = 0,
    _l4_hash: u32 = 0,
    _len: u32 = 0,
    _mac_header: i32 = 0,
    _mac_header_valid: u32 = 0,
    _name: ?[]const u8 = null,
    _napi_id: u32 = 0,
    _nr_frags: u32 = 0,
    _protocol: u32 = 0,
    _queue_mapping: u32 = 0,
    _skbaddr: u64 = 0,
    _truesize: u32 = 0,
    _vlan_proto: u32 = 0,
    _vlan_tagged: u32 = 0,
    _vlan_tci: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!NapiGroReceiveEntryFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = NapiGroReceiveEntryFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                NapiGroReceiveEntryFtraceEventWire.DATA_LEN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._data_len = result.value;
                },
                NapiGroReceiveEntryFtraceEventWire.GSO_SIZE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._gso_size = result.value;
                },
                NapiGroReceiveEntryFtraceEventWire.GSO_TYPE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._gso_type = result.value;
                },
                NapiGroReceiveEntryFtraceEventWire.HASH_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._hash = result.value;
                },
                NapiGroReceiveEntryFtraceEventWire.IP_SUMMED_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._ip_summed = result.value;
                },
                NapiGroReceiveEntryFtraceEventWire.L4_HASH_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._l4_hash = result.value;
                },
                NapiGroReceiveEntryFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                NapiGroReceiveEntryFtraceEventWire.MAC_HEADER_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._mac_header = result.value;
                },
                NapiGroReceiveEntryFtraceEventWire.MAC_HEADER_VALID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._mac_header_valid = result.value;
                },
                NapiGroReceiveEntryFtraceEventWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                NapiGroReceiveEntryFtraceEventWire.NAPI_ID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._napi_id = result.value;
                },
                NapiGroReceiveEntryFtraceEventWire.NR_FRAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._nr_frags = result.value;
                },
                NapiGroReceiveEntryFtraceEventWire.PROTOCOL_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._protocol = result.value;
                },
                NapiGroReceiveEntryFtraceEventWire.QUEUE_MAPPING_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._queue_mapping = result.value;
                },
                NapiGroReceiveEntryFtraceEventWire.SKBADDR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._skbaddr = result.value;
                },
                NapiGroReceiveEntryFtraceEventWire.TRUESIZE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._truesize = result.value;
                },
                NapiGroReceiveEntryFtraceEventWire.VLAN_PROTO_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._vlan_proto = result.value;
                },
                NapiGroReceiveEntryFtraceEventWire.VLAN_TAGGED_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._vlan_tagged = result.value;
                },
                NapiGroReceiveEntryFtraceEventWire.VLAN_TCI_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._vlan_tci = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDataLen(self: *const NapiGroReceiveEntryFtraceEventReader) u32 {
        return self._data_len;
    }
    pub inline fn getGsoSize(self: *const NapiGroReceiveEntryFtraceEventReader) u32 {
        return self._gso_size;
    }
    pub inline fn getGsoType(self: *const NapiGroReceiveEntryFtraceEventReader) u32 {
        return self._gso_type;
    }
    pub inline fn getHash(self: *const NapiGroReceiveEntryFtraceEventReader) u32 {
        return self._hash;
    }
    pub inline fn getIpSummed(self: *const NapiGroReceiveEntryFtraceEventReader) u32 {
        return self._ip_summed;
    }
    pub inline fn getL4Hash(self: *const NapiGroReceiveEntryFtraceEventReader) u32 {
        return self._l4_hash;
    }
    pub inline fn getLen(self: *const NapiGroReceiveEntryFtraceEventReader) u32 {
        return self._len;
    }
    pub inline fn getMacHeader(self: *const NapiGroReceiveEntryFtraceEventReader) i32 {
        return self._mac_header;
    }
    pub inline fn getMacHeaderValid(self: *const NapiGroReceiveEntryFtraceEventReader) u32 {
        return self._mac_header_valid;
    }
    pub inline fn getName(self: *const NapiGroReceiveEntryFtraceEventReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub inline fn getNapiId(self: *const NapiGroReceiveEntryFtraceEventReader) u32 {
        return self._napi_id;
    }
    pub inline fn getNrFrags(self: *const NapiGroReceiveEntryFtraceEventReader) u32 {
        return self._nr_frags;
    }
    pub inline fn getProtocol(self: *const NapiGroReceiveEntryFtraceEventReader) u32 {
        return self._protocol;
    }
    pub inline fn getQueueMapping(self: *const NapiGroReceiveEntryFtraceEventReader) u32 {
        return self._queue_mapping;
    }
    pub inline fn getSkbaddr(self: *const NapiGroReceiveEntryFtraceEventReader) u64 {
        return self._skbaddr;
    }
    pub inline fn getTruesize(self: *const NapiGroReceiveEntryFtraceEventReader) u32 {
        return self._truesize;
    }
    pub inline fn getVlanProto(self: *const NapiGroReceiveEntryFtraceEventReader) u32 {
        return self._vlan_proto;
    }
    pub inline fn getVlanTagged(self: *const NapiGroReceiveEntryFtraceEventReader) u32 {
        return self._vlan_tagged;
    }
    pub inline fn getVlanTci(self: *const NapiGroReceiveEntryFtraceEventReader) u32 {
        return self._vlan_tci;
    }
};
const NapiGroReceiveExitFtraceEventWire = struct {
    const RET_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const NapiGroReceiveExitFtraceEvent = struct {
    // fields
    ret: i32 = 0,
    pub fn calcProtobufSize(self: *const NapiGroReceiveExitFtraceEvent) usize {
        var res: usize = 0;
        if (self.ret != 0) {
            res += gremlin.sizes.sizeWireNumber(NapiGroReceiveExitFtraceEventWire.RET_WIRE) + gremlin.sizes.sizeI32(self.ret);
        }
        return res;
    }
    pub fn encode(self: *const NapiGroReceiveExitFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const NapiGroReceiveExitFtraceEvent, target: *gremlin.Writer) void {
        if (self.ret != 0) {
            target.appendInt32(NapiGroReceiveExitFtraceEventWire.RET_WIRE, self.ret);
        }
    }
};
pub const NapiGroReceiveExitFtraceEventReader = struct {
    buf: gremlin.Reader,
    _ret: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!NapiGroReceiveExitFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = NapiGroReceiveExitFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                NapiGroReceiveExitFtraceEventWire.RET_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._ret = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getRet(self: *const NapiGroReceiveExitFtraceEventReader) i32 {
        return self._ret;
    }
};
