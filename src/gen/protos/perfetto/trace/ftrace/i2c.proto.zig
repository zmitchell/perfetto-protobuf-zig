// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const I2cReadFtraceEventWire = struct {
    const ADAPTER_NR_WIRE: gremlin.ProtoWireNumber = 1;
    const MSG_NR_WIRE: gremlin.ProtoWireNumber = 2;
    const ADDR_WIRE: gremlin.ProtoWireNumber = 3;
    const FLAGS_WIRE: gremlin.ProtoWireNumber = 4;
    const LEN_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const I2cReadFtraceEvent = struct {
    // fields
    adapter_nr: i32 = 0,
    msg_nr: u32 = 0,
    addr: u32 = 0,
    flags: u32 = 0,
    len: u32 = 0,
    pub fn calcProtobufSize(self: *const I2cReadFtraceEvent) usize {
        var res: usize = 0;
        if (self.adapter_nr != 0) {
            res += gremlin.sizes.sizeWireNumber(I2cReadFtraceEventWire.ADAPTER_NR_WIRE) + gremlin.sizes.sizeI32(self.adapter_nr);
        }
        if (self.msg_nr != 0) {
            res += gremlin.sizes.sizeWireNumber(I2cReadFtraceEventWire.MSG_NR_WIRE) + gremlin.sizes.sizeU32(self.msg_nr);
        }
        if (self.addr != 0) {
            res += gremlin.sizes.sizeWireNumber(I2cReadFtraceEventWire.ADDR_WIRE) + gremlin.sizes.sizeU32(self.addr);
        }
        if (self.flags != 0) {
            res += gremlin.sizes.sizeWireNumber(I2cReadFtraceEventWire.FLAGS_WIRE) + gremlin.sizes.sizeU32(self.flags);
        }
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(I2cReadFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeU32(self.len);
        }
        return res;
    }
    pub fn encode(self: *const I2cReadFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const I2cReadFtraceEvent, target: *gremlin.Writer) void {
        if (self.adapter_nr != 0) {
            target.appendInt32(I2cReadFtraceEventWire.ADAPTER_NR_WIRE, self.adapter_nr);
        }
        if (self.msg_nr != 0) {
            target.appendUint32(I2cReadFtraceEventWire.MSG_NR_WIRE, self.msg_nr);
        }
        if (self.addr != 0) {
            target.appendUint32(I2cReadFtraceEventWire.ADDR_WIRE, self.addr);
        }
        if (self.flags != 0) {
            target.appendUint32(I2cReadFtraceEventWire.FLAGS_WIRE, self.flags);
        }
        if (self.len != 0) {
            target.appendUint32(I2cReadFtraceEventWire.LEN_WIRE, self.len);
        }
    }
};
pub const I2cReadFtraceEventReader = struct {
    buf: gremlin.Reader,
    _adapter_nr: i32 = 0,
    _msg_nr: u32 = 0,
    _addr: u32 = 0,
    _flags: u32 = 0,
    _len: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!I2cReadFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = I2cReadFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                I2cReadFtraceEventWire.ADAPTER_NR_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._adapter_nr = result.value;
                },
                I2cReadFtraceEventWire.MSG_NR_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._msg_nr = result.value;
                },
                I2cReadFtraceEventWire.ADDR_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._addr = result.value;
                },
                I2cReadFtraceEventWire.FLAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._flags = result.value;
                },
                I2cReadFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getAdapterNr(self: *const I2cReadFtraceEventReader) i32 {
        return self._adapter_nr;
    }
    pub inline fn getMsgNr(self: *const I2cReadFtraceEventReader) u32 {
        return self._msg_nr;
    }
    pub inline fn getAddr(self: *const I2cReadFtraceEventReader) u32 {
        return self._addr;
    }
    pub inline fn getFlags(self: *const I2cReadFtraceEventReader) u32 {
        return self._flags;
    }
    pub inline fn getLen(self: *const I2cReadFtraceEventReader) u32 {
        return self._len;
    }
};
const I2cWriteFtraceEventWire = struct {
    const ADAPTER_NR_WIRE: gremlin.ProtoWireNumber = 1;
    const MSG_NR_WIRE: gremlin.ProtoWireNumber = 2;
    const ADDR_WIRE: gremlin.ProtoWireNumber = 3;
    const FLAGS_WIRE: gremlin.ProtoWireNumber = 4;
    const LEN_WIRE: gremlin.ProtoWireNumber = 5;
    const BUF_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const I2cWriteFtraceEvent = struct {
    // fields
    adapter_nr: i32 = 0,
    msg_nr: u32 = 0,
    addr: u32 = 0,
    flags: u32 = 0,
    len: u32 = 0,
    buf: u32 = 0,
    pub fn calcProtobufSize(self: *const I2cWriteFtraceEvent) usize {
        var res: usize = 0;
        if (self.adapter_nr != 0) {
            res += gremlin.sizes.sizeWireNumber(I2cWriteFtraceEventWire.ADAPTER_NR_WIRE) + gremlin.sizes.sizeI32(self.adapter_nr);
        }
        if (self.msg_nr != 0) {
            res += gremlin.sizes.sizeWireNumber(I2cWriteFtraceEventWire.MSG_NR_WIRE) + gremlin.sizes.sizeU32(self.msg_nr);
        }
        if (self.addr != 0) {
            res += gremlin.sizes.sizeWireNumber(I2cWriteFtraceEventWire.ADDR_WIRE) + gremlin.sizes.sizeU32(self.addr);
        }
        if (self.flags != 0) {
            res += gremlin.sizes.sizeWireNumber(I2cWriteFtraceEventWire.FLAGS_WIRE) + gremlin.sizes.sizeU32(self.flags);
        }
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(I2cWriteFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeU32(self.len);
        }
        if (self.buf != 0) {
            res += gremlin.sizes.sizeWireNumber(I2cWriteFtraceEventWire.BUF_WIRE) + gremlin.sizes.sizeU32(self.buf);
        }
        return res;
    }
    pub fn encode(self: *const I2cWriteFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const I2cWriteFtraceEvent, target: *gremlin.Writer) void {
        if (self.adapter_nr != 0) {
            target.appendInt32(I2cWriteFtraceEventWire.ADAPTER_NR_WIRE, self.adapter_nr);
        }
        if (self.msg_nr != 0) {
            target.appendUint32(I2cWriteFtraceEventWire.MSG_NR_WIRE, self.msg_nr);
        }
        if (self.addr != 0) {
            target.appendUint32(I2cWriteFtraceEventWire.ADDR_WIRE, self.addr);
        }
        if (self.flags != 0) {
            target.appendUint32(I2cWriteFtraceEventWire.FLAGS_WIRE, self.flags);
        }
        if (self.len != 0) {
            target.appendUint32(I2cWriteFtraceEventWire.LEN_WIRE, self.len);
        }
        if (self.buf != 0) {
            target.appendUint32(I2cWriteFtraceEventWire.BUF_WIRE, self.buf);
        }
    }
};
pub const I2cWriteFtraceEventReader = struct {
    buf: gremlin.Reader,
    _adapter_nr: i32 = 0,
    _msg_nr: u32 = 0,
    _addr: u32 = 0,
    _flags: u32 = 0,
    _len: u32 = 0,
    _buf: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!I2cWriteFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = I2cWriteFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                I2cWriteFtraceEventWire.ADAPTER_NR_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._adapter_nr = result.value;
                },
                I2cWriteFtraceEventWire.MSG_NR_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._msg_nr = result.value;
                },
                I2cWriteFtraceEventWire.ADDR_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._addr = result.value;
                },
                I2cWriteFtraceEventWire.FLAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._flags = result.value;
                },
                I2cWriteFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                I2cWriteFtraceEventWire.BUF_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getAdapterNr(self: *const I2cWriteFtraceEventReader) i32 {
        return self._adapter_nr;
    }
    pub inline fn getMsgNr(self: *const I2cWriteFtraceEventReader) u32 {
        return self._msg_nr;
    }
    pub inline fn getAddr(self: *const I2cWriteFtraceEventReader) u32 {
        return self._addr;
    }
    pub inline fn getFlags(self: *const I2cWriteFtraceEventReader) u32 {
        return self._flags;
    }
    pub inline fn getLen(self: *const I2cWriteFtraceEventReader) u32 {
        return self._len;
    }
    pub inline fn getBuf(self: *const I2cWriteFtraceEventReader) u32 {
        return self._buf;
    }
};
const I2cResultFtraceEventWire = struct {
    const ADAPTER_NR_WIRE: gremlin.ProtoWireNumber = 1;
    const NR_MSGS_WIRE: gremlin.ProtoWireNumber = 2;
    const RET_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const I2cResultFtraceEvent = struct {
    // fields
    adapter_nr: i32 = 0,
    nr_msgs: u32 = 0,
    ret: i32 = 0,
    pub fn calcProtobufSize(self: *const I2cResultFtraceEvent) usize {
        var res: usize = 0;
        if (self.adapter_nr != 0) {
            res += gremlin.sizes.sizeWireNumber(I2cResultFtraceEventWire.ADAPTER_NR_WIRE) + gremlin.sizes.sizeI32(self.adapter_nr);
        }
        if (self.nr_msgs != 0) {
            res += gremlin.sizes.sizeWireNumber(I2cResultFtraceEventWire.NR_MSGS_WIRE) + gremlin.sizes.sizeU32(self.nr_msgs);
        }
        if (self.ret != 0) {
            res += gremlin.sizes.sizeWireNumber(I2cResultFtraceEventWire.RET_WIRE) + gremlin.sizes.sizeI32(self.ret);
        }
        return res;
    }
    pub fn encode(self: *const I2cResultFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const I2cResultFtraceEvent, target: *gremlin.Writer) void {
        if (self.adapter_nr != 0) {
            target.appendInt32(I2cResultFtraceEventWire.ADAPTER_NR_WIRE, self.adapter_nr);
        }
        if (self.nr_msgs != 0) {
            target.appendUint32(I2cResultFtraceEventWire.NR_MSGS_WIRE, self.nr_msgs);
        }
        if (self.ret != 0) {
            target.appendInt32(I2cResultFtraceEventWire.RET_WIRE, self.ret);
        }
    }
};
pub const I2cResultFtraceEventReader = struct {
    buf: gremlin.Reader,
    _adapter_nr: i32 = 0,
    _nr_msgs: u32 = 0,
    _ret: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!I2cResultFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = I2cResultFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                I2cResultFtraceEventWire.ADAPTER_NR_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._adapter_nr = result.value;
                },
                I2cResultFtraceEventWire.NR_MSGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._nr_msgs = result.value;
                },
                I2cResultFtraceEventWire.RET_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._ret = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getAdapterNr(self: *const I2cResultFtraceEventReader) i32 {
        return self._adapter_nr;
    }
    pub inline fn getNrMsgs(self: *const I2cResultFtraceEventReader) u32 {
        return self._nr_msgs;
    }
    pub inline fn getRet(self: *const I2cResultFtraceEventReader) i32 {
        return self._ret;
    }
};
const I2cReplyFtraceEventWire = struct {
    const ADAPTER_NR_WIRE: gremlin.ProtoWireNumber = 1;
    const MSG_NR_WIRE: gremlin.ProtoWireNumber = 2;
    const ADDR_WIRE: gremlin.ProtoWireNumber = 3;
    const FLAGS_WIRE: gremlin.ProtoWireNumber = 4;
    const LEN_WIRE: gremlin.ProtoWireNumber = 5;
    const BUF_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const I2cReplyFtraceEvent = struct {
    // fields
    adapter_nr: i32 = 0,
    msg_nr: u32 = 0,
    addr: u32 = 0,
    flags: u32 = 0,
    len: u32 = 0,
    buf: u32 = 0,
    pub fn calcProtobufSize(self: *const I2cReplyFtraceEvent) usize {
        var res: usize = 0;
        if (self.adapter_nr != 0) {
            res += gremlin.sizes.sizeWireNumber(I2cReplyFtraceEventWire.ADAPTER_NR_WIRE) + gremlin.sizes.sizeI32(self.adapter_nr);
        }
        if (self.msg_nr != 0) {
            res += gremlin.sizes.sizeWireNumber(I2cReplyFtraceEventWire.MSG_NR_WIRE) + gremlin.sizes.sizeU32(self.msg_nr);
        }
        if (self.addr != 0) {
            res += gremlin.sizes.sizeWireNumber(I2cReplyFtraceEventWire.ADDR_WIRE) + gremlin.sizes.sizeU32(self.addr);
        }
        if (self.flags != 0) {
            res += gremlin.sizes.sizeWireNumber(I2cReplyFtraceEventWire.FLAGS_WIRE) + gremlin.sizes.sizeU32(self.flags);
        }
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(I2cReplyFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeU32(self.len);
        }
        if (self.buf != 0) {
            res += gremlin.sizes.sizeWireNumber(I2cReplyFtraceEventWire.BUF_WIRE) + gremlin.sizes.sizeU32(self.buf);
        }
        return res;
    }
    pub fn encode(self: *const I2cReplyFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const I2cReplyFtraceEvent, target: *gremlin.Writer) void {
        if (self.adapter_nr != 0) {
            target.appendInt32(I2cReplyFtraceEventWire.ADAPTER_NR_WIRE, self.adapter_nr);
        }
        if (self.msg_nr != 0) {
            target.appendUint32(I2cReplyFtraceEventWire.MSG_NR_WIRE, self.msg_nr);
        }
        if (self.addr != 0) {
            target.appendUint32(I2cReplyFtraceEventWire.ADDR_WIRE, self.addr);
        }
        if (self.flags != 0) {
            target.appendUint32(I2cReplyFtraceEventWire.FLAGS_WIRE, self.flags);
        }
        if (self.len != 0) {
            target.appendUint32(I2cReplyFtraceEventWire.LEN_WIRE, self.len);
        }
        if (self.buf != 0) {
            target.appendUint32(I2cReplyFtraceEventWire.BUF_WIRE, self.buf);
        }
    }
};
pub const I2cReplyFtraceEventReader = struct {
    buf: gremlin.Reader,
    _adapter_nr: i32 = 0,
    _msg_nr: u32 = 0,
    _addr: u32 = 0,
    _flags: u32 = 0,
    _len: u32 = 0,
    _buf: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!I2cReplyFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = I2cReplyFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                I2cReplyFtraceEventWire.ADAPTER_NR_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._adapter_nr = result.value;
                },
                I2cReplyFtraceEventWire.MSG_NR_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._msg_nr = result.value;
                },
                I2cReplyFtraceEventWire.ADDR_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._addr = result.value;
                },
                I2cReplyFtraceEventWire.FLAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._flags = result.value;
                },
                I2cReplyFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                I2cReplyFtraceEventWire.BUF_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getAdapterNr(self: *const I2cReplyFtraceEventReader) i32 {
        return self._adapter_nr;
    }
    pub inline fn getMsgNr(self: *const I2cReplyFtraceEventReader) u32 {
        return self._msg_nr;
    }
    pub inline fn getAddr(self: *const I2cReplyFtraceEventReader) u32 {
        return self._addr;
    }
    pub inline fn getFlags(self: *const I2cReplyFtraceEventReader) u32 {
        return self._flags;
    }
    pub inline fn getLen(self: *const I2cReplyFtraceEventReader) u32 {
        return self._len;
    }
    pub inline fn getBuf(self: *const I2cReplyFtraceEventReader) u32 {
        return self._buf;
    }
};
const SmbusReadFtraceEventWire = struct {
    const ADAPTER_NR_WIRE: gremlin.ProtoWireNumber = 1;
    const FLAGS_WIRE: gremlin.ProtoWireNumber = 2;
    const ADDR_WIRE: gremlin.ProtoWireNumber = 3;
    const COMMAND_WIRE: gremlin.ProtoWireNumber = 4;
    const PROTOCOL_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const SmbusReadFtraceEvent = struct {
    // fields
    adapter_nr: i32 = 0,
    flags: u32 = 0,
    addr: u32 = 0,
    command: u32 = 0,
    protocol: u32 = 0,
    pub fn calcProtobufSize(self: *const SmbusReadFtraceEvent) usize {
        var res: usize = 0;
        if (self.adapter_nr != 0) {
            res += gremlin.sizes.sizeWireNumber(SmbusReadFtraceEventWire.ADAPTER_NR_WIRE) + gremlin.sizes.sizeI32(self.adapter_nr);
        }
        if (self.flags != 0) {
            res += gremlin.sizes.sizeWireNumber(SmbusReadFtraceEventWire.FLAGS_WIRE) + gremlin.sizes.sizeU32(self.flags);
        }
        if (self.addr != 0) {
            res += gremlin.sizes.sizeWireNumber(SmbusReadFtraceEventWire.ADDR_WIRE) + gremlin.sizes.sizeU32(self.addr);
        }
        if (self.command != 0) {
            res += gremlin.sizes.sizeWireNumber(SmbusReadFtraceEventWire.COMMAND_WIRE) + gremlin.sizes.sizeU32(self.command);
        }
        if (self.protocol != 0) {
            res += gremlin.sizes.sizeWireNumber(SmbusReadFtraceEventWire.PROTOCOL_WIRE) + gremlin.sizes.sizeU32(self.protocol);
        }
        return res;
    }
    pub fn encode(self: *const SmbusReadFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SmbusReadFtraceEvent, target: *gremlin.Writer) void {
        if (self.adapter_nr != 0) {
            target.appendInt32(SmbusReadFtraceEventWire.ADAPTER_NR_WIRE, self.adapter_nr);
        }
        if (self.flags != 0) {
            target.appendUint32(SmbusReadFtraceEventWire.FLAGS_WIRE, self.flags);
        }
        if (self.addr != 0) {
            target.appendUint32(SmbusReadFtraceEventWire.ADDR_WIRE, self.addr);
        }
        if (self.command != 0) {
            target.appendUint32(SmbusReadFtraceEventWire.COMMAND_WIRE, self.command);
        }
        if (self.protocol != 0) {
            target.appendUint32(SmbusReadFtraceEventWire.PROTOCOL_WIRE, self.protocol);
        }
    }
};
pub const SmbusReadFtraceEventReader = struct {
    buf: gremlin.Reader,
    _adapter_nr: i32 = 0,
    _flags: u32 = 0,
    _addr: u32 = 0,
    _command: u32 = 0,
    _protocol: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!SmbusReadFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = SmbusReadFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SmbusReadFtraceEventWire.ADAPTER_NR_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._adapter_nr = result.value;
                },
                SmbusReadFtraceEventWire.FLAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._flags = result.value;
                },
                SmbusReadFtraceEventWire.ADDR_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._addr = result.value;
                },
                SmbusReadFtraceEventWire.COMMAND_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._command = result.value;
                },
                SmbusReadFtraceEventWire.PROTOCOL_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._protocol = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getAdapterNr(self: *const SmbusReadFtraceEventReader) i32 {
        return self._adapter_nr;
    }
    pub inline fn getFlags(self: *const SmbusReadFtraceEventReader) u32 {
        return self._flags;
    }
    pub inline fn getAddr(self: *const SmbusReadFtraceEventReader) u32 {
        return self._addr;
    }
    pub inline fn getCommand(self: *const SmbusReadFtraceEventReader) u32 {
        return self._command;
    }
    pub inline fn getProtocol(self: *const SmbusReadFtraceEventReader) u32 {
        return self._protocol;
    }
};
const SmbusWriteFtraceEventWire = struct {
    const ADAPTER_NR_WIRE: gremlin.ProtoWireNumber = 1;
    const ADDR_WIRE: gremlin.ProtoWireNumber = 2;
    const FLAGS_WIRE: gremlin.ProtoWireNumber = 3;
    const COMMAND_WIRE: gremlin.ProtoWireNumber = 4;
    const LEN_WIRE: gremlin.ProtoWireNumber = 5;
    const PROTOCOL_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const SmbusWriteFtraceEvent = struct {
    // fields
    adapter_nr: i32 = 0,
    addr: u32 = 0,
    flags: u32 = 0,
    command: u32 = 0,
    len: u32 = 0,
    protocol: u32 = 0,
    pub fn calcProtobufSize(self: *const SmbusWriteFtraceEvent) usize {
        var res: usize = 0;
        if (self.adapter_nr != 0) {
            res += gremlin.sizes.sizeWireNumber(SmbusWriteFtraceEventWire.ADAPTER_NR_WIRE) + gremlin.sizes.sizeI32(self.adapter_nr);
        }
        if (self.addr != 0) {
            res += gremlin.sizes.sizeWireNumber(SmbusWriteFtraceEventWire.ADDR_WIRE) + gremlin.sizes.sizeU32(self.addr);
        }
        if (self.flags != 0) {
            res += gremlin.sizes.sizeWireNumber(SmbusWriteFtraceEventWire.FLAGS_WIRE) + gremlin.sizes.sizeU32(self.flags);
        }
        if (self.command != 0) {
            res += gremlin.sizes.sizeWireNumber(SmbusWriteFtraceEventWire.COMMAND_WIRE) + gremlin.sizes.sizeU32(self.command);
        }
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(SmbusWriteFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeU32(self.len);
        }
        if (self.protocol != 0) {
            res += gremlin.sizes.sizeWireNumber(SmbusWriteFtraceEventWire.PROTOCOL_WIRE) + gremlin.sizes.sizeU32(self.protocol);
        }
        return res;
    }
    pub fn encode(self: *const SmbusWriteFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SmbusWriteFtraceEvent, target: *gremlin.Writer) void {
        if (self.adapter_nr != 0) {
            target.appendInt32(SmbusWriteFtraceEventWire.ADAPTER_NR_WIRE, self.adapter_nr);
        }
        if (self.addr != 0) {
            target.appendUint32(SmbusWriteFtraceEventWire.ADDR_WIRE, self.addr);
        }
        if (self.flags != 0) {
            target.appendUint32(SmbusWriteFtraceEventWire.FLAGS_WIRE, self.flags);
        }
        if (self.command != 0) {
            target.appendUint32(SmbusWriteFtraceEventWire.COMMAND_WIRE, self.command);
        }
        if (self.len != 0) {
            target.appendUint32(SmbusWriteFtraceEventWire.LEN_WIRE, self.len);
        }
        if (self.protocol != 0) {
            target.appendUint32(SmbusWriteFtraceEventWire.PROTOCOL_WIRE, self.protocol);
        }
    }
};
pub const SmbusWriteFtraceEventReader = struct {
    buf: gremlin.Reader,
    _adapter_nr: i32 = 0,
    _addr: u32 = 0,
    _flags: u32 = 0,
    _command: u32 = 0,
    _len: u32 = 0,
    _protocol: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!SmbusWriteFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = SmbusWriteFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SmbusWriteFtraceEventWire.ADAPTER_NR_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._adapter_nr = result.value;
                },
                SmbusWriteFtraceEventWire.ADDR_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._addr = result.value;
                },
                SmbusWriteFtraceEventWire.FLAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._flags = result.value;
                },
                SmbusWriteFtraceEventWire.COMMAND_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._command = result.value;
                },
                SmbusWriteFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                SmbusWriteFtraceEventWire.PROTOCOL_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._protocol = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getAdapterNr(self: *const SmbusWriteFtraceEventReader) i32 {
        return self._adapter_nr;
    }
    pub inline fn getAddr(self: *const SmbusWriteFtraceEventReader) u32 {
        return self._addr;
    }
    pub inline fn getFlags(self: *const SmbusWriteFtraceEventReader) u32 {
        return self._flags;
    }
    pub inline fn getCommand(self: *const SmbusWriteFtraceEventReader) u32 {
        return self._command;
    }
    pub inline fn getLen(self: *const SmbusWriteFtraceEventReader) u32 {
        return self._len;
    }
    pub inline fn getProtocol(self: *const SmbusWriteFtraceEventReader) u32 {
        return self._protocol;
    }
};
const SmbusResultFtraceEventWire = struct {
    const ADAPTER_NR_WIRE: gremlin.ProtoWireNumber = 1;
    const ADDR_WIRE: gremlin.ProtoWireNumber = 2;
    const FLAGS_WIRE: gremlin.ProtoWireNumber = 3;
    const READ_WRITE_WIRE: gremlin.ProtoWireNumber = 4;
    const COMMAND_WIRE: gremlin.ProtoWireNumber = 5;
    const RES_WIRE: gremlin.ProtoWireNumber = 6;
    const PROTOCOL_WIRE: gremlin.ProtoWireNumber = 7;
};
pub const SmbusResultFtraceEvent = struct {
    // fields
    adapter_nr: i32 = 0,
    addr: u32 = 0,
    flags: u32 = 0,
    read_write: u32 = 0,
    command: u32 = 0,
    res: i32 = 0,
    protocol: u32 = 0,
    pub fn calcProtobufSize(self: *const SmbusResultFtraceEvent) usize {
        var res: usize = 0;
        if (self.adapter_nr != 0) {
            res += gremlin.sizes.sizeWireNumber(SmbusResultFtraceEventWire.ADAPTER_NR_WIRE) + gremlin.sizes.sizeI32(self.adapter_nr);
        }
        if (self.addr != 0) {
            res += gremlin.sizes.sizeWireNumber(SmbusResultFtraceEventWire.ADDR_WIRE) + gremlin.sizes.sizeU32(self.addr);
        }
        if (self.flags != 0) {
            res += gremlin.sizes.sizeWireNumber(SmbusResultFtraceEventWire.FLAGS_WIRE) + gremlin.sizes.sizeU32(self.flags);
        }
        if (self.read_write != 0) {
            res += gremlin.sizes.sizeWireNumber(SmbusResultFtraceEventWire.READ_WRITE_WIRE) + gremlin.sizes.sizeU32(self.read_write);
        }
        if (self.command != 0) {
            res += gremlin.sizes.sizeWireNumber(SmbusResultFtraceEventWire.COMMAND_WIRE) + gremlin.sizes.sizeU32(self.command);
        }
        if (self.res != 0) {
            res += gremlin.sizes.sizeWireNumber(SmbusResultFtraceEventWire.RES_WIRE) + gremlin.sizes.sizeI32(self.res);
        }
        if (self.protocol != 0) {
            res += gremlin.sizes.sizeWireNumber(SmbusResultFtraceEventWire.PROTOCOL_WIRE) + gremlin.sizes.sizeU32(self.protocol);
        }
        return res;
    }
    pub fn encode(self: *const SmbusResultFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SmbusResultFtraceEvent, target: *gremlin.Writer) void {
        if (self.adapter_nr != 0) {
            target.appendInt32(SmbusResultFtraceEventWire.ADAPTER_NR_WIRE, self.adapter_nr);
        }
        if (self.addr != 0) {
            target.appendUint32(SmbusResultFtraceEventWire.ADDR_WIRE, self.addr);
        }
        if (self.flags != 0) {
            target.appendUint32(SmbusResultFtraceEventWire.FLAGS_WIRE, self.flags);
        }
        if (self.read_write != 0) {
            target.appendUint32(SmbusResultFtraceEventWire.READ_WRITE_WIRE, self.read_write);
        }
        if (self.command != 0) {
            target.appendUint32(SmbusResultFtraceEventWire.COMMAND_WIRE, self.command);
        }
        if (self.res != 0) {
            target.appendInt32(SmbusResultFtraceEventWire.RES_WIRE, self.res);
        }
        if (self.protocol != 0) {
            target.appendUint32(SmbusResultFtraceEventWire.PROTOCOL_WIRE, self.protocol);
        }
    }
};
pub const SmbusResultFtraceEventReader = struct {
    buf: gremlin.Reader,
    _adapter_nr: i32 = 0,
    _addr: u32 = 0,
    _flags: u32 = 0,
    _read_write: u32 = 0,
    _command: u32 = 0,
    _res: i32 = 0,
    _protocol: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!SmbusResultFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = SmbusResultFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SmbusResultFtraceEventWire.ADAPTER_NR_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._adapter_nr = result.value;
                },
                SmbusResultFtraceEventWire.ADDR_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._addr = result.value;
                },
                SmbusResultFtraceEventWire.FLAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._flags = result.value;
                },
                SmbusResultFtraceEventWire.READ_WRITE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._read_write = result.value;
                },
                SmbusResultFtraceEventWire.COMMAND_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._command = result.value;
                },
                SmbusResultFtraceEventWire.RES_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._res = result.value;
                },
                SmbusResultFtraceEventWire.PROTOCOL_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._protocol = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getAdapterNr(self: *const SmbusResultFtraceEventReader) i32 {
        return self._adapter_nr;
    }
    pub inline fn getAddr(self: *const SmbusResultFtraceEventReader) u32 {
        return self._addr;
    }
    pub inline fn getFlags(self: *const SmbusResultFtraceEventReader) u32 {
        return self._flags;
    }
    pub inline fn getReadWrite(self: *const SmbusResultFtraceEventReader) u32 {
        return self._read_write;
    }
    pub inline fn getCommand(self: *const SmbusResultFtraceEventReader) u32 {
        return self._command;
    }
    pub inline fn getRes(self: *const SmbusResultFtraceEventReader) i32 {
        return self._res;
    }
    pub inline fn getProtocol(self: *const SmbusResultFtraceEventReader) u32 {
        return self._protocol;
    }
};
const SmbusReplyFtraceEventWire = struct {
    const ADAPTER_NR_WIRE: gremlin.ProtoWireNumber = 1;
    const ADDR_WIRE: gremlin.ProtoWireNumber = 2;
    const FLAGS_WIRE: gremlin.ProtoWireNumber = 3;
    const COMMAND_WIRE: gremlin.ProtoWireNumber = 4;
    const LEN_WIRE: gremlin.ProtoWireNumber = 5;
    const PROTOCOL_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const SmbusReplyFtraceEvent = struct {
    // fields
    adapter_nr: i32 = 0,
    addr: u32 = 0,
    flags: u32 = 0,
    command: u32 = 0,
    len: u32 = 0,
    protocol: u32 = 0,
    pub fn calcProtobufSize(self: *const SmbusReplyFtraceEvent) usize {
        var res: usize = 0;
        if (self.adapter_nr != 0) {
            res += gremlin.sizes.sizeWireNumber(SmbusReplyFtraceEventWire.ADAPTER_NR_WIRE) + gremlin.sizes.sizeI32(self.adapter_nr);
        }
        if (self.addr != 0) {
            res += gremlin.sizes.sizeWireNumber(SmbusReplyFtraceEventWire.ADDR_WIRE) + gremlin.sizes.sizeU32(self.addr);
        }
        if (self.flags != 0) {
            res += gremlin.sizes.sizeWireNumber(SmbusReplyFtraceEventWire.FLAGS_WIRE) + gremlin.sizes.sizeU32(self.flags);
        }
        if (self.command != 0) {
            res += gremlin.sizes.sizeWireNumber(SmbusReplyFtraceEventWire.COMMAND_WIRE) + gremlin.sizes.sizeU32(self.command);
        }
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(SmbusReplyFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeU32(self.len);
        }
        if (self.protocol != 0) {
            res += gremlin.sizes.sizeWireNumber(SmbusReplyFtraceEventWire.PROTOCOL_WIRE) + gremlin.sizes.sizeU32(self.protocol);
        }
        return res;
    }
    pub fn encode(self: *const SmbusReplyFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SmbusReplyFtraceEvent, target: *gremlin.Writer) void {
        if (self.adapter_nr != 0) {
            target.appendInt32(SmbusReplyFtraceEventWire.ADAPTER_NR_WIRE, self.adapter_nr);
        }
        if (self.addr != 0) {
            target.appendUint32(SmbusReplyFtraceEventWire.ADDR_WIRE, self.addr);
        }
        if (self.flags != 0) {
            target.appendUint32(SmbusReplyFtraceEventWire.FLAGS_WIRE, self.flags);
        }
        if (self.command != 0) {
            target.appendUint32(SmbusReplyFtraceEventWire.COMMAND_WIRE, self.command);
        }
        if (self.len != 0) {
            target.appendUint32(SmbusReplyFtraceEventWire.LEN_WIRE, self.len);
        }
        if (self.protocol != 0) {
            target.appendUint32(SmbusReplyFtraceEventWire.PROTOCOL_WIRE, self.protocol);
        }
    }
};
pub const SmbusReplyFtraceEventReader = struct {
    buf: gremlin.Reader,
    _adapter_nr: i32 = 0,
    _addr: u32 = 0,
    _flags: u32 = 0,
    _command: u32 = 0,
    _len: u32 = 0,
    _protocol: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!SmbusReplyFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = SmbusReplyFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SmbusReplyFtraceEventWire.ADAPTER_NR_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._adapter_nr = result.value;
                },
                SmbusReplyFtraceEventWire.ADDR_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._addr = result.value;
                },
                SmbusReplyFtraceEventWire.FLAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._flags = result.value;
                },
                SmbusReplyFtraceEventWire.COMMAND_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._command = result.value;
                },
                SmbusReplyFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                SmbusReplyFtraceEventWire.PROTOCOL_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._protocol = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getAdapterNr(self: *const SmbusReplyFtraceEventReader) i32 {
        return self._adapter_nr;
    }
    pub inline fn getAddr(self: *const SmbusReplyFtraceEventReader) u32 {
        return self._addr;
    }
    pub inline fn getFlags(self: *const SmbusReplyFtraceEventReader) u32 {
        return self._flags;
    }
    pub inline fn getCommand(self: *const SmbusReplyFtraceEventReader) u32 {
        return self._command;
    }
    pub inline fn getLen(self: *const SmbusReplyFtraceEventReader) u32 {
        return self._len;
    }
    pub inline fn getProtocol(self: *const SmbusReplyFtraceEventReader) u32 {
        return self._protocol;
    }
};
