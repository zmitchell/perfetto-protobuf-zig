// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const MdpCmdKickoffFtraceEventWire = struct {
    const CTL_NUM_WIRE: gremlin.ProtoWireNumber = 1;
    const KICKOFF_CNT_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const MdpCmdKickoffFtraceEvent = struct {
    // fields
    ctl_num: u32 = 0,
    kickoff_cnt: i32 = 0,
    pub fn calcProtobufSize(self: *const MdpCmdKickoffFtraceEvent) usize {
        var res: usize = 0;
        if (self.ctl_num != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpCmdKickoffFtraceEventWire.CTL_NUM_WIRE) + gremlin.sizes.sizeU32(self.ctl_num);
        }
        if (self.kickoff_cnt != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpCmdKickoffFtraceEventWire.KICKOFF_CNT_WIRE) + gremlin.sizes.sizeI32(self.kickoff_cnt);
        }
        return res;
    }
    pub fn encode(self: *const MdpCmdKickoffFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const MdpCmdKickoffFtraceEvent, target: *gremlin.Writer) void {
        if (self.ctl_num != 0) {
            target.appendUint32(MdpCmdKickoffFtraceEventWire.CTL_NUM_WIRE, self.ctl_num);
        }
        if (self.kickoff_cnt != 0) {
            target.appendInt32(MdpCmdKickoffFtraceEventWire.KICKOFF_CNT_WIRE, self.kickoff_cnt);
        }
    }
};
pub const MdpCmdKickoffFtraceEventReader = struct {
    buf: gremlin.Reader,
    _ctl_num: u32 = 0,
    _kickoff_cnt: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!MdpCmdKickoffFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = MdpCmdKickoffFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MdpCmdKickoffFtraceEventWire.CTL_NUM_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._ctl_num = result.value;
                },
                MdpCmdKickoffFtraceEventWire.KICKOFF_CNT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._kickoff_cnt = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getCtlNum(self: *const MdpCmdKickoffFtraceEventReader) u32 {
        return self._ctl_num;
    }
    pub inline fn getKickoffCnt(self: *const MdpCmdKickoffFtraceEventReader) i32 {
        return self._kickoff_cnt;
    }
};
const MdpCommitFtraceEventWire = struct {
    const NUM_WIRE: gremlin.ProtoWireNumber = 1;
    const PLAY_CNT_WIRE: gremlin.ProtoWireNumber = 2;
    const CLK_RATE_WIRE: gremlin.ProtoWireNumber = 3;
    const BANDWIDTH_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const MdpCommitFtraceEvent = struct {
    // fields
    num: u32 = 0,
    play_cnt: u32 = 0,
    clk_rate: u32 = 0,
    bandwidth: u64 = 0,
    pub fn calcProtobufSize(self: *const MdpCommitFtraceEvent) usize {
        var res: usize = 0;
        if (self.num != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpCommitFtraceEventWire.NUM_WIRE) + gremlin.sizes.sizeU32(self.num);
        }
        if (self.play_cnt != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpCommitFtraceEventWire.PLAY_CNT_WIRE) + gremlin.sizes.sizeU32(self.play_cnt);
        }
        if (self.clk_rate != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpCommitFtraceEventWire.CLK_RATE_WIRE) + gremlin.sizes.sizeU32(self.clk_rate);
        }
        if (self.bandwidth != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpCommitFtraceEventWire.BANDWIDTH_WIRE) + gremlin.sizes.sizeU64(self.bandwidth);
        }
        return res;
    }
    pub fn encode(self: *const MdpCommitFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const MdpCommitFtraceEvent, target: *gremlin.Writer) void {
        if (self.num != 0) {
            target.appendUint32(MdpCommitFtraceEventWire.NUM_WIRE, self.num);
        }
        if (self.play_cnt != 0) {
            target.appendUint32(MdpCommitFtraceEventWire.PLAY_CNT_WIRE, self.play_cnt);
        }
        if (self.clk_rate != 0) {
            target.appendUint32(MdpCommitFtraceEventWire.CLK_RATE_WIRE, self.clk_rate);
        }
        if (self.bandwidth != 0) {
            target.appendUint64(MdpCommitFtraceEventWire.BANDWIDTH_WIRE, self.bandwidth);
        }
    }
};
pub const MdpCommitFtraceEventReader = struct {
    buf: gremlin.Reader,
    _num: u32 = 0,
    _play_cnt: u32 = 0,
    _clk_rate: u32 = 0,
    _bandwidth: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!MdpCommitFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = MdpCommitFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MdpCommitFtraceEventWire.NUM_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._num = result.value;
                },
                MdpCommitFtraceEventWire.PLAY_CNT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._play_cnt = result.value;
                },
                MdpCommitFtraceEventWire.CLK_RATE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._clk_rate = result.value;
                },
                MdpCommitFtraceEventWire.BANDWIDTH_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._bandwidth = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getNum(self: *const MdpCommitFtraceEventReader) u32 {
        return self._num;
    }
    pub inline fn getPlayCnt(self: *const MdpCommitFtraceEventReader) u32 {
        return self._play_cnt;
    }
    pub inline fn getClkRate(self: *const MdpCommitFtraceEventReader) u32 {
        return self._clk_rate;
    }
    pub inline fn getBandwidth(self: *const MdpCommitFtraceEventReader) u64 {
        return self._bandwidth;
    }
};
const MdpPerfSetOtFtraceEventWire = struct {
    const PNUM_WIRE: gremlin.ProtoWireNumber = 1;
    const XIN_ID_WIRE: gremlin.ProtoWireNumber = 2;
    const RD_LIM_WIRE: gremlin.ProtoWireNumber = 3;
    const IS_VBIF_RT_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const MdpPerfSetOtFtraceEvent = struct {
    // fields
    pnum: u32 = 0,
    xin_id: u32 = 0,
    rd_lim: u32 = 0,
    is_vbif_rt: u32 = 0,
    pub fn calcProtobufSize(self: *const MdpPerfSetOtFtraceEvent) usize {
        var res: usize = 0;
        if (self.pnum != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpPerfSetOtFtraceEventWire.PNUM_WIRE) + gremlin.sizes.sizeU32(self.pnum);
        }
        if (self.xin_id != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpPerfSetOtFtraceEventWire.XIN_ID_WIRE) + gremlin.sizes.sizeU32(self.xin_id);
        }
        if (self.rd_lim != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpPerfSetOtFtraceEventWire.RD_LIM_WIRE) + gremlin.sizes.sizeU32(self.rd_lim);
        }
        if (self.is_vbif_rt != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpPerfSetOtFtraceEventWire.IS_VBIF_RT_WIRE) + gremlin.sizes.sizeU32(self.is_vbif_rt);
        }
        return res;
    }
    pub fn encode(self: *const MdpPerfSetOtFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const MdpPerfSetOtFtraceEvent, target: *gremlin.Writer) void {
        if (self.pnum != 0) {
            target.appendUint32(MdpPerfSetOtFtraceEventWire.PNUM_WIRE, self.pnum);
        }
        if (self.xin_id != 0) {
            target.appendUint32(MdpPerfSetOtFtraceEventWire.XIN_ID_WIRE, self.xin_id);
        }
        if (self.rd_lim != 0) {
            target.appendUint32(MdpPerfSetOtFtraceEventWire.RD_LIM_WIRE, self.rd_lim);
        }
        if (self.is_vbif_rt != 0) {
            target.appendUint32(MdpPerfSetOtFtraceEventWire.IS_VBIF_RT_WIRE, self.is_vbif_rt);
        }
    }
};
pub const MdpPerfSetOtFtraceEventReader = struct {
    buf: gremlin.Reader,
    _pnum: u32 = 0,
    _xin_id: u32 = 0,
    _rd_lim: u32 = 0,
    _is_vbif_rt: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!MdpPerfSetOtFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = MdpPerfSetOtFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MdpPerfSetOtFtraceEventWire.PNUM_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._pnum = result.value;
                },
                MdpPerfSetOtFtraceEventWire.XIN_ID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._xin_id = result.value;
                },
                MdpPerfSetOtFtraceEventWire.RD_LIM_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._rd_lim = result.value;
                },
                MdpPerfSetOtFtraceEventWire.IS_VBIF_RT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._is_vbif_rt = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getPnum(self: *const MdpPerfSetOtFtraceEventReader) u32 {
        return self._pnum;
    }
    pub inline fn getXinId(self: *const MdpPerfSetOtFtraceEventReader) u32 {
        return self._xin_id;
    }
    pub inline fn getRdLim(self: *const MdpPerfSetOtFtraceEventReader) u32 {
        return self._rd_lim;
    }
    pub inline fn getIsVbifRt(self: *const MdpPerfSetOtFtraceEventReader) u32 {
        return self._is_vbif_rt;
    }
};
const MdpSsppChangeFtraceEventWire = struct {
    const NUM_WIRE: gremlin.ProtoWireNumber = 1;
    const PLAY_CNT_WIRE: gremlin.ProtoWireNumber = 2;
    const MIXER_WIRE: gremlin.ProtoWireNumber = 3;
    const STAGE_WIRE: gremlin.ProtoWireNumber = 4;
    const FLAGS_WIRE: gremlin.ProtoWireNumber = 5;
    const FORMAT_WIRE: gremlin.ProtoWireNumber = 6;
    const IMG_W_WIRE: gremlin.ProtoWireNumber = 7;
    const IMG_H_WIRE: gremlin.ProtoWireNumber = 8;
    const SRC_X_WIRE: gremlin.ProtoWireNumber = 9;
    const SRC_Y_WIRE: gremlin.ProtoWireNumber = 10;
    const SRC_W_WIRE: gremlin.ProtoWireNumber = 11;
    const SRC_H_WIRE: gremlin.ProtoWireNumber = 12;
    const DST_X_WIRE: gremlin.ProtoWireNumber = 13;
    const DST_Y_WIRE: gremlin.ProtoWireNumber = 14;
    const DST_W_WIRE: gremlin.ProtoWireNumber = 15;
    const DST_H_WIRE: gremlin.ProtoWireNumber = 16;
};
pub const MdpSsppChangeFtraceEvent = struct {
    // fields
    num: u32 = 0,
    play_cnt: u32 = 0,
    mixer: u32 = 0,
    stage: u32 = 0,
    flags: u32 = 0,
    format: u32 = 0,
    img_w: u32 = 0,
    img_h: u32 = 0,
    src_x: u32 = 0,
    src_y: u32 = 0,
    src_w: u32 = 0,
    src_h: u32 = 0,
    dst_x: u32 = 0,
    dst_y: u32 = 0,
    dst_w: u32 = 0,
    dst_h: u32 = 0,
    pub fn calcProtobufSize(self: *const MdpSsppChangeFtraceEvent) usize {
        var res: usize = 0;
        if (self.num != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpSsppChangeFtraceEventWire.NUM_WIRE) + gremlin.sizes.sizeU32(self.num);
        }
        if (self.play_cnt != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpSsppChangeFtraceEventWire.PLAY_CNT_WIRE) + gremlin.sizes.sizeU32(self.play_cnt);
        }
        if (self.mixer != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpSsppChangeFtraceEventWire.MIXER_WIRE) + gremlin.sizes.sizeU32(self.mixer);
        }
        if (self.stage != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpSsppChangeFtraceEventWire.STAGE_WIRE) + gremlin.sizes.sizeU32(self.stage);
        }
        if (self.flags != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpSsppChangeFtraceEventWire.FLAGS_WIRE) + gremlin.sizes.sizeU32(self.flags);
        }
        if (self.format != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpSsppChangeFtraceEventWire.FORMAT_WIRE) + gremlin.sizes.sizeU32(self.format);
        }
        if (self.img_w != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpSsppChangeFtraceEventWire.IMG_W_WIRE) + gremlin.sizes.sizeU32(self.img_w);
        }
        if (self.img_h != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpSsppChangeFtraceEventWire.IMG_H_WIRE) + gremlin.sizes.sizeU32(self.img_h);
        }
        if (self.src_x != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpSsppChangeFtraceEventWire.SRC_X_WIRE) + gremlin.sizes.sizeU32(self.src_x);
        }
        if (self.src_y != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpSsppChangeFtraceEventWire.SRC_Y_WIRE) + gremlin.sizes.sizeU32(self.src_y);
        }
        if (self.src_w != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpSsppChangeFtraceEventWire.SRC_W_WIRE) + gremlin.sizes.sizeU32(self.src_w);
        }
        if (self.src_h != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpSsppChangeFtraceEventWire.SRC_H_WIRE) + gremlin.sizes.sizeU32(self.src_h);
        }
        if (self.dst_x != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpSsppChangeFtraceEventWire.DST_X_WIRE) + gremlin.sizes.sizeU32(self.dst_x);
        }
        if (self.dst_y != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpSsppChangeFtraceEventWire.DST_Y_WIRE) + gremlin.sizes.sizeU32(self.dst_y);
        }
        if (self.dst_w != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpSsppChangeFtraceEventWire.DST_W_WIRE) + gremlin.sizes.sizeU32(self.dst_w);
        }
        if (self.dst_h != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpSsppChangeFtraceEventWire.DST_H_WIRE) + gremlin.sizes.sizeU32(self.dst_h);
        }
        return res;
    }
    pub fn encode(self: *const MdpSsppChangeFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const MdpSsppChangeFtraceEvent, target: *gremlin.Writer) void {
        if (self.num != 0) {
            target.appendUint32(MdpSsppChangeFtraceEventWire.NUM_WIRE, self.num);
        }
        if (self.play_cnt != 0) {
            target.appendUint32(MdpSsppChangeFtraceEventWire.PLAY_CNT_WIRE, self.play_cnt);
        }
        if (self.mixer != 0) {
            target.appendUint32(MdpSsppChangeFtraceEventWire.MIXER_WIRE, self.mixer);
        }
        if (self.stage != 0) {
            target.appendUint32(MdpSsppChangeFtraceEventWire.STAGE_WIRE, self.stage);
        }
        if (self.flags != 0) {
            target.appendUint32(MdpSsppChangeFtraceEventWire.FLAGS_WIRE, self.flags);
        }
        if (self.format != 0) {
            target.appendUint32(MdpSsppChangeFtraceEventWire.FORMAT_WIRE, self.format);
        }
        if (self.img_w != 0) {
            target.appendUint32(MdpSsppChangeFtraceEventWire.IMG_W_WIRE, self.img_w);
        }
        if (self.img_h != 0) {
            target.appendUint32(MdpSsppChangeFtraceEventWire.IMG_H_WIRE, self.img_h);
        }
        if (self.src_x != 0) {
            target.appendUint32(MdpSsppChangeFtraceEventWire.SRC_X_WIRE, self.src_x);
        }
        if (self.src_y != 0) {
            target.appendUint32(MdpSsppChangeFtraceEventWire.SRC_Y_WIRE, self.src_y);
        }
        if (self.src_w != 0) {
            target.appendUint32(MdpSsppChangeFtraceEventWire.SRC_W_WIRE, self.src_w);
        }
        if (self.src_h != 0) {
            target.appendUint32(MdpSsppChangeFtraceEventWire.SRC_H_WIRE, self.src_h);
        }
        if (self.dst_x != 0) {
            target.appendUint32(MdpSsppChangeFtraceEventWire.DST_X_WIRE, self.dst_x);
        }
        if (self.dst_y != 0) {
            target.appendUint32(MdpSsppChangeFtraceEventWire.DST_Y_WIRE, self.dst_y);
        }
        if (self.dst_w != 0) {
            target.appendUint32(MdpSsppChangeFtraceEventWire.DST_W_WIRE, self.dst_w);
        }
        if (self.dst_h != 0) {
            target.appendUint32(MdpSsppChangeFtraceEventWire.DST_H_WIRE, self.dst_h);
        }
    }
};
pub const MdpSsppChangeFtraceEventReader = struct {
    buf: gremlin.Reader,
    _num: u32 = 0,
    _play_cnt: u32 = 0,
    _mixer: u32 = 0,
    _stage: u32 = 0,
    _flags: u32 = 0,
    _format: u32 = 0,
    _img_w: u32 = 0,
    _img_h: u32 = 0,
    _src_x: u32 = 0,
    _src_y: u32 = 0,
    _src_w: u32 = 0,
    _src_h: u32 = 0,
    _dst_x: u32 = 0,
    _dst_y: u32 = 0,
    _dst_w: u32 = 0,
    _dst_h: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!MdpSsppChangeFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = MdpSsppChangeFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MdpSsppChangeFtraceEventWire.NUM_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._num = result.value;
                },
                MdpSsppChangeFtraceEventWire.PLAY_CNT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._play_cnt = result.value;
                },
                MdpSsppChangeFtraceEventWire.MIXER_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._mixer = result.value;
                },
                MdpSsppChangeFtraceEventWire.STAGE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._stage = result.value;
                },
                MdpSsppChangeFtraceEventWire.FLAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._flags = result.value;
                },
                MdpSsppChangeFtraceEventWire.FORMAT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._format = result.value;
                },
                MdpSsppChangeFtraceEventWire.IMG_W_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._img_w = result.value;
                },
                MdpSsppChangeFtraceEventWire.IMG_H_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._img_h = result.value;
                },
                MdpSsppChangeFtraceEventWire.SRC_X_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._src_x = result.value;
                },
                MdpSsppChangeFtraceEventWire.SRC_Y_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._src_y = result.value;
                },
                MdpSsppChangeFtraceEventWire.SRC_W_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._src_w = result.value;
                },
                MdpSsppChangeFtraceEventWire.SRC_H_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._src_h = result.value;
                },
                MdpSsppChangeFtraceEventWire.DST_X_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._dst_x = result.value;
                },
                MdpSsppChangeFtraceEventWire.DST_Y_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._dst_y = result.value;
                },
                MdpSsppChangeFtraceEventWire.DST_W_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._dst_w = result.value;
                },
                MdpSsppChangeFtraceEventWire.DST_H_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._dst_h = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getNum(self: *const MdpSsppChangeFtraceEventReader) u32 {
        return self._num;
    }
    pub inline fn getPlayCnt(self: *const MdpSsppChangeFtraceEventReader) u32 {
        return self._play_cnt;
    }
    pub inline fn getMixer(self: *const MdpSsppChangeFtraceEventReader) u32 {
        return self._mixer;
    }
    pub inline fn getStage(self: *const MdpSsppChangeFtraceEventReader) u32 {
        return self._stage;
    }
    pub inline fn getFlags(self: *const MdpSsppChangeFtraceEventReader) u32 {
        return self._flags;
    }
    pub inline fn getFormat(self: *const MdpSsppChangeFtraceEventReader) u32 {
        return self._format;
    }
    pub inline fn getImgW(self: *const MdpSsppChangeFtraceEventReader) u32 {
        return self._img_w;
    }
    pub inline fn getImgH(self: *const MdpSsppChangeFtraceEventReader) u32 {
        return self._img_h;
    }
    pub inline fn getSrcX(self: *const MdpSsppChangeFtraceEventReader) u32 {
        return self._src_x;
    }
    pub inline fn getSrcY(self: *const MdpSsppChangeFtraceEventReader) u32 {
        return self._src_y;
    }
    pub inline fn getSrcW(self: *const MdpSsppChangeFtraceEventReader) u32 {
        return self._src_w;
    }
    pub inline fn getSrcH(self: *const MdpSsppChangeFtraceEventReader) u32 {
        return self._src_h;
    }
    pub inline fn getDstX(self: *const MdpSsppChangeFtraceEventReader) u32 {
        return self._dst_x;
    }
    pub inline fn getDstY(self: *const MdpSsppChangeFtraceEventReader) u32 {
        return self._dst_y;
    }
    pub inline fn getDstW(self: *const MdpSsppChangeFtraceEventReader) u32 {
        return self._dst_w;
    }
    pub inline fn getDstH(self: *const MdpSsppChangeFtraceEventReader) u32 {
        return self._dst_h;
    }
};
const TracingMarkWriteFtraceEventWire = struct {
    const PID_WIRE: gremlin.ProtoWireNumber = 1;
    const TRACE_NAME_WIRE: gremlin.ProtoWireNumber = 2;
    const TRACE_BEGIN_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const TracingMarkWriteFtraceEvent = struct {
    // fields
    pid: i32 = 0,
    trace_name: ?[]const u8 = null,
    trace_begin: u32 = 0,
    pub fn calcProtobufSize(self: *const TracingMarkWriteFtraceEvent) usize {
        var res: usize = 0;
        if (self.pid != 0) {
            res += gremlin.sizes.sizeWireNumber(TracingMarkWriteFtraceEventWire.PID_WIRE) + gremlin.sizes.sizeI32(self.pid);
        }
        if (self.trace_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TracingMarkWriteFtraceEventWire.TRACE_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.trace_begin != 0) {
            res += gremlin.sizes.sizeWireNumber(TracingMarkWriteFtraceEventWire.TRACE_BEGIN_WIRE) + gremlin.sizes.sizeU32(self.trace_begin);
        }
        return res;
    }
    pub fn encode(self: *const TracingMarkWriteFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TracingMarkWriteFtraceEvent, target: *gremlin.Writer) void {
        if (self.pid != 0) {
            target.appendInt32(TracingMarkWriteFtraceEventWire.PID_WIRE, self.pid);
        }
        if (self.trace_name) |v| {
            if (v.len > 0) {
                target.appendBytes(TracingMarkWriteFtraceEventWire.TRACE_NAME_WIRE, v);
            }
        }
        if (self.trace_begin != 0) {
            target.appendUint32(TracingMarkWriteFtraceEventWire.TRACE_BEGIN_WIRE, self.trace_begin);
        }
    }
};
pub const TracingMarkWriteFtraceEventReader = struct {
    buf: gremlin.Reader,
    _pid: i32 = 0,
    _trace_name: ?[]const u8 = null,
    _trace_begin: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!TracingMarkWriteFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = TracingMarkWriteFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TracingMarkWriteFtraceEventWire.PID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._pid = result.value;
                },
                TracingMarkWriteFtraceEventWire.TRACE_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._trace_name = result.value;
                },
                TracingMarkWriteFtraceEventWire.TRACE_BEGIN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._trace_begin = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getPid(self: *const TracingMarkWriteFtraceEventReader) i32 {
        return self._pid;
    }
    pub inline fn getTraceName(self: *const TracingMarkWriteFtraceEventReader) []const u8 {
        return self._trace_name orelse &[_]u8{};
    }
    pub inline fn getTraceBegin(self: *const TracingMarkWriteFtraceEventReader) u32 {
        return self._trace_begin;
    }
};
const MdpCmdPingpongDoneFtraceEventWire = struct {
    const CTL_NUM_WIRE: gremlin.ProtoWireNumber = 1;
    const INTF_NUM_WIRE: gremlin.ProtoWireNumber = 2;
    const PP_NUM_WIRE: gremlin.ProtoWireNumber = 3;
    const KOFF_CNT_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const MdpCmdPingpongDoneFtraceEvent = struct {
    // fields
    ctl_num: u32 = 0,
    intf_num: u32 = 0,
    pp_num: u32 = 0,
    koff_cnt: i32 = 0,
    pub fn calcProtobufSize(self: *const MdpCmdPingpongDoneFtraceEvent) usize {
        var res: usize = 0;
        if (self.ctl_num != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpCmdPingpongDoneFtraceEventWire.CTL_NUM_WIRE) + gremlin.sizes.sizeU32(self.ctl_num);
        }
        if (self.intf_num != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpCmdPingpongDoneFtraceEventWire.INTF_NUM_WIRE) + gremlin.sizes.sizeU32(self.intf_num);
        }
        if (self.pp_num != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpCmdPingpongDoneFtraceEventWire.PP_NUM_WIRE) + gremlin.sizes.sizeU32(self.pp_num);
        }
        if (self.koff_cnt != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpCmdPingpongDoneFtraceEventWire.KOFF_CNT_WIRE) + gremlin.sizes.sizeI32(self.koff_cnt);
        }
        return res;
    }
    pub fn encode(self: *const MdpCmdPingpongDoneFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const MdpCmdPingpongDoneFtraceEvent, target: *gremlin.Writer) void {
        if (self.ctl_num != 0) {
            target.appendUint32(MdpCmdPingpongDoneFtraceEventWire.CTL_NUM_WIRE, self.ctl_num);
        }
        if (self.intf_num != 0) {
            target.appendUint32(MdpCmdPingpongDoneFtraceEventWire.INTF_NUM_WIRE, self.intf_num);
        }
        if (self.pp_num != 0) {
            target.appendUint32(MdpCmdPingpongDoneFtraceEventWire.PP_NUM_WIRE, self.pp_num);
        }
        if (self.koff_cnt != 0) {
            target.appendInt32(MdpCmdPingpongDoneFtraceEventWire.KOFF_CNT_WIRE, self.koff_cnt);
        }
    }
};
pub const MdpCmdPingpongDoneFtraceEventReader = struct {
    buf: gremlin.Reader,
    _ctl_num: u32 = 0,
    _intf_num: u32 = 0,
    _pp_num: u32 = 0,
    _koff_cnt: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!MdpCmdPingpongDoneFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = MdpCmdPingpongDoneFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MdpCmdPingpongDoneFtraceEventWire.CTL_NUM_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._ctl_num = result.value;
                },
                MdpCmdPingpongDoneFtraceEventWire.INTF_NUM_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._intf_num = result.value;
                },
                MdpCmdPingpongDoneFtraceEventWire.PP_NUM_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._pp_num = result.value;
                },
                MdpCmdPingpongDoneFtraceEventWire.KOFF_CNT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._koff_cnt = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getCtlNum(self: *const MdpCmdPingpongDoneFtraceEventReader) u32 {
        return self._ctl_num;
    }
    pub inline fn getIntfNum(self: *const MdpCmdPingpongDoneFtraceEventReader) u32 {
        return self._intf_num;
    }
    pub inline fn getPpNum(self: *const MdpCmdPingpongDoneFtraceEventReader) u32 {
        return self._pp_num;
    }
    pub inline fn getKoffCnt(self: *const MdpCmdPingpongDoneFtraceEventReader) i32 {
        return self._koff_cnt;
    }
};
const MdpCompareBwFtraceEventWire = struct {
    const NEW_AB_WIRE: gremlin.ProtoWireNumber = 1;
    const NEW_IB_WIRE: gremlin.ProtoWireNumber = 2;
    const NEW_WB_WIRE: gremlin.ProtoWireNumber = 3;
    const OLD_AB_WIRE: gremlin.ProtoWireNumber = 4;
    const OLD_IB_WIRE: gremlin.ProtoWireNumber = 5;
    const OLD_WB_WIRE: gremlin.ProtoWireNumber = 6;
    const PARAMS_CHANGED_WIRE: gremlin.ProtoWireNumber = 7;
    const UPDATE_BW_WIRE: gremlin.ProtoWireNumber = 8;
};
pub const MdpCompareBwFtraceEvent = struct {
    // fields
    new_ab: u64 = 0,
    new_ib: u64 = 0,
    new_wb: u64 = 0,
    old_ab: u64 = 0,
    old_ib: u64 = 0,
    old_wb: u64 = 0,
    params_changed: u32 = 0,
    update_bw: u32 = 0,
    pub fn calcProtobufSize(self: *const MdpCompareBwFtraceEvent) usize {
        var res: usize = 0;
        if (self.new_ab != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpCompareBwFtraceEventWire.NEW_AB_WIRE) + gremlin.sizes.sizeU64(self.new_ab);
        }
        if (self.new_ib != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpCompareBwFtraceEventWire.NEW_IB_WIRE) + gremlin.sizes.sizeU64(self.new_ib);
        }
        if (self.new_wb != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpCompareBwFtraceEventWire.NEW_WB_WIRE) + gremlin.sizes.sizeU64(self.new_wb);
        }
        if (self.old_ab != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpCompareBwFtraceEventWire.OLD_AB_WIRE) + gremlin.sizes.sizeU64(self.old_ab);
        }
        if (self.old_ib != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpCompareBwFtraceEventWire.OLD_IB_WIRE) + gremlin.sizes.sizeU64(self.old_ib);
        }
        if (self.old_wb != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpCompareBwFtraceEventWire.OLD_WB_WIRE) + gremlin.sizes.sizeU64(self.old_wb);
        }
        if (self.params_changed != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpCompareBwFtraceEventWire.PARAMS_CHANGED_WIRE) + gremlin.sizes.sizeU32(self.params_changed);
        }
        if (self.update_bw != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpCompareBwFtraceEventWire.UPDATE_BW_WIRE) + gremlin.sizes.sizeU32(self.update_bw);
        }
        return res;
    }
    pub fn encode(self: *const MdpCompareBwFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const MdpCompareBwFtraceEvent, target: *gremlin.Writer) void {
        if (self.new_ab != 0) {
            target.appendUint64(MdpCompareBwFtraceEventWire.NEW_AB_WIRE, self.new_ab);
        }
        if (self.new_ib != 0) {
            target.appendUint64(MdpCompareBwFtraceEventWire.NEW_IB_WIRE, self.new_ib);
        }
        if (self.new_wb != 0) {
            target.appendUint64(MdpCompareBwFtraceEventWire.NEW_WB_WIRE, self.new_wb);
        }
        if (self.old_ab != 0) {
            target.appendUint64(MdpCompareBwFtraceEventWire.OLD_AB_WIRE, self.old_ab);
        }
        if (self.old_ib != 0) {
            target.appendUint64(MdpCompareBwFtraceEventWire.OLD_IB_WIRE, self.old_ib);
        }
        if (self.old_wb != 0) {
            target.appendUint64(MdpCompareBwFtraceEventWire.OLD_WB_WIRE, self.old_wb);
        }
        if (self.params_changed != 0) {
            target.appendUint32(MdpCompareBwFtraceEventWire.PARAMS_CHANGED_WIRE, self.params_changed);
        }
        if (self.update_bw != 0) {
            target.appendUint32(MdpCompareBwFtraceEventWire.UPDATE_BW_WIRE, self.update_bw);
        }
    }
};
pub const MdpCompareBwFtraceEventReader = struct {
    buf: gremlin.Reader,
    _new_ab: u64 = 0,
    _new_ib: u64 = 0,
    _new_wb: u64 = 0,
    _old_ab: u64 = 0,
    _old_ib: u64 = 0,
    _old_wb: u64 = 0,
    _params_changed: u32 = 0,
    _update_bw: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!MdpCompareBwFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = MdpCompareBwFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MdpCompareBwFtraceEventWire.NEW_AB_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._new_ab = result.value;
                },
                MdpCompareBwFtraceEventWire.NEW_IB_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._new_ib = result.value;
                },
                MdpCompareBwFtraceEventWire.NEW_WB_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._new_wb = result.value;
                },
                MdpCompareBwFtraceEventWire.OLD_AB_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._old_ab = result.value;
                },
                MdpCompareBwFtraceEventWire.OLD_IB_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._old_ib = result.value;
                },
                MdpCompareBwFtraceEventWire.OLD_WB_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._old_wb = result.value;
                },
                MdpCompareBwFtraceEventWire.PARAMS_CHANGED_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._params_changed = result.value;
                },
                MdpCompareBwFtraceEventWire.UPDATE_BW_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._update_bw = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getNewAb(self: *const MdpCompareBwFtraceEventReader) u64 {
        return self._new_ab;
    }
    pub inline fn getNewIb(self: *const MdpCompareBwFtraceEventReader) u64 {
        return self._new_ib;
    }
    pub inline fn getNewWb(self: *const MdpCompareBwFtraceEventReader) u64 {
        return self._new_wb;
    }
    pub inline fn getOldAb(self: *const MdpCompareBwFtraceEventReader) u64 {
        return self._old_ab;
    }
    pub inline fn getOldIb(self: *const MdpCompareBwFtraceEventReader) u64 {
        return self._old_ib;
    }
    pub inline fn getOldWb(self: *const MdpCompareBwFtraceEventReader) u64 {
        return self._old_wb;
    }
    pub inline fn getParamsChanged(self: *const MdpCompareBwFtraceEventReader) u32 {
        return self._params_changed;
    }
    pub inline fn getUpdateBw(self: *const MdpCompareBwFtraceEventReader) u32 {
        return self._update_bw;
    }
};
const MdpPerfSetPanicLutsFtraceEventWire = struct {
    const PNUM_WIRE: gremlin.ProtoWireNumber = 1;
    const FMT_WIRE: gremlin.ProtoWireNumber = 2;
    const MODE_WIRE: gremlin.ProtoWireNumber = 3;
    const PANIC_LUT_WIRE: gremlin.ProtoWireNumber = 4;
    const ROBUST_LUT_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const MdpPerfSetPanicLutsFtraceEvent = struct {
    // fields
    pnum: u32 = 0,
    fmt: u32 = 0,
    mode: u32 = 0,
    panic_lut: u32 = 0,
    robust_lut: u32 = 0,
    pub fn calcProtobufSize(self: *const MdpPerfSetPanicLutsFtraceEvent) usize {
        var res: usize = 0;
        if (self.pnum != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpPerfSetPanicLutsFtraceEventWire.PNUM_WIRE) + gremlin.sizes.sizeU32(self.pnum);
        }
        if (self.fmt != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpPerfSetPanicLutsFtraceEventWire.FMT_WIRE) + gremlin.sizes.sizeU32(self.fmt);
        }
        if (self.mode != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpPerfSetPanicLutsFtraceEventWire.MODE_WIRE) + gremlin.sizes.sizeU32(self.mode);
        }
        if (self.panic_lut != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpPerfSetPanicLutsFtraceEventWire.PANIC_LUT_WIRE) + gremlin.sizes.sizeU32(self.panic_lut);
        }
        if (self.robust_lut != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpPerfSetPanicLutsFtraceEventWire.ROBUST_LUT_WIRE) + gremlin.sizes.sizeU32(self.robust_lut);
        }
        return res;
    }
    pub fn encode(self: *const MdpPerfSetPanicLutsFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const MdpPerfSetPanicLutsFtraceEvent, target: *gremlin.Writer) void {
        if (self.pnum != 0) {
            target.appendUint32(MdpPerfSetPanicLutsFtraceEventWire.PNUM_WIRE, self.pnum);
        }
        if (self.fmt != 0) {
            target.appendUint32(MdpPerfSetPanicLutsFtraceEventWire.FMT_WIRE, self.fmt);
        }
        if (self.mode != 0) {
            target.appendUint32(MdpPerfSetPanicLutsFtraceEventWire.MODE_WIRE, self.mode);
        }
        if (self.panic_lut != 0) {
            target.appendUint32(MdpPerfSetPanicLutsFtraceEventWire.PANIC_LUT_WIRE, self.panic_lut);
        }
        if (self.robust_lut != 0) {
            target.appendUint32(MdpPerfSetPanicLutsFtraceEventWire.ROBUST_LUT_WIRE, self.robust_lut);
        }
    }
};
pub const MdpPerfSetPanicLutsFtraceEventReader = struct {
    buf: gremlin.Reader,
    _pnum: u32 = 0,
    _fmt: u32 = 0,
    _mode: u32 = 0,
    _panic_lut: u32 = 0,
    _robust_lut: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!MdpPerfSetPanicLutsFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = MdpPerfSetPanicLutsFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MdpPerfSetPanicLutsFtraceEventWire.PNUM_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._pnum = result.value;
                },
                MdpPerfSetPanicLutsFtraceEventWire.FMT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._fmt = result.value;
                },
                MdpPerfSetPanicLutsFtraceEventWire.MODE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._mode = result.value;
                },
                MdpPerfSetPanicLutsFtraceEventWire.PANIC_LUT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._panic_lut = result.value;
                },
                MdpPerfSetPanicLutsFtraceEventWire.ROBUST_LUT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._robust_lut = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getPnum(self: *const MdpPerfSetPanicLutsFtraceEventReader) u32 {
        return self._pnum;
    }
    pub inline fn getFmt(self: *const MdpPerfSetPanicLutsFtraceEventReader) u32 {
        return self._fmt;
    }
    pub inline fn getMode(self: *const MdpPerfSetPanicLutsFtraceEventReader) u32 {
        return self._mode;
    }
    pub inline fn getPanicLut(self: *const MdpPerfSetPanicLutsFtraceEventReader) u32 {
        return self._panic_lut;
    }
    pub inline fn getRobustLut(self: *const MdpPerfSetPanicLutsFtraceEventReader) u32 {
        return self._robust_lut;
    }
};
const MdpSsppSetFtraceEventWire = struct {
    const NUM_WIRE: gremlin.ProtoWireNumber = 1;
    const PLAY_CNT_WIRE: gremlin.ProtoWireNumber = 2;
    const MIXER_WIRE: gremlin.ProtoWireNumber = 3;
    const STAGE_WIRE: gremlin.ProtoWireNumber = 4;
    const FLAGS_WIRE: gremlin.ProtoWireNumber = 5;
    const FORMAT_WIRE: gremlin.ProtoWireNumber = 6;
    const IMG_W_WIRE: gremlin.ProtoWireNumber = 7;
    const IMG_H_WIRE: gremlin.ProtoWireNumber = 8;
    const SRC_X_WIRE: gremlin.ProtoWireNumber = 9;
    const SRC_Y_WIRE: gremlin.ProtoWireNumber = 10;
    const SRC_W_WIRE: gremlin.ProtoWireNumber = 11;
    const SRC_H_WIRE: gremlin.ProtoWireNumber = 12;
    const DST_X_WIRE: gremlin.ProtoWireNumber = 13;
    const DST_Y_WIRE: gremlin.ProtoWireNumber = 14;
    const DST_W_WIRE: gremlin.ProtoWireNumber = 15;
    const DST_H_WIRE: gremlin.ProtoWireNumber = 16;
};
pub const MdpSsppSetFtraceEvent = struct {
    // fields
    num: u32 = 0,
    play_cnt: u32 = 0,
    mixer: u32 = 0,
    stage: u32 = 0,
    flags: u32 = 0,
    format: u32 = 0,
    img_w: u32 = 0,
    img_h: u32 = 0,
    src_x: u32 = 0,
    src_y: u32 = 0,
    src_w: u32 = 0,
    src_h: u32 = 0,
    dst_x: u32 = 0,
    dst_y: u32 = 0,
    dst_w: u32 = 0,
    dst_h: u32 = 0,
    pub fn calcProtobufSize(self: *const MdpSsppSetFtraceEvent) usize {
        var res: usize = 0;
        if (self.num != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpSsppSetFtraceEventWire.NUM_WIRE) + gremlin.sizes.sizeU32(self.num);
        }
        if (self.play_cnt != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpSsppSetFtraceEventWire.PLAY_CNT_WIRE) + gremlin.sizes.sizeU32(self.play_cnt);
        }
        if (self.mixer != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpSsppSetFtraceEventWire.MIXER_WIRE) + gremlin.sizes.sizeU32(self.mixer);
        }
        if (self.stage != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpSsppSetFtraceEventWire.STAGE_WIRE) + gremlin.sizes.sizeU32(self.stage);
        }
        if (self.flags != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpSsppSetFtraceEventWire.FLAGS_WIRE) + gremlin.sizes.sizeU32(self.flags);
        }
        if (self.format != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpSsppSetFtraceEventWire.FORMAT_WIRE) + gremlin.sizes.sizeU32(self.format);
        }
        if (self.img_w != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpSsppSetFtraceEventWire.IMG_W_WIRE) + gremlin.sizes.sizeU32(self.img_w);
        }
        if (self.img_h != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpSsppSetFtraceEventWire.IMG_H_WIRE) + gremlin.sizes.sizeU32(self.img_h);
        }
        if (self.src_x != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpSsppSetFtraceEventWire.SRC_X_WIRE) + gremlin.sizes.sizeU32(self.src_x);
        }
        if (self.src_y != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpSsppSetFtraceEventWire.SRC_Y_WIRE) + gremlin.sizes.sizeU32(self.src_y);
        }
        if (self.src_w != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpSsppSetFtraceEventWire.SRC_W_WIRE) + gremlin.sizes.sizeU32(self.src_w);
        }
        if (self.src_h != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpSsppSetFtraceEventWire.SRC_H_WIRE) + gremlin.sizes.sizeU32(self.src_h);
        }
        if (self.dst_x != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpSsppSetFtraceEventWire.DST_X_WIRE) + gremlin.sizes.sizeU32(self.dst_x);
        }
        if (self.dst_y != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpSsppSetFtraceEventWire.DST_Y_WIRE) + gremlin.sizes.sizeU32(self.dst_y);
        }
        if (self.dst_w != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpSsppSetFtraceEventWire.DST_W_WIRE) + gremlin.sizes.sizeU32(self.dst_w);
        }
        if (self.dst_h != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpSsppSetFtraceEventWire.DST_H_WIRE) + gremlin.sizes.sizeU32(self.dst_h);
        }
        return res;
    }
    pub fn encode(self: *const MdpSsppSetFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const MdpSsppSetFtraceEvent, target: *gremlin.Writer) void {
        if (self.num != 0) {
            target.appendUint32(MdpSsppSetFtraceEventWire.NUM_WIRE, self.num);
        }
        if (self.play_cnt != 0) {
            target.appendUint32(MdpSsppSetFtraceEventWire.PLAY_CNT_WIRE, self.play_cnt);
        }
        if (self.mixer != 0) {
            target.appendUint32(MdpSsppSetFtraceEventWire.MIXER_WIRE, self.mixer);
        }
        if (self.stage != 0) {
            target.appendUint32(MdpSsppSetFtraceEventWire.STAGE_WIRE, self.stage);
        }
        if (self.flags != 0) {
            target.appendUint32(MdpSsppSetFtraceEventWire.FLAGS_WIRE, self.flags);
        }
        if (self.format != 0) {
            target.appendUint32(MdpSsppSetFtraceEventWire.FORMAT_WIRE, self.format);
        }
        if (self.img_w != 0) {
            target.appendUint32(MdpSsppSetFtraceEventWire.IMG_W_WIRE, self.img_w);
        }
        if (self.img_h != 0) {
            target.appendUint32(MdpSsppSetFtraceEventWire.IMG_H_WIRE, self.img_h);
        }
        if (self.src_x != 0) {
            target.appendUint32(MdpSsppSetFtraceEventWire.SRC_X_WIRE, self.src_x);
        }
        if (self.src_y != 0) {
            target.appendUint32(MdpSsppSetFtraceEventWire.SRC_Y_WIRE, self.src_y);
        }
        if (self.src_w != 0) {
            target.appendUint32(MdpSsppSetFtraceEventWire.SRC_W_WIRE, self.src_w);
        }
        if (self.src_h != 0) {
            target.appendUint32(MdpSsppSetFtraceEventWire.SRC_H_WIRE, self.src_h);
        }
        if (self.dst_x != 0) {
            target.appendUint32(MdpSsppSetFtraceEventWire.DST_X_WIRE, self.dst_x);
        }
        if (self.dst_y != 0) {
            target.appendUint32(MdpSsppSetFtraceEventWire.DST_Y_WIRE, self.dst_y);
        }
        if (self.dst_w != 0) {
            target.appendUint32(MdpSsppSetFtraceEventWire.DST_W_WIRE, self.dst_w);
        }
        if (self.dst_h != 0) {
            target.appendUint32(MdpSsppSetFtraceEventWire.DST_H_WIRE, self.dst_h);
        }
    }
};
pub const MdpSsppSetFtraceEventReader = struct {
    buf: gremlin.Reader,
    _num: u32 = 0,
    _play_cnt: u32 = 0,
    _mixer: u32 = 0,
    _stage: u32 = 0,
    _flags: u32 = 0,
    _format: u32 = 0,
    _img_w: u32 = 0,
    _img_h: u32 = 0,
    _src_x: u32 = 0,
    _src_y: u32 = 0,
    _src_w: u32 = 0,
    _src_h: u32 = 0,
    _dst_x: u32 = 0,
    _dst_y: u32 = 0,
    _dst_w: u32 = 0,
    _dst_h: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!MdpSsppSetFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = MdpSsppSetFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MdpSsppSetFtraceEventWire.NUM_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._num = result.value;
                },
                MdpSsppSetFtraceEventWire.PLAY_CNT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._play_cnt = result.value;
                },
                MdpSsppSetFtraceEventWire.MIXER_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._mixer = result.value;
                },
                MdpSsppSetFtraceEventWire.STAGE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._stage = result.value;
                },
                MdpSsppSetFtraceEventWire.FLAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._flags = result.value;
                },
                MdpSsppSetFtraceEventWire.FORMAT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._format = result.value;
                },
                MdpSsppSetFtraceEventWire.IMG_W_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._img_w = result.value;
                },
                MdpSsppSetFtraceEventWire.IMG_H_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._img_h = result.value;
                },
                MdpSsppSetFtraceEventWire.SRC_X_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._src_x = result.value;
                },
                MdpSsppSetFtraceEventWire.SRC_Y_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._src_y = result.value;
                },
                MdpSsppSetFtraceEventWire.SRC_W_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._src_w = result.value;
                },
                MdpSsppSetFtraceEventWire.SRC_H_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._src_h = result.value;
                },
                MdpSsppSetFtraceEventWire.DST_X_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._dst_x = result.value;
                },
                MdpSsppSetFtraceEventWire.DST_Y_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._dst_y = result.value;
                },
                MdpSsppSetFtraceEventWire.DST_W_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._dst_w = result.value;
                },
                MdpSsppSetFtraceEventWire.DST_H_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._dst_h = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getNum(self: *const MdpSsppSetFtraceEventReader) u32 {
        return self._num;
    }
    pub inline fn getPlayCnt(self: *const MdpSsppSetFtraceEventReader) u32 {
        return self._play_cnt;
    }
    pub inline fn getMixer(self: *const MdpSsppSetFtraceEventReader) u32 {
        return self._mixer;
    }
    pub inline fn getStage(self: *const MdpSsppSetFtraceEventReader) u32 {
        return self._stage;
    }
    pub inline fn getFlags(self: *const MdpSsppSetFtraceEventReader) u32 {
        return self._flags;
    }
    pub inline fn getFormat(self: *const MdpSsppSetFtraceEventReader) u32 {
        return self._format;
    }
    pub inline fn getImgW(self: *const MdpSsppSetFtraceEventReader) u32 {
        return self._img_w;
    }
    pub inline fn getImgH(self: *const MdpSsppSetFtraceEventReader) u32 {
        return self._img_h;
    }
    pub inline fn getSrcX(self: *const MdpSsppSetFtraceEventReader) u32 {
        return self._src_x;
    }
    pub inline fn getSrcY(self: *const MdpSsppSetFtraceEventReader) u32 {
        return self._src_y;
    }
    pub inline fn getSrcW(self: *const MdpSsppSetFtraceEventReader) u32 {
        return self._src_w;
    }
    pub inline fn getSrcH(self: *const MdpSsppSetFtraceEventReader) u32 {
        return self._src_h;
    }
    pub inline fn getDstX(self: *const MdpSsppSetFtraceEventReader) u32 {
        return self._dst_x;
    }
    pub inline fn getDstY(self: *const MdpSsppSetFtraceEventReader) u32 {
        return self._dst_y;
    }
    pub inline fn getDstW(self: *const MdpSsppSetFtraceEventReader) u32 {
        return self._dst_w;
    }
    pub inline fn getDstH(self: *const MdpSsppSetFtraceEventReader) u32 {
        return self._dst_h;
    }
};
const MdpCmdReadptrDoneFtraceEventWire = struct {
    const CTL_NUM_WIRE: gremlin.ProtoWireNumber = 1;
    const KOFF_CNT_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const MdpCmdReadptrDoneFtraceEvent = struct {
    // fields
    ctl_num: u32 = 0,
    koff_cnt: i32 = 0,
    pub fn calcProtobufSize(self: *const MdpCmdReadptrDoneFtraceEvent) usize {
        var res: usize = 0;
        if (self.ctl_num != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpCmdReadptrDoneFtraceEventWire.CTL_NUM_WIRE) + gremlin.sizes.sizeU32(self.ctl_num);
        }
        if (self.koff_cnt != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpCmdReadptrDoneFtraceEventWire.KOFF_CNT_WIRE) + gremlin.sizes.sizeI32(self.koff_cnt);
        }
        return res;
    }
    pub fn encode(self: *const MdpCmdReadptrDoneFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const MdpCmdReadptrDoneFtraceEvent, target: *gremlin.Writer) void {
        if (self.ctl_num != 0) {
            target.appendUint32(MdpCmdReadptrDoneFtraceEventWire.CTL_NUM_WIRE, self.ctl_num);
        }
        if (self.koff_cnt != 0) {
            target.appendInt32(MdpCmdReadptrDoneFtraceEventWire.KOFF_CNT_WIRE, self.koff_cnt);
        }
    }
};
pub const MdpCmdReadptrDoneFtraceEventReader = struct {
    buf: gremlin.Reader,
    _ctl_num: u32 = 0,
    _koff_cnt: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!MdpCmdReadptrDoneFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = MdpCmdReadptrDoneFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MdpCmdReadptrDoneFtraceEventWire.CTL_NUM_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._ctl_num = result.value;
                },
                MdpCmdReadptrDoneFtraceEventWire.KOFF_CNT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._koff_cnt = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getCtlNum(self: *const MdpCmdReadptrDoneFtraceEventReader) u32 {
        return self._ctl_num;
    }
    pub inline fn getKoffCnt(self: *const MdpCmdReadptrDoneFtraceEventReader) i32 {
        return self._koff_cnt;
    }
};
const MdpMisrCrcFtraceEventWire = struct {
    const BLOCK_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const VSYNC_CNT_WIRE: gremlin.ProtoWireNumber = 2;
    const CRC_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const MdpMisrCrcFtraceEvent = struct {
    // fields
    block_id: u32 = 0,
    vsync_cnt: u32 = 0,
    crc: u32 = 0,
    pub fn calcProtobufSize(self: *const MdpMisrCrcFtraceEvent) usize {
        var res: usize = 0;
        if (self.block_id != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpMisrCrcFtraceEventWire.BLOCK_ID_WIRE) + gremlin.sizes.sizeU32(self.block_id);
        }
        if (self.vsync_cnt != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpMisrCrcFtraceEventWire.VSYNC_CNT_WIRE) + gremlin.sizes.sizeU32(self.vsync_cnt);
        }
        if (self.crc != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpMisrCrcFtraceEventWire.CRC_WIRE) + gremlin.sizes.sizeU32(self.crc);
        }
        return res;
    }
    pub fn encode(self: *const MdpMisrCrcFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const MdpMisrCrcFtraceEvent, target: *gremlin.Writer) void {
        if (self.block_id != 0) {
            target.appendUint32(MdpMisrCrcFtraceEventWire.BLOCK_ID_WIRE, self.block_id);
        }
        if (self.vsync_cnt != 0) {
            target.appendUint32(MdpMisrCrcFtraceEventWire.VSYNC_CNT_WIRE, self.vsync_cnt);
        }
        if (self.crc != 0) {
            target.appendUint32(MdpMisrCrcFtraceEventWire.CRC_WIRE, self.crc);
        }
    }
};
pub const MdpMisrCrcFtraceEventReader = struct {
    buf: gremlin.Reader,
    _block_id: u32 = 0,
    _vsync_cnt: u32 = 0,
    _crc: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!MdpMisrCrcFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = MdpMisrCrcFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MdpMisrCrcFtraceEventWire.BLOCK_ID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._block_id = result.value;
                },
                MdpMisrCrcFtraceEventWire.VSYNC_CNT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._vsync_cnt = result.value;
                },
                MdpMisrCrcFtraceEventWire.CRC_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._crc = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getBlockId(self: *const MdpMisrCrcFtraceEventReader) u32 {
        return self._block_id;
    }
    pub inline fn getVsyncCnt(self: *const MdpMisrCrcFtraceEventReader) u32 {
        return self._vsync_cnt;
    }
    pub inline fn getCrc(self: *const MdpMisrCrcFtraceEventReader) u32 {
        return self._crc;
    }
};
const MdpPerfSetQosLutsFtraceEventWire = struct {
    const PNUM_WIRE: gremlin.ProtoWireNumber = 1;
    const FMT_WIRE: gremlin.ProtoWireNumber = 2;
    const INTF_WIRE: gremlin.ProtoWireNumber = 3;
    const ROT_WIRE: gremlin.ProtoWireNumber = 4;
    const FL_WIRE: gremlin.ProtoWireNumber = 5;
    const LUT_WIRE: gremlin.ProtoWireNumber = 6;
    const LINEAR_WIRE: gremlin.ProtoWireNumber = 7;
};
pub const MdpPerfSetQosLutsFtraceEvent = struct {
    // fields
    pnum: u32 = 0,
    fmt: u32 = 0,
    intf: u32 = 0,
    rot: u32 = 0,
    fl: u32 = 0,
    lut: u32 = 0,
    linear: u32 = 0,
    pub fn calcProtobufSize(self: *const MdpPerfSetQosLutsFtraceEvent) usize {
        var res: usize = 0;
        if (self.pnum != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpPerfSetQosLutsFtraceEventWire.PNUM_WIRE) + gremlin.sizes.sizeU32(self.pnum);
        }
        if (self.fmt != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpPerfSetQosLutsFtraceEventWire.FMT_WIRE) + gremlin.sizes.sizeU32(self.fmt);
        }
        if (self.intf != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpPerfSetQosLutsFtraceEventWire.INTF_WIRE) + gremlin.sizes.sizeU32(self.intf);
        }
        if (self.rot != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpPerfSetQosLutsFtraceEventWire.ROT_WIRE) + gremlin.sizes.sizeU32(self.rot);
        }
        if (self.fl != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpPerfSetQosLutsFtraceEventWire.FL_WIRE) + gremlin.sizes.sizeU32(self.fl);
        }
        if (self.lut != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpPerfSetQosLutsFtraceEventWire.LUT_WIRE) + gremlin.sizes.sizeU32(self.lut);
        }
        if (self.linear != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpPerfSetQosLutsFtraceEventWire.LINEAR_WIRE) + gremlin.sizes.sizeU32(self.linear);
        }
        return res;
    }
    pub fn encode(self: *const MdpPerfSetQosLutsFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const MdpPerfSetQosLutsFtraceEvent, target: *gremlin.Writer) void {
        if (self.pnum != 0) {
            target.appendUint32(MdpPerfSetQosLutsFtraceEventWire.PNUM_WIRE, self.pnum);
        }
        if (self.fmt != 0) {
            target.appendUint32(MdpPerfSetQosLutsFtraceEventWire.FMT_WIRE, self.fmt);
        }
        if (self.intf != 0) {
            target.appendUint32(MdpPerfSetQosLutsFtraceEventWire.INTF_WIRE, self.intf);
        }
        if (self.rot != 0) {
            target.appendUint32(MdpPerfSetQosLutsFtraceEventWire.ROT_WIRE, self.rot);
        }
        if (self.fl != 0) {
            target.appendUint32(MdpPerfSetQosLutsFtraceEventWire.FL_WIRE, self.fl);
        }
        if (self.lut != 0) {
            target.appendUint32(MdpPerfSetQosLutsFtraceEventWire.LUT_WIRE, self.lut);
        }
        if (self.linear != 0) {
            target.appendUint32(MdpPerfSetQosLutsFtraceEventWire.LINEAR_WIRE, self.linear);
        }
    }
};
pub const MdpPerfSetQosLutsFtraceEventReader = struct {
    buf: gremlin.Reader,
    _pnum: u32 = 0,
    _fmt: u32 = 0,
    _intf: u32 = 0,
    _rot: u32 = 0,
    _fl: u32 = 0,
    _lut: u32 = 0,
    _linear: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!MdpPerfSetQosLutsFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = MdpPerfSetQosLutsFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MdpPerfSetQosLutsFtraceEventWire.PNUM_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._pnum = result.value;
                },
                MdpPerfSetQosLutsFtraceEventWire.FMT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._fmt = result.value;
                },
                MdpPerfSetQosLutsFtraceEventWire.INTF_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._intf = result.value;
                },
                MdpPerfSetQosLutsFtraceEventWire.ROT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._rot = result.value;
                },
                MdpPerfSetQosLutsFtraceEventWire.FL_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._fl = result.value;
                },
                MdpPerfSetQosLutsFtraceEventWire.LUT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._lut = result.value;
                },
                MdpPerfSetQosLutsFtraceEventWire.LINEAR_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._linear = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getPnum(self: *const MdpPerfSetQosLutsFtraceEventReader) u32 {
        return self._pnum;
    }
    pub inline fn getFmt(self: *const MdpPerfSetQosLutsFtraceEventReader) u32 {
        return self._fmt;
    }
    pub inline fn getIntf(self: *const MdpPerfSetQosLutsFtraceEventReader) u32 {
        return self._intf;
    }
    pub inline fn getRot(self: *const MdpPerfSetQosLutsFtraceEventReader) u32 {
        return self._rot;
    }
    pub inline fn getFl(self: *const MdpPerfSetQosLutsFtraceEventReader) u32 {
        return self._fl;
    }
    pub inline fn getLut(self: *const MdpPerfSetQosLutsFtraceEventReader) u32 {
        return self._lut;
    }
    pub inline fn getLinear(self: *const MdpPerfSetQosLutsFtraceEventReader) u32 {
        return self._linear;
    }
};
const MdpTraceCounterFtraceEventWire = struct {
    const PID_WIRE: gremlin.ProtoWireNumber = 1;
    const COUNTER_NAME_WIRE: gremlin.ProtoWireNumber = 2;
    const VALUE_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const MdpTraceCounterFtraceEvent = struct {
    // fields
    pid: i32 = 0,
    counter_name: ?[]const u8 = null,
    value: i32 = 0,
    pub fn calcProtobufSize(self: *const MdpTraceCounterFtraceEvent) usize {
        var res: usize = 0;
        if (self.pid != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpTraceCounterFtraceEventWire.PID_WIRE) + gremlin.sizes.sizeI32(self.pid);
        }
        if (self.counter_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(MdpTraceCounterFtraceEventWire.COUNTER_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.value != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpTraceCounterFtraceEventWire.VALUE_WIRE) + gremlin.sizes.sizeI32(self.value);
        }
        return res;
    }
    pub fn encode(self: *const MdpTraceCounterFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const MdpTraceCounterFtraceEvent, target: *gremlin.Writer) void {
        if (self.pid != 0) {
            target.appendInt32(MdpTraceCounterFtraceEventWire.PID_WIRE, self.pid);
        }
        if (self.counter_name) |v| {
            if (v.len > 0) {
                target.appendBytes(MdpTraceCounterFtraceEventWire.COUNTER_NAME_WIRE, v);
            }
        }
        if (self.value != 0) {
            target.appendInt32(MdpTraceCounterFtraceEventWire.VALUE_WIRE, self.value);
        }
    }
};
pub const MdpTraceCounterFtraceEventReader = struct {
    buf: gremlin.Reader,
    _pid: i32 = 0,
    _counter_name: ?[]const u8 = null,
    _value: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!MdpTraceCounterFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = MdpTraceCounterFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MdpTraceCounterFtraceEventWire.PID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._pid = result.value;
                },
                MdpTraceCounterFtraceEventWire.COUNTER_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._counter_name = result.value;
                },
                MdpTraceCounterFtraceEventWire.VALUE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._value = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getPid(self: *const MdpTraceCounterFtraceEventReader) i32 {
        return self._pid;
    }
    pub inline fn getCounterName(self: *const MdpTraceCounterFtraceEventReader) []const u8 {
        return self._counter_name orelse &[_]u8{};
    }
    pub inline fn getValue(self: *const MdpTraceCounterFtraceEventReader) i32 {
        return self._value;
    }
};
const MdpCmdReleaseBwFtraceEventWire = struct {
    const CTL_NUM_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const MdpCmdReleaseBwFtraceEvent = struct {
    // fields
    ctl_num: u32 = 0,
    pub fn calcProtobufSize(self: *const MdpCmdReleaseBwFtraceEvent) usize {
        var res: usize = 0;
        if (self.ctl_num != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpCmdReleaseBwFtraceEventWire.CTL_NUM_WIRE) + gremlin.sizes.sizeU32(self.ctl_num);
        }
        return res;
    }
    pub fn encode(self: *const MdpCmdReleaseBwFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const MdpCmdReleaseBwFtraceEvent, target: *gremlin.Writer) void {
        if (self.ctl_num != 0) {
            target.appendUint32(MdpCmdReleaseBwFtraceEventWire.CTL_NUM_WIRE, self.ctl_num);
        }
    }
};
pub const MdpCmdReleaseBwFtraceEventReader = struct {
    buf: gremlin.Reader,
    _ctl_num: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!MdpCmdReleaseBwFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = MdpCmdReleaseBwFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MdpCmdReleaseBwFtraceEventWire.CTL_NUM_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._ctl_num = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getCtlNum(self: *const MdpCmdReleaseBwFtraceEventReader) u32 {
        return self._ctl_num;
    }
};
const MdpMixerUpdateFtraceEventWire = struct {
    const MIXER_NUM_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const MdpMixerUpdateFtraceEvent = struct {
    // fields
    mixer_num: u32 = 0,
    pub fn calcProtobufSize(self: *const MdpMixerUpdateFtraceEvent) usize {
        var res: usize = 0;
        if (self.mixer_num != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpMixerUpdateFtraceEventWire.MIXER_NUM_WIRE) + gremlin.sizes.sizeU32(self.mixer_num);
        }
        return res;
    }
    pub fn encode(self: *const MdpMixerUpdateFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const MdpMixerUpdateFtraceEvent, target: *gremlin.Writer) void {
        if (self.mixer_num != 0) {
            target.appendUint32(MdpMixerUpdateFtraceEventWire.MIXER_NUM_WIRE, self.mixer_num);
        }
    }
};
pub const MdpMixerUpdateFtraceEventReader = struct {
    buf: gremlin.Reader,
    _mixer_num: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!MdpMixerUpdateFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = MdpMixerUpdateFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MdpMixerUpdateFtraceEventWire.MIXER_NUM_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._mixer_num = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getMixerNum(self: *const MdpMixerUpdateFtraceEventReader) u32 {
        return self._mixer_num;
    }
};
const MdpPerfSetWmLevelsFtraceEventWire = struct {
    const PNUM_WIRE: gremlin.ProtoWireNumber = 1;
    const USE_SPACE_WIRE: gremlin.ProtoWireNumber = 2;
    const PRIORITY_BYTES_WIRE: gremlin.ProtoWireNumber = 3;
    const WM0_WIRE: gremlin.ProtoWireNumber = 4;
    const WM1_WIRE: gremlin.ProtoWireNumber = 5;
    const WM2_WIRE: gremlin.ProtoWireNumber = 6;
    const MB_CNT_WIRE: gremlin.ProtoWireNumber = 7;
    const MB_SIZE_WIRE: gremlin.ProtoWireNumber = 8;
};
pub const MdpPerfSetWmLevelsFtraceEvent = struct {
    // fields
    pnum: u32 = 0,
    use_space: u32 = 0,
    priority_bytes: u32 = 0,
    wm0: u32 = 0,
    wm1: u32 = 0,
    wm2: u32 = 0,
    mb_cnt: u32 = 0,
    mb_size: u32 = 0,
    pub fn calcProtobufSize(self: *const MdpPerfSetWmLevelsFtraceEvent) usize {
        var res: usize = 0;
        if (self.pnum != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpPerfSetWmLevelsFtraceEventWire.PNUM_WIRE) + gremlin.sizes.sizeU32(self.pnum);
        }
        if (self.use_space != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpPerfSetWmLevelsFtraceEventWire.USE_SPACE_WIRE) + gremlin.sizes.sizeU32(self.use_space);
        }
        if (self.priority_bytes != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpPerfSetWmLevelsFtraceEventWire.PRIORITY_BYTES_WIRE) + gremlin.sizes.sizeU32(self.priority_bytes);
        }
        if (self.wm0 != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpPerfSetWmLevelsFtraceEventWire.WM0_WIRE) + gremlin.sizes.sizeU32(self.wm0);
        }
        if (self.wm1 != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpPerfSetWmLevelsFtraceEventWire.WM1_WIRE) + gremlin.sizes.sizeU32(self.wm1);
        }
        if (self.wm2 != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpPerfSetWmLevelsFtraceEventWire.WM2_WIRE) + gremlin.sizes.sizeU32(self.wm2);
        }
        if (self.mb_cnt != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpPerfSetWmLevelsFtraceEventWire.MB_CNT_WIRE) + gremlin.sizes.sizeU32(self.mb_cnt);
        }
        if (self.mb_size != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpPerfSetWmLevelsFtraceEventWire.MB_SIZE_WIRE) + gremlin.sizes.sizeU32(self.mb_size);
        }
        return res;
    }
    pub fn encode(self: *const MdpPerfSetWmLevelsFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const MdpPerfSetWmLevelsFtraceEvent, target: *gremlin.Writer) void {
        if (self.pnum != 0) {
            target.appendUint32(MdpPerfSetWmLevelsFtraceEventWire.PNUM_WIRE, self.pnum);
        }
        if (self.use_space != 0) {
            target.appendUint32(MdpPerfSetWmLevelsFtraceEventWire.USE_SPACE_WIRE, self.use_space);
        }
        if (self.priority_bytes != 0) {
            target.appendUint32(MdpPerfSetWmLevelsFtraceEventWire.PRIORITY_BYTES_WIRE, self.priority_bytes);
        }
        if (self.wm0 != 0) {
            target.appendUint32(MdpPerfSetWmLevelsFtraceEventWire.WM0_WIRE, self.wm0);
        }
        if (self.wm1 != 0) {
            target.appendUint32(MdpPerfSetWmLevelsFtraceEventWire.WM1_WIRE, self.wm1);
        }
        if (self.wm2 != 0) {
            target.appendUint32(MdpPerfSetWmLevelsFtraceEventWire.WM2_WIRE, self.wm2);
        }
        if (self.mb_cnt != 0) {
            target.appendUint32(MdpPerfSetWmLevelsFtraceEventWire.MB_CNT_WIRE, self.mb_cnt);
        }
        if (self.mb_size != 0) {
            target.appendUint32(MdpPerfSetWmLevelsFtraceEventWire.MB_SIZE_WIRE, self.mb_size);
        }
    }
};
pub const MdpPerfSetWmLevelsFtraceEventReader = struct {
    buf: gremlin.Reader,
    _pnum: u32 = 0,
    _use_space: u32 = 0,
    _priority_bytes: u32 = 0,
    _wm0: u32 = 0,
    _wm1: u32 = 0,
    _wm2: u32 = 0,
    _mb_cnt: u32 = 0,
    _mb_size: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!MdpPerfSetWmLevelsFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = MdpPerfSetWmLevelsFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MdpPerfSetWmLevelsFtraceEventWire.PNUM_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._pnum = result.value;
                },
                MdpPerfSetWmLevelsFtraceEventWire.USE_SPACE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._use_space = result.value;
                },
                MdpPerfSetWmLevelsFtraceEventWire.PRIORITY_BYTES_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._priority_bytes = result.value;
                },
                MdpPerfSetWmLevelsFtraceEventWire.WM0_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._wm0 = result.value;
                },
                MdpPerfSetWmLevelsFtraceEventWire.WM1_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._wm1 = result.value;
                },
                MdpPerfSetWmLevelsFtraceEventWire.WM2_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._wm2 = result.value;
                },
                MdpPerfSetWmLevelsFtraceEventWire.MB_CNT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._mb_cnt = result.value;
                },
                MdpPerfSetWmLevelsFtraceEventWire.MB_SIZE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._mb_size = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getPnum(self: *const MdpPerfSetWmLevelsFtraceEventReader) u32 {
        return self._pnum;
    }
    pub inline fn getUseSpace(self: *const MdpPerfSetWmLevelsFtraceEventReader) u32 {
        return self._use_space;
    }
    pub inline fn getPriorityBytes(self: *const MdpPerfSetWmLevelsFtraceEventReader) u32 {
        return self._priority_bytes;
    }
    pub inline fn getWm0(self: *const MdpPerfSetWmLevelsFtraceEventReader) u32 {
        return self._wm0;
    }
    pub inline fn getWm1(self: *const MdpPerfSetWmLevelsFtraceEventReader) u32 {
        return self._wm1;
    }
    pub inline fn getWm2(self: *const MdpPerfSetWmLevelsFtraceEventReader) u32 {
        return self._wm2;
    }
    pub inline fn getMbCnt(self: *const MdpPerfSetWmLevelsFtraceEventReader) u32 {
        return self._mb_cnt;
    }
    pub inline fn getMbSize(self: *const MdpPerfSetWmLevelsFtraceEventReader) u32 {
        return self._mb_size;
    }
};
const MdpVideoUnderrunDoneFtraceEventWire = struct {
    const CTL_NUM_WIRE: gremlin.ProtoWireNumber = 1;
    const UNDERRUN_CNT_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const MdpVideoUnderrunDoneFtraceEvent = struct {
    // fields
    ctl_num: u32 = 0,
    underrun_cnt: u32 = 0,
    pub fn calcProtobufSize(self: *const MdpVideoUnderrunDoneFtraceEvent) usize {
        var res: usize = 0;
        if (self.ctl_num != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpVideoUnderrunDoneFtraceEventWire.CTL_NUM_WIRE) + gremlin.sizes.sizeU32(self.ctl_num);
        }
        if (self.underrun_cnt != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpVideoUnderrunDoneFtraceEventWire.UNDERRUN_CNT_WIRE) + gremlin.sizes.sizeU32(self.underrun_cnt);
        }
        return res;
    }
    pub fn encode(self: *const MdpVideoUnderrunDoneFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const MdpVideoUnderrunDoneFtraceEvent, target: *gremlin.Writer) void {
        if (self.ctl_num != 0) {
            target.appendUint32(MdpVideoUnderrunDoneFtraceEventWire.CTL_NUM_WIRE, self.ctl_num);
        }
        if (self.underrun_cnt != 0) {
            target.appendUint32(MdpVideoUnderrunDoneFtraceEventWire.UNDERRUN_CNT_WIRE, self.underrun_cnt);
        }
    }
};
pub const MdpVideoUnderrunDoneFtraceEventReader = struct {
    buf: gremlin.Reader,
    _ctl_num: u32 = 0,
    _underrun_cnt: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!MdpVideoUnderrunDoneFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = MdpVideoUnderrunDoneFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MdpVideoUnderrunDoneFtraceEventWire.CTL_NUM_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._ctl_num = result.value;
                },
                MdpVideoUnderrunDoneFtraceEventWire.UNDERRUN_CNT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._underrun_cnt = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getCtlNum(self: *const MdpVideoUnderrunDoneFtraceEventReader) u32 {
        return self._ctl_num;
    }
    pub inline fn getUnderrunCnt(self: *const MdpVideoUnderrunDoneFtraceEventReader) u32 {
        return self._underrun_cnt;
    }
};
const MdpCmdWaitPingpongFtraceEventWire = struct {
    const CTL_NUM_WIRE: gremlin.ProtoWireNumber = 1;
    const KICKOFF_CNT_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const MdpCmdWaitPingpongFtraceEvent = struct {
    // fields
    ctl_num: u32 = 0,
    kickoff_cnt: i32 = 0,
    pub fn calcProtobufSize(self: *const MdpCmdWaitPingpongFtraceEvent) usize {
        var res: usize = 0;
        if (self.ctl_num != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpCmdWaitPingpongFtraceEventWire.CTL_NUM_WIRE) + gremlin.sizes.sizeU32(self.ctl_num);
        }
        if (self.kickoff_cnt != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpCmdWaitPingpongFtraceEventWire.KICKOFF_CNT_WIRE) + gremlin.sizes.sizeI32(self.kickoff_cnt);
        }
        return res;
    }
    pub fn encode(self: *const MdpCmdWaitPingpongFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const MdpCmdWaitPingpongFtraceEvent, target: *gremlin.Writer) void {
        if (self.ctl_num != 0) {
            target.appendUint32(MdpCmdWaitPingpongFtraceEventWire.CTL_NUM_WIRE, self.ctl_num);
        }
        if (self.kickoff_cnt != 0) {
            target.appendInt32(MdpCmdWaitPingpongFtraceEventWire.KICKOFF_CNT_WIRE, self.kickoff_cnt);
        }
    }
};
pub const MdpCmdWaitPingpongFtraceEventReader = struct {
    buf: gremlin.Reader,
    _ctl_num: u32 = 0,
    _kickoff_cnt: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!MdpCmdWaitPingpongFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = MdpCmdWaitPingpongFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MdpCmdWaitPingpongFtraceEventWire.CTL_NUM_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._ctl_num = result.value;
                },
                MdpCmdWaitPingpongFtraceEventWire.KICKOFF_CNT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._kickoff_cnt = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getCtlNum(self: *const MdpCmdWaitPingpongFtraceEventReader) u32 {
        return self._ctl_num;
    }
    pub inline fn getKickoffCnt(self: *const MdpCmdWaitPingpongFtraceEventReader) i32 {
        return self._kickoff_cnt;
    }
};
const MdpPerfPrefillCalcFtraceEventWire = struct {
    const PNUM_WIRE: gremlin.ProtoWireNumber = 1;
    const LATENCY_BUF_WIRE: gremlin.ProtoWireNumber = 2;
    const OT_WIRE: gremlin.ProtoWireNumber = 3;
    const Y_BUF_WIRE: gremlin.ProtoWireNumber = 4;
    const Y_SCALER_WIRE: gremlin.ProtoWireNumber = 5;
    const PP_LINES_WIRE: gremlin.ProtoWireNumber = 6;
    const PP_BYTES_WIRE: gremlin.ProtoWireNumber = 7;
    const POST_SC_WIRE: gremlin.ProtoWireNumber = 8;
    const FBC_BYTES_WIRE: gremlin.ProtoWireNumber = 9;
    const PREFILL_BYTES_WIRE: gremlin.ProtoWireNumber = 10;
};
pub const MdpPerfPrefillCalcFtraceEvent = struct {
    // fields
    pnum: u32 = 0,
    latency_buf: u32 = 0,
    ot: u32 = 0,
    y_buf: u32 = 0,
    y_scaler: u32 = 0,
    pp_lines: u32 = 0,
    pp_bytes: u32 = 0,
    post_sc: u32 = 0,
    fbc_bytes: u32 = 0,
    prefill_bytes: u32 = 0,
    pub fn calcProtobufSize(self: *const MdpPerfPrefillCalcFtraceEvent) usize {
        var res: usize = 0;
        if (self.pnum != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpPerfPrefillCalcFtraceEventWire.PNUM_WIRE) + gremlin.sizes.sizeU32(self.pnum);
        }
        if (self.latency_buf != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpPerfPrefillCalcFtraceEventWire.LATENCY_BUF_WIRE) + gremlin.sizes.sizeU32(self.latency_buf);
        }
        if (self.ot != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpPerfPrefillCalcFtraceEventWire.OT_WIRE) + gremlin.sizes.sizeU32(self.ot);
        }
        if (self.y_buf != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpPerfPrefillCalcFtraceEventWire.Y_BUF_WIRE) + gremlin.sizes.sizeU32(self.y_buf);
        }
        if (self.y_scaler != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpPerfPrefillCalcFtraceEventWire.Y_SCALER_WIRE) + gremlin.sizes.sizeU32(self.y_scaler);
        }
        if (self.pp_lines != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpPerfPrefillCalcFtraceEventWire.PP_LINES_WIRE) + gremlin.sizes.sizeU32(self.pp_lines);
        }
        if (self.pp_bytes != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpPerfPrefillCalcFtraceEventWire.PP_BYTES_WIRE) + gremlin.sizes.sizeU32(self.pp_bytes);
        }
        if (self.post_sc != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpPerfPrefillCalcFtraceEventWire.POST_SC_WIRE) + gremlin.sizes.sizeU32(self.post_sc);
        }
        if (self.fbc_bytes != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpPerfPrefillCalcFtraceEventWire.FBC_BYTES_WIRE) + gremlin.sizes.sizeU32(self.fbc_bytes);
        }
        if (self.prefill_bytes != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpPerfPrefillCalcFtraceEventWire.PREFILL_BYTES_WIRE) + gremlin.sizes.sizeU32(self.prefill_bytes);
        }
        return res;
    }
    pub fn encode(self: *const MdpPerfPrefillCalcFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const MdpPerfPrefillCalcFtraceEvent, target: *gremlin.Writer) void {
        if (self.pnum != 0) {
            target.appendUint32(MdpPerfPrefillCalcFtraceEventWire.PNUM_WIRE, self.pnum);
        }
        if (self.latency_buf != 0) {
            target.appendUint32(MdpPerfPrefillCalcFtraceEventWire.LATENCY_BUF_WIRE, self.latency_buf);
        }
        if (self.ot != 0) {
            target.appendUint32(MdpPerfPrefillCalcFtraceEventWire.OT_WIRE, self.ot);
        }
        if (self.y_buf != 0) {
            target.appendUint32(MdpPerfPrefillCalcFtraceEventWire.Y_BUF_WIRE, self.y_buf);
        }
        if (self.y_scaler != 0) {
            target.appendUint32(MdpPerfPrefillCalcFtraceEventWire.Y_SCALER_WIRE, self.y_scaler);
        }
        if (self.pp_lines != 0) {
            target.appendUint32(MdpPerfPrefillCalcFtraceEventWire.PP_LINES_WIRE, self.pp_lines);
        }
        if (self.pp_bytes != 0) {
            target.appendUint32(MdpPerfPrefillCalcFtraceEventWire.PP_BYTES_WIRE, self.pp_bytes);
        }
        if (self.post_sc != 0) {
            target.appendUint32(MdpPerfPrefillCalcFtraceEventWire.POST_SC_WIRE, self.post_sc);
        }
        if (self.fbc_bytes != 0) {
            target.appendUint32(MdpPerfPrefillCalcFtraceEventWire.FBC_BYTES_WIRE, self.fbc_bytes);
        }
        if (self.prefill_bytes != 0) {
            target.appendUint32(MdpPerfPrefillCalcFtraceEventWire.PREFILL_BYTES_WIRE, self.prefill_bytes);
        }
    }
};
pub const MdpPerfPrefillCalcFtraceEventReader = struct {
    buf: gremlin.Reader,
    _pnum: u32 = 0,
    _latency_buf: u32 = 0,
    _ot: u32 = 0,
    _y_buf: u32 = 0,
    _y_scaler: u32 = 0,
    _pp_lines: u32 = 0,
    _pp_bytes: u32 = 0,
    _post_sc: u32 = 0,
    _fbc_bytes: u32 = 0,
    _prefill_bytes: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!MdpPerfPrefillCalcFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = MdpPerfPrefillCalcFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MdpPerfPrefillCalcFtraceEventWire.PNUM_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._pnum = result.value;
                },
                MdpPerfPrefillCalcFtraceEventWire.LATENCY_BUF_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._latency_buf = result.value;
                },
                MdpPerfPrefillCalcFtraceEventWire.OT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._ot = result.value;
                },
                MdpPerfPrefillCalcFtraceEventWire.Y_BUF_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._y_buf = result.value;
                },
                MdpPerfPrefillCalcFtraceEventWire.Y_SCALER_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._y_scaler = result.value;
                },
                MdpPerfPrefillCalcFtraceEventWire.PP_LINES_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._pp_lines = result.value;
                },
                MdpPerfPrefillCalcFtraceEventWire.PP_BYTES_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._pp_bytes = result.value;
                },
                MdpPerfPrefillCalcFtraceEventWire.POST_SC_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._post_sc = result.value;
                },
                MdpPerfPrefillCalcFtraceEventWire.FBC_BYTES_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._fbc_bytes = result.value;
                },
                MdpPerfPrefillCalcFtraceEventWire.PREFILL_BYTES_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._prefill_bytes = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getPnum(self: *const MdpPerfPrefillCalcFtraceEventReader) u32 {
        return self._pnum;
    }
    pub inline fn getLatencyBuf(self: *const MdpPerfPrefillCalcFtraceEventReader) u32 {
        return self._latency_buf;
    }
    pub inline fn getOt(self: *const MdpPerfPrefillCalcFtraceEventReader) u32 {
        return self._ot;
    }
    pub inline fn getYBuf(self: *const MdpPerfPrefillCalcFtraceEventReader) u32 {
        return self._y_buf;
    }
    pub inline fn getYScaler(self: *const MdpPerfPrefillCalcFtraceEventReader) u32 {
        return self._y_scaler;
    }
    pub inline fn getPpLines(self: *const MdpPerfPrefillCalcFtraceEventReader) u32 {
        return self._pp_lines;
    }
    pub inline fn getPpBytes(self: *const MdpPerfPrefillCalcFtraceEventReader) u32 {
        return self._pp_bytes;
    }
    pub inline fn getPostSc(self: *const MdpPerfPrefillCalcFtraceEventReader) u32 {
        return self._post_sc;
    }
    pub inline fn getFbcBytes(self: *const MdpPerfPrefillCalcFtraceEventReader) u32 {
        return self._fbc_bytes;
    }
    pub inline fn getPrefillBytes(self: *const MdpPerfPrefillCalcFtraceEventReader) u32 {
        return self._prefill_bytes;
    }
};
const MdpPerfUpdateBusFtraceEventWire = struct {
    const CLIENT_WIRE: gremlin.ProtoWireNumber = 1;
    const AB_QUOTA_WIRE: gremlin.ProtoWireNumber = 2;
    const IB_QUOTA_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const MdpPerfUpdateBusFtraceEvent = struct {
    // fields
    client: i32 = 0,
    ab_quota: u64 = 0,
    ib_quota: u64 = 0,
    pub fn calcProtobufSize(self: *const MdpPerfUpdateBusFtraceEvent) usize {
        var res: usize = 0;
        if (self.client != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpPerfUpdateBusFtraceEventWire.CLIENT_WIRE) + gremlin.sizes.sizeI32(self.client);
        }
        if (self.ab_quota != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpPerfUpdateBusFtraceEventWire.AB_QUOTA_WIRE) + gremlin.sizes.sizeU64(self.ab_quota);
        }
        if (self.ib_quota != 0) {
            res += gremlin.sizes.sizeWireNumber(MdpPerfUpdateBusFtraceEventWire.IB_QUOTA_WIRE) + gremlin.sizes.sizeU64(self.ib_quota);
        }
        return res;
    }
    pub fn encode(self: *const MdpPerfUpdateBusFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const MdpPerfUpdateBusFtraceEvent, target: *gremlin.Writer) void {
        if (self.client != 0) {
            target.appendInt32(MdpPerfUpdateBusFtraceEventWire.CLIENT_WIRE, self.client);
        }
        if (self.ab_quota != 0) {
            target.appendUint64(MdpPerfUpdateBusFtraceEventWire.AB_QUOTA_WIRE, self.ab_quota);
        }
        if (self.ib_quota != 0) {
            target.appendUint64(MdpPerfUpdateBusFtraceEventWire.IB_QUOTA_WIRE, self.ib_quota);
        }
    }
};
pub const MdpPerfUpdateBusFtraceEventReader = struct {
    buf: gremlin.Reader,
    _client: i32 = 0,
    _ab_quota: u64 = 0,
    _ib_quota: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!MdpPerfUpdateBusFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = MdpPerfUpdateBusFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MdpPerfUpdateBusFtraceEventWire.CLIENT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._client = result.value;
                },
                MdpPerfUpdateBusFtraceEventWire.AB_QUOTA_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ab_quota = result.value;
                },
                MdpPerfUpdateBusFtraceEventWire.IB_QUOTA_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ib_quota = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getClient(self: *const MdpPerfUpdateBusFtraceEventReader) i32 {
        return self._client;
    }
    pub inline fn getAbQuota(self: *const MdpPerfUpdateBusFtraceEventReader) u64 {
        return self._ab_quota;
    }
    pub inline fn getIbQuota(self: *const MdpPerfUpdateBusFtraceEventReader) u64 {
        return self._ib_quota;
    }
};
const RotatorBwAoAsContextFtraceEventWire = struct {
    const STATE_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const RotatorBwAoAsContextFtraceEvent = struct {
    // fields
    state: u32 = 0,
    pub fn calcProtobufSize(self: *const RotatorBwAoAsContextFtraceEvent) usize {
        var res: usize = 0;
        if (self.state != 0) {
            res += gremlin.sizes.sizeWireNumber(RotatorBwAoAsContextFtraceEventWire.STATE_WIRE) + gremlin.sizes.sizeU32(self.state);
        }
        return res;
    }
    pub fn encode(self: *const RotatorBwAoAsContextFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const RotatorBwAoAsContextFtraceEvent, target: *gremlin.Writer) void {
        if (self.state != 0) {
            target.appendUint32(RotatorBwAoAsContextFtraceEventWire.STATE_WIRE, self.state);
        }
    }
};
pub const RotatorBwAoAsContextFtraceEventReader = struct {
    buf: gremlin.Reader,
    _state: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!RotatorBwAoAsContextFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = RotatorBwAoAsContextFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                RotatorBwAoAsContextFtraceEventWire.STATE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._state = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getState(self: *const RotatorBwAoAsContextFtraceEventReader) u32 {
        return self._state;
    }
};
