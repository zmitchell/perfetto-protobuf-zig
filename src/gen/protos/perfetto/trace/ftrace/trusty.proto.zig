// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const TrustySmcFtraceEventWire = struct {
    const R0_WIRE: gremlin.ProtoWireNumber = 1;
    const R1_WIRE: gremlin.ProtoWireNumber = 2;
    const R2_WIRE: gremlin.ProtoWireNumber = 3;
    const R3_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const TrustySmcFtraceEvent = struct {
    // fields
    r0: u64 = 0,
    r1: u64 = 0,
    r2: u64 = 0,
    r3: u64 = 0,
    pub fn calcProtobufSize(self: *const TrustySmcFtraceEvent) usize {
        var res: usize = 0;
        if (self.r0 != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustySmcFtraceEventWire.R0_WIRE) + gremlin.sizes.sizeU64(self.r0);
        }
        if (self.r1 != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustySmcFtraceEventWire.R1_WIRE) + gremlin.sizes.sizeU64(self.r1);
        }
        if (self.r2 != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustySmcFtraceEventWire.R2_WIRE) + gremlin.sizes.sizeU64(self.r2);
        }
        if (self.r3 != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustySmcFtraceEventWire.R3_WIRE) + gremlin.sizes.sizeU64(self.r3);
        }
        return res;
    }
    pub fn encode(self: *const TrustySmcFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TrustySmcFtraceEvent, target: *gremlin.Writer) void {
        if (self.r0 != 0) {
            target.appendUint64(TrustySmcFtraceEventWire.R0_WIRE, self.r0);
        }
        if (self.r1 != 0) {
            target.appendUint64(TrustySmcFtraceEventWire.R1_WIRE, self.r1);
        }
        if (self.r2 != 0) {
            target.appendUint64(TrustySmcFtraceEventWire.R2_WIRE, self.r2);
        }
        if (self.r3 != 0) {
            target.appendUint64(TrustySmcFtraceEventWire.R3_WIRE, self.r3);
        }
    }
};
pub const TrustySmcFtraceEventReader = struct {
    buf: gremlin.Reader,
    _r0: u64 = 0,
    _r1: u64 = 0,
    _r2: u64 = 0,
    _r3: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!TrustySmcFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = TrustySmcFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TrustySmcFtraceEventWire.R0_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._r0 = result.value;
                },
                TrustySmcFtraceEventWire.R1_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._r1 = result.value;
                },
                TrustySmcFtraceEventWire.R2_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._r2 = result.value;
                },
                TrustySmcFtraceEventWire.R3_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._r3 = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getR0(self: *const TrustySmcFtraceEventReader) u64 {
        return self._r0;
    }
    pub inline fn getR1(self: *const TrustySmcFtraceEventReader) u64 {
        return self._r1;
    }
    pub inline fn getR2(self: *const TrustySmcFtraceEventReader) u64 {
        return self._r2;
    }
    pub inline fn getR3(self: *const TrustySmcFtraceEventReader) u64 {
        return self._r3;
    }
};
const TrustySmcDoneFtraceEventWire = struct {
    const RET_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const TrustySmcDoneFtraceEvent = struct {
    // fields
    ret: u64 = 0,
    pub fn calcProtobufSize(self: *const TrustySmcDoneFtraceEvent) usize {
        var res: usize = 0;
        if (self.ret != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustySmcDoneFtraceEventWire.RET_WIRE) + gremlin.sizes.sizeU64(self.ret);
        }
        return res;
    }
    pub fn encode(self: *const TrustySmcDoneFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TrustySmcDoneFtraceEvent, target: *gremlin.Writer) void {
        if (self.ret != 0) {
            target.appendUint64(TrustySmcDoneFtraceEventWire.RET_WIRE, self.ret);
        }
    }
};
pub const TrustySmcDoneFtraceEventReader = struct {
    buf: gremlin.Reader,
    _ret: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!TrustySmcDoneFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = TrustySmcDoneFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TrustySmcDoneFtraceEventWire.RET_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ret = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getRet(self: *const TrustySmcDoneFtraceEventReader) u64 {
        return self._ret;
    }
};
const TrustyStdCall32FtraceEventWire = struct {
    const R0_WIRE: gremlin.ProtoWireNumber = 1;
    const R1_WIRE: gremlin.ProtoWireNumber = 2;
    const R2_WIRE: gremlin.ProtoWireNumber = 3;
    const R3_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const TrustyStdCall32FtraceEvent = struct {
    // fields
    r0: u64 = 0,
    r1: u64 = 0,
    r2: u64 = 0,
    r3: u64 = 0,
    pub fn calcProtobufSize(self: *const TrustyStdCall32FtraceEvent) usize {
        var res: usize = 0;
        if (self.r0 != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustyStdCall32FtraceEventWire.R0_WIRE) + gremlin.sizes.sizeU64(self.r0);
        }
        if (self.r1 != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustyStdCall32FtraceEventWire.R1_WIRE) + gremlin.sizes.sizeU64(self.r1);
        }
        if (self.r2 != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustyStdCall32FtraceEventWire.R2_WIRE) + gremlin.sizes.sizeU64(self.r2);
        }
        if (self.r3 != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustyStdCall32FtraceEventWire.R3_WIRE) + gremlin.sizes.sizeU64(self.r3);
        }
        return res;
    }
    pub fn encode(self: *const TrustyStdCall32FtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TrustyStdCall32FtraceEvent, target: *gremlin.Writer) void {
        if (self.r0 != 0) {
            target.appendUint64(TrustyStdCall32FtraceEventWire.R0_WIRE, self.r0);
        }
        if (self.r1 != 0) {
            target.appendUint64(TrustyStdCall32FtraceEventWire.R1_WIRE, self.r1);
        }
        if (self.r2 != 0) {
            target.appendUint64(TrustyStdCall32FtraceEventWire.R2_WIRE, self.r2);
        }
        if (self.r3 != 0) {
            target.appendUint64(TrustyStdCall32FtraceEventWire.R3_WIRE, self.r3);
        }
    }
};
pub const TrustyStdCall32FtraceEventReader = struct {
    buf: gremlin.Reader,
    _r0: u64 = 0,
    _r1: u64 = 0,
    _r2: u64 = 0,
    _r3: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!TrustyStdCall32FtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = TrustyStdCall32FtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TrustyStdCall32FtraceEventWire.R0_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._r0 = result.value;
                },
                TrustyStdCall32FtraceEventWire.R1_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._r1 = result.value;
                },
                TrustyStdCall32FtraceEventWire.R2_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._r2 = result.value;
                },
                TrustyStdCall32FtraceEventWire.R3_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._r3 = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getR0(self: *const TrustyStdCall32FtraceEventReader) u64 {
        return self._r0;
    }
    pub inline fn getR1(self: *const TrustyStdCall32FtraceEventReader) u64 {
        return self._r1;
    }
    pub inline fn getR2(self: *const TrustyStdCall32FtraceEventReader) u64 {
        return self._r2;
    }
    pub inline fn getR3(self: *const TrustyStdCall32FtraceEventReader) u64 {
        return self._r3;
    }
};
const TrustyStdCall32DoneFtraceEventWire = struct {
    const RET_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const TrustyStdCall32DoneFtraceEvent = struct {
    // fields
    ret: i64 = 0,
    pub fn calcProtobufSize(self: *const TrustyStdCall32DoneFtraceEvent) usize {
        var res: usize = 0;
        if (self.ret != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustyStdCall32DoneFtraceEventWire.RET_WIRE) + gremlin.sizes.sizeI64(self.ret);
        }
        return res;
    }
    pub fn encode(self: *const TrustyStdCall32DoneFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TrustyStdCall32DoneFtraceEvent, target: *gremlin.Writer) void {
        if (self.ret != 0) {
            target.appendInt64(TrustyStdCall32DoneFtraceEventWire.RET_WIRE, self.ret);
        }
    }
};
pub const TrustyStdCall32DoneFtraceEventReader = struct {
    buf: gremlin.Reader,
    _ret: i64 = 0,
    pub fn init(src: []const u8) gremlin.Error!TrustyStdCall32DoneFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = TrustyStdCall32DoneFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TrustyStdCall32DoneFtraceEventWire.RET_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._ret = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getRet(self: *const TrustyStdCall32DoneFtraceEventReader) i64 {
        return self._ret;
    }
};
const TrustyShareMemoryFtraceEventWire = struct {
    const LEN_WIRE: gremlin.ProtoWireNumber = 1;
    const LEND_WIRE: gremlin.ProtoWireNumber = 2;
    const NENTS_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const TrustyShareMemoryFtraceEvent = struct {
    // fields
    len: u64 = 0,
    lend: u32 = 0,
    nents: u32 = 0,
    pub fn calcProtobufSize(self: *const TrustyShareMemoryFtraceEvent) usize {
        var res: usize = 0;
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustyShareMemoryFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeU64(self.len);
        }
        if (self.lend != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustyShareMemoryFtraceEventWire.LEND_WIRE) + gremlin.sizes.sizeU32(self.lend);
        }
        if (self.nents != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustyShareMemoryFtraceEventWire.NENTS_WIRE) + gremlin.sizes.sizeU32(self.nents);
        }
        return res;
    }
    pub fn encode(self: *const TrustyShareMemoryFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TrustyShareMemoryFtraceEvent, target: *gremlin.Writer) void {
        if (self.len != 0) {
            target.appendUint64(TrustyShareMemoryFtraceEventWire.LEN_WIRE, self.len);
        }
        if (self.lend != 0) {
            target.appendUint32(TrustyShareMemoryFtraceEventWire.LEND_WIRE, self.lend);
        }
        if (self.nents != 0) {
            target.appendUint32(TrustyShareMemoryFtraceEventWire.NENTS_WIRE, self.nents);
        }
    }
};
pub const TrustyShareMemoryFtraceEventReader = struct {
    buf: gremlin.Reader,
    _len: u64 = 0,
    _lend: u32 = 0,
    _nents: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!TrustyShareMemoryFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = TrustyShareMemoryFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TrustyShareMemoryFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                TrustyShareMemoryFtraceEventWire.LEND_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._lend = result.value;
                },
                TrustyShareMemoryFtraceEventWire.NENTS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._nents = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getLen(self: *const TrustyShareMemoryFtraceEventReader) u64 {
        return self._len;
    }
    pub inline fn getLend(self: *const TrustyShareMemoryFtraceEventReader) u32 {
        return self._lend;
    }
    pub inline fn getNents(self: *const TrustyShareMemoryFtraceEventReader) u32 {
        return self._nents;
    }
};
const TrustyShareMemoryDoneFtraceEventWire = struct {
    const HANDLE_WIRE: gremlin.ProtoWireNumber = 1;
    const LEN_WIRE: gremlin.ProtoWireNumber = 2;
    const LEND_WIRE: gremlin.ProtoWireNumber = 3;
    const NENTS_WIRE: gremlin.ProtoWireNumber = 4;
    const RET_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const TrustyShareMemoryDoneFtraceEvent = struct {
    // fields
    handle: u64 = 0,
    len: u64 = 0,
    lend: u32 = 0,
    nents: u32 = 0,
    ret: i32 = 0,
    pub fn calcProtobufSize(self: *const TrustyShareMemoryDoneFtraceEvent) usize {
        var res: usize = 0;
        if (self.handle != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustyShareMemoryDoneFtraceEventWire.HANDLE_WIRE) + gremlin.sizes.sizeU64(self.handle);
        }
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustyShareMemoryDoneFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeU64(self.len);
        }
        if (self.lend != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustyShareMemoryDoneFtraceEventWire.LEND_WIRE) + gremlin.sizes.sizeU32(self.lend);
        }
        if (self.nents != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustyShareMemoryDoneFtraceEventWire.NENTS_WIRE) + gremlin.sizes.sizeU32(self.nents);
        }
        if (self.ret != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustyShareMemoryDoneFtraceEventWire.RET_WIRE) + gremlin.sizes.sizeI32(self.ret);
        }
        return res;
    }
    pub fn encode(self: *const TrustyShareMemoryDoneFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TrustyShareMemoryDoneFtraceEvent, target: *gremlin.Writer) void {
        if (self.handle != 0) {
            target.appendUint64(TrustyShareMemoryDoneFtraceEventWire.HANDLE_WIRE, self.handle);
        }
        if (self.len != 0) {
            target.appendUint64(TrustyShareMemoryDoneFtraceEventWire.LEN_WIRE, self.len);
        }
        if (self.lend != 0) {
            target.appendUint32(TrustyShareMemoryDoneFtraceEventWire.LEND_WIRE, self.lend);
        }
        if (self.nents != 0) {
            target.appendUint32(TrustyShareMemoryDoneFtraceEventWire.NENTS_WIRE, self.nents);
        }
        if (self.ret != 0) {
            target.appendInt32(TrustyShareMemoryDoneFtraceEventWire.RET_WIRE, self.ret);
        }
    }
};
pub const TrustyShareMemoryDoneFtraceEventReader = struct {
    buf: gremlin.Reader,
    _handle: u64 = 0,
    _len: u64 = 0,
    _lend: u32 = 0,
    _nents: u32 = 0,
    _ret: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!TrustyShareMemoryDoneFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = TrustyShareMemoryDoneFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TrustyShareMemoryDoneFtraceEventWire.HANDLE_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._handle = result.value;
                },
                TrustyShareMemoryDoneFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                TrustyShareMemoryDoneFtraceEventWire.LEND_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._lend = result.value;
                },
                TrustyShareMemoryDoneFtraceEventWire.NENTS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._nents = result.value;
                },
                TrustyShareMemoryDoneFtraceEventWire.RET_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._ret = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getHandle(self: *const TrustyShareMemoryDoneFtraceEventReader) u64 {
        return self._handle;
    }
    pub inline fn getLen(self: *const TrustyShareMemoryDoneFtraceEventReader) u64 {
        return self._len;
    }
    pub inline fn getLend(self: *const TrustyShareMemoryDoneFtraceEventReader) u32 {
        return self._lend;
    }
    pub inline fn getNents(self: *const TrustyShareMemoryDoneFtraceEventReader) u32 {
        return self._nents;
    }
    pub inline fn getRet(self: *const TrustyShareMemoryDoneFtraceEventReader) i32 {
        return self._ret;
    }
};
const TrustyReclaimMemoryFtraceEventWire = struct {
    const ID_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const TrustyReclaimMemoryFtraceEvent = struct {
    // fields
    id: u64 = 0,
    pub fn calcProtobufSize(self: *const TrustyReclaimMemoryFtraceEvent) usize {
        var res: usize = 0;
        if (self.id != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustyReclaimMemoryFtraceEventWire.ID_WIRE) + gremlin.sizes.sizeU64(self.id);
        }
        return res;
    }
    pub fn encode(self: *const TrustyReclaimMemoryFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TrustyReclaimMemoryFtraceEvent, target: *gremlin.Writer) void {
        if (self.id != 0) {
            target.appendUint64(TrustyReclaimMemoryFtraceEventWire.ID_WIRE, self.id);
        }
    }
};
pub const TrustyReclaimMemoryFtraceEventReader = struct {
    buf: gremlin.Reader,
    _id: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!TrustyReclaimMemoryFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = TrustyReclaimMemoryFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TrustyReclaimMemoryFtraceEventWire.ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._id = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getId(self: *const TrustyReclaimMemoryFtraceEventReader) u64 {
        return self._id;
    }
};
const TrustyReclaimMemoryDoneFtraceEventWire = struct {
    const ID_WIRE: gremlin.ProtoWireNumber = 1;
    const RET_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const TrustyReclaimMemoryDoneFtraceEvent = struct {
    // fields
    id: u64 = 0,
    ret: i32 = 0,
    pub fn calcProtobufSize(self: *const TrustyReclaimMemoryDoneFtraceEvent) usize {
        var res: usize = 0;
        if (self.id != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustyReclaimMemoryDoneFtraceEventWire.ID_WIRE) + gremlin.sizes.sizeU64(self.id);
        }
        if (self.ret != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustyReclaimMemoryDoneFtraceEventWire.RET_WIRE) + gremlin.sizes.sizeI32(self.ret);
        }
        return res;
    }
    pub fn encode(self: *const TrustyReclaimMemoryDoneFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TrustyReclaimMemoryDoneFtraceEvent, target: *gremlin.Writer) void {
        if (self.id != 0) {
            target.appendUint64(TrustyReclaimMemoryDoneFtraceEventWire.ID_WIRE, self.id);
        }
        if (self.ret != 0) {
            target.appendInt32(TrustyReclaimMemoryDoneFtraceEventWire.RET_WIRE, self.ret);
        }
    }
};
pub const TrustyReclaimMemoryDoneFtraceEventReader = struct {
    buf: gremlin.Reader,
    _id: u64 = 0,
    _ret: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!TrustyReclaimMemoryDoneFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = TrustyReclaimMemoryDoneFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TrustyReclaimMemoryDoneFtraceEventWire.ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._id = result.value;
                },
                TrustyReclaimMemoryDoneFtraceEventWire.RET_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._ret = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getId(self: *const TrustyReclaimMemoryDoneFtraceEventReader) u64 {
        return self._id;
    }
    pub inline fn getRet(self: *const TrustyReclaimMemoryDoneFtraceEventReader) i32 {
        return self._ret;
    }
};
const TrustyIrqFtraceEventWire = struct {
    const IRQ_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const TrustyIrqFtraceEvent = struct {
    // fields
    irq: i32 = 0,
    pub fn calcProtobufSize(self: *const TrustyIrqFtraceEvent) usize {
        var res: usize = 0;
        if (self.irq != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustyIrqFtraceEventWire.IRQ_WIRE) + gremlin.sizes.sizeI32(self.irq);
        }
        return res;
    }
    pub fn encode(self: *const TrustyIrqFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TrustyIrqFtraceEvent, target: *gremlin.Writer) void {
        if (self.irq != 0) {
            target.appendInt32(TrustyIrqFtraceEventWire.IRQ_WIRE, self.irq);
        }
    }
};
pub const TrustyIrqFtraceEventReader = struct {
    buf: gremlin.Reader,
    _irq: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!TrustyIrqFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = TrustyIrqFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TrustyIrqFtraceEventWire.IRQ_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._irq = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getIrq(self: *const TrustyIrqFtraceEventReader) i32 {
        return self._irq;
    }
};
const TrustyIpcHandleEventFtraceEventWire = struct {
    const CHAN_WIRE: gremlin.ProtoWireNumber = 1;
    const EVENT_ID_WIRE: gremlin.ProtoWireNumber = 2;
    const SRV_NAME_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const TrustyIpcHandleEventFtraceEvent = struct {
    // fields
    chan: u32 = 0,
    event_id: u32 = 0,
    srv_name: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const TrustyIpcHandleEventFtraceEvent) usize {
        var res: usize = 0;
        if (self.chan != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustyIpcHandleEventFtraceEventWire.CHAN_WIRE) + gremlin.sizes.sizeU32(self.chan);
        }
        if (self.event_id != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustyIpcHandleEventFtraceEventWire.EVENT_ID_WIRE) + gremlin.sizes.sizeU32(self.event_id);
        }
        if (self.srv_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TrustyIpcHandleEventFtraceEventWire.SRV_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const TrustyIpcHandleEventFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TrustyIpcHandleEventFtraceEvent, target: *gremlin.Writer) void {
        if (self.chan != 0) {
            target.appendUint32(TrustyIpcHandleEventFtraceEventWire.CHAN_WIRE, self.chan);
        }
        if (self.event_id != 0) {
            target.appendUint32(TrustyIpcHandleEventFtraceEventWire.EVENT_ID_WIRE, self.event_id);
        }
        if (self.srv_name) |v| {
            if (v.len > 0) {
                target.appendBytes(TrustyIpcHandleEventFtraceEventWire.SRV_NAME_WIRE, v);
            }
        }
    }
};
pub const TrustyIpcHandleEventFtraceEventReader = struct {
    buf: gremlin.Reader,
    _chan: u32 = 0,
    _event_id: u32 = 0,
    _srv_name: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!TrustyIpcHandleEventFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = TrustyIpcHandleEventFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TrustyIpcHandleEventFtraceEventWire.CHAN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._chan = result.value;
                },
                TrustyIpcHandleEventFtraceEventWire.EVENT_ID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._event_id = result.value;
                },
                TrustyIpcHandleEventFtraceEventWire.SRV_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._srv_name = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getChan(self: *const TrustyIpcHandleEventFtraceEventReader) u32 {
        return self._chan;
    }
    pub inline fn getEventId(self: *const TrustyIpcHandleEventFtraceEventReader) u32 {
        return self._event_id;
    }
    pub inline fn getSrvName(self: *const TrustyIpcHandleEventFtraceEventReader) []const u8 {
        return self._srv_name orelse &[_]u8{};
    }
};
const TrustyIpcConnectFtraceEventWire = struct {
    const CHAN_WIRE: gremlin.ProtoWireNumber = 1;
    const PORT_WIRE: gremlin.ProtoWireNumber = 2;
    const STATE_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const TrustyIpcConnectFtraceEvent = struct {
    // fields
    chan: u32 = 0,
    port: ?[]const u8 = null,
    state: i32 = 0,
    pub fn calcProtobufSize(self: *const TrustyIpcConnectFtraceEvent) usize {
        var res: usize = 0;
        if (self.chan != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustyIpcConnectFtraceEventWire.CHAN_WIRE) + gremlin.sizes.sizeU32(self.chan);
        }
        if (self.port) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TrustyIpcConnectFtraceEventWire.PORT_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.state != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustyIpcConnectFtraceEventWire.STATE_WIRE) + gremlin.sizes.sizeI32(self.state);
        }
        return res;
    }
    pub fn encode(self: *const TrustyIpcConnectFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TrustyIpcConnectFtraceEvent, target: *gremlin.Writer) void {
        if (self.chan != 0) {
            target.appendUint32(TrustyIpcConnectFtraceEventWire.CHAN_WIRE, self.chan);
        }
        if (self.port) |v| {
            if (v.len > 0) {
                target.appendBytes(TrustyIpcConnectFtraceEventWire.PORT_WIRE, v);
            }
        }
        if (self.state != 0) {
            target.appendInt32(TrustyIpcConnectFtraceEventWire.STATE_WIRE, self.state);
        }
    }
};
pub const TrustyIpcConnectFtraceEventReader = struct {
    buf: gremlin.Reader,
    _chan: u32 = 0,
    _port: ?[]const u8 = null,
    _state: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!TrustyIpcConnectFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = TrustyIpcConnectFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TrustyIpcConnectFtraceEventWire.CHAN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._chan = result.value;
                },
                TrustyIpcConnectFtraceEventWire.PORT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._port = result.value;
                },
                TrustyIpcConnectFtraceEventWire.STATE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._state = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getChan(self: *const TrustyIpcConnectFtraceEventReader) u32 {
        return self._chan;
    }
    pub inline fn getPort(self: *const TrustyIpcConnectFtraceEventReader) []const u8 {
        return self._port orelse &[_]u8{};
    }
    pub inline fn getState(self: *const TrustyIpcConnectFtraceEventReader) i32 {
        return self._state;
    }
};
const TrustyIpcConnectEndFtraceEventWire = struct {
    const CHAN_WIRE: gremlin.ProtoWireNumber = 1;
    const ERR_WIRE: gremlin.ProtoWireNumber = 2;
    const STATE_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const TrustyIpcConnectEndFtraceEvent = struct {
    // fields
    chan: u32 = 0,
    err: i32 = 0,
    state: i32 = 0,
    pub fn calcProtobufSize(self: *const TrustyIpcConnectEndFtraceEvent) usize {
        var res: usize = 0;
        if (self.chan != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustyIpcConnectEndFtraceEventWire.CHAN_WIRE) + gremlin.sizes.sizeU32(self.chan);
        }
        if (self.err != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustyIpcConnectEndFtraceEventWire.ERR_WIRE) + gremlin.sizes.sizeI32(self.err);
        }
        if (self.state != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustyIpcConnectEndFtraceEventWire.STATE_WIRE) + gremlin.sizes.sizeI32(self.state);
        }
        return res;
    }
    pub fn encode(self: *const TrustyIpcConnectEndFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TrustyIpcConnectEndFtraceEvent, target: *gremlin.Writer) void {
        if (self.chan != 0) {
            target.appendUint32(TrustyIpcConnectEndFtraceEventWire.CHAN_WIRE, self.chan);
        }
        if (self.err != 0) {
            target.appendInt32(TrustyIpcConnectEndFtraceEventWire.ERR_WIRE, self.err);
        }
        if (self.state != 0) {
            target.appendInt32(TrustyIpcConnectEndFtraceEventWire.STATE_WIRE, self.state);
        }
    }
};
pub const TrustyIpcConnectEndFtraceEventReader = struct {
    buf: gremlin.Reader,
    _chan: u32 = 0,
    _err: i32 = 0,
    _state: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!TrustyIpcConnectEndFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = TrustyIpcConnectEndFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TrustyIpcConnectEndFtraceEventWire.CHAN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._chan = result.value;
                },
                TrustyIpcConnectEndFtraceEventWire.ERR_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._err = result.value;
                },
                TrustyIpcConnectEndFtraceEventWire.STATE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._state = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getChan(self: *const TrustyIpcConnectEndFtraceEventReader) u32 {
        return self._chan;
    }
    pub inline fn getErr(self: *const TrustyIpcConnectEndFtraceEventReader) i32 {
        return self._err;
    }
    pub inline fn getState(self: *const TrustyIpcConnectEndFtraceEventReader) i32 {
        return self._state;
    }
};
const TrustyIpcWriteFtraceEventWire = struct {
    const BUF_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const CHAN_WIRE: gremlin.ProtoWireNumber = 2;
    const KIND_SHM_WIRE: gremlin.ProtoWireNumber = 3;
    const LEN_OR_ERR_WIRE: gremlin.ProtoWireNumber = 4;
    const SHM_CNT_WIRE: gremlin.ProtoWireNumber = 5;
    const SRV_NAME_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const TrustyIpcWriteFtraceEvent = struct {
    // fields
    buf_id: u64 = 0,
    chan: u32 = 0,
    kind_shm: i32 = 0,
    len_or_err: i32 = 0,
    shm_cnt: u64 = 0,
    srv_name: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const TrustyIpcWriteFtraceEvent) usize {
        var res: usize = 0;
        if (self.buf_id != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustyIpcWriteFtraceEventWire.BUF_ID_WIRE) + gremlin.sizes.sizeU64(self.buf_id);
        }
        if (self.chan != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustyIpcWriteFtraceEventWire.CHAN_WIRE) + gremlin.sizes.sizeU32(self.chan);
        }
        if (self.kind_shm != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustyIpcWriteFtraceEventWire.KIND_SHM_WIRE) + gremlin.sizes.sizeI32(self.kind_shm);
        }
        if (self.len_or_err != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustyIpcWriteFtraceEventWire.LEN_OR_ERR_WIRE) + gremlin.sizes.sizeI32(self.len_or_err);
        }
        if (self.shm_cnt != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustyIpcWriteFtraceEventWire.SHM_CNT_WIRE) + gremlin.sizes.sizeU64(self.shm_cnt);
        }
        if (self.srv_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TrustyIpcWriteFtraceEventWire.SRV_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const TrustyIpcWriteFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TrustyIpcWriteFtraceEvent, target: *gremlin.Writer) void {
        if (self.buf_id != 0) {
            target.appendUint64(TrustyIpcWriteFtraceEventWire.BUF_ID_WIRE, self.buf_id);
        }
        if (self.chan != 0) {
            target.appendUint32(TrustyIpcWriteFtraceEventWire.CHAN_WIRE, self.chan);
        }
        if (self.kind_shm != 0) {
            target.appendInt32(TrustyIpcWriteFtraceEventWire.KIND_SHM_WIRE, self.kind_shm);
        }
        if (self.len_or_err != 0) {
            target.appendInt32(TrustyIpcWriteFtraceEventWire.LEN_OR_ERR_WIRE, self.len_or_err);
        }
        if (self.shm_cnt != 0) {
            target.appendUint64(TrustyIpcWriteFtraceEventWire.SHM_CNT_WIRE, self.shm_cnt);
        }
        if (self.srv_name) |v| {
            if (v.len > 0) {
                target.appendBytes(TrustyIpcWriteFtraceEventWire.SRV_NAME_WIRE, v);
            }
        }
    }
};
pub const TrustyIpcWriteFtraceEventReader = struct {
    buf: gremlin.Reader,
    _buf_id: u64 = 0,
    _chan: u32 = 0,
    _kind_shm: i32 = 0,
    _len_or_err: i32 = 0,
    _shm_cnt: u64 = 0,
    _srv_name: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!TrustyIpcWriteFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = TrustyIpcWriteFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TrustyIpcWriteFtraceEventWire.BUF_ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._buf_id = result.value;
                },
                TrustyIpcWriteFtraceEventWire.CHAN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._chan = result.value;
                },
                TrustyIpcWriteFtraceEventWire.KIND_SHM_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._kind_shm = result.value;
                },
                TrustyIpcWriteFtraceEventWire.LEN_OR_ERR_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._len_or_err = result.value;
                },
                TrustyIpcWriteFtraceEventWire.SHM_CNT_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._shm_cnt = result.value;
                },
                TrustyIpcWriteFtraceEventWire.SRV_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._srv_name = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getBufId(self: *const TrustyIpcWriteFtraceEventReader) u64 {
        return self._buf_id;
    }
    pub inline fn getChan(self: *const TrustyIpcWriteFtraceEventReader) u32 {
        return self._chan;
    }
    pub inline fn getKindShm(self: *const TrustyIpcWriteFtraceEventReader) i32 {
        return self._kind_shm;
    }
    pub inline fn getLenOrErr(self: *const TrustyIpcWriteFtraceEventReader) i32 {
        return self._len_or_err;
    }
    pub inline fn getShmCnt(self: *const TrustyIpcWriteFtraceEventReader) u64 {
        return self._shm_cnt;
    }
    pub inline fn getSrvName(self: *const TrustyIpcWriteFtraceEventReader) []const u8 {
        return self._srv_name orelse &[_]u8{};
    }
};
const TrustyIpcPollFtraceEventWire = struct {
    const CHAN_WIRE: gremlin.ProtoWireNumber = 1;
    const POLL_MASK_WIRE: gremlin.ProtoWireNumber = 2;
    const SRV_NAME_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const TrustyIpcPollFtraceEvent = struct {
    // fields
    chan: u32 = 0,
    poll_mask: u32 = 0,
    srv_name: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const TrustyIpcPollFtraceEvent) usize {
        var res: usize = 0;
        if (self.chan != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustyIpcPollFtraceEventWire.CHAN_WIRE) + gremlin.sizes.sizeU32(self.chan);
        }
        if (self.poll_mask != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustyIpcPollFtraceEventWire.POLL_MASK_WIRE) + gremlin.sizes.sizeU32(self.poll_mask);
        }
        if (self.srv_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TrustyIpcPollFtraceEventWire.SRV_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const TrustyIpcPollFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TrustyIpcPollFtraceEvent, target: *gremlin.Writer) void {
        if (self.chan != 0) {
            target.appendUint32(TrustyIpcPollFtraceEventWire.CHAN_WIRE, self.chan);
        }
        if (self.poll_mask != 0) {
            target.appendUint32(TrustyIpcPollFtraceEventWire.POLL_MASK_WIRE, self.poll_mask);
        }
        if (self.srv_name) |v| {
            if (v.len > 0) {
                target.appendBytes(TrustyIpcPollFtraceEventWire.SRV_NAME_WIRE, v);
            }
        }
    }
};
pub const TrustyIpcPollFtraceEventReader = struct {
    buf: gremlin.Reader,
    _chan: u32 = 0,
    _poll_mask: u32 = 0,
    _srv_name: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!TrustyIpcPollFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = TrustyIpcPollFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TrustyIpcPollFtraceEventWire.CHAN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._chan = result.value;
                },
                TrustyIpcPollFtraceEventWire.POLL_MASK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._poll_mask = result.value;
                },
                TrustyIpcPollFtraceEventWire.SRV_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._srv_name = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getChan(self: *const TrustyIpcPollFtraceEventReader) u32 {
        return self._chan;
    }
    pub inline fn getPollMask(self: *const TrustyIpcPollFtraceEventReader) u32 {
        return self._poll_mask;
    }
    pub inline fn getSrvName(self: *const TrustyIpcPollFtraceEventReader) []const u8 {
        return self._srv_name orelse &[_]u8{};
    }
};
const TrustyIpcReadFtraceEventWire = struct {
    const CHAN_WIRE: gremlin.ProtoWireNumber = 1;
    const SRV_NAME_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const TrustyIpcReadFtraceEvent = struct {
    // fields
    chan: u32 = 0,
    srv_name: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const TrustyIpcReadFtraceEvent) usize {
        var res: usize = 0;
        if (self.chan != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustyIpcReadFtraceEventWire.CHAN_WIRE) + gremlin.sizes.sizeU32(self.chan);
        }
        if (self.srv_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TrustyIpcReadFtraceEventWire.SRV_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const TrustyIpcReadFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TrustyIpcReadFtraceEvent, target: *gremlin.Writer) void {
        if (self.chan != 0) {
            target.appendUint32(TrustyIpcReadFtraceEventWire.CHAN_WIRE, self.chan);
        }
        if (self.srv_name) |v| {
            if (v.len > 0) {
                target.appendBytes(TrustyIpcReadFtraceEventWire.SRV_NAME_WIRE, v);
            }
        }
    }
};
pub const TrustyIpcReadFtraceEventReader = struct {
    buf: gremlin.Reader,
    _chan: u32 = 0,
    _srv_name: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!TrustyIpcReadFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = TrustyIpcReadFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TrustyIpcReadFtraceEventWire.CHAN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._chan = result.value;
                },
                TrustyIpcReadFtraceEventWire.SRV_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._srv_name = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getChan(self: *const TrustyIpcReadFtraceEventReader) u32 {
        return self._chan;
    }
    pub inline fn getSrvName(self: *const TrustyIpcReadFtraceEventReader) []const u8 {
        return self._srv_name orelse &[_]u8{};
    }
};
const TrustyIpcReadEndFtraceEventWire = struct {
    const BUF_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const CHAN_WIRE: gremlin.ProtoWireNumber = 2;
    const LEN_OR_ERR_WIRE: gremlin.ProtoWireNumber = 3;
    const SHM_CNT_WIRE: gremlin.ProtoWireNumber = 4;
    const SRV_NAME_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const TrustyIpcReadEndFtraceEvent = struct {
    // fields
    buf_id: u64 = 0,
    chan: u32 = 0,
    len_or_err: i32 = 0,
    shm_cnt: u64 = 0,
    srv_name: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const TrustyIpcReadEndFtraceEvent) usize {
        var res: usize = 0;
        if (self.buf_id != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustyIpcReadEndFtraceEventWire.BUF_ID_WIRE) + gremlin.sizes.sizeU64(self.buf_id);
        }
        if (self.chan != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustyIpcReadEndFtraceEventWire.CHAN_WIRE) + gremlin.sizes.sizeU32(self.chan);
        }
        if (self.len_or_err != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustyIpcReadEndFtraceEventWire.LEN_OR_ERR_WIRE) + gremlin.sizes.sizeI32(self.len_or_err);
        }
        if (self.shm_cnt != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustyIpcReadEndFtraceEventWire.SHM_CNT_WIRE) + gremlin.sizes.sizeU64(self.shm_cnt);
        }
        if (self.srv_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TrustyIpcReadEndFtraceEventWire.SRV_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const TrustyIpcReadEndFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TrustyIpcReadEndFtraceEvent, target: *gremlin.Writer) void {
        if (self.buf_id != 0) {
            target.appendUint64(TrustyIpcReadEndFtraceEventWire.BUF_ID_WIRE, self.buf_id);
        }
        if (self.chan != 0) {
            target.appendUint32(TrustyIpcReadEndFtraceEventWire.CHAN_WIRE, self.chan);
        }
        if (self.len_or_err != 0) {
            target.appendInt32(TrustyIpcReadEndFtraceEventWire.LEN_OR_ERR_WIRE, self.len_or_err);
        }
        if (self.shm_cnt != 0) {
            target.appendUint64(TrustyIpcReadEndFtraceEventWire.SHM_CNT_WIRE, self.shm_cnt);
        }
        if (self.srv_name) |v| {
            if (v.len > 0) {
                target.appendBytes(TrustyIpcReadEndFtraceEventWire.SRV_NAME_WIRE, v);
            }
        }
    }
};
pub const TrustyIpcReadEndFtraceEventReader = struct {
    buf: gremlin.Reader,
    _buf_id: u64 = 0,
    _chan: u32 = 0,
    _len_or_err: i32 = 0,
    _shm_cnt: u64 = 0,
    _srv_name: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!TrustyIpcReadEndFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = TrustyIpcReadEndFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TrustyIpcReadEndFtraceEventWire.BUF_ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._buf_id = result.value;
                },
                TrustyIpcReadEndFtraceEventWire.CHAN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._chan = result.value;
                },
                TrustyIpcReadEndFtraceEventWire.LEN_OR_ERR_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._len_or_err = result.value;
                },
                TrustyIpcReadEndFtraceEventWire.SHM_CNT_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._shm_cnt = result.value;
                },
                TrustyIpcReadEndFtraceEventWire.SRV_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._srv_name = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getBufId(self: *const TrustyIpcReadEndFtraceEventReader) u64 {
        return self._buf_id;
    }
    pub inline fn getChan(self: *const TrustyIpcReadEndFtraceEventReader) u32 {
        return self._chan;
    }
    pub inline fn getLenOrErr(self: *const TrustyIpcReadEndFtraceEventReader) i32 {
        return self._len_or_err;
    }
    pub inline fn getShmCnt(self: *const TrustyIpcReadEndFtraceEventReader) u64 {
        return self._shm_cnt;
    }
    pub inline fn getSrvName(self: *const TrustyIpcReadEndFtraceEventReader) []const u8 {
        return self._srv_name orelse &[_]u8{};
    }
};
const TrustyIpcRxFtraceEventWire = struct {
    const BUF_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const CHAN_WIRE: gremlin.ProtoWireNumber = 2;
    const SRV_NAME_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const TrustyIpcRxFtraceEvent = struct {
    // fields
    buf_id: u64 = 0,
    chan: u32 = 0,
    srv_name: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const TrustyIpcRxFtraceEvent) usize {
        var res: usize = 0;
        if (self.buf_id != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustyIpcRxFtraceEventWire.BUF_ID_WIRE) + gremlin.sizes.sizeU64(self.buf_id);
        }
        if (self.chan != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustyIpcRxFtraceEventWire.CHAN_WIRE) + gremlin.sizes.sizeU32(self.chan);
        }
        if (self.srv_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TrustyIpcRxFtraceEventWire.SRV_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const TrustyIpcRxFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TrustyIpcRxFtraceEvent, target: *gremlin.Writer) void {
        if (self.buf_id != 0) {
            target.appendUint64(TrustyIpcRxFtraceEventWire.BUF_ID_WIRE, self.buf_id);
        }
        if (self.chan != 0) {
            target.appendUint32(TrustyIpcRxFtraceEventWire.CHAN_WIRE, self.chan);
        }
        if (self.srv_name) |v| {
            if (v.len > 0) {
                target.appendBytes(TrustyIpcRxFtraceEventWire.SRV_NAME_WIRE, v);
            }
        }
    }
};
pub const TrustyIpcRxFtraceEventReader = struct {
    buf: gremlin.Reader,
    _buf_id: u64 = 0,
    _chan: u32 = 0,
    _srv_name: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!TrustyIpcRxFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = TrustyIpcRxFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TrustyIpcRxFtraceEventWire.BUF_ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._buf_id = result.value;
                },
                TrustyIpcRxFtraceEventWire.CHAN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._chan = result.value;
                },
                TrustyIpcRxFtraceEventWire.SRV_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._srv_name = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getBufId(self: *const TrustyIpcRxFtraceEventReader) u64 {
        return self._buf_id;
    }
    pub inline fn getChan(self: *const TrustyIpcRxFtraceEventReader) u32 {
        return self._chan;
    }
    pub inline fn getSrvName(self: *const TrustyIpcRxFtraceEventReader) []const u8 {
        return self._srv_name orelse &[_]u8{};
    }
};
const TrustyEnqueueNopFtraceEventWire = struct {
    const ARG1_WIRE: gremlin.ProtoWireNumber = 1;
    const ARG2_WIRE: gremlin.ProtoWireNumber = 2;
    const ARG3_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const TrustyEnqueueNopFtraceEvent = struct {
    // fields
    arg1: u32 = 0,
    arg2: u32 = 0,
    arg3: u32 = 0,
    pub fn calcProtobufSize(self: *const TrustyEnqueueNopFtraceEvent) usize {
        var res: usize = 0;
        if (self.arg1 != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustyEnqueueNopFtraceEventWire.ARG1_WIRE) + gremlin.sizes.sizeU32(self.arg1);
        }
        if (self.arg2 != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustyEnqueueNopFtraceEventWire.ARG2_WIRE) + gremlin.sizes.sizeU32(self.arg2);
        }
        if (self.arg3 != 0) {
            res += gremlin.sizes.sizeWireNumber(TrustyEnqueueNopFtraceEventWire.ARG3_WIRE) + gremlin.sizes.sizeU32(self.arg3);
        }
        return res;
    }
    pub fn encode(self: *const TrustyEnqueueNopFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TrustyEnqueueNopFtraceEvent, target: *gremlin.Writer) void {
        if (self.arg1 != 0) {
            target.appendUint32(TrustyEnqueueNopFtraceEventWire.ARG1_WIRE, self.arg1);
        }
        if (self.arg2 != 0) {
            target.appendUint32(TrustyEnqueueNopFtraceEventWire.ARG2_WIRE, self.arg2);
        }
        if (self.arg3 != 0) {
            target.appendUint32(TrustyEnqueueNopFtraceEventWire.ARG3_WIRE, self.arg3);
        }
    }
};
pub const TrustyEnqueueNopFtraceEventReader = struct {
    buf: gremlin.Reader,
    _arg1: u32 = 0,
    _arg2: u32 = 0,
    _arg3: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!TrustyEnqueueNopFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = TrustyEnqueueNopFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TrustyEnqueueNopFtraceEventWire.ARG1_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._arg1 = result.value;
                },
                TrustyEnqueueNopFtraceEventWire.ARG2_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._arg2 = result.value;
                },
                TrustyEnqueueNopFtraceEventWire.ARG3_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._arg3 = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getArg1(self: *const TrustyEnqueueNopFtraceEventReader) u32 {
        return self._arg1;
    }
    pub inline fn getArg2(self: *const TrustyEnqueueNopFtraceEventReader) u32 {
        return self._arg2;
    }
    pub inline fn getArg3(self: *const TrustyEnqueueNopFtraceEventReader) u32 {
        return self._arg3;
    }
};
