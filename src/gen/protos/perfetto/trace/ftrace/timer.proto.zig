// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const HrtimerStartFtraceEventWire = struct {
    const HRTIMER_WIRE: gremlin.ProtoWireNumber = 1;
    const FUNCTION_WIRE: gremlin.ProtoWireNumber = 2;
    const EXPIRES_WIRE: gremlin.ProtoWireNumber = 3;
    const SOFTEXPIRES_WIRE: gremlin.ProtoWireNumber = 4;
    const MODE_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const HrtimerStartFtraceEvent = struct {
    // fields
    hrtimer: u64 = 0,
    function: u64 = 0,
    expires: i64 = 0,
    softexpires: i64 = 0,
    mode: u32 = 0,
    pub fn calcProtobufSize(self: *const HrtimerStartFtraceEvent) usize {
        var res: usize = 0;
        if (self.hrtimer != 0) {
            res += gremlin.sizes.sizeWireNumber(HrtimerStartFtraceEventWire.HRTIMER_WIRE) + gremlin.sizes.sizeU64(self.hrtimer);
        }
        if (self.function != 0) {
            res += gremlin.sizes.sizeWireNumber(HrtimerStartFtraceEventWire.FUNCTION_WIRE) + gremlin.sizes.sizeU64(self.function);
        }
        if (self.expires != 0) {
            res += gremlin.sizes.sizeWireNumber(HrtimerStartFtraceEventWire.EXPIRES_WIRE) + gremlin.sizes.sizeI64(self.expires);
        }
        if (self.softexpires != 0) {
            res += gremlin.sizes.sizeWireNumber(HrtimerStartFtraceEventWire.SOFTEXPIRES_WIRE) + gremlin.sizes.sizeI64(self.softexpires);
        }
        if (self.mode != 0) {
            res += gremlin.sizes.sizeWireNumber(HrtimerStartFtraceEventWire.MODE_WIRE) + gremlin.sizes.sizeU32(self.mode);
        }
        return res;
    }
    pub fn encode(self: *const HrtimerStartFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const HrtimerStartFtraceEvent, target: *gremlin.Writer) void {
        if (self.hrtimer != 0) {
            target.appendUint64(HrtimerStartFtraceEventWire.HRTIMER_WIRE, self.hrtimer);
        }
        if (self.function != 0) {
            target.appendUint64(HrtimerStartFtraceEventWire.FUNCTION_WIRE, self.function);
        }
        if (self.expires != 0) {
            target.appendInt64(HrtimerStartFtraceEventWire.EXPIRES_WIRE, self.expires);
        }
        if (self.softexpires != 0) {
            target.appendInt64(HrtimerStartFtraceEventWire.SOFTEXPIRES_WIRE, self.softexpires);
        }
        if (self.mode != 0) {
            target.appendUint32(HrtimerStartFtraceEventWire.MODE_WIRE, self.mode);
        }
    }
};
pub const HrtimerStartFtraceEventReader = struct {
    buf: gremlin.Reader,
    _hrtimer: u64 = 0,
    _function: u64 = 0,
    _expires: i64 = 0,
    _softexpires: i64 = 0,
    _mode: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!HrtimerStartFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = HrtimerStartFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                HrtimerStartFtraceEventWire.HRTIMER_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._hrtimer = result.value;
                },
                HrtimerStartFtraceEventWire.FUNCTION_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._function = result.value;
                },
                HrtimerStartFtraceEventWire.EXPIRES_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._expires = result.value;
                },
                HrtimerStartFtraceEventWire.SOFTEXPIRES_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._softexpires = result.value;
                },
                HrtimerStartFtraceEventWire.MODE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._mode = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getHrtimer(self: *const HrtimerStartFtraceEventReader) u64 {
        return self._hrtimer;
    }
    pub inline fn getFunction(self: *const HrtimerStartFtraceEventReader) u64 {
        return self._function;
    }
    pub inline fn getExpires(self: *const HrtimerStartFtraceEventReader) i64 {
        return self._expires;
    }
    pub inline fn getSoftexpires(self: *const HrtimerStartFtraceEventReader) i64 {
        return self._softexpires;
    }
    pub inline fn getMode(self: *const HrtimerStartFtraceEventReader) u32 {
        return self._mode;
    }
};
const HrtimerCancelFtraceEventWire = struct {
    const HRTIMER_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const HrtimerCancelFtraceEvent = struct {
    // fields
    hrtimer: u64 = 0,
    pub fn calcProtobufSize(self: *const HrtimerCancelFtraceEvent) usize {
        var res: usize = 0;
        if (self.hrtimer != 0) {
            res += gremlin.sizes.sizeWireNumber(HrtimerCancelFtraceEventWire.HRTIMER_WIRE) + gremlin.sizes.sizeU64(self.hrtimer);
        }
        return res;
    }
    pub fn encode(self: *const HrtimerCancelFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const HrtimerCancelFtraceEvent, target: *gremlin.Writer) void {
        if (self.hrtimer != 0) {
            target.appendUint64(HrtimerCancelFtraceEventWire.HRTIMER_WIRE, self.hrtimer);
        }
    }
};
pub const HrtimerCancelFtraceEventReader = struct {
    buf: gremlin.Reader,
    _hrtimer: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!HrtimerCancelFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = HrtimerCancelFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                HrtimerCancelFtraceEventWire.HRTIMER_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._hrtimer = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getHrtimer(self: *const HrtimerCancelFtraceEventReader) u64 {
        return self._hrtimer;
    }
};
const HrtimerExpireEntryFtraceEventWire = struct {
    const HRTIMER_WIRE: gremlin.ProtoWireNumber = 1;
    const NOW_WIRE: gremlin.ProtoWireNumber = 2;
    const FUNCTION_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const HrtimerExpireEntryFtraceEvent = struct {
    // fields
    hrtimer: u64 = 0,
    now: i64 = 0,
    function: u64 = 0,
    pub fn calcProtobufSize(self: *const HrtimerExpireEntryFtraceEvent) usize {
        var res: usize = 0;
        if (self.hrtimer != 0) {
            res += gremlin.sizes.sizeWireNumber(HrtimerExpireEntryFtraceEventWire.HRTIMER_WIRE) + gremlin.sizes.sizeU64(self.hrtimer);
        }
        if (self.now != 0) {
            res += gremlin.sizes.sizeWireNumber(HrtimerExpireEntryFtraceEventWire.NOW_WIRE) + gremlin.sizes.sizeI64(self.now);
        }
        if (self.function != 0) {
            res += gremlin.sizes.sizeWireNumber(HrtimerExpireEntryFtraceEventWire.FUNCTION_WIRE) + gremlin.sizes.sizeU64(self.function);
        }
        return res;
    }
    pub fn encode(self: *const HrtimerExpireEntryFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const HrtimerExpireEntryFtraceEvent, target: *gremlin.Writer) void {
        if (self.hrtimer != 0) {
            target.appendUint64(HrtimerExpireEntryFtraceEventWire.HRTIMER_WIRE, self.hrtimer);
        }
        if (self.now != 0) {
            target.appendInt64(HrtimerExpireEntryFtraceEventWire.NOW_WIRE, self.now);
        }
        if (self.function != 0) {
            target.appendUint64(HrtimerExpireEntryFtraceEventWire.FUNCTION_WIRE, self.function);
        }
    }
};
pub const HrtimerExpireEntryFtraceEventReader = struct {
    buf: gremlin.Reader,
    _hrtimer: u64 = 0,
    _now: i64 = 0,
    _function: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!HrtimerExpireEntryFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = HrtimerExpireEntryFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                HrtimerExpireEntryFtraceEventWire.HRTIMER_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._hrtimer = result.value;
                },
                HrtimerExpireEntryFtraceEventWire.NOW_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._now = result.value;
                },
                HrtimerExpireEntryFtraceEventWire.FUNCTION_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._function = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getHrtimer(self: *const HrtimerExpireEntryFtraceEventReader) u64 {
        return self._hrtimer;
    }
    pub inline fn getNow(self: *const HrtimerExpireEntryFtraceEventReader) i64 {
        return self._now;
    }
    pub inline fn getFunction(self: *const HrtimerExpireEntryFtraceEventReader) u64 {
        return self._function;
    }
};
const HrtimerExpireExitFtraceEventWire = struct {
    const HRTIMER_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const HrtimerExpireExitFtraceEvent = struct {
    // fields
    hrtimer: u64 = 0,
    pub fn calcProtobufSize(self: *const HrtimerExpireExitFtraceEvent) usize {
        var res: usize = 0;
        if (self.hrtimer != 0) {
            res += gremlin.sizes.sizeWireNumber(HrtimerExpireExitFtraceEventWire.HRTIMER_WIRE) + gremlin.sizes.sizeU64(self.hrtimer);
        }
        return res;
    }
    pub fn encode(self: *const HrtimerExpireExitFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const HrtimerExpireExitFtraceEvent, target: *gremlin.Writer) void {
        if (self.hrtimer != 0) {
            target.appendUint64(HrtimerExpireExitFtraceEventWire.HRTIMER_WIRE, self.hrtimer);
        }
    }
};
pub const HrtimerExpireExitFtraceEventReader = struct {
    buf: gremlin.Reader,
    _hrtimer: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!HrtimerExpireExitFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = HrtimerExpireExitFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                HrtimerExpireExitFtraceEventWire.HRTIMER_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._hrtimer = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getHrtimer(self: *const HrtimerExpireExitFtraceEventReader) u64 {
        return self._hrtimer;
    }
};
const TimerStartFtraceEventWire = struct {
    const TIMER_WIRE: gremlin.ProtoWireNumber = 1;
    const FUNCTION_WIRE: gremlin.ProtoWireNumber = 2;
    const EXPIRES_WIRE: gremlin.ProtoWireNumber = 3;
    const NOW_WIRE: gremlin.ProtoWireNumber = 4;
    const DEFERRABLE_WIRE: gremlin.ProtoWireNumber = 5;
    const FLAGS_WIRE: gremlin.ProtoWireNumber = 6;
    const BUCKET_EXPIRY_WIRE: gremlin.ProtoWireNumber = 7;
};
pub const TimerStartFtraceEvent = struct {
    // fields
    timer: u64 = 0,
    function: u64 = 0,
    expires: u64 = 0,
    now: u64 = 0,
    deferrable: u32 = 0,
    flags: u32 = 0,
    bucket_expiry: u64 = 0,
    pub fn calcProtobufSize(self: *const TimerStartFtraceEvent) usize {
        var res: usize = 0;
        if (self.timer != 0) {
            res += gremlin.sizes.sizeWireNumber(TimerStartFtraceEventWire.TIMER_WIRE) + gremlin.sizes.sizeU64(self.timer);
        }
        if (self.function != 0) {
            res += gremlin.sizes.sizeWireNumber(TimerStartFtraceEventWire.FUNCTION_WIRE) + gremlin.sizes.sizeU64(self.function);
        }
        if (self.expires != 0) {
            res += gremlin.sizes.sizeWireNumber(TimerStartFtraceEventWire.EXPIRES_WIRE) + gremlin.sizes.sizeU64(self.expires);
        }
        if (self.now != 0) {
            res += gremlin.sizes.sizeWireNumber(TimerStartFtraceEventWire.NOW_WIRE) + gremlin.sizes.sizeU64(self.now);
        }
        if (self.deferrable != 0) {
            res += gremlin.sizes.sizeWireNumber(TimerStartFtraceEventWire.DEFERRABLE_WIRE) + gremlin.sizes.sizeU32(self.deferrable);
        }
        if (self.flags != 0) {
            res += gremlin.sizes.sizeWireNumber(TimerStartFtraceEventWire.FLAGS_WIRE) + gremlin.sizes.sizeU32(self.flags);
        }
        if (self.bucket_expiry != 0) {
            res += gremlin.sizes.sizeWireNumber(TimerStartFtraceEventWire.BUCKET_EXPIRY_WIRE) + gremlin.sizes.sizeU64(self.bucket_expiry);
        }
        return res;
    }
    pub fn encode(self: *const TimerStartFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TimerStartFtraceEvent, target: *gremlin.Writer) void {
        if (self.timer != 0) {
            target.appendUint64(TimerStartFtraceEventWire.TIMER_WIRE, self.timer);
        }
        if (self.function != 0) {
            target.appendUint64(TimerStartFtraceEventWire.FUNCTION_WIRE, self.function);
        }
        if (self.expires != 0) {
            target.appendUint64(TimerStartFtraceEventWire.EXPIRES_WIRE, self.expires);
        }
        if (self.now != 0) {
            target.appendUint64(TimerStartFtraceEventWire.NOW_WIRE, self.now);
        }
        if (self.deferrable != 0) {
            target.appendUint32(TimerStartFtraceEventWire.DEFERRABLE_WIRE, self.deferrable);
        }
        if (self.flags != 0) {
            target.appendUint32(TimerStartFtraceEventWire.FLAGS_WIRE, self.flags);
        }
        if (self.bucket_expiry != 0) {
            target.appendUint64(TimerStartFtraceEventWire.BUCKET_EXPIRY_WIRE, self.bucket_expiry);
        }
    }
};
pub const TimerStartFtraceEventReader = struct {
    buf: gremlin.Reader,
    _timer: u64 = 0,
    _function: u64 = 0,
    _expires: u64 = 0,
    _now: u64 = 0,
    _deferrable: u32 = 0,
    _flags: u32 = 0,
    _bucket_expiry: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!TimerStartFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = TimerStartFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TimerStartFtraceEventWire.TIMER_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._timer = result.value;
                },
                TimerStartFtraceEventWire.FUNCTION_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._function = result.value;
                },
                TimerStartFtraceEventWire.EXPIRES_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._expires = result.value;
                },
                TimerStartFtraceEventWire.NOW_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._now = result.value;
                },
                TimerStartFtraceEventWire.DEFERRABLE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._deferrable = result.value;
                },
                TimerStartFtraceEventWire.FLAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._flags = result.value;
                },
                TimerStartFtraceEventWire.BUCKET_EXPIRY_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._bucket_expiry = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getTimer(self: *const TimerStartFtraceEventReader) u64 {
        return self._timer;
    }
    pub inline fn getFunction(self: *const TimerStartFtraceEventReader) u64 {
        return self._function;
    }
    pub inline fn getExpires(self: *const TimerStartFtraceEventReader) u64 {
        return self._expires;
    }
    pub inline fn getNow(self: *const TimerStartFtraceEventReader) u64 {
        return self._now;
    }
    pub inline fn getDeferrable(self: *const TimerStartFtraceEventReader) u32 {
        return self._deferrable;
    }
    pub inline fn getFlags(self: *const TimerStartFtraceEventReader) u32 {
        return self._flags;
    }
    pub inline fn getBucketExpiry(self: *const TimerStartFtraceEventReader) u64 {
        return self._bucket_expiry;
    }
};
const TimerCancelFtraceEventWire = struct {
    const TIMER_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const TimerCancelFtraceEvent = struct {
    // fields
    timer: u64 = 0,
    pub fn calcProtobufSize(self: *const TimerCancelFtraceEvent) usize {
        var res: usize = 0;
        if (self.timer != 0) {
            res += gremlin.sizes.sizeWireNumber(TimerCancelFtraceEventWire.TIMER_WIRE) + gremlin.sizes.sizeU64(self.timer);
        }
        return res;
    }
    pub fn encode(self: *const TimerCancelFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TimerCancelFtraceEvent, target: *gremlin.Writer) void {
        if (self.timer != 0) {
            target.appendUint64(TimerCancelFtraceEventWire.TIMER_WIRE, self.timer);
        }
    }
};
pub const TimerCancelFtraceEventReader = struct {
    buf: gremlin.Reader,
    _timer: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!TimerCancelFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = TimerCancelFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TimerCancelFtraceEventWire.TIMER_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._timer = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getTimer(self: *const TimerCancelFtraceEventReader) u64 {
        return self._timer;
    }
};
const TimerExpireEntryFtraceEventWire = struct {
    const TIMER_WIRE: gremlin.ProtoWireNumber = 1;
    const NOW_WIRE: gremlin.ProtoWireNumber = 2;
    const FUNCTION_WIRE: gremlin.ProtoWireNumber = 3;
    const BASECLK_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const TimerExpireEntryFtraceEvent = struct {
    // fields
    timer: u64 = 0,
    now: u64 = 0,
    function: u64 = 0,
    baseclk: u64 = 0,
    pub fn calcProtobufSize(self: *const TimerExpireEntryFtraceEvent) usize {
        var res: usize = 0;
        if (self.timer != 0) {
            res += gremlin.sizes.sizeWireNumber(TimerExpireEntryFtraceEventWire.TIMER_WIRE) + gremlin.sizes.sizeU64(self.timer);
        }
        if (self.now != 0) {
            res += gremlin.sizes.sizeWireNumber(TimerExpireEntryFtraceEventWire.NOW_WIRE) + gremlin.sizes.sizeU64(self.now);
        }
        if (self.function != 0) {
            res += gremlin.sizes.sizeWireNumber(TimerExpireEntryFtraceEventWire.FUNCTION_WIRE) + gremlin.sizes.sizeU64(self.function);
        }
        if (self.baseclk != 0) {
            res += gremlin.sizes.sizeWireNumber(TimerExpireEntryFtraceEventWire.BASECLK_WIRE) + gremlin.sizes.sizeU64(self.baseclk);
        }
        return res;
    }
    pub fn encode(self: *const TimerExpireEntryFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TimerExpireEntryFtraceEvent, target: *gremlin.Writer) void {
        if (self.timer != 0) {
            target.appendUint64(TimerExpireEntryFtraceEventWire.TIMER_WIRE, self.timer);
        }
        if (self.now != 0) {
            target.appendUint64(TimerExpireEntryFtraceEventWire.NOW_WIRE, self.now);
        }
        if (self.function != 0) {
            target.appendUint64(TimerExpireEntryFtraceEventWire.FUNCTION_WIRE, self.function);
        }
        if (self.baseclk != 0) {
            target.appendUint64(TimerExpireEntryFtraceEventWire.BASECLK_WIRE, self.baseclk);
        }
    }
};
pub const TimerExpireEntryFtraceEventReader = struct {
    buf: gremlin.Reader,
    _timer: u64 = 0,
    _now: u64 = 0,
    _function: u64 = 0,
    _baseclk: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!TimerExpireEntryFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = TimerExpireEntryFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TimerExpireEntryFtraceEventWire.TIMER_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._timer = result.value;
                },
                TimerExpireEntryFtraceEventWire.NOW_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._now = result.value;
                },
                TimerExpireEntryFtraceEventWire.FUNCTION_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._function = result.value;
                },
                TimerExpireEntryFtraceEventWire.BASECLK_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._baseclk = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getTimer(self: *const TimerExpireEntryFtraceEventReader) u64 {
        return self._timer;
    }
    pub inline fn getNow(self: *const TimerExpireEntryFtraceEventReader) u64 {
        return self._now;
    }
    pub inline fn getFunction(self: *const TimerExpireEntryFtraceEventReader) u64 {
        return self._function;
    }
    pub inline fn getBaseclk(self: *const TimerExpireEntryFtraceEventReader) u64 {
        return self._baseclk;
    }
};
const TimerExpireExitFtraceEventWire = struct {
    const TIMER_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const TimerExpireExitFtraceEvent = struct {
    // fields
    timer: u64 = 0,
    pub fn calcProtobufSize(self: *const TimerExpireExitFtraceEvent) usize {
        var res: usize = 0;
        if (self.timer != 0) {
            res += gremlin.sizes.sizeWireNumber(TimerExpireExitFtraceEventWire.TIMER_WIRE) + gremlin.sizes.sizeU64(self.timer);
        }
        return res;
    }
    pub fn encode(self: *const TimerExpireExitFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TimerExpireExitFtraceEvent, target: *gremlin.Writer) void {
        if (self.timer != 0) {
            target.appendUint64(TimerExpireExitFtraceEventWire.TIMER_WIRE, self.timer);
        }
    }
};
pub const TimerExpireExitFtraceEventReader = struct {
    buf: gremlin.Reader,
    _timer: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!TimerExpireExitFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = TimerExpireExitFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TimerExpireExitFtraceEventWire.TIMER_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._timer = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getTimer(self: *const TimerExpireExitFtraceEventReader) u64 {
        return self._timer;
    }
};
