// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const KgslGpuFrequencyFtraceEventWire = struct {
    const GPU_FREQ_WIRE: gremlin.ProtoWireNumber = 1;
    const GPU_ID_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const KgslGpuFrequencyFtraceEvent = struct {
    // fields
    gpu_freq: u32 = 0,
    gpu_id: u32 = 0,
    pub fn calcProtobufSize(self: *const KgslGpuFrequencyFtraceEvent) usize {
        var res: usize = 0;
        if (self.gpu_freq != 0) {
            res += gremlin.sizes.sizeWireNumber(KgslGpuFrequencyFtraceEventWire.GPU_FREQ_WIRE) + gremlin.sizes.sizeU32(self.gpu_freq);
        }
        if (self.gpu_id != 0) {
            res += gremlin.sizes.sizeWireNumber(KgslGpuFrequencyFtraceEventWire.GPU_ID_WIRE) + gremlin.sizes.sizeU32(self.gpu_id);
        }
        return res;
    }
    pub fn encode(self: *const KgslGpuFrequencyFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const KgslGpuFrequencyFtraceEvent, target: *gremlin.Writer) void {
        if (self.gpu_freq != 0) {
            target.appendUint32(KgslGpuFrequencyFtraceEventWire.GPU_FREQ_WIRE, self.gpu_freq);
        }
        if (self.gpu_id != 0) {
            target.appendUint32(KgslGpuFrequencyFtraceEventWire.GPU_ID_WIRE, self.gpu_id);
        }
    }
};
pub const KgslGpuFrequencyFtraceEventReader = struct {
    buf: gremlin.Reader,
    _gpu_freq: u32 = 0,
    _gpu_id: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!KgslGpuFrequencyFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = KgslGpuFrequencyFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                KgslGpuFrequencyFtraceEventWire.GPU_FREQ_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._gpu_freq = result.value;
                },
                KgslGpuFrequencyFtraceEventWire.GPU_ID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._gpu_id = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getGpuFreq(self: *const KgslGpuFrequencyFtraceEventReader) u32 {
        return self._gpu_freq;
    }
    pub inline fn getGpuId(self: *const KgslGpuFrequencyFtraceEventReader) u32 {
        return self._gpu_id;
    }
};
const KgslAdrenoCmdbatchQueuedFtraceEventWire = struct {
    const ID_WIRE: gremlin.ProtoWireNumber = 1;
    const TIMESTAMP_WIRE: gremlin.ProtoWireNumber = 2;
    const QUEUED_WIRE: gremlin.ProtoWireNumber = 3;
    const FLAGS_WIRE: gremlin.ProtoWireNumber = 4;
    const PRIO_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const KgslAdrenoCmdbatchQueuedFtraceEvent = struct {
    // fields
    id: u32 = 0,
    timestamp: u32 = 0,
    queued: u32 = 0,
    flags: u32 = 0,
    prio: u32 = 0,
    pub fn calcProtobufSize(self: *const KgslAdrenoCmdbatchQueuedFtraceEvent) usize {
        var res: usize = 0;
        if (self.id != 0) {
            res += gremlin.sizes.sizeWireNumber(KgslAdrenoCmdbatchQueuedFtraceEventWire.ID_WIRE) + gremlin.sizes.sizeU32(self.id);
        }
        if (self.timestamp != 0) {
            res += gremlin.sizes.sizeWireNumber(KgslAdrenoCmdbatchQueuedFtraceEventWire.TIMESTAMP_WIRE) + gremlin.sizes.sizeU32(self.timestamp);
        }
        if (self.queued != 0) {
            res += gremlin.sizes.sizeWireNumber(KgslAdrenoCmdbatchQueuedFtraceEventWire.QUEUED_WIRE) + gremlin.sizes.sizeU32(self.queued);
        }
        if (self.flags != 0) {
            res += gremlin.sizes.sizeWireNumber(KgslAdrenoCmdbatchQueuedFtraceEventWire.FLAGS_WIRE) + gremlin.sizes.sizeU32(self.flags);
        }
        if (self.prio != 0) {
            res += gremlin.sizes.sizeWireNumber(KgslAdrenoCmdbatchQueuedFtraceEventWire.PRIO_WIRE) + gremlin.sizes.sizeU32(self.prio);
        }
        return res;
    }
    pub fn encode(self: *const KgslAdrenoCmdbatchQueuedFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const KgslAdrenoCmdbatchQueuedFtraceEvent, target: *gremlin.Writer) void {
        if (self.id != 0) {
            target.appendUint32(KgslAdrenoCmdbatchQueuedFtraceEventWire.ID_WIRE, self.id);
        }
        if (self.timestamp != 0) {
            target.appendUint32(KgslAdrenoCmdbatchQueuedFtraceEventWire.TIMESTAMP_WIRE, self.timestamp);
        }
        if (self.queued != 0) {
            target.appendUint32(KgslAdrenoCmdbatchQueuedFtraceEventWire.QUEUED_WIRE, self.queued);
        }
        if (self.flags != 0) {
            target.appendUint32(KgslAdrenoCmdbatchQueuedFtraceEventWire.FLAGS_WIRE, self.flags);
        }
        if (self.prio != 0) {
            target.appendUint32(KgslAdrenoCmdbatchQueuedFtraceEventWire.PRIO_WIRE, self.prio);
        }
    }
};
pub const KgslAdrenoCmdbatchQueuedFtraceEventReader = struct {
    buf: gremlin.Reader,
    _id: u32 = 0,
    _timestamp: u32 = 0,
    _queued: u32 = 0,
    _flags: u32 = 0,
    _prio: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!KgslAdrenoCmdbatchQueuedFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = KgslAdrenoCmdbatchQueuedFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                KgslAdrenoCmdbatchQueuedFtraceEventWire.ID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._id = result.value;
                },
                KgslAdrenoCmdbatchQueuedFtraceEventWire.TIMESTAMP_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._timestamp = result.value;
                },
                KgslAdrenoCmdbatchQueuedFtraceEventWire.QUEUED_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._queued = result.value;
                },
                KgslAdrenoCmdbatchQueuedFtraceEventWire.FLAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._flags = result.value;
                },
                KgslAdrenoCmdbatchQueuedFtraceEventWire.PRIO_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._prio = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getId(self: *const KgslAdrenoCmdbatchQueuedFtraceEventReader) u32 {
        return self._id;
    }
    pub inline fn getTimestamp(self: *const KgslAdrenoCmdbatchQueuedFtraceEventReader) u32 {
        return self._timestamp;
    }
    pub inline fn getQueued(self: *const KgslAdrenoCmdbatchQueuedFtraceEventReader) u32 {
        return self._queued;
    }
    pub inline fn getFlags(self: *const KgslAdrenoCmdbatchQueuedFtraceEventReader) u32 {
        return self._flags;
    }
    pub inline fn getPrio(self: *const KgslAdrenoCmdbatchQueuedFtraceEventReader) u32 {
        return self._prio;
    }
};
const KgslAdrenoCmdbatchSubmittedFtraceEventWire = struct {
    const ID_WIRE: gremlin.ProtoWireNumber = 1;
    const TIMESTAMP_WIRE: gremlin.ProtoWireNumber = 2;
    const INFLIGHT_WIRE: gremlin.ProtoWireNumber = 3;
    const FLAGS_WIRE: gremlin.ProtoWireNumber = 4;
    const TICKS_WIRE: gremlin.ProtoWireNumber = 5;
    const SECS_WIRE: gremlin.ProtoWireNumber = 6;
    const USECS_WIRE: gremlin.ProtoWireNumber = 7;
    const PRIO_WIRE: gremlin.ProtoWireNumber = 8;
    const RB_ID_WIRE: gremlin.ProtoWireNumber = 9;
    const RPTR_WIRE: gremlin.ProtoWireNumber = 10;
    const WPTR_WIRE: gremlin.ProtoWireNumber = 11;
    const Q_INFLIGHT_WIRE: gremlin.ProtoWireNumber = 12;
    const DISPATCH_QUEUE_WIRE: gremlin.ProtoWireNumber = 13;
};
pub const KgslAdrenoCmdbatchSubmittedFtraceEvent = struct {
    // fields
    id: u32 = 0,
    timestamp: u32 = 0,
    inflight: i64 = 0,
    flags: u32 = 0,
    ticks: u64 = 0,
    secs: u64 = 0,
    usecs: u64 = 0,
    prio: i32 = 0,
    rb_id: i32 = 0,
    rptr: u32 = 0,
    wptr: u32 = 0,
    q_inflight: i32 = 0,
    dispatch_queue: i32 = 0,
    pub fn calcProtobufSize(self: *const KgslAdrenoCmdbatchSubmittedFtraceEvent) usize {
        var res: usize = 0;
        if (self.id != 0) {
            res += gremlin.sizes.sizeWireNumber(KgslAdrenoCmdbatchSubmittedFtraceEventWire.ID_WIRE) + gremlin.sizes.sizeU32(self.id);
        }
        if (self.timestamp != 0) {
            res += gremlin.sizes.sizeWireNumber(KgslAdrenoCmdbatchSubmittedFtraceEventWire.TIMESTAMP_WIRE) + gremlin.sizes.sizeU32(self.timestamp);
        }
        if (self.inflight != 0) {
            res += gremlin.sizes.sizeWireNumber(KgslAdrenoCmdbatchSubmittedFtraceEventWire.INFLIGHT_WIRE) + gremlin.sizes.sizeI64(self.inflight);
        }
        if (self.flags != 0) {
            res += gremlin.sizes.sizeWireNumber(KgslAdrenoCmdbatchSubmittedFtraceEventWire.FLAGS_WIRE) + gremlin.sizes.sizeU32(self.flags);
        }
        if (self.ticks != 0) {
            res += gremlin.sizes.sizeWireNumber(KgslAdrenoCmdbatchSubmittedFtraceEventWire.TICKS_WIRE) + gremlin.sizes.sizeU64(self.ticks);
        }
        if (self.secs != 0) {
            res += gremlin.sizes.sizeWireNumber(KgslAdrenoCmdbatchSubmittedFtraceEventWire.SECS_WIRE) + gremlin.sizes.sizeU64(self.secs);
        }
        if (self.usecs != 0) {
            res += gremlin.sizes.sizeWireNumber(KgslAdrenoCmdbatchSubmittedFtraceEventWire.USECS_WIRE) + gremlin.sizes.sizeU64(self.usecs);
        }
        if (self.prio != 0) {
            res += gremlin.sizes.sizeWireNumber(KgslAdrenoCmdbatchSubmittedFtraceEventWire.PRIO_WIRE) + gremlin.sizes.sizeI32(self.prio);
        }
        if (self.rb_id != 0) {
            res += gremlin.sizes.sizeWireNumber(KgslAdrenoCmdbatchSubmittedFtraceEventWire.RB_ID_WIRE) + gremlin.sizes.sizeI32(self.rb_id);
        }
        if (self.rptr != 0) {
            res += gremlin.sizes.sizeWireNumber(KgslAdrenoCmdbatchSubmittedFtraceEventWire.RPTR_WIRE) + gremlin.sizes.sizeU32(self.rptr);
        }
        if (self.wptr != 0) {
            res += gremlin.sizes.sizeWireNumber(KgslAdrenoCmdbatchSubmittedFtraceEventWire.WPTR_WIRE) + gremlin.sizes.sizeU32(self.wptr);
        }
        if (self.q_inflight != 0) {
            res += gremlin.sizes.sizeWireNumber(KgslAdrenoCmdbatchSubmittedFtraceEventWire.Q_INFLIGHT_WIRE) + gremlin.sizes.sizeI32(self.q_inflight);
        }
        if (self.dispatch_queue != 0) {
            res += gremlin.sizes.sizeWireNumber(KgslAdrenoCmdbatchSubmittedFtraceEventWire.DISPATCH_QUEUE_WIRE) + gremlin.sizes.sizeI32(self.dispatch_queue);
        }
        return res;
    }
    pub fn encode(self: *const KgslAdrenoCmdbatchSubmittedFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const KgslAdrenoCmdbatchSubmittedFtraceEvent, target: *gremlin.Writer) void {
        if (self.id != 0) {
            target.appendUint32(KgslAdrenoCmdbatchSubmittedFtraceEventWire.ID_WIRE, self.id);
        }
        if (self.timestamp != 0) {
            target.appendUint32(KgslAdrenoCmdbatchSubmittedFtraceEventWire.TIMESTAMP_WIRE, self.timestamp);
        }
        if (self.inflight != 0) {
            target.appendInt64(KgslAdrenoCmdbatchSubmittedFtraceEventWire.INFLIGHT_WIRE, self.inflight);
        }
        if (self.flags != 0) {
            target.appendUint32(KgslAdrenoCmdbatchSubmittedFtraceEventWire.FLAGS_WIRE, self.flags);
        }
        if (self.ticks != 0) {
            target.appendUint64(KgslAdrenoCmdbatchSubmittedFtraceEventWire.TICKS_WIRE, self.ticks);
        }
        if (self.secs != 0) {
            target.appendUint64(KgslAdrenoCmdbatchSubmittedFtraceEventWire.SECS_WIRE, self.secs);
        }
        if (self.usecs != 0) {
            target.appendUint64(KgslAdrenoCmdbatchSubmittedFtraceEventWire.USECS_WIRE, self.usecs);
        }
        if (self.prio != 0) {
            target.appendInt32(KgslAdrenoCmdbatchSubmittedFtraceEventWire.PRIO_WIRE, self.prio);
        }
        if (self.rb_id != 0) {
            target.appendInt32(KgslAdrenoCmdbatchSubmittedFtraceEventWire.RB_ID_WIRE, self.rb_id);
        }
        if (self.rptr != 0) {
            target.appendUint32(KgslAdrenoCmdbatchSubmittedFtraceEventWire.RPTR_WIRE, self.rptr);
        }
        if (self.wptr != 0) {
            target.appendUint32(KgslAdrenoCmdbatchSubmittedFtraceEventWire.WPTR_WIRE, self.wptr);
        }
        if (self.q_inflight != 0) {
            target.appendInt32(KgslAdrenoCmdbatchSubmittedFtraceEventWire.Q_INFLIGHT_WIRE, self.q_inflight);
        }
        if (self.dispatch_queue != 0) {
            target.appendInt32(KgslAdrenoCmdbatchSubmittedFtraceEventWire.DISPATCH_QUEUE_WIRE, self.dispatch_queue);
        }
    }
};
pub const KgslAdrenoCmdbatchSubmittedFtraceEventReader = struct {
    buf: gremlin.Reader,
    _id: u32 = 0,
    _timestamp: u32 = 0,
    _inflight: i64 = 0,
    _flags: u32 = 0,
    _ticks: u64 = 0,
    _secs: u64 = 0,
    _usecs: u64 = 0,
    _prio: i32 = 0,
    _rb_id: i32 = 0,
    _rptr: u32 = 0,
    _wptr: u32 = 0,
    _q_inflight: i32 = 0,
    _dispatch_queue: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!KgslAdrenoCmdbatchSubmittedFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = KgslAdrenoCmdbatchSubmittedFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                KgslAdrenoCmdbatchSubmittedFtraceEventWire.ID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._id = result.value;
                },
                KgslAdrenoCmdbatchSubmittedFtraceEventWire.TIMESTAMP_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._timestamp = result.value;
                },
                KgslAdrenoCmdbatchSubmittedFtraceEventWire.INFLIGHT_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._inflight = result.value;
                },
                KgslAdrenoCmdbatchSubmittedFtraceEventWire.FLAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._flags = result.value;
                },
                KgslAdrenoCmdbatchSubmittedFtraceEventWire.TICKS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ticks = result.value;
                },
                KgslAdrenoCmdbatchSubmittedFtraceEventWire.SECS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._secs = result.value;
                },
                KgslAdrenoCmdbatchSubmittedFtraceEventWire.USECS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._usecs = result.value;
                },
                KgslAdrenoCmdbatchSubmittedFtraceEventWire.PRIO_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._prio = result.value;
                },
                KgslAdrenoCmdbatchSubmittedFtraceEventWire.RB_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._rb_id = result.value;
                },
                KgslAdrenoCmdbatchSubmittedFtraceEventWire.RPTR_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._rptr = result.value;
                },
                KgslAdrenoCmdbatchSubmittedFtraceEventWire.WPTR_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._wptr = result.value;
                },
                KgslAdrenoCmdbatchSubmittedFtraceEventWire.Q_INFLIGHT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._q_inflight = result.value;
                },
                KgslAdrenoCmdbatchSubmittedFtraceEventWire.DISPATCH_QUEUE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._dispatch_queue = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getId(self: *const KgslAdrenoCmdbatchSubmittedFtraceEventReader) u32 {
        return self._id;
    }
    pub inline fn getTimestamp(self: *const KgslAdrenoCmdbatchSubmittedFtraceEventReader) u32 {
        return self._timestamp;
    }
    pub inline fn getInflight(self: *const KgslAdrenoCmdbatchSubmittedFtraceEventReader) i64 {
        return self._inflight;
    }
    pub inline fn getFlags(self: *const KgslAdrenoCmdbatchSubmittedFtraceEventReader) u32 {
        return self._flags;
    }
    pub inline fn getTicks(self: *const KgslAdrenoCmdbatchSubmittedFtraceEventReader) u64 {
        return self._ticks;
    }
    pub inline fn getSecs(self: *const KgslAdrenoCmdbatchSubmittedFtraceEventReader) u64 {
        return self._secs;
    }
    pub inline fn getUsecs(self: *const KgslAdrenoCmdbatchSubmittedFtraceEventReader) u64 {
        return self._usecs;
    }
    pub inline fn getPrio(self: *const KgslAdrenoCmdbatchSubmittedFtraceEventReader) i32 {
        return self._prio;
    }
    pub inline fn getRbId(self: *const KgslAdrenoCmdbatchSubmittedFtraceEventReader) i32 {
        return self._rb_id;
    }
    pub inline fn getRptr(self: *const KgslAdrenoCmdbatchSubmittedFtraceEventReader) u32 {
        return self._rptr;
    }
    pub inline fn getWptr(self: *const KgslAdrenoCmdbatchSubmittedFtraceEventReader) u32 {
        return self._wptr;
    }
    pub inline fn getQInflight(self: *const KgslAdrenoCmdbatchSubmittedFtraceEventReader) i32 {
        return self._q_inflight;
    }
    pub inline fn getDispatchQueue(self: *const KgslAdrenoCmdbatchSubmittedFtraceEventReader) i32 {
        return self._dispatch_queue;
    }
};
const KgslAdrenoCmdbatchSyncFtraceEventWire = struct {
    const ID_WIRE: gremlin.ProtoWireNumber = 1;
    const TIMESTAMP_WIRE: gremlin.ProtoWireNumber = 2;
    const TICKS_WIRE: gremlin.ProtoWireNumber = 3;
    const PRIO_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const KgslAdrenoCmdbatchSyncFtraceEvent = struct {
    // fields
    id: u32 = 0,
    timestamp: u32 = 0,
    ticks: u64 = 0,
    prio: i32 = 0,
    pub fn calcProtobufSize(self: *const KgslAdrenoCmdbatchSyncFtraceEvent) usize {
        var res: usize = 0;
        if (self.id != 0) {
            res += gremlin.sizes.sizeWireNumber(KgslAdrenoCmdbatchSyncFtraceEventWire.ID_WIRE) + gremlin.sizes.sizeU32(self.id);
        }
        if (self.timestamp != 0) {
            res += gremlin.sizes.sizeWireNumber(KgslAdrenoCmdbatchSyncFtraceEventWire.TIMESTAMP_WIRE) + gremlin.sizes.sizeU32(self.timestamp);
        }
        if (self.ticks != 0) {
            res += gremlin.sizes.sizeWireNumber(KgslAdrenoCmdbatchSyncFtraceEventWire.TICKS_WIRE) + gremlin.sizes.sizeU64(self.ticks);
        }
        if (self.prio != 0) {
            res += gremlin.sizes.sizeWireNumber(KgslAdrenoCmdbatchSyncFtraceEventWire.PRIO_WIRE) + gremlin.sizes.sizeI32(self.prio);
        }
        return res;
    }
    pub fn encode(self: *const KgslAdrenoCmdbatchSyncFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const KgslAdrenoCmdbatchSyncFtraceEvent, target: *gremlin.Writer) void {
        if (self.id != 0) {
            target.appendUint32(KgslAdrenoCmdbatchSyncFtraceEventWire.ID_WIRE, self.id);
        }
        if (self.timestamp != 0) {
            target.appendUint32(KgslAdrenoCmdbatchSyncFtraceEventWire.TIMESTAMP_WIRE, self.timestamp);
        }
        if (self.ticks != 0) {
            target.appendUint64(KgslAdrenoCmdbatchSyncFtraceEventWire.TICKS_WIRE, self.ticks);
        }
        if (self.prio != 0) {
            target.appendInt32(KgslAdrenoCmdbatchSyncFtraceEventWire.PRIO_WIRE, self.prio);
        }
    }
};
pub const KgslAdrenoCmdbatchSyncFtraceEventReader = struct {
    buf: gremlin.Reader,
    _id: u32 = 0,
    _timestamp: u32 = 0,
    _ticks: u64 = 0,
    _prio: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!KgslAdrenoCmdbatchSyncFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = KgslAdrenoCmdbatchSyncFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                KgslAdrenoCmdbatchSyncFtraceEventWire.ID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._id = result.value;
                },
                KgslAdrenoCmdbatchSyncFtraceEventWire.TIMESTAMP_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._timestamp = result.value;
                },
                KgslAdrenoCmdbatchSyncFtraceEventWire.TICKS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ticks = result.value;
                },
                KgslAdrenoCmdbatchSyncFtraceEventWire.PRIO_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._prio = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getId(self: *const KgslAdrenoCmdbatchSyncFtraceEventReader) u32 {
        return self._id;
    }
    pub inline fn getTimestamp(self: *const KgslAdrenoCmdbatchSyncFtraceEventReader) u32 {
        return self._timestamp;
    }
    pub inline fn getTicks(self: *const KgslAdrenoCmdbatchSyncFtraceEventReader) u64 {
        return self._ticks;
    }
    pub inline fn getPrio(self: *const KgslAdrenoCmdbatchSyncFtraceEventReader) i32 {
        return self._prio;
    }
};
const KgslAdrenoCmdbatchRetiredFtraceEventWire = struct {
    const ID_WIRE: gremlin.ProtoWireNumber = 1;
    const TIMESTAMP_WIRE: gremlin.ProtoWireNumber = 2;
    const INFLIGHT_WIRE: gremlin.ProtoWireNumber = 3;
    const RECOVERY_WIRE: gremlin.ProtoWireNumber = 4;
    const FLAGS_WIRE: gremlin.ProtoWireNumber = 5;
    const START_WIRE: gremlin.ProtoWireNumber = 6;
    const RETIRE_WIRE: gremlin.ProtoWireNumber = 7;
    const PRIO_WIRE: gremlin.ProtoWireNumber = 8;
    const RB_ID_WIRE: gremlin.ProtoWireNumber = 9;
    const RPTR_WIRE: gremlin.ProtoWireNumber = 10;
    const WPTR_WIRE: gremlin.ProtoWireNumber = 11;
    const Q_INFLIGHT_WIRE: gremlin.ProtoWireNumber = 12;
    const FAULT_RECOVERY_WIRE: gremlin.ProtoWireNumber = 13;
    const DISPATCH_QUEUE_WIRE: gremlin.ProtoWireNumber = 14;
    const SUBMITTED_TO_RB_WIRE: gremlin.ProtoWireNumber = 15;
    const RETIRED_ON_GMU_WIRE: gremlin.ProtoWireNumber = 16;
    const ACTIVE_WIRE: gremlin.ProtoWireNumber = 17;
};
pub const KgslAdrenoCmdbatchRetiredFtraceEvent = struct {
    // fields
    id: u32 = 0,
    timestamp: u32 = 0,
    inflight: i64 = 0,
    recovery: u32 = 0,
    flags: u32 = 0,
    start: u64 = 0,
    retire: u64 = 0,
    prio: i32 = 0,
    rb_id: i32 = 0,
    rptr: u32 = 0,
    wptr: u32 = 0,
    q_inflight: i32 = 0,
    fault_recovery: u64 = 0,
    dispatch_queue: u32 = 0,
    submitted_to_rb: u64 = 0,
    retired_on_gmu: u64 = 0,
    active: u64 = 0,
    pub fn calcProtobufSize(self: *const KgslAdrenoCmdbatchRetiredFtraceEvent) usize {
        var res: usize = 0;
        if (self.id != 0) {
            res += gremlin.sizes.sizeWireNumber(KgslAdrenoCmdbatchRetiredFtraceEventWire.ID_WIRE) + gremlin.sizes.sizeU32(self.id);
        }
        if (self.timestamp != 0) {
            res += gremlin.sizes.sizeWireNumber(KgslAdrenoCmdbatchRetiredFtraceEventWire.TIMESTAMP_WIRE) + gremlin.sizes.sizeU32(self.timestamp);
        }
        if (self.inflight != 0) {
            res += gremlin.sizes.sizeWireNumber(KgslAdrenoCmdbatchRetiredFtraceEventWire.INFLIGHT_WIRE) + gremlin.sizes.sizeI64(self.inflight);
        }
        if (self.recovery != 0) {
            res += gremlin.sizes.sizeWireNumber(KgslAdrenoCmdbatchRetiredFtraceEventWire.RECOVERY_WIRE) + gremlin.sizes.sizeU32(self.recovery);
        }
        if (self.flags != 0) {
            res += gremlin.sizes.sizeWireNumber(KgslAdrenoCmdbatchRetiredFtraceEventWire.FLAGS_WIRE) + gremlin.sizes.sizeU32(self.flags);
        }
        if (self.start != 0) {
            res += gremlin.sizes.sizeWireNumber(KgslAdrenoCmdbatchRetiredFtraceEventWire.START_WIRE) + gremlin.sizes.sizeU64(self.start);
        }
        if (self.retire != 0) {
            res += gremlin.sizes.sizeWireNumber(KgslAdrenoCmdbatchRetiredFtraceEventWire.RETIRE_WIRE) + gremlin.sizes.sizeU64(self.retire);
        }
        if (self.prio != 0) {
            res += gremlin.sizes.sizeWireNumber(KgslAdrenoCmdbatchRetiredFtraceEventWire.PRIO_WIRE) + gremlin.sizes.sizeI32(self.prio);
        }
        if (self.rb_id != 0) {
            res += gremlin.sizes.sizeWireNumber(KgslAdrenoCmdbatchRetiredFtraceEventWire.RB_ID_WIRE) + gremlin.sizes.sizeI32(self.rb_id);
        }
        if (self.rptr != 0) {
            res += gremlin.sizes.sizeWireNumber(KgslAdrenoCmdbatchRetiredFtraceEventWire.RPTR_WIRE) + gremlin.sizes.sizeU32(self.rptr);
        }
        if (self.wptr != 0) {
            res += gremlin.sizes.sizeWireNumber(KgslAdrenoCmdbatchRetiredFtraceEventWire.WPTR_WIRE) + gremlin.sizes.sizeU32(self.wptr);
        }
        if (self.q_inflight != 0) {
            res += gremlin.sizes.sizeWireNumber(KgslAdrenoCmdbatchRetiredFtraceEventWire.Q_INFLIGHT_WIRE) + gremlin.sizes.sizeI32(self.q_inflight);
        }
        if (self.fault_recovery != 0) {
            res += gremlin.sizes.sizeWireNumber(KgslAdrenoCmdbatchRetiredFtraceEventWire.FAULT_RECOVERY_WIRE) + gremlin.sizes.sizeU64(self.fault_recovery);
        }
        if (self.dispatch_queue != 0) {
            res += gremlin.sizes.sizeWireNumber(KgslAdrenoCmdbatchRetiredFtraceEventWire.DISPATCH_QUEUE_WIRE) + gremlin.sizes.sizeU32(self.dispatch_queue);
        }
        if (self.submitted_to_rb != 0) {
            res += gremlin.sizes.sizeWireNumber(KgslAdrenoCmdbatchRetiredFtraceEventWire.SUBMITTED_TO_RB_WIRE) + gremlin.sizes.sizeU64(self.submitted_to_rb);
        }
        if (self.retired_on_gmu != 0) {
            res += gremlin.sizes.sizeWireNumber(KgslAdrenoCmdbatchRetiredFtraceEventWire.RETIRED_ON_GMU_WIRE) + gremlin.sizes.sizeU64(self.retired_on_gmu);
        }
        if (self.active != 0) {
            res += gremlin.sizes.sizeWireNumber(KgslAdrenoCmdbatchRetiredFtraceEventWire.ACTIVE_WIRE) + gremlin.sizes.sizeU64(self.active);
        }
        return res;
    }
    pub fn encode(self: *const KgslAdrenoCmdbatchRetiredFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const KgslAdrenoCmdbatchRetiredFtraceEvent, target: *gremlin.Writer) void {
        if (self.id != 0) {
            target.appendUint32(KgslAdrenoCmdbatchRetiredFtraceEventWire.ID_WIRE, self.id);
        }
        if (self.timestamp != 0) {
            target.appendUint32(KgslAdrenoCmdbatchRetiredFtraceEventWire.TIMESTAMP_WIRE, self.timestamp);
        }
        if (self.inflight != 0) {
            target.appendInt64(KgslAdrenoCmdbatchRetiredFtraceEventWire.INFLIGHT_WIRE, self.inflight);
        }
        if (self.recovery != 0) {
            target.appendUint32(KgslAdrenoCmdbatchRetiredFtraceEventWire.RECOVERY_WIRE, self.recovery);
        }
        if (self.flags != 0) {
            target.appendUint32(KgslAdrenoCmdbatchRetiredFtraceEventWire.FLAGS_WIRE, self.flags);
        }
        if (self.start != 0) {
            target.appendUint64(KgslAdrenoCmdbatchRetiredFtraceEventWire.START_WIRE, self.start);
        }
        if (self.retire != 0) {
            target.appendUint64(KgslAdrenoCmdbatchRetiredFtraceEventWire.RETIRE_WIRE, self.retire);
        }
        if (self.prio != 0) {
            target.appendInt32(KgslAdrenoCmdbatchRetiredFtraceEventWire.PRIO_WIRE, self.prio);
        }
        if (self.rb_id != 0) {
            target.appendInt32(KgslAdrenoCmdbatchRetiredFtraceEventWire.RB_ID_WIRE, self.rb_id);
        }
        if (self.rptr != 0) {
            target.appendUint32(KgslAdrenoCmdbatchRetiredFtraceEventWire.RPTR_WIRE, self.rptr);
        }
        if (self.wptr != 0) {
            target.appendUint32(KgslAdrenoCmdbatchRetiredFtraceEventWire.WPTR_WIRE, self.wptr);
        }
        if (self.q_inflight != 0) {
            target.appendInt32(KgslAdrenoCmdbatchRetiredFtraceEventWire.Q_INFLIGHT_WIRE, self.q_inflight);
        }
        if (self.fault_recovery != 0) {
            target.appendUint64(KgslAdrenoCmdbatchRetiredFtraceEventWire.FAULT_RECOVERY_WIRE, self.fault_recovery);
        }
        if (self.dispatch_queue != 0) {
            target.appendUint32(KgslAdrenoCmdbatchRetiredFtraceEventWire.DISPATCH_QUEUE_WIRE, self.dispatch_queue);
        }
        if (self.submitted_to_rb != 0) {
            target.appendUint64(KgslAdrenoCmdbatchRetiredFtraceEventWire.SUBMITTED_TO_RB_WIRE, self.submitted_to_rb);
        }
        if (self.retired_on_gmu != 0) {
            target.appendUint64(KgslAdrenoCmdbatchRetiredFtraceEventWire.RETIRED_ON_GMU_WIRE, self.retired_on_gmu);
        }
        if (self.active != 0) {
            target.appendUint64(KgslAdrenoCmdbatchRetiredFtraceEventWire.ACTIVE_WIRE, self.active);
        }
    }
};
pub const KgslAdrenoCmdbatchRetiredFtraceEventReader = struct {
    buf: gremlin.Reader,
    _id: u32 = 0,
    _timestamp: u32 = 0,
    _inflight: i64 = 0,
    _recovery: u32 = 0,
    _flags: u32 = 0,
    _start: u64 = 0,
    _retire: u64 = 0,
    _prio: i32 = 0,
    _rb_id: i32 = 0,
    _rptr: u32 = 0,
    _wptr: u32 = 0,
    _q_inflight: i32 = 0,
    _fault_recovery: u64 = 0,
    _dispatch_queue: u32 = 0,
    _submitted_to_rb: u64 = 0,
    _retired_on_gmu: u64 = 0,
    _active: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!KgslAdrenoCmdbatchRetiredFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = KgslAdrenoCmdbatchRetiredFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                KgslAdrenoCmdbatchRetiredFtraceEventWire.ID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._id = result.value;
                },
                KgslAdrenoCmdbatchRetiredFtraceEventWire.TIMESTAMP_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._timestamp = result.value;
                },
                KgslAdrenoCmdbatchRetiredFtraceEventWire.INFLIGHT_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._inflight = result.value;
                },
                KgslAdrenoCmdbatchRetiredFtraceEventWire.RECOVERY_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._recovery = result.value;
                },
                KgslAdrenoCmdbatchRetiredFtraceEventWire.FLAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._flags = result.value;
                },
                KgslAdrenoCmdbatchRetiredFtraceEventWire.START_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._start = result.value;
                },
                KgslAdrenoCmdbatchRetiredFtraceEventWire.RETIRE_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._retire = result.value;
                },
                KgslAdrenoCmdbatchRetiredFtraceEventWire.PRIO_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._prio = result.value;
                },
                KgslAdrenoCmdbatchRetiredFtraceEventWire.RB_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._rb_id = result.value;
                },
                KgslAdrenoCmdbatchRetiredFtraceEventWire.RPTR_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._rptr = result.value;
                },
                KgslAdrenoCmdbatchRetiredFtraceEventWire.WPTR_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._wptr = result.value;
                },
                KgslAdrenoCmdbatchRetiredFtraceEventWire.Q_INFLIGHT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._q_inflight = result.value;
                },
                KgslAdrenoCmdbatchRetiredFtraceEventWire.FAULT_RECOVERY_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._fault_recovery = result.value;
                },
                KgslAdrenoCmdbatchRetiredFtraceEventWire.DISPATCH_QUEUE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._dispatch_queue = result.value;
                },
                KgslAdrenoCmdbatchRetiredFtraceEventWire.SUBMITTED_TO_RB_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._submitted_to_rb = result.value;
                },
                KgslAdrenoCmdbatchRetiredFtraceEventWire.RETIRED_ON_GMU_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._retired_on_gmu = result.value;
                },
                KgslAdrenoCmdbatchRetiredFtraceEventWire.ACTIVE_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._active = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getId(self: *const KgslAdrenoCmdbatchRetiredFtraceEventReader) u32 {
        return self._id;
    }
    pub inline fn getTimestamp(self: *const KgslAdrenoCmdbatchRetiredFtraceEventReader) u32 {
        return self._timestamp;
    }
    pub inline fn getInflight(self: *const KgslAdrenoCmdbatchRetiredFtraceEventReader) i64 {
        return self._inflight;
    }
    pub inline fn getRecovery(self: *const KgslAdrenoCmdbatchRetiredFtraceEventReader) u32 {
        return self._recovery;
    }
    pub inline fn getFlags(self: *const KgslAdrenoCmdbatchRetiredFtraceEventReader) u32 {
        return self._flags;
    }
    pub inline fn getStart(self: *const KgslAdrenoCmdbatchRetiredFtraceEventReader) u64 {
        return self._start;
    }
    pub inline fn getRetire(self: *const KgslAdrenoCmdbatchRetiredFtraceEventReader) u64 {
        return self._retire;
    }
    pub inline fn getPrio(self: *const KgslAdrenoCmdbatchRetiredFtraceEventReader) i32 {
        return self._prio;
    }
    pub inline fn getRbId(self: *const KgslAdrenoCmdbatchRetiredFtraceEventReader) i32 {
        return self._rb_id;
    }
    pub inline fn getRptr(self: *const KgslAdrenoCmdbatchRetiredFtraceEventReader) u32 {
        return self._rptr;
    }
    pub inline fn getWptr(self: *const KgslAdrenoCmdbatchRetiredFtraceEventReader) u32 {
        return self._wptr;
    }
    pub inline fn getQInflight(self: *const KgslAdrenoCmdbatchRetiredFtraceEventReader) i32 {
        return self._q_inflight;
    }
    pub inline fn getFaultRecovery(self: *const KgslAdrenoCmdbatchRetiredFtraceEventReader) u64 {
        return self._fault_recovery;
    }
    pub inline fn getDispatchQueue(self: *const KgslAdrenoCmdbatchRetiredFtraceEventReader) u32 {
        return self._dispatch_queue;
    }
    pub inline fn getSubmittedToRb(self: *const KgslAdrenoCmdbatchRetiredFtraceEventReader) u64 {
        return self._submitted_to_rb;
    }
    pub inline fn getRetiredOnGmu(self: *const KgslAdrenoCmdbatchRetiredFtraceEventReader) u64 {
        return self._retired_on_gmu;
    }
    pub inline fn getActive(self: *const KgslAdrenoCmdbatchRetiredFtraceEventReader) u64 {
        return self._active;
    }
};
