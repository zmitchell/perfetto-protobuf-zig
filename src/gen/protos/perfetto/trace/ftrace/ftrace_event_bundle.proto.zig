// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
const ftrace_stats = @import("ftrace_stats.proto.zig");
const ftrace_event = @import("ftrace_event.proto.zig");
// enums
pub const FtraceClock = enum(i32) {
    FTRACE_CLOCK_UNSPECIFIED = 0,
    FTRACE_CLOCK_UNKNOWN = 1,
    FTRACE_CLOCK_GLOBAL = 2,
    FTRACE_CLOCK_LOCAL = 3,
    FTRACE_CLOCK_MONO_RAW = 4,
};
// structs
const FtraceEventBundleWire = struct {
    const CPU_WIRE: gremlin.ProtoWireNumber = 1;
    const EVENT_WIRE: gremlin.ProtoWireNumber = 2;
    const LOST_EVENTS_WIRE: gremlin.ProtoWireNumber = 3;
    const COMPACT_SCHED_WIRE: gremlin.ProtoWireNumber = 4;
    const FTRACE_CLOCK_WIRE: gremlin.ProtoWireNumber = 5;
    const FTRACE_TIMESTAMP_WIRE: gremlin.ProtoWireNumber = 6;
    const BOOT_TIMESTAMP_WIRE: gremlin.ProtoWireNumber = 7;
    const ERROR_WIRE: gremlin.ProtoWireNumber = 8;
    const LAST_READ_EVENT_TIMESTAMP_WIRE: gremlin.ProtoWireNumber = 9;
    const PREVIOUS_BUNDLE_END_TIMESTAMP_WIRE: gremlin.ProtoWireNumber = 10;
    const GENERIC_EVENT_DESCRIPTORS_WIRE: gremlin.ProtoWireNumber = 11;
    const BROKEN_ABI_TRACE_PAGE_WIRE: gremlin.ProtoWireNumber = 512;
};
pub const FtraceEventBundle = struct {
    // nested structs
    const CompactSchedWire = struct {
        const INTERN_TABLE_WIRE: gremlin.ProtoWireNumber = 5;
        const SWITCH_TIMESTAMP_WIRE: gremlin.ProtoWireNumber = 1;
        const SWITCH_PREV_STATE_WIRE: gremlin.ProtoWireNumber = 2;
        const SWITCH_NEXT_PID_WIRE: gremlin.ProtoWireNumber = 3;
        const SWITCH_NEXT_PRIO_WIRE: gremlin.ProtoWireNumber = 4;
        const SWITCH_NEXT_COMM_INDEX_WIRE: gremlin.ProtoWireNumber = 6;
        const WAKING_TIMESTAMP_WIRE: gremlin.ProtoWireNumber = 7;
        const WAKING_PID_WIRE: gremlin.ProtoWireNumber = 8;
        const WAKING_TARGET_CPU_WIRE: gremlin.ProtoWireNumber = 9;
        const WAKING_PRIO_WIRE: gremlin.ProtoWireNumber = 10;
        const WAKING_COMM_INDEX_WIRE: gremlin.ProtoWireNumber = 11;
        const WAKING_COMMON_FLAGS_WIRE: gremlin.ProtoWireNumber = 12;
    };
    pub const CompactSched = struct {
        // fields
        intern_table: ?[]const ?[]const u8 = null,
        switch_timestamp: ?[]const u64 = null,
        switch_prev_state: ?[]const i64 = null,
        switch_next_pid: ?[]const i32 = null,
        switch_next_prio: ?[]const i32 = null,
        switch_next_comm_index: ?[]const u32 = null,
        waking_timestamp: ?[]const u64 = null,
        waking_pid: ?[]const i32 = null,
        waking_target_cpu: ?[]const i32 = null,
        waking_prio: ?[]const i32 = null,
        waking_comm_index: ?[]const u32 = null,
        waking_common_flags: ?[]const u32 = null,
        pub fn calcProtobufSize(self: *const FtraceEventBundle.CompactSched) usize {
            var res: usize = 0;
            if (self.intern_table) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(FtraceEventBundle.CompactSchedWire.INTERN_TABLE_WIRE);
                    if (maybe_v) |v| {
                        res += gremlin.sizes.sizeUsize(v.len) + v.len;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.switch_timestamp) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    res += gremlin.sizes.sizeWireNumber(FtraceEventBundle.CompactSchedWire.SWITCH_TIMESTAMP_WIRE) + gremlin.sizes.sizeU64(arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeU64(v);
                    }
                    res += gremlin.sizes.sizeWireNumber(FtraceEventBundle.CompactSchedWire.SWITCH_TIMESTAMP_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
                }
            }
            if (self.switch_prev_state) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    res += gremlin.sizes.sizeWireNumber(FtraceEventBundle.CompactSchedWire.SWITCH_PREV_STATE_WIRE) + gremlin.sizes.sizeI64(arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeI64(v);
                    }
                    res += gremlin.sizes.sizeWireNumber(FtraceEventBundle.CompactSchedWire.SWITCH_PREV_STATE_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
                }
            }
            if (self.switch_next_pid) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    res += gremlin.sizes.sizeWireNumber(FtraceEventBundle.CompactSchedWire.SWITCH_NEXT_PID_WIRE) + gremlin.sizes.sizeI32(arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeI32(v);
                    }
                    res += gremlin.sizes.sizeWireNumber(FtraceEventBundle.CompactSchedWire.SWITCH_NEXT_PID_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
                }
            }
            if (self.switch_next_prio) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    res += gremlin.sizes.sizeWireNumber(FtraceEventBundle.CompactSchedWire.SWITCH_NEXT_PRIO_WIRE) + gremlin.sizes.sizeI32(arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeI32(v);
                    }
                    res += gremlin.sizes.sizeWireNumber(FtraceEventBundle.CompactSchedWire.SWITCH_NEXT_PRIO_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
                }
            }
            if (self.switch_next_comm_index) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    res += gremlin.sizes.sizeWireNumber(FtraceEventBundle.CompactSchedWire.SWITCH_NEXT_COMM_INDEX_WIRE) + gremlin.sizes.sizeU32(arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeU32(v);
                    }
                    res += gremlin.sizes.sizeWireNumber(FtraceEventBundle.CompactSchedWire.SWITCH_NEXT_COMM_INDEX_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
                }
            }
            if (self.waking_timestamp) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    res += gremlin.sizes.sizeWireNumber(FtraceEventBundle.CompactSchedWire.WAKING_TIMESTAMP_WIRE) + gremlin.sizes.sizeU64(arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeU64(v);
                    }
                    res += gremlin.sizes.sizeWireNumber(FtraceEventBundle.CompactSchedWire.WAKING_TIMESTAMP_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
                }
            }
            if (self.waking_pid) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    res += gremlin.sizes.sizeWireNumber(FtraceEventBundle.CompactSchedWire.WAKING_PID_WIRE) + gremlin.sizes.sizeI32(arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeI32(v);
                    }
                    res += gremlin.sizes.sizeWireNumber(FtraceEventBundle.CompactSchedWire.WAKING_PID_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
                }
            }
            if (self.waking_target_cpu) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    res += gremlin.sizes.sizeWireNumber(FtraceEventBundle.CompactSchedWire.WAKING_TARGET_CPU_WIRE) + gremlin.sizes.sizeI32(arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeI32(v);
                    }
                    res += gremlin.sizes.sizeWireNumber(FtraceEventBundle.CompactSchedWire.WAKING_TARGET_CPU_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
                }
            }
            if (self.waking_prio) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    res += gremlin.sizes.sizeWireNumber(FtraceEventBundle.CompactSchedWire.WAKING_PRIO_WIRE) + gremlin.sizes.sizeI32(arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeI32(v);
                    }
                    res += gremlin.sizes.sizeWireNumber(FtraceEventBundle.CompactSchedWire.WAKING_PRIO_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
                }
            }
            if (self.waking_comm_index) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    res += gremlin.sizes.sizeWireNumber(FtraceEventBundle.CompactSchedWire.WAKING_COMM_INDEX_WIRE) + gremlin.sizes.sizeU32(arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeU32(v);
                    }
                    res += gremlin.sizes.sizeWireNumber(FtraceEventBundle.CompactSchedWire.WAKING_COMM_INDEX_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
                }
            }
            if (self.waking_common_flags) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    res += gremlin.sizes.sizeWireNumber(FtraceEventBundle.CompactSchedWire.WAKING_COMMON_FLAGS_WIRE) + gremlin.sizes.sizeU32(arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeU32(v);
                    }
                    res += gremlin.sizes.sizeWireNumber(FtraceEventBundle.CompactSchedWire.WAKING_COMMON_FLAGS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
                }
            }
            return res;
        }
        pub fn encode(self: *const FtraceEventBundle.CompactSched, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const FtraceEventBundle.CompactSched, target: *gremlin.Writer) void {
            if (self.intern_table) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        target.appendBytes(FtraceEventBundle.CompactSchedWire.INTERN_TABLE_WIRE, v);
                    } else {
                        target.appendBytesTag(FtraceEventBundle.CompactSchedWire.INTERN_TABLE_WIRE, 0);
                    }
                }
            }
            if (self.switch_timestamp) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    target.appendUint64(FtraceEventBundle.CompactSchedWire.SWITCH_TIMESTAMP_WIRE, arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeU64(v);
                    }
                    target.appendBytesTag(FtraceEventBundle.CompactSchedWire.SWITCH_TIMESTAMP_WIRE, packed_size);
                    for (arr) |v| {
                        target.appendUint64WithoutTag(v);
                    }
                }
            }
            if (self.switch_prev_state) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    target.appendInt64(FtraceEventBundle.CompactSchedWire.SWITCH_PREV_STATE_WIRE, arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeI64(v);
                    }
                    target.appendBytesTag(FtraceEventBundle.CompactSchedWire.SWITCH_PREV_STATE_WIRE, packed_size);
                    for (arr) |v| {
                        target.appendInt64WithoutTag(v);
                    }
                }
            }
            if (self.switch_next_pid) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    target.appendInt32(FtraceEventBundle.CompactSchedWire.SWITCH_NEXT_PID_WIRE, arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeI32(v);
                    }
                    target.appendBytesTag(FtraceEventBundle.CompactSchedWire.SWITCH_NEXT_PID_WIRE, packed_size);
                    for (arr) |v| {
                        target.appendInt32WithoutTag(v);
                    }
                }
            }
            if (self.switch_next_prio) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    target.appendInt32(FtraceEventBundle.CompactSchedWire.SWITCH_NEXT_PRIO_WIRE, arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeI32(v);
                    }
                    target.appendBytesTag(FtraceEventBundle.CompactSchedWire.SWITCH_NEXT_PRIO_WIRE, packed_size);
                    for (arr) |v| {
                        target.appendInt32WithoutTag(v);
                    }
                }
            }
            if (self.switch_next_comm_index) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    target.appendUint32(FtraceEventBundle.CompactSchedWire.SWITCH_NEXT_COMM_INDEX_WIRE, arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeU32(v);
                    }
                    target.appendBytesTag(FtraceEventBundle.CompactSchedWire.SWITCH_NEXT_COMM_INDEX_WIRE, packed_size);
                    for (arr) |v| {
                        target.appendUint32WithoutTag(v);
                    }
                }
            }
            if (self.waking_timestamp) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    target.appendUint64(FtraceEventBundle.CompactSchedWire.WAKING_TIMESTAMP_WIRE, arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeU64(v);
                    }
                    target.appendBytesTag(FtraceEventBundle.CompactSchedWire.WAKING_TIMESTAMP_WIRE, packed_size);
                    for (arr) |v| {
                        target.appendUint64WithoutTag(v);
                    }
                }
            }
            if (self.waking_pid) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    target.appendInt32(FtraceEventBundle.CompactSchedWire.WAKING_PID_WIRE, arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeI32(v);
                    }
                    target.appendBytesTag(FtraceEventBundle.CompactSchedWire.WAKING_PID_WIRE, packed_size);
                    for (arr) |v| {
                        target.appendInt32WithoutTag(v);
                    }
                }
            }
            if (self.waking_target_cpu) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    target.appendInt32(FtraceEventBundle.CompactSchedWire.WAKING_TARGET_CPU_WIRE, arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeI32(v);
                    }
                    target.appendBytesTag(FtraceEventBundle.CompactSchedWire.WAKING_TARGET_CPU_WIRE, packed_size);
                    for (arr) |v| {
                        target.appendInt32WithoutTag(v);
                    }
                }
            }
            if (self.waking_prio) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    target.appendInt32(FtraceEventBundle.CompactSchedWire.WAKING_PRIO_WIRE, arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeI32(v);
                    }
                    target.appendBytesTag(FtraceEventBundle.CompactSchedWire.WAKING_PRIO_WIRE, packed_size);
                    for (arr) |v| {
                        target.appendInt32WithoutTag(v);
                    }
                }
            }
            if (self.waking_comm_index) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    target.appendUint32(FtraceEventBundle.CompactSchedWire.WAKING_COMM_INDEX_WIRE, arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeU32(v);
                    }
                    target.appendBytesTag(FtraceEventBundle.CompactSchedWire.WAKING_COMM_INDEX_WIRE, packed_size);
                    for (arr) |v| {
                        target.appendUint32WithoutTag(v);
                    }
                }
            }
            if (self.waking_common_flags) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    target.appendUint32(FtraceEventBundle.CompactSchedWire.WAKING_COMMON_FLAGS_WIRE, arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeU32(v);
                    }
                    target.appendBytesTag(FtraceEventBundle.CompactSchedWire.WAKING_COMMON_FLAGS_WIRE, packed_size);
                    for (arr) |v| {
                        target.appendUint32WithoutTag(v);
                    }
                }
            }
        }
    };
    pub const CompactSchedReader = struct {
        buf: gremlin.Reader,
        _intern_table_offset: ?usize = null,
        _intern_table_last_offset: ?usize = null,
        _intern_table_cnt: usize = 0,
        _switch_timestamp_offset: ?usize = null,
        _switch_timestamp_last_offset: ?usize = null,
        _switch_timestamp_packed: bool = false,
        _switch_prev_state_offset: ?usize = null,
        _switch_prev_state_last_offset: ?usize = null,
        _switch_prev_state_packed: bool = false,
        _switch_next_pid_offset: ?usize = null,
        _switch_next_pid_last_offset: ?usize = null,
        _switch_next_pid_packed: bool = false,
        _switch_next_prio_offset: ?usize = null,
        _switch_next_prio_last_offset: ?usize = null,
        _switch_next_prio_packed: bool = false,
        _switch_next_comm_index_offset: ?usize = null,
        _switch_next_comm_index_last_offset: ?usize = null,
        _switch_next_comm_index_packed: bool = false,
        _waking_timestamp_offset: ?usize = null,
        _waking_timestamp_last_offset: ?usize = null,
        _waking_timestamp_packed: bool = false,
        _waking_pid_offset: ?usize = null,
        _waking_pid_last_offset: ?usize = null,
        _waking_pid_packed: bool = false,
        _waking_target_cpu_offset: ?usize = null,
        _waking_target_cpu_last_offset: ?usize = null,
        _waking_target_cpu_packed: bool = false,
        _waking_prio_offset: ?usize = null,
        _waking_prio_last_offset: ?usize = null,
        _waking_prio_packed: bool = false,
        _waking_comm_index_offset: ?usize = null,
        _waking_comm_index_last_offset: ?usize = null,
        _waking_comm_index_packed: bool = false,
        _waking_common_flags_offset: ?usize = null,
        _waking_common_flags_last_offset: ?usize = null,
        _waking_common_flags_packed: bool = false,
        pub fn init(src: []const u8) gremlin.Error!FtraceEventBundle.CompactSchedReader {
            const buf = gremlin.Reader.init(src);
            var res = FtraceEventBundle.CompactSchedReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    FtraceEventBundle.CompactSchedWire.INTERN_TABLE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._intern_table_offset == null) {
                            res._intern_table_offset = offset - result.size;
                        }
                        res._intern_table_last_offset = offset;
                        res._intern_table_cnt += 1;
                    },
                    FtraceEventBundle.CompactSchedWire.SWITCH_TIMESTAMP_WIRE => {
                        if (res._switch_timestamp_offset == null) {
                            res._switch_timestamp_offset = offset;
                        }
                        if (tag.wire == gremlin.ProtoWireType.bytes) {
                            res._switch_timestamp_packed = true;
                            const length_result = try buf.readVarInt(offset);
                            res._switch_timestamp_offset = offset + length_result.size;
                            res._switch_timestamp_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                            offset = res._switch_timestamp_last_offset.?;
                        } else {
                            const result = try buf.readUInt64(offset);
                            offset += result.size;
                            res._switch_timestamp_last_offset = offset;
                        }
                    },
                    FtraceEventBundle.CompactSchedWire.SWITCH_PREV_STATE_WIRE => {
                        if (res._switch_prev_state_offset == null) {
                            res._switch_prev_state_offset = offset;
                        }
                        if (tag.wire == gremlin.ProtoWireType.bytes) {
                            res._switch_prev_state_packed = true;
                            const length_result = try buf.readVarInt(offset);
                            res._switch_prev_state_offset = offset + length_result.size;
                            res._switch_prev_state_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                            offset = res._switch_prev_state_last_offset.?;
                        } else {
                            const result = try buf.readInt64(offset);
                            offset += result.size;
                            res._switch_prev_state_last_offset = offset;
                        }
                    },
                    FtraceEventBundle.CompactSchedWire.SWITCH_NEXT_PID_WIRE => {
                        if (res._switch_next_pid_offset == null) {
                            res._switch_next_pid_offset = offset;
                        }
                        if (tag.wire == gremlin.ProtoWireType.bytes) {
                            res._switch_next_pid_packed = true;
                            const length_result = try buf.readVarInt(offset);
                            res._switch_next_pid_offset = offset + length_result.size;
                            res._switch_next_pid_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                            offset = res._switch_next_pid_last_offset.?;
                        } else {
                            const result = try buf.readInt32(offset);
                            offset += result.size;
                            res._switch_next_pid_last_offset = offset;
                        }
                    },
                    FtraceEventBundle.CompactSchedWire.SWITCH_NEXT_PRIO_WIRE => {
                        if (res._switch_next_prio_offset == null) {
                            res._switch_next_prio_offset = offset;
                        }
                        if (tag.wire == gremlin.ProtoWireType.bytes) {
                            res._switch_next_prio_packed = true;
                            const length_result = try buf.readVarInt(offset);
                            res._switch_next_prio_offset = offset + length_result.size;
                            res._switch_next_prio_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                            offset = res._switch_next_prio_last_offset.?;
                        } else {
                            const result = try buf.readInt32(offset);
                            offset += result.size;
                            res._switch_next_prio_last_offset = offset;
                        }
                    },
                    FtraceEventBundle.CompactSchedWire.SWITCH_NEXT_COMM_INDEX_WIRE => {
                        if (res._switch_next_comm_index_offset == null) {
                            res._switch_next_comm_index_offset = offset;
                        }
                        if (tag.wire == gremlin.ProtoWireType.bytes) {
                            res._switch_next_comm_index_packed = true;
                            const length_result = try buf.readVarInt(offset);
                            res._switch_next_comm_index_offset = offset + length_result.size;
                            res._switch_next_comm_index_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                            offset = res._switch_next_comm_index_last_offset.?;
                        } else {
                            const result = try buf.readUInt32(offset);
                            offset += result.size;
                            res._switch_next_comm_index_last_offset = offset;
                        }
                    },
                    FtraceEventBundle.CompactSchedWire.WAKING_TIMESTAMP_WIRE => {
                        if (res._waking_timestamp_offset == null) {
                            res._waking_timestamp_offset = offset;
                        }
                        if (tag.wire == gremlin.ProtoWireType.bytes) {
                            res._waking_timestamp_packed = true;
                            const length_result = try buf.readVarInt(offset);
                            res._waking_timestamp_offset = offset + length_result.size;
                            res._waking_timestamp_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                            offset = res._waking_timestamp_last_offset.?;
                        } else {
                            const result = try buf.readUInt64(offset);
                            offset += result.size;
                            res._waking_timestamp_last_offset = offset;
                        }
                    },
                    FtraceEventBundle.CompactSchedWire.WAKING_PID_WIRE => {
                        if (res._waking_pid_offset == null) {
                            res._waking_pid_offset = offset;
                        }
                        if (tag.wire == gremlin.ProtoWireType.bytes) {
                            res._waking_pid_packed = true;
                            const length_result = try buf.readVarInt(offset);
                            res._waking_pid_offset = offset + length_result.size;
                            res._waking_pid_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                            offset = res._waking_pid_last_offset.?;
                        } else {
                            const result = try buf.readInt32(offset);
                            offset += result.size;
                            res._waking_pid_last_offset = offset;
                        }
                    },
                    FtraceEventBundle.CompactSchedWire.WAKING_TARGET_CPU_WIRE => {
                        if (res._waking_target_cpu_offset == null) {
                            res._waking_target_cpu_offset = offset;
                        }
                        if (tag.wire == gremlin.ProtoWireType.bytes) {
                            res._waking_target_cpu_packed = true;
                            const length_result = try buf.readVarInt(offset);
                            res._waking_target_cpu_offset = offset + length_result.size;
                            res._waking_target_cpu_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                            offset = res._waking_target_cpu_last_offset.?;
                        } else {
                            const result = try buf.readInt32(offset);
                            offset += result.size;
                            res._waking_target_cpu_last_offset = offset;
                        }
                    },
                    FtraceEventBundle.CompactSchedWire.WAKING_PRIO_WIRE => {
                        if (res._waking_prio_offset == null) {
                            res._waking_prio_offset = offset;
                        }
                        if (tag.wire == gremlin.ProtoWireType.bytes) {
                            res._waking_prio_packed = true;
                            const length_result = try buf.readVarInt(offset);
                            res._waking_prio_offset = offset + length_result.size;
                            res._waking_prio_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                            offset = res._waking_prio_last_offset.?;
                        } else {
                            const result = try buf.readInt32(offset);
                            offset += result.size;
                            res._waking_prio_last_offset = offset;
                        }
                    },
                    FtraceEventBundle.CompactSchedWire.WAKING_COMM_INDEX_WIRE => {
                        if (res._waking_comm_index_offset == null) {
                            res._waking_comm_index_offset = offset;
                        }
                        if (tag.wire == gremlin.ProtoWireType.bytes) {
                            res._waking_comm_index_packed = true;
                            const length_result = try buf.readVarInt(offset);
                            res._waking_comm_index_offset = offset + length_result.size;
                            res._waking_comm_index_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                            offset = res._waking_comm_index_last_offset.?;
                        } else {
                            const result = try buf.readUInt32(offset);
                            offset += result.size;
                            res._waking_comm_index_last_offset = offset;
                        }
                    },
                    FtraceEventBundle.CompactSchedWire.WAKING_COMMON_FLAGS_WIRE => {
                        if (res._waking_common_flags_offset == null) {
                            res._waking_common_flags_offset = offset;
                        }
                        if (tag.wire == gremlin.ProtoWireType.bytes) {
                            res._waking_common_flags_packed = true;
                            const length_result = try buf.readVarInt(offset);
                            res._waking_common_flags_offset = offset + length_result.size;
                            res._waking_common_flags_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                            offset = res._waking_common_flags_last_offset.?;
                        } else {
                            const result = try buf.readUInt32(offset);
                            offset += result.size;
                            res._waking_common_flags_last_offset = offset;
                        }
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn internTableCount(self: *const FtraceEventBundle.CompactSchedReader) usize {
            return self._intern_table_cnt;
        }
        pub fn internTableNext(self: *FtraceEventBundle.CompactSchedReader) ?[]const u8 {
            if (self._intern_table_offset == null) return null;
            const current_offset = self._intern_table_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            if (self._intern_table_last_offset != null and current_offset >= self._intern_table_last_offset.?) {
                self._intern_table_offset = null;
                return result.value;
            }
            if (self._intern_table_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._intern_table_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == FtraceEventBundle.CompactSchedWire.INTERN_TABLE_WIRE) {
                    self._intern_table_offset = next_offset;
                    return result.value;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._intern_table_offset = null;
            return result.value;
        }
        pub fn switchTimestampNext(self: *FtraceEventBundle.CompactSchedReader) gremlin.Error!?u64 {
            if (self._switch_timestamp_offset == null) return null;
            const current_offset = self._switch_timestamp_offset.?;
            if (current_offset >= self._switch_timestamp_last_offset.?) {
                self._switch_timestamp_offset = null;
                return null;
            }
            if (self._switch_timestamp_packed) {
                const value_result = try self.buf.readUInt64(current_offset);
                self._switch_timestamp_offset = current_offset + value_result.size;
                if (self._switch_timestamp_offset.? >= self._switch_timestamp_last_offset.?) {
                    self._switch_timestamp_offset = null;
                }
                return value_result.value;
            } else {
                const value_result = try self.buf.readUInt64(current_offset);
                var next_offset = current_offset + value_result.size;
                const max_offset = self._switch_timestamp_last_offset.?;
                // Search for the next occurrence of this field
                while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                    const next_tag = try self.buf.readTagAt(next_offset);
                    next_offset += next_tag.size;
                    if (next_tag.number == FtraceEventBundle.CompactSchedWire.SWITCH_TIMESTAMP_WIRE) {
                        self._switch_timestamp_offset = next_offset;
                        return value_result.value;
                    } else {
                        next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                    }
                }
                self._switch_timestamp_offset = null;
                return value_result.value;
            }
        }
        pub fn switchPrevStateNext(self: *FtraceEventBundle.CompactSchedReader) gremlin.Error!?i64 {
            if (self._switch_prev_state_offset == null) return null;
            const current_offset = self._switch_prev_state_offset.?;
            if (current_offset >= self._switch_prev_state_last_offset.?) {
                self._switch_prev_state_offset = null;
                return null;
            }
            if (self._switch_prev_state_packed) {
                const value_result = try self.buf.readInt64(current_offset);
                self._switch_prev_state_offset = current_offset + value_result.size;
                if (self._switch_prev_state_offset.? >= self._switch_prev_state_last_offset.?) {
                    self._switch_prev_state_offset = null;
                }
                return value_result.value;
            } else {
                const value_result = try self.buf.readInt64(current_offset);
                var next_offset = current_offset + value_result.size;
                const max_offset = self._switch_prev_state_last_offset.?;
                // Search for the next occurrence of this field
                while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                    const next_tag = try self.buf.readTagAt(next_offset);
                    next_offset += next_tag.size;
                    if (next_tag.number == FtraceEventBundle.CompactSchedWire.SWITCH_PREV_STATE_WIRE) {
                        self._switch_prev_state_offset = next_offset;
                        return value_result.value;
                    } else {
                        next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                    }
                }
                self._switch_prev_state_offset = null;
                return value_result.value;
            }
        }
        pub fn switchNextPidNext(self: *FtraceEventBundle.CompactSchedReader) gremlin.Error!?i32 {
            if (self._switch_next_pid_offset == null) return null;
            const current_offset = self._switch_next_pid_offset.?;
            if (current_offset >= self._switch_next_pid_last_offset.?) {
                self._switch_next_pid_offset = null;
                return null;
            }
            if (self._switch_next_pid_packed) {
                const value_result = try self.buf.readInt32(current_offset);
                self._switch_next_pid_offset = current_offset + value_result.size;
                if (self._switch_next_pid_offset.? >= self._switch_next_pid_last_offset.?) {
                    self._switch_next_pid_offset = null;
                }
                return value_result.value;
            } else {
                const value_result = try self.buf.readInt32(current_offset);
                var next_offset = current_offset + value_result.size;
                const max_offset = self._switch_next_pid_last_offset.?;
                // Search for the next occurrence of this field
                while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                    const next_tag = try self.buf.readTagAt(next_offset);
                    next_offset += next_tag.size;
                    if (next_tag.number == FtraceEventBundle.CompactSchedWire.SWITCH_NEXT_PID_WIRE) {
                        self._switch_next_pid_offset = next_offset;
                        return value_result.value;
                    } else {
                        next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                    }
                }
                self._switch_next_pid_offset = null;
                return value_result.value;
            }
        }
        pub fn switchNextPrioNext(self: *FtraceEventBundle.CompactSchedReader) gremlin.Error!?i32 {
            if (self._switch_next_prio_offset == null) return null;
            const current_offset = self._switch_next_prio_offset.?;
            if (current_offset >= self._switch_next_prio_last_offset.?) {
                self._switch_next_prio_offset = null;
                return null;
            }
            if (self._switch_next_prio_packed) {
                const value_result = try self.buf.readInt32(current_offset);
                self._switch_next_prio_offset = current_offset + value_result.size;
                if (self._switch_next_prio_offset.? >= self._switch_next_prio_last_offset.?) {
                    self._switch_next_prio_offset = null;
                }
                return value_result.value;
            } else {
                const value_result = try self.buf.readInt32(current_offset);
                var next_offset = current_offset + value_result.size;
                const max_offset = self._switch_next_prio_last_offset.?;
                // Search for the next occurrence of this field
                while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                    const next_tag = try self.buf.readTagAt(next_offset);
                    next_offset += next_tag.size;
                    if (next_tag.number == FtraceEventBundle.CompactSchedWire.SWITCH_NEXT_PRIO_WIRE) {
                        self._switch_next_prio_offset = next_offset;
                        return value_result.value;
                    } else {
                        next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                    }
                }
                self._switch_next_prio_offset = null;
                return value_result.value;
            }
        }
        pub fn switchNextCommIndexNext(self: *FtraceEventBundle.CompactSchedReader) gremlin.Error!?u32 {
            if (self._switch_next_comm_index_offset == null) return null;
            const current_offset = self._switch_next_comm_index_offset.?;
            if (current_offset >= self._switch_next_comm_index_last_offset.?) {
                self._switch_next_comm_index_offset = null;
                return null;
            }
            if (self._switch_next_comm_index_packed) {
                const value_result = try self.buf.readUInt32(current_offset);
                self._switch_next_comm_index_offset = current_offset + value_result.size;
                if (self._switch_next_comm_index_offset.? >= self._switch_next_comm_index_last_offset.?) {
                    self._switch_next_comm_index_offset = null;
                }
                return value_result.value;
            } else {
                const value_result = try self.buf.readUInt32(current_offset);
                var next_offset = current_offset + value_result.size;
                const max_offset = self._switch_next_comm_index_last_offset.?;
                // Search for the next occurrence of this field
                while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                    const next_tag = try self.buf.readTagAt(next_offset);
                    next_offset += next_tag.size;
                    if (next_tag.number == FtraceEventBundle.CompactSchedWire.SWITCH_NEXT_COMM_INDEX_WIRE) {
                        self._switch_next_comm_index_offset = next_offset;
                        return value_result.value;
                    } else {
                        next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                    }
                }
                self._switch_next_comm_index_offset = null;
                return value_result.value;
            }
        }
        pub fn wakingTimestampNext(self: *FtraceEventBundle.CompactSchedReader) gremlin.Error!?u64 {
            if (self._waking_timestamp_offset == null) return null;
            const current_offset = self._waking_timestamp_offset.?;
            if (current_offset >= self._waking_timestamp_last_offset.?) {
                self._waking_timestamp_offset = null;
                return null;
            }
            if (self._waking_timestamp_packed) {
                const value_result = try self.buf.readUInt64(current_offset);
                self._waking_timestamp_offset = current_offset + value_result.size;
                if (self._waking_timestamp_offset.? >= self._waking_timestamp_last_offset.?) {
                    self._waking_timestamp_offset = null;
                }
                return value_result.value;
            } else {
                const value_result = try self.buf.readUInt64(current_offset);
                var next_offset = current_offset + value_result.size;
                const max_offset = self._waking_timestamp_last_offset.?;
                // Search for the next occurrence of this field
                while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                    const next_tag = try self.buf.readTagAt(next_offset);
                    next_offset += next_tag.size;
                    if (next_tag.number == FtraceEventBundle.CompactSchedWire.WAKING_TIMESTAMP_WIRE) {
                        self._waking_timestamp_offset = next_offset;
                        return value_result.value;
                    } else {
                        next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                    }
                }
                self._waking_timestamp_offset = null;
                return value_result.value;
            }
        }
        pub fn wakingPidNext(self: *FtraceEventBundle.CompactSchedReader) gremlin.Error!?i32 {
            if (self._waking_pid_offset == null) return null;
            const current_offset = self._waking_pid_offset.?;
            if (current_offset >= self._waking_pid_last_offset.?) {
                self._waking_pid_offset = null;
                return null;
            }
            if (self._waking_pid_packed) {
                const value_result = try self.buf.readInt32(current_offset);
                self._waking_pid_offset = current_offset + value_result.size;
                if (self._waking_pid_offset.? >= self._waking_pid_last_offset.?) {
                    self._waking_pid_offset = null;
                }
                return value_result.value;
            } else {
                const value_result = try self.buf.readInt32(current_offset);
                var next_offset = current_offset + value_result.size;
                const max_offset = self._waking_pid_last_offset.?;
                // Search for the next occurrence of this field
                while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                    const next_tag = try self.buf.readTagAt(next_offset);
                    next_offset += next_tag.size;
                    if (next_tag.number == FtraceEventBundle.CompactSchedWire.WAKING_PID_WIRE) {
                        self._waking_pid_offset = next_offset;
                        return value_result.value;
                    } else {
                        next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                    }
                }
                self._waking_pid_offset = null;
                return value_result.value;
            }
        }
        pub fn wakingTargetCpuNext(self: *FtraceEventBundle.CompactSchedReader) gremlin.Error!?i32 {
            if (self._waking_target_cpu_offset == null) return null;
            const current_offset = self._waking_target_cpu_offset.?;
            if (current_offset >= self._waking_target_cpu_last_offset.?) {
                self._waking_target_cpu_offset = null;
                return null;
            }
            if (self._waking_target_cpu_packed) {
                const value_result = try self.buf.readInt32(current_offset);
                self._waking_target_cpu_offset = current_offset + value_result.size;
                if (self._waking_target_cpu_offset.? >= self._waking_target_cpu_last_offset.?) {
                    self._waking_target_cpu_offset = null;
                }
                return value_result.value;
            } else {
                const value_result = try self.buf.readInt32(current_offset);
                var next_offset = current_offset + value_result.size;
                const max_offset = self._waking_target_cpu_last_offset.?;
                // Search for the next occurrence of this field
                while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                    const next_tag = try self.buf.readTagAt(next_offset);
                    next_offset += next_tag.size;
                    if (next_tag.number == FtraceEventBundle.CompactSchedWire.WAKING_TARGET_CPU_WIRE) {
                        self._waking_target_cpu_offset = next_offset;
                        return value_result.value;
                    } else {
                        next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                    }
                }
                self._waking_target_cpu_offset = null;
                return value_result.value;
            }
        }
        pub fn wakingPrioNext(self: *FtraceEventBundle.CompactSchedReader) gremlin.Error!?i32 {
            if (self._waking_prio_offset == null) return null;
            const current_offset = self._waking_prio_offset.?;
            if (current_offset >= self._waking_prio_last_offset.?) {
                self._waking_prio_offset = null;
                return null;
            }
            if (self._waking_prio_packed) {
                const value_result = try self.buf.readInt32(current_offset);
                self._waking_prio_offset = current_offset + value_result.size;
                if (self._waking_prio_offset.? >= self._waking_prio_last_offset.?) {
                    self._waking_prio_offset = null;
                }
                return value_result.value;
            } else {
                const value_result = try self.buf.readInt32(current_offset);
                var next_offset = current_offset + value_result.size;
                const max_offset = self._waking_prio_last_offset.?;
                // Search for the next occurrence of this field
                while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                    const next_tag = try self.buf.readTagAt(next_offset);
                    next_offset += next_tag.size;
                    if (next_tag.number == FtraceEventBundle.CompactSchedWire.WAKING_PRIO_WIRE) {
                        self._waking_prio_offset = next_offset;
                        return value_result.value;
                    } else {
                        next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                    }
                }
                self._waking_prio_offset = null;
                return value_result.value;
            }
        }
        pub fn wakingCommIndexNext(self: *FtraceEventBundle.CompactSchedReader) gremlin.Error!?u32 {
            if (self._waking_comm_index_offset == null) return null;
            const current_offset = self._waking_comm_index_offset.?;
            if (current_offset >= self._waking_comm_index_last_offset.?) {
                self._waking_comm_index_offset = null;
                return null;
            }
            if (self._waking_comm_index_packed) {
                const value_result = try self.buf.readUInt32(current_offset);
                self._waking_comm_index_offset = current_offset + value_result.size;
                if (self._waking_comm_index_offset.? >= self._waking_comm_index_last_offset.?) {
                    self._waking_comm_index_offset = null;
                }
                return value_result.value;
            } else {
                const value_result = try self.buf.readUInt32(current_offset);
                var next_offset = current_offset + value_result.size;
                const max_offset = self._waking_comm_index_last_offset.?;
                // Search for the next occurrence of this field
                while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                    const next_tag = try self.buf.readTagAt(next_offset);
                    next_offset += next_tag.size;
                    if (next_tag.number == FtraceEventBundle.CompactSchedWire.WAKING_COMM_INDEX_WIRE) {
                        self._waking_comm_index_offset = next_offset;
                        return value_result.value;
                    } else {
                        next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                    }
                }
                self._waking_comm_index_offset = null;
                return value_result.value;
            }
        }
        pub fn wakingCommonFlagsNext(self: *FtraceEventBundle.CompactSchedReader) gremlin.Error!?u32 {
            if (self._waking_common_flags_offset == null) return null;
            const current_offset = self._waking_common_flags_offset.?;
            if (current_offset >= self._waking_common_flags_last_offset.?) {
                self._waking_common_flags_offset = null;
                return null;
            }
            if (self._waking_common_flags_packed) {
                const value_result = try self.buf.readUInt32(current_offset);
                self._waking_common_flags_offset = current_offset + value_result.size;
                if (self._waking_common_flags_offset.? >= self._waking_common_flags_last_offset.?) {
                    self._waking_common_flags_offset = null;
                }
                return value_result.value;
            } else {
                const value_result = try self.buf.readUInt32(current_offset);
                var next_offset = current_offset + value_result.size;
                const max_offset = self._waking_common_flags_last_offset.?;
                // Search for the next occurrence of this field
                while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                    const next_tag = try self.buf.readTagAt(next_offset);
                    next_offset += next_tag.size;
                    if (next_tag.number == FtraceEventBundle.CompactSchedWire.WAKING_COMMON_FLAGS_WIRE) {
                        self._waking_common_flags_offset = next_offset;
                        return value_result.value;
                    } else {
                        next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                    }
                }
                self._waking_common_flags_offset = null;
                return value_result.value;
            }
        }
    };
    const FtraceErrorWire = struct {
        const TIMESTAMP_WIRE: gremlin.ProtoWireNumber = 1;
        const STATUS_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const FtraceError = struct {
        // fields
        timestamp: u64 = 0,
        status: ftrace_stats.FtraceParseStatus = @enumFromInt(0),
        pub fn calcProtobufSize(self: *const FtraceEventBundle.FtraceError) usize {
            var res: usize = 0;
            if (self.timestamp != 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventBundle.FtraceErrorWire.TIMESTAMP_WIRE) + gremlin.sizes.sizeU64(self.timestamp);
            }
            if (@intFromEnum(self.status) != 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventBundle.FtraceErrorWire.STATUS_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.status));
            }
            return res;
        }
        pub fn encode(self: *const FtraceEventBundle.FtraceError, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const FtraceEventBundle.FtraceError, target: *gremlin.Writer) void {
            if (self.timestamp != 0) {
                target.appendUint64(FtraceEventBundle.FtraceErrorWire.TIMESTAMP_WIRE, self.timestamp);
            }
            if (@intFromEnum(self.status) != 0) {
                target.appendInt32(FtraceEventBundle.FtraceErrorWire.STATUS_WIRE, @intFromEnum(self.status));
            }
        }
    };
    pub const FtraceErrorReader = struct {
        buf: gremlin.Reader,
        _timestamp: u64 = 0,
        _status: ftrace_stats.FtraceParseStatus = @enumFromInt(0),
        pub fn init(src: []const u8) gremlin.Error!FtraceEventBundle.FtraceErrorReader {
            const buf = gremlin.Reader.init(src);
            var res = FtraceEventBundle.FtraceErrorReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    FtraceEventBundle.FtraceErrorWire.TIMESTAMP_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._timestamp = result.value;
                    },
                    FtraceEventBundle.FtraceErrorWire.STATUS_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._status = @enumFromInt(result.value);
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getTimestamp(self: *const FtraceEventBundle.FtraceErrorReader) u64 {
            return self._timestamp;
        }
        pub inline fn getStatus(self: *const FtraceEventBundle.FtraceErrorReader) ftrace_stats.FtraceParseStatus {
            return self._status;
        }
    };
    const GenericEventDescriptorWire = struct {
        const FIELD_ID_WIRE: gremlin.ProtoWireNumber = 1;
        const GROUP_NAME_WIRE: gremlin.ProtoWireNumber = 3;
        const EVENT_DESCRIPTOR_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const GenericEventDescriptor = struct {
        // fields
        field_id: i32 = 0,
        group_name: ?[]const u8 = null,
        event_descriptor: ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const FtraceEventBundle.GenericEventDescriptor) usize {
            var res: usize = 0;
            if (self.field_id != 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventBundle.GenericEventDescriptorWire.FIELD_ID_WIRE) + gremlin.sizes.sizeI32(self.field_id);
            }
            if (self.group_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(FtraceEventBundle.GenericEventDescriptorWire.GROUP_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.event_descriptor) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(FtraceEventBundle.GenericEventDescriptorWire.EVENT_DESCRIPTOR_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            return res;
        }
        pub fn encode(self: *const FtraceEventBundle.GenericEventDescriptor, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const FtraceEventBundle.GenericEventDescriptor, target: *gremlin.Writer) void {
            if (self.field_id != 0) {
                target.appendInt32(FtraceEventBundle.GenericEventDescriptorWire.FIELD_ID_WIRE, self.field_id);
            }
            if (self.group_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(FtraceEventBundle.GenericEventDescriptorWire.GROUP_NAME_WIRE, v);
                }
            }
            if (self.event_descriptor) |v| {
                if (v.len > 0) {
                    target.appendBytes(FtraceEventBundle.GenericEventDescriptorWire.EVENT_DESCRIPTOR_WIRE, v);
                }
            }
        }
    };
    pub const GenericEventDescriptorReader = struct {
        buf: gremlin.Reader,
        _field_id: i32 = 0,
        _group_name: ?[]const u8 = null,
        _event_descriptor: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!FtraceEventBundle.GenericEventDescriptorReader {
            const buf = gremlin.Reader.init(src);
            var res = FtraceEventBundle.GenericEventDescriptorReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    FtraceEventBundle.GenericEventDescriptorWire.FIELD_ID_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._field_id = result.value;
                    },
                    FtraceEventBundle.GenericEventDescriptorWire.GROUP_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._group_name = result.value;
                    },
                    FtraceEventBundle.GenericEventDescriptorWire.EVENT_DESCRIPTOR_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._event_descriptor = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getFieldId(self: *const FtraceEventBundle.GenericEventDescriptorReader) i32 {
            return self._field_id;
        }
        pub inline fn getGroupName(self: *const FtraceEventBundle.GenericEventDescriptorReader) []const u8 {
            return self._group_name orelse &[_]u8{};
        }
        pub inline fn getEventDescriptor(self: *const FtraceEventBundle.GenericEventDescriptorReader) []const u8 {
            return self._event_descriptor orelse &[_]u8{};
        }
    };
    // fields
    cpu: u32 = 0,
    event: ?[]const ?ftrace_event.FtraceEvent = null,
    lost_events: bool = false,
    compact_sched: ?FtraceEventBundle.CompactSched = null,
    ftrace_clock: FtraceClock = @enumFromInt(0),
    ftrace_timestamp: i64 = 0,
    boot_timestamp: i64 = 0,
    error_: ?[]const ?FtraceEventBundle.FtraceError = null,
    last_read_event_timestamp: u64 = 0,
    previous_bundle_end_timestamp: u64 = 0,
    generic_event_descriptors: ?[]const ?FtraceEventBundle.GenericEventDescriptor = null,
    broken_abi_trace_page: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const FtraceEventBundle) usize {
        var res: usize = 0;
        if (self.cpu != 0) {
            res += gremlin.sizes.sizeWireNumber(FtraceEventBundleWire.CPU_WIRE) + gremlin.sizes.sizeU32(self.cpu);
        }
        if (self.event) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(FtraceEventBundleWire.EVENT_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.lost_events != false) {
            res += gremlin.sizes.sizeWireNumber(FtraceEventBundleWire.LOST_EVENTS_WIRE) + gremlin.sizes.sizeBool(self.lost_events);
        }
        if (self.compact_sched) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventBundleWire.COMPACT_SCHED_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (@intFromEnum(self.ftrace_clock) != 0) {
            res += gremlin.sizes.sizeWireNumber(FtraceEventBundleWire.FTRACE_CLOCK_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.ftrace_clock));
        }
        if (self.ftrace_timestamp != 0) {
            res += gremlin.sizes.sizeWireNumber(FtraceEventBundleWire.FTRACE_TIMESTAMP_WIRE) + gremlin.sizes.sizeI64(self.ftrace_timestamp);
        }
        if (self.boot_timestamp != 0) {
            res += gremlin.sizes.sizeWireNumber(FtraceEventBundleWire.BOOT_TIMESTAMP_WIRE) + gremlin.sizes.sizeI64(self.boot_timestamp);
        }
        if (self.error_) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(FtraceEventBundleWire.ERROR_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.last_read_event_timestamp != 0) {
            res += gremlin.sizes.sizeWireNumber(FtraceEventBundleWire.LAST_READ_EVENT_TIMESTAMP_WIRE) + gremlin.sizes.sizeU64(self.last_read_event_timestamp);
        }
        if (self.previous_bundle_end_timestamp != 0) {
            res += gremlin.sizes.sizeWireNumber(FtraceEventBundleWire.PREVIOUS_BUNDLE_END_TIMESTAMP_WIRE) + gremlin.sizes.sizeU64(self.previous_bundle_end_timestamp);
        }
        if (self.generic_event_descriptors) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(FtraceEventBundleWire.GENERIC_EVENT_DESCRIPTORS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.broken_abi_trace_page) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceEventBundleWire.BROKEN_ABI_TRACE_PAGE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const FtraceEventBundle, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const FtraceEventBundle, target: *gremlin.Writer) void {
        if (self.cpu != 0) {
            target.appendUint32(FtraceEventBundleWire.CPU_WIRE, self.cpu);
        }
        if (self.event) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(FtraceEventBundleWire.EVENT_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(FtraceEventBundleWire.EVENT_WIRE, 0);
                }
            }
        }
        if (self.lost_events != false) {
            target.appendBool(FtraceEventBundleWire.LOST_EVENTS_WIRE, self.lost_events);
        }
        if (self.compact_sched) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceEventBundleWire.COMPACT_SCHED_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (@intFromEnum(self.ftrace_clock) != 0) {
            target.appendInt32(FtraceEventBundleWire.FTRACE_CLOCK_WIRE, @intFromEnum(self.ftrace_clock));
        }
        if (self.ftrace_timestamp != 0) {
            target.appendInt64(FtraceEventBundleWire.FTRACE_TIMESTAMP_WIRE, self.ftrace_timestamp);
        }
        if (self.boot_timestamp != 0) {
            target.appendInt64(FtraceEventBundleWire.BOOT_TIMESTAMP_WIRE, self.boot_timestamp);
        }
        if (self.error_) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(FtraceEventBundleWire.ERROR_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(FtraceEventBundleWire.ERROR_WIRE, 0);
                }
            }
        }
        if (self.last_read_event_timestamp != 0) {
            target.appendUint64(FtraceEventBundleWire.LAST_READ_EVENT_TIMESTAMP_WIRE, self.last_read_event_timestamp);
        }
        if (self.previous_bundle_end_timestamp != 0) {
            target.appendUint64(FtraceEventBundleWire.PREVIOUS_BUNDLE_END_TIMESTAMP_WIRE, self.previous_bundle_end_timestamp);
        }
        if (self.generic_event_descriptors) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(FtraceEventBundleWire.GENERIC_EVENT_DESCRIPTORS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(FtraceEventBundleWire.GENERIC_EVENT_DESCRIPTORS_WIRE, 0);
                }
            }
        }
        if (self.broken_abi_trace_page) |v| {
            if (v.len > 0) {
                target.appendBytes(FtraceEventBundleWire.BROKEN_ABI_TRACE_PAGE_WIRE, v);
            }
        }
    }
};
pub const FtraceEventBundleReader = struct {
    buf: gremlin.Reader,
    _cpu: u32 = 0,
    _event_offset: ?usize = null,
    _event_last_offset: ?usize = null,
    _event_cnt: usize = 0,
    _lost_events: bool = false,
    _compact_sched_buf: ?[]const u8 = null,
    _ftrace_clock: FtraceClock = @enumFromInt(0),
    _ftrace_timestamp: i64 = 0,
    _boot_timestamp: i64 = 0,
    _error__offset: ?usize = null,
    _error__last_offset: ?usize = null,
    _error__cnt: usize = 0,
    _last_read_event_timestamp: u64 = 0,
    _previous_bundle_end_timestamp: u64 = 0,
    _generic_event_descriptors_offset: ?usize = null,
    _generic_event_descriptors_last_offset: ?usize = null,
    _generic_event_descriptors_cnt: usize = 0,
    _broken_abi_trace_page: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!FtraceEventBundleReader {
        const buf = gremlin.Reader.init(src);
        var res = FtraceEventBundleReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                FtraceEventBundleWire.CPU_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._cpu = result.value;
                },
                FtraceEventBundleWire.EVENT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._event_offset == null) {
                        res._event_offset = offset - result.size;
                    }
                    res._event_last_offset = offset;
                    res._event_cnt += 1;
                },
                FtraceEventBundleWire.LOST_EVENTS_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._lost_events = result.value;
                },
                FtraceEventBundleWire.COMPACT_SCHED_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._compact_sched_buf = result.value;
                },
                FtraceEventBundleWire.FTRACE_CLOCK_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._ftrace_clock = @enumFromInt(result.value);
                },
                FtraceEventBundleWire.FTRACE_TIMESTAMP_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._ftrace_timestamp = result.value;
                },
                FtraceEventBundleWire.BOOT_TIMESTAMP_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._boot_timestamp = result.value;
                },
                FtraceEventBundleWire.ERROR_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._error__offset == null) {
                        res._error__offset = offset - result.size;
                    }
                    res._error__last_offset = offset;
                    res._error__cnt += 1;
                },
                FtraceEventBundleWire.LAST_READ_EVENT_TIMESTAMP_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._last_read_event_timestamp = result.value;
                },
                FtraceEventBundleWire.PREVIOUS_BUNDLE_END_TIMESTAMP_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._previous_bundle_end_timestamp = result.value;
                },
                FtraceEventBundleWire.GENERIC_EVENT_DESCRIPTORS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._generic_event_descriptors_offset == null) {
                        res._generic_event_descriptors_offset = offset - result.size;
                    }
                    res._generic_event_descriptors_last_offset = offset;
                    res._generic_event_descriptors_cnt += 1;
                },
                FtraceEventBundleWire.BROKEN_ABI_TRACE_PAGE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._broken_abi_trace_page = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getCpu(self: *const FtraceEventBundleReader) u32 {
        return self._cpu;
    }
    pub fn eventCount(self: *const FtraceEventBundleReader) usize {
        return self._event_cnt;
    }
    pub fn eventNext(self: *FtraceEventBundleReader) ?ftrace_event.FtraceEventReader {
        if (self._event_offset == null) return null;
        const current_offset = self._event_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = ftrace_event.FtraceEventReader.init(result.value) catch return null;
        if (self._event_last_offset != null and current_offset >= self._event_last_offset.?) {
            self._event_offset = null;
            return msg;
        }
        if (self._event_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._event_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == FtraceEventBundleWire.EVENT_WIRE) {
                self._event_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._event_offset = null;
        return msg;
    }
    pub inline fn getLostEvents(self: *const FtraceEventBundleReader) bool {
        return self._lost_events;
    }
    pub fn getCompactSched(self: *const FtraceEventBundleReader) gremlin.Error!FtraceEventBundle.CompactSchedReader {
        if (self._compact_sched_buf) |buf| {
            return try FtraceEventBundle.CompactSchedReader.init(buf);
        }
        return try FtraceEventBundle.CompactSchedReader.init(&[_]u8{});
    }
    pub inline fn getFtraceClock(self: *const FtraceEventBundleReader) FtraceClock {
        return self._ftrace_clock;
    }
    pub inline fn getFtraceTimestamp(self: *const FtraceEventBundleReader) i64 {
        return self._ftrace_timestamp;
    }
    pub inline fn getBootTimestamp(self: *const FtraceEventBundleReader) i64 {
        return self._boot_timestamp;
    }
    pub fn errorCount(self: *const FtraceEventBundleReader) usize {
        return self._error__cnt;
    }
    pub fn errorNext(self: *FtraceEventBundleReader) ?FtraceEventBundle.FtraceErrorReader {
        if (self._error__offset == null) return null;
        const current_offset = self._error__offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = FtraceEventBundle.FtraceErrorReader.init(result.value) catch return null;
        if (self._error__last_offset != null and current_offset >= self._error__last_offset.?) {
            self._error__offset = null;
            return msg;
        }
        if (self._error__last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._error__last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == FtraceEventBundleWire.ERROR_WIRE) {
                self._error__offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._error__offset = null;
        return msg;
    }
    pub inline fn getLastReadEventTimestamp(self: *const FtraceEventBundleReader) u64 {
        return self._last_read_event_timestamp;
    }
    pub inline fn getPreviousBundleEndTimestamp(self: *const FtraceEventBundleReader) u64 {
        return self._previous_bundle_end_timestamp;
    }
    pub fn genericEventDescriptorsCount(self: *const FtraceEventBundleReader) usize {
        return self._generic_event_descriptors_cnt;
    }
    pub fn genericEventDescriptorsNext(self: *FtraceEventBundleReader) ?FtraceEventBundle.GenericEventDescriptorReader {
        if (self._generic_event_descriptors_offset == null) return null;
        const current_offset = self._generic_event_descriptors_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = FtraceEventBundle.GenericEventDescriptorReader.init(result.value) catch return null;
        if (self._generic_event_descriptors_last_offset != null and current_offset >= self._generic_event_descriptors_last_offset.?) {
            self._generic_event_descriptors_offset = null;
            return msg;
        }
        if (self._generic_event_descriptors_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._generic_event_descriptors_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == FtraceEventBundleWire.GENERIC_EVENT_DESCRIPTORS_WIRE) {
                self._generic_event_descriptors_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._generic_event_descriptors_offset = null;
        return msg;
    }
    pub inline fn getBrokenAbiTracePage(self: *const FtraceEventBundleReader) []const u8 {
        return self._broken_abi_trace_page orelse &[_]u8{};
    }
};
