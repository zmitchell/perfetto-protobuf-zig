// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const SchedSwitchFtraceEventWire = struct {
    const PREV_COMM_WIRE: gremlin.ProtoWireNumber = 1;
    const PREV_PID_WIRE: gremlin.ProtoWireNumber = 2;
    const PREV_PRIO_WIRE: gremlin.ProtoWireNumber = 3;
    const PREV_STATE_WIRE: gremlin.ProtoWireNumber = 4;
    const NEXT_COMM_WIRE: gremlin.ProtoWireNumber = 5;
    const NEXT_PID_WIRE: gremlin.ProtoWireNumber = 6;
    const NEXT_PRIO_WIRE: gremlin.ProtoWireNumber = 7;
};
pub const SchedSwitchFtraceEvent = struct {
    // fields
    prev_comm: ?[]const u8 = null,
    prev_pid: i32 = 0,
    prev_prio: i32 = 0,
    prev_state: i64 = 0,
    next_comm: ?[]const u8 = null,
    next_pid: i32 = 0,
    next_prio: i32 = 0,
    pub fn calcProtobufSize(self: *const SchedSwitchFtraceEvent) usize {
        var res: usize = 0;
        if (self.prev_comm) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(SchedSwitchFtraceEventWire.PREV_COMM_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.prev_pid != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedSwitchFtraceEventWire.PREV_PID_WIRE) + gremlin.sizes.sizeI32(self.prev_pid);
        }
        if (self.prev_prio != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedSwitchFtraceEventWire.PREV_PRIO_WIRE) + gremlin.sizes.sizeI32(self.prev_prio);
        }
        if (self.prev_state != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedSwitchFtraceEventWire.PREV_STATE_WIRE) + gremlin.sizes.sizeI64(self.prev_state);
        }
        if (self.next_comm) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(SchedSwitchFtraceEventWire.NEXT_COMM_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.next_pid != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedSwitchFtraceEventWire.NEXT_PID_WIRE) + gremlin.sizes.sizeI32(self.next_pid);
        }
        if (self.next_prio != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedSwitchFtraceEventWire.NEXT_PRIO_WIRE) + gremlin.sizes.sizeI32(self.next_prio);
        }
        return res;
    }
    pub fn encode(self: *const SchedSwitchFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SchedSwitchFtraceEvent, target: *gremlin.Writer) void {
        if (self.prev_comm) |v| {
            if (v.len > 0) {
                target.appendBytes(SchedSwitchFtraceEventWire.PREV_COMM_WIRE, v);
            }
        }
        if (self.prev_pid != 0) {
            target.appendInt32(SchedSwitchFtraceEventWire.PREV_PID_WIRE, self.prev_pid);
        }
        if (self.prev_prio != 0) {
            target.appendInt32(SchedSwitchFtraceEventWire.PREV_PRIO_WIRE, self.prev_prio);
        }
        if (self.prev_state != 0) {
            target.appendInt64(SchedSwitchFtraceEventWire.PREV_STATE_WIRE, self.prev_state);
        }
        if (self.next_comm) |v| {
            if (v.len > 0) {
                target.appendBytes(SchedSwitchFtraceEventWire.NEXT_COMM_WIRE, v);
            }
        }
        if (self.next_pid != 0) {
            target.appendInt32(SchedSwitchFtraceEventWire.NEXT_PID_WIRE, self.next_pid);
        }
        if (self.next_prio != 0) {
            target.appendInt32(SchedSwitchFtraceEventWire.NEXT_PRIO_WIRE, self.next_prio);
        }
    }
};
pub const SchedSwitchFtraceEventReader = struct {
    buf: gremlin.Reader,
    _prev_comm: ?[]const u8 = null,
    _prev_pid: i32 = 0,
    _prev_prio: i32 = 0,
    _prev_state: i64 = 0,
    _next_comm: ?[]const u8 = null,
    _next_pid: i32 = 0,
    _next_prio: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!SchedSwitchFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = SchedSwitchFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SchedSwitchFtraceEventWire.PREV_COMM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._prev_comm = result.value;
                },
                SchedSwitchFtraceEventWire.PREV_PID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._prev_pid = result.value;
                },
                SchedSwitchFtraceEventWire.PREV_PRIO_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._prev_prio = result.value;
                },
                SchedSwitchFtraceEventWire.PREV_STATE_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._prev_state = result.value;
                },
                SchedSwitchFtraceEventWire.NEXT_COMM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._next_comm = result.value;
                },
                SchedSwitchFtraceEventWire.NEXT_PID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._next_pid = result.value;
                },
                SchedSwitchFtraceEventWire.NEXT_PRIO_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._next_prio = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getPrevComm(self: *const SchedSwitchFtraceEventReader) []const u8 {
        return self._prev_comm orelse &[_]u8{};
    }
    pub inline fn getPrevPid(self: *const SchedSwitchFtraceEventReader) i32 {
        return self._prev_pid;
    }
    pub inline fn getPrevPrio(self: *const SchedSwitchFtraceEventReader) i32 {
        return self._prev_prio;
    }
    pub inline fn getPrevState(self: *const SchedSwitchFtraceEventReader) i64 {
        return self._prev_state;
    }
    pub inline fn getNextComm(self: *const SchedSwitchFtraceEventReader) []const u8 {
        return self._next_comm orelse &[_]u8{};
    }
    pub inline fn getNextPid(self: *const SchedSwitchFtraceEventReader) i32 {
        return self._next_pid;
    }
    pub inline fn getNextPrio(self: *const SchedSwitchFtraceEventReader) i32 {
        return self._next_prio;
    }
};
const SchedWakeupFtraceEventWire = struct {
    const COMM_WIRE: gremlin.ProtoWireNumber = 1;
    const PID_WIRE: gremlin.ProtoWireNumber = 2;
    const PRIO_WIRE: gremlin.ProtoWireNumber = 3;
    const SUCCESS_WIRE: gremlin.ProtoWireNumber = 4;
    const TARGET_CPU_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const SchedWakeupFtraceEvent = struct {
    // fields
    comm: ?[]const u8 = null,
    pid: i32 = 0,
    prio: i32 = 0,
    success: i32 = 0,
    target_cpu: i32 = 0,
    pub fn calcProtobufSize(self: *const SchedWakeupFtraceEvent) usize {
        var res: usize = 0;
        if (self.comm) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(SchedWakeupFtraceEventWire.COMM_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.pid != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedWakeupFtraceEventWire.PID_WIRE) + gremlin.sizes.sizeI32(self.pid);
        }
        if (self.prio != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedWakeupFtraceEventWire.PRIO_WIRE) + gremlin.sizes.sizeI32(self.prio);
        }
        if (self.success != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedWakeupFtraceEventWire.SUCCESS_WIRE) + gremlin.sizes.sizeI32(self.success);
        }
        if (self.target_cpu != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedWakeupFtraceEventWire.TARGET_CPU_WIRE) + gremlin.sizes.sizeI32(self.target_cpu);
        }
        return res;
    }
    pub fn encode(self: *const SchedWakeupFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SchedWakeupFtraceEvent, target: *gremlin.Writer) void {
        if (self.comm) |v| {
            if (v.len > 0) {
                target.appendBytes(SchedWakeupFtraceEventWire.COMM_WIRE, v);
            }
        }
        if (self.pid != 0) {
            target.appendInt32(SchedWakeupFtraceEventWire.PID_WIRE, self.pid);
        }
        if (self.prio != 0) {
            target.appendInt32(SchedWakeupFtraceEventWire.PRIO_WIRE, self.prio);
        }
        if (self.success != 0) {
            target.appendInt32(SchedWakeupFtraceEventWire.SUCCESS_WIRE, self.success);
        }
        if (self.target_cpu != 0) {
            target.appendInt32(SchedWakeupFtraceEventWire.TARGET_CPU_WIRE, self.target_cpu);
        }
    }
};
pub const SchedWakeupFtraceEventReader = struct {
    buf: gremlin.Reader,
    _comm: ?[]const u8 = null,
    _pid: i32 = 0,
    _prio: i32 = 0,
    _success: i32 = 0,
    _target_cpu: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!SchedWakeupFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = SchedWakeupFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SchedWakeupFtraceEventWire.COMM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._comm = result.value;
                },
                SchedWakeupFtraceEventWire.PID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._pid = result.value;
                },
                SchedWakeupFtraceEventWire.PRIO_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._prio = result.value;
                },
                SchedWakeupFtraceEventWire.SUCCESS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._success = result.value;
                },
                SchedWakeupFtraceEventWire.TARGET_CPU_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._target_cpu = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getComm(self: *const SchedWakeupFtraceEventReader) []const u8 {
        return self._comm orelse &[_]u8{};
    }
    pub inline fn getPid(self: *const SchedWakeupFtraceEventReader) i32 {
        return self._pid;
    }
    pub inline fn getPrio(self: *const SchedWakeupFtraceEventReader) i32 {
        return self._prio;
    }
    pub inline fn getSuccess(self: *const SchedWakeupFtraceEventReader) i32 {
        return self._success;
    }
    pub inline fn getTargetCpu(self: *const SchedWakeupFtraceEventReader) i32 {
        return self._target_cpu;
    }
};
const SchedBlockedReasonFtraceEventWire = struct {
    const PID_WIRE: gremlin.ProtoWireNumber = 1;
    const CALLER_WIRE: gremlin.ProtoWireNumber = 2;
    const IO_WAIT_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const SchedBlockedReasonFtraceEvent = struct {
    // fields
    pid: i32 = 0,
    caller: u64 = 0,
    io_wait: u32 = 0,
    pub fn calcProtobufSize(self: *const SchedBlockedReasonFtraceEvent) usize {
        var res: usize = 0;
        if (self.pid != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedBlockedReasonFtraceEventWire.PID_WIRE) + gremlin.sizes.sizeI32(self.pid);
        }
        if (self.caller != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedBlockedReasonFtraceEventWire.CALLER_WIRE) + gremlin.sizes.sizeU64(self.caller);
        }
        if (self.io_wait != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedBlockedReasonFtraceEventWire.IO_WAIT_WIRE) + gremlin.sizes.sizeU32(self.io_wait);
        }
        return res;
    }
    pub fn encode(self: *const SchedBlockedReasonFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SchedBlockedReasonFtraceEvent, target: *gremlin.Writer) void {
        if (self.pid != 0) {
            target.appendInt32(SchedBlockedReasonFtraceEventWire.PID_WIRE, self.pid);
        }
        if (self.caller != 0) {
            target.appendUint64(SchedBlockedReasonFtraceEventWire.CALLER_WIRE, self.caller);
        }
        if (self.io_wait != 0) {
            target.appendUint32(SchedBlockedReasonFtraceEventWire.IO_WAIT_WIRE, self.io_wait);
        }
    }
};
pub const SchedBlockedReasonFtraceEventReader = struct {
    buf: gremlin.Reader,
    _pid: i32 = 0,
    _caller: u64 = 0,
    _io_wait: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!SchedBlockedReasonFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = SchedBlockedReasonFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SchedBlockedReasonFtraceEventWire.PID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._pid = result.value;
                },
                SchedBlockedReasonFtraceEventWire.CALLER_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._caller = result.value;
                },
                SchedBlockedReasonFtraceEventWire.IO_WAIT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._io_wait = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getPid(self: *const SchedBlockedReasonFtraceEventReader) i32 {
        return self._pid;
    }
    pub inline fn getCaller(self: *const SchedBlockedReasonFtraceEventReader) u64 {
        return self._caller;
    }
    pub inline fn getIoWait(self: *const SchedBlockedReasonFtraceEventReader) u32 {
        return self._io_wait;
    }
};
const SchedCpuHotplugFtraceEventWire = struct {
    const AFFECTED_CPU_WIRE: gremlin.ProtoWireNumber = 1;
    const ERROR_WIRE: gremlin.ProtoWireNumber = 2;
    const STATUS_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const SchedCpuHotplugFtraceEvent = struct {
    // fields
    affected_cpu: i32 = 0,
    error_: i32 = 0,
    status: i32 = 0,
    pub fn calcProtobufSize(self: *const SchedCpuHotplugFtraceEvent) usize {
        var res: usize = 0;
        if (self.affected_cpu != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedCpuHotplugFtraceEventWire.AFFECTED_CPU_WIRE) + gremlin.sizes.sizeI32(self.affected_cpu);
        }
        if (self.error_ != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedCpuHotplugFtraceEventWire.ERROR_WIRE) + gremlin.sizes.sizeI32(self.error_);
        }
        if (self.status != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedCpuHotplugFtraceEventWire.STATUS_WIRE) + gremlin.sizes.sizeI32(self.status);
        }
        return res;
    }
    pub fn encode(self: *const SchedCpuHotplugFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SchedCpuHotplugFtraceEvent, target: *gremlin.Writer) void {
        if (self.affected_cpu != 0) {
            target.appendInt32(SchedCpuHotplugFtraceEventWire.AFFECTED_CPU_WIRE, self.affected_cpu);
        }
        if (self.error_ != 0) {
            target.appendInt32(SchedCpuHotplugFtraceEventWire.ERROR_WIRE, self.error_);
        }
        if (self.status != 0) {
            target.appendInt32(SchedCpuHotplugFtraceEventWire.STATUS_WIRE, self.status);
        }
    }
};
pub const SchedCpuHotplugFtraceEventReader = struct {
    buf: gremlin.Reader,
    _affected_cpu: i32 = 0,
    _error_: i32 = 0,
    _status: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!SchedCpuHotplugFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = SchedCpuHotplugFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SchedCpuHotplugFtraceEventWire.AFFECTED_CPU_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._affected_cpu = result.value;
                },
                SchedCpuHotplugFtraceEventWire.ERROR_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._error_ = result.value;
                },
                SchedCpuHotplugFtraceEventWire.STATUS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._status = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getAffectedCpu(self: *const SchedCpuHotplugFtraceEventReader) i32 {
        return self._affected_cpu;
    }
    pub inline fn getError(self: *const SchedCpuHotplugFtraceEventReader) i32 {
        return self._error_;
    }
    pub inline fn getStatus(self: *const SchedCpuHotplugFtraceEventReader) i32 {
        return self._status;
    }
};
const SchedWakingFtraceEventWire = struct {
    const COMM_WIRE: gremlin.ProtoWireNumber = 1;
    const PID_WIRE: gremlin.ProtoWireNumber = 2;
    const PRIO_WIRE: gremlin.ProtoWireNumber = 3;
    const SUCCESS_WIRE: gremlin.ProtoWireNumber = 4;
    const TARGET_CPU_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const SchedWakingFtraceEvent = struct {
    // fields
    comm: ?[]const u8 = null,
    pid: i32 = 0,
    prio: i32 = 0,
    success: i32 = 0,
    target_cpu: i32 = 0,
    pub fn calcProtobufSize(self: *const SchedWakingFtraceEvent) usize {
        var res: usize = 0;
        if (self.comm) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(SchedWakingFtraceEventWire.COMM_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.pid != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedWakingFtraceEventWire.PID_WIRE) + gremlin.sizes.sizeI32(self.pid);
        }
        if (self.prio != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedWakingFtraceEventWire.PRIO_WIRE) + gremlin.sizes.sizeI32(self.prio);
        }
        if (self.success != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedWakingFtraceEventWire.SUCCESS_WIRE) + gremlin.sizes.sizeI32(self.success);
        }
        if (self.target_cpu != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedWakingFtraceEventWire.TARGET_CPU_WIRE) + gremlin.sizes.sizeI32(self.target_cpu);
        }
        return res;
    }
    pub fn encode(self: *const SchedWakingFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SchedWakingFtraceEvent, target: *gremlin.Writer) void {
        if (self.comm) |v| {
            if (v.len > 0) {
                target.appendBytes(SchedWakingFtraceEventWire.COMM_WIRE, v);
            }
        }
        if (self.pid != 0) {
            target.appendInt32(SchedWakingFtraceEventWire.PID_WIRE, self.pid);
        }
        if (self.prio != 0) {
            target.appendInt32(SchedWakingFtraceEventWire.PRIO_WIRE, self.prio);
        }
        if (self.success != 0) {
            target.appendInt32(SchedWakingFtraceEventWire.SUCCESS_WIRE, self.success);
        }
        if (self.target_cpu != 0) {
            target.appendInt32(SchedWakingFtraceEventWire.TARGET_CPU_WIRE, self.target_cpu);
        }
    }
};
pub const SchedWakingFtraceEventReader = struct {
    buf: gremlin.Reader,
    _comm: ?[]const u8 = null,
    _pid: i32 = 0,
    _prio: i32 = 0,
    _success: i32 = 0,
    _target_cpu: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!SchedWakingFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = SchedWakingFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SchedWakingFtraceEventWire.COMM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._comm = result.value;
                },
                SchedWakingFtraceEventWire.PID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._pid = result.value;
                },
                SchedWakingFtraceEventWire.PRIO_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._prio = result.value;
                },
                SchedWakingFtraceEventWire.SUCCESS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._success = result.value;
                },
                SchedWakingFtraceEventWire.TARGET_CPU_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._target_cpu = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getComm(self: *const SchedWakingFtraceEventReader) []const u8 {
        return self._comm orelse &[_]u8{};
    }
    pub inline fn getPid(self: *const SchedWakingFtraceEventReader) i32 {
        return self._pid;
    }
    pub inline fn getPrio(self: *const SchedWakingFtraceEventReader) i32 {
        return self._prio;
    }
    pub inline fn getSuccess(self: *const SchedWakingFtraceEventReader) i32 {
        return self._success;
    }
    pub inline fn getTargetCpu(self: *const SchedWakingFtraceEventReader) i32 {
        return self._target_cpu;
    }
};
const SchedWakeupNewFtraceEventWire = struct {
    const COMM_WIRE: gremlin.ProtoWireNumber = 1;
    const PID_WIRE: gremlin.ProtoWireNumber = 2;
    const PRIO_WIRE: gremlin.ProtoWireNumber = 3;
    const SUCCESS_WIRE: gremlin.ProtoWireNumber = 4;
    const TARGET_CPU_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const SchedWakeupNewFtraceEvent = struct {
    // fields
    comm: ?[]const u8 = null,
    pid: i32 = 0,
    prio: i32 = 0,
    success: i32 = 0,
    target_cpu: i32 = 0,
    pub fn calcProtobufSize(self: *const SchedWakeupNewFtraceEvent) usize {
        var res: usize = 0;
        if (self.comm) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(SchedWakeupNewFtraceEventWire.COMM_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.pid != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedWakeupNewFtraceEventWire.PID_WIRE) + gremlin.sizes.sizeI32(self.pid);
        }
        if (self.prio != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedWakeupNewFtraceEventWire.PRIO_WIRE) + gremlin.sizes.sizeI32(self.prio);
        }
        if (self.success != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedWakeupNewFtraceEventWire.SUCCESS_WIRE) + gremlin.sizes.sizeI32(self.success);
        }
        if (self.target_cpu != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedWakeupNewFtraceEventWire.TARGET_CPU_WIRE) + gremlin.sizes.sizeI32(self.target_cpu);
        }
        return res;
    }
    pub fn encode(self: *const SchedWakeupNewFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SchedWakeupNewFtraceEvent, target: *gremlin.Writer) void {
        if (self.comm) |v| {
            if (v.len > 0) {
                target.appendBytes(SchedWakeupNewFtraceEventWire.COMM_WIRE, v);
            }
        }
        if (self.pid != 0) {
            target.appendInt32(SchedWakeupNewFtraceEventWire.PID_WIRE, self.pid);
        }
        if (self.prio != 0) {
            target.appendInt32(SchedWakeupNewFtraceEventWire.PRIO_WIRE, self.prio);
        }
        if (self.success != 0) {
            target.appendInt32(SchedWakeupNewFtraceEventWire.SUCCESS_WIRE, self.success);
        }
        if (self.target_cpu != 0) {
            target.appendInt32(SchedWakeupNewFtraceEventWire.TARGET_CPU_WIRE, self.target_cpu);
        }
    }
};
pub const SchedWakeupNewFtraceEventReader = struct {
    buf: gremlin.Reader,
    _comm: ?[]const u8 = null,
    _pid: i32 = 0,
    _prio: i32 = 0,
    _success: i32 = 0,
    _target_cpu: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!SchedWakeupNewFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = SchedWakeupNewFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SchedWakeupNewFtraceEventWire.COMM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._comm = result.value;
                },
                SchedWakeupNewFtraceEventWire.PID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._pid = result.value;
                },
                SchedWakeupNewFtraceEventWire.PRIO_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._prio = result.value;
                },
                SchedWakeupNewFtraceEventWire.SUCCESS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._success = result.value;
                },
                SchedWakeupNewFtraceEventWire.TARGET_CPU_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._target_cpu = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getComm(self: *const SchedWakeupNewFtraceEventReader) []const u8 {
        return self._comm orelse &[_]u8{};
    }
    pub inline fn getPid(self: *const SchedWakeupNewFtraceEventReader) i32 {
        return self._pid;
    }
    pub inline fn getPrio(self: *const SchedWakeupNewFtraceEventReader) i32 {
        return self._prio;
    }
    pub inline fn getSuccess(self: *const SchedWakeupNewFtraceEventReader) i32 {
        return self._success;
    }
    pub inline fn getTargetCpu(self: *const SchedWakeupNewFtraceEventReader) i32 {
        return self._target_cpu;
    }
};
const SchedProcessExecFtraceEventWire = struct {
    const FILENAME_WIRE: gremlin.ProtoWireNumber = 1;
    const PID_WIRE: gremlin.ProtoWireNumber = 2;
    const OLD_PID_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const SchedProcessExecFtraceEvent = struct {
    // fields
    filename: ?[]const u8 = null,
    pid: i32 = 0,
    old_pid: i32 = 0,
    pub fn calcProtobufSize(self: *const SchedProcessExecFtraceEvent) usize {
        var res: usize = 0;
        if (self.filename) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(SchedProcessExecFtraceEventWire.FILENAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.pid != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedProcessExecFtraceEventWire.PID_WIRE) + gremlin.sizes.sizeI32(self.pid);
        }
        if (self.old_pid != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedProcessExecFtraceEventWire.OLD_PID_WIRE) + gremlin.sizes.sizeI32(self.old_pid);
        }
        return res;
    }
    pub fn encode(self: *const SchedProcessExecFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SchedProcessExecFtraceEvent, target: *gremlin.Writer) void {
        if (self.filename) |v| {
            if (v.len > 0) {
                target.appendBytes(SchedProcessExecFtraceEventWire.FILENAME_WIRE, v);
            }
        }
        if (self.pid != 0) {
            target.appendInt32(SchedProcessExecFtraceEventWire.PID_WIRE, self.pid);
        }
        if (self.old_pid != 0) {
            target.appendInt32(SchedProcessExecFtraceEventWire.OLD_PID_WIRE, self.old_pid);
        }
    }
};
pub const SchedProcessExecFtraceEventReader = struct {
    buf: gremlin.Reader,
    _filename: ?[]const u8 = null,
    _pid: i32 = 0,
    _old_pid: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!SchedProcessExecFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = SchedProcessExecFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SchedProcessExecFtraceEventWire.FILENAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._filename = result.value;
                },
                SchedProcessExecFtraceEventWire.PID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._pid = result.value;
                },
                SchedProcessExecFtraceEventWire.OLD_PID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._old_pid = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getFilename(self: *const SchedProcessExecFtraceEventReader) []const u8 {
        return self._filename orelse &[_]u8{};
    }
    pub inline fn getPid(self: *const SchedProcessExecFtraceEventReader) i32 {
        return self._pid;
    }
    pub inline fn getOldPid(self: *const SchedProcessExecFtraceEventReader) i32 {
        return self._old_pid;
    }
};
const SchedProcessExitFtraceEventWire = struct {
    const COMM_WIRE: gremlin.ProtoWireNumber = 1;
    const PID_WIRE: gremlin.ProtoWireNumber = 2;
    const TGID_WIRE: gremlin.ProtoWireNumber = 3;
    const PRIO_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const SchedProcessExitFtraceEvent = struct {
    // fields
    comm: ?[]const u8 = null,
    pid: i32 = 0,
    tgid: i32 = 0,
    prio: i32 = 0,
    pub fn calcProtobufSize(self: *const SchedProcessExitFtraceEvent) usize {
        var res: usize = 0;
        if (self.comm) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(SchedProcessExitFtraceEventWire.COMM_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.pid != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedProcessExitFtraceEventWire.PID_WIRE) + gremlin.sizes.sizeI32(self.pid);
        }
        if (self.tgid != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedProcessExitFtraceEventWire.TGID_WIRE) + gremlin.sizes.sizeI32(self.tgid);
        }
        if (self.prio != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedProcessExitFtraceEventWire.PRIO_WIRE) + gremlin.sizes.sizeI32(self.prio);
        }
        return res;
    }
    pub fn encode(self: *const SchedProcessExitFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SchedProcessExitFtraceEvent, target: *gremlin.Writer) void {
        if (self.comm) |v| {
            if (v.len > 0) {
                target.appendBytes(SchedProcessExitFtraceEventWire.COMM_WIRE, v);
            }
        }
        if (self.pid != 0) {
            target.appendInt32(SchedProcessExitFtraceEventWire.PID_WIRE, self.pid);
        }
        if (self.tgid != 0) {
            target.appendInt32(SchedProcessExitFtraceEventWire.TGID_WIRE, self.tgid);
        }
        if (self.prio != 0) {
            target.appendInt32(SchedProcessExitFtraceEventWire.PRIO_WIRE, self.prio);
        }
    }
};
pub const SchedProcessExitFtraceEventReader = struct {
    buf: gremlin.Reader,
    _comm: ?[]const u8 = null,
    _pid: i32 = 0,
    _tgid: i32 = 0,
    _prio: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!SchedProcessExitFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = SchedProcessExitFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SchedProcessExitFtraceEventWire.COMM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._comm = result.value;
                },
                SchedProcessExitFtraceEventWire.PID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._pid = result.value;
                },
                SchedProcessExitFtraceEventWire.TGID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._tgid = result.value;
                },
                SchedProcessExitFtraceEventWire.PRIO_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._prio = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getComm(self: *const SchedProcessExitFtraceEventReader) []const u8 {
        return self._comm orelse &[_]u8{};
    }
    pub inline fn getPid(self: *const SchedProcessExitFtraceEventReader) i32 {
        return self._pid;
    }
    pub inline fn getTgid(self: *const SchedProcessExitFtraceEventReader) i32 {
        return self._tgid;
    }
    pub inline fn getPrio(self: *const SchedProcessExitFtraceEventReader) i32 {
        return self._prio;
    }
};
const SchedProcessForkFtraceEventWire = struct {
    const PARENT_COMM_WIRE: gremlin.ProtoWireNumber = 1;
    const PARENT_PID_WIRE: gremlin.ProtoWireNumber = 2;
    const CHILD_COMM_WIRE: gremlin.ProtoWireNumber = 3;
    const CHILD_PID_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const SchedProcessForkFtraceEvent = struct {
    // fields
    parent_comm: ?[]const u8 = null,
    parent_pid: i32 = 0,
    child_comm: ?[]const u8 = null,
    child_pid: i32 = 0,
    pub fn calcProtobufSize(self: *const SchedProcessForkFtraceEvent) usize {
        var res: usize = 0;
        if (self.parent_comm) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(SchedProcessForkFtraceEventWire.PARENT_COMM_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.parent_pid != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedProcessForkFtraceEventWire.PARENT_PID_WIRE) + gremlin.sizes.sizeI32(self.parent_pid);
        }
        if (self.child_comm) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(SchedProcessForkFtraceEventWire.CHILD_COMM_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.child_pid != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedProcessForkFtraceEventWire.CHILD_PID_WIRE) + gremlin.sizes.sizeI32(self.child_pid);
        }
        return res;
    }
    pub fn encode(self: *const SchedProcessForkFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SchedProcessForkFtraceEvent, target: *gremlin.Writer) void {
        if (self.parent_comm) |v| {
            if (v.len > 0) {
                target.appendBytes(SchedProcessForkFtraceEventWire.PARENT_COMM_WIRE, v);
            }
        }
        if (self.parent_pid != 0) {
            target.appendInt32(SchedProcessForkFtraceEventWire.PARENT_PID_WIRE, self.parent_pid);
        }
        if (self.child_comm) |v| {
            if (v.len > 0) {
                target.appendBytes(SchedProcessForkFtraceEventWire.CHILD_COMM_WIRE, v);
            }
        }
        if (self.child_pid != 0) {
            target.appendInt32(SchedProcessForkFtraceEventWire.CHILD_PID_WIRE, self.child_pid);
        }
    }
};
pub const SchedProcessForkFtraceEventReader = struct {
    buf: gremlin.Reader,
    _parent_comm: ?[]const u8 = null,
    _parent_pid: i32 = 0,
    _child_comm: ?[]const u8 = null,
    _child_pid: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!SchedProcessForkFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = SchedProcessForkFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SchedProcessForkFtraceEventWire.PARENT_COMM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._parent_comm = result.value;
                },
                SchedProcessForkFtraceEventWire.PARENT_PID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._parent_pid = result.value;
                },
                SchedProcessForkFtraceEventWire.CHILD_COMM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._child_comm = result.value;
                },
                SchedProcessForkFtraceEventWire.CHILD_PID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._child_pid = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getParentComm(self: *const SchedProcessForkFtraceEventReader) []const u8 {
        return self._parent_comm orelse &[_]u8{};
    }
    pub inline fn getParentPid(self: *const SchedProcessForkFtraceEventReader) i32 {
        return self._parent_pid;
    }
    pub inline fn getChildComm(self: *const SchedProcessForkFtraceEventReader) []const u8 {
        return self._child_comm orelse &[_]u8{};
    }
    pub inline fn getChildPid(self: *const SchedProcessForkFtraceEventReader) i32 {
        return self._child_pid;
    }
};
const SchedProcessFreeFtraceEventWire = struct {
    const COMM_WIRE: gremlin.ProtoWireNumber = 1;
    const PID_WIRE: gremlin.ProtoWireNumber = 2;
    const PRIO_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const SchedProcessFreeFtraceEvent = struct {
    // fields
    comm: ?[]const u8 = null,
    pid: i32 = 0,
    prio: i32 = 0,
    pub fn calcProtobufSize(self: *const SchedProcessFreeFtraceEvent) usize {
        var res: usize = 0;
        if (self.comm) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(SchedProcessFreeFtraceEventWire.COMM_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.pid != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedProcessFreeFtraceEventWire.PID_WIRE) + gremlin.sizes.sizeI32(self.pid);
        }
        if (self.prio != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedProcessFreeFtraceEventWire.PRIO_WIRE) + gremlin.sizes.sizeI32(self.prio);
        }
        return res;
    }
    pub fn encode(self: *const SchedProcessFreeFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SchedProcessFreeFtraceEvent, target: *gremlin.Writer) void {
        if (self.comm) |v| {
            if (v.len > 0) {
                target.appendBytes(SchedProcessFreeFtraceEventWire.COMM_WIRE, v);
            }
        }
        if (self.pid != 0) {
            target.appendInt32(SchedProcessFreeFtraceEventWire.PID_WIRE, self.pid);
        }
        if (self.prio != 0) {
            target.appendInt32(SchedProcessFreeFtraceEventWire.PRIO_WIRE, self.prio);
        }
    }
};
pub const SchedProcessFreeFtraceEventReader = struct {
    buf: gremlin.Reader,
    _comm: ?[]const u8 = null,
    _pid: i32 = 0,
    _prio: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!SchedProcessFreeFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = SchedProcessFreeFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SchedProcessFreeFtraceEventWire.COMM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._comm = result.value;
                },
                SchedProcessFreeFtraceEventWire.PID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._pid = result.value;
                },
                SchedProcessFreeFtraceEventWire.PRIO_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._prio = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getComm(self: *const SchedProcessFreeFtraceEventReader) []const u8 {
        return self._comm orelse &[_]u8{};
    }
    pub inline fn getPid(self: *const SchedProcessFreeFtraceEventReader) i32 {
        return self._pid;
    }
    pub inline fn getPrio(self: *const SchedProcessFreeFtraceEventReader) i32 {
        return self._prio;
    }
};
const SchedProcessHangFtraceEventWire = struct {
    const COMM_WIRE: gremlin.ProtoWireNumber = 1;
    const PID_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const SchedProcessHangFtraceEvent = struct {
    // fields
    comm: ?[]const u8 = null,
    pid: i32 = 0,
    pub fn calcProtobufSize(self: *const SchedProcessHangFtraceEvent) usize {
        var res: usize = 0;
        if (self.comm) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(SchedProcessHangFtraceEventWire.COMM_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.pid != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedProcessHangFtraceEventWire.PID_WIRE) + gremlin.sizes.sizeI32(self.pid);
        }
        return res;
    }
    pub fn encode(self: *const SchedProcessHangFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SchedProcessHangFtraceEvent, target: *gremlin.Writer) void {
        if (self.comm) |v| {
            if (v.len > 0) {
                target.appendBytes(SchedProcessHangFtraceEventWire.COMM_WIRE, v);
            }
        }
        if (self.pid != 0) {
            target.appendInt32(SchedProcessHangFtraceEventWire.PID_WIRE, self.pid);
        }
    }
};
pub const SchedProcessHangFtraceEventReader = struct {
    buf: gremlin.Reader,
    _comm: ?[]const u8 = null,
    _pid: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!SchedProcessHangFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = SchedProcessHangFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SchedProcessHangFtraceEventWire.COMM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._comm = result.value;
                },
                SchedProcessHangFtraceEventWire.PID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._pid = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getComm(self: *const SchedProcessHangFtraceEventReader) []const u8 {
        return self._comm orelse &[_]u8{};
    }
    pub inline fn getPid(self: *const SchedProcessHangFtraceEventReader) i32 {
        return self._pid;
    }
};
const SchedProcessWaitFtraceEventWire = struct {
    const COMM_WIRE: gremlin.ProtoWireNumber = 1;
    const PID_WIRE: gremlin.ProtoWireNumber = 2;
    const PRIO_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const SchedProcessWaitFtraceEvent = struct {
    // fields
    comm: ?[]const u8 = null,
    pid: i32 = 0,
    prio: i32 = 0,
    pub fn calcProtobufSize(self: *const SchedProcessWaitFtraceEvent) usize {
        var res: usize = 0;
        if (self.comm) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(SchedProcessWaitFtraceEventWire.COMM_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.pid != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedProcessWaitFtraceEventWire.PID_WIRE) + gremlin.sizes.sizeI32(self.pid);
        }
        if (self.prio != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedProcessWaitFtraceEventWire.PRIO_WIRE) + gremlin.sizes.sizeI32(self.prio);
        }
        return res;
    }
    pub fn encode(self: *const SchedProcessWaitFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SchedProcessWaitFtraceEvent, target: *gremlin.Writer) void {
        if (self.comm) |v| {
            if (v.len > 0) {
                target.appendBytes(SchedProcessWaitFtraceEventWire.COMM_WIRE, v);
            }
        }
        if (self.pid != 0) {
            target.appendInt32(SchedProcessWaitFtraceEventWire.PID_WIRE, self.pid);
        }
        if (self.prio != 0) {
            target.appendInt32(SchedProcessWaitFtraceEventWire.PRIO_WIRE, self.prio);
        }
    }
};
pub const SchedProcessWaitFtraceEventReader = struct {
    buf: gremlin.Reader,
    _comm: ?[]const u8 = null,
    _pid: i32 = 0,
    _prio: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!SchedProcessWaitFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = SchedProcessWaitFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SchedProcessWaitFtraceEventWire.COMM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._comm = result.value;
                },
                SchedProcessWaitFtraceEventWire.PID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._pid = result.value;
                },
                SchedProcessWaitFtraceEventWire.PRIO_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._prio = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getComm(self: *const SchedProcessWaitFtraceEventReader) []const u8 {
        return self._comm orelse &[_]u8{};
    }
    pub inline fn getPid(self: *const SchedProcessWaitFtraceEventReader) i32 {
        return self._pid;
    }
    pub inline fn getPrio(self: *const SchedProcessWaitFtraceEventReader) i32 {
        return self._prio;
    }
};
const SchedPiSetprioFtraceEventWire = struct {
    const COMM_WIRE: gremlin.ProtoWireNumber = 1;
    const NEWPRIO_WIRE: gremlin.ProtoWireNumber = 2;
    const OLDPRIO_WIRE: gremlin.ProtoWireNumber = 3;
    const PID_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const SchedPiSetprioFtraceEvent = struct {
    // fields
    comm: ?[]const u8 = null,
    newprio: i32 = 0,
    oldprio: i32 = 0,
    pid: i32 = 0,
    pub fn calcProtobufSize(self: *const SchedPiSetprioFtraceEvent) usize {
        var res: usize = 0;
        if (self.comm) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(SchedPiSetprioFtraceEventWire.COMM_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.newprio != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedPiSetprioFtraceEventWire.NEWPRIO_WIRE) + gremlin.sizes.sizeI32(self.newprio);
        }
        if (self.oldprio != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedPiSetprioFtraceEventWire.OLDPRIO_WIRE) + gremlin.sizes.sizeI32(self.oldprio);
        }
        if (self.pid != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedPiSetprioFtraceEventWire.PID_WIRE) + gremlin.sizes.sizeI32(self.pid);
        }
        return res;
    }
    pub fn encode(self: *const SchedPiSetprioFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SchedPiSetprioFtraceEvent, target: *gremlin.Writer) void {
        if (self.comm) |v| {
            if (v.len > 0) {
                target.appendBytes(SchedPiSetprioFtraceEventWire.COMM_WIRE, v);
            }
        }
        if (self.newprio != 0) {
            target.appendInt32(SchedPiSetprioFtraceEventWire.NEWPRIO_WIRE, self.newprio);
        }
        if (self.oldprio != 0) {
            target.appendInt32(SchedPiSetprioFtraceEventWire.OLDPRIO_WIRE, self.oldprio);
        }
        if (self.pid != 0) {
            target.appendInt32(SchedPiSetprioFtraceEventWire.PID_WIRE, self.pid);
        }
    }
};
pub const SchedPiSetprioFtraceEventReader = struct {
    buf: gremlin.Reader,
    _comm: ?[]const u8 = null,
    _newprio: i32 = 0,
    _oldprio: i32 = 0,
    _pid: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!SchedPiSetprioFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = SchedPiSetprioFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SchedPiSetprioFtraceEventWire.COMM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._comm = result.value;
                },
                SchedPiSetprioFtraceEventWire.NEWPRIO_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._newprio = result.value;
                },
                SchedPiSetprioFtraceEventWire.OLDPRIO_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._oldprio = result.value;
                },
                SchedPiSetprioFtraceEventWire.PID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._pid = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getComm(self: *const SchedPiSetprioFtraceEventReader) []const u8 {
        return self._comm orelse &[_]u8{};
    }
    pub inline fn getNewprio(self: *const SchedPiSetprioFtraceEventReader) i32 {
        return self._newprio;
    }
    pub inline fn getOldprio(self: *const SchedPiSetprioFtraceEventReader) i32 {
        return self._oldprio;
    }
    pub inline fn getPid(self: *const SchedPiSetprioFtraceEventReader) i32 {
        return self._pid;
    }
};
const SchedCpuUtilCfsFtraceEventWire = struct {
    const ACTIVE_WIRE: gremlin.ProtoWireNumber = 1;
    const CAPACITY_WIRE: gremlin.ProtoWireNumber = 2;
    const CAPACITY_ORIG_WIRE: gremlin.ProtoWireNumber = 3;
    const CPU_WIRE: gremlin.ProtoWireNumber = 4;
    const CPU_IMPORTANCE_WIRE: gremlin.ProtoWireNumber = 5;
    const CPU_UTIL_WIRE: gremlin.ProtoWireNumber = 6;
    const EXIT_LAT_WIRE: gremlin.ProtoWireNumber = 7;
    const GROUP_CAPACITY_WIRE: gremlin.ProtoWireNumber = 8;
    const GRP_OVERUTILIZED_WIRE: gremlin.ProtoWireNumber = 9;
    const IDLE_CPU_WIRE: gremlin.ProtoWireNumber = 10;
    const NR_RUNNING_WIRE: gremlin.ProtoWireNumber = 11;
    const SPARE_CAP_WIRE: gremlin.ProtoWireNumber = 12;
    const TASK_FITS_WIRE: gremlin.ProtoWireNumber = 13;
    const WAKE_GROUP_UTIL_WIRE: gremlin.ProtoWireNumber = 14;
    const WAKE_UTIL_WIRE: gremlin.ProtoWireNumber = 15;
};
pub const SchedCpuUtilCfsFtraceEvent = struct {
    // fields
    active: i32 = 0,
    capacity: u64 = 0,
    capacity_orig: u64 = 0,
    cpu: u32 = 0,
    cpu_importance: u64 = 0,
    cpu_util: u64 = 0,
    exit_lat: u32 = 0,
    group_capacity: u64 = 0,
    grp_overutilized: u32 = 0,
    idle_cpu: u32 = 0,
    nr_running: u32 = 0,
    spare_cap: i64 = 0,
    task_fits: u32 = 0,
    wake_group_util: u64 = 0,
    wake_util: u64 = 0,
    pub fn calcProtobufSize(self: *const SchedCpuUtilCfsFtraceEvent) usize {
        var res: usize = 0;
        if (self.active != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedCpuUtilCfsFtraceEventWire.ACTIVE_WIRE) + gremlin.sizes.sizeI32(self.active);
        }
        if (self.capacity != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedCpuUtilCfsFtraceEventWire.CAPACITY_WIRE) + gremlin.sizes.sizeU64(self.capacity);
        }
        if (self.capacity_orig != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedCpuUtilCfsFtraceEventWire.CAPACITY_ORIG_WIRE) + gremlin.sizes.sizeU64(self.capacity_orig);
        }
        if (self.cpu != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedCpuUtilCfsFtraceEventWire.CPU_WIRE) + gremlin.sizes.sizeU32(self.cpu);
        }
        if (self.cpu_importance != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedCpuUtilCfsFtraceEventWire.CPU_IMPORTANCE_WIRE) + gremlin.sizes.sizeU64(self.cpu_importance);
        }
        if (self.cpu_util != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedCpuUtilCfsFtraceEventWire.CPU_UTIL_WIRE) + gremlin.sizes.sizeU64(self.cpu_util);
        }
        if (self.exit_lat != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedCpuUtilCfsFtraceEventWire.EXIT_LAT_WIRE) + gremlin.sizes.sizeU32(self.exit_lat);
        }
        if (self.group_capacity != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedCpuUtilCfsFtraceEventWire.GROUP_CAPACITY_WIRE) + gremlin.sizes.sizeU64(self.group_capacity);
        }
        if (self.grp_overutilized != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedCpuUtilCfsFtraceEventWire.GRP_OVERUTILIZED_WIRE) + gremlin.sizes.sizeU32(self.grp_overutilized);
        }
        if (self.idle_cpu != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedCpuUtilCfsFtraceEventWire.IDLE_CPU_WIRE) + gremlin.sizes.sizeU32(self.idle_cpu);
        }
        if (self.nr_running != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedCpuUtilCfsFtraceEventWire.NR_RUNNING_WIRE) + gremlin.sizes.sizeU32(self.nr_running);
        }
        if (self.spare_cap != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedCpuUtilCfsFtraceEventWire.SPARE_CAP_WIRE) + gremlin.sizes.sizeI64(self.spare_cap);
        }
        if (self.task_fits != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedCpuUtilCfsFtraceEventWire.TASK_FITS_WIRE) + gremlin.sizes.sizeU32(self.task_fits);
        }
        if (self.wake_group_util != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedCpuUtilCfsFtraceEventWire.WAKE_GROUP_UTIL_WIRE) + gremlin.sizes.sizeU64(self.wake_group_util);
        }
        if (self.wake_util != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedCpuUtilCfsFtraceEventWire.WAKE_UTIL_WIRE) + gremlin.sizes.sizeU64(self.wake_util);
        }
        return res;
    }
    pub fn encode(self: *const SchedCpuUtilCfsFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SchedCpuUtilCfsFtraceEvent, target: *gremlin.Writer) void {
        if (self.active != 0) {
            target.appendInt32(SchedCpuUtilCfsFtraceEventWire.ACTIVE_WIRE, self.active);
        }
        if (self.capacity != 0) {
            target.appendUint64(SchedCpuUtilCfsFtraceEventWire.CAPACITY_WIRE, self.capacity);
        }
        if (self.capacity_orig != 0) {
            target.appendUint64(SchedCpuUtilCfsFtraceEventWire.CAPACITY_ORIG_WIRE, self.capacity_orig);
        }
        if (self.cpu != 0) {
            target.appendUint32(SchedCpuUtilCfsFtraceEventWire.CPU_WIRE, self.cpu);
        }
        if (self.cpu_importance != 0) {
            target.appendUint64(SchedCpuUtilCfsFtraceEventWire.CPU_IMPORTANCE_WIRE, self.cpu_importance);
        }
        if (self.cpu_util != 0) {
            target.appendUint64(SchedCpuUtilCfsFtraceEventWire.CPU_UTIL_WIRE, self.cpu_util);
        }
        if (self.exit_lat != 0) {
            target.appendUint32(SchedCpuUtilCfsFtraceEventWire.EXIT_LAT_WIRE, self.exit_lat);
        }
        if (self.group_capacity != 0) {
            target.appendUint64(SchedCpuUtilCfsFtraceEventWire.GROUP_CAPACITY_WIRE, self.group_capacity);
        }
        if (self.grp_overutilized != 0) {
            target.appendUint32(SchedCpuUtilCfsFtraceEventWire.GRP_OVERUTILIZED_WIRE, self.grp_overutilized);
        }
        if (self.idle_cpu != 0) {
            target.appendUint32(SchedCpuUtilCfsFtraceEventWire.IDLE_CPU_WIRE, self.idle_cpu);
        }
        if (self.nr_running != 0) {
            target.appendUint32(SchedCpuUtilCfsFtraceEventWire.NR_RUNNING_WIRE, self.nr_running);
        }
        if (self.spare_cap != 0) {
            target.appendInt64(SchedCpuUtilCfsFtraceEventWire.SPARE_CAP_WIRE, self.spare_cap);
        }
        if (self.task_fits != 0) {
            target.appendUint32(SchedCpuUtilCfsFtraceEventWire.TASK_FITS_WIRE, self.task_fits);
        }
        if (self.wake_group_util != 0) {
            target.appendUint64(SchedCpuUtilCfsFtraceEventWire.WAKE_GROUP_UTIL_WIRE, self.wake_group_util);
        }
        if (self.wake_util != 0) {
            target.appendUint64(SchedCpuUtilCfsFtraceEventWire.WAKE_UTIL_WIRE, self.wake_util);
        }
    }
};
pub const SchedCpuUtilCfsFtraceEventReader = struct {
    buf: gremlin.Reader,
    _active: i32 = 0,
    _capacity: u64 = 0,
    _capacity_orig: u64 = 0,
    _cpu: u32 = 0,
    _cpu_importance: u64 = 0,
    _cpu_util: u64 = 0,
    _exit_lat: u32 = 0,
    _group_capacity: u64 = 0,
    _grp_overutilized: u32 = 0,
    _idle_cpu: u32 = 0,
    _nr_running: u32 = 0,
    _spare_cap: i64 = 0,
    _task_fits: u32 = 0,
    _wake_group_util: u64 = 0,
    _wake_util: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!SchedCpuUtilCfsFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = SchedCpuUtilCfsFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SchedCpuUtilCfsFtraceEventWire.ACTIVE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._active = result.value;
                },
                SchedCpuUtilCfsFtraceEventWire.CAPACITY_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._capacity = result.value;
                },
                SchedCpuUtilCfsFtraceEventWire.CAPACITY_ORIG_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._capacity_orig = result.value;
                },
                SchedCpuUtilCfsFtraceEventWire.CPU_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._cpu = result.value;
                },
                SchedCpuUtilCfsFtraceEventWire.CPU_IMPORTANCE_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._cpu_importance = result.value;
                },
                SchedCpuUtilCfsFtraceEventWire.CPU_UTIL_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._cpu_util = result.value;
                },
                SchedCpuUtilCfsFtraceEventWire.EXIT_LAT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._exit_lat = result.value;
                },
                SchedCpuUtilCfsFtraceEventWire.GROUP_CAPACITY_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._group_capacity = result.value;
                },
                SchedCpuUtilCfsFtraceEventWire.GRP_OVERUTILIZED_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._grp_overutilized = result.value;
                },
                SchedCpuUtilCfsFtraceEventWire.IDLE_CPU_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._idle_cpu = result.value;
                },
                SchedCpuUtilCfsFtraceEventWire.NR_RUNNING_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._nr_running = result.value;
                },
                SchedCpuUtilCfsFtraceEventWire.SPARE_CAP_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._spare_cap = result.value;
                },
                SchedCpuUtilCfsFtraceEventWire.TASK_FITS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._task_fits = result.value;
                },
                SchedCpuUtilCfsFtraceEventWire.WAKE_GROUP_UTIL_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._wake_group_util = result.value;
                },
                SchedCpuUtilCfsFtraceEventWire.WAKE_UTIL_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._wake_util = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getActive(self: *const SchedCpuUtilCfsFtraceEventReader) i32 {
        return self._active;
    }
    pub inline fn getCapacity(self: *const SchedCpuUtilCfsFtraceEventReader) u64 {
        return self._capacity;
    }
    pub inline fn getCapacityOrig(self: *const SchedCpuUtilCfsFtraceEventReader) u64 {
        return self._capacity_orig;
    }
    pub inline fn getCpu(self: *const SchedCpuUtilCfsFtraceEventReader) u32 {
        return self._cpu;
    }
    pub inline fn getCpuImportance(self: *const SchedCpuUtilCfsFtraceEventReader) u64 {
        return self._cpu_importance;
    }
    pub inline fn getCpuUtil(self: *const SchedCpuUtilCfsFtraceEventReader) u64 {
        return self._cpu_util;
    }
    pub inline fn getExitLat(self: *const SchedCpuUtilCfsFtraceEventReader) u32 {
        return self._exit_lat;
    }
    pub inline fn getGroupCapacity(self: *const SchedCpuUtilCfsFtraceEventReader) u64 {
        return self._group_capacity;
    }
    pub inline fn getGrpOverutilized(self: *const SchedCpuUtilCfsFtraceEventReader) u32 {
        return self._grp_overutilized;
    }
    pub inline fn getIdleCpu(self: *const SchedCpuUtilCfsFtraceEventReader) u32 {
        return self._idle_cpu;
    }
    pub inline fn getNrRunning(self: *const SchedCpuUtilCfsFtraceEventReader) u32 {
        return self._nr_running;
    }
    pub inline fn getSpareCap(self: *const SchedCpuUtilCfsFtraceEventReader) i64 {
        return self._spare_cap;
    }
    pub inline fn getTaskFits(self: *const SchedCpuUtilCfsFtraceEventReader) u32 {
        return self._task_fits;
    }
    pub inline fn getWakeGroupUtil(self: *const SchedCpuUtilCfsFtraceEventReader) u64 {
        return self._wake_group_util;
    }
    pub inline fn getWakeUtil(self: *const SchedCpuUtilCfsFtraceEventReader) u64 {
        return self._wake_util;
    }
};
const SchedMigrateTaskFtraceEventWire = struct {
    const COMM_WIRE: gremlin.ProtoWireNumber = 1;
    const PID_WIRE: gremlin.ProtoWireNumber = 2;
    const PRIO_WIRE: gremlin.ProtoWireNumber = 3;
    const ORIG_CPU_WIRE: gremlin.ProtoWireNumber = 4;
    const DEST_CPU_WIRE: gremlin.ProtoWireNumber = 5;
    const RUNNING_WIRE: gremlin.ProtoWireNumber = 6;
    const LOAD_WIRE: gremlin.ProtoWireNumber = 7;
};
pub const SchedMigrateTaskFtraceEvent = struct {
    // fields
    comm: ?[]const u8 = null,
    pid: i32 = 0,
    prio: i32 = 0,
    orig_cpu: i32 = 0,
    dest_cpu: i32 = 0,
    running: i32 = 0,
    load: u32 = 0,
    pub fn calcProtobufSize(self: *const SchedMigrateTaskFtraceEvent) usize {
        var res: usize = 0;
        if (self.comm) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(SchedMigrateTaskFtraceEventWire.COMM_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.pid != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedMigrateTaskFtraceEventWire.PID_WIRE) + gremlin.sizes.sizeI32(self.pid);
        }
        if (self.prio != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedMigrateTaskFtraceEventWire.PRIO_WIRE) + gremlin.sizes.sizeI32(self.prio);
        }
        if (self.orig_cpu != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedMigrateTaskFtraceEventWire.ORIG_CPU_WIRE) + gremlin.sizes.sizeI32(self.orig_cpu);
        }
        if (self.dest_cpu != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedMigrateTaskFtraceEventWire.DEST_CPU_WIRE) + gremlin.sizes.sizeI32(self.dest_cpu);
        }
        if (self.running != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedMigrateTaskFtraceEventWire.RUNNING_WIRE) + gremlin.sizes.sizeI32(self.running);
        }
        if (self.load != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedMigrateTaskFtraceEventWire.LOAD_WIRE) + gremlin.sizes.sizeU32(self.load);
        }
        return res;
    }
    pub fn encode(self: *const SchedMigrateTaskFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SchedMigrateTaskFtraceEvent, target: *gremlin.Writer) void {
        if (self.comm) |v| {
            if (v.len > 0) {
                target.appendBytes(SchedMigrateTaskFtraceEventWire.COMM_WIRE, v);
            }
        }
        if (self.pid != 0) {
            target.appendInt32(SchedMigrateTaskFtraceEventWire.PID_WIRE, self.pid);
        }
        if (self.prio != 0) {
            target.appendInt32(SchedMigrateTaskFtraceEventWire.PRIO_WIRE, self.prio);
        }
        if (self.orig_cpu != 0) {
            target.appendInt32(SchedMigrateTaskFtraceEventWire.ORIG_CPU_WIRE, self.orig_cpu);
        }
        if (self.dest_cpu != 0) {
            target.appendInt32(SchedMigrateTaskFtraceEventWire.DEST_CPU_WIRE, self.dest_cpu);
        }
        if (self.running != 0) {
            target.appendInt32(SchedMigrateTaskFtraceEventWire.RUNNING_WIRE, self.running);
        }
        if (self.load != 0) {
            target.appendUint32(SchedMigrateTaskFtraceEventWire.LOAD_WIRE, self.load);
        }
    }
};
pub const SchedMigrateTaskFtraceEventReader = struct {
    buf: gremlin.Reader,
    _comm: ?[]const u8 = null,
    _pid: i32 = 0,
    _prio: i32 = 0,
    _orig_cpu: i32 = 0,
    _dest_cpu: i32 = 0,
    _running: i32 = 0,
    _load: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!SchedMigrateTaskFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = SchedMigrateTaskFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SchedMigrateTaskFtraceEventWire.COMM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._comm = result.value;
                },
                SchedMigrateTaskFtraceEventWire.PID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._pid = result.value;
                },
                SchedMigrateTaskFtraceEventWire.PRIO_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._prio = result.value;
                },
                SchedMigrateTaskFtraceEventWire.ORIG_CPU_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._orig_cpu = result.value;
                },
                SchedMigrateTaskFtraceEventWire.DEST_CPU_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._dest_cpu = result.value;
                },
                SchedMigrateTaskFtraceEventWire.RUNNING_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._running = result.value;
                },
                SchedMigrateTaskFtraceEventWire.LOAD_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._load = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getComm(self: *const SchedMigrateTaskFtraceEventReader) []const u8 {
        return self._comm orelse &[_]u8{};
    }
    pub inline fn getPid(self: *const SchedMigrateTaskFtraceEventReader) i32 {
        return self._pid;
    }
    pub inline fn getPrio(self: *const SchedMigrateTaskFtraceEventReader) i32 {
        return self._prio;
    }
    pub inline fn getOrigCpu(self: *const SchedMigrateTaskFtraceEventReader) i32 {
        return self._orig_cpu;
    }
    pub inline fn getDestCpu(self: *const SchedMigrateTaskFtraceEventReader) i32 {
        return self._dest_cpu;
    }
    pub inline fn getRunning(self: *const SchedMigrateTaskFtraceEventReader) i32 {
        return self._running;
    }
    pub inline fn getLoad(self: *const SchedMigrateTaskFtraceEventReader) u32 {
        return self._load;
    }
};
const SchedWakeupTaskAttrFtraceEventWire = struct {
    const PID_WIRE: gremlin.ProtoWireNumber = 1;
    const CPU_AFFINITY_WIRE: gremlin.ProtoWireNumber = 2;
    const TASK_UTIL_WIRE: gremlin.ProtoWireNumber = 3;
    const UCLAMP_MIN_WIRE: gremlin.ProtoWireNumber = 4;
    const VRUNTIME_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const SchedWakeupTaskAttrFtraceEvent = struct {
    // fields
    pid: i32 = 0,
    cpu_affinity: u64 = 0,
    task_util: u64 = 0,
    uclamp_min: u64 = 0,
    vruntime: u64 = 0,
    pub fn calcProtobufSize(self: *const SchedWakeupTaskAttrFtraceEvent) usize {
        var res: usize = 0;
        if (self.pid != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedWakeupTaskAttrFtraceEventWire.PID_WIRE) + gremlin.sizes.sizeI32(self.pid);
        }
        if (self.cpu_affinity != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedWakeupTaskAttrFtraceEventWire.CPU_AFFINITY_WIRE) + gremlin.sizes.sizeU64(self.cpu_affinity);
        }
        if (self.task_util != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedWakeupTaskAttrFtraceEventWire.TASK_UTIL_WIRE) + gremlin.sizes.sizeU64(self.task_util);
        }
        if (self.uclamp_min != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedWakeupTaskAttrFtraceEventWire.UCLAMP_MIN_WIRE) + gremlin.sizes.sizeU64(self.uclamp_min);
        }
        if (self.vruntime != 0) {
            res += gremlin.sizes.sizeWireNumber(SchedWakeupTaskAttrFtraceEventWire.VRUNTIME_WIRE) + gremlin.sizes.sizeU64(self.vruntime);
        }
        return res;
    }
    pub fn encode(self: *const SchedWakeupTaskAttrFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SchedWakeupTaskAttrFtraceEvent, target: *gremlin.Writer) void {
        if (self.pid != 0) {
            target.appendInt32(SchedWakeupTaskAttrFtraceEventWire.PID_WIRE, self.pid);
        }
        if (self.cpu_affinity != 0) {
            target.appendUint64(SchedWakeupTaskAttrFtraceEventWire.CPU_AFFINITY_WIRE, self.cpu_affinity);
        }
        if (self.task_util != 0) {
            target.appendUint64(SchedWakeupTaskAttrFtraceEventWire.TASK_UTIL_WIRE, self.task_util);
        }
        if (self.uclamp_min != 0) {
            target.appendUint64(SchedWakeupTaskAttrFtraceEventWire.UCLAMP_MIN_WIRE, self.uclamp_min);
        }
        if (self.vruntime != 0) {
            target.appendUint64(SchedWakeupTaskAttrFtraceEventWire.VRUNTIME_WIRE, self.vruntime);
        }
    }
};
pub const SchedWakeupTaskAttrFtraceEventReader = struct {
    buf: gremlin.Reader,
    _pid: i32 = 0,
    _cpu_affinity: u64 = 0,
    _task_util: u64 = 0,
    _uclamp_min: u64 = 0,
    _vruntime: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!SchedWakeupTaskAttrFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = SchedWakeupTaskAttrFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SchedWakeupTaskAttrFtraceEventWire.PID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._pid = result.value;
                },
                SchedWakeupTaskAttrFtraceEventWire.CPU_AFFINITY_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._cpu_affinity = result.value;
                },
                SchedWakeupTaskAttrFtraceEventWire.TASK_UTIL_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._task_util = result.value;
                },
                SchedWakeupTaskAttrFtraceEventWire.UCLAMP_MIN_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._uclamp_min = result.value;
                },
                SchedWakeupTaskAttrFtraceEventWire.VRUNTIME_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._vruntime = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getPid(self: *const SchedWakeupTaskAttrFtraceEventReader) i32 {
        return self._pid;
    }
    pub inline fn getCpuAffinity(self: *const SchedWakeupTaskAttrFtraceEventReader) u64 {
        return self._cpu_affinity;
    }
    pub inline fn getTaskUtil(self: *const SchedWakeupTaskAttrFtraceEventReader) u64 {
        return self._task_util;
    }
    pub inline fn getUclampMin(self: *const SchedWakeupTaskAttrFtraceEventReader) u64 {
        return self._uclamp_min;
    }
    pub inline fn getVruntime(self: *const SchedWakeupTaskAttrFtraceEventReader) u64 {
        return self._vruntime;
    }
};
