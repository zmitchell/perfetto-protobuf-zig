// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const F2fsDoSubmitBioFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const BTYPE_WIRE: gremlin.ProtoWireNumber = 2;
    const SYNC_WIRE: gremlin.ProtoWireNumber = 3;
    const SECTOR_WIRE: gremlin.ProtoWireNumber = 4;
    const SIZE_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const F2fsDoSubmitBioFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    btype: i32 = 0,
    sync: u32 = 0,
    sector: u64 = 0,
    size: u32 = 0,
    pub fn calcProtobufSize(self: *const F2fsDoSubmitBioFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsDoSubmitBioFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.btype != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsDoSubmitBioFtraceEventWire.BTYPE_WIRE) + gremlin.sizes.sizeI32(self.btype);
        }
        if (self.sync != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsDoSubmitBioFtraceEventWire.SYNC_WIRE) + gremlin.sizes.sizeU32(self.sync);
        }
        if (self.sector != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsDoSubmitBioFtraceEventWire.SECTOR_WIRE) + gremlin.sizes.sizeU64(self.sector);
        }
        if (self.size != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsDoSubmitBioFtraceEventWire.SIZE_WIRE) + gremlin.sizes.sizeU32(self.size);
        }
        return res;
    }
    pub fn encode(self: *const F2fsDoSubmitBioFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const F2fsDoSubmitBioFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(F2fsDoSubmitBioFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.btype != 0) {
            target.appendInt32(F2fsDoSubmitBioFtraceEventWire.BTYPE_WIRE, self.btype);
        }
        if (self.sync != 0) {
            target.appendUint32(F2fsDoSubmitBioFtraceEventWire.SYNC_WIRE, self.sync);
        }
        if (self.sector != 0) {
            target.appendUint64(F2fsDoSubmitBioFtraceEventWire.SECTOR_WIRE, self.sector);
        }
        if (self.size != 0) {
            target.appendUint32(F2fsDoSubmitBioFtraceEventWire.SIZE_WIRE, self.size);
        }
    }
};
pub const F2fsDoSubmitBioFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _btype: i32 = 0,
    _sync: u32 = 0,
    _sector: u64 = 0,
    _size: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!F2fsDoSubmitBioFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = F2fsDoSubmitBioFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                F2fsDoSubmitBioFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                F2fsDoSubmitBioFtraceEventWire.BTYPE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._btype = result.value;
                },
                F2fsDoSubmitBioFtraceEventWire.SYNC_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._sync = result.value;
                },
                F2fsDoSubmitBioFtraceEventWire.SECTOR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._sector = result.value;
                },
                F2fsDoSubmitBioFtraceEventWire.SIZE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._size = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const F2fsDoSubmitBioFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getBtype(self: *const F2fsDoSubmitBioFtraceEventReader) i32 {
        return self._btype;
    }
    pub inline fn getSync(self: *const F2fsDoSubmitBioFtraceEventReader) u32 {
        return self._sync;
    }
    pub inline fn getSector(self: *const F2fsDoSubmitBioFtraceEventReader) u64 {
        return self._sector;
    }
    pub inline fn getSize(self: *const F2fsDoSubmitBioFtraceEventReader) u32 {
        return self._size;
    }
};
const F2fsEvictInodeFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const PINO_WIRE: gremlin.ProtoWireNumber = 3;
    const MODE_WIRE: gremlin.ProtoWireNumber = 4;
    const SIZE_WIRE: gremlin.ProtoWireNumber = 5;
    const NLINK_WIRE: gremlin.ProtoWireNumber = 6;
    const BLOCKS_WIRE: gremlin.ProtoWireNumber = 7;
    const ADVISE_WIRE: gremlin.ProtoWireNumber = 8;
};
pub const F2fsEvictInodeFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    pino: u64 = 0,
    mode: u32 = 0,
    size: i64 = 0,
    nlink: u32 = 0,
    blocks: u64 = 0,
    advise: u32 = 0,
    pub fn calcProtobufSize(self: *const F2fsEvictInodeFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsEvictInodeFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsEvictInodeFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.pino != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsEvictInodeFtraceEventWire.PINO_WIRE) + gremlin.sizes.sizeU64(self.pino);
        }
        if (self.mode != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsEvictInodeFtraceEventWire.MODE_WIRE) + gremlin.sizes.sizeU32(self.mode);
        }
        if (self.size != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsEvictInodeFtraceEventWire.SIZE_WIRE) + gremlin.sizes.sizeI64(self.size);
        }
        if (self.nlink != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsEvictInodeFtraceEventWire.NLINK_WIRE) + gremlin.sizes.sizeU32(self.nlink);
        }
        if (self.blocks != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsEvictInodeFtraceEventWire.BLOCKS_WIRE) + gremlin.sizes.sizeU64(self.blocks);
        }
        if (self.advise != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsEvictInodeFtraceEventWire.ADVISE_WIRE) + gremlin.sizes.sizeU32(self.advise);
        }
        return res;
    }
    pub fn encode(self: *const F2fsEvictInodeFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const F2fsEvictInodeFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(F2fsEvictInodeFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(F2fsEvictInodeFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.pino != 0) {
            target.appendUint64(F2fsEvictInodeFtraceEventWire.PINO_WIRE, self.pino);
        }
        if (self.mode != 0) {
            target.appendUint32(F2fsEvictInodeFtraceEventWire.MODE_WIRE, self.mode);
        }
        if (self.size != 0) {
            target.appendInt64(F2fsEvictInodeFtraceEventWire.SIZE_WIRE, self.size);
        }
        if (self.nlink != 0) {
            target.appendUint32(F2fsEvictInodeFtraceEventWire.NLINK_WIRE, self.nlink);
        }
        if (self.blocks != 0) {
            target.appendUint64(F2fsEvictInodeFtraceEventWire.BLOCKS_WIRE, self.blocks);
        }
        if (self.advise != 0) {
            target.appendUint32(F2fsEvictInodeFtraceEventWire.ADVISE_WIRE, self.advise);
        }
    }
};
pub const F2fsEvictInodeFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _pino: u64 = 0,
    _mode: u32 = 0,
    _size: i64 = 0,
    _nlink: u32 = 0,
    _blocks: u64 = 0,
    _advise: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!F2fsEvictInodeFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = F2fsEvictInodeFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                F2fsEvictInodeFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                F2fsEvictInodeFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                F2fsEvictInodeFtraceEventWire.PINO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._pino = result.value;
                },
                F2fsEvictInodeFtraceEventWire.MODE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._mode = result.value;
                },
                F2fsEvictInodeFtraceEventWire.SIZE_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._size = result.value;
                },
                F2fsEvictInodeFtraceEventWire.NLINK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._nlink = result.value;
                },
                F2fsEvictInodeFtraceEventWire.BLOCKS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._blocks = result.value;
                },
                F2fsEvictInodeFtraceEventWire.ADVISE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._advise = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const F2fsEvictInodeFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const F2fsEvictInodeFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getPino(self: *const F2fsEvictInodeFtraceEventReader) u64 {
        return self._pino;
    }
    pub inline fn getMode(self: *const F2fsEvictInodeFtraceEventReader) u32 {
        return self._mode;
    }
    pub inline fn getSize(self: *const F2fsEvictInodeFtraceEventReader) i64 {
        return self._size;
    }
    pub inline fn getNlink(self: *const F2fsEvictInodeFtraceEventReader) u32 {
        return self._nlink;
    }
    pub inline fn getBlocks(self: *const F2fsEvictInodeFtraceEventReader) u64 {
        return self._blocks;
    }
    pub inline fn getAdvise(self: *const F2fsEvictInodeFtraceEventReader) u32 {
        return self._advise;
    }
};
const F2fsFallocateFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const MODE_WIRE: gremlin.ProtoWireNumber = 3;
    const OFFSET_WIRE: gremlin.ProtoWireNumber = 4;
    const LEN_WIRE: gremlin.ProtoWireNumber = 5;
    const SIZE_WIRE: gremlin.ProtoWireNumber = 6;
    const BLOCKS_WIRE: gremlin.ProtoWireNumber = 7;
    const RET_WIRE: gremlin.ProtoWireNumber = 8;
};
pub const F2fsFallocateFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    mode: i32 = 0,
    offset: i64 = 0,
    len: i64 = 0,
    size: i64 = 0,
    blocks: u64 = 0,
    ret: i32 = 0,
    pub fn calcProtobufSize(self: *const F2fsFallocateFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsFallocateFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsFallocateFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.mode != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsFallocateFtraceEventWire.MODE_WIRE) + gremlin.sizes.sizeI32(self.mode);
        }
        if (self.offset != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsFallocateFtraceEventWire.OFFSET_WIRE) + gremlin.sizes.sizeI64(self.offset);
        }
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsFallocateFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeI64(self.len);
        }
        if (self.size != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsFallocateFtraceEventWire.SIZE_WIRE) + gremlin.sizes.sizeI64(self.size);
        }
        if (self.blocks != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsFallocateFtraceEventWire.BLOCKS_WIRE) + gremlin.sizes.sizeU64(self.blocks);
        }
        if (self.ret != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsFallocateFtraceEventWire.RET_WIRE) + gremlin.sizes.sizeI32(self.ret);
        }
        return res;
    }
    pub fn encode(self: *const F2fsFallocateFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const F2fsFallocateFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(F2fsFallocateFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(F2fsFallocateFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.mode != 0) {
            target.appendInt32(F2fsFallocateFtraceEventWire.MODE_WIRE, self.mode);
        }
        if (self.offset != 0) {
            target.appendInt64(F2fsFallocateFtraceEventWire.OFFSET_WIRE, self.offset);
        }
        if (self.len != 0) {
            target.appendInt64(F2fsFallocateFtraceEventWire.LEN_WIRE, self.len);
        }
        if (self.size != 0) {
            target.appendInt64(F2fsFallocateFtraceEventWire.SIZE_WIRE, self.size);
        }
        if (self.blocks != 0) {
            target.appendUint64(F2fsFallocateFtraceEventWire.BLOCKS_WIRE, self.blocks);
        }
        if (self.ret != 0) {
            target.appendInt32(F2fsFallocateFtraceEventWire.RET_WIRE, self.ret);
        }
    }
};
pub const F2fsFallocateFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _mode: i32 = 0,
    _offset: i64 = 0,
    _len: i64 = 0,
    _size: i64 = 0,
    _blocks: u64 = 0,
    _ret: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!F2fsFallocateFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = F2fsFallocateFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                F2fsFallocateFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                F2fsFallocateFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                F2fsFallocateFtraceEventWire.MODE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._mode = result.value;
                },
                F2fsFallocateFtraceEventWire.OFFSET_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._offset = result.value;
                },
                F2fsFallocateFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                F2fsFallocateFtraceEventWire.SIZE_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._size = result.value;
                },
                F2fsFallocateFtraceEventWire.BLOCKS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._blocks = result.value;
                },
                F2fsFallocateFtraceEventWire.RET_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._ret = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const F2fsFallocateFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const F2fsFallocateFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getMode(self: *const F2fsFallocateFtraceEventReader) i32 {
        return self._mode;
    }
    pub inline fn getOffset(self: *const F2fsFallocateFtraceEventReader) i64 {
        return self._offset;
    }
    pub inline fn getLen(self: *const F2fsFallocateFtraceEventReader) i64 {
        return self._len;
    }
    pub inline fn getSize(self: *const F2fsFallocateFtraceEventReader) i64 {
        return self._size;
    }
    pub inline fn getBlocks(self: *const F2fsFallocateFtraceEventReader) u64 {
        return self._blocks;
    }
    pub inline fn getRet(self: *const F2fsFallocateFtraceEventReader) i32 {
        return self._ret;
    }
};
const F2fsGetDataBlockFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const IBLOCK_WIRE: gremlin.ProtoWireNumber = 3;
    const BH_START_WIRE: gremlin.ProtoWireNumber = 4;
    const BH_SIZE_WIRE: gremlin.ProtoWireNumber = 5;
    const RET_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const F2fsGetDataBlockFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    iblock: u64 = 0,
    bh_start: u64 = 0,
    bh_size: u64 = 0,
    ret: i32 = 0,
    pub fn calcProtobufSize(self: *const F2fsGetDataBlockFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsGetDataBlockFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsGetDataBlockFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.iblock != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsGetDataBlockFtraceEventWire.IBLOCK_WIRE) + gremlin.sizes.sizeU64(self.iblock);
        }
        if (self.bh_start != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsGetDataBlockFtraceEventWire.BH_START_WIRE) + gremlin.sizes.sizeU64(self.bh_start);
        }
        if (self.bh_size != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsGetDataBlockFtraceEventWire.BH_SIZE_WIRE) + gremlin.sizes.sizeU64(self.bh_size);
        }
        if (self.ret != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsGetDataBlockFtraceEventWire.RET_WIRE) + gremlin.sizes.sizeI32(self.ret);
        }
        return res;
    }
    pub fn encode(self: *const F2fsGetDataBlockFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const F2fsGetDataBlockFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(F2fsGetDataBlockFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(F2fsGetDataBlockFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.iblock != 0) {
            target.appendUint64(F2fsGetDataBlockFtraceEventWire.IBLOCK_WIRE, self.iblock);
        }
        if (self.bh_start != 0) {
            target.appendUint64(F2fsGetDataBlockFtraceEventWire.BH_START_WIRE, self.bh_start);
        }
        if (self.bh_size != 0) {
            target.appendUint64(F2fsGetDataBlockFtraceEventWire.BH_SIZE_WIRE, self.bh_size);
        }
        if (self.ret != 0) {
            target.appendInt32(F2fsGetDataBlockFtraceEventWire.RET_WIRE, self.ret);
        }
    }
};
pub const F2fsGetDataBlockFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _iblock: u64 = 0,
    _bh_start: u64 = 0,
    _bh_size: u64 = 0,
    _ret: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!F2fsGetDataBlockFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = F2fsGetDataBlockFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                F2fsGetDataBlockFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                F2fsGetDataBlockFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                F2fsGetDataBlockFtraceEventWire.IBLOCK_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._iblock = result.value;
                },
                F2fsGetDataBlockFtraceEventWire.BH_START_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._bh_start = result.value;
                },
                F2fsGetDataBlockFtraceEventWire.BH_SIZE_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._bh_size = result.value;
                },
                F2fsGetDataBlockFtraceEventWire.RET_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._ret = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const F2fsGetDataBlockFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const F2fsGetDataBlockFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getIblock(self: *const F2fsGetDataBlockFtraceEventReader) u64 {
        return self._iblock;
    }
    pub inline fn getBhStart(self: *const F2fsGetDataBlockFtraceEventReader) u64 {
        return self._bh_start;
    }
    pub inline fn getBhSize(self: *const F2fsGetDataBlockFtraceEventReader) u64 {
        return self._bh_size;
    }
    pub inline fn getRet(self: *const F2fsGetDataBlockFtraceEventReader) i32 {
        return self._ret;
    }
};
const F2fsGetVictimFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const TYPE_WIRE: gremlin.ProtoWireNumber = 2;
    const GC_TYPE_WIRE: gremlin.ProtoWireNumber = 3;
    const ALLOC_MODE_WIRE: gremlin.ProtoWireNumber = 4;
    const GC_MODE_WIRE: gremlin.ProtoWireNumber = 5;
    const VICTIM_WIRE: gremlin.ProtoWireNumber = 6;
    const OFS_UNIT_WIRE: gremlin.ProtoWireNumber = 7;
    const PRE_VICTIM_WIRE: gremlin.ProtoWireNumber = 8;
    const PREFREE_WIRE: gremlin.ProtoWireNumber = 9;
    const FREE_WIRE: gremlin.ProtoWireNumber = 10;
    const COST_WIRE: gremlin.ProtoWireNumber = 11;
};
pub const F2fsGetVictimFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    type: i32 = 0,
    gc_type: i32 = 0,
    alloc_mode: i32 = 0,
    gc_mode: i32 = 0,
    victim: u32 = 0,
    ofs_unit: u32 = 0,
    pre_victim: u32 = 0,
    prefree: u32 = 0,
    free: u32 = 0,
    cost: u32 = 0,
    pub fn calcProtobufSize(self: *const F2fsGetVictimFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsGetVictimFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.type != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsGetVictimFtraceEventWire.TYPE_WIRE) + gremlin.sizes.sizeI32(self.type);
        }
        if (self.gc_type != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsGetVictimFtraceEventWire.GC_TYPE_WIRE) + gremlin.sizes.sizeI32(self.gc_type);
        }
        if (self.alloc_mode != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsGetVictimFtraceEventWire.ALLOC_MODE_WIRE) + gremlin.sizes.sizeI32(self.alloc_mode);
        }
        if (self.gc_mode != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsGetVictimFtraceEventWire.GC_MODE_WIRE) + gremlin.sizes.sizeI32(self.gc_mode);
        }
        if (self.victim != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsGetVictimFtraceEventWire.VICTIM_WIRE) + gremlin.sizes.sizeU32(self.victim);
        }
        if (self.ofs_unit != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsGetVictimFtraceEventWire.OFS_UNIT_WIRE) + gremlin.sizes.sizeU32(self.ofs_unit);
        }
        if (self.pre_victim != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsGetVictimFtraceEventWire.PRE_VICTIM_WIRE) + gremlin.sizes.sizeU32(self.pre_victim);
        }
        if (self.prefree != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsGetVictimFtraceEventWire.PREFREE_WIRE) + gremlin.sizes.sizeU32(self.prefree);
        }
        if (self.free != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsGetVictimFtraceEventWire.FREE_WIRE) + gremlin.sizes.sizeU32(self.free);
        }
        if (self.cost != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsGetVictimFtraceEventWire.COST_WIRE) + gremlin.sizes.sizeU32(self.cost);
        }
        return res;
    }
    pub fn encode(self: *const F2fsGetVictimFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const F2fsGetVictimFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(F2fsGetVictimFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.type != 0) {
            target.appendInt32(F2fsGetVictimFtraceEventWire.TYPE_WIRE, self.type);
        }
        if (self.gc_type != 0) {
            target.appendInt32(F2fsGetVictimFtraceEventWire.GC_TYPE_WIRE, self.gc_type);
        }
        if (self.alloc_mode != 0) {
            target.appendInt32(F2fsGetVictimFtraceEventWire.ALLOC_MODE_WIRE, self.alloc_mode);
        }
        if (self.gc_mode != 0) {
            target.appendInt32(F2fsGetVictimFtraceEventWire.GC_MODE_WIRE, self.gc_mode);
        }
        if (self.victim != 0) {
            target.appendUint32(F2fsGetVictimFtraceEventWire.VICTIM_WIRE, self.victim);
        }
        if (self.ofs_unit != 0) {
            target.appendUint32(F2fsGetVictimFtraceEventWire.OFS_UNIT_WIRE, self.ofs_unit);
        }
        if (self.pre_victim != 0) {
            target.appendUint32(F2fsGetVictimFtraceEventWire.PRE_VICTIM_WIRE, self.pre_victim);
        }
        if (self.prefree != 0) {
            target.appendUint32(F2fsGetVictimFtraceEventWire.PREFREE_WIRE, self.prefree);
        }
        if (self.free != 0) {
            target.appendUint32(F2fsGetVictimFtraceEventWire.FREE_WIRE, self.free);
        }
        if (self.cost != 0) {
            target.appendUint32(F2fsGetVictimFtraceEventWire.COST_WIRE, self.cost);
        }
    }
};
pub const F2fsGetVictimFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _type: i32 = 0,
    _gc_type: i32 = 0,
    _alloc_mode: i32 = 0,
    _gc_mode: i32 = 0,
    _victim: u32 = 0,
    _ofs_unit: u32 = 0,
    _pre_victim: u32 = 0,
    _prefree: u32 = 0,
    _free: u32 = 0,
    _cost: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!F2fsGetVictimFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = F2fsGetVictimFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                F2fsGetVictimFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                F2fsGetVictimFtraceEventWire.TYPE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._type = result.value;
                },
                F2fsGetVictimFtraceEventWire.GC_TYPE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._gc_type = result.value;
                },
                F2fsGetVictimFtraceEventWire.ALLOC_MODE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._alloc_mode = result.value;
                },
                F2fsGetVictimFtraceEventWire.GC_MODE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._gc_mode = result.value;
                },
                F2fsGetVictimFtraceEventWire.VICTIM_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._victim = result.value;
                },
                F2fsGetVictimFtraceEventWire.OFS_UNIT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._ofs_unit = result.value;
                },
                F2fsGetVictimFtraceEventWire.PRE_VICTIM_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._pre_victim = result.value;
                },
                F2fsGetVictimFtraceEventWire.PREFREE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._prefree = result.value;
                },
                F2fsGetVictimFtraceEventWire.FREE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._free = result.value;
                },
                F2fsGetVictimFtraceEventWire.COST_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._cost = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const F2fsGetVictimFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getType(self: *const F2fsGetVictimFtraceEventReader) i32 {
        return self._type;
    }
    pub inline fn getGcType(self: *const F2fsGetVictimFtraceEventReader) i32 {
        return self._gc_type;
    }
    pub inline fn getAllocMode(self: *const F2fsGetVictimFtraceEventReader) i32 {
        return self._alloc_mode;
    }
    pub inline fn getGcMode(self: *const F2fsGetVictimFtraceEventReader) i32 {
        return self._gc_mode;
    }
    pub inline fn getVictim(self: *const F2fsGetVictimFtraceEventReader) u32 {
        return self._victim;
    }
    pub inline fn getOfsUnit(self: *const F2fsGetVictimFtraceEventReader) u32 {
        return self._ofs_unit;
    }
    pub inline fn getPreVictim(self: *const F2fsGetVictimFtraceEventReader) u32 {
        return self._pre_victim;
    }
    pub inline fn getPrefree(self: *const F2fsGetVictimFtraceEventReader) u32 {
        return self._prefree;
    }
    pub inline fn getFree(self: *const F2fsGetVictimFtraceEventReader) u32 {
        return self._free;
    }
    pub inline fn getCost(self: *const F2fsGetVictimFtraceEventReader) u32 {
        return self._cost;
    }
};
const F2fsIgetFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const PINO_WIRE: gremlin.ProtoWireNumber = 3;
    const MODE_WIRE: gremlin.ProtoWireNumber = 4;
    const SIZE_WIRE: gremlin.ProtoWireNumber = 5;
    const NLINK_WIRE: gremlin.ProtoWireNumber = 6;
    const BLOCKS_WIRE: gremlin.ProtoWireNumber = 7;
    const ADVISE_WIRE: gremlin.ProtoWireNumber = 8;
};
pub const F2fsIgetFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    pino: u64 = 0,
    mode: u32 = 0,
    size: i64 = 0,
    nlink: u32 = 0,
    blocks: u64 = 0,
    advise: u32 = 0,
    pub fn calcProtobufSize(self: *const F2fsIgetFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIgetFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIgetFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.pino != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIgetFtraceEventWire.PINO_WIRE) + gremlin.sizes.sizeU64(self.pino);
        }
        if (self.mode != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIgetFtraceEventWire.MODE_WIRE) + gremlin.sizes.sizeU32(self.mode);
        }
        if (self.size != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIgetFtraceEventWire.SIZE_WIRE) + gremlin.sizes.sizeI64(self.size);
        }
        if (self.nlink != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIgetFtraceEventWire.NLINK_WIRE) + gremlin.sizes.sizeU32(self.nlink);
        }
        if (self.blocks != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIgetFtraceEventWire.BLOCKS_WIRE) + gremlin.sizes.sizeU64(self.blocks);
        }
        if (self.advise != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIgetFtraceEventWire.ADVISE_WIRE) + gremlin.sizes.sizeU32(self.advise);
        }
        return res;
    }
    pub fn encode(self: *const F2fsIgetFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const F2fsIgetFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(F2fsIgetFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(F2fsIgetFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.pino != 0) {
            target.appendUint64(F2fsIgetFtraceEventWire.PINO_WIRE, self.pino);
        }
        if (self.mode != 0) {
            target.appendUint32(F2fsIgetFtraceEventWire.MODE_WIRE, self.mode);
        }
        if (self.size != 0) {
            target.appendInt64(F2fsIgetFtraceEventWire.SIZE_WIRE, self.size);
        }
        if (self.nlink != 0) {
            target.appendUint32(F2fsIgetFtraceEventWire.NLINK_WIRE, self.nlink);
        }
        if (self.blocks != 0) {
            target.appendUint64(F2fsIgetFtraceEventWire.BLOCKS_WIRE, self.blocks);
        }
        if (self.advise != 0) {
            target.appendUint32(F2fsIgetFtraceEventWire.ADVISE_WIRE, self.advise);
        }
    }
};
pub const F2fsIgetFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _pino: u64 = 0,
    _mode: u32 = 0,
    _size: i64 = 0,
    _nlink: u32 = 0,
    _blocks: u64 = 0,
    _advise: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!F2fsIgetFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = F2fsIgetFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                F2fsIgetFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                F2fsIgetFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                F2fsIgetFtraceEventWire.PINO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._pino = result.value;
                },
                F2fsIgetFtraceEventWire.MODE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._mode = result.value;
                },
                F2fsIgetFtraceEventWire.SIZE_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._size = result.value;
                },
                F2fsIgetFtraceEventWire.NLINK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._nlink = result.value;
                },
                F2fsIgetFtraceEventWire.BLOCKS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._blocks = result.value;
                },
                F2fsIgetFtraceEventWire.ADVISE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._advise = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const F2fsIgetFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const F2fsIgetFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getPino(self: *const F2fsIgetFtraceEventReader) u64 {
        return self._pino;
    }
    pub inline fn getMode(self: *const F2fsIgetFtraceEventReader) u32 {
        return self._mode;
    }
    pub inline fn getSize(self: *const F2fsIgetFtraceEventReader) i64 {
        return self._size;
    }
    pub inline fn getNlink(self: *const F2fsIgetFtraceEventReader) u32 {
        return self._nlink;
    }
    pub inline fn getBlocks(self: *const F2fsIgetFtraceEventReader) u64 {
        return self._blocks;
    }
    pub inline fn getAdvise(self: *const F2fsIgetFtraceEventReader) u32 {
        return self._advise;
    }
};
const F2fsIgetExitFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const RET_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const F2fsIgetExitFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    ret: i32 = 0,
    pub fn calcProtobufSize(self: *const F2fsIgetExitFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIgetExitFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIgetExitFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.ret != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIgetExitFtraceEventWire.RET_WIRE) + gremlin.sizes.sizeI32(self.ret);
        }
        return res;
    }
    pub fn encode(self: *const F2fsIgetExitFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const F2fsIgetExitFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(F2fsIgetExitFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(F2fsIgetExitFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.ret != 0) {
            target.appendInt32(F2fsIgetExitFtraceEventWire.RET_WIRE, self.ret);
        }
    }
};
pub const F2fsIgetExitFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _ret: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!F2fsIgetExitFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = F2fsIgetExitFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                F2fsIgetExitFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                F2fsIgetExitFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                F2fsIgetExitFtraceEventWire.RET_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._ret = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const F2fsIgetExitFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const F2fsIgetExitFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getRet(self: *const F2fsIgetExitFtraceEventReader) i32 {
        return self._ret;
    }
};
const F2fsNewInodeFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const RET_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const F2fsNewInodeFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    ret: i32 = 0,
    pub fn calcProtobufSize(self: *const F2fsNewInodeFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsNewInodeFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsNewInodeFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.ret != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsNewInodeFtraceEventWire.RET_WIRE) + gremlin.sizes.sizeI32(self.ret);
        }
        return res;
    }
    pub fn encode(self: *const F2fsNewInodeFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const F2fsNewInodeFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(F2fsNewInodeFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(F2fsNewInodeFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.ret != 0) {
            target.appendInt32(F2fsNewInodeFtraceEventWire.RET_WIRE, self.ret);
        }
    }
};
pub const F2fsNewInodeFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _ret: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!F2fsNewInodeFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = F2fsNewInodeFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                F2fsNewInodeFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                F2fsNewInodeFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                F2fsNewInodeFtraceEventWire.RET_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._ret = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const F2fsNewInodeFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const F2fsNewInodeFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getRet(self: *const F2fsNewInodeFtraceEventReader) i32 {
        return self._ret;
    }
};
const F2fsReadpageFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const INDEX_WIRE: gremlin.ProtoWireNumber = 3;
    const BLKADDR_WIRE: gremlin.ProtoWireNumber = 4;
    const TYPE_WIRE: gremlin.ProtoWireNumber = 5;
    const DIR_WIRE: gremlin.ProtoWireNumber = 6;
    const DIRTY_WIRE: gremlin.ProtoWireNumber = 7;
    const UPTODATE_WIRE: gremlin.ProtoWireNumber = 8;
};
pub const F2fsReadpageFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    index: u64 = 0,
    blkaddr: u64 = 0,
    type: i32 = 0,
    dir: i32 = 0,
    dirty: i32 = 0,
    uptodate: i32 = 0,
    pub fn calcProtobufSize(self: *const F2fsReadpageFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsReadpageFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsReadpageFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.index != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsReadpageFtraceEventWire.INDEX_WIRE) + gremlin.sizes.sizeU64(self.index);
        }
        if (self.blkaddr != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsReadpageFtraceEventWire.BLKADDR_WIRE) + gremlin.sizes.sizeU64(self.blkaddr);
        }
        if (self.type != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsReadpageFtraceEventWire.TYPE_WIRE) + gremlin.sizes.sizeI32(self.type);
        }
        if (self.dir != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsReadpageFtraceEventWire.DIR_WIRE) + gremlin.sizes.sizeI32(self.dir);
        }
        if (self.dirty != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsReadpageFtraceEventWire.DIRTY_WIRE) + gremlin.sizes.sizeI32(self.dirty);
        }
        if (self.uptodate != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsReadpageFtraceEventWire.UPTODATE_WIRE) + gremlin.sizes.sizeI32(self.uptodate);
        }
        return res;
    }
    pub fn encode(self: *const F2fsReadpageFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const F2fsReadpageFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(F2fsReadpageFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(F2fsReadpageFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.index != 0) {
            target.appendUint64(F2fsReadpageFtraceEventWire.INDEX_WIRE, self.index);
        }
        if (self.blkaddr != 0) {
            target.appendUint64(F2fsReadpageFtraceEventWire.BLKADDR_WIRE, self.blkaddr);
        }
        if (self.type != 0) {
            target.appendInt32(F2fsReadpageFtraceEventWire.TYPE_WIRE, self.type);
        }
        if (self.dir != 0) {
            target.appendInt32(F2fsReadpageFtraceEventWire.DIR_WIRE, self.dir);
        }
        if (self.dirty != 0) {
            target.appendInt32(F2fsReadpageFtraceEventWire.DIRTY_WIRE, self.dirty);
        }
        if (self.uptodate != 0) {
            target.appendInt32(F2fsReadpageFtraceEventWire.UPTODATE_WIRE, self.uptodate);
        }
    }
};
pub const F2fsReadpageFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _index: u64 = 0,
    _blkaddr: u64 = 0,
    _type: i32 = 0,
    _dir: i32 = 0,
    _dirty: i32 = 0,
    _uptodate: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!F2fsReadpageFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = F2fsReadpageFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                F2fsReadpageFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                F2fsReadpageFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                F2fsReadpageFtraceEventWire.INDEX_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._index = result.value;
                },
                F2fsReadpageFtraceEventWire.BLKADDR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._blkaddr = result.value;
                },
                F2fsReadpageFtraceEventWire.TYPE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._type = result.value;
                },
                F2fsReadpageFtraceEventWire.DIR_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._dir = result.value;
                },
                F2fsReadpageFtraceEventWire.DIRTY_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._dirty = result.value;
                },
                F2fsReadpageFtraceEventWire.UPTODATE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._uptodate = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const F2fsReadpageFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const F2fsReadpageFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getIndex(self: *const F2fsReadpageFtraceEventReader) u64 {
        return self._index;
    }
    pub inline fn getBlkaddr(self: *const F2fsReadpageFtraceEventReader) u64 {
        return self._blkaddr;
    }
    pub inline fn getType(self: *const F2fsReadpageFtraceEventReader) i32 {
        return self._type;
    }
    pub inline fn getDir(self: *const F2fsReadpageFtraceEventReader) i32 {
        return self._dir;
    }
    pub inline fn getDirty(self: *const F2fsReadpageFtraceEventReader) i32 {
        return self._dirty;
    }
    pub inline fn getUptodate(self: *const F2fsReadpageFtraceEventReader) i32 {
        return self._uptodate;
    }
};
const F2fsReserveNewBlockFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const NID_WIRE: gremlin.ProtoWireNumber = 2;
    const OFS_IN_NODE_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const F2fsReserveNewBlockFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    nid: u32 = 0,
    ofs_in_node: u32 = 0,
    pub fn calcProtobufSize(self: *const F2fsReserveNewBlockFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsReserveNewBlockFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.nid != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsReserveNewBlockFtraceEventWire.NID_WIRE) + gremlin.sizes.sizeU32(self.nid);
        }
        if (self.ofs_in_node != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsReserveNewBlockFtraceEventWire.OFS_IN_NODE_WIRE) + gremlin.sizes.sizeU32(self.ofs_in_node);
        }
        return res;
    }
    pub fn encode(self: *const F2fsReserveNewBlockFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const F2fsReserveNewBlockFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(F2fsReserveNewBlockFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.nid != 0) {
            target.appendUint32(F2fsReserveNewBlockFtraceEventWire.NID_WIRE, self.nid);
        }
        if (self.ofs_in_node != 0) {
            target.appendUint32(F2fsReserveNewBlockFtraceEventWire.OFS_IN_NODE_WIRE, self.ofs_in_node);
        }
    }
};
pub const F2fsReserveNewBlockFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _nid: u32 = 0,
    _ofs_in_node: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!F2fsReserveNewBlockFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = F2fsReserveNewBlockFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                F2fsReserveNewBlockFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                F2fsReserveNewBlockFtraceEventWire.NID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._nid = result.value;
                },
                F2fsReserveNewBlockFtraceEventWire.OFS_IN_NODE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._ofs_in_node = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const F2fsReserveNewBlockFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getNid(self: *const F2fsReserveNewBlockFtraceEventReader) u32 {
        return self._nid;
    }
    pub inline fn getOfsInNode(self: *const F2fsReserveNewBlockFtraceEventReader) u32 {
        return self._ofs_in_node;
    }
};
const F2fsSetPageDirtyFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const TYPE_WIRE: gremlin.ProtoWireNumber = 3;
    const DIR_WIRE: gremlin.ProtoWireNumber = 4;
    const INDEX_WIRE: gremlin.ProtoWireNumber = 5;
    const DIRTY_WIRE: gremlin.ProtoWireNumber = 6;
    const UPTODATE_WIRE: gremlin.ProtoWireNumber = 7;
};
pub const F2fsSetPageDirtyFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    type: i32 = 0,
    dir: i32 = 0,
    index: u64 = 0,
    dirty: i32 = 0,
    uptodate: i32 = 0,
    pub fn calcProtobufSize(self: *const F2fsSetPageDirtyFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsSetPageDirtyFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsSetPageDirtyFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.type != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsSetPageDirtyFtraceEventWire.TYPE_WIRE) + gremlin.sizes.sizeI32(self.type);
        }
        if (self.dir != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsSetPageDirtyFtraceEventWire.DIR_WIRE) + gremlin.sizes.sizeI32(self.dir);
        }
        if (self.index != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsSetPageDirtyFtraceEventWire.INDEX_WIRE) + gremlin.sizes.sizeU64(self.index);
        }
        if (self.dirty != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsSetPageDirtyFtraceEventWire.DIRTY_WIRE) + gremlin.sizes.sizeI32(self.dirty);
        }
        if (self.uptodate != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsSetPageDirtyFtraceEventWire.UPTODATE_WIRE) + gremlin.sizes.sizeI32(self.uptodate);
        }
        return res;
    }
    pub fn encode(self: *const F2fsSetPageDirtyFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const F2fsSetPageDirtyFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(F2fsSetPageDirtyFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(F2fsSetPageDirtyFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.type != 0) {
            target.appendInt32(F2fsSetPageDirtyFtraceEventWire.TYPE_WIRE, self.type);
        }
        if (self.dir != 0) {
            target.appendInt32(F2fsSetPageDirtyFtraceEventWire.DIR_WIRE, self.dir);
        }
        if (self.index != 0) {
            target.appendUint64(F2fsSetPageDirtyFtraceEventWire.INDEX_WIRE, self.index);
        }
        if (self.dirty != 0) {
            target.appendInt32(F2fsSetPageDirtyFtraceEventWire.DIRTY_WIRE, self.dirty);
        }
        if (self.uptodate != 0) {
            target.appendInt32(F2fsSetPageDirtyFtraceEventWire.UPTODATE_WIRE, self.uptodate);
        }
    }
};
pub const F2fsSetPageDirtyFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _type: i32 = 0,
    _dir: i32 = 0,
    _index: u64 = 0,
    _dirty: i32 = 0,
    _uptodate: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!F2fsSetPageDirtyFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = F2fsSetPageDirtyFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                F2fsSetPageDirtyFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                F2fsSetPageDirtyFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                F2fsSetPageDirtyFtraceEventWire.TYPE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._type = result.value;
                },
                F2fsSetPageDirtyFtraceEventWire.DIR_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._dir = result.value;
                },
                F2fsSetPageDirtyFtraceEventWire.INDEX_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._index = result.value;
                },
                F2fsSetPageDirtyFtraceEventWire.DIRTY_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._dirty = result.value;
                },
                F2fsSetPageDirtyFtraceEventWire.UPTODATE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._uptodate = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const F2fsSetPageDirtyFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const F2fsSetPageDirtyFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getType(self: *const F2fsSetPageDirtyFtraceEventReader) i32 {
        return self._type;
    }
    pub inline fn getDir(self: *const F2fsSetPageDirtyFtraceEventReader) i32 {
        return self._dir;
    }
    pub inline fn getIndex(self: *const F2fsSetPageDirtyFtraceEventReader) u64 {
        return self._index;
    }
    pub inline fn getDirty(self: *const F2fsSetPageDirtyFtraceEventReader) i32 {
        return self._dirty;
    }
    pub inline fn getUptodate(self: *const F2fsSetPageDirtyFtraceEventReader) i32 {
        return self._uptodate;
    }
};
const F2fsSubmitWritePageFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const TYPE_WIRE: gremlin.ProtoWireNumber = 3;
    const INDEX_WIRE: gremlin.ProtoWireNumber = 4;
    const BLOCK_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const F2fsSubmitWritePageFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    type: i32 = 0,
    index: u64 = 0,
    block: u32 = 0,
    pub fn calcProtobufSize(self: *const F2fsSubmitWritePageFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsSubmitWritePageFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsSubmitWritePageFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.type != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsSubmitWritePageFtraceEventWire.TYPE_WIRE) + gremlin.sizes.sizeI32(self.type);
        }
        if (self.index != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsSubmitWritePageFtraceEventWire.INDEX_WIRE) + gremlin.sizes.sizeU64(self.index);
        }
        if (self.block != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsSubmitWritePageFtraceEventWire.BLOCK_WIRE) + gremlin.sizes.sizeU32(self.block);
        }
        return res;
    }
    pub fn encode(self: *const F2fsSubmitWritePageFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const F2fsSubmitWritePageFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(F2fsSubmitWritePageFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(F2fsSubmitWritePageFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.type != 0) {
            target.appendInt32(F2fsSubmitWritePageFtraceEventWire.TYPE_WIRE, self.type);
        }
        if (self.index != 0) {
            target.appendUint64(F2fsSubmitWritePageFtraceEventWire.INDEX_WIRE, self.index);
        }
        if (self.block != 0) {
            target.appendUint32(F2fsSubmitWritePageFtraceEventWire.BLOCK_WIRE, self.block);
        }
    }
};
pub const F2fsSubmitWritePageFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _type: i32 = 0,
    _index: u64 = 0,
    _block: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!F2fsSubmitWritePageFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = F2fsSubmitWritePageFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                F2fsSubmitWritePageFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                F2fsSubmitWritePageFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                F2fsSubmitWritePageFtraceEventWire.TYPE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._type = result.value;
                },
                F2fsSubmitWritePageFtraceEventWire.INDEX_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._index = result.value;
                },
                F2fsSubmitWritePageFtraceEventWire.BLOCK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._block = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const F2fsSubmitWritePageFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const F2fsSubmitWritePageFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getType(self: *const F2fsSubmitWritePageFtraceEventReader) i32 {
        return self._type;
    }
    pub inline fn getIndex(self: *const F2fsSubmitWritePageFtraceEventReader) u64 {
        return self._index;
    }
    pub inline fn getBlock(self: *const F2fsSubmitWritePageFtraceEventReader) u32 {
        return self._block;
    }
};
const F2fsSyncFileEnterFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const PINO_WIRE: gremlin.ProtoWireNumber = 3;
    const MODE_WIRE: gremlin.ProtoWireNumber = 4;
    const SIZE_WIRE: gremlin.ProtoWireNumber = 5;
    const NLINK_WIRE: gremlin.ProtoWireNumber = 6;
    const BLOCKS_WIRE: gremlin.ProtoWireNumber = 7;
    const ADVISE_WIRE: gremlin.ProtoWireNumber = 8;
};
pub const F2fsSyncFileEnterFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    pino: u64 = 0,
    mode: u32 = 0,
    size: i64 = 0,
    nlink: u32 = 0,
    blocks: u64 = 0,
    advise: u32 = 0,
    pub fn calcProtobufSize(self: *const F2fsSyncFileEnterFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsSyncFileEnterFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsSyncFileEnterFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.pino != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsSyncFileEnterFtraceEventWire.PINO_WIRE) + gremlin.sizes.sizeU64(self.pino);
        }
        if (self.mode != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsSyncFileEnterFtraceEventWire.MODE_WIRE) + gremlin.sizes.sizeU32(self.mode);
        }
        if (self.size != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsSyncFileEnterFtraceEventWire.SIZE_WIRE) + gremlin.sizes.sizeI64(self.size);
        }
        if (self.nlink != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsSyncFileEnterFtraceEventWire.NLINK_WIRE) + gremlin.sizes.sizeU32(self.nlink);
        }
        if (self.blocks != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsSyncFileEnterFtraceEventWire.BLOCKS_WIRE) + gremlin.sizes.sizeU64(self.blocks);
        }
        if (self.advise != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsSyncFileEnterFtraceEventWire.ADVISE_WIRE) + gremlin.sizes.sizeU32(self.advise);
        }
        return res;
    }
    pub fn encode(self: *const F2fsSyncFileEnterFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const F2fsSyncFileEnterFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(F2fsSyncFileEnterFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(F2fsSyncFileEnterFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.pino != 0) {
            target.appendUint64(F2fsSyncFileEnterFtraceEventWire.PINO_WIRE, self.pino);
        }
        if (self.mode != 0) {
            target.appendUint32(F2fsSyncFileEnterFtraceEventWire.MODE_WIRE, self.mode);
        }
        if (self.size != 0) {
            target.appendInt64(F2fsSyncFileEnterFtraceEventWire.SIZE_WIRE, self.size);
        }
        if (self.nlink != 0) {
            target.appendUint32(F2fsSyncFileEnterFtraceEventWire.NLINK_WIRE, self.nlink);
        }
        if (self.blocks != 0) {
            target.appendUint64(F2fsSyncFileEnterFtraceEventWire.BLOCKS_WIRE, self.blocks);
        }
        if (self.advise != 0) {
            target.appendUint32(F2fsSyncFileEnterFtraceEventWire.ADVISE_WIRE, self.advise);
        }
    }
};
pub const F2fsSyncFileEnterFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _pino: u64 = 0,
    _mode: u32 = 0,
    _size: i64 = 0,
    _nlink: u32 = 0,
    _blocks: u64 = 0,
    _advise: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!F2fsSyncFileEnterFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = F2fsSyncFileEnterFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                F2fsSyncFileEnterFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                F2fsSyncFileEnterFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                F2fsSyncFileEnterFtraceEventWire.PINO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._pino = result.value;
                },
                F2fsSyncFileEnterFtraceEventWire.MODE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._mode = result.value;
                },
                F2fsSyncFileEnterFtraceEventWire.SIZE_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._size = result.value;
                },
                F2fsSyncFileEnterFtraceEventWire.NLINK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._nlink = result.value;
                },
                F2fsSyncFileEnterFtraceEventWire.BLOCKS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._blocks = result.value;
                },
                F2fsSyncFileEnterFtraceEventWire.ADVISE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._advise = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const F2fsSyncFileEnterFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const F2fsSyncFileEnterFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getPino(self: *const F2fsSyncFileEnterFtraceEventReader) u64 {
        return self._pino;
    }
    pub inline fn getMode(self: *const F2fsSyncFileEnterFtraceEventReader) u32 {
        return self._mode;
    }
    pub inline fn getSize(self: *const F2fsSyncFileEnterFtraceEventReader) i64 {
        return self._size;
    }
    pub inline fn getNlink(self: *const F2fsSyncFileEnterFtraceEventReader) u32 {
        return self._nlink;
    }
    pub inline fn getBlocks(self: *const F2fsSyncFileEnterFtraceEventReader) u64 {
        return self._blocks;
    }
    pub inline fn getAdvise(self: *const F2fsSyncFileEnterFtraceEventReader) u32 {
        return self._advise;
    }
};
const F2fsSyncFileExitFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const NEED_CP_WIRE: gremlin.ProtoWireNumber = 3;
    const DATASYNC_WIRE: gremlin.ProtoWireNumber = 4;
    const RET_WIRE: gremlin.ProtoWireNumber = 5;
    const CP_REASON_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const F2fsSyncFileExitFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    need_cp: u32 = 0,
    datasync: i32 = 0,
    ret: i32 = 0,
    cp_reason: i32 = 0,
    pub fn calcProtobufSize(self: *const F2fsSyncFileExitFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsSyncFileExitFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsSyncFileExitFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.need_cp != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsSyncFileExitFtraceEventWire.NEED_CP_WIRE) + gremlin.sizes.sizeU32(self.need_cp);
        }
        if (self.datasync != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsSyncFileExitFtraceEventWire.DATASYNC_WIRE) + gremlin.sizes.sizeI32(self.datasync);
        }
        if (self.ret != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsSyncFileExitFtraceEventWire.RET_WIRE) + gremlin.sizes.sizeI32(self.ret);
        }
        if (self.cp_reason != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsSyncFileExitFtraceEventWire.CP_REASON_WIRE) + gremlin.sizes.sizeI32(self.cp_reason);
        }
        return res;
    }
    pub fn encode(self: *const F2fsSyncFileExitFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const F2fsSyncFileExitFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(F2fsSyncFileExitFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(F2fsSyncFileExitFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.need_cp != 0) {
            target.appendUint32(F2fsSyncFileExitFtraceEventWire.NEED_CP_WIRE, self.need_cp);
        }
        if (self.datasync != 0) {
            target.appendInt32(F2fsSyncFileExitFtraceEventWire.DATASYNC_WIRE, self.datasync);
        }
        if (self.ret != 0) {
            target.appendInt32(F2fsSyncFileExitFtraceEventWire.RET_WIRE, self.ret);
        }
        if (self.cp_reason != 0) {
            target.appendInt32(F2fsSyncFileExitFtraceEventWire.CP_REASON_WIRE, self.cp_reason);
        }
    }
};
pub const F2fsSyncFileExitFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _need_cp: u32 = 0,
    _datasync: i32 = 0,
    _ret: i32 = 0,
    _cp_reason: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!F2fsSyncFileExitFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = F2fsSyncFileExitFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                F2fsSyncFileExitFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                F2fsSyncFileExitFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                F2fsSyncFileExitFtraceEventWire.NEED_CP_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._need_cp = result.value;
                },
                F2fsSyncFileExitFtraceEventWire.DATASYNC_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._datasync = result.value;
                },
                F2fsSyncFileExitFtraceEventWire.RET_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._ret = result.value;
                },
                F2fsSyncFileExitFtraceEventWire.CP_REASON_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._cp_reason = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const F2fsSyncFileExitFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const F2fsSyncFileExitFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getNeedCp(self: *const F2fsSyncFileExitFtraceEventReader) u32 {
        return self._need_cp;
    }
    pub inline fn getDatasync(self: *const F2fsSyncFileExitFtraceEventReader) i32 {
        return self._datasync;
    }
    pub inline fn getRet(self: *const F2fsSyncFileExitFtraceEventReader) i32 {
        return self._ret;
    }
    pub inline fn getCpReason(self: *const F2fsSyncFileExitFtraceEventReader) i32 {
        return self._cp_reason;
    }
};
const F2fsSyncFsFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const DIRTY_WIRE: gremlin.ProtoWireNumber = 2;
    const WAIT_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const F2fsSyncFsFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    dirty: i32 = 0,
    wait: i32 = 0,
    pub fn calcProtobufSize(self: *const F2fsSyncFsFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsSyncFsFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.dirty != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsSyncFsFtraceEventWire.DIRTY_WIRE) + gremlin.sizes.sizeI32(self.dirty);
        }
        if (self.wait != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsSyncFsFtraceEventWire.WAIT_WIRE) + gremlin.sizes.sizeI32(self.wait);
        }
        return res;
    }
    pub fn encode(self: *const F2fsSyncFsFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const F2fsSyncFsFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(F2fsSyncFsFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.dirty != 0) {
            target.appendInt32(F2fsSyncFsFtraceEventWire.DIRTY_WIRE, self.dirty);
        }
        if (self.wait != 0) {
            target.appendInt32(F2fsSyncFsFtraceEventWire.WAIT_WIRE, self.wait);
        }
    }
};
pub const F2fsSyncFsFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _dirty: i32 = 0,
    _wait: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!F2fsSyncFsFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = F2fsSyncFsFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                F2fsSyncFsFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                F2fsSyncFsFtraceEventWire.DIRTY_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._dirty = result.value;
                },
                F2fsSyncFsFtraceEventWire.WAIT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._wait = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const F2fsSyncFsFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getDirty(self: *const F2fsSyncFsFtraceEventReader) i32 {
        return self._dirty;
    }
    pub inline fn getWait(self: *const F2fsSyncFsFtraceEventReader) i32 {
        return self._wait;
    }
};
const F2fsTruncateFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const PINO_WIRE: gremlin.ProtoWireNumber = 3;
    const MODE_WIRE: gremlin.ProtoWireNumber = 4;
    const SIZE_WIRE: gremlin.ProtoWireNumber = 5;
    const NLINK_WIRE: gremlin.ProtoWireNumber = 6;
    const BLOCKS_WIRE: gremlin.ProtoWireNumber = 7;
    const ADVISE_WIRE: gremlin.ProtoWireNumber = 8;
};
pub const F2fsTruncateFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    pino: u64 = 0,
    mode: u32 = 0,
    size: i64 = 0,
    nlink: u32 = 0,
    blocks: u64 = 0,
    advise: u32 = 0,
    pub fn calcProtobufSize(self: *const F2fsTruncateFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncateFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncateFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.pino != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncateFtraceEventWire.PINO_WIRE) + gremlin.sizes.sizeU64(self.pino);
        }
        if (self.mode != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncateFtraceEventWire.MODE_WIRE) + gremlin.sizes.sizeU32(self.mode);
        }
        if (self.size != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncateFtraceEventWire.SIZE_WIRE) + gremlin.sizes.sizeI64(self.size);
        }
        if (self.nlink != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncateFtraceEventWire.NLINK_WIRE) + gremlin.sizes.sizeU32(self.nlink);
        }
        if (self.blocks != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncateFtraceEventWire.BLOCKS_WIRE) + gremlin.sizes.sizeU64(self.blocks);
        }
        if (self.advise != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncateFtraceEventWire.ADVISE_WIRE) + gremlin.sizes.sizeU32(self.advise);
        }
        return res;
    }
    pub fn encode(self: *const F2fsTruncateFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const F2fsTruncateFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(F2fsTruncateFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(F2fsTruncateFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.pino != 0) {
            target.appendUint64(F2fsTruncateFtraceEventWire.PINO_WIRE, self.pino);
        }
        if (self.mode != 0) {
            target.appendUint32(F2fsTruncateFtraceEventWire.MODE_WIRE, self.mode);
        }
        if (self.size != 0) {
            target.appendInt64(F2fsTruncateFtraceEventWire.SIZE_WIRE, self.size);
        }
        if (self.nlink != 0) {
            target.appendUint32(F2fsTruncateFtraceEventWire.NLINK_WIRE, self.nlink);
        }
        if (self.blocks != 0) {
            target.appendUint64(F2fsTruncateFtraceEventWire.BLOCKS_WIRE, self.blocks);
        }
        if (self.advise != 0) {
            target.appendUint32(F2fsTruncateFtraceEventWire.ADVISE_WIRE, self.advise);
        }
    }
};
pub const F2fsTruncateFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _pino: u64 = 0,
    _mode: u32 = 0,
    _size: i64 = 0,
    _nlink: u32 = 0,
    _blocks: u64 = 0,
    _advise: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!F2fsTruncateFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = F2fsTruncateFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                F2fsTruncateFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                F2fsTruncateFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                F2fsTruncateFtraceEventWire.PINO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._pino = result.value;
                },
                F2fsTruncateFtraceEventWire.MODE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._mode = result.value;
                },
                F2fsTruncateFtraceEventWire.SIZE_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._size = result.value;
                },
                F2fsTruncateFtraceEventWire.NLINK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._nlink = result.value;
                },
                F2fsTruncateFtraceEventWire.BLOCKS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._blocks = result.value;
                },
                F2fsTruncateFtraceEventWire.ADVISE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._advise = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const F2fsTruncateFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const F2fsTruncateFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getPino(self: *const F2fsTruncateFtraceEventReader) u64 {
        return self._pino;
    }
    pub inline fn getMode(self: *const F2fsTruncateFtraceEventReader) u32 {
        return self._mode;
    }
    pub inline fn getSize(self: *const F2fsTruncateFtraceEventReader) i64 {
        return self._size;
    }
    pub inline fn getNlink(self: *const F2fsTruncateFtraceEventReader) u32 {
        return self._nlink;
    }
    pub inline fn getBlocks(self: *const F2fsTruncateFtraceEventReader) u64 {
        return self._blocks;
    }
    pub inline fn getAdvise(self: *const F2fsTruncateFtraceEventReader) u32 {
        return self._advise;
    }
};
const F2fsTruncateBlocksEnterFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const SIZE_WIRE: gremlin.ProtoWireNumber = 3;
    const BLOCKS_WIRE: gremlin.ProtoWireNumber = 4;
    const FROM_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const F2fsTruncateBlocksEnterFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    size: i64 = 0,
    blocks: u64 = 0,
    from: u64 = 0,
    pub fn calcProtobufSize(self: *const F2fsTruncateBlocksEnterFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncateBlocksEnterFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncateBlocksEnterFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.size != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncateBlocksEnterFtraceEventWire.SIZE_WIRE) + gremlin.sizes.sizeI64(self.size);
        }
        if (self.blocks != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncateBlocksEnterFtraceEventWire.BLOCKS_WIRE) + gremlin.sizes.sizeU64(self.blocks);
        }
        if (self.from != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncateBlocksEnterFtraceEventWire.FROM_WIRE) + gremlin.sizes.sizeU64(self.from);
        }
        return res;
    }
    pub fn encode(self: *const F2fsTruncateBlocksEnterFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const F2fsTruncateBlocksEnterFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(F2fsTruncateBlocksEnterFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(F2fsTruncateBlocksEnterFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.size != 0) {
            target.appendInt64(F2fsTruncateBlocksEnterFtraceEventWire.SIZE_WIRE, self.size);
        }
        if (self.blocks != 0) {
            target.appendUint64(F2fsTruncateBlocksEnterFtraceEventWire.BLOCKS_WIRE, self.blocks);
        }
        if (self.from != 0) {
            target.appendUint64(F2fsTruncateBlocksEnterFtraceEventWire.FROM_WIRE, self.from);
        }
    }
};
pub const F2fsTruncateBlocksEnterFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _size: i64 = 0,
    _blocks: u64 = 0,
    _from: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!F2fsTruncateBlocksEnterFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = F2fsTruncateBlocksEnterFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                F2fsTruncateBlocksEnterFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                F2fsTruncateBlocksEnterFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                F2fsTruncateBlocksEnterFtraceEventWire.SIZE_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._size = result.value;
                },
                F2fsTruncateBlocksEnterFtraceEventWire.BLOCKS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._blocks = result.value;
                },
                F2fsTruncateBlocksEnterFtraceEventWire.FROM_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._from = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const F2fsTruncateBlocksEnterFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const F2fsTruncateBlocksEnterFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getSize(self: *const F2fsTruncateBlocksEnterFtraceEventReader) i64 {
        return self._size;
    }
    pub inline fn getBlocks(self: *const F2fsTruncateBlocksEnterFtraceEventReader) u64 {
        return self._blocks;
    }
    pub inline fn getFrom(self: *const F2fsTruncateBlocksEnterFtraceEventReader) u64 {
        return self._from;
    }
};
const F2fsTruncateBlocksExitFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const RET_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const F2fsTruncateBlocksExitFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    ret: i32 = 0,
    pub fn calcProtobufSize(self: *const F2fsTruncateBlocksExitFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncateBlocksExitFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncateBlocksExitFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.ret != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncateBlocksExitFtraceEventWire.RET_WIRE) + gremlin.sizes.sizeI32(self.ret);
        }
        return res;
    }
    pub fn encode(self: *const F2fsTruncateBlocksExitFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const F2fsTruncateBlocksExitFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(F2fsTruncateBlocksExitFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(F2fsTruncateBlocksExitFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.ret != 0) {
            target.appendInt32(F2fsTruncateBlocksExitFtraceEventWire.RET_WIRE, self.ret);
        }
    }
};
pub const F2fsTruncateBlocksExitFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _ret: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!F2fsTruncateBlocksExitFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = F2fsTruncateBlocksExitFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                F2fsTruncateBlocksExitFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                F2fsTruncateBlocksExitFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                F2fsTruncateBlocksExitFtraceEventWire.RET_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._ret = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const F2fsTruncateBlocksExitFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const F2fsTruncateBlocksExitFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getRet(self: *const F2fsTruncateBlocksExitFtraceEventReader) i32 {
        return self._ret;
    }
};
const F2fsTruncateDataBlocksRangeFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const NID_WIRE: gremlin.ProtoWireNumber = 3;
    const OFS_WIRE: gremlin.ProtoWireNumber = 4;
    const FREE_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const F2fsTruncateDataBlocksRangeFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    nid: u32 = 0,
    ofs: u32 = 0,
    free: i32 = 0,
    pub fn calcProtobufSize(self: *const F2fsTruncateDataBlocksRangeFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncateDataBlocksRangeFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncateDataBlocksRangeFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.nid != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncateDataBlocksRangeFtraceEventWire.NID_WIRE) + gremlin.sizes.sizeU32(self.nid);
        }
        if (self.ofs != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncateDataBlocksRangeFtraceEventWire.OFS_WIRE) + gremlin.sizes.sizeU32(self.ofs);
        }
        if (self.free != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncateDataBlocksRangeFtraceEventWire.FREE_WIRE) + gremlin.sizes.sizeI32(self.free);
        }
        return res;
    }
    pub fn encode(self: *const F2fsTruncateDataBlocksRangeFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const F2fsTruncateDataBlocksRangeFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(F2fsTruncateDataBlocksRangeFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(F2fsTruncateDataBlocksRangeFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.nid != 0) {
            target.appendUint32(F2fsTruncateDataBlocksRangeFtraceEventWire.NID_WIRE, self.nid);
        }
        if (self.ofs != 0) {
            target.appendUint32(F2fsTruncateDataBlocksRangeFtraceEventWire.OFS_WIRE, self.ofs);
        }
        if (self.free != 0) {
            target.appendInt32(F2fsTruncateDataBlocksRangeFtraceEventWire.FREE_WIRE, self.free);
        }
    }
};
pub const F2fsTruncateDataBlocksRangeFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _nid: u32 = 0,
    _ofs: u32 = 0,
    _free: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!F2fsTruncateDataBlocksRangeFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = F2fsTruncateDataBlocksRangeFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                F2fsTruncateDataBlocksRangeFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                F2fsTruncateDataBlocksRangeFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                F2fsTruncateDataBlocksRangeFtraceEventWire.NID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._nid = result.value;
                },
                F2fsTruncateDataBlocksRangeFtraceEventWire.OFS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._ofs = result.value;
                },
                F2fsTruncateDataBlocksRangeFtraceEventWire.FREE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._free = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const F2fsTruncateDataBlocksRangeFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const F2fsTruncateDataBlocksRangeFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getNid(self: *const F2fsTruncateDataBlocksRangeFtraceEventReader) u32 {
        return self._nid;
    }
    pub inline fn getOfs(self: *const F2fsTruncateDataBlocksRangeFtraceEventReader) u32 {
        return self._ofs;
    }
    pub inline fn getFree(self: *const F2fsTruncateDataBlocksRangeFtraceEventReader) i32 {
        return self._free;
    }
};
const F2fsTruncateInodeBlocksEnterFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const SIZE_WIRE: gremlin.ProtoWireNumber = 3;
    const BLOCKS_WIRE: gremlin.ProtoWireNumber = 4;
    const FROM_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const F2fsTruncateInodeBlocksEnterFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    size: i64 = 0,
    blocks: u64 = 0,
    from: u64 = 0,
    pub fn calcProtobufSize(self: *const F2fsTruncateInodeBlocksEnterFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncateInodeBlocksEnterFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncateInodeBlocksEnterFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.size != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncateInodeBlocksEnterFtraceEventWire.SIZE_WIRE) + gremlin.sizes.sizeI64(self.size);
        }
        if (self.blocks != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncateInodeBlocksEnterFtraceEventWire.BLOCKS_WIRE) + gremlin.sizes.sizeU64(self.blocks);
        }
        if (self.from != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncateInodeBlocksEnterFtraceEventWire.FROM_WIRE) + gremlin.sizes.sizeU64(self.from);
        }
        return res;
    }
    pub fn encode(self: *const F2fsTruncateInodeBlocksEnterFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const F2fsTruncateInodeBlocksEnterFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(F2fsTruncateInodeBlocksEnterFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(F2fsTruncateInodeBlocksEnterFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.size != 0) {
            target.appendInt64(F2fsTruncateInodeBlocksEnterFtraceEventWire.SIZE_WIRE, self.size);
        }
        if (self.blocks != 0) {
            target.appendUint64(F2fsTruncateInodeBlocksEnterFtraceEventWire.BLOCKS_WIRE, self.blocks);
        }
        if (self.from != 0) {
            target.appendUint64(F2fsTruncateInodeBlocksEnterFtraceEventWire.FROM_WIRE, self.from);
        }
    }
};
pub const F2fsTruncateInodeBlocksEnterFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _size: i64 = 0,
    _blocks: u64 = 0,
    _from: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!F2fsTruncateInodeBlocksEnterFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = F2fsTruncateInodeBlocksEnterFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                F2fsTruncateInodeBlocksEnterFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                F2fsTruncateInodeBlocksEnterFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                F2fsTruncateInodeBlocksEnterFtraceEventWire.SIZE_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._size = result.value;
                },
                F2fsTruncateInodeBlocksEnterFtraceEventWire.BLOCKS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._blocks = result.value;
                },
                F2fsTruncateInodeBlocksEnterFtraceEventWire.FROM_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._from = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const F2fsTruncateInodeBlocksEnterFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const F2fsTruncateInodeBlocksEnterFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getSize(self: *const F2fsTruncateInodeBlocksEnterFtraceEventReader) i64 {
        return self._size;
    }
    pub inline fn getBlocks(self: *const F2fsTruncateInodeBlocksEnterFtraceEventReader) u64 {
        return self._blocks;
    }
    pub inline fn getFrom(self: *const F2fsTruncateInodeBlocksEnterFtraceEventReader) u64 {
        return self._from;
    }
};
const F2fsTruncateInodeBlocksExitFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const RET_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const F2fsTruncateInodeBlocksExitFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    ret: i32 = 0,
    pub fn calcProtobufSize(self: *const F2fsTruncateInodeBlocksExitFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncateInodeBlocksExitFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncateInodeBlocksExitFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.ret != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncateInodeBlocksExitFtraceEventWire.RET_WIRE) + gremlin.sizes.sizeI32(self.ret);
        }
        return res;
    }
    pub fn encode(self: *const F2fsTruncateInodeBlocksExitFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const F2fsTruncateInodeBlocksExitFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(F2fsTruncateInodeBlocksExitFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(F2fsTruncateInodeBlocksExitFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.ret != 0) {
            target.appendInt32(F2fsTruncateInodeBlocksExitFtraceEventWire.RET_WIRE, self.ret);
        }
    }
};
pub const F2fsTruncateInodeBlocksExitFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _ret: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!F2fsTruncateInodeBlocksExitFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = F2fsTruncateInodeBlocksExitFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                F2fsTruncateInodeBlocksExitFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                F2fsTruncateInodeBlocksExitFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                F2fsTruncateInodeBlocksExitFtraceEventWire.RET_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._ret = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const F2fsTruncateInodeBlocksExitFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const F2fsTruncateInodeBlocksExitFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getRet(self: *const F2fsTruncateInodeBlocksExitFtraceEventReader) i32 {
        return self._ret;
    }
};
const F2fsTruncateNodeFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const NID_WIRE: gremlin.ProtoWireNumber = 3;
    const BLK_ADDR_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const F2fsTruncateNodeFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    nid: u32 = 0,
    blk_addr: u32 = 0,
    pub fn calcProtobufSize(self: *const F2fsTruncateNodeFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncateNodeFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncateNodeFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.nid != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncateNodeFtraceEventWire.NID_WIRE) + gremlin.sizes.sizeU32(self.nid);
        }
        if (self.blk_addr != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncateNodeFtraceEventWire.BLK_ADDR_WIRE) + gremlin.sizes.sizeU32(self.blk_addr);
        }
        return res;
    }
    pub fn encode(self: *const F2fsTruncateNodeFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const F2fsTruncateNodeFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(F2fsTruncateNodeFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(F2fsTruncateNodeFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.nid != 0) {
            target.appendUint32(F2fsTruncateNodeFtraceEventWire.NID_WIRE, self.nid);
        }
        if (self.blk_addr != 0) {
            target.appendUint32(F2fsTruncateNodeFtraceEventWire.BLK_ADDR_WIRE, self.blk_addr);
        }
    }
};
pub const F2fsTruncateNodeFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _nid: u32 = 0,
    _blk_addr: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!F2fsTruncateNodeFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = F2fsTruncateNodeFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                F2fsTruncateNodeFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                F2fsTruncateNodeFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                F2fsTruncateNodeFtraceEventWire.NID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._nid = result.value;
                },
                F2fsTruncateNodeFtraceEventWire.BLK_ADDR_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._blk_addr = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const F2fsTruncateNodeFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const F2fsTruncateNodeFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getNid(self: *const F2fsTruncateNodeFtraceEventReader) u32 {
        return self._nid;
    }
    pub inline fn getBlkAddr(self: *const F2fsTruncateNodeFtraceEventReader) u32 {
        return self._blk_addr;
    }
};
const F2fsTruncateNodesEnterFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const NID_WIRE: gremlin.ProtoWireNumber = 3;
    const BLK_ADDR_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const F2fsTruncateNodesEnterFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    nid: u32 = 0,
    blk_addr: u32 = 0,
    pub fn calcProtobufSize(self: *const F2fsTruncateNodesEnterFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncateNodesEnterFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncateNodesEnterFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.nid != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncateNodesEnterFtraceEventWire.NID_WIRE) + gremlin.sizes.sizeU32(self.nid);
        }
        if (self.blk_addr != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncateNodesEnterFtraceEventWire.BLK_ADDR_WIRE) + gremlin.sizes.sizeU32(self.blk_addr);
        }
        return res;
    }
    pub fn encode(self: *const F2fsTruncateNodesEnterFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const F2fsTruncateNodesEnterFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(F2fsTruncateNodesEnterFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(F2fsTruncateNodesEnterFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.nid != 0) {
            target.appendUint32(F2fsTruncateNodesEnterFtraceEventWire.NID_WIRE, self.nid);
        }
        if (self.blk_addr != 0) {
            target.appendUint32(F2fsTruncateNodesEnterFtraceEventWire.BLK_ADDR_WIRE, self.blk_addr);
        }
    }
};
pub const F2fsTruncateNodesEnterFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _nid: u32 = 0,
    _blk_addr: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!F2fsTruncateNodesEnterFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = F2fsTruncateNodesEnterFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                F2fsTruncateNodesEnterFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                F2fsTruncateNodesEnterFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                F2fsTruncateNodesEnterFtraceEventWire.NID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._nid = result.value;
                },
                F2fsTruncateNodesEnterFtraceEventWire.BLK_ADDR_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._blk_addr = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const F2fsTruncateNodesEnterFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const F2fsTruncateNodesEnterFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getNid(self: *const F2fsTruncateNodesEnterFtraceEventReader) u32 {
        return self._nid;
    }
    pub inline fn getBlkAddr(self: *const F2fsTruncateNodesEnterFtraceEventReader) u32 {
        return self._blk_addr;
    }
};
const F2fsTruncateNodesExitFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const RET_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const F2fsTruncateNodesExitFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    ret: i32 = 0,
    pub fn calcProtobufSize(self: *const F2fsTruncateNodesExitFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncateNodesExitFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncateNodesExitFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.ret != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncateNodesExitFtraceEventWire.RET_WIRE) + gremlin.sizes.sizeI32(self.ret);
        }
        return res;
    }
    pub fn encode(self: *const F2fsTruncateNodesExitFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const F2fsTruncateNodesExitFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(F2fsTruncateNodesExitFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(F2fsTruncateNodesExitFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.ret != 0) {
            target.appendInt32(F2fsTruncateNodesExitFtraceEventWire.RET_WIRE, self.ret);
        }
    }
};
pub const F2fsTruncateNodesExitFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _ret: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!F2fsTruncateNodesExitFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = F2fsTruncateNodesExitFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                F2fsTruncateNodesExitFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                F2fsTruncateNodesExitFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                F2fsTruncateNodesExitFtraceEventWire.RET_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._ret = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const F2fsTruncateNodesExitFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const F2fsTruncateNodesExitFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getRet(self: *const F2fsTruncateNodesExitFtraceEventReader) i32 {
        return self._ret;
    }
};
const F2fsTruncatePartialNodesFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const NID_WIRE: gremlin.ProtoWireNumber = 3;
    const DEPTH_WIRE: gremlin.ProtoWireNumber = 4;
    const ERR_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const F2fsTruncatePartialNodesFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    nid: u32 = 0,
    depth: i32 = 0,
    err: i32 = 0,
    pub fn calcProtobufSize(self: *const F2fsTruncatePartialNodesFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncatePartialNodesFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncatePartialNodesFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.nid != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncatePartialNodesFtraceEventWire.NID_WIRE) + gremlin.sizes.sizeU32(self.nid);
        }
        if (self.depth != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncatePartialNodesFtraceEventWire.DEPTH_WIRE) + gremlin.sizes.sizeI32(self.depth);
        }
        if (self.err != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsTruncatePartialNodesFtraceEventWire.ERR_WIRE) + gremlin.sizes.sizeI32(self.err);
        }
        return res;
    }
    pub fn encode(self: *const F2fsTruncatePartialNodesFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const F2fsTruncatePartialNodesFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(F2fsTruncatePartialNodesFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(F2fsTruncatePartialNodesFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.nid != 0) {
            target.appendUint32(F2fsTruncatePartialNodesFtraceEventWire.NID_WIRE, self.nid);
        }
        if (self.depth != 0) {
            target.appendInt32(F2fsTruncatePartialNodesFtraceEventWire.DEPTH_WIRE, self.depth);
        }
        if (self.err != 0) {
            target.appendInt32(F2fsTruncatePartialNodesFtraceEventWire.ERR_WIRE, self.err);
        }
    }
};
pub const F2fsTruncatePartialNodesFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _nid: u32 = 0,
    _depth: i32 = 0,
    _err: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!F2fsTruncatePartialNodesFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = F2fsTruncatePartialNodesFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                F2fsTruncatePartialNodesFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                F2fsTruncatePartialNodesFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                F2fsTruncatePartialNodesFtraceEventWire.NID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._nid = result.value;
                },
                F2fsTruncatePartialNodesFtraceEventWire.DEPTH_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._depth = result.value;
                },
                F2fsTruncatePartialNodesFtraceEventWire.ERR_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._err = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const F2fsTruncatePartialNodesFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const F2fsTruncatePartialNodesFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getNid(self: *const F2fsTruncatePartialNodesFtraceEventReader) u32 {
        return self._nid;
    }
    pub inline fn getDepth(self: *const F2fsTruncatePartialNodesFtraceEventReader) i32 {
        return self._depth;
    }
    pub inline fn getErr(self: *const F2fsTruncatePartialNodesFtraceEventReader) i32 {
        return self._err;
    }
};
const F2fsUnlinkEnterFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const SIZE_WIRE: gremlin.ProtoWireNumber = 3;
    const BLOCKS_WIRE: gremlin.ProtoWireNumber = 4;
    const NAME_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const F2fsUnlinkEnterFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    size: i64 = 0,
    blocks: u64 = 0,
    name: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const F2fsUnlinkEnterFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsUnlinkEnterFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsUnlinkEnterFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.size != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsUnlinkEnterFtraceEventWire.SIZE_WIRE) + gremlin.sizes.sizeI64(self.size);
        }
        if (self.blocks != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsUnlinkEnterFtraceEventWire.BLOCKS_WIRE) + gremlin.sizes.sizeU64(self.blocks);
        }
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(F2fsUnlinkEnterFtraceEventWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const F2fsUnlinkEnterFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const F2fsUnlinkEnterFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(F2fsUnlinkEnterFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(F2fsUnlinkEnterFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.size != 0) {
            target.appendInt64(F2fsUnlinkEnterFtraceEventWire.SIZE_WIRE, self.size);
        }
        if (self.blocks != 0) {
            target.appendUint64(F2fsUnlinkEnterFtraceEventWire.BLOCKS_WIRE, self.blocks);
        }
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(F2fsUnlinkEnterFtraceEventWire.NAME_WIRE, v);
            }
        }
    }
};
pub const F2fsUnlinkEnterFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _size: i64 = 0,
    _blocks: u64 = 0,
    _name: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!F2fsUnlinkEnterFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = F2fsUnlinkEnterFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                F2fsUnlinkEnterFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                F2fsUnlinkEnterFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                F2fsUnlinkEnterFtraceEventWire.SIZE_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._size = result.value;
                },
                F2fsUnlinkEnterFtraceEventWire.BLOCKS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._blocks = result.value;
                },
                F2fsUnlinkEnterFtraceEventWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const F2fsUnlinkEnterFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const F2fsUnlinkEnterFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getSize(self: *const F2fsUnlinkEnterFtraceEventReader) i64 {
        return self._size;
    }
    pub inline fn getBlocks(self: *const F2fsUnlinkEnterFtraceEventReader) u64 {
        return self._blocks;
    }
    pub inline fn getName(self: *const F2fsUnlinkEnterFtraceEventReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
};
const F2fsUnlinkExitFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const RET_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const F2fsUnlinkExitFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    ret: i32 = 0,
    pub fn calcProtobufSize(self: *const F2fsUnlinkExitFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsUnlinkExitFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsUnlinkExitFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.ret != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsUnlinkExitFtraceEventWire.RET_WIRE) + gremlin.sizes.sizeI32(self.ret);
        }
        return res;
    }
    pub fn encode(self: *const F2fsUnlinkExitFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const F2fsUnlinkExitFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(F2fsUnlinkExitFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(F2fsUnlinkExitFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.ret != 0) {
            target.appendInt32(F2fsUnlinkExitFtraceEventWire.RET_WIRE, self.ret);
        }
    }
};
pub const F2fsUnlinkExitFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _ret: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!F2fsUnlinkExitFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = F2fsUnlinkExitFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                F2fsUnlinkExitFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                F2fsUnlinkExitFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                F2fsUnlinkExitFtraceEventWire.RET_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._ret = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const F2fsUnlinkExitFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const F2fsUnlinkExitFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getRet(self: *const F2fsUnlinkExitFtraceEventReader) i32 {
        return self._ret;
    }
};
const F2fsVmPageMkwriteFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const TYPE_WIRE: gremlin.ProtoWireNumber = 3;
    const DIR_WIRE: gremlin.ProtoWireNumber = 4;
    const INDEX_WIRE: gremlin.ProtoWireNumber = 5;
    const DIRTY_WIRE: gremlin.ProtoWireNumber = 6;
    const UPTODATE_WIRE: gremlin.ProtoWireNumber = 7;
};
pub const F2fsVmPageMkwriteFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    type: i32 = 0,
    dir: i32 = 0,
    index: u64 = 0,
    dirty: i32 = 0,
    uptodate: i32 = 0,
    pub fn calcProtobufSize(self: *const F2fsVmPageMkwriteFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsVmPageMkwriteFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsVmPageMkwriteFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.type != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsVmPageMkwriteFtraceEventWire.TYPE_WIRE) + gremlin.sizes.sizeI32(self.type);
        }
        if (self.dir != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsVmPageMkwriteFtraceEventWire.DIR_WIRE) + gremlin.sizes.sizeI32(self.dir);
        }
        if (self.index != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsVmPageMkwriteFtraceEventWire.INDEX_WIRE) + gremlin.sizes.sizeU64(self.index);
        }
        if (self.dirty != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsVmPageMkwriteFtraceEventWire.DIRTY_WIRE) + gremlin.sizes.sizeI32(self.dirty);
        }
        if (self.uptodate != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsVmPageMkwriteFtraceEventWire.UPTODATE_WIRE) + gremlin.sizes.sizeI32(self.uptodate);
        }
        return res;
    }
    pub fn encode(self: *const F2fsVmPageMkwriteFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const F2fsVmPageMkwriteFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(F2fsVmPageMkwriteFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(F2fsVmPageMkwriteFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.type != 0) {
            target.appendInt32(F2fsVmPageMkwriteFtraceEventWire.TYPE_WIRE, self.type);
        }
        if (self.dir != 0) {
            target.appendInt32(F2fsVmPageMkwriteFtraceEventWire.DIR_WIRE, self.dir);
        }
        if (self.index != 0) {
            target.appendUint64(F2fsVmPageMkwriteFtraceEventWire.INDEX_WIRE, self.index);
        }
        if (self.dirty != 0) {
            target.appendInt32(F2fsVmPageMkwriteFtraceEventWire.DIRTY_WIRE, self.dirty);
        }
        if (self.uptodate != 0) {
            target.appendInt32(F2fsVmPageMkwriteFtraceEventWire.UPTODATE_WIRE, self.uptodate);
        }
    }
};
pub const F2fsVmPageMkwriteFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _type: i32 = 0,
    _dir: i32 = 0,
    _index: u64 = 0,
    _dirty: i32 = 0,
    _uptodate: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!F2fsVmPageMkwriteFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = F2fsVmPageMkwriteFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                F2fsVmPageMkwriteFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                F2fsVmPageMkwriteFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                F2fsVmPageMkwriteFtraceEventWire.TYPE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._type = result.value;
                },
                F2fsVmPageMkwriteFtraceEventWire.DIR_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._dir = result.value;
                },
                F2fsVmPageMkwriteFtraceEventWire.INDEX_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._index = result.value;
                },
                F2fsVmPageMkwriteFtraceEventWire.DIRTY_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._dirty = result.value;
                },
                F2fsVmPageMkwriteFtraceEventWire.UPTODATE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._uptodate = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const F2fsVmPageMkwriteFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const F2fsVmPageMkwriteFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getType(self: *const F2fsVmPageMkwriteFtraceEventReader) i32 {
        return self._type;
    }
    pub inline fn getDir(self: *const F2fsVmPageMkwriteFtraceEventReader) i32 {
        return self._dir;
    }
    pub inline fn getIndex(self: *const F2fsVmPageMkwriteFtraceEventReader) u64 {
        return self._index;
    }
    pub inline fn getDirty(self: *const F2fsVmPageMkwriteFtraceEventReader) i32 {
        return self._dirty;
    }
    pub inline fn getUptodate(self: *const F2fsVmPageMkwriteFtraceEventReader) i32 {
        return self._uptodate;
    }
};
const F2fsWriteBeginFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const POS_WIRE: gremlin.ProtoWireNumber = 3;
    const LEN_WIRE: gremlin.ProtoWireNumber = 4;
    const FLAGS_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const F2fsWriteBeginFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    pos: i64 = 0,
    len: u32 = 0,
    flags: u32 = 0,
    pub fn calcProtobufSize(self: *const F2fsWriteBeginFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsWriteBeginFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsWriteBeginFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.pos != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsWriteBeginFtraceEventWire.POS_WIRE) + gremlin.sizes.sizeI64(self.pos);
        }
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsWriteBeginFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeU32(self.len);
        }
        if (self.flags != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsWriteBeginFtraceEventWire.FLAGS_WIRE) + gremlin.sizes.sizeU32(self.flags);
        }
        return res;
    }
    pub fn encode(self: *const F2fsWriteBeginFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const F2fsWriteBeginFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(F2fsWriteBeginFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(F2fsWriteBeginFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.pos != 0) {
            target.appendInt64(F2fsWriteBeginFtraceEventWire.POS_WIRE, self.pos);
        }
        if (self.len != 0) {
            target.appendUint32(F2fsWriteBeginFtraceEventWire.LEN_WIRE, self.len);
        }
        if (self.flags != 0) {
            target.appendUint32(F2fsWriteBeginFtraceEventWire.FLAGS_WIRE, self.flags);
        }
    }
};
pub const F2fsWriteBeginFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _pos: i64 = 0,
    _len: u32 = 0,
    _flags: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!F2fsWriteBeginFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = F2fsWriteBeginFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                F2fsWriteBeginFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                F2fsWriteBeginFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                F2fsWriteBeginFtraceEventWire.POS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._pos = result.value;
                },
                F2fsWriteBeginFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                F2fsWriteBeginFtraceEventWire.FLAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._flags = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const F2fsWriteBeginFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const F2fsWriteBeginFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getPos(self: *const F2fsWriteBeginFtraceEventReader) i64 {
        return self._pos;
    }
    pub inline fn getLen(self: *const F2fsWriteBeginFtraceEventReader) u32 {
        return self._len;
    }
    pub inline fn getFlags(self: *const F2fsWriteBeginFtraceEventReader) u32 {
        return self._flags;
    }
};
const F2fsWriteCheckpointFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const IS_UMOUNT_WIRE: gremlin.ProtoWireNumber = 2;
    const MSG_WIRE: gremlin.ProtoWireNumber = 3;
    const REASON_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const F2fsWriteCheckpointFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    is_umount: u32 = 0,
    msg: ?[]const u8 = null,
    reason: i32 = 0,
    pub fn calcProtobufSize(self: *const F2fsWriteCheckpointFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsWriteCheckpointFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.is_umount != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsWriteCheckpointFtraceEventWire.IS_UMOUNT_WIRE) + gremlin.sizes.sizeU32(self.is_umount);
        }
        if (self.msg) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(F2fsWriteCheckpointFtraceEventWire.MSG_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.reason != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsWriteCheckpointFtraceEventWire.REASON_WIRE) + gremlin.sizes.sizeI32(self.reason);
        }
        return res;
    }
    pub fn encode(self: *const F2fsWriteCheckpointFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const F2fsWriteCheckpointFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(F2fsWriteCheckpointFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.is_umount != 0) {
            target.appendUint32(F2fsWriteCheckpointFtraceEventWire.IS_UMOUNT_WIRE, self.is_umount);
        }
        if (self.msg) |v| {
            if (v.len > 0) {
                target.appendBytes(F2fsWriteCheckpointFtraceEventWire.MSG_WIRE, v);
            }
        }
        if (self.reason != 0) {
            target.appendInt32(F2fsWriteCheckpointFtraceEventWire.REASON_WIRE, self.reason);
        }
    }
};
pub const F2fsWriteCheckpointFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _is_umount: u32 = 0,
    _msg: ?[]const u8 = null,
    _reason: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!F2fsWriteCheckpointFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = F2fsWriteCheckpointFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                F2fsWriteCheckpointFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                F2fsWriteCheckpointFtraceEventWire.IS_UMOUNT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._is_umount = result.value;
                },
                F2fsWriteCheckpointFtraceEventWire.MSG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._msg = result.value;
                },
                F2fsWriteCheckpointFtraceEventWire.REASON_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._reason = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const F2fsWriteCheckpointFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIsUmount(self: *const F2fsWriteCheckpointFtraceEventReader) u32 {
        return self._is_umount;
    }
    pub inline fn getMsg(self: *const F2fsWriteCheckpointFtraceEventReader) []const u8 {
        return self._msg orelse &[_]u8{};
    }
    pub inline fn getReason(self: *const F2fsWriteCheckpointFtraceEventReader) i32 {
        return self._reason;
    }
};
const F2fsWriteEndFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const INO_WIRE: gremlin.ProtoWireNumber = 2;
    const POS_WIRE: gremlin.ProtoWireNumber = 3;
    const LEN_WIRE: gremlin.ProtoWireNumber = 4;
    const COPIED_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const F2fsWriteEndFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ino: u64 = 0,
    pos: i64 = 0,
    len: u32 = 0,
    copied: u32 = 0,
    pub fn calcProtobufSize(self: *const F2fsWriteEndFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsWriteEndFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ino != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsWriteEndFtraceEventWire.INO_WIRE) + gremlin.sizes.sizeU64(self.ino);
        }
        if (self.pos != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsWriteEndFtraceEventWire.POS_WIRE) + gremlin.sizes.sizeI64(self.pos);
        }
        if (self.len != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsWriteEndFtraceEventWire.LEN_WIRE) + gremlin.sizes.sizeU32(self.len);
        }
        if (self.copied != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsWriteEndFtraceEventWire.COPIED_WIRE) + gremlin.sizes.sizeU32(self.copied);
        }
        return res;
    }
    pub fn encode(self: *const F2fsWriteEndFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const F2fsWriteEndFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(F2fsWriteEndFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ino != 0) {
            target.appendUint64(F2fsWriteEndFtraceEventWire.INO_WIRE, self.ino);
        }
        if (self.pos != 0) {
            target.appendInt64(F2fsWriteEndFtraceEventWire.POS_WIRE, self.pos);
        }
        if (self.len != 0) {
            target.appendUint32(F2fsWriteEndFtraceEventWire.LEN_WIRE, self.len);
        }
        if (self.copied != 0) {
            target.appendUint32(F2fsWriteEndFtraceEventWire.COPIED_WIRE, self.copied);
        }
    }
};
pub const F2fsWriteEndFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ino: u64 = 0,
    _pos: i64 = 0,
    _len: u32 = 0,
    _copied: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!F2fsWriteEndFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = F2fsWriteEndFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                F2fsWriteEndFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                F2fsWriteEndFtraceEventWire.INO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ino = result.value;
                },
                F2fsWriteEndFtraceEventWire.POS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._pos = result.value;
                },
                F2fsWriteEndFtraceEventWire.LEN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._len = result.value;
                },
                F2fsWriteEndFtraceEventWire.COPIED_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._copied = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const F2fsWriteEndFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getIno(self: *const F2fsWriteEndFtraceEventReader) u64 {
        return self._ino;
    }
    pub inline fn getPos(self: *const F2fsWriteEndFtraceEventReader) i64 {
        return self._pos;
    }
    pub inline fn getLen(self: *const F2fsWriteEndFtraceEventReader) u32 {
        return self._len;
    }
    pub inline fn getCopied(self: *const F2fsWriteEndFtraceEventReader) u32 {
        return self._copied;
    }
};
const F2fsIostatFtraceEventWire = struct {
    const APP_BIO_WIRE: gremlin.ProtoWireNumber = 1;
    const APP_BRIO_WIRE: gremlin.ProtoWireNumber = 2;
    const APP_DIO_WIRE: gremlin.ProtoWireNumber = 3;
    const APP_DRIO_WIRE: gremlin.ProtoWireNumber = 4;
    const APP_MIO_WIRE: gremlin.ProtoWireNumber = 5;
    const APP_MRIO_WIRE: gremlin.ProtoWireNumber = 6;
    const APP_RIO_WIRE: gremlin.ProtoWireNumber = 7;
    const APP_WIO_WIRE: gremlin.ProtoWireNumber = 8;
    const DEV_WIRE: gremlin.ProtoWireNumber = 9;
    const FS_CDRIO_WIRE: gremlin.ProtoWireNumber = 10;
    const FS_CP_DIO_WIRE: gremlin.ProtoWireNumber = 11;
    const FS_CP_MIO_WIRE: gremlin.ProtoWireNumber = 12;
    const FS_CP_NIO_WIRE: gremlin.ProtoWireNumber = 13;
    const FS_DIO_WIRE: gremlin.ProtoWireNumber = 14;
    const FS_DISCARD_WIRE: gremlin.ProtoWireNumber = 15;
    const FS_DRIO_WIRE: gremlin.ProtoWireNumber = 16;
    const FS_GC_DIO_WIRE: gremlin.ProtoWireNumber = 17;
    const FS_GC_NIO_WIRE: gremlin.ProtoWireNumber = 18;
    const FS_GDRIO_WIRE: gremlin.ProtoWireNumber = 19;
    const FS_MIO_WIRE: gremlin.ProtoWireNumber = 20;
    const FS_MRIO_WIRE: gremlin.ProtoWireNumber = 21;
    const FS_NIO_WIRE: gremlin.ProtoWireNumber = 22;
    const FS_NRIO_WIRE: gremlin.ProtoWireNumber = 23;
};
pub const F2fsIostatFtraceEvent = struct {
    // fields
    app_bio: u64 = 0,
    app_brio: u64 = 0,
    app_dio: u64 = 0,
    app_drio: u64 = 0,
    app_mio: u64 = 0,
    app_mrio: u64 = 0,
    app_rio: u64 = 0,
    app_wio: u64 = 0,
    dev: u64 = 0,
    fs_cdrio: u64 = 0,
    fs_cp_dio: u64 = 0,
    fs_cp_mio: u64 = 0,
    fs_cp_nio: u64 = 0,
    fs_dio: u64 = 0,
    fs_discard: u64 = 0,
    fs_drio: u64 = 0,
    fs_gc_dio: u64 = 0,
    fs_gc_nio: u64 = 0,
    fs_gdrio: u64 = 0,
    fs_mio: u64 = 0,
    fs_mrio: u64 = 0,
    fs_nio: u64 = 0,
    fs_nrio: u64 = 0,
    pub fn calcProtobufSize(self: *const F2fsIostatFtraceEvent) usize {
        var res: usize = 0;
        if (self.app_bio != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatFtraceEventWire.APP_BIO_WIRE) + gremlin.sizes.sizeU64(self.app_bio);
        }
        if (self.app_brio != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatFtraceEventWire.APP_BRIO_WIRE) + gremlin.sizes.sizeU64(self.app_brio);
        }
        if (self.app_dio != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatFtraceEventWire.APP_DIO_WIRE) + gremlin.sizes.sizeU64(self.app_dio);
        }
        if (self.app_drio != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatFtraceEventWire.APP_DRIO_WIRE) + gremlin.sizes.sizeU64(self.app_drio);
        }
        if (self.app_mio != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatFtraceEventWire.APP_MIO_WIRE) + gremlin.sizes.sizeU64(self.app_mio);
        }
        if (self.app_mrio != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatFtraceEventWire.APP_MRIO_WIRE) + gremlin.sizes.sizeU64(self.app_mrio);
        }
        if (self.app_rio != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatFtraceEventWire.APP_RIO_WIRE) + gremlin.sizes.sizeU64(self.app_rio);
        }
        if (self.app_wio != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatFtraceEventWire.APP_WIO_WIRE) + gremlin.sizes.sizeU64(self.app_wio);
        }
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.fs_cdrio != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatFtraceEventWire.FS_CDRIO_WIRE) + gremlin.sizes.sizeU64(self.fs_cdrio);
        }
        if (self.fs_cp_dio != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatFtraceEventWire.FS_CP_DIO_WIRE) + gremlin.sizes.sizeU64(self.fs_cp_dio);
        }
        if (self.fs_cp_mio != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatFtraceEventWire.FS_CP_MIO_WIRE) + gremlin.sizes.sizeU64(self.fs_cp_mio);
        }
        if (self.fs_cp_nio != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatFtraceEventWire.FS_CP_NIO_WIRE) + gremlin.sizes.sizeU64(self.fs_cp_nio);
        }
        if (self.fs_dio != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatFtraceEventWire.FS_DIO_WIRE) + gremlin.sizes.sizeU64(self.fs_dio);
        }
        if (self.fs_discard != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatFtraceEventWire.FS_DISCARD_WIRE) + gremlin.sizes.sizeU64(self.fs_discard);
        }
        if (self.fs_drio != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatFtraceEventWire.FS_DRIO_WIRE) + gremlin.sizes.sizeU64(self.fs_drio);
        }
        if (self.fs_gc_dio != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatFtraceEventWire.FS_GC_DIO_WIRE) + gremlin.sizes.sizeU64(self.fs_gc_dio);
        }
        if (self.fs_gc_nio != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatFtraceEventWire.FS_GC_NIO_WIRE) + gremlin.sizes.sizeU64(self.fs_gc_nio);
        }
        if (self.fs_gdrio != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatFtraceEventWire.FS_GDRIO_WIRE) + gremlin.sizes.sizeU64(self.fs_gdrio);
        }
        if (self.fs_mio != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatFtraceEventWire.FS_MIO_WIRE) + gremlin.sizes.sizeU64(self.fs_mio);
        }
        if (self.fs_mrio != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatFtraceEventWire.FS_MRIO_WIRE) + gremlin.sizes.sizeU64(self.fs_mrio);
        }
        if (self.fs_nio != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatFtraceEventWire.FS_NIO_WIRE) + gremlin.sizes.sizeU64(self.fs_nio);
        }
        if (self.fs_nrio != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatFtraceEventWire.FS_NRIO_WIRE) + gremlin.sizes.sizeU64(self.fs_nrio);
        }
        return res;
    }
    pub fn encode(self: *const F2fsIostatFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const F2fsIostatFtraceEvent, target: *gremlin.Writer) void {
        if (self.app_bio != 0) {
            target.appendUint64(F2fsIostatFtraceEventWire.APP_BIO_WIRE, self.app_bio);
        }
        if (self.app_brio != 0) {
            target.appendUint64(F2fsIostatFtraceEventWire.APP_BRIO_WIRE, self.app_brio);
        }
        if (self.app_dio != 0) {
            target.appendUint64(F2fsIostatFtraceEventWire.APP_DIO_WIRE, self.app_dio);
        }
        if (self.app_drio != 0) {
            target.appendUint64(F2fsIostatFtraceEventWire.APP_DRIO_WIRE, self.app_drio);
        }
        if (self.app_mio != 0) {
            target.appendUint64(F2fsIostatFtraceEventWire.APP_MIO_WIRE, self.app_mio);
        }
        if (self.app_mrio != 0) {
            target.appendUint64(F2fsIostatFtraceEventWire.APP_MRIO_WIRE, self.app_mrio);
        }
        if (self.app_rio != 0) {
            target.appendUint64(F2fsIostatFtraceEventWire.APP_RIO_WIRE, self.app_rio);
        }
        if (self.app_wio != 0) {
            target.appendUint64(F2fsIostatFtraceEventWire.APP_WIO_WIRE, self.app_wio);
        }
        if (self.dev != 0) {
            target.appendUint64(F2fsIostatFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.fs_cdrio != 0) {
            target.appendUint64(F2fsIostatFtraceEventWire.FS_CDRIO_WIRE, self.fs_cdrio);
        }
        if (self.fs_cp_dio != 0) {
            target.appendUint64(F2fsIostatFtraceEventWire.FS_CP_DIO_WIRE, self.fs_cp_dio);
        }
        if (self.fs_cp_mio != 0) {
            target.appendUint64(F2fsIostatFtraceEventWire.FS_CP_MIO_WIRE, self.fs_cp_mio);
        }
        if (self.fs_cp_nio != 0) {
            target.appendUint64(F2fsIostatFtraceEventWire.FS_CP_NIO_WIRE, self.fs_cp_nio);
        }
        if (self.fs_dio != 0) {
            target.appendUint64(F2fsIostatFtraceEventWire.FS_DIO_WIRE, self.fs_dio);
        }
        if (self.fs_discard != 0) {
            target.appendUint64(F2fsIostatFtraceEventWire.FS_DISCARD_WIRE, self.fs_discard);
        }
        if (self.fs_drio != 0) {
            target.appendUint64(F2fsIostatFtraceEventWire.FS_DRIO_WIRE, self.fs_drio);
        }
        if (self.fs_gc_dio != 0) {
            target.appendUint64(F2fsIostatFtraceEventWire.FS_GC_DIO_WIRE, self.fs_gc_dio);
        }
        if (self.fs_gc_nio != 0) {
            target.appendUint64(F2fsIostatFtraceEventWire.FS_GC_NIO_WIRE, self.fs_gc_nio);
        }
        if (self.fs_gdrio != 0) {
            target.appendUint64(F2fsIostatFtraceEventWire.FS_GDRIO_WIRE, self.fs_gdrio);
        }
        if (self.fs_mio != 0) {
            target.appendUint64(F2fsIostatFtraceEventWire.FS_MIO_WIRE, self.fs_mio);
        }
        if (self.fs_mrio != 0) {
            target.appendUint64(F2fsIostatFtraceEventWire.FS_MRIO_WIRE, self.fs_mrio);
        }
        if (self.fs_nio != 0) {
            target.appendUint64(F2fsIostatFtraceEventWire.FS_NIO_WIRE, self.fs_nio);
        }
        if (self.fs_nrio != 0) {
            target.appendUint64(F2fsIostatFtraceEventWire.FS_NRIO_WIRE, self.fs_nrio);
        }
    }
};
pub const F2fsIostatFtraceEventReader = struct {
    buf: gremlin.Reader,
    _app_bio: u64 = 0,
    _app_brio: u64 = 0,
    _app_dio: u64 = 0,
    _app_drio: u64 = 0,
    _app_mio: u64 = 0,
    _app_mrio: u64 = 0,
    _app_rio: u64 = 0,
    _app_wio: u64 = 0,
    _dev: u64 = 0,
    _fs_cdrio: u64 = 0,
    _fs_cp_dio: u64 = 0,
    _fs_cp_mio: u64 = 0,
    _fs_cp_nio: u64 = 0,
    _fs_dio: u64 = 0,
    _fs_discard: u64 = 0,
    _fs_drio: u64 = 0,
    _fs_gc_dio: u64 = 0,
    _fs_gc_nio: u64 = 0,
    _fs_gdrio: u64 = 0,
    _fs_mio: u64 = 0,
    _fs_mrio: u64 = 0,
    _fs_nio: u64 = 0,
    _fs_nrio: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!F2fsIostatFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = F2fsIostatFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                F2fsIostatFtraceEventWire.APP_BIO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._app_bio = result.value;
                },
                F2fsIostatFtraceEventWire.APP_BRIO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._app_brio = result.value;
                },
                F2fsIostatFtraceEventWire.APP_DIO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._app_dio = result.value;
                },
                F2fsIostatFtraceEventWire.APP_DRIO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._app_drio = result.value;
                },
                F2fsIostatFtraceEventWire.APP_MIO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._app_mio = result.value;
                },
                F2fsIostatFtraceEventWire.APP_MRIO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._app_mrio = result.value;
                },
                F2fsIostatFtraceEventWire.APP_RIO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._app_rio = result.value;
                },
                F2fsIostatFtraceEventWire.APP_WIO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._app_wio = result.value;
                },
                F2fsIostatFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                F2fsIostatFtraceEventWire.FS_CDRIO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._fs_cdrio = result.value;
                },
                F2fsIostatFtraceEventWire.FS_CP_DIO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._fs_cp_dio = result.value;
                },
                F2fsIostatFtraceEventWire.FS_CP_MIO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._fs_cp_mio = result.value;
                },
                F2fsIostatFtraceEventWire.FS_CP_NIO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._fs_cp_nio = result.value;
                },
                F2fsIostatFtraceEventWire.FS_DIO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._fs_dio = result.value;
                },
                F2fsIostatFtraceEventWire.FS_DISCARD_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._fs_discard = result.value;
                },
                F2fsIostatFtraceEventWire.FS_DRIO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._fs_drio = result.value;
                },
                F2fsIostatFtraceEventWire.FS_GC_DIO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._fs_gc_dio = result.value;
                },
                F2fsIostatFtraceEventWire.FS_GC_NIO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._fs_gc_nio = result.value;
                },
                F2fsIostatFtraceEventWire.FS_GDRIO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._fs_gdrio = result.value;
                },
                F2fsIostatFtraceEventWire.FS_MIO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._fs_mio = result.value;
                },
                F2fsIostatFtraceEventWire.FS_MRIO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._fs_mrio = result.value;
                },
                F2fsIostatFtraceEventWire.FS_NIO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._fs_nio = result.value;
                },
                F2fsIostatFtraceEventWire.FS_NRIO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._fs_nrio = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getAppBio(self: *const F2fsIostatFtraceEventReader) u64 {
        return self._app_bio;
    }
    pub inline fn getAppBrio(self: *const F2fsIostatFtraceEventReader) u64 {
        return self._app_brio;
    }
    pub inline fn getAppDio(self: *const F2fsIostatFtraceEventReader) u64 {
        return self._app_dio;
    }
    pub inline fn getAppDrio(self: *const F2fsIostatFtraceEventReader) u64 {
        return self._app_drio;
    }
    pub inline fn getAppMio(self: *const F2fsIostatFtraceEventReader) u64 {
        return self._app_mio;
    }
    pub inline fn getAppMrio(self: *const F2fsIostatFtraceEventReader) u64 {
        return self._app_mrio;
    }
    pub inline fn getAppRio(self: *const F2fsIostatFtraceEventReader) u64 {
        return self._app_rio;
    }
    pub inline fn getAppWio(self: *const F2fsIostatFtraceEventReader) u64 {
        return self._app_wio;
    }
    pub inline fn getDev(self: *const F2fsIostatFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getFsCdrio(self: *const F2fsIostatFtraceEventReader) u64 {
        return self._fs_cdrio;
    }
    pub inline fn getFsCpDio(self: *const F2fsIostatFtraceEventReader) u64 {
        return self._fs_cp_dio;
    }
    pub inline fn getFsCpMio(self: *const F2fsIostatFtraceEventReader) u64 {
        return self._fs_cp_mio;
    }
    pub inline fn getFsCpNio(self: *const F2fsIostatFtraceEventReader) u64 {
        return self._fs_cp_nio;
    }
    pub inline fn getFsDio(self: *const F2fsIostatFtraceEventReader) u64 {
        return self._fs_dio;
    }
    pub inline fn getFsDiscard(self: *const F2fsIostatFtraceEventReader) u64 {
        return self._fs_discard;
    }
    pub inline fn getFsDrio(self: *const F2fsIostatFtraceEventReader) u64 {
        return self._fs_drio;
    }
    pub inline fn getFsGcDio(self: *const F2fsIostatFtraceEventReader) u64 {
        return self._fs_gc_dio;
    }
    pub inline fn getFsGcNio(self: *const F2fsIostatFtraceEventReader) u64 {
        return self._fs_gc_nio;
    }
    pub inline fn getFsGdrio(self: *const F2fsIostatFtraceEventReader) u64 {
        return self._fs_gdrio;
    }
    pub inline fn getFsMio(self: *const F2fsIostatFtraceEventReader) u64 {
        return self._fs_mio;
    }
    pub inline fn getFsMrio(self: *const F2fsIostatFtraceEventReader) u64 {
        return self._fs_mrio;
    }
    pub inline fn getFsNio(self: *const F2fsIostatFtraceEventReader) u64 {
        return self._fs_nio;
    }
    pub inline fn getFsNrio(self: *const F2fsIostatFtraceEventReader) u64 {
        return self._fs_nrio;
    }
};
const F2fsIostatLatencyFtraceEventWire = struct {
    const D_RD_AVG_WIRE: gremlin.ProtoWireNumber = 1;
    const D_RD_CNT_WIRE: gremlin.ProtoWireNumber = 2;
    const D_RD_PEAK_WIRE: gremlin.ProtoWireNumber = 3;
    const D_WR_AS_AVG_WIRE: gremlin.ProtoWireNumber = 4;
    const D_WR_AS_CNT_WIRE: gremlin.ProtoWireNumber = 5;
    const D_WR_AS_PEAK_WIRE: gremlin.ProtoWireNumber = 6;
    const D_WR_S_AVG_WIRE: gremlin.ProtoWireNumber = 7;
    const D_WR_S_CNT_WIRE: gremlin.ProtoWireNumber = 8;
    const D_WR_S_PEAK_WIRE: gremlin.ProtoWireNumber = 9;
    const DEV_WIRE: gremlin.ProtoWireNumber = 10;
    const M_RD_AVG_WIRE: gremlin.ProtoWireNumber = 11;
    const M_RD_CNT_WIRE: gremlin.ProtoWireNumber = 12;
    const M_RD_PEAK_WIRE: gremlin.ProtoWireNumber = 13;
    const M_WR_AS_AVG_WIRE: gremlin.ProtoWireNumber = 14;
    const M_WR_AS_CNT_WIRE: gremlin.ProtoWireNumber = 15;
    const M_WR_AS_PEAK_WIRE: gremlin.ProtoWireNumber = 16;
    const M_WR_S_AVG_WIRE: gremlin.ProtoWireNumber = 17;
    const M_WR_S_CNT_WIRE: gremlin.ProtoWireNumber = 18;
    const M_WR_S_PEAK_WIRE: gremlin.ProtoWireNumber = 19;
    const N_RD_AVG_WIRE: gremlin.ProtoWireNumber = 20;
    const N_RD_CNT_WIRE: gremlin.ProtoWireNumber = 21;
    const N_RD_PEAK_WIRE: gremlin.ProtoWireNumber = 22;
    const N_WR_AS_AVG_WIRE: gremlin.ProtoWireNumber = 23;
    const N_WR_AS_CNT_WIRE: gremlin.ProtoWireNumber = 24;
    const N_WR_AS_PEAK_WIRE: gremlin.ProtoWireNumber = 25;
    const N_WR_S_AVG_WIRE: gremlin.ProtoWireNumber = 26;
    const N_WR_S_CNT_WIRE: gremlin.ProtoWireNumber = 27;
    const N_WR_S_PEAK_WIRE: gremlin.ProtoWireNumber = 28;
};
pub const F2fsIostatLatencyFtraceEvent = struct {
    // fields
    d_rd_avg: u32 = 0,
    d_rd_cnt: u32 = 0,
    d_rd_peak: u32 = 0,
    d_wr_as_avg: u32 = 0,
    d_wr_as_cnt: u32 = 0,
    d_wr_as_peak: u32 = 0,
    d_wr_s_avg: u32 = 0,
    d_wr_s_cnt: u32 = 0,
    d_wr_s_peak: u32 = 0,
    dev: u64 = 0,
    m_rd_avg: u32 = 0,
    m_rd_cnt: u32 = 0,
    m_rd_peak: u32 = 0,
    m_wr_as_avg: u32 = 0,
    m_wr_as_cnt: u32 = 0,
    m_wr_as_peak: u32 = 0,
    m_wr_s_avg: u32 = 0,
    m_wr_s_cnt: u32 = 0,
    m_wr_s_peak: u32 = 0,
    n_rd_avg: u32 = 0,
    n_rd_cnt: u32 = 0,
    n_rd_peak: u32 = 0,
    n_wr_as_avg: u32 = 0,
    n_wr_as_cnt: u32 = 0,
    n_wr_as_peak: u32 = 0,
    n_wr_s_avg: u32 = 0,
    n_wr_s_cnt: u32 = 0,
    n_wr_s_peak: u32 = 0,
    pub fn calcProtobufSize(self: *const F2fsIostatLatencyFtraceEvent) usize {
        var res: usize = 0;
        if (self.d_rd_avg != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatLatencyFtraceEventWire.D_RD_AVG_WIRE) + gremlin.sizes.sizeU32(self.d_rd_avg);
        }
        if (self.d_rd_cnt != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatLatencyFtraceEventWire.D_RD_CNT_WIRE) + gremlin.sizes.sizeU32(self.d_rd_cnt);
        }
        if (self.d_rd_peak != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatLatencyFtraceEventWire.D_RD_PEAK_WIRE) + gremlin.sizes.sizeU32(self.d_rd_peak);
        }
        if (self.d_wr_as_avg != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatLatencyFtraceEventWire.D_WR_AS_AVG_WIRE) + gremlin.sizes.sizeU32(self.d_wr_as_avg);
        }
        if (self.d_wr_as_cnt != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatLatencyFtraceEventWire.D_WR_AS_CNT_WIRE) + gremlin.sizes.sizeU32(self.d_wr_as_cnt);
        }
        if (self.d_wr_as_peak != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatLatencyFtraceEventWire.D_WR_AS_PEAK_WIRE) + gremlin.sizes.sizeU32(self.d_wr_as_peak);
        }
        if (self.d_wr_s_avg != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatLatencyFtraceEventWire.D_WR_S_AVG_WIRE) + gremlin.sizes.sizeU32(self.d_wr_s_avg);
        }
        if (self.d_wr_s_cnt != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatLatencyFtraceEventWire.D_WR_S_CNT_WIRE) + gremlin.sizes.sizeU32(self.d_wr_s_cnt);
        }
        if (self.d_wr_s_peak != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatLatencyFtraceEventWire.D_WR_S_PEAK_WIRE) + gremlin.sizes.sizeU32(self.d_wr_s_peak);
        }
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatLatencyFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.m_rd_avg != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatLatencyFtraceEventWire.M_RD_AVG_WIRE) + gremlin.sizes.sizeU32(self.m_rd_avg);
        }
        if (self.m_rd_cnt != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatLatencyFtraceEventWire.M_RD_CNT_WIRE) + gremlin.sizes.sizeU32(self.m_rd_cnt);
        }
        if (self.m_rd_peak != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatLatencyFtraceEventWire.M_RD_PEAK_WIRE) + gremlin.sizes.sizeU32(self.m_rd_peak);
        }
        if (self.m_wr_as_avg != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatLatencyFtraceEventWire.M_WR_AS_AVG_WIRE) + gremlin.sizes.sizeU32(self.m_wr_as_avg);
        }
        if (self.m_wr_as_cnt != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatLatencyFtraceEventWire.M_WR_AS_CNT_WIRE) + gremlin.sizes.sizeU32(self.m_wr_as_cnt);
        }
        if (self.m_wr_as_peak != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatLatencyFtraceEventWire.M_WR_AS_PEAK_WIRE) + gremlin.sizes.sizeU32(self.m_wr_as_peak);
        }
        if (self.m_wr_s_avg != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatLatencyFtraceEventWire.M_WR_S_AVG_WIRE) + gremlin.sizes.sizeU32(self.m_wr_s_avg);
        }
        if (self.m_wr_s_cnt != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatLatencyFtraceEventWire.M_WR_S_CNT_WIRE) + gremlin.sizes.sizeU32(self.m_wr_s_cnt);
        }
        if (self.m_wr_s_peak != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatLatencyFtraceEventWire.M_WR_S_PEAK_WIRE) + gremlin.sizes.sizeU32(self.m_wr_s_peak);
        }
        if (self.n_rd_avg != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatLatencyFtraceEventWire.N_RD_AVG_WIRE) + gremlin.sizes.sizeU32(self.n_rd_avg);
        }
        if (self.n_rd_cnt != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatLatencyFtraceEventWire.N_RD_CNT_WIRE) + gremlin.sizes.sizeU32(self.n_rd_cnt);
        }
        if (self.n_rd_peak != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatLatencyFtraceEventWire.N_RD_PEAK_WIRE) + gremlin.sizes.sizeU32(self.n_rd_peak);
        }
        if (self.n_wr_as_avg != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatLatencyFtraceEventWire.N_WR_AS_AVG_WIRE) + gremlin.sizes.sizeU32(self.n_wr_as_avg);
        }
        if (self.n_wr_as_cnt != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatLatencyFtraceEventWire.N_WR_AS_CNT_WIRE) + gremlin.sizes.sizeU32(self.n_wr_as_cnt);
        }
        if (self.n_wr_as_peak != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatLatencyFtraceEventWire.N_WR_AS_PEAK_WIRE) + gremlin.sizes.sizeU32(self.n_wr_as_peak);
        }
        if (self.n_wr_s_avg != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatLatencyFtraceEventWire.N_WR_S_AVG_WIRE) + gremlin.sizes.sizeU32(self.n_wr_s_avg);
        }
        if (self.n_wr_s_cnt != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatLatencyFtraceEventWire.N_WR_S_CNT_WIRE) + gremlin.sizes.sizeU32(self.n_wr_s_cnt);
        }
        if (self.n_wr_s_peak != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsIostatLatencyFtraceEventWire.N_WR_S_PEAK_WIRE) + gremlin.sizes.sizeU32(self.n_wr_s_peak);
        }
        return res;
    }
    pub fn encode(self: *const F2fsIostatLatencyFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const F2fsIostatLatencyFtraceEvent, target: *gremlin.Writer) void {
        if (self.d_rd_avg != 0) {
            target.appendUint32(F2fsIostatLatencyFtraceEventWire.D_RD_AVG_WIRE, self.d_rd_avg);
        }
        if (self.d_rd_cnt != 0) {
            target.appendUint32(F2fsIostatLatencyFtraceEventWire.D_RD_CNT_WIRE, self.d_rd_cnt);
        }
        if (self.d_rd_peak != 0) {
            target.appendUint32(F2fsIostatLatencyFtraceEventWire.D_RD_PEAK_WIRE, self.d_rd_peak);
        }
        if (self.d_wr_as_avg != 0) {
            target.appendUint32(F2fsIostatLatencyFtraceEventWire.D_WR_AS_AVG_WIRE, self.d_wr_as_avg);
        }
        if (self.d_wr_as_cnt != 0) {
            target.appendUint32(F2fsIostatLatencyFtraceEventWire.D_WR_AS_CNT_WIRE, self.d_wr_as_cnt);
        }
        if (self.d_wr_as_peak != 0) {
            target.appendUint32(F2fsIostatLatencyFtraceEventWire.D_WR_AS_PEAK_WIRE, self.d_wr_as_peak);
        }
        if (self.d_wr_s_avg != 0) {
            target.appendUint32(F2fsIostatLatencyFtraceEventWire.D_WR_S_AVG_WIRE, self.d_wr_s_avg);
        }
        if (self.d_wr_s_cnt != 0) {
            target.appendUint32(F2fsIostatLatencyFtraceEventWire.D_WR_S_CNT_WIRE, self.d_wr_s_cnt);
        }
        if (self.d_wr_s_peak != 0) {
            target.appendUint32(F2fsIostatLatencyFtraceEventWire.D_WR_S_PEAK_WIRE, self.d_wr_s_peak);
        }
        if (self.dev != 0) {
            target.appendUint64(F2fsIostatLatencyFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.m_rd_avg != 0) {
            target.appendUint32(F2fsIostatLatencyFtraceEventWire.M_RD_AVG_WIRE, self.m_rd_avg);
        }
        if (self.m_rd_cnt != 0) {
            target.appendUint32(F2fsIostatLatencyFtraceEventWire.M_RD_CNT_WIRE, self.m_rd_cnt);
        }
        if (self.m_rd_peak != 0) {
            target.appendUint32(F2fsIostatLatencyFtraceEventWire.M_RD_PEAK_WIRE, self.m_rd_peak);
        }
        if (self.m_wr_as_avg != 0) {
            target.appendUint32(F2fsIostatLatencyFtraceEventWire.M_WR_AS_AVG_WIRE, self.m_wr_as_avg);
        }
        if (self.m_wr_as_cnt != 0) {
            target.appendUint32(F2fsIostatLatencyFtraceEventWire.M_WR_AS_CNT_WIRE, self.m_wr_as_cnt);
        }
        if (self.m_wr_as_peak != 0) {
            target.appendUint32(F2fsIostatLatencyFtraceEventWire.M_WR_AS_PEAK_WIRE, self.m_wr_as_peak);
        }
        if (self.m_wr_s_avg != 0) {
            target.appendUint32(F2fsIostatLatencyFtraceEventWire.M_WR_S_AVG_WIRE, self.m_wr_s_avg);
        }
        if (self.m_wr_s_cnt != 0) {
            target.appendUint32(F2fsIostatLatencyFtraceEventWire.M_WR_S_CNT_WIRE, self.m_wr_s_cnt);
        }
        if (self.m_wr_s_peak != 0) {
            target.appendUint32(F2fsIostatLatencyFtraceEventWire.M_WR_S_PEAK_WIRE, self.m_wr_s_peak);
        }
        if (self.n_rd_avg != 0) {
            target.appendUint32(F2fsIostatLatencyFtraceEventWire.N_RD_AVG_WIRE, self.n_rd_avg);
        }
        if (self.n_rd_cnt != 0) {
            target.appendUint32(F2fsIostatLatencyFtraceEventWire.N_RD_CNT_WIRE, self.n_rd_cnt);
        }
        if (self.n_rd_peak != 0) {
            target.appendUint32(F2fsIostatLatencyFtraceEventWire.N_RD_PEAK_WIRE, self.n_rd_peak);
        }
        if (self.n_wr_as_avg != 0) {
            target.appendUint32(F2fsIostatLatencyFtraceEventWire.N_WR_AS_AVG_WIRE, self.n_wr_as_avg);
        }
        if (self.n_wr_as_cnt != 0) {
            target.appendUint32(F2fsIostatLatencyFtraceEventWire.N_WR_AS_CNT_WIRE, self.n_wr_as_cnt);
        }
        if (self.n_wr_as_peak != 0) {
            target.appendUint32(F2fsIostatLatencyFtraceEventWire.N_WR_AS_PEAK_WIRE, self.n_wr_as_peak);
        }
        if (self.n_wr_s_avg != 0) {
            target.appendUint32(F2fsIostatLatencyFtraceEventWire.N_WR_S_AVG_WIRE, self.n_wr_s_avg);
        }
        if (self.n_wr_s_cnt != 0) {
            target.appendUint32(F2fsIostatLatencyFtraceEventWire.N_WR_S_CNT_WIRE, self.n_wr_s_cnt);
        }
        if (self.n_wr_s_peak != 0) {
            target.appendUint32(F2fsIostatLatencyFtraceEventWire.N_WR_S_PEAK_WIRE, self.n_wr_s_peak);
        }
    }
};
pub const F2fsIostatLatencyFtraceEventReader = struct {
    buf: gremlin.Reader,
    _d_rd_avg: u32 = 0,
    _d_rd_cnt: u32 = 0,
    _d_rd_peak: u32 = 0,
    _d_wr_as_avg: u32 = 0,
    _d_wr_as_cnt: u32 = 0,
    _d_wr_as_peak: u32 = 0,
    _d_wr_s_avg: u32 = 0,
    _d_wr_s_cnt: u32 = 0,
    _d_wr_s_peak: u32 = 0,
    _dev: u64 = 0,
    _m_rd_avg: u32 = 0,
    _m_rd_cnt: u32 = 0,
    _m_rd_peak: u32 = 0,
    _m_wr_as_avg: u32 = 0,
    _m_wr_as_cnt: u32 = 0,
    _m_wr_as_peak: u32 = 0,
    _m_wr_s_avg: u32 = 0,
    _m_wr_s_cnt: u32 = 0,
    _m_wr_s_peak: u32 = 0,
    _n_rd_avg: u32 = 0,
    _n_rd_cnt: u32 = 0,
    _n_rd_peak: u32 = 0,
    _n_wr_as_avg: u32 = 0,
    _n_wr_as_cnt: u32 = 0,
    _n_wr_as_peak: u32 = 0,
    _n_wr_s_avg: u32 = 0,
    _n_wr_s_cnt: u32 = 0,
    _n_wr_s_peak: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!F2fsIostatLatencyFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = F2fsIostatLatencyFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                F2fsIostatLatencyFtraceEventWire.D_RD_AVG_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._d_rd_avg = result.value;
                },
                F2fsIostatLatencyFtraceEventWire.D_RD_CNT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._d_rd_cnt = result.value;
                },
                F2fsIostatLatencyFtraceEventWire.D_RD_PEAK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._d_rd_peak = result.value;
                },
                F2fsIostatLatencyFtraceEventWire.D_WR_AS_AVG_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._d_wr_as_avg = result.value;
                },
                F2fsIostatLatencyFtraceEventWire.D_WR_AS_CNT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._d_wr_as_cnt = result.value;
                },
                F2fsIostatLatencyFtraceEventWire.D_WR_AS_PEAK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._d_wr_as_peak = result.value;
                },
                F2fsIostatLatencyFtraceEventWire.D_WR_S_AVG_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._d_wr_s_avg = result.value;
                },
                F2fsIostatLatencyFtraceEventWire.D_WR_S_CNT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._d_wr_s_cnt = result.value;
                },
                F2fsIostatLatencyFtraceEventWire.D_WR_S_PEAK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._d_wr_s_peak = result.value;
                },
                F2fsIostatLatencyFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                F2fsIostatLatencyFtraceEventWire.M_RD_AVG_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._m_rd_avg = result.value;
                },
                F2fsIostatLatencyFtraceEventWire.M_RD_CNT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._m_rd_cnt = result.value;
                },
                F2fsIostatLatencyFtraceEventWire.M_RD_PEAK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._m_rd_peak = result.value;
                },
                F2fsIostatLatencyFtraceEventWire.M_WR_AS_AVG_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._m_wr_as_avg = result.value;
                },
                F2fsIostatLatencyFtraceEventWire.M_WR_AS_CNT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._m_wr_as_cnt = result.value;
                },
                F2fsIostatLatencyFtraceEventWire.M_WR_AS_PEAK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._m_wr_as_peak = result.value;
                },
                F2fsIostatLatencyFtraceEventWire.M_WR_S_AVG_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._m_wr_s_avg = result.value;
                },
                F2fsIostatLatencyFtraceEventWire.M_WR_S_CNT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._m_wr_s_cnt = result.value;
                },
                F2fsIostatLatencyFtraceEventWire.M_WR_S_PEAK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._m_wr_s_peak = result.value;
                },
                F2fsIostatLatencyFtraceEventWire.N_RD_AVG_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._n_rd_avg = result.value;
                },
                F2fsIostatLatencyFtraceEventWire.N_RD_CNT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._n_rd_cnt = result.value;
                },
                F2fsIostatLatencyFtraceEventWire.N_RD_PEAK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._n_rd_peak = result.value;
                },
                F2fsIostatLatencyFtraceEventWire.N_WR_AS_AVG_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._n_wr_as_avg = result.value;
                },
                F2fsIostatLatencyFtraceEventWire.N_WR_AS_CNT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._n_wr_as_cnt = result.value;
                },
                F2fsIostatLatencyFtraceEventWire.N_WR_AS_PEAK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._n_wr_as_peak = result.value;
                },
                F2fsIostatLatencyFtraceEventWire.N_WR_S_AVG_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._n_wr_s_avg = result.value;
                },
                F2fsIostatLatencyFtraceEventWire.N_WR_S_CNT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._n_wr_s_cnt = result.value;
                },
                F2fsIostatLatencyFtraceEventWire.N_WR_S_PEAK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._n_wr_s_peak = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDRdAvg(self: *const F2fsIostatLatencyFtraceEventReader) u32 {
        return self._d_rd_avg;
    }
    pub inline fn getDRdCnt(self: *const F2fsIostatLatencyFtraceEventReader) u32 {
        return self._d_rd_cnt;
    }
    pub inline fn getDRdPeak(self: *const F2fsIostatLatencyFtraceEventReader) u32 {
        return self._d_rd_peak;
    }
    pub inline fn getDWrAsAvg(self: *const F2fsIostatLatencyFtraceEventReader) u32 {
        return self._d_wr_as_avg;
    }
    pub inline fn getDWrAsCnt(self: *const F2fsIostatLatencyFtraceEventReader) u32 {
        return self._d_wr_as_cnt;
    }
    pub inline fn getDWrAsPeak(self: *const F2fsIostatLatencyFtraceEventReader) u32 {
        return self._d_wr_as_peak;
    }
    pub inline fn getDWrSAvg(self: *const F2fsIostatLatencyFtraceEventReader) u32 {
        return self._d_wr_s_avg;
    }
    pub inline fn getDWrSCnt(self: *const F2fsIostatLatencyFtraceEventReader) u32 {
        return self._d_wr_s_cnt;
    }
    pub inline fn getDWrSPeak(self: *const F2fsIostatLatencyFtraceEventReader) u32 {
        return self._d_wr_s_peak;
    }
    pub inline fn getDev(self: *const F2fsIostatLatencyFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getMRdAvg(self: *const F2fsIostatLatencyFtraceEventReader) u32 {
        return self._m_rd_avg;
    }
    pub inline fn getMRdCnt(self: *const F2fsIostatLatencyFtraceEventReader) u32 {
        return self._m_rd_cnt;
    }
    pub inline fn getMRdPeak(self: *const F2fsIostatLatencyFtraceEventReader) u32 {
        return self._m_rd_peak;
    }
    pub inline fn getMWrAsAvg(self: *const F2fsIostatLatencyFtraceEventReader) u32 {
        return self._m_wr_as_avg;
    }
    pub inline fn getMWrAsCnt(self: *const F2fsIostatLatencyFtraceEventReader) u32 {
        return self._m_wr_as_cnt;
    }
    pub inline fn getMWrAsPeak(self: *const F2fsIostatLatencyFtraceEventReader) u32 {
        return self._m_wr_as_peak;
    }
    pub inline fn getMWrSAvg(self: *const F2fsIostatLatencyFtraceEventReader) u32 {
        return self._m_wr_s_avg;
    }
    pub inline fn getMWrSCnt(self: *const F2fsIostatLatencyFtraceEventReader) u32 {
        return self._m_wr_s_cnt;
    }
    pub inline fn getMWrSPeak(self: *const F2fsIostatLatencyFtraceEventReader) u32 {
        return self._m_wr_s_peak;
    }
    pub inline fn getNRdAvg(self: *const F2fsIostatLatencyFtraceEventReader) u32 {
        return self._n_rd_avg;
    }
    pub inline fn getNRdCnt(self: *const F2fsIostatLatencyFtraceEventReader) u32 {
        return self._n_rd_cnt;
    }
    pub inline fn getNRdPeak(self: *const F2fsIostatLatencyFtraceEventReader) u32 {
        return self._n_rd_peak;
    }
    pub inline fn getNWrAsAvg(self: *const F2fsIostatLatencyFtraceEventReader) u32 {
        return self._n_wr_as_avg;
    }
    pub inline fn getNWrAsCnt(self: *const F2fsIostatLatencyFtraceEventReader) u32 {
        return self._n_wr_as_cnt;
    }
    pub inline fn getNWrAsPeak(self: *const F2fsIostatLatencyFtraceEventReader) u32 {
        return self._n_wr_as_peak;
    }
    pub inline fn getNWrSAvg(self: *const F2fsIostatLatencyFtraceEventReader) u32 {
        return self._n_wr_s_avg;
    }
    pub inline fn getNWrSCnt(self: *const F2fsIostatLatencyFtraceEventReader) u32 {
        return self._n_wr_s_cnt;
    }
    pub inline fn getNWrSPeak(self: *const F2fsIostatLatencyFtraceEventReader) u32 {
        return self._n_wr_s_peak;
    }
};
const F2fsBackgroundGcFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const WAIT_MS_WIRE: gremlin.ProtoWireNumber = 2;
    const PREFREE_WIRE: gremlin.ProtoWireNumber = 3;
    const FREE_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const F2fsBackgroundGcFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    wait_ms: u32 = 0,
    prefree: u32 = 0,
    free: u32 = 0,
    pub fn calcProtobufSize(self: *const F2fsBackgroundGcFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsBackgroundGcFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.wait_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsBackgroundGcFtraceEventWire.WAIT_MS_WIRE) + gremlin.sizes.sizeU32(self.wait_ms);
        }
        if (self.prefree != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsBackgroundGcFtraceEventWire.PREFREE_WIRE) + gremlin.sizes.sizeU32(self.prefree);
        }
        if (self.free != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsBackgroundGcFtraceEventWire.FREE_WIRE) + gremlin.sizes.sizeU32(self.free);
        }
        return res;
    }
    pub fn encode(self: *const F2fsBackgroundGcFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const F2fsBackgroundGcFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(F2fsBackgroundGcFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.wait_ms != 0) {
            target.appendUint32(F2fsBackgroundGcFtraceEventWire.WAIT_MS_WIRE, self.wait_ms);
        }
        if (self.prefree != 0) {
            target.appendUint32(F2fsBackgroundGcFtraceEventWire.PREFREE_WIRE, self.prefree);
        }
        if (self.free != 0) {
            target.appendUint32(F2fsBackgroundGcFtraceEventWire.FREE_WIRE, self.free);
        }
    }
};
pub const F2fsBackgroundGcFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _wait_ms: u32 = 0,
    _prefree: u32 = 0,
    _free: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!F2fsBackgroundGcFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = F2fsBackgroundGcFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                F2fsBackgroundGcFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                F2fsBackgroundGcFtraceEventWire.WAIT_MS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._wait_ms = result.value;
                },
                F2fsBackgroundGcFtraceEventWire.PREFREE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._prefree = result.value;
                },
                F2fsBackgroundGcFtraceEventWire.FREE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._free = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const F2fsBackgroundGcFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getWaitMs(self: *const F2fsBackgroundGcFtraceEventReader) u32 {
        return self._wait_ms;
    }
    pub inline fn getPrefree(self: *const F2fsBackgroundGcFtraceEventReader) u32 {
        return self._prefree;
    }
    pub inline fn getFree(self: *const F2fsBackgroundGcFtraceEventReader) u32 {
        return self._free;
    }
};
const F2fsGcBeginFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const SYNC_WIRE: gremlin.ProtoWireNumber = 2;
    const BACKGROUND_WIRE: gremlin.ProtoWireNumber = 3;
    const DIRTY_NODES_WIRE: gremlin.ProtoWireNumber = 4;
    const DIRTY_DENTS_WIRE: gremlin.ProtoWireNumber = 5;
    const DIRTY_IMETA_WIRE: gremlin.ProtoWireNumber = 6;
    const FREE_SEC_WIRE: gremlin.ProtoWireNumber = 7;
    const FREE_SEG_WIRE: gremlin.ProtoWireNumber = 8;
    const RESERVED_SEG_WIRE: gremlin.ProtoWireNumber = 9;
    const PREFREE_SEG_WIRE: gremlin.ProtoWireNumber = 10;
    const GC_TYPE_WIRE: gremlin.ProtoWireNumber = 11;
    const NO_BG_GC_WIRE: gremlin.ProtoWireNumber = 12;
    const NR_FREE_SECS_WIRE: gremlin.ProtoWireNumber = 13;
};
pub const F2fsGcBeginFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    sync: u32 = 0,
    background: u32 = 0,
    dirty_nodes: i64 = 0,
    dirty_dents: i64 = 0,
    dirty_imeta: i64 = 0,
    free_sec: u32 = 0,
    free_seg: u32 = 0,
    reserved_seg: i32 = 0,
    prefree_seg: u32 = 0,
    gc_type: i32 = 0,
    no_bg_gc: u32 = 0,
    nr_free_secs: u32 = 0,
    pub fn calcProtobufSize(self: *const F2fsGcBeginFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsGcBeginFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.sync != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsGcBeginFtraceEventWire.SYNC_WIRE) + gremlin.sizes.sizeU32(self.sync);
        }
        if (self.background != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsGcBeginFtraceEventWire.BACKGROUND_WIRE) + gremlin.sizes.sizeU32(self.background);
        }
        if (self.dirty_nodes != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsGcBeginFtraceEventWire.DIRTY_NODES_WIRE) + gremlin.sizes.sizeI64(self.dirty_nodes);
        }
        if (self.dirty_dents != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsGcBeginFtraceEventWire.DIRTY_DENTS_WIRE) + gremlin.sizes.sizeI64(self.dirty_dents);
        }
        if (self.dirty_imeta != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsGcBeginFtraceEventWire.DIRTY_IMETA_WIRE) + gremlin.sizes.sizeI64(self.dirty_imeta);
        }
        if (self.free_sec != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsGcBeginFtraceEventWire.FREE_SEC_WIRE) + gremlin.sizes.sizeU32(self.free_sec);
        }
        if (self.free_seg != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsGcBeginFtraceEventWire.FREE_SEG_WIRE) + gremlin.sizes.sizeU32(self.free_seg);
        }
        if (self.reserved_seg != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsGcBeginFtraceEventWire.RESERVED_SEG_WIRE) + gremlin.sizes.sizeI32(self.reserved_seg);
        }
        if (self.prefree_seg != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsGcBeginFtraceEventWire.PREFREE_SEG_WIRE) + gremlin.sizes.sizeU32(self.prefree_seg);
        }
        if (self.gc_type != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsGcBeginFtraceEventWire.GC_TYPE_WIRE) + gremlin.sizes.sizeI32(self.gc_type);
        }
        if (self.no_bg_gc != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsGcBeginFtraceEventWire.NO_BG_GC_WIRE) + gremlin.sizes.sizeU32(self.no_bg_gc);
        }
        if (self.nr_free_secs != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsGcBeginFtraceEventWire.NR_FREE_SECS_WIRE) + gremlin.sizes.sizeU32(self.nr_free_secs);
        }
        return res;
    }
    pub fn encode(self: *const F2fsGcBeginFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const F2fsGcBeginFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(F2fsGcBeginFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.sync != 0) {
            target.appendUint32(F2fsGcBeginFtraceEventWire.SYNC_WIRE, self.sync);
        }
        if (self.background != 0) {
            target.appendUint32(F2fsGcBeginFtraceEventWire.BACKGROUND_WIRE, self.background);
        }
        if (self.dirty_nodes != 0) {
            target.appendInt64(F2fsGcBeginFtraceEventWire.DIRTY_NODES_WIRE, self.dirty_nodes);
        }
        if (self.dirty_dents != 0) {
            target.appendInt64(F2fsGcBeginFtraceEventWire.DIRTY_DENTS_WIRE, self.dirty_dents);
        }
        if (self.dirty_imeta != 0) {
            target.appendInt64(F2fsGcBeginFtraceEventWire.DIRTY_IMETA_WIRE, self.dirty_imeta);
        }
        if (self.free_sec != 0) {
            target.appendUint32(F2fsGcBeginFtraceEventWire.FREE_SEC_WIRE, self.free_sec);
        }
        if (self.free_seg != 0) {
            target.appendUint32(F2fsGcBeginFtraceEventWire.FREE_SEG_WIRE, self.free_seg);
        }
        if (self.reserved_seg != 0) {
            target.appendInt32(F2fsGcBeginFtraceEventWire.RESERVED_SEG_WIRE, self.reserved_seg);
        }
        if (self.prefree_seg != 0) {
            target.appendUint32(F2fsGcBeginFtraceEventWire.PREFREE_SEG_WIRE, self.prefree_seg);
        }
        if (self.gc_type != 0) {
            target.appendInt32(F2fsGcBeginFtraceEventWire.GC_TYPE_WIRE, self.gc_type);
        }
        if (self.no_bg_gc != 0) {
            target.appendUint32(F2fsGcBeginFtraceEventWire.NO_BG_GC_WIRE, self.no_bg_gc);
        }
        if (self.nr_free_secs != 0) {
            target.appendUint32(F2fsGcBeginFtraceEventWire.NR_FREE_SECS_WIRE, self.nr_free_secs);
        }
    }
};
pub const F2fsGcBeginFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _sync: u32 = 0,
    _background: u32 = 0,
    _dirty_nodes: i64 = 0,
    _dirty_dents: i64 = 0,
    _dirty_imeta: i64 = 0,
    _free_sec: u32 = 0,
    _free_seg: u32 = 0,
    _reserved_seg: i32 = 0,
    _prefree_seg: u32 = 0,
    _gc_type: i32 = 0,
    _no_bg_gc: u32 = 0,
    _nr_free_secs: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!F2fsGcBeginFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = F2fsGcBeginFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                F2fsGcBeginFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                F2fsGcBeginFtraceEventWire.SYNC_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._sync = result.value;
                },
                F2fsGcBeginFtraceEventWire.BACKGROUND_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._background = result.value;
                },
                F2fsGcBeginFtraceEventWire.DIRTY_NODES_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._dirty_nodes = result.value;
                },
                F2fsGcBeginFtraceEventWire.DIRTY_DENTS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._dirty_dents = result.value;
                },
                F2fsGcBeginFtraceEventWire.DIRTY_IMETA_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._dirty_imeta = result.value;
                },
                F2fsGcBeginFtraceEventWire.FREE_SEC_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._free_sec = result.value;
                },
                F2fsGcBeginFtraceEventWire.FREE_SEG_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._free_seg = result.value;
                },
                F2fsGcBeginFtraceEventWire.RESERVED_SEG_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._reserved_seg = result.value;
                },
                F2fsGcBeginFtraceEventWire.PREFREE_SEG_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._prefree_seg = result.value;
                },
                F2fsGcBeginFtraceEventWire.GC_TYPE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._gc_type = result.value;
                },
                F2fsGcBeginFtraceEventWire.NO_BG_GC_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._no_bg_gc = result.value;
                },
                F2fsGcBeginFtraceEventWire.NR_FREE_SECS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._nr_free_secs = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const F2fsGcBeginFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getSync(self: *const F2fsGcBeginFtraceEventReader) u32 {
        return self._sync;
    }
    pub inline fn getBackground(self: *const F2fsGcBeginFtraceEventReader) u32 {
        return self._background;
    }
    pub inline fn getDirtyNodes(self: *const F2fsGcBeginFtraceEventReader) i64 {
        return self._dirty_nodes;
    }
    pub inline fn getDirtyDents(self: *const F2fsGcBeginFtraceEventReader) i64 {
        return self._dirty_dents;
    }
    pub inline fn getDirtyImeta(self: *const F2fsGcBeginFtraceEventReader) i64 {
        return self._dirty_imeta;
    }
    pub inline fn getFreeSec(self: *const F2fsGcBeginFtraceEventReader) u32 {
        return self._free_sec;
    }
    pub inline fn getFreeSeg(self: *const F2fsGcBeginFtraceEventReader) u32 {
        return self._free_seg;
    }
    pub inline fn getReservedSeg(self: *const F2fsGcBeginFtraceEventReader) i32 {
        return self._reserved_seg;
    }
    pub inline fn getPrefreeSeg(self: *const F2fsGcBeginFtraceEventReader) u32 {
        return self._prefree_seg;
    }
    pub inline fn getGcType(self: *const F2fsGcBeginFtraceEventReader) i32 {
        return self._gc_type;
    }
    pub inline fn getNoBgGc(self: *const F2fsGcBeginFtraceEventReader) u32 {
        return self._no_bg_gc;
    }
    pub inline fn getNrFreeSecs(self: *const F2fsGcBeginFtraceEventReader) u32 {
        return self._nr_free_secs;
    }
};
const F2fsGcEndFtraceEventWire = struct {
    const DEV_WIRE: gremlin.ProtoWireNumber = 1;
    const RET_WIRE: gremlin.ProtoWireNumber = 2;
    const SEG_FREED_WIRE: gremlin.ProtoWireNumber = 3;
    const SEC_FREED_WIRE: gremlin.ProtoWireNumber = 4;
    const DIRTY_NODES_WIRE: gremlin.ProtoWireNumber = 5;
    const DIRTY_DENTS_WIRE: gremlin.ProtoWireNumber = 6;
    const DIRTY_IMETA_WIRE: gremlin.ProtoWireNumber = 7;
    const FREE_SEC_WIRE: gremlin.ProtoWireNumber = 8;
    const FREE_SEG_WIRE: gremlin.ProtoWireNumber = 9;
    const RESERVED_SEG_WIRE: gremlin.ProtoWireNumber = 10;
    const PREFREE_SEG_WIRE: gremlin.ProtoWireNumber = 11;
};
pub const F2fsGcEndFtraceEvent = struct {
    // fields
    dev: u64 = 0,
    ret: i32 = 0,
    seg_freed: i32 = 0,
    sec_freed: i32 = 0,
    dirty_nodes: i64 = 0,
    dirty_dents: i64 = 0,
    dirty_imeta: i64 = 0,
    free_sec: u32 = 0,
    free_seg: u32 = 0,
    reserved_seg: i32 = 0,
    prefree_seg: u32 = 0,
    pub fn calcProtobufSize(self: *const F2fsGcEndFtraceEvent) usize {
        var res: usize = 0;
        if (self.dev != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsGcEndFtraceEventWire.DEV_WIRE) + gremlin.sizes.sizeU64(self.dev);
        }
        if (self.ret != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsGcEndFtraceEventWire.RET_WIRE) + gremlin.sizes.sizeI32(self.ret);
        }
        if (self.seg_freed != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsGcEndFtraceEventWire.SEG_FREED_WIRE) + gremlin.sizes.sizeI32(self.seg_freed);
        }
        if (self.sec_freed != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsGcEndFtraceEventWire.SEC_FREED_WIRE) + gremlin.sizes.sizeI32(self.sec_freed);
        }
        if (self.dirty_nodes != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsGcEndFtraceEventWire.DIRTY_NODES_WIRE) + gremlin.sizes.sizeI64(self.dirty_nodes);
        }
        if (self.dirty_dents != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsGcEndFtraceEventWire.DIRTY_DENTS_WIRE) + gremlin.sizes.sizeI64(self.dirty_dents);
        }
        if (self.dirty_imeta != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsGcEndFtraceEventWire.DIRTY_IMETA_WIRE) + gremlin.sizes.sizeI64(self.dirty_imeta);
        }
        if (self.free_sec != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsGcEndFtraceEventWire.FREE_SEC_WIRE) + gremlin.sizes.sizeU32(self.free_sec);
        }
        if (self.free_seg != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsGcEndFtraceEventWire.FREE_SEG_WIRE) + gremlin.sizes.sizeU32(self.free_seg);
        }
        if (self.reserved_seg != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsGcEndFtraceEventWire.RESERVED_SEG_WIRE) + gremlin.sizes.sizeI32(self.reserved_seg);
        }
        if (self.prefree_seg != 0) {
            res += gremlin.sizes.sizeWireNumber(F2fsGcEndFtraceEventWire.PREFREE_SEG_WIRE) + gremlin.sizes.sizeU32(self.prefree_seg);
        }
        return res;
    }
    pub fn encode(self: *const F2fsGcEndFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const F2fsGcEndFtraceEvent, target: *gremlin.Writer) void {
        if (self.dev != 0) {
            target.appendUint64(F2fsGcEndFtraceEventWire.DEV_WIRE, self.dev);
        }
        if (self.ret != 0) {
            target.appendInt32(F2fsGcEndFtraceEventWire.RET_WIRE, self.ret);
        }
        if (self.seg_freed != 0) {
            target.appendInt32(F2fsGcEndFtraceEventWire.SEG_FREED_WIRE, self.seg_freed);
        }
        if (self.sec_freed != 0) {
            target.appendInt32(F2fsGcEndFtraceEventWire.SEC_FREED_WIRE, self.sec_freed);
        }
        if (self.dirty_nodes != 0) {
            target.appendInt64(F2fsGcEndFtraceEventWire.DIRTY_NODES_WIRE, self.dirty_nodes);
        }
        if (self.dirty_dents != 0) {
            target.appendInt64(F2fsGcEndFtraceEventWire.DIRTY_DENTS_WIRE, self.dirty_dents);
        }
        if (self.dirty_imeta != 0) {
            target.appendInt64(F2fsGcEndFtraceEventWire.DIRTY_IMETA_WIRE, self.dirty_imeta);
        }
        if (self.free_sec != 0) {
            target.appendUint32(F2fsGcEndFtraceEventWire.FREE_SEC_WIRE, self.free_sec);
        }
        if (self.free_seg != 0) {
            target.appendUint32(F2fsGcEndFtraceEventWire.FREE_SEG_WIRE, self.free_seg);
        }
        if (self.reserved_seg != 0) {
            target.appendInt32(F2fsGcEndFtraceEventWire.RESERVED_SEG_WIRE, self.reserved_seg);
        }
        if (self.prefree_seg != 0) {
            target.appendUint32(F2fsGcEndFtraceEventWire.PREFREE_SEG_WIRE, self.prefree_seg);
        }
    }
};
pub const F2fsGcEndFtraceEventReader = struct {
    buf: gremlin.Reader,
    _dev: u64 = 0,
    _ret: i32 = 0,
    _seg_freed: i32 = 0,
    _sec_freed: i32 = 0,
    _dirty_nodes: i64 = 0,
    _dirty_dents: i64 = 0,
    _dirty_imeta: i64 = 0,
    _free_sec: u32 = 0,
    _free_seg: u32 = 0,
    _reserved_seg: i32 = 0,
    _prefree_seg: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!F2fsGcEndFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = F2fsGcEndFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                F2fsGcEndFtraceEventWire.DEV_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._dev = result.value;
                },
                F2fsGcEndFtraceEventWire.RET_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._ret = result.value;
                },
                F2fsGcEndFtraceEventWire.SEG_FREED_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._seg_freed = result.value;
                },
                F2fsGcEndFtraceEventWire.SEC_FREED_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._sec_freed = result.value;
                },
                F2fsGcEndFtraceEventWire.DIRTY_NODES_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._dirty_nodes = result.value;
                },
                F2fsGcEndFtraceEventWire.DIRTY_DENTS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._dirty_dents = result.value;
                },
                F2fsGcEndFtraceEventWire.DIRTY_IMETA_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._dirty_imeta = result.value;
                },
                F2fsGcEndFtraceEventWire.FREE_SEC_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._free_sec = result.value;
                },
                F2fsGcEndFtraceEventWire.FREE_SEG_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._free_seg = result.value;
                },
                F2fsGcEndFtraceEventWire.RESERVED_SEG_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._reserved_seg = result.value;
                },
                F2fsGcEndFtraceEventWire.PREFREE_SEG_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._prefree_seg = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDev(self: *const F2fsGcEndFtraceEventReader) u64 {
        return self._dev;
    }
    pub inline fn getRet(self: *const F2fsGcEndFtraceEventReader) i32 {
        return self._ret;
    }
    pub inline fn getSegFreed(self: *const F2fsGcEndFtraceEventReader) i32 {
        return self._seg_freed;
    }
    pub inline fn getSecFreed(self: *const F2fsGcEndFtraceEventReader) i32 {
        return self._sec_freed;
    }
    pub inline fn getDirtyNodes(self: *const F2fsGcEndFtraceEventReader) i64 {
        return self._dirty_nodes;
    }
    pub inline fn getDirtyDents(self: *const F2fsGcEndFtraceEventReader) i64 {
        return self._dirty_dents;
    }
    pub inline fn getDirtyImeta(self: *const F2fsGcEndFtraceEventReader) i64 {
        return self._dirty_imeta;
    }
    pub inline fn getFreeSec(self: *const F2fsGcEndFtraceEventReader) u32 {
        return self._free_sec;
    }
    pub inline fn getFreeSeg(self: *const F2fsGcEndFtraceEventReader) u32 {
        return self._free_seg;
    }
    pub inline fn getReservedSeg(self: *const F2fsGcEndFtraceEventReader) i32 {
        return self._reserved_seg;
    }
    pub inline fn getPrefreeSeg(self: *const F2fsGcEndFtraceEventReader) u32 {
        return self._prefree_seg;
    }
};
