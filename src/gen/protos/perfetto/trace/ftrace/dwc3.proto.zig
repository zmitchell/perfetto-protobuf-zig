// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const Dwc3AllocRequestFtraceEventWire = struct {
    const NAME_WIRE: gremlin.ProtoWireNumber = 1;
    const REQ_WIRE: gremlin.ProtoWireNumber = 2;
    const ACTUAL_WIRE: gremlin.ProtoWireNumber = 3;
    const LENGTH_WIRE: gremlin.ProtoWireNumber = 4;
    const STATUS_WIRE: gremlin.ProtoWireNumber = 5;
    const ZERO_WIRE: gremlin.ProtoWireNumber = 6;
    const SHORT_NOT_OK_WIRE: gremlin.ProtoWireNumber = 7;
    const NO_INTERRUPT_WIRE: gremlin.ProtoWireNumber = 8;
};
pub const Dwc3AllocRequestFtraceEvent = struct {
    // fields
    name: ?[]const u8 = null,
    req: u64 = 0,
    actual: u32 = 0,
    length: u32 = 0,
    status: i32 = 0,
    zero: i32 = 0,
    short_not_ok: i32 = 0,
    no_interrupt: i32 = 0,
    pub fn calcProtobufSize(self: *const Dwc3AllocRequestFtraceEvent) usize {
        var res: usize = 0;
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(Dwc3AllocRequestFtraceEventWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.req != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3AllocRequestFtraceEventWire.REQ_WIRE) + gremlin.sizes.sizeU64(self.req);
        }
        if (self.actual != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3AllocRequestFtraceEventWire.ACTUAL_WIRE) + gremlin.sizes.sizeU32(self.actual);
        }
        if (self.length != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3AllocRequestFtraceEventWire.LENGTH_WIRE) + gremlin.sizes.sizeU32(self.length);
        }
        if (self.status != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3AllocRequestFtraceEventWire.STATUS_WIRE) + gremlin.sizes.sizeI32(self.status);
        }
        if (self.zero != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3AllocRequestFtraceEventWire.ZERO_WIRE) + gremlin.sizes.sizeI32(self.zero);
        }
        if (self.short_not_ok != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3AllocRequestFtraceEventWire.SHORT_NOT_OK_WIRE) + gremlin.sizes.sizeI32(self.short_not_ok);
        }
        if (self.no_interrupt != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3AllocRequestFtraceEventWire.NO_INTERRUPT_WIRE) + gremlin.sizes.sizeI32(self.no_interrupt);
        }
        return res;
    }
    pub fn encode(self: *const Dwc3AllocRequestFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Dwc3AllocRequestFtraceEvent, target: *gremlin.Writer) void {
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(Dwc3AllocRequestFtraceEventWire.NAME_WIRE, v);
            }
        }
        if (self.req != 0) {
            target.appendUint64(Dwc3AllocRequestFtraceEventWire.REQ_WIRE, self.req);
        }
        if (self.actual != 0) {
            target.appendUint32(Dwc3AllocRequestFtraceEventWire.ACTUAL_WIRE, self.actual);
        }
        if (self.length != 0) {
            target.appendUint32(Dwc3AllocRequestFtraceEventWire.LENGTH_WIRE, self.length);
        }
        if (self.status != 0) {
            target.appendInt32(Dwc3AllocRequestFtraceEventWire.STATUS_WIRE, self.status);
        }
        if (self.zero != 0) {
            target.appendInt32(Dwc3AllocRequestFtraceEventWire.ZERO_WIRE, self.zero);
        }
        if (self.short_not_ok != 0) {
            target.appendInt32(Dwc3AllocRequestFtraceEventWire.SHORT_NOT_OK_WIRE, self.short_not_ok);
        }
        if (self.no_interrupt != 0) {
            target.appendInt32(Dwc3AllocRequestFtraceEventWire.NO_INTERRUPT_WIRE, self.no_interrupt);
        }
    }
};
pub const Dwc3AllocRequestFtraceEventReader = struct {
    buf: gremlin.Reader,
    _name: ?[]const u8 = null,
    _req: u64 = 0,
    _actual: u32 = 0,
    _length: u32 = 0,
    _status: i32 = 0,
    _zero: i32 = 0,
    _short_not_ok: i32 = 0,
    _no_interrupt: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Dwc3AllocRequestFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Dwc3AllocRequestFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Dwc3AllocRequestFtraceEventWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                Dwc3AllocRequestFtraceEventWire.REQ_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._req = result.value;
                },
                Dwc3AllocRequestFtraceEventWire.ACTUAL_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._actual = result.value;
                },
                Dwc3AllocRequestFtraceEventWire.LENGTH_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._length = result.value;
                },
                Dwc3AllocRequestFtraceEventWire.STATUS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._status = result.value;
                },
                Dwc3AllocRequestFtraceEventWire.ZERO_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._zero = result.value;
                },
                Dwc3AllocRequestFtraceEventWire.SHORT_NOT_OK_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._short_not_ok = result.value;
                },
                Dwc3AllocRequestFtraceEventWire.NO_INTERRUPT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._no_interrupt = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getName(self: *const Dwc3AllocRequestFtraceEventReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub inline fn getReq(self: *const Dwc3AllocRequestFtraceEventReader) u64 {
        return self._req;
    }
    pub inline fn getActual(self: *const Dwc3AllocRequestFtraceEventReader) u32 {
        return self._actual;
    }
    pub inline fn getLength(self: *const Dwc3AllocRequestFtraceEventReader) u32 {
        return self._length;
    }
    pub inline fn getStatus(self: *const Dwc3AllocRequestFtraceEventReader) i32 {
        return self._status;
    }
    pub inline fn getZero(self: *const Dwc3AllocRequestFtraceEventReader) i32 {
        return self._zero;
    }
    pub inline fn getShortNotOk(self: *const Dwc3AllocRequestFtraceEventReader) i32 {
        return self._short_not_ok;
    }
    pub inline fn getNoInterrupt(self: *const Dwc3AllocRequestFtraceEventReader) i32 {
        return self._no_interrupt;
    }
};
const Dwc3CompleteTrbFtraceEventWire = struct {
    const NAME_WIRE: gremlin.ProtoWireNumber = 1;
    const TRB_WIRE: gremlin.ProtoWireNumber = 2;
    const ALLOCATED_WIRE: gremlin.ProtoWireNumber = 3;
    const QUEUED_WIRE: gremlin.ProtoWireNumber = 4;
    const BPL_WIRE: gremlin.ProtoWireNumber = 5;
    const BPH_WIRE: gremlin.ProtoWireNumber = 6;
    const SIZE_WIRE: gremlin.ProtoWireNumber = 7;
    const CTRL_WIRE: gremlin.ProtoWireNumber = 8;
    const TYPE_WIRE: gremlin.ProtoWireNumber = 9;
    const ENQUEUE_WIRE: gremlin.ProtoWireNumber = 10;
    const DEQUEUE_WIRE: gremlin.ProtoWireNumber = 11;
};
pub const Dwc3CompleteTrbFtraceEvent = struct {
    // fields
    name: ?[]const u8 = null,
    trb: u64 = 0,
    allocated: u32 = 0,
    queued: u32 = 0,
    bpl: u32 = 0,
    bph: u32 = 0,
    size: u32 = 0,
    ctrl: u32 = 0,
    type: u32 = 0,
    enqueue: u32 = 0,
    dequeue: u32 = 0,
    pub fn calcProtobufSize(self: *const Dwc3CompleteTrbFtraceEvent) usize {
        var res: usize = 0;
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(Dwc3CompleteTrbFtraceEventWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.trb != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3CompleteTrbFtraceEventWire.TRB_WIRE) + gremlin.sizes.sizeU64(self.trb);
        }
        if (self.allocated != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3CompleteTrbFtraceEventWire.ALLOCATED_WIRE) + gremlin.sizes.sizeU32(self.allocated);
        }
        if (self.queued != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3CompleteTrbFtraceEventWire.QUEUED_WIRE) + gremlin.sizes.sizeU32(self.queued);
        }
        if (self.bpl != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3CompleteTrbFtraceEventWire.BPL_WIRE) + gremlin.sizes.sizeU32(self.bpl);
        }
        if (self.bph != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3CompleteTrbFtraceEventWire.BPH_WIRE) + gremlin.sizes.sizeU32(self.bph);
        }
        if (self.size != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3CompleteTrbFtraceEventWire.SIZE_WIRE) + gremlin.sizes.sizeU32(self.size);
        }
        if (self.ctrl != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3CompleteTrbFtraceEventWire.CTRL_WIRE) + gremlin.sizes.sizeU32(self.ctrl);
        }
        if (self.type != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3CompleteTrbFtraceEventWire.TYPE_WIRE) + gremlin.sizes.sizeU32(self.type);
        }
        if (self.enqueue != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3CompleteTrbFtraceEventWire.ENQUEUE_WIRE) + gremlin.sizes.sizeU32(self.enqueue);
        }
        if (self.dequeue != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3CompleteTrbFtraceEventWire.DEQUEUE_WIRE) + gremlin.sizes.sizeU32(self.dequeue);
        }
        return res;
    }
    pub fn encode(self: *const Dwc3CompleteTrbFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Dwc3CompleteTrbFtraceEvent, target: *gremlin.Writer) void {
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(Dwc3CompleteTrbFtraceEventWire.NAME_WIRE, v);
            }
        }
        if (self.trb != 0) {
            target.appendUint64(Dwc3CompleteTrbFtraceEventWire.TRB_WIRE, self.trb);
        }
        if (self.allocated != 0) {
            target.appendUint32(Dwc3CompleteTrbFtraceEventWire.ALLOCATED_WIRE, self.allocated);
        }
        if (self.queued != 0) {
            target.appendUint32(Dwc3CompleteTrbFtraceEventWire.QUEUED_WIRE, self.queued);
        }
        if (self.bpl != 0) {
            target.appendUint32(Dwc3CompleteTrbFtraceEventWire.BPL_WIRE, self.bpl);
        }
        if (self.bph != 0) {
            target.appendUint32(Dwc3CompleteTrbFtraceEventWire.BPH_WIRE, self.bph);
        }
        if (self.size != 0) {
            target.appendUint32(Dwc3CompleteTrbFtraceEventWire.SIZE_WIRE, self.size);
        }
        if (self.ctrl != 0) {
            target.appendUint32(Dwc3CompleteTrbFtraceEventWire.CTRL_WIRE, self.ctrl);
        }
        if (self.type != 0) {
            target.appendUint32(Dwc3CompleteTrbFtraceEventWire.TYPE_WIRE, self.type);
        }
        if (self.enqueue != 0) {
            target.appendUint32(Dwc3CompleteTrbFtraceEventWire.ENQUEUE_WIRE, self.enqueue);
        }
        if (self.dequeue != 0) {
            target.appendUint32(Dwc3CompleteTrbFtraceEventWire.DEQUEUE_WIRE, self.dequeue);
        }
    }
};
pub const Dwc3CompleteTrbFtraceEventReader = struct {
    buf: gremlin.Reader,
    _name: ?[]const u8 = null,
    _trb: u64 = 0,
    _allocated: u32 = 0,
    _queued: u32 = 0,
    _bpl: u32 = 0,
    _bph: u32 = 0,
    _size: u32 = 0,
    _ctrl: u32 = 0,
    _type: u32 = 0,
    _enqueue: u32 = 0,
    _dequeue: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Dwc3CompleteTrbFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Dwc3CompleteTrbFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Dwc3CompleteTrbFtraceEventWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                Dwc3CompleteTrbFtraceEventWire.TRB_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._trb = result.value;
                },
                Dwc3CompleteTrbFtraceEventWire.ALLOCATED_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._allocated = result.value;
                },
                Dwc3CompleteTrbFtraceEventWire.QUEUED_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._queued = result.value;
                },
                Dwc3CompleteTrbFtraceEventWire.BPL_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._bpl = result.value;
                },
                Dwc3CompleteTrbFtraceEventWire.BPH_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._bph = result.value;
                },
                Dwc3CompleteTrbFtraceEventWire.SIZE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._size = result.value;
                },
                Dwc3CompleteTrbFtraceEventWire.CTRL_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._ctrl = result.value;
                },
                Dwc3CompleteTrbFtraceEventWire.TYPE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._type = result.value;
                },
                Dwc3CompleteTrbFtraceEventWire.ENQUEUE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._enqueue = result.value;
                },
                Dwc3CompleteTrbFtraceEventWire.DEQUEUE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._dequeue = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getName(self: *const Dwc3CompleteTrbFtraceEventReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub inline fn getTrb(self: *const Dwc3CompleteTrbFtraceEventReader) u64 {
        return self._trb;
    }
    pub inline fn getAllocated(self: *const Dwc3CompleteTrbFtraceEventReader) u32 {
        return self._allocated;
    }
    pub inline fn getQueued(self: *const Dwc3CompleteTrbFtraceEventReader) u32 {
        return self._queued;
    }
    pub inline fn getBpl(self: *const Dwc3CompleteTrbFtraceEventReader) u32 {
        return self._bpl;
    }
    pub inline fn getBph(self: *const Dwc3CompleteTrbFtraceEventReader) u32 {
        return self._bph;
    }
    pub inline fn getSize(self: *const Dwc3CompleteTrbFtraceEventReader) u32 {
        return self._size;
    }
    pub inline fn getCtrl(self: *const Dwc3CompleteTrbFtraceEventReader) u32 {
        return self._ctrl;
    }
    pub inline fn getType(self: *const Dwc3CompleteTrbFtraceEventReader) u32 {
        return self._type;
    }
    pub inline fn getEnqueue(self: *const Dwc3CompleteTrbFtraceEventReader) u32 {
        return self._enqueue;
    }
    pub inline fn getDequeue(self: *const Dwc3CompleteTrbFtraceEventReader) u32 {
        return self._dequeue;
    }
};
const Dwc3CtrlReqFtraceEventWire = struct {
    const B_REQUEST_TYPE_WIRE: gremlin.ProtoWireNumber = 1;
    const B_REQUEST_WIRE: gremlin.ProtoWireNumber = 2;
    const W_VALUE_WIRE: gremlin.ProtoWireNumber = 3;
    const W_INDEX_WIRE: gremlin.ProtoWireNumber = 4;
    const W_LENGTH_WIRE: gremlin.ProtoWireNumber = 5;
    const STR_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const Dwc3CtrlReqFtraceEvent = struct {
    // fields
    b_request_type: u32 = 0,
    b_request: u32 = 0,
    w_value: u32 = 0,
    w_index: u32 = 0,
    w_length: u32 = 0,
    str: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const Dwc3CtrlReqFtraceEvent) usize {
        var res: usize = 0;
        if (self.b_request_type != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3CtrlReqFtraceEventWire.B_REQUEST_TYPE_WIRE) + gremlin.sizes.sizeU32(self.b_request_type);
        }
        if (self.b_request != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3CtrlReqFtraceEventWire.B_REQUEST_WIRE) + gremlin.sizes.sizeU32(self.b_request);
        }
        if (self.w_value != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3CtrlReqFtraceEventWire.W_VALUE_WIRE) + gremlin.sizes.sizeU32(self.w_value);
        }
        if (self.w_index != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3CtrlReqFtraceEventWire.W_INDEX_WIRE) + gremlin.sizes.sizeU32(self.w_index);
        }
        if (self.w_length != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3CtrlReqFtraceEventWire.W_LENGTH_WIRE) + gremlin.sizes.sizeU32(self.w_length);
        }
        if (self.str) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(Dwc3CtrlReqFtraceEventWire.STR_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const Dwc3CtrlReqFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Dwc3CtrlReqFtraceEvent, target: *gremlin.Writer) void {
        if (self.b_request_type != 0) {
            target.appendUint32(Dwc3CtrlReqFtraceEventWire.B_REQUEST_TYPE_WIRE, self.b_request_type);
        }
        if (self.b_request != 0) {
            target.appendUint32(Dwc3CtrlReqFtraceEventWire.B_REQUEST_WIRE, self.b_request);
        }
        if (self.w_value != 0) {
            target.appendUint32(Dwc3CtrlReqFtraceEventWire.W_VALUE_WIRE, self.w_value);
        }
        if (self.w_index != 0) {
            target.appendUint32(Dwc3CtrlReqFtraceEventWire.W_INDEX_WIRE, self.w_index);
        }
        if (self.w_length != 0) {
            target.appendUint32(Dwc3CtrlReqFtraceEventWire.W_LENGTH_WIRE, self.w_length);
        }
        if (self.str) |v| {
            if (v.len > 0) {
                target.appendBytes(Dwc3CtrlReqFtraceEventWire.STR_WIRE, v);
            }
        }
    }
};
pub const Dwc3CtrlReqFtraceEventReader = struct {
    buf: gremlin.Reader,
    _b_request_type: u32 = 0,
    _b_request: u32 = 0,
    _w_value: u32 = 0,
    _w_index: u32 = 0,
    _w_length: u32 = 0,
    _str: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!Dwc3CtrlReqFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Dwc3CtrlReqFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Dwc3CtrlReqFtraceEventWire.B_REQUEST_TYPE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._b_request_type = result.value;
                },
                Dwc3CtrlReqFtraceEventWire.B_REQUEST_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._b_request = result.value;
                },
                Dwc3CtrlReqFtraceEventWire.W_VALUE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._w_value = result.value;
                },
                Dwc3CtrlReqFtraceEventWire.W_INDEX_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._w_index = result.value;
                },
                Dwc3CtrlReqFtraceEventWire.W_LENGTH_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._w_length = result.value;
                },
                Dwc3CtrlReqFtraceEventWire.STR_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._str = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getBRequestType(self: *const Dwc3CtrlReqFtraceEventReader) u32 {
        return self._b_request_type;
    }
    pub inline fn getBRequest(self: *const Dwc3CtrlReqFtraceEventReader) u32 {
        return self._b_request;
    }
    pub inline fn getWValue(self: *const Dwc3CtrlReqFtraceEventReader) u32 {
        return self._w_value;
    }
    pub inline fn getWIndex(self: *const Dwc3CtrlReqFtraceEventReader) u32 {
        return self._w_index;
    }
    pub inline fn getWLength(self: *const Dwc3CtrlReqFtraceEventReader) u32 {
        return self._w_length;
    }
    pub inline fn getStr(self: *const Dwc3CtrlReqFtraceEventReader) []const u8 {
        return self._str orelse &[_]u8{};
    }
};
const Dwc3EpDequeueFtraceEventWire = struct {
    const NAME_WIRE: gremlin.ProtoWireNumber = 1;
    const REQ_WIRE: gremlin.ProtoWireNumber = 2;
    const ACTUAL_WIRE: gremlin.ProtoWireNumber = 3;
    const LENGTH_WIRE: gremlin.ProtoWireNumber = 4;
    const STATUS_WIRE: gremlin.ProtoWireNumber = 5;
    const ZERO_WIRE: gremlin.ProtoWireNumber = 6;
    const SHORT_NOT_OK_WIRE: gremlin.ProtoWireNumber = 7;
    const NO_INTERRUPT_WIRE: gremlin.ProtoWireNumber = 8;
};
pub const Dwc3EpDequeueFtraceEvent = struct {
    // fields
    name: ?[]const u8 = null,
    req: u64 = 0,
    actual: u32 = 0,
    length: u32 = 0,
    status: i32 = 0,
    zero: i32 = 0,
    short_not_ok: i32 = 0,
    no_interrupt: i32 = 0,
    pub fn calcProtobufSize(self: *const Dwc3EpDequeueFtraceEvent) usize {
        var res: usize = 0;
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(Dwc3EpDequeueFtraceEventWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.req != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3EpDequeueFtraceEventWire.REQ_WIRE) + gremlin.sizes.sizeU64(self.req);
        }
        if (self.actual != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3EpDequeueFtraceEventWire.ACTUAL_WIRE) + gremlin.sizes.sizeU32(self.actual);
        }
        if (self.length != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3EpDequeueFtraceEventWire.LENGTH_WIRE) + gremlin.sizes.sizeU32(self.length);
        }
        if (self.status != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3EpDequeueFtraceEventWire.STATUS_WIRE) + gremlin.sizes.sizeI32(self.status);
        }
        if (self.zero != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3EpDequeueFtraceEventWire.ZERO_WIRE) + gremlin.sizes.sizeI32(self.zero);
        }
        if (self.short_not_ok != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3EpDequeueFtraceEventWire.SHORT_NOT_OK_WIRE) + gremlin.sizes.sizeI32(self.short_not_ok);
        }
        if (self.no_interrupt != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3EpDequeueFtraceEventWire.NO_INTERRUPT_WIRE) + gremlin.sizes.sizeI32(self.no_interrupt);
        }
        return res;
    }
    pub fn encode(self: *const Dwc3EpDequeueFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Dwc3EpDequeueFtraceEvent, target: *gremlin.Writer) void {
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(Dwc3EpDequeueFtraceEventWire.NAME_WIRE, v);
            }
        }
        if (self.req != 0) {
            target.appendUint64(Dwc3EpDequeueFtraceEventWire.REQ_WIRE, self.req);
        }
        if (self.actual != 0) {
            target.appendUint32(Dwc3EpDequeueFtraceEventWire.ACTUAL_WIRE, self.actual);
        }
        if (self.length != 0) {
            target.appendUint32(Dwc3EpDequeueFtraceEventWire.LENGTH_WIRE, self.length);
        }
        if (self.status != 0) {
            target.appendInt32(Dwc3EpDequeueFtraceEventWire.STATUS_WIRE, self.status);
        }
        if (self.zero != 0) {
            target.appendInt32(Dwc3EpDequeueFtraceEventWire.ZERO_WIRE, self.zero);
        }
        if (self.short_not_ok != 0) {
            target.appendInt32(Dwc3EpDequeueFtraceEventWire.SHORT_NOT_OK_WIRE, self.short_not_ok);
        }
        if (self.no_interrupt != 0) {
            target.appendInt32(Dwc3EpDequeueFtraceEventWire.NO_INTERRUPT_WIRE, self.no_interrupt);
        }
    }
};
pub const Dwc3EpDequeueFtraceEventReader = struct {
    buf: gremlin.Reader,
    _name: ?[]const u8 = null,
    _req: u64 = 0,
    _actual: u32 = 0,
    _length: u32 = 0,
    _status: i32 = 0,
    _zero: i32 = 0,
    _short_not_ok: i32 = 0,
    _no_interrupt: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Dwc3EpDequeueFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Dwc3EpDequeueFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Dwc3EpDequeueFtraceEventWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                Dwc3EpDequeueFtraceEventWire.REQ_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._req = result.value;
                },
                Dwc3EpDequeueFtraceEventWire.ACTUAL_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._actual = result.value;
                },
                Dwc3EpDequeueFtraceEventWire.LENGTH_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._length = result.value;
                },
                Dwc3EpDequeueFtraceEventWire.STATUS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._status = result.value;
                },
                Dwc3EpDequeueFtraceEventWire.ZERO_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._zero = result.value;
                },
                Dwc3EpDequeueFtraceEventWire.SHORT_NOT_OK_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._short_not_ok = result.value;
                },
                Dwc3EpDequeueFtraceEventWire.NO_INTERRUPT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._no_interrupt = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getName(self: *const Dwc3EpDequeueFtraceEventReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub inline fn getReq(self: *const Dwc3EpDequeueFtraceEventReader) u64 {
        return self._req;
    }
    pub inline fn getActual(self: *const Dwc3EpDequeueFtraceEventReader) u32 {
        return self._actual;
    }
    pub inline fn getLength(self: *const Dwc3EpDequeueFtraceEventReader) u32 {
        return self._length;
    }
    pub inline fn getStatus(self: *const Dwc3EpDequeueFtraceEventReader) i32 {
        return self._status;
    }
    pub inline fn getZero(self: *const Dwc3EpDequeueFtraceEventReader) i32 {
        return self._zero;
    }
    pub inline fn getShortNotOk(self: *const Dwc3EpDequeueFtraceEventReader) i32 {
        return self._short_not_ok;
    }
    pub inline fn getNoInterrupt(self: *const Dwc3EpDequeueFtraceEventReader) i32 {
        return self._no_interrupt;
    }
};
const Dwc3EpQueueFtraceEventWire = struct {
    const NAME_WIRE: gremlin.ProtoWireNumber = 1;
    const REQ_WIRE: gremlin.ProtoWireNumber = 2;
    const ACTUAL_WIRE: gremlin.ProtoWireNumber = 3;
    const LENGTH_WIRE: gremlin.ProtoWireNumber = 4;
    const STATUS_WIRE: gremlin.ProtoWireNumber = 5;
    const ZERO_WIRE: gremlin.ProtoWireNumber = 6;
    const SHORT_NOT_OK_WIRE: gremlin.ProtoWireNumber = 7;
    const NO_INTERRUPT_WIRE: gremlin.ProtoWireNumber = 8;
};
pub const Dwc3EpQueueFtraceEvent = struct {
    // fields
    name: ?[]const u8 = null,
    req: u64 = 0,
    actual: u32 = 0,
    length: u32 = 0,
    status: i32 = 0,
    zero: i32 = 0,
    short_not_ok: i32 = 0,
    no_interrupt: i32 = 0,
    pub fn calcProtobufSize(self: *const Dwc3EpQueueFtraceEvent) usize {
        var res: usize = 0;
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(Dwc3EpQueueFtraceEventWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.req != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3EpQueueFtraceEventWire.REQ_WIRE) + gremlin.sizes.sizeU64(self.req);
        }
        if (self.actual != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3EpQueueFtraceEventWire.ACTUAL_WIRE) + gremlin.sizes.sizeU32(self.actual);
        }
        if (self.length != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3EpQueueFtraceEventWire.LENGTH_WIRE) + gremlin.sizes.sizeU32(self.length);
        }
        if (self.status != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3EpQueueFtraceEventWire.STATUS_WIRE) + gremlin.sizes.sizeI32(self.status);
        }
        if (self.zero != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3EpQueueFtraceEventWire.ZERO_WIRE) + gremlin.sizes.sizeI32(self.zero);
        }
        if (self.short_not_ok != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3EpQueueFtraceEventWire.SHORT_NOT_OK_WIRE) + gremlin.sizes.sizeI32(self.short_not_ok);
        }
        if (self.no_interrupt != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3EpQueueFtraceEventWire.NO_INTERRUPT_WIRE) + gremlin.sizes.sizeI32(self.no_interrupt);
        }
        return res;
    }
    pub fn encode(self: *const Dwc3EpQueueFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Dwc3EpQueueFtraceEvent, target: *gremlin.Writer) void {
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(Dwc3EpQueueFtraceEventWire.NAME_WIRE, v);
            }
        }
        if (self.req != 0) {
            target.appendUint64(Dwc3EpQueueFtraceEventWire.REQ_WIRE, self.req);
        }
        if (self.actual != 0) {
            target.appendUint32(Dwc3EpQueueFtraceEventWire.ACTUAL_WIRE, self.actual);
        }
        if (self.length != 0) {
            target.appendUint32(Dwc3EpQueueFtraceEventWire.LENGTH_WIRE, self.length);
        }
        if (self.status != 0) {
            target.appendInt32(Dwc3EpQueueFtraceEventWire.STATUS_WIRE, self.status);
        }
        if (self.zero != 0) {
            target.appendInt32(Dwc3EpQueueFtraceEventWire.ZERO_WIRE, self.zero);
        }
        if (self.short_not_ok != 0) {
            target.appendInt32(Dwc3EpQueueFtraceEventWire.SHORT_NOT_OK_WIRE, self.short_not_ok);
        }
        if (self.no_interrupt != 0) {
            target.appendInt32(Dwc3EpQueueFtraceEventWire.NO_INTERRUPT_WIRE, self.no_interrupt);
        }
    }
};
pub const Dwc3EpQueueFtraceEventReader = struct {
    buf: gremlin.Reader,
    _name: ?[]const u8 = null,
    _req: u64 = 0,
    _actual: u32 = 0,
    _length: u32 = 0,
    _status: i32 = 0,
    _zero: i32 = 0,
    _short_not_ok: i32 = 0,
    _no_interrupt: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Dwc3EpQueueFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Dwc3EpQueueFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Dwc3EpQueueFtraceEventWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                Dwc3EpQueueFtraceEventWire.REQ_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._req = result.value;
                },
                Dwc3EpQueueFtraceEventWire.ACTUAL_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._actual = result.value;
                },
                Dwc3EpQueueFtraceEventWire.LENGTH_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._length = result.value;
                },
                Dwc3EpQueueFtraceEventWire.STATUS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._status = result.value;
                },
                Dwc3EpQueueFtraceEventWire.ZERO_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._zero = result.value;
                },
                Dwc3EpQueueFtraceEventWire.SHORT_NOT_OK_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._short_not_ok = result.value;
                },
                Dwc3EpQueueFtraceEventWire.NO_INTERRUPT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._no_interrupt = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getName(self: *const Dwc3EpQueueFtraceEventReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub inline fn getReq(self: *const Dwc3EpQueueFtraceEventReader) u64 {
        return self._req;
    }
    pub inline fn getActual(self: *const Dwc3EpQueueFtraceEventReader) u32 {
        return self._actual;
    }
    pub inline fn getLength(self: *const Dwc3EpQueueFtraceEventReader) u32 {
        return self._length;
    }
    pub inline fn getStatus(self: *const Dwc3EpQueueFtraceEventReader) i32 {
        return self._status;
    }
    pub inline fn getZero(self: *const Dwc3EpQueueFtraceEventReader) i32 {
        return self._zero;
    }
    pub inline fn getShortNotOk(self: *const Dwc3EpQueueFtraceEventReader) i32 {
        return self._short_not_ok;
    }
    pub inline fn getNoInterrupt(self: *const Dwc3EpQueueFtraceEventReader) i32 {
        return self._no_interrupt;
    }
};
const Dwc3EventFtraceEventWire = struct {
    const EVENT_WIRE: gremlin.ProtoWireNumber = 1;
    const EP0STATE_WIRE: gremlin.ProtoWireNumber = 2;
    const STR_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const Dwc3EventFtraceEvent = struct {
    // fields
    event: u32 = 0,
    ep0state: u32 = 0,
    str: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const Dwc3EventFtraceEvent) usize {
        var res: usize = 0;
        if (self.event != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3EventFtraceEventWire.EVENT_WIRE) + gremlin.sizes.sizeU32(self.event);
        }
        if (self.ep0state != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3EventFtraceEventWire.EP0STATE_WIRE) + gremlin.sizes.sizeU32(self.ep0state);
        }
        if (self.str) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(Dwc3EventFtraceEventWire.STR_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const Dwc3EventFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Dwc3EventFtraceEvent, target: *gremlin.Writer) void {
        if (self.event != 0) {
            target.appendUint32(Dwc3EventFtraceEventWire.EVENT_WIRE, self.event);
        }
        if (self.ep0state != 0) {
            target.appendUint32(Dwc3EventFtraceEventWire.EP0STATE_WIRE, self.ep0state);
        }
        if (self.str) |v| {
            if (v.len > 0) {
                target.appendBytes(Dwc3EventFtraceEventWire.STR_WIRE, v);
            }
        }
    }
};
pub const Dwc3EventFtraceEventReader = struct {
    buf: gremlin.Reader,
    _event: u32 = 0,
    _ep0state: u32 = 0,
    _str: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!Dwc3EventFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Dwc3EventFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Dwc3EventFtraceEventWire.EVENT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._event = result.value;
                },
                Dwc3EventFtraceEventWire.EP0STATE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._ep0state = result.value;
                },
                Dwc3EventFtraceEventWire.STR_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._str = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getEvent(self: *const Dwc3EventFtraceEventReader) u32 {
        return self._event;
    }
    pub inline fn getEp0state(self: *const Dwc3EventFtraceEventReader) u32 {
        return self._ep0state;
    }
    pub inline fn getStr(self: *const Dwc3EventFtraceEventReader) []const u8 {
        return self._str orelse &[_]u8{};
    }
};
const Dwc3FreeRequestFtraceEventWire = struct {
    const NAME_WIRE: gremlin.ProtoWireNumber = 1;
    const REQ_WIRE: gremlin.ProtoWireNumber = 2;
    const ACTUAL_WIRE: gremlin.ProtoWireNumber = 3;
    const LENGTH_WIRE: gremlin.ProtoWireNumber = 4;
    const STATUS_WIRE: gremlin.ProtoWireNumber = 5;
    const ZERO_WIRE: gremlin.ProtoWireNumber = 6;
    const SHORT_NOT_OK_WIRE: gremlin.ProtoWireNumber = 7;
    const NO_INTERRUPT_WIRE: gremlin.ProtoWireNumber = 8;
};
pub const Dwc3FreeRequestFtraceEvent = struct {
    // fields
    name: ?[]const u8 = null,
    req: u64 = 0,
    actual: u32 = 0,
    length: u32 = 0,
    status: i32 = 0,
    zero: i32 = 0,
    short_not_ok: i32 = 0,
    no_interrupt: i32 = 0,
    pub fn calcProtobufSize(self: *const Dwc3FreeRequestFtraceEvent) usize {
        var res: usize = 0;
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(Dwc3FreeRequestFtraceEventWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.req != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3FreeRequestFtraceEventWire.REQ_WIRE) + gremlin.sizes.sizeU64(self.req);
        }
        if (self.actual != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3FreeRequestFtraceEventWire.ACTUAL_WIRE) + gremlin.sizes.sizeU32(self.actual);
        }
        if (self.length != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3FreeRequestFtraceEventWire.LENGTH_WIRE) + gremlin.sizes.sizeU32(self.length);
        }
        if (self.status != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3FreeRequestFtraceEventWire.STATUS_WIRE) + gremlin.sizes.sizeI32(self.status);
        }
        if (self.zero != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3FreeRequestFtraceEventWire.ZERO_WIRE) + gremlin.sizes.sizeI32(self.zero);
        }
        if (self.short_not_ok != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3FreeRequestFtraceEventWire.SHORT_NOT_OK_WIRE) + gremlin.sizes.sizeI32(self.short_not_ok);
        }
        if (self.no_interrupt != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3FreeRequestFtraceEventWire.NO_INTERRUPT_WIRE) + gremlin.sizes.sizeI32(self.no_interrupt);
        }
        return res;
    }
    pub fn encode(self: *const Dwc3FreeRequestFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Dwc3FreeRequestFtraceEvent, target: *gremlin.Writer) void {
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(Dwc3FreeRequestFtraceEventWire.NAME_WIRE, v);
            }
        }
        if (self.req != 0) {
            target.appendUint64(Dwc3FreeRequestFtraceEventWire.REQ_WIRE, self.req);
        }
        if (self.actual != 0) {
            target.appendUint32(Dwc3FreeRequestFtraceEventWire.ACTUAL_WIRE, self.actual);
        }
        if (self.length != 0) {
            target.appendUint32(Dwc3FreeRequestFtraceEventWire.LENGTH_WIRE, self.length);
        }
        if (self.status != 0) {
            target.appendInt32(Dwc3FreeRequestFtraceEventWire.STATUS_WIRE, self.status);
        }
        if (self.zero != 0) {
            target.appendInt32(Dwc3FreeRequestFtraceEventWire.ZERO_WIRE, self.zero);
        }
        if (self.short_not_ok != 0) {
            target.appendInt32(Dwc3FreeRequestFtraceEventWire.SHORT_NOT_OK_WIRE, self.short_not_ok);
        }
        if (self.no_interrupt != 0) {
            target.appendInt32(Dwc3FreeRequestFtraceEventWire.NO_INTERRUPT_WIRE, self.no_interrupt);
        }
    }
};
pub const Dwc3FreeRequestFtraceEventReader = struct {
    buf: gremlin.Reader,
    _name: ?[]const u8 = null,
    _req: u64 = 0,
    _actual: u32 = 0,
    _length: u32 = 0,
    _status: i32 = 0,
    _zero: i32 = 0,
    _short_not_ok: i32 = 0,
    _no_interrupt: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Dwc3FreeRequestFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Dwc3FreeRequestFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Dwc3FreeRequestFtraceEventWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                Dwc3FreeRequestFtraceEventWire.REQ_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._req = result.value;
                },
                Dwc3FreeRequestFtraceEventWire.ACTUAL_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._actual = result.value;
                },
                Dwc3FreeRequestFtraceEventWire.LENGTH_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._length = result.value;
                },
                Dwc3FreeRequestFtraceEventWire.STATUS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._status = result.value;
                },
                Dwc3FreeRequestFtraceEventWire.ZERO_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._zero = result.value;
                },
                Dwc3FreeRequestFtraceEventWire.SHORT_NOT_OK_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._short_not_ok = result.value;
                },
                Dwc3FreeRequestFtraceEventWire.NO_INTERRUPT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._no_interrupt = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getName(self: *const Dwc3FreeRequestFtraceEventReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub inline fn getReq(self: *const Dwc3FreeRequestFtraceEventReader) u64 {
        return self._req;
    }
    pub inline fn getActual(self: *const Dwc3FreeRequestFtraceEventReader) u32 {
        return self._actual;
    }
    pub inline fn getLength(self: *const Dwc3FreeRequestFtraceEventReader) u32 {
        return self._length;
    }
    pub inline fn getStatus(self: *const Dwc3FreeRequestFtraceEventReader) i32 {
        return self._status;
    }
    pub inline fn getZero(self: *const Dwc3FreeRequestFtraceEventReader) i32 {
        return self._zero;
    }
    pub inline fn getShortNotOk(self: *const Dwc3FreeRequestFtraceEventReader) i32 {
        return self._short_not_ok;
    }
    pub inline fn getNoInterrupt(self: *const Dwc3FreeRequestFtraceEventReader) i32 {
        return self._no_interrupt;
    }
};
const Dwc3GadgetEpCmdFtraceEventWire = struct {
    const NAME_WIRE: gremlin.ProtoWireNumber = 1;
    const CMD_WIRE: gremlin.ProtoWireNumber = 2;
    const PARAM0_WIRE: gremlin.ProtoWireNumber = 3;
    const PARAM1_WIRE: gremlin.ProtoWireNumber = 4;
    const PARAM2_WIRE: gremlin.ProtoWireNumber = 5;
    const CMD_STATUS_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const Dwc3GadgetEpCmdFtraceEvent = struct {
    // fields
    name: ?[]const u8 = null,
    cmd: u32 = 0,
    param0: u32 = 0,
    param1: u32 = 0,
    param2: u32 = 0,
    cmd_status: i32 = 0,
    pub fn calcProtobufSize(self: *const Dwc3GadgetEpCmdFtraceEvent) usize {
        var res: usize = 0;
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(Dwc3GadgetEpCmdFtraceEventWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.cmd != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3GadgetEpCmdFtraceEventWire.CMD_WIRE) + gremlin.sizes.sizeU32(self.cmd);
        }
        if (self.param0 != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3GadgetEpCmdFtraceEventWire.PARAM0_WIRE) + gremlin.sizes.sizeU32(self.param0);
        }
        if (self.param1 != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3GadgetEpCmdFtraceEventWire.PARAM1_WIRE) + gremlin.sizes.sizeU32(self.param1);
        }
        if (self.param2 != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3GadgetEpCmdFtraceEventWire.PARAM2_WIRE) + gremlin.sizes.sizeU32(self.param2);
        }
        if (self.cmd_status != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3GadgetEpCmdFtraceEventWire.CMD_STATUS_WIRE) + gremlin.sizes.sizeI32(self.cmd_status);
        }
        return res;
    }
    pub fn encode(self: *const Dwc3GadgetEpCmdFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Dwc3GadgetEpCmdFtraceEvent, target: *gremlin.Writer) void {
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(Dwc3GadgetEpCmdFtraceEventWire.NAME_WIRE, v);
            }
        }
        if (self.cmd != 0) {
            target.appendUint32(Dwc3GadgetEpCmdFtraceEventWire.CMD_WIRE, self.cmd);
        }
        if (self.param0 != 0) {
            target.appendUint32(Dwc3GadgetEpCmdFtraceEventWire.PARAM0_WIRE, self.param0);
        }
        if (self.param1 != 0) {
            target.appendUint32(Dwc3GadgetEpCmdFtraceEventWire.PARAM1_WIRE, self.param1);
        }
        if (self.param2 != 0) {
            target.appendUint32(Dwc3GadgetEpCmdFtraceEventWire.PARAM2_WIRE, self.param2);
        }
        if (self.cmd_status != 0) {
            target.appendInt32(Dwc3GadgetEpCmdFtraceEventWire.CMD_STATUS_WIRE, self.cmd_status);
        }
    }
};
pub const Dwc3GadgetEpCmdFtraceEventReader = struct {
    buf: gremlin.Reader,
    _name: ?[]const u8 = null,
    _cmd: u32 = 0,
    _param0: u32 = 0,
    _param1: u32 = 0,
    _param2: u32 = 0,
    _cmd_status: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Dwc3GadgetEpCmdFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Dwc3GadgetEpCmdFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Dwc3GadgetEpCmdFtraceEventWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                Dwc3GadgetEpCmdFtraceEventWire.CMD_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._cmd = result.value;
                },
                Dwc3GadgetEpCmdFtraceEventWire.PARAM0_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._param0 = result.value;
                },
                Dwc3GadgetEpCmdFtraceEventWire.PARAM1_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._param1 = result.value;
                },
                Dwc3GadgetEpCmdFtraceEventWire.PARAM2_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._param2 = result.value;
                },
                Dwc3GadgetEpCmdFtraceEventWire.CMD_STATUS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._cmd_status = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getName(self: *const Dwc3GadgetEpCmdFtraceEventReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub inline fn getCmd(self: *const Dwc3GadgetEpCmdFtraceEventReader) u32 {
        return self._cmd;
    }
    pub inline fn getParam0(self: *const Dwc3GadgetEpCmdFtraceEventReader) u32 {
        return self._param0;
    }
    pub inline fn getParam1(self: *const Dwc3GadgetEpCmdFtraceEventReader) u32 {
        return self._param1;
    }
    pub inline fn getParam2(self: *const Dwc3GadgetEpCmdFtraceEventReader) u32 {
        return self._param2;
    }
    pub inline fn getCmdStatus(self: *const Dwc3GadgetEpCmdFtraceEventReader) i32 {
        return self._cmd_status;
    }
};
const Dwc3GadgetEpDisableFtraceEventWire = struct {
    const NAME_WIRE: gremlin.ProtoWireNumber = 1;
    const MAXPACKET_WIRE: gremlin.ProtoWireNumber = 2;
    const MAXPACKET_LIMIT_WIRE: gremlin.ProtoWireNumber = 3;
    const MAX_STREAMS_WIRE: gremlin.ProtoWireNumber = 4;
    const MAXBURST_WIRE: gremlin.ProtoWireNumber = 5;
    const FLAGS_WIRE: gremlin.ProtoWireNumber = 6;
    const DIRECTION_WIRE: gremlin.ProtoWireNumber = 7;
    const TRB_ENQUEUE_WIRE: gremlin.ProtoWireNumber = 8;
    const TRB_DEQUEUE_WIRE: gremlin.ProtoWireNumber = 9;
};
pub const Dwc3GadgetEpDisableFtraceEvent = struct {
    // fields
    name: ?[]const u8 = null,
    maxpacket: u32 = 0,
    maxpacket_limit: u32 = 0,
    max_streams: u32 = 0,
    maxburst: u32 = 0,
    flags: u32 = 0,
    direction: u32 = 0,
    trb_enqueue: u32 = 0,
    trb_dequeue: u32 = 0,
    pub fn calcProtobufSize(self: *const Dwc3GadgetEpDisableFtraceEvent) usize {
        var res: usize = 0;
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(Dwc3GadgetEpDisableFtraceEventWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.maxpacket != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3GadgetEpDisableFtraceEventWire.MAXPACKET_WIRE) + gremlin.sizes.sizeU32(self.maxpacket);
        }
        if (self.maxpacket_limit != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3GadgetEpDisableFtraceEventWire.MAXPACKET_LIMIT_WIRE) + gremlin.sizes.sizeU32(self.maxpacket_limit);
        }
        if (self.max_streams != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3GadgetEpDisableFtraceEventWire.MAX_STREAMS_WIRE) + gremlin.sizes.sizeU32(self.max_streams);
        }
        if (self.maxburst != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3GadgetEpDisableFtraceEventWire.MAXBURST_WIRE) + gremlin.sizes.sizeU32(self.maxburst);
        }
        if (self.flags != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3GadgetEpDisableFtraceEventWire.FLAGS_WIRE) + gremlin.sizes.sizeU32(self.flags);
        }
        if (self.direction != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3GadgetEpDisableFtraceEventWire.DIRECTION_WIRE) + gremlin.sizes.sizeU32(self.direction);
        }
        if (self.trb_enqueue != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3GadgetEpDisableFtraceEventWire.TRB_ENQUEUE_WIRE) + gremlin.sizes.sizeU32(self.trb_enqueue);
        }
        if (self.trb_dequeue != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3GadgetEpDisableFtraceEventWire.TRB_DEQUEUE_WIRE) + gremlin.sizes.sizeU32(self.trb_dequeue);
        }
        return res;
    }
    pub fn encode(self: *const Dwc3GadgetEpDisableFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Dwc3GadgetEpDisableFtraceEvent, target: *gremlin.Writer) void {
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(Dwc3GadgetEpDisableFtraceEventWire.NAME_WIRE, v);
            }
        }
        if (self.maxpacket != 0) {
            target.appendUint32(Dwc3GadgetEpDisableFtraceEventWire.MAXPACKET_WIRE, self.maxpacket);
        }
        if (self.maxpacket_limit != 0) {
            target.appendUint32(Dwc3GadgetEpDisableFtraceEventWire.MAXPACKET_LIMIT_WIRE, self.maxpacket_limit);
        }
        if (self.max_streams != 0) {
            target.appendUint32(Dwc3GadgetEpDisableFtraceEventWire.MAX_STREAMS_WIRE, self.max_streams);
        }
        if (self.maxburst != 0) {
            target.appendUint32(Dwc3GadgetEpDisableFtraceEventWire.MAXBURST_WIRE, self.maxburst);
        }
        if (self.flags != 0) {
            target.appendUint32(Dwc3GadgetEpDisableFtraceEventWire.FLAGS_WIRE, self.flags);
        }
        if (self.direction != 0) {
            target.appendUint32(Dwc3GadgetEpDisableFtraceEventWire.DIRECTION_WIRE, self.direction);
        }
        if (self.trb_enqueue != 0) {
            target.appendUint32(Dwc3GadgetEpDisableFtraceEventWire.TRB_ENQUEUE_WIRE, self.trb_enqueue);
        }
        if (self.trb_dequeue != 0) {
            target.appendUint32(Dwc3GadgetEpDisableFtraceEventWire.TRB_DEQUEUE_WIRE, self.trb_dequeue);
        }
    }
};
pub const Dwc3GadgetEpDisableFtraceEventReader = struct {
    buf: gremlin.Reader,
    _name: ?[]const u8 = null,
    _maxpacket: u32 = 0,
    _maxpacket_limit: u32 = 0,
    _max_streams: u32 = 0,
    _maxburst: u32 = 0,
    _flags: u32 = 0,
    _direction: u32 = 0,
    _trb_enqueue: u32 = 0,
    _trb_dequeue: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Dwc3GadgetEpDisableFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Dwc3GadgetEpDisableFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Dwc3GadgetEpDisableFtraceEventWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                Dwc3GadgetEpDisableFtraceEventWire.MAXPACKET_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._maxpacket = result.value;
                },
                Dwc3GadgetEpDisableFtraceEventWire.MAXPACKET_LIMIT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._maxpacket_limit = result.value;
                },
                Dwc3GadgetEpDisableFtraceEventWire.MAX_STREAMS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._max_streams = result.value;
                },
                Dwc3GadgetEpDisableFtraceEventWire.MAXBURST_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._maxburst = result.value;
                },
                Dwc3GadgetEpDisableFtraceEventWire.FLAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._flags = result.value;
                },
                Dwc3GadgetEpDisableFtraceEventWire.DIRECTION_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._direction = result.value;
                },
                Dwc3GadgetEpDisableFtraceEventWire.TRB_ENQUEUE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._trb_enqueue = result.value;
                },
                Dwc3GadgetEpDisableFtraceEventWire.TRB_DEQUEUE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._trb_dequeue = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getName(self: *const Dwc3GadgetEpDisableFtraceEventReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub inline fn getMaxpacket(self: *const Dwc3GadgetEpDisableFtraceEventReader) u32 {
        return self._maxpacket;
    }
    pub inline fn getMaxpacketLimit(self: *const Dwc3GadgetEpDisableFtraceEventReader) u32 {
        return self._maxpacket_limit;
    }
    pub inline fn getMaxStreams(self: *const Dwc3GadgetEpDisableFtraceEventReader) u32 {
        return self._max_streams;
    }
    pub inline fn getMaxburst(self: *const Dwc3GadgetEpDisableFtraceEventReader) u32 {
        return self._maxburst;
    }
    pub inline fn getFlags(self: *const Dwc3GadgetEpDisableFtraceEventReader) u32 {
        return self._flags;
    }
    pub inline fn getDirection(self: *const Dwc3GadgetEpDisableFtraceEventReader) u32 {
        return self._direction;
    }
    pub inline fn getTrbEnqueue(self: *const Dwc3GadgetEpDisableFtraceEventReader) u32 {
        return self._trb_enqueue;
    }
    pub inline fn getTrbDequeue(self: *const Dwc3GadgetEpDisableFtraceEventReader) u32 {
        return self._trb_dequeue;
    }
};
const Dwc3GadgetEpEnableFtraceEventWire = struct {
    const NAME_WIRE: gremlin.ProtoWireNumber = 1;
    const MAXPACKET_WIRE: gremlin.ProtoWireNumber = 2;
    const MAXPACKET_LIMIT_WIRE: gremlin.ProtoWireNumber = 3;
    const MAX_STREAMS_WIRE: gremlin.ProtoWireNumber = 4;
    const MAXBURST_WIRE: gremlin.ProtoWireNumber = 5;
    const FLAGS_WIRE: gremlin.ProtoWireNumber = 6;
    const DIRECTION_WIRE: gremlin.ProtoWireNumber = 7;
    const TRB_ENQUEUE_WIRE: gremlin.ProtoWireNumber = 8;
    const TRB_DEQUEUE_WIRE: gremlin.ProtoWireNumber = 9;
};
pub const Dwc3GadgetEpEnableFtraceEvent = struct {
    // fields
    name: ?[]const u8 = null,
    maxpacket: u32 = 0,
    maxpacket_limit: u32 = 0,
    max_streams: u32 = 0,
    maxburst: u32 = 0,
    flags: u32 = 0,
    direction: u32 = 0,
    trb_enqueue: u32 = 0,
    trb_dequeue: u32 = 0,
    pub fn calcProtobufSize(self: *const Dwc3GadgetEpEnableFtraceEvent) usize {
        var res: usize = 0;
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(Dwc3GadgetEpEnableFtraceEventWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.maxpacket != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3GadgetEpEnableFtraceEventWire.MAXPACKET_WIRE) + gremlin.sizes.sizeU32(self.maxpacket);
        }
        if (self.maxpacket_limit != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3GadgetEpEnableFtraceEventWire.MAXPACKET_LIMIT_WIRE) + gremlin.sizes.sizeU32(self.maxpacket_limit);
        }
        if (self.max_streams != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3GadgetEpEnableFtraceEventWire.MAX_STREAMS_WIRE) + gremlin.sizes.sizeU32(self.max_streams);
        }
        if (self.maxburst != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3GadgetEpEnableFtraceEventWire.MAXBURST_WIRE) + gremlin.sizes.sizeU32(self.maxburst);
        }
        if (self.flags != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3GadgetEpEnableFtraceEventWire.FLAGS_WIRE) + gremlin.sizes.sizeU32(self.flags);
        }
        if (self.direction != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3GadgetEpEnableFtraceEventWire.DIRECTION_WIRE) + gremlin.sizes.sizeU32(self.direction);
        }
        if (self.trb_enqueue != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3GadgetEpEnableFtraceEventWire.TRB_ENQUEUE_WIRE) + gremlin.sizes.sizeU32(self.trb_enqueue);
        }
        if (self.trb_dequeue != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3GadgetEpEnableFtraceEventWire.TRB_DEQUEUE_WIRE) + gremlin.sizes.sizeU32(self.trb_dequeue);
        }
        return res;
    }
    pub fn encode(self: *const Dwc3GadgetEpEnableFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Dwc3GadgetEpEnableFtraceEvent, target: *gremlin.Writer) void {
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(Dwc3GadgetEpEnableFtraceEventWire.NAME_WIRE, v);
            }
        }
        if (self.maxpacket != 0) {
            target.appendUint32(Dwc3GadgetEpEnableFtraceEventWire.MAXPACKET_WIRE, self.maxpacket);
        }
        if (self.maxpacket_limit != 0) {
            target.appendUint32(Dwc3GadgetEpEnableFtraceEventWire.MAXPACKET_LIMIT_WIRE, self.maxpacket_limit);
        }
        if (self.max_streams != 0) {
            target.appendUint32(Dwc3GadgetEpEnableFtraceEventWire.MAX_STREAMS_WIRE, self.max_streams);
        }
        if (self.maxburst != 0) {
            target.appendUint32(Dwc3GadgetEpEnableFtraceEventWire.MAXBURST_WIRE, self.maxburst);
        }
        if (self.flags != 0) {
            target.appendUint32(Dwc3GadgetEpEnableFtraceEventWire.FLAGS_WIRE, self.flags);
        }
        if (self.direction != 0) {
            target.appendUint32(Dwc3GadgetEpEnableFtraceEventWire.DIRECTION_WIRE, self.direction);
        }
        if (self.trb_enqueue != 0) {
            target.appendUint32(Dwc3GadgetEpEnableFtraceEventWire.TRB_ENQUEUE_WIRE, self.trb_enqueue);
        }
        if (self.trb_dequeue != 0) {
            target.appendUint32(Dwc3GadgetEpEnableFtraceEventWire.TRB_DEQUEUE_WIRE, self.trb_dequeue);
        }
    }
};
pub const Dwc3GadgetEpEnableFtraceEventReader = struct {
    buf: gremlin.Reader,
    _name: ?[]const u8 = null,
    _maxpacket: u32 = 0,
    _maxpacket_limit: u32 = 0,
    _max_streams: u32 = 0,
    _maxburst: u32 = 0,
    _flags: u32 = 0,
    _direction: u32 = 0,
    _trb_enqueue: u32 = 0,
    _trb_dequeue: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Dwc3GadgetEpEnableFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Dwc3GadgetEpEnableFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Dwc3GadgetEpEnableFtraceEventWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                Dwc3GadgetEpEnableFtraceEventWire.MAXPACKET_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._maxpacket = result.value;
                },
                Dwc3GadgetEpEnableFtraceEventWire.MAXPACKET_LIMIT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._maxpacket_limit = result.value;
                },
                Dwc3GadgetEpEnableFtraceEventWire.MAX_STREAMS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._max_streams = result.value;
                },
                Dwc3GadgetEpEnableFtraceEventWire.MAXBURST_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._maxburst = result.value;
                },
                Dwc3GadgetEpEnableFtraceEventWire.FLAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._flags = result.value;
                },
                Dwc3GadgetEpEnableFtraceEventWire.DIRECTION_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._direction = result.value;
                },
                Dwc3GadgetEpEnableFtraceEventWire.TRB_ENQUEUE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._trb_enqueue = result.value;
                },
                Dwc3GadgetEpEnableFtraceEventWire.TRB_DEQUEUE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._trb_dequeue = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getName(self: *const Dwc3GadgetEpEnableFtraceEventReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub inline fn getMaxpacket(self: *const Dwc3GadgetEpEnableFtraceEventReader) u32 {
        return self._maxpacket;
    }
    pub inline fn getMaxpacketLimit(self: *const Dwc3GadgetEpEnableFtraceEventReader) u32 {
        return self._maxpacket_limit;
    }
    pub inline fn getMaxStreams(self: *const Dwc3GadgetEpEnableFtraceEventReader) u32 {
        return self._max_streams;
    }
    pub inline fn getMaxburst(self: *const Dwc3GadgetEpEnableFtraceEventReader) u32 {
        return self._maxburst;
    }
    pub inline fn getFlags(self: *const Dwc3GadgetEpEnableFtraceEventReader) u32 {
        return self._flags;
    }
    pub inline fn getDirection(self: *const Dwc3GadgetEpEnableFtraceEventReader) u32 {
        return self._direction;
    }
    pub inline fn getTrbEnqueue(self: *const Dwc3GadgetEpEnableFtraceEventReader) u32 {
        return self._trb_enqueue;
    }
    pub inline fn getTrbDequeue(self: *const Dwc3GadgetEpEnableFtraceEventReader) u32 {
        return self._trb_dequeue;
    }
};
const Dwc3GadgetGenericCmdFtraceEventWire = struct {
    const CMD_WIRE: gremlin.ProtoWireNumber = 1;
    const PARAM_WIRE: gremlin.ProtoWireNumber = 2;
    const STATUS_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const Dwc3GadgetGenericCmdFtraceEvent = struct {
    // fields
    cmd: u32 = 0,
    param: u32 = 0,
    status: i32 = 0,
    pub fn calcProtobufSize(self: *const Dwc3GadgetGenericCmdFtraceEvent) usize {
        var res: usize = 0;
        if (self.cmd != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3GadgetGenericCmdFtraceEventWire.CMD_WIRE) + gremlin.sizes.sizeU32(self.cmd);
        }
        if (self.param != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3GadgetGenericCmdFtraceEventWire.PARAM_WIRE) + gremlin.sizes.sizeU32(self.param);
        }
        if (self.status != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3GadgetGenericCmdFtraceEventWire.STATUS_WIRE) + gremlin.sizes.sizeI32(self.status);
        }
        return res;
    }
    pub fn encode(self: *const Dwc3GadgetGenericCmdFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Dwc3GadgetGenericCmdFtraceEvent, target: *gremlin.Writer) void {
        if (self.cmd != 0) {
            target.appendUint32(Dwc3GadgetGenericCmdFtraceEventWire.CMD_WIRE, self.cmd);
        }
        if (self.param != 0) {
            target.appendUint32(Dwc3GadgetGenericCmdFtraceEventWire.PARAM_WIRE, self.param);
        }
        if (self.status != 0) {
            target.appendInt32(Dwc3GadgetGenericCmdFtraceEventWire.STATUS_WIRE, self.status);
        }
    }
};
pub const Dwc3GadgetGenericCmdFtraceEventReader = struct {
    buf: gremlin.Reader,
    _cmd: u32 = 0,
    _param: u32 = 0,
    _status: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Dwc3GadgetGenericCmdFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Dwc3GadgetGenericCmdFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Dwc3GadgetGenericCmdFtraceEventWire.CMD_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._cmd = result.value;
                },
                Dwc3GadgetGenericCmdFtraceEventWire.PARAM_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._param = result.value;
                },
                Dwc3GadgetGenericCmdFtraceEventWire.STATUS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._status = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getCmd(self: *const Dwc3GadgetGenericCmdFtraceEventReader) u32 {
        return self._cmd;
    }
    pub inline fn getParam(self: *const Dwc3GadgetGenericCmdFtraceEventReader) u32 {
        return self._param;
    }
    pub inline fn getStatus(self: *const Dwc3GadgetGenericCmdFtraceEventReader) i32 {
        return self._status;
    }
};
const Dwc3GadgetGivebackFtraceEventWire = struct {
    const NAME_WIRE: gremlin.ProtoWireNumber = 1;
    const REQ_WIRE: gremlin.ProtoWireNumber = 2;
    const ACTUAL_WIRE: gremlin.ProtoWireNumber = 3;
    const LENGTH_WIRE: gremlin.ProtoWireNumber = 4;
    const STATUS_WIRE: gremlin.ProtoWireNumber = 5;
    const ZERO_WIRE: gremlin.ProtoWireNumber = 6;
    const SHORT_NOT_OK_WIRE: gremlin.ProtoWireNumber = 7;
    const NO_INTERRUPT_WIRE: gremlin.ProtoWireNumber = 8;
};
pub const Dwc3GadgetGivebackFtraceEvent = struct {
    // fields
    name: ?[]const u8 = null,
    req: u64 = 0,
    actual: u32 = 0,
    length: u32 = 0,
    status: i32 = 0,
    zero: i32 = 0,
    short_not_ok: i32 = 0,
    no_interrupt: i32 = 0,
    pub fn calcProtobufSize(self: *const Dwc3GadgetGivebackFtraceEvent) usize {
        var res: usize = 0;
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(Dwc3GadgetGivebackFtraceEventWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.req != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3GadgetGivebackFtraceEventWire.REQ_WIRE) + gremlin.sizes.sizeU64(self.req);
        }
        if (self.actual != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3GadgetGivebackFtraceEventWire.ACTUAL_WIRE) + gremlin.sizes.sizeU32(self.actual);
        }
        if (self.length != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3GadgetGivebackFtraceEventWire.LENGTH_WIRE) + gremlin.sizes.sizeU32(self.length);
        }
        if (self.status != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3GadgetGivebackFtraceEventWire.STATUS_WIRE) + gremlin.sizes.sizeI32(self.status);
        }
        if (self.zero != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3GadgetGivebackFtraceEventWire.ZERO_WIRE) + gremlin.sizes.sizeI32(self.zero);
        }
        if (self.short_not_ok != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3GadgetGivebackFtraceEventWire.SHORT_NOT_OK_WIRE) + gremlin.sizes.sizeI32(self.short_not_ok);
        }
        if (self.no_interrupt != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3GadgetGivebackFtraceEventWire.NO_INTERRUPT_WIRE) + gremlin.sizes.sizeI32(self.no_interrupt);
        }
        return res;
    }
    pub fn encode(self: *const Dwc3GadgetGivebackFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Dwc3GadgetGivebackFtraceEvent, target: *gremlin.Writer) void {
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(Dwc3GadgetGivebackFtraceEventWire.NAME_WIRE, v);
            }
        }
        if (self.req != 0) {
            target.appendUint64(Dwc3GadgetGivebackFtraceEventWire.REQ_WIRE, self.req);
        }
        if (self.actual != 0) {
            target.appendUint32(Dwc3GadgetGivebackFtraceEventWire.ACTUAL_WIRE, self.actual);
        }
        if (self.length != 0) {
            target.appendUint32(Dwc3GadgetGivebackFtraceEventWire.LENGTH_WIRE, self.length);
        }
        if (self.status != 0) {
            target.appendInt32(Dwc3GadgetGivebackFtraceEventWire.STATUS_WIRE, self.status);
        }
        if (self.zero != 0) {
            target.appendInt32(Dwc3GadgetGivebackFtraceEventWire.ZERO_WIRE, self.zero);
        }
        if (self.short_not_ok != 0) {
            target.appendInt32(Dwc3GadgetGivebackFtraceEventWire.SHORT_NOT_OK_WIRE, self.short_not_ok);
        }
        if (self.no_interrupt != 0) {
            target.appendInt32(Dwc3GadgetGivebackFtraceEventWire.NO_INTERRUPT_WIRE, self.no_interrupt);
        }
    }
};
pub const Dwc3GadgetGivebackFtraceEventReader = struct {
    buf: gremlin.Reader,
    _name: ?[]const u8 = null,
    _req: u64 = 0,
    _actual: u32 = 0,
    _length: u32 = 0,
    _status: i32 = 0,
    _zero: i32 = 0,
    _short_not_ok: i32 = 0,
    _no_interrupt: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Dwc3GadgetGivebackFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Dwc3GadgetGivebackFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Dwc3GadgetGivebackFtraceEventWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                Dwc3GadgetGivebackFtraceEventWire.REQ_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._req = result.value;
                },
                Dwc3GadgetGivebackFtraceEventWire.ACTUAL_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._actual = result.value;
                },
                Dwc3GadgetGivebackFtraceEventWire.LENGTH_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._length = result.value;
                },
                Dwc3GadgetGivebackFtraceEventWire.STATUS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._status = result.value;
                },
                Dwc3GadgetGivebackFtraceEventWire.ZERO_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._zero = result.value;
                },
                Dwc3GadgetGivebackFtraceEventWire.SHORT_NOT_OK_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._short_not_ok = result.value;
                },
                Dwc3GadgetGivebackFtraceEventWire.NO_INTERRUPT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._no_interrupt = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getName(self: *const Dwc3GadgetGivebackFtraceEventReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub inline fn getReq(self: *const Dwc3GadgetGivebackFtraceEventReader) u64 {
        return self._req;
    }
    pub inline fn getActual(self: *const Dwc3GadgetGivebackFtraceEventReader) u32 {
        return self._actual;
    }
    pub inline fn getLength(self: *const Dwc3GadgetGivebackFtraceEventReader) u32 {
        return self._length;
    }
    pub inline fn getStatus(self: *const Dwc3GadgetGivebackFtraceEventReader) i32 {
        return self._status;
    }
    pub inline fn getZero(self: *const Dwc3GadgetGivebackFtraceEventReader) i32 {
        return self._zero;
    }
    pub inline fn getShortNotOk(self: *const Dwc3GadgetGivebackFtraceEventReader) i32 {
        return self._short_not_ok;
    }
    pub inline fn getNoInterrupt(self: *const Dwc3GadgetGivebackFtraceEventReader) i32 {
        return self._no_interrupt;
    }
};
const Dwc3PrepareTrbFtraceEventWire = struct {
    const NAME_WIRE: gremlin.ProtoWireNumber = 1;
    const TRB_WIRE: gremlin.ProtoWireNumber = 2;
    const ALLOCATED_WIRE: gremlin.ProtoWireNumber = 3;
    const QUEUED_WIRE: gremlin.ProtoWireNumber = 4;
    const BPL_WIRE: gremlin.ProtoWireNumber = 5;
    const BPH_WIRE: gremlin.ProtoWireNumber = 6;
    const SIZE_WIRE: gremlin.ProtoWireNumber = 7;
    const CTRL_WIRE: gremlin.ProtoWireNumber = 8;
    const TYPE_WIRE: gremlin.ProtoWireNumber = 9;
    const ENQUEUE_WIRE: gremlin.ProtoWireNumber = 10;
    const DEQUEUE_WIRE: gremlin.ProtoWireNumber = 11;
};
pub const Dwc3PrepareTrbFtraceEvent = struct {
    // fields
    name: ?[]const u8 = null,
    trb: u64 = 0,
    allocated: u32 = 0,
    queued: u32 = 0,
    bpl: u32 = 0,
    bph: u32 = 0,
    size: u32 = 0,
    ctrl: u32 = 0,
    type: u32 = 0,
    enqueue: u32 = 0,
    dequeue: u32 = 0,
    pub fn calcProtobufSize(self: *const Dwc3PrepareTrbFtraceEvent) usize {
        var res: usize = 0;
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(Dwc3PrepareTrbFtraceEventWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.trb != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3PrepareTrbFtraceEventWire.TRB_WIRE) + gremlin.sizes.sizeU64(self.trb);
        }
        if (self.allocated != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3PrepareTrbFtraceEventWire.ALLOCATED_WIRE) + gremlin.sizes.sizeU32(self.allocated);
        }
        if (self.queued != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3PrepareTrbFtraceEventWire.QUEUED_WIRE) + gremlin.sizes.sizeU32(self.queued);
        }
        if (self.bpl != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3PrepareTrbFtraceEventWire.BPL_WIRE) + gremlin.sizes.sizeU32(self.bpl);
        }
        if (self.bph != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3PrepareTrbFtraceEventWire.BPH_WIRE) + gremlin.sizes.sizeU32(self.bph);
        }
        if (self.size != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3PrepareTrbFtraceEventWire.SIZE_WIRE) + gremlin.sizes.sizeU32(self.size);
        }
        if (self.ctrl != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3PrepareTrbFtraceEventWire.CTRL_WIRE) + gremlin.sizes.sizeU32(self.ctrl);
        }
        if (self.type != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3PrepareTrbFtraceEventWire.TYPE_WIRE) + gremlin.sizes.sizeU32(self.type);
        }
        if (self.enqueue != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3PrepareTrbFtraceEventWire.ENQUEUE_WIRE) + gremlin.sizes.sizeU32(self.enqueue);
        }
        if (self.dequeue != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3PrepareTrbFtraceEventWire.DEQUEUE_WIRE) + gremlin.sizes.sizeU32(self.dequeue);
        }
        return res;
    }
    pub fn encode(self: *const Dwc3PrepareTrbFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Dwc3PrepareTrbFtraceEvent, target: *gremlin.Writer) void {
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(Dwc3PrepareTrbFtraceEventWire.NAME_WIRE, v);
            }
        }
        if (self.trb != 0) {
            target.appendUint64(Dwc3PrepareTrbFtraceEventWire.TRB_WIRE, self.trb);
        }
        if (self.allocated != 0) {
            target.appendUint32(Dwc3PrepareTrbFtraceEventWire.ALLOCATED_WIRE, self.allocated);
        }
        if (self.queued != 0) {
            target.appendUint32(Dwc3PrepareTrbFtraceEventWire.QUEUED_WIRE, self.queued);
        }
        if (self.bpl != 0) {
            target.appendUint32(Dwc3PrepareTrbFtraceEventWire.BPL_WIRE, self.bpl);
        }
        if (self.bph != 0) {
            target.appendUint32(Dwc3PrepareTrbFtraceEventWire.BPH_WIRE, self.bph);
        }
        if (self.size != 0) {
            target.appendUint32(Dwc3PrepareTrbFtraceEventWire.SIZE_WIRE, self.size);
        }
        if (self.ctrl != 0) {
            target.appendUint32(Dwc3PrepareTrbFtraceEventWire.CTRL_WIRE, self.ctrl);
        }
        if (self.type != 0) {
            target.appendUint32(Dwc3PrepareTrbFtraceEventWire.TYPE_WIRE, self.type);
        }
        if (self.enqueue != 0) {
            target.appendUint32(Dwc3PrepareTrbFtraceEventWire.ENQUEUE_WIRE, self.enqueue);
        }
        if (self.dequeue != 0) {
            target.appendUint32(Dwc3PrepareTrbFtraceEventWire.DEQUEUE_WIRE, self.dequeue);
        }
    }
};
pub const Dwc3PrepareTrbFtraceEventReader = struct {
    buf: gremlin.Reader,
    _name: ?[]const u8 = null,
    _trb: u64 = 0,
    _allocated: u32 = 0,
    _queued: u32 = 0,
    _bpl: u32 = 0,
    _bph: u32 = 0,
    _size: u32 = 0,
    _ctrl: u32 = 0,
    _type: u32 = 0,
    _enqueue: u32 = 0,
    _dequeue: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!Dwc3PrepareTrbFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Dwc3PrepareTrbFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Dwc3PrepareTrbFtraceEventWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                Dwc3PrepareTrbFtraceEventWire.TRB_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._trb = result.value;
                },
                Dwc3PrepareTrbFtraceEventWire.ALLOCATED_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._allocated = result.value;
                },
                Dwc3PrepareTrbFtraceEventWire.QUEUED_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._queued = result.value;
                },
                Dwc3PrepareTrbFtraceEventWire.BPL_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._bpl = result.value;
                },
                Dwc3PrepareTrbFtraceEventWire.BPH_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._bph = result.value;
                },
                Dwc3PrepareTrbFtraceEventWire.SIZE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._size = result.value;
                },
                Dwc3PrepareTrbFtraceEventWire.CTRL_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._ctrl = result.value;
                },
                Dwc3PrepareTrbFtraceEventWire.TYPE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._type = result.value;
                },
                Dwc3PrepareTrbFtraceEventWire.ENQUEUE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._enqueue = result.value;
                },
                Dwc3PrepareTrbFtraceEventWire.DEQUEUE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._dequeue = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getName(self: *const Dwc3PrepareTrbFtraceEventReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub inline fn getTrb(self: *const Dwc3PrepareTrbFtraceEventReader) u64 {
        return self._trb;
    }
    pub inline fn getAllocated(self: *const Dwc3PrepareTrbFtraceEventReader) u32 {
        return self._allocated;
    }
    pub inline fn getQueued(self: *const Dwc3PrepareTrbFtraceEventReader) u32 {
        return self._queued;
    }
    pub inline fn getBpl(self: *const Dwc3PrepareTrbFtraceEventReader) u32 {
        return self._bpl;
    }
    pub inline fn getBph(self: *const Dwc3PrepareTrbFtraceEventReader) u32 {
        return self._bph;
    }
    pub inline fn getSize(self: *const Dwc3PrepareTrbFtraceEventReader) u32 {
        return self._size;
    }
    pub inline fn getCtrl(self: *const Dwc3PrepareTrbFtraceEventReader) u32 {
        return self._ctrl;
    }
    pub inline fn getType(self: *const Dwc3PrepareTrbFtraceEventReader) u32 {
        return self._type;
    }
    pub inline fn getEnqueue(self: *const Dwc3PrepareTrbFtraceEventReader) u32 {
        return self._enqueue;
    }
    pub inline fn getDequeue(self: *const Dwc3PrepareTrbFtraceEventReader) u32 {
        return self._dequeue;
    }
};
const Dwc3ReadlFtraceEventWire = struct {
    const BASE_WIRE: gremlin.ProtoWireNumber = 1;
    const OFFSET_WIRE: gremlin.ProtoWireNumber = 2;
    const VALUE_WIRE: gremlin.ProtoWireNumber = 3;
    const MSG_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const Dwc3ReadlFtraceEvent = struct {
    // fields
    base: u64 = 0,
    offset: u32 = 0,
    value: u32 = 0,
    msg: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const Dwc3ReadlFtraceEvent) usize {
        var res: usize = 0;
        if (self.base != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3ReadlFtraceEventWire.BASE_WIRE) + gremlin.sizes.sizeU64(self.base);
        }
        if (self.offset != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3ReadlFtraceEventWire.OFFSET_WIRE) + gremlin.sizes.sizeU32(self.offset);
        }
        if (self.value != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3ReadlFtraceEventWire.VALUE_WIRE) + gremlin.sizes.sizeU32(self.value);
        }
        if (self.msg) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(Dwc3ReadlFtraceEventWire.MSG_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const Dwc3ReadlFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Dwc3ReadlFtraceEvent, target: *gremlin.Writer) void {
        if (self.base != 0) {
            target.appendUint64(Dwc3ReadlFtraceEventWire.BASE_WIRE, self.base);
        }
        if (self.offset != 0) {
            target.appendUint32(Dwc3ReadlFtraceEventWire.OFFSET_WIRE, self.offset);
        }
        if (self.value != 0) {
            target.appendUint32(Dwc3ReadlFtraceEventWire.VALUE_WIRE, self.value);
        }
        if (self.msg) |v| {
            if (v.len > 0) {
                target.appendBytes(Dwc3ReadlFtraceEventWire.MSG_WIRE, v);
            }
        }
    }
};
pub const Dwc3ReadlFtraceEventReader = struct {
    buf: gremlin.Reader,
    _base: u64 = 0,
    _offset: u32 = 0,
    _value: u32 = 0,
    _msg: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!Dwc3ReadlFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Dwc3ReadlFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Dwc3ReadlFtraceEventWire.BASE_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._base = result.value;
                },
                Dwc3ReadlFtraceEventWire.OFFSET_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._offset = result.value;
                },
                Dwc3ReadlFtraceEventWire.VALUE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._value = result.value;
                },
                Dwc3ReadlFtraceEventWire.MSG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._msg = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getBase(self: *const Dwc3ReadlFtraceEventReader) u64 {
        return self._base;
    }
    pub inline fn getOffset(self: *const Dwc3ReadlFtraceEventReader) u32 {
        return self._offset;
    }
    pub inline fn getValue(self: *const Dwc3ReadlFtraceEventReader) u32 {
        return self._value;
    }
    pub inline fn getMsg(self: *const Dwc3ReadlFtraceEventReader) []const u8 {
        return self._msg orelse &[_]u8{};
    }
};
const Dwc3WritelFtraceEventWire = struct {
    const BASE_WIRE: gremlin.ProtoWireNumber = 1;
    const OFFSET_WIRE: gremlin.ProtoWireNumber = 2;
    const VALUE_WIRE: gremlin.ProtoWireNumber = 3;
    const MSG_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const Dwc3WritelFtraceEvent = struct {
    // fields
    base: u64 = 0,
    offset: u32 = 0,
    value: u32 = 0,
    msg: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const Dwc3WritelFtraceEvent) usize {
        var res: usize = 0;
        if (self.base != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3WritelFtraceEventWire.BASE_WIRE) + gremlin.sizes.sizeU64(self.base);
        }
        if (self.offset != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3WritelFtraceEventWire.OFFSET_WIRE) + gremlin.sizes.sizeU32(self.offset);
        }
        if (self.value != 0) {
            res += gremlin.sizes.sizeWireNumber(Dwc3WritelFtraceEventWire.VALUE_WIRE) + gremlin.sizes.sizeU32(self.value);
        }
        if (self.msg) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(Dwc3WritelFtraceEventWire.MSG_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const Dwc3WritelFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Dwc3WritelFtraceEvent, target: *gremlin.Writer) void {
        if (self.base != 0) {
            target.appendUint64(Dwc3WritelFtraceEventWire.BASE_WIRE, self.base);
        }
        if (self.offset != 0) {
            target.appendUint32(Dwc3WritelFtraceEventWire.OFFSET_WIRE, self.offset);
        }
        if (self.value != 0) {
            target.appendUint32(Dwc3WritelFtraceEventWire.VALUE_WIRE, self.value);
        }
        if (self.msg) |v| {
            if (v.len > 0) {
                target.appendBytes(Dwc3WritelFtraceEventWire.MSG_WIRE, v);
            }
        }
    }
};
pub const Dwc3WritelFtraceEventReader = struct {
    buf: gremlin.Reader,
    _base: u64 = 0,
    _offset: u32 = 0,
    _value: u32 = 0,
    _msg: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!Dwc3WritelFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = Dwc3WritelFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                Dwc3WritelFtraceEventWire.BASE_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._base = result.value;
                },
                Dwc3WritelFtraceEventWire.OFFSET_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._offset = result.value;
                },
                Dwc3WritelFtraceEventWire.VALUE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._value = result.value;
                },
                Dwc3WritelFtraceEventWire.MSG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._msg = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getBase(self: *const Dwc3WritelFtraceEventReader) u64 {
        return self._base;
    }
    pub inline fn getOffset(self: *const Dwc3WritelFtraceEventReader) u32 {
        return self._offset;
    }
    pub inline fn getValue(self: *const Dwc3WritelFtraceEventReader) u32 {
        return self._value;
    }
    pub inline fn getMsg(self: *const Dwc3WritelFtraceEventReader) []const u8 {
        return self._msg orelse &[_]u8{};
    }
};
