// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const SoftirqEntryFtraceEventWire = struct {
    const VEC_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const SoftirqEntryFtraceEvent = struct {
    // fields
    vec: u32 = 0,
    pub fn calcProtobufSize(self: *const SoftirqEntryFtraceEvent) usize {
        var res: usize = 0;
        if (self.vec != 0) {
            res += gremlin.sizes.sizeWireNumber(SoftirqEntryFtraceEventWire.VEC_WIRE) + gremlin.sizes.sizeU32(self.vec);
        }
        return res;
    }
    pub fn encode(self: *const SoftirqEntryFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SoftirqEntryFtraceEvent, target: *gremlin.Writer) void {
        if (self.vec != 0) {
            target.appendUint32(SoftirqEntryFtraceEventWire.VEC_WIRE, self.vec);
        }
    }
};
pub const SoftirqEntryFtraceEventReader = struct {
    buf: gremlin.Reader,
    _vec: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!SoftirqEntryFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = SoftirqEntryFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SoftirqEntryFtraceEventWire.VEC_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._vec = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getVec(self: *const SoftirqEntryFtraceEventReader) u32 {
        return self._vec;
    }
};
const SoftirqExitFtraceEventWire = struct {
    const VEC_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const SoftirqExitFtraceEvent = struct {
    // fields
    vec: u32 = 0,
    pub fn calcProtobufSize(self: *const SoftirqExitFtraceEvent) usize {
        var res: usize = 0;
        if (self.vec != 0) {
            res += gremlin.sizes.sizeWireNumber(SoftirqExitFtraceEventWire.VEC_WIRE) + gremlin.sizes.sizeU32(self.vec);
        }
        return res;
    }
    pub fn encode(self: *const SoftirqExitFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SoftirqExitFtraceEvent, target: *gremlin.Writer) void {
        if (self.vec != 0) {
            target.appendUint32(SoftirqExitFtraceEventWire.VEC_WIRE, self.vec);
        }
    }
};
pub const SoftirqExitFtraceEventReader = struct {
    buf: gremlin.Reader,
    _vec: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!SoftirqExitFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = SoftirqExitFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SoftirqExitFtraceEventWire.VEC_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._vec = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getVec(self: *const SoftirqExitFtraceEventReader) u32 {
        return self._vec;
    }
};
const SoftirqRaiseFtraceEventWire = struct {
    const VEC_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const SoftirqRaiseFtraceEvent = struct {
    // fields
    vec: u32 = 0,
    pub fn calcProtobufSize(self: *const SoftirqRaiseFtraceEvent) usize {
        var res: usize = 0;
        if (self.vec != 0) {
            res += gremlin.sizes.sizeWireNumber(SoftirqRaiseFtraceEventWire.VEC_WIRE) + gremlin.sizes.sizeU32(self.vec);
        }
        return res;
    }
    pub fn encode(self: *const SoftirqRaiseFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SoftirqRaiseFtraceEvent, target: *gremlin.Writer) void {
        if (self.vec != 0) {
            target.appendUint32(SoftirqRaiseFtraceEventWire.VEC_WIRE, self.vec);
        }
    }
};
pub const SoftirqRaiseFtraceEventReader = struct {
    buf: gremlin.Reader,
    _vec: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!SoftirqRaiseFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = SoftirqRaiseFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SoftirqRaiseFtraceEventWire.VEC_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._vec = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getVec(self: *const SoftirqRaiseFtraceEventReader) u32 {
        return self._vec;
    }
};
const IrqHandlerEntryFtraceEventWire = struct {
    const IRQ_WIRE: gremlin.ProtoWireNumber = 1;
    const NAME_WIRE: gremlin.ProtoWireNumber = 2;
    const HANDLER_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const IrqHandlerEntryFtraceEvent = struct {
    // fields
    irq: i32 = 0,
    name: ?[]const u8 = null,
    handler: u32 = 0,
    pub fn calcProtobufSize(self: *const IrqHandlerEntryFtraceEvent) usize {
        var res: usize = 0;
        if (self.irq != 0) {
            res += gremlin.sizes.sizeWireNumber(IrqHandlerEntryFtraceEventWire.IRQ_WIRE) + gremlin.sizes.sizeI32(self.irq);
        }
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(IrqHandlerEntryFtraceEventWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.handler != 0) {
            res += gremlin.sizes.sizeWireNumber(IrqHandlerEntryFtraceEventWire.HANDLER_WIRE) + gremlin.sizes.sizeU32(self.handler);
        }
        return res;
    }
    pub fn encode(self: *const IrqHandlerEntryFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const IrqHandlerEntryFtraceEvent, target: *gremlin.Writer) void {
        if (self.irq != 0) {
            target.appendInt32(IrqHandlerEntryFtraceEventWire.IRQ_WIRE, self.irq);
        }
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(IrqHandlerEntryFtraceEventWire.NAME_WIRE, v);
            }
        }
        if (self.handler != 0) {
            target.appendUint32(IrqHandlerEntryFtraceEventWire.HANDLER_WIRE, self.handler);
        }
    }
};
pub const IrqHandlerEntryFtraceEventReader = struct {
    buf: gremlin.Reader,
    _irq: i32 = 0,
    _name: ?[]const u8 = null,
    _handler: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!IrqHandlerEntryFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = IrqHandlerEntryFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                IrqHandlerEntryFtraceEventWire.IRQ_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._irq = result.value;
                },
                IrqHandlerEntryFtraceEventWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                IrqHandlerEntryFtraceEventWire.HANDLER_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._handler = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getIrq(self: *const IrqHandlerEntryFtraceEventReader) i32 {
        return self._irq;
    }
    pub inline fn getName(self: *const IrqHandlerEntryFtraceEventReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub inline fn getHandler(self: *const IrqHandlerEntryFtraceEventReader) u32 {
        return self._handler;
    }
};
const IrqHandlerExitFtraceEventWire = struct {
    const IRQ_WIRE: gremlin.ProtoWireNumber = 1;
    const RET_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const IrqHandlerExitFtraceEvent = struct {
    // fields
    irq: i32 = 0,
    ret: i32 = 0,
    pub fn calcProtobufSize(self: *const IrqHandlerExitFtraceEvent) usize {
        var res: usize = 0;
        if (self.irq != 0) {
            res += gremlin.sizes.sizeWireNumber(IrqHandlerExitFtraceEventWire.IRQ_WIRE) + gremlin.sizes.sizeI32(self.irq);
        }
        if (self.ret != 0) {
            res += gremlin.sizes.sizeWireNumber(IrqHandlerExitFtraceEventWire.RET_WIRE) + gremlin.sizes.sizeI32(self.ret);
        }
        return res;
    }
    pub fn encode(self: *const IrqHandlerExitFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const IrqHandlerExitFtraceEvent, target: *gremlin.Writer) void {
        if (self.irq != 0) {
            target.appendInt32(IrqHandlerExitFtraceEventWire.IRQ_WIRE, self.irq);
        }
        if (self.ret != 0) {
            target.appendInt32(IrqHandlerExitFtraceEventWire.RET_WIRE, self.ret);
        }
    }
};
pub const IrqHandlerExitFtraceEventReader = struct {
    buf: gremlin.Reader,
    _irq: i32 = 0,
    _ret: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!IrqHandlerExitFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = IrqHandlerExitFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                IrqHandlerExitFtraceEventWire.IRQ_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._irq = result.value;
                },
                IrqHandlerExitFtraceEventWire.RET_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._ret = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getIrq(self: *const IrqHandlerExitFtraceEventReader) i32 {
        return self._irq;
    }
    pub inline fn getRet(self: *const IrqHandlerExitFtraceEventReader) i32 {
        return self._ret;
    }
};
