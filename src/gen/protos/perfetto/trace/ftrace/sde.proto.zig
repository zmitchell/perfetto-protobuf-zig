// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const SdeTracingMarkWriteFtraceEventWire = struct {
    const PID_WIRE: gremlin.ProtoWireNumber = 1;
    const TRACE_NAME_WIRE: gremlin.ProtoWireNumber = 2;
    const TRACE_TYPE_WIRE: gremlin.ProtoWireNumber = 3;
    const VALUE_WIRE: gremlin.ProtoWireNumber = 4;
    const TRACE_BEGIN_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const SdeTracingMarkWriteFtraceEvent = struct {
    // fields
    pid: i32 = 0,
    trace_name: ?[]const u8 = null,
    trace_type: u32 = 0,
    value: i32 = 0,
    trace_begin: u32 = 0,
    pub fn calcProtobufSize(self: *const SdeTracingMarkWriteFtraceEvent) usize {
        var res: usize = 0;
        if (self.pid != 0) {
            res += gremlin.sizes.sizeWireNumber(SdeTracingMarkWriteFtraceEventWire.PID_WIRE) + gremlin.sizes.sizeI32(self.pid);
        }
        if (self.trace_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(SdeTracingMarkWriteFtraceEventWire.TRACE_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.trace_type != 0) {
            res += gremlin.sizes.sizeWireNumber(SdeTracingMarkWriteFtraceEventWire.TRACE_TYPE_WIRE) + gremlin.sizes.sizeU32(self.trace_type);
        }
        if (self.value != 0) {
            res += gremlin.sizes.sizeWireNumber(SdeTracingMarkWriteFtraceEventWire.VALUE_WIRE) + gremlin.sizes.sizeI32(self.value);
        }
        if (self.trace_begin != 0) {
            res += gremlin.sizes.sizeWireNumber(SdeTracingMarkWriteFtraceEventWire.TRACE_BEGIN_WIRE) + gremlin.sizes.sizeU32(self.trace_begin);
        }
        return res;
    }
    pub fn encode(self: *const SdeTracingMarkWriteFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SdeTracingMarkWriteFtraceEvent, target: *gremlin.Writer) void {
        if (self.pid != 0) {
            target.appendInt32(SdeTracingMarkWriteFtraceEventWire.PID_WIRE, self.pid);
        }
        if (self.trace_name) |v| {
            if (v.len > 0) {
                target.appendBytes(SdeTracingMarkWriteFtraceEventWire.TRACE_NAME_WIRE, v);
            }
        }
        if (self.trace_type != 0) {
            target.appendUint32(SdeTracingMarkWriteFtraceEventWire.TRACE_TYPE_WIRE, self.trace_type);
        }
        if (self.value != 0) {
            target.appendInt32(SdeTracingMarkWriteFtraceEventWire.VALUE_WIRE, self.value);
        }
        if (self.trace_begin != 0) {
            target.appendUint32(SdeTracingMarkWriteFtraceEventWire.TRACE_BEGIN_WIRE, self.trace_begin);
        }
    }
};
pub const SdeTracingMarkWriteFtraceEventReader = struct {
    buf: gremlin.Reader,
    _pid: i32 = 0,
    _trace_name: ?[]const u8 = null,
    _trace_type: u32 = 0,
    _value: i32 = 0,
    _trace_begin: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!SdeTracingMarkWriteFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = SdeTracingMarkWriteFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SdeTracingMarkWriteFtraceEventWire.PID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._pid = result.value;
                },
                SdeTracingMarkWriteFtraceEventWire.TRACE_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._trace_name = result.value;
                },
                SdeTracingMarkWriteFtraceEventWire.TRACE_TYPE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._trace_type = result.value;
                },
                SdeTracingMarkWriteFtraceEventWire.VALUE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._value = result.value;
                },
                SdeTracingMarkWriteFtraceEventWire.TRACE_BEGIN_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._trace_begin = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getPid(self: *const SdeTracingMarkWriteFtraceEventReader) i32 {
        return self._pid;
    }
    pub inline fn getTraceName(self: *const SdeTracingMarkWriteFtraceEventReader) []const u8 {
        return self._trace_name orelse &[_]u8{};
    }
    pub inline fn getTraceType(self: *const SdeTracingMarkWriteFtraceEventReader) u32 {
        return self._trace_type;
    }
    pub inline fn getValue(self: *const SdeTracingMarkWriteFtraceEventReader) i32 {
        return self._value;
    }
    pub inline fn getTraceBegin(self: *const SdeTracingMarkWriteFtraceEventReader) u32 {
        return self._trace_begin;
    }
};
const SdeSdeEvtlogFtraceEventWire = struct {
    const EVTLOG_TAG_WIRE: gremlin.ProtoWireNumber = 1;
    const PID_WIRE: gremlin.ProtoWireNumber = 2;
    const TAG_ID_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const SdeSdeEvtlogFtraceEvent = struct {
    // fields
    evtlog_tag: ?[]const u8 = null,
    pid: i32 = 0,
    tag_id: u32 = 0,
    pub fn calcProtobufSize(self: *const SdeSdeEvtlogFtraceEvent) usize {
        var res: usize = 0;
        if (self.evtlog_tag) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(SdeSdeEvtlogFtraceEventWire.EVTLOG_TAG_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.pid != 0) {
            res += gremlin.sizes.sizeWireNumber(SdeSdeEvtlogFtraceEventWire.PID_WIRE) + gremlin.sizes.sizeI32(self.pid);
        }
        if (self.tag_id != 0) {
            res += gremlin.sizes.sizeWireNumber(SdeSdeEvtlogFtraceEventWire.TAG_ID_WIRE) + gremlin.sizes.sizeU32(self.tag_id);
        }
        return res;
    }
    pub fn encode(self: *const SdeSdeEvtlogFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SdeSdeEvtlogFtraceEvent, target: *gremlin.Writer) void {
        if (self.evtlog_tag) |v| {
            if (v.len > 0) {
                target.appendBytes(SdeSdeEvtlogFtraceEventWire.EVTLOG_TAG_WIRE, v);
            }
        }
        if (self.pid != 0) {
            target.appendInt32(SdeSdeEvtlogFtraceEventWire.PID_WIRE, self.pid);
        }
        if (self.tag_id != 0) {
            target.appendUint32(SdeSdeEvtlogFtraceEventWire.TAG_ID_WIRE, self.tag_id);
        }
    }
};
pub const SdeSdeEvtlogFtraceEventReader = struct {
    buf: gremlin.Reader,
    _evtlog_tag: ?[]const u8 = null,
    _pid: i32 = 0,
    _tag_id: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!SdeSdeEvtlogFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = SdeSdeEvtlogFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SdeSdeEvtlogFtraceEventWire.EVTLOG_TAG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._evtlog_tag = result.value;
                },
                SdeSdeEvtlogFtraceEventWire.PID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._pid = result.value;
                },
                SdeSdeEvtlogFtraceEventWire.TAG_ID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._tag_id = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getEvtlogTag(self: *const SdeSdeEvtlogFtraceEventReader) []const u8 {
        return self._evtlog_tag orelse &[_]u8{};
    }
    pub inline fn getPid(self: *const SdeSdeEvtlogFtraceEventReader) i32 {
        return self._pid;
    }
    pub inline fn getTagId(self: *const SdeSdeEvtlogFtraceEventReader) u32 {
        return self._tag_id;
    }
};
const SdeSdePerfCalcCrtcFtraceEventWire = struct {
    const BW_CTL_EBI_WIRE: gremlin.ProtoWireNumber = 1;
    const BW_CTL_LLCC_WIRE: gremlin.ProtoWireNumber = 2;
    const BW_CTL_MNOC_WIRE: gremlin.ProtoWireNumber = 3;
    const CORE_CLK_RATE_WIRE: gremlin.ProtoWireNumber = 4;
    const CRTC_WIRE: gremlin.ProtoWireNumber = 5;
    const IB_EBI_WIRE: gremlin.ProtoWireNumber = 6;
    const IB_LLCC_WIRE: gremlin.ProtoWireNumber = 7;
    const IB_MNOC_WIRE: gremlin.ProtoWireNumber = 8;
};
pub const SdeSdePerfCalcCrtcFtraceEvent = struct {
    // fields
    bw_ctl_ebi: u64 = 0,
    bw_ctl_llcc: u64 = 0,
    bw_ctl_mnoc: u64 = 0,
    core_clk_rate: u32 = 0,
    crtc: u32 = 0,
    ib_ebi: u64 = 0,
    ib_llcc: u64 = 0,
    ib_mnoc: u64 = 0,
    pub fn calcProtobufSize(self: *const SdeSdePerfCalcCrtcFtraceEvent) usize {
        var res: usize = 0;
        if (self.bw_ctl_ebi != 0) {
            res += gremlin.sizes.sizeWireNumber(SdeSdePerfCalcCrtcFtraceEventWire.BW_CTL_EBI_WIRE) + gremlin.sizes.sizeU64(self.bw_ctl_ebi);
        }
        if (self.bw_ctl_llcc != 0) {
            res += gremlin.sizes.sizeWireNumber(SdeSdePerfCalcCrtcFtraceEventWire.BW_CTL_LLCC_WIRE) + gremlin.sizes.sizeU64(self.bw_ctl_llcc);
        }
        if (self.bw_ctl_mnoc != 0) {
            res += gremlin.sizes.sizeWireNumber(SdeSdePerfCalcCrtcFtraceEventWire.BW_CTL_MNOC_WIRE) + gremlin.sizes.sizeU64(self.bw_ctl_mnoc);
        }
        if (self.core_clk_rate != 0) {
            res += gremlin.sizes.sizeWireNumber(SdeSdePerfCalcCrtcFtraceEventWire.CORE_CLK_RATE_WIRE) + gremlin.sizes.sizeU32(self.core_clk_rate);
        }
        if (self.crtc != 0) {
            res += gremlin.sizes.sizeWireNumber(SdeSdePerfCalcCrtcFtraceEventWire.CRTC_WIRE) + gremlin.sizes.sizeU32(self.crtc);
        }
        if (self.ib_ebi != 0) {
            res += gremlin.sizes.sizeWireNumber(SdeSdePerfCalcCrtcFtraceEventWire.IB_EBI_WIRE) + gremlin.sizes.sizeU64(self.ib_ebi);
        }
        if (self.ib_llcc != 0) {
            res += gremlin.sizes.sizeWireNumber(SdeSdePerfCalcCrtcFtraceEventWire.IB_LLCC_WIRE) + gremlin.sizes.sizeU64(self.ib_llcc);
        }
        if (self.ib_mnoc != 0) {
            res += gremlin.sizes.sizeWireNumber(SdeSdePerfCalcCrtcFtraceEventWire.IB_MNOC_WIRE) + gremlin.sizes.sizeU64(self.ib_mnoc);
        }
        return res;
    }
    pub fn encode(self: *const SdeSdePerfCalcCrtcFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SdeSdePerfCalcCrtcFtraceEvent, target: *gremlin.Writer) void {
        if (self.bw_ctl_ebi != 0) {
            target.appendUint64(SdeSdePerfCalcCrtcFtraceEventWire.BW_CTL_EBI_WIRE, self.bw_ctl_ebi);
        }
        if (self.bw_ctl_llcc != 0) {
            target.appendUint64(SdeSdePerfCalcCrtcFtraceEventWire.BW_CTL_LLCC_WIRE, self.bw_ctl_llcc);
        }
        if (self.bw_ctl_mnoc != 0) {
            target.appendUint64(SdeSdePerfCalcCrtcFtraceEventWire.BW_CTL_MNOC_WIRE, self.bw_ctl_mnoc);
        }
        if (self.core_clk_rate != 0) {
            target.appendUint32(SdeSdePerfCalcCrtcFtraceEventWire.CORE_CLK_RATE_WIRE, self.core_clk_rate);
        }
        if (self.crtc != 0) {
            target.appendUint32(SdeSdePerfCalcCrtcFtraceEventWire.CRTC_WIRE, self.crtc);
        }
        if (self.ib_ebi != 0) {
            target.appendUint64(SdeSdePerfCalcCrtcFtraceEventWire.IB_EBI_WIRE, self.ib_ebi);
        }
        if (self.ib_llcc != 0) {
            target.appendUint64(SdeSdePerfCalcCrtcFtraceEventWire.IB_LLCC_WIRE, self.ib_llcc);
        }
        if (self.ib_mnoc != 0) {
            target.appendUint64(SdeSdePerfCalcCrtcFtraceEventWire.IB_MNOC_WIRE, self.ib_mnoc);
        }
    }
};
pub const SdeSdePerfCalcCrtcFtraceEventReader = struct {
    buf: gremlin.Reader,
    _bw_ctl_ebi: u64 = 0,
    _bw_ctl_llcc: u64 = 0,
    _bw_ctl_mnoc: u64 = 0,
    _core_clk_rate: u32 = 0,
    _crtc: u32 = 0,
    _ib_ebi: u64 = 0,
    _ib_llcc: u64 = 0,
    _ib_mnoc: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!SdeSdePerfCalcCrtcFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = SdeSdePerfCalcCrtcFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SdeSdePerfCalcCrtcFtraceEventWire.BW_CTL_EBI_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._bw_ctl_ebi = result.value;
                },
                SdeSdePerfCalcCrtcFtraceEventWire.BW_CTL_LLCC_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._bw_ctl_llcc = result.value;
                },
                SdeSdePerfCalcCrtcFtraceEventWire.BW_CTL_MNOC_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._bw_ctl_mnoc = result.value;
                },
                SdeSdePerfCalcCrtcFtraceEventWire.CORE_CLK_RATE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._core_clk_rate = result.value;
                },
                SdeSdePerfCalcCrtcFtraceEventWire.CRTC_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._crtc = result.value;
                },
                SdeSdePerfCalcCrtcFtraceEventWire.IB_EBI_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ib_ebi = result.value;
                },
                SdeSdePerfCalcCrtcFtraceEventWire.IB_LLCC_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ib_llcc = result.value;
                },
                SdeSdePerfCalcCrtcFtraceEventWire.IB_MNOC_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ib_mnoc = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getBwCtlEbi(self: *const SdeSdePerfCalcCrtcFtraceEventReader) u64 {
        return self._bw_ctl_ebi;
    }
    pub inline fn getBwCtlLlcc(self: *const SdeSdePerfCalcCrtcFtraceEventReader) u64 {
        return self._bw_ctl_llcc;
    }
    pub inline fn getBwCtlMnoc(self: *const SdeSdePerfCalcCrtcFtraceEventReader) u64 {
        return self._bw_ctl_mnoc;
    }
    pub inline fn getCoreClkRate(self: *const SdeSdePerfCalcCrtcFtraceEventReader) u32 {
        return self._core_clk_rate;
    }
    pub inline fn getCrtc(self: *const SdeSdePerfCalcCrtcFtraceEventReader) u32 {
        return self._crtc;
    }
    pub inline fn getIbEbi(self: *const SdeSdePerfCalcCrtcFtraceEventReader) u64 {
        return self._ib_ebi;
    }
    pub inline fn getIbLlcc(self: *const SdeSdePerfCalcCrtcFtraceEventReader) u64 {
        return self._ib_llcc;
    }
    pub inline fn getIbMnoc(self: *const SdeSdePerfCalcCrtcFtraceEventReader) u64 {
        return self._ib_mnoc;
    }
};
const SdeSdePerfCrtcUpdateFtraceEventWire = struct {
    const BW_CTL_EBI_WIRE: gremlin.ProtoWireNumber = 1;
    const BW_CTL_LLCC_WIRE: gremlin.ProtoWireNumber = 2;
    const BW_CTL_MNOC_WIRE: gremlin.ProtoWireNumber = 3;
    const CORE_CLK_RATE_WIRE: gremlin.ProtoWireNumber = 4;
    const CRTC_WIRE: gremlin.ProtoWireNumber = 5;
    const PARAMS_WIRE: gremlin.ProtoWireNumber = 6;
    const PER_PIPE_IB_EBI_WIRE: gremlin.ProtoWireNumber = 7;
    const PER_PIPE_IB_LLCC_WIRE: gremlin.ProtoWireNumber = 8;
    const PER_PIPE_IB_MNOC_WIRE: gremlin.ProtoWireNumber = 9;
    const STOP_REQ_WIRE: gremlin.ProtoWireNumber = 10;
    const UPDATE_BUS_WIRE: gremlin.ProtoWireNumber = 11;
    const UPDATE_CLK_WIRE: gremlin.ProtoWireNumber = 12;
};
pub const SdeSdePerfCrtcUpdateFtraceEvent = struct {
    // fields
    bw_ctl_ebi: u64 = 0,
    bw_ctl_llcc: u64 = 0,
    bw_ctl_mnoc: u64 = 0,
    core_clk_rate: u32 = 0,
    crtc: u32 = 0,
    params: i32 = 0,
    per_pipe_ib_ebi: u64 = 0,
    per_pipe_ib_llcc: u64 = 0,
    per_pipe_ib_mnoc: u64 = 0,
    stop_req: u32 = 0,
    update_bus: u32 = 0,
    update_clk: u32 = 0,
    pub fn calcProtobufSize(self: *const SdeSdePerfCrtcUpdateFtraceEvent) usize {
        var res: usize = 0;
        if (self.bw_ctl_ebi != 0) {
            res += gremlin.sizes.sizeWireNumber(SdeSdePerfCrtcUpdateFtraceEventWire.BW_CTL_EBI_WIRE) + gremlin.sizes.sizeU64(self.bw_ctl_ebi);
        }
        if (self.bw_ctl_llcc != 0) {
            res += gremlin.sizes.sizeWireNumber(SdeSdePerfCrtcUpdateFtraceEventWire.BW_CTL_LLCC_WIRE) + gremlin.sizes.sizeU64(self.bw_ctl_llcc);
        }
        if (self.bw_ctl_mnoc != 0) {
            res += gremlin.sizes.sizeWireNumber(SdeSdePerfCrtcUpdateFtraceEventWire.BW_CTL_MNOC_WIRE) + gremlin.sizes.sizeU64(self.bw_ctl_mnoc);
        }
        if (self.core_clk_rate != 0) {
            res += gremlin.sizes.sizeWireNumber(SdeSdePerfCrtcUpdateFtraceEventWire.CORE_CLK_RATE_WIRE) + gremlin.sizes.sizeU32(self.core_clk_rate);
        }
        if (self.crtc != 0) {
            res += gremlin.sizes.sizeWireNumber(SdeSdePerfCrtcUpdateFtraceEventWire.CRTC_WIRE) + gremlin.sizes.sizeU32(self.crtc);
        }
        if (self.params != 0) {
            res += gremlin.sizes.sizeWireNumber(SdeSdePerfCrtcUpdateFtraceEventWire.PARAMS_WIRE) + gremlin.sizes.sizeI32(self.params);
        }
        if (self.per_pipe_ib_ebi != 0) {
            res += gremlin.sizes.sizeWireNumber(SdeSdePerfCrtcUpdateFtraceEventWire.PER_PIPE_IB_EBI_WIRE) + gremlin.sizes.sizeU64(self.per_pipe_ib_ebi);
        }
        if (self.per_pipe_ib_llcc != 0) {
            res += gremlin.sizes.sizeWireNumber(SdeSdePerfCrtcUpdateFtraceEventWire.PER_PIPE_IB_LLCC_WIRE) + gremlin.sizes.sizeU64(self.per_pipe_ib_llcc);
        }
        if (self.per_pipe_ib_mnoc != 0) {
            res += gremlin.sizes.sizeWireNumber(SdeSdePerfCrtcUpdateFtraceEventWire.PER_PIPE_IB_MNOC_WIRE) + gremlin.sizes.sizeU64(self.per_pipe_ib_mnoc);
        }
        if (self.stop_req != 0) {
            res += gremlin.sizes.sizeWireNumber(SdeSdePerfCrtcUpdateFtraceEventWire.STOP_REQ_WIRE) + gremlin.sizes.sizeU32(self.stop_req);
        }
        if (self.update_bus != 0) {
            res += gremlin.sizes.sizeWireNumber(SdeSdePerfCrtcUpdateFtraceEventWire.UPDATE_BUS_WIRE) + gremlin.sizes.sizeU32(self.update_bus);
        }
        if (self.update_clk != 0) {
            res += gremlin.sizes.sizeWireNumber(SdeSdePerfCrtcUpdateFtraceEventWire.UPDATE_CLK_WIRE) + gremlin.sizes.sizeU32(self.update_clk);
        }
        return res;
    }
    pub fn encode(self: *const SdeSdePerfCrtcUpdateFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SdeSdePerfCrtcUpdateFtraceEvent, target: *gremlin.Writer) void {
        if (self.bw_ctl_ebi != 0) {
            target.appendUint64(SdeSdePerfCrtcUpdateFtraceEventWire.BW_CTL_EBI_WIRE, self.bw_ctl_ebi);
        }
        if (self.bw_ctl_llcc != 0) {
            target.appendUint64(SdeSdePerfCrtcUpdateFtraceEventWire.BW_CTL_LLCC_WIRE, self.bw_ctl_llcc);
        }
        if (self.bw_ctl_mnoc != 0) {
            target.appendUint64(SdeSdePerfCrtcUpdateFtraceEventWire.BW_CTL_MNOC_WIRE, self.bw_ctl_mnoc);
        }
        if (self.core_clk_rate != 0) {
            target.appendUint32(SdeSdePerfCrtcUpdateFtraceEventWire.CORE_CLK_RATE_WIRE, self.core_clk_rate);
        }
        if (self.crtc != 0) {
            target.appendUint32(SdeSdePerfCrtcUpdateFtraceEventWire.CRTC_WIRE, self.crtc);
        }
        if (self.params != 0) {
            target.appendInt32(SdeSdePerfCrtcUpdateFtraceEventWire.PARAMS_WIRE, self.params);
        }
        if (self.per_pipe_ib_ebi != 0) {
            target.appendUint64(SdeSdePerfCrtcUpdateFtraceEventWire.PER_PIPE_IB_EBI_WIRE, self.per_pipe_ib_ebi);
        }
        if (self.per_pipe_ib_llcc != 0) {
            target.appendUint64(SdeSdePerfCrtcUpdateFtraceEventWire.PER_PIPE_IB_LLCC_WIRE, self.per_pipe_ib_llcc);
        }
        if (self.per_pipe_ib_mnoc != 0) {
            target.appendUint64(SdeSdePerfCrtcUpdateFtraceEventWire.PER_PIPE_IB_MNOC_WIRE, self.per_pipe_ib_mnoc);
        }
        if (self.stop_req != 0) {
            target.appendUint32(SdeSdePerfCrtcUpdateFtraceEventWire.STOP_REQ_WIRE, self.stop_req);
        }
        if (self.update_bus != 0) {
            target.appendUint32(SdeSdePerfCrtcUpdateFtraceEventWire.UPDATE_BUS_WIRE, self.update_bus);
        }
        if (self.update_clk != 0) {
            target.appendUint32(SdeSdePerfCrtcUpdateFtraceEventWire.UPDATE_CLK_WIRE, self.update_clk);
        }
    }
};
pub const SdeSdePerfCrtcUpdateFtraceEventReader = struct {
    buf: gremlin.Reader,
    _bw_ctl_ebi: u64 = 0,
    _bw_ctl_llcc: u64 = 0,
    _bw_ctl_mnoc: u64 = 0,
    _core_clk_rate: u32 = 0,
    _crtc: u32 = 0,
    _params: i32 = 0,
    _per_pipe_ib_ebi: u64 = 0,
    _per_pipe_ib_llcc: u64 = 0,
    _per_pipe_ib_mnoc: u64 = 0,
    _stop_req: u32 = 0,
    _update_bus: u32 = 0,
    _update_clk: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!SdeSdePerfCrtcUpdateFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = SdeSdePerfCrtcUpdateFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SdeSdePerfCrtcUpdateFtraceEventWire.BW_CTL_EBI_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._bw_ctl_ebi = result.value;
                },
                SdeSdePerfCrtcUpdateFtraceEventWire.BW_CTL_LLCC_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._bw_ctl_llcc = result.value;
                },
                SdeSdePerfCrtcUpdateFtraceEventWire.BW_CTL_MNOC_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._bw_ctl_mnoc = result.value;
                },
                SdeSdePerfCrtcUpdateFtraceEventWire.CORE_CLK_RATE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._core_clk_rate = result.value;
                },
                SdeSdePerfCrtcUpdateFtraceEventWire.CRTC_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._crtc = result.value;
                },
                SdeSdePerfCrtcUpdateFtraceEventWire.PARAMS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._params = result.value;
                },
                SdeSdePerfCrtcUpdateFtraceEventWire.PER_PIPE_IB_EBI_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._per_pipe_ib_ebi = result.value;
                },
                SdeSdePerfCrtcUpdateFtraceEventWire.PER_PIPE_IB_LLCC_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._per_pipe_ib_llcc = result.value;
                },
                SdeSdePerfCrtcUpdateFtraceEventWire.PER_PIPE_IB_MNOC_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._per_pipe_ib_mnoc = result.value;
                },
                SdeSdePerfCrtcUpdateFtraceEventWire.STOP_REQ_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._stop_req = result.value;
                },
                SdeSdePerfCrtcUpdateFtraceEventWire.UPDATE_BUS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._update_bus = result.value;
                },
                SdeSdePerfCrtcUpdateFtraceEventWire.UPDATE_CLK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._update_clk = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getBwCtlEbi(self: *const SdeSdePerfCrtcUpdateFtraceEventReader) u64 {
        return self._bw_ctl_ebi;
    }
    pub inline fn getBwCtlLlcc(self: *const SdeSdePerfCrtcUpdateFtraceEventReader) u64 {
        return self._bw_ctl_llcc;
    }
    pub inline fn getBwCtlMnoc(self: *const SdeSdePerfCrtcUpdateFtraceEventReader) u64 {
        return self._bw_ctl_mnoc;
    }
    pub inline fn getCoreClkRate(self: *const SdeSdePerfCrtcUpdateFtraceEventReader) u32 {
        return self._core_clk_rate;
    }
    pub inline fn getCrtc(self: *const SdeSdePerfCrtcUpdateFtraceEventReader) u32 {
        return self._crtc;
    }
    pub inline fn getParams(self: *const SdeSdePerfCrtcUpdateFtraceEventReader) i32 {
        return self._params;
    }
    pub inline fn getPerPipeIbEbi(self: *const SdeSdePerfCrtcUpdateFtraceEventReader) u64 {
        return self._per_pipe_ib_ebi;
    }
    pub inline fn getPerPipeIbLlcc(self: *const SdeSdePerfCrtcUpdateFtraceEventReader) u64 {
        return self._per_pipe_ib_llcc;
    }
    pub inline fn getPerPipeIbMnoc(self: *const SdeSdePerfCrtcUpdateFtraceEventReader) u64 {
        return self._per_pipe_ib_mnoc;
    }
    pub inline fn getStopReq(self: *const SdeSdePerfCrtcUpdateFtraceEventReader) u32 {
        return self._stop_req;
    }
    pub inline fn getUpdateBus(self: *const SdeSdePerfCrtcUpdateFtraceEventReader) u32 {
        return self._update_bus;
    }
    pub inline fn getUpdateClk(self: *const SdeSdePerfCrtcUpdateFtraceEventReader) u32 {
        return self._update_clk;
    }
};
const SdeSdePerfSetQosLutsFtraceEventWire = struct {
    const FL_WIRE: gremlin.ProtoWireNumber = 1;
    const FMT_WIRE: gremlin.ProtoWireNumber = 2;
    const LUT_WIRE: gremlin.ProtoWireNumber = 3;
    const LUT_USAGE_WIRE: gremlin.ProtoWireNumber = 4;
    const PNUM_WIRE: gremlin.ProtoWireNumber = 5;
    const RT_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const SdeSdePerfSetQosLutsFtraceEvent = struct {
    // fields
    fl: u32 = 0,
    fmt: u32 = 0,
    lut: u64 = 0,
    lut_usage: u32 = 0,
    pnum: u32 = 0,
    rt: u32 = 0,
    pub fn calcProtobufSize(self: *const SdeSdePerfSetQosLutsFtraceEvent) usize {
        var res: usize = 0;
        if (self.fl != 0) {
            res += gremlin.sizes.sizeWireNumber(SdeSdePerfSetQosLutsFtraceEventWire.FL_WIRE) + gremlin.sizes.sizeU32(self.fl);
        }
        if (self.fmt != 0) {
            res += gremlin.sizes.sizeWireNumber(SdeSdePerfSetQosLutsFtraceEventWire.FMT_WIRE) + gremlin.sizes.sizeU32(self.fmt);
        }
        if (self.lut != 0) {
            res += gremlin.sizes.sizeWireNumber(SdeSdePerfSetQosLutsFtraceEventWire.LUT_WIRE) + gremlin.sizes.sizeU64(self.lut);
        }
        if (self.lut_usage != 0) {
            res += gremlin.sizes.sizeWireNumber(SdeSdePerfSetQosLutsFtraceEventWire.LUT_USAGE_WIRE) + gremlin.sizes.sizeU32(self.lut_usage);
        }
        if (self.pnum != 0) {
            res += gremlin.sizes.sizeWireNumber(SdeSdePerfSetQosLutsFtraceEventWire.PNUM_WIRE) + gremlin.sizes.sizeU32(self.pnum);
        }
        if (self.rt != 0) {
            res += gremlin.sizes.sizeWireNumber(SdeSdePerfSetQosLutsFtraceEventWire.RT_WIRE) + gremlin.sizes.sizeU32(self.rt);
        }
        return res;
    }
    pub fn encode(self: *const SdeSdePerfSetQosLutsFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SdeSdePerfSetQosLutsFtraceEvent, target: *gremlin.Writer) void {
        if (self.fl != 0) {
            target.appendUint32(SdeSdePerfSetQosLutsFtraceEventWire.FL_WIRE, self.fl);
        }
        if (self.fmt != 0) {
            target.appendUint32(SdeSdePerfSetQosLutsFtraceEventWire.FMT_WIRE, self.fmt);
        }
        if (self.lut != 0) {
            target.appendUint64(SdeSdePerfSetQosLutsFtraceEventWire.LUT_WIRE, self.lut);
        }
        if (self.lut_usage != 0) {
            target.appendUint32(SdeSdePerfSetQosLutsFtraceEventWire.LUT_USAGE_WIRE, self.lut_usage);
        }
        if (self.pnum != 0) {
            target.appendUint32(SdeSdePerfSetQosLutsFtraceEventWire.PNUM_WIRE, self.pnum);
        }
        if (self.rt != 0) {
            target.appendUint32(SdeSdePerfSetQosLutsFtraceEventWire.RT_WIRE, self.rt);
        }
    }
};
pub const SdeSdePerfSetQosLutsFtraceEventReader = struct {
    buf: gremlin.Reader,
    _fl: u32 = 0,
    _fmt: u32 = 0,
    _lut: u64 = 0,
    _lut_usage: u32 = 0,
    _pnum: u32 = 0,
    _rt: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!SdeSdePerfSetQosLutsFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = SdeSdePerfSetQosLutsFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SdeSdePerfSetQosLutsFtraceEventWire.FL_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._fl = result.value;
                },
                SdeSdePerfSetQosLutsFtraceEventWire.FMT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._fmt = result.value;
                },
                SdeSdePerfSetQosLutsFtraceEventWire.LUT_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._lut = result.value;
                },
                SdeSdePerfSetQosLutsFtraceEventWire.LUT_USAGE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._lut_usage = result.value;
                },
                SdeSdePerfSetQosLutsFtraceEventWire.PNUM_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._pnum = result.value;
                },
                SdeSdePerfSetQosLutsFtraceEventWire.RT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._rt = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getFl(self: *const SdeSdePerfSetQosLutsFtraceEventReader) u32 {
        return self._fl;
    }
    pub inline fn getFmt(self: *const SdeSdePerfSetQosLutsFtraceEventReader) u32 {
        return self._fmt;
    }
    pub inline fn getLut(self: *const SdeSdePerfSetQosLutsFtraceEventReader) u64 {
        return self._lut;
    }
    pub inline fn getLutUsage(self: *const SdeSdePerfSetQosLutsFtraceEventReader) u32 {
        return self._lut_usage;
    }
    pub inline fn getPnum(self: *const SdeSdePerfSetQosLutsFtraceEventReader) u32 {
        return self._pnum;
    }
    pub inline fn getRt(self: *const SdeSdePerfSetQosLutsFtraceEventReader) u32 {
        return self._rt;
    }
};
const SdeSdePerfUpdateBusFtraceEventWire = struct {
    const AB_QUOTA_WIRE: gremlin.ProtoWireNumber = 1;
    const BUS_ID_WIRE: gremlin.ProtoWireNumber = 2;
    const CLIENT_WIRE: gremlin.ProtoWireNumber = 3;
    const IB_QUOTA_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const SdeSdePerfUpdateBusFtraceEvent = struct {
    // fields
    ab_quota: u64 = 0,
    bus_id: u32 = 0,
    client: i32 = 0,
    ib_quota: u64 = 0,
    pub fn calcProtobufSize(self: *const SdeSdePerfUpdateBusFtraceEvent) usize {
        var res: usize = 0;
        if (self.ab_quota != 0) {
            res += gremlin.sizes.sizeWireNumber(SdeSdePerfUpdateBusFtraceEventWire.AB_QUOTA_WIRE) + gremlin.sizes.sizeU64(self.ab_quota);
        }
        if (self.bus_id != 0) {
            res += gremlin.sizes.sizeWireNumber(SdeSdePerfUpdateBusFtraceEventWire.BUS_ID_WIRE) + gremlin.sizes.sizeU32(self.bus_id);
        }
        if (self.client != 0) {
            res += gremlin.sizes.sizeWireNumber(SdeSdePerfUpdateBusFtraceEventWire.CLIENT_WIRE) + gremlin.sizes.sizeI32(self.client);
        }
        if (self.ib_quota != 0) {
            res += gremlin.sizes.sizeWireNumber(SdeSdePerfUpdateBusFtraceEventWire.IB_QUOTA_WIRE) + gremlin.sizes.sizeU64(self.ib_quota);
        }
        return res;
    }
    pub fn encode(self: *const SdeSdePerfUpdateBusFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SdeSdePerfUpdateBusFtraceEvent, target: *gremlin.Writer) void {
        if (self.ab_quota != 0) {
            target.appendUint64(SdeSdePerfUpdateBusFtraceEventWire.AB_QUOTA_WIRE, self.ab_quota);
        }
        if (self.bus_id != 0) {
            target.appendUint32(SdeSdePerfUpdateBusFtraceEventWire.BUS_ID_WIRE, self.bus_id);
        }
        if (self.client != 0) {
            target.appendInt32(SdeSdePerfUpdateBusFtraceEventWire.CLIENT_WIRE, self.client);
        }
        if (self.ib_quota != 0) {
            target.appendUint64(SdeSdePerfUpdateBusFtraceEventWire.IB_QUOTA_WIRE, self.ib_quota);
        }
    }
};
pub const SdeSdePerfUpdateBusFtraceEventReader = struct {
    buf: gremlin.Reader,
    _ab_quota: u64 = 0,
    _bus_id: u32 = 0,
    _client: i32 = 0,
    _ib_quota: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!SdeSdePerfUpdateBusFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = SdeSdePerfUpdateBusFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SdeSdePerfUpdateBusFtraceEventWire.AB_QUOTA_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ab_quota = result.value;
                },
                SdeSdePerfUpdateBusFtraceEventWire.BUS_ID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._bus_id = result.value;
                },
                SdeSdePerfUpdateBusFtraceEventWire.CLIENT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._client = result.value;
                },
                SdeSdePerfUpdateBusFtraceEventWire.IB_QUOTA_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._ib_quota = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getAbQuota(self: *const SdeSdePerfUpdateBusFtraceEventReader) u64 {
        return self._ab_quota;
    }
    pub inline fn getBusId(self: *const SdeSdePerfUpdateBusFtraceEventReader) u32 {
        return self._bus_id;
    }
    pub inline fn getClient(self: *const SdeSdePerfUpdateBusFtraceEventReader) i32 {
        return self._client;
    }
    pub inline fn getIbQuota(self: *const SdeSdePerfUpdateBusFtraceEventReader) u64 {
        return self._ib_quota;
    }
};
