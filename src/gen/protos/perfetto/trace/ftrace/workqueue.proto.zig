// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const WorkqueueActivateWorkFtraceEventWire = struct {
    const WORK_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const WorkqueueActivateWorkFtraceEvent = struct {
    // fields
    work: u64 = 0,
    pub fn calcProtobufSize(self: *const WorkqueueActivateWorkFtraceEvent) usize {
        var res: usize = 0;
        if (self.work != 0) {
            res += gremlin.sizes.sizeWireNumber(WorkqueueActivateWorkFtraceEventWire.WORK_WIRE) + gremlin.sizes.sizeU64(self.work);
        }
        return res;
    }
    pub fn encode(self: *const WorkqueueActivateWorkFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const WorkqueueActivateWorkFtraceEvent, target: *gremlin.Writer) void {
        if (self.work != 0) {
            target.appendUint64(WorkqueueActivateWorkFtraceEventWire.WORK_WIRE, self.work);
        }
    }
};
pub const WorkqueueActivateWorkFtraceEventReader = struct {
    buf: gremlin.Reader,
    _work: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!WorkqueueActivateWorkFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = WorkqueueActivateWorkFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                WorkqueueActivateWorkFtraceEventWire.WORK_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._work = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getWork(self: *const WorkqueueActivateWorkFtraceEventReader) u64 {
        return self._work;
    }
};
const WorkqueueExecuteEndFtraceEventWire = struct {
    const WORK_WIRE: gremlin.ProtoWireNumber = 1;
    const FUNCTION_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const WorkqueueExecuteEndFtraceEvent = struct {
    // fields
    work: u64 = 0,
    function: u64 = 0,
    pub fn calcProtobufSize(self: *const WorkqueueExecuteEndFtraceEvent) usize {
        var res: usize = 0;
        if (self.work != 0) {
            res += gremlin.sizes.sizeWireNumber(WorkqueueExecuteEndFtraceEventWire.WORK_WIRE) + gremlin.sizes.sizeU64(self.work);
        }
        if (self.function != 0) {
            res += gremlin.sizes.sizeWireNumber(WorkqueueExecuteEndFtraceEventWire.FUNCTION_WIRE) + gremlin.sizes.sizeU64(self.function);
        }
        return res;
    }
    pub fn encode(self: *const WorkqueueExecuteEndFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const WorkqueueExecuteEndFtraceEvent, target: *gremlin.Writer) void {
        if (self.work != 0) {
            target.appendUint64(WorkqueueExecuteEndFtraceEventWire.WORK_WIRE, self.work);
        }
        if (self.function != 0) {
            target.appendUint64(WorkqueueExecuteEndFtraceEventWire.FUNCTION_WIRE, self.function);
        }
    }
};
pub const WorkqueueExecuteEndFtraceEventReader = struct {
    buf: gremlin.Reader,
    _work: u64 = 0,
    _function: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!WorkqueueExecuteEndFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = WorkqueueExecuteEndFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                WorkqueueExecuteEndFtraceEventWire.WORK_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._work = result.value;
                },
                WorkqueueExecuteEndFtraceEventWire.FUNCTION_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._function = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getWork(self: *const WorkqueueExecuteEndFtraceEventReader) u64 {
        return self._work;
    }
    pub inline fn getFunction(self: *const WorkqueueExecuteEndFtraceEventReader) u64 {
        return self._function;
    }
};
const WorkqueueExecuteStartFtraceEventWire = struct {
    const WORK_WIRE: gremlin.ProtoWireNumber = 1;
    const FUNCTION_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const WorkqueueExecuteStartFtraceEvent = struct {
    // fields
    work: u64 = 0,
    function: u64 = 0,
    pub fn calcProtobufSize(self: *const WorkqueueExecuteStartFtraceEvent) usize {
        var res: usize = 0;
        if (self.work != 0) {
            res += gremlin.sizes.sizeWireNumber(WorkqueueExecuteStartFtraceEventWire.WORK_WIRE) + gremlin.sizes.sizeU64(self.work);
        }
        if (self.function != 0) {
            res += gremlin.sizes.sizeWireNumber(WorkqueueExecuteStartFtraceEventWire.FUNCTION_WIRE) + gremlin.sizes.sizeU64(self.function);
        }
        return res;
    }
    pub fn encode(self: *const WorkqueueExecuteStartFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const WorkqueueExecuteStartFtraceEvent, target: *gremlin.Writer) void {
        if (self.work != 0) {
            target.appendUint64(WorkqueueExecuteStartFtraceEventWire.WORK_WIRE, self.work);
        }
        if (self.function != 0) {
            target.appendUint64(WorkqueueExecuteStartFtraceEventWire.FUNCTION_WIRE, self.function);
        }
    }
};
pub const WorkqueueExecuteStartFtraceEventReader = struct {
    buf: gremlin.Reader,
    _work: u64 = 0,
    _function: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!WorkqueueExecuteStartFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = WorkqueueExecuteStartFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                WorkqueueExecuteStartFtraceEventWire.WORK_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._work = result.value;
                },
                WorkqueueExecuteStartFtraceEventWire.FUNCTION_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._function = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getWork(self: *const WorkqueueExecuteStartFtraceEventReader) u64 {
        return self._work;
    }
    pub inline fn getFunction(self: *const WorkqueueExecuteStartFtraceEventReader) u64 {
        return self._function;
    }
};
const WorkqueueQueueWorkFtraceEventWire = struct {
    const WORK_WIRE: gremlin.ProtoWireNumber = 1;
    const FUNCTION_WIRE: gremlin.ProtoWireNumber = 2;
    const WORKQUEUE_WIRE: gremlin.ProtoWireNumber = 3;
    const REQ_CPU_WIRE: gremlin.ProtoWireNumber = 4;
    const CPU_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const WorkqueueQueueWorkFtraceEvent = struct {
    // fields
    work: u64 = 0,
    function: u64 = 0,
    workqueue: u64 = 0,
    req_cpu: u32 = 0,
    cpu: u32 = 0,
    pub fn calcProtobufSize(self: *const WorkqueueQueueWorkFtraceEvent) usize {
        var res: usize = 0;
        if (self.work != 0) {
            res += gremlin.sizes.sizeWireNumber(WorkqueueQueueWorkFtraceEventWire.WORK_WIRE) + gremlin.sizes.sizeU64(self.work);
        }
        if (self.function != 0) {
            res += gremlin.sizes.sizeWireNumber(WorkqueueQueueWorkFtraceEventWire.FUNCTION_WIRE) + gremlin.sizes.sizeU64(self.function);
        }
        if (self.workqueue != 0) {
            res += gremlin.sizes.sizeWireNumber(WorkqueueQueueWorkFtraceEventWire.WORKQUEUE_WIRE) + gremlin.sizes.sizeU64(self.workqueue);
        }
        if (self.req_cpu != 0) {
            res += gremlin.sizes.sizeWireNumber(WorkqueueQueueWorkFtraceEventWire.REQ_CPU_WIRE) + gremlin.sizes.sizeU32(self.req_cpu);
        }
        if (self.cpu != 0) {
            res += gremlin.sizes.sizeWireNumber(WorkqueueQueueWorkFtraceEventWire.CPU_WIRE) + gremlin.sizes.sizeU32(self.cpu);
        }
        return res;
    }
    pub fn encode(self: *const WorkqueueQueueWorkFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const WorkqueueQueueWorkFtraceEvent, target: *gremlin.Writer) void {
        if (self.work != 0) {
            target.appendUint64(WorkqueueQueueWorkFtraceEventWire.WORK_WIRE, self.work);
        }
        if (self.function != 0) {
            target.appendUint64(WorkqueueQueueWorkFtraceEventWire.FUNCTION_WIRE, self.function);
        }
        if (self.workqueue != 0) {
            target.appendUint64(WorkqueueQueueWorkFtraceEventWire.WORKQUEUE_WIRE, self.workqueue);
        }
        if (self.req_cpu != 0) {
            target.appendUint32(WorkqueueQueueWorkFtraceEventWire.REQ_CPU_WIRE, self.req_cpu);
        }
        if (self.cpu != 0) {
            target.appendUint32(WorkqueueQueueWorkFtraceEventWire.CPU_WIRE, self.cpu);
        }
    }
};
pub const WorkqueueQueueWorkFtraceEventReader = struct {
    buf: gremlin.Reader,
    _work: u64 = 0,
    _function: u64 = 0,
    _workqueue: u64 = 0,
    _req_cpu: u32 = 0,
    _cpu: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!WorkqueueQueueWorkFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = WorkqueueQueueWorkFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                WorkqueueQueueWorkFtraceEventWire.WORK_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._work = result.value;
                },
                WorkqueueQueueWorkFtraceEventWire.FUNCTION_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._function = result.value;
                },
                WorkqueueQueueWorkFtraceEventWire.WORKQUEUE_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._workqueue = result.value;
                },
                WorkqueueQueueWorkFtraceEventWire.REQ_CPU_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._req_cpu = result.value;
                },
                WorkqueueQueueWorkFtraceEventWire.CPU_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._cpu = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getWork(self: *const WorkqueueQueueWorkFtraceEventReader) u64 {
        return self._work;
    }
    pub inline fn getFunction(self: *const WorkqueueQueueWorkFtraceEventReader) u64 {
        return self._function;
    }
    pub inline fn getWorkqueue(self: *const WorkqueueQueueWorkFtraceEventReader) u64 {
        return self._workqueue;
    }
    pub inline fn getReqCpu(self: *const WorkqueueQueueWorkFtraceEventReader) u32 {
        return self._req_cpu;
    }
    pub inline fn getCpu(self: *const WorkqueueQueueWorkFtraceEventReader) u32 {
        return self._cpu;
    }
};
