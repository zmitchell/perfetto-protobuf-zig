// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const MmCompactionBeginFtraceEventWire = struct {
    const ZONE_START_WIRE: gremlin.ProtoWireNumber = 1;
    const MIGRATE_PFN_WIRE: gremlin.ProtoWireNumber = 2;
    const FREE_PFN_WIRE: gremlin.ProtoWireNumber = 3;
    const ZONE_END_WIRE: gremlin.ProtoWireNumber = 4;
    const SYNC_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const MmCompactionBeginFtraceEvent = struct {
    // fields
    zone_start: u64 = 0,
    migrate_pfn: u64 = 0,
    free_pfn: u64 = 0,
    zone_end: u64 = 0,
    sync: u32 = 0,
    pub fn calcProtobufSize(self: *const MmCompactionBeginFtraceEvent) usize {
        var res: usize = 0;
        if (self.zone_start != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionBeginFtraceEventWire.ZONE_START_WIRE) + gremlin.sizes.sizeU64(self.zone_start);
        }
        if (self.migrate_pfn != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionBeginFtraceEventWire.MIGRATE_PFN_WIRE) + gremlin.sizes.sizeU64(self.migrate_pfn);
        }
        if (self.free_pfn != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionBeginFtraceEventWire.FREE_PFN_WIRE) + gremlin.sizes.sizeU64(self.free_pfn);
        }
        if (self.zone_end != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionBeginFtraceEventWire.ZONE_END_WIRE) + gremlin.sizes.sizeU64(self.zone_end);
        }
        if (self.sync != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionBeginFtraceEventWire.SYNC_WIRE) + gremlin.sizes.sizeU32(self.sync);
        }
        return res;
    }
    pub fn encode(self: *const MmCompactionBeginFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const MmCompactionBeginFtraceEvent, target: *gremlin.Writer) void {
        if (self.zone_start != 0) {
            target.appendUint64(MmCompactionBeginFtraceEventWire.ZONE_START_WIRE, self.zone_start);
        }
        if (self.migrate_pfn != 0) {
            target.appendUint64(MmCompactionBeginFtraceEventWire.MIGRATE_PFN_WIRE, self.migrate_pfn);
        }
        if (self.free_pfn != 0) {
            target.appendUint64(MmCompactionBeginFtraceEventWire.FREE_PFN_WIRE, self.free_pfn);
        }
        if (self.zone_end != 0) {
            target.appendUint64(MmCompactionBeginFtraceEventWire.ZONE_END_WIRE, self.zone_end);
        }
        if (self.sync != 0) {
            target.appendUint32(MmCompactionBeginFtraceEventWire.SYNC_WIRE, self.sync);
        }
    }
};
pub const MmCompactionBeginFtraceEventReader = struct {
    buf: gremlin.Reader,
    _zone_start: u64 = 0,
    _migrate_pfn: u64 = 0,
    _free_pfn: u64 = 0,
    _zone_end: u64 = 0,
    _sync: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!MmCompactionBeginFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = MmCompactionBeginFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MmCompactionBeginFtraceEventWire.ZONE_START_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._zone_start = result.value;
                },
                MmCompactionBeginFtraceEventWire.MIGRATE_PFN_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._migrate_pfn = result.value;
                },
                MmCompactionBeginFtraceEventWire.FREE_PFN_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._free_pfn = result.value;
                },
                MmCompactionBeginFtraceEventWire.ZONE_END_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._zone_end = result.value;
                },
                MmCompactionBeginFtraceEventWire.SYNC_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._sync = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getZoneStart(self: *const MmCompactionBeginFtraceEventReader) u64 {
        return self._zone_start;
    }
    pub inline fn getMigratePfn(self: *const MmCompactionBeginFtraceEventReader) u64 {
        return self._migrate_pfn;
    }
    pub inline fn getFreePfn(self: *const MmCompactionBeginFtraceEventReader) u64 {
        return self._free_pfn;
    }
    pub inline fn getZoneEnd(self: *const MmCompactionBeginFtraceEventReader) u64 {
        return self._zone_end;
    }
    pub inline fn getSync(self: *const MmCompactionBeginFtraceEventReader) u32 {
        return self._sync;
    }
};
const MmCompactionDeferCompactionFtraceEventWire = struct {
    const NID_WIRE: gremlin.ProtoWireNumber = 1;
    const IDX_WIRE: gremlin.ProtoWireNumber = 2;
    const ORDER_WIRE: gremlin.ProtoWireNumber = 3;
    const CONSIDERED_WIRE: gremlin.ProtoWireNumber = 4;
    const DEFER_SHIFT_WIRE: gremlin.ProtoWireNumber = 5;
    const ORDER_FAILED_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const MmCompactionDeferCompactionFtraceEvent = struct {
    // fields
    nid: i32 = 0,
    idx: u32 = 0,
    order: i32 = 0,
    considered: u32 = 0,
    defer_shift: u32 = 0,
    order_failed: i32 = 0,
    pub fn calcProtobufSize(self: *const MmCompactionDeferCompactionFtraceEvent) usize {
        var res: usize = 0;
        if (self.nid != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionDeferCompactionFtraceEventWire.NID_WIRE) + gremlin.sizes.sizeI32(self.nid);
        }
        if (self.idx != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionDeferCompactionFtraceEventWire.IDX_WIRE) + gremlin.sizes.sizeU32(self.idx);
        }
        if (self.order != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionDeferCompactionFtraceEventWire.ORDER_WIRE) + gremlin.sizes.sizeI32(self.order);
        }
        if (self.considered != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionDeferCompactionFtraceEventWire.CONSIDERED_WIRE) + gremlin.sizes.sizeU32(self.considered);
        }
        if (self.defer_shift != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionDeferCompactionFtraceEventWire.DEFER_SHIFT_WIRE) + gremlin.sizes.sizeU32(self.defer_shift);
        }
        if (self.order_failed != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionDeferCompactionFtraceEventWire.ORDER_FAILED_WIRE) + gremlin.sizes.sizeI32(self.order_failed);
        }
        return res;
    }
    pub fn encode(self: *const MmCompactionDeferCompactionFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const MmCompactionDeferCompactionFtraceEvent, target: *gremlin.Writer) void {
        if (self.nid != 0) {
            target.appendInt32(MmCompactionDeferCompactionFtraceEventWire.NID_WIRE, self.nid);
        }
        if (self.idx != 0) {
            target.appendUint32(MmCompactionDeferCompactionFtraceEventWire.IDX_WIRE, self.idx);
        }
        if (self.order != 0) {
            target.appendInt32(MmCompactionDeferCompactionFtraceEventWire.ORDER_WIRE, self.order);
        }
        if (self.considered != 0) {
            target.appendUint32(MmCompactionDeferCompactionFtraceEventWire.CONSIDERED_WIRE, self.considered);
        }
        if (self.defer_shift != 0) {
            target.appendUint32(MmCompactionDeferCompactionFtraceEventWire.DEFER_SHIFT_WIRE, self.defer_shift);
        }
        if (self.order_failed != 0) {
            target.appendInt32(MmCompactionDeferCompactionFtraceEventWire.ORDER_FAILED_WIRE, self.order_failed);
        }
    }
};
pub const MmCompactionDeferCompactionFtraceEventReader = struct {
    buf: gremlin.Reader,
    _nid: i32 = 0,
    _idx: u32 = 0,
    _order: i32 = 0,
    _considered: u32 = 0,
    _defer_shift: u32 = 0,
    _order_failed: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!MmCompactionDeferCompactionFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = MmCompactionDeferCompactionFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MmCompactionDeferCompactionFtraceEventWire.NID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._nid = result.value;
                },
                MmCompactionDeferCompactionFtraceEventWire.IDX_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._idx = result.value;
                },
                MmCompactionDeferCompactionFtraceEventWire.ORDER_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._order = result.value;
                },
                MmCompactionDeferCompactionFtraceEventWire.CONSIDERED_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._considered = result.value;
                },
                MmCompactionDeferCompactionFtraceEventWire.DEFER_SHIFT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._defer_shift = result.value;
                },
                MmCompactionDeferCompactionFtraceEventWire.ORDER_FAILED_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._order_failed = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getNid(self: *const MmCompactionDeferCompactionFtraceEventReader) i32 {
        return self._nid;
    }
    pub inline fn getIdx(self: *const MmCompactionDeferCompactionFtraceEventReader) u32 {
        return self._idx;
    }
    pub inline fn getOrder(self: *const MmCompactionDeferCompactionFtraceEventReader) i32 {
        return self._order;
    }
    pub inline fn getConsidered(self: *const MmCompactionDeferCompactionFtraceEventReader) u32 {
        return self._considered;
    }
    pub inline fn getDeferShift(self: *const MmCompactionDeferCompactionFtraceEventReader) u32 {
        return self._defer_shift;
    }
    pub inline fn getOrderFailed(self: *const MmCompactionDeferCompactionFtraceEventReader) i32 {
        return self._order_failed;
    }
};
const MmCompactionDeferredFtraceEventWire = struct {
    const NID_WIRE: gremlin.ProtoWireNumber = 1;
    const IDX_WIRE: gremlin.ProtoWireNumber = 2;
    const ORDER_WIRE: gremlin.ProtoWireNumber = 3;
    const CONSIDERED_WIRE: gremlin.ProtoWireNumber = 4;
    const DEFER_SHIFT_WIRE: gremlin.ProtoWireNumber = 5;
    const ORDER_FAILED_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const MmCompactionDeferredFtraceEvent = struct {
    // fields
    nid: i32 = 0,
    idx: u32 = 0,
    order: i32 = 0,
    considered: u32 = 0,
    defer_shift: u32 = 0,
    order_failed: i32 = 0,
    pub fn calcProtobufSize(self: *const MmCompactionDeferredFtraceEvent) usize {
        var res: usize = 0;
        if (self.nid != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionDeferredFtraceEventWire.NID_WIRE) + gremlin.sizes.sizeI32(self.nid);
        }
        if (self.idx != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionDeferredFtraceEventWire.IDX_WIRE) + gremlin.sizes.sizeU32(self.idx);
        }
        if (self.order != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionDeferredFtraceEventWire.ORDER_WIRE) + gremlin.sizes.sizeI32(self.order);
        }
        if (self.considered != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionDeferredFtraceEventWire.CONSIDERED_WIRE) + gremlin.sizes.sizeU32(self.considered);
        }
        if (self.defer_shift != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionDeferredFtraceEventWire.DEFER_SHIFT_WIRE) + gremlin.sizes.sizeU32(self.defer_shift);
        }
        if (self.order_failed != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionDeferredFtraceEventWire.ORDER_FAILED_WIRE) + gremlin.sizes.sizeI32(self.order_failed);
        }
        return res;
    }
    pub fn encode(self: *const MmCompactionDeferredFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const MmCompactionDeferredFtraceEvent, target: *gremlin.Writer) void {
        if (self.nid != 0) {
            target.appendInt32(MmCompactionDeferredFtraceEventWire.NID_WIRE, self.nid);
        }
        if (self.idx != 0) {
            target.appendUint32(MmCompactionDeferredFtraceEventWire.IDX_WIRE, self.idx);
        }
        if (self.order != 0) {
            target.appendInt32(MmCompactionDeferredFtraceEventWire.ORDER_WIRE, self.order);
        }
        if (self.considered != 0) {
            target.appendUint32(MmCompactionDeferredFtraceEventWire.CONSIDERED_WIRE, self.considered);
        }
        if (self.defer_shift != 0) {
            target.appendUint32(MmCompactionDeferredFtraceEventWire.DEFER_SHIFT_WIRE, self.defer_shift);
        }
        if (self.order_failed != 0) {
            target.appendInt32(MmCompactionDeferredFtraceEventWire.ORDER_FAILED_WIRE, self.order_failed);
        }
    }
};
pub const MmCompactionDeferredFtraceEventReader = struct {
    buf: gremlin.Reader,
    _nid: i32 = 0,
    _idx: u32 = 0,
    _order: i32 = 0,
    _considered: u32 = 0,
    _defer_shift: u32 = 0,
    _order_failed: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!MmCompactionDeferredFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = MmCompactionDeferredFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MmCompactionDeferredFtraceEventWire.NID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._nid = result.value;
                },
                MmCompactionDeferredFtraceEventWire.IDX_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._idx = result.value;
                },
                MmCompactionDeferredFtraceEventWire.ORDER_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._order = result.value;
                },
                MmCompactionDeferredFtraceEventWire.CONSIDERED_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._considered = result.value;
                },
                MmCompactionDeferredFtraceEventWire.DEFER_SHIFT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._defer_shift = result.value;
                },
                MmCompactionDeferredFtraceEventWire.ORDER_FAILED_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._order_failed = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getNid(self: *const MmCompactionDeferredFtraceEventReader) i32 {
        return self._nid;
    }
    pub inline fn getIdx(self: *const MmCompactionDeferredFtraceEventReader) u32 {
        return self._idx;
    }
    pub inline fn getOrder(self: *const MmCompactionDeferredFtraceEventReader) i32 {
        return self._order;
    }
    pub inline fn getConsidered(self: *const MmCompactionDeferredFtraceEventReader) u32 {
        return self._considered;
    }
    pub inline fn getDeferShift(self: *const MmCompactionDeferredFtraceEventReader) u32 {
        return self._defer_shift;
    }
    pub inline fn getOrderFailed(self: *const MmCompactionDeferredFtraceEventReader) i32 {
        return self._order_failed;
    }
};
const MmCompactionDeferResetFtraceEventWire = struct {
    const NID_WIRE: gremlin.ProtoWireNumber = 1;
    const IDX_WIRE: gremlin.ProtoWireNumber = 2;
    const ORDER_WIRE: gremlin.ProtoWireNumber = 3;
    const CONSIDERED_WIRE: gremlin.ProtoWireNumber = 4;
    const DEFER_SHIFT_WIRE: gremlin.ProtoWireNumber = 5;
    const ORDER_FAILED_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const MmCompactionDeferResetFtraceEvent = struct {
    // fields
    nid: i32 = 0,
    idx: u32 = 0,
    order: i32 = 0,
    considered: u32 = 0,
    defer_shift: u32 = 0,
    order_failed: i32 = 0,
    pub fn calcProtobufSize(self: *const MmCompactionDeferResetFtraceEvent) usize {
        var res: usize = 0;
        if (self.nid != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionDeferResetFtraceEventWire.NID_WIRE) + gremlin.sizes.sizeI32(self.nid);
        }
        if (self.idx != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionDeferResetFtraceEventWire.IDX_WIRE) + gremlin.sizes.sizeU32(self.idx);
        }
        if (self.order != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionDeferResetFtraceEventWire.ORDER_WIRE) + gremlin.sizes.sizeI32(self.order);
        }
        if (self.considered != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionDeferResetFtraceEventWire.CONSIDERED_WIRE) + gremlin.sizes.sizeU32(self.considered);
        }
        if (self.defer_shift != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionDeferResetFtraceEventWire.DEFER_SHIFT_WIRE) + gremlin.sizes.sizeU32(self.defer_shift);
        }
        if (self.order_failed != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionDeferResetFtraceEventWire.ORDER_FAILED_WIRE) + gremlin.sizes.sizeI32(self.order_failed);
        }
        return res;
    }
    pub fn encode(self: *const MmCompactionDeferResetFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const MmCompactionDeferResetFtraceEvent, target: *gremlin.Writer) void {
        if (self.nid != 0) {
            target.appendInt32(MmCompactionDeferResetFtraceEventWire.NID_WIRE, self.nid);
        }
        if (self.idx != 0) {
            target.appendUint32(MmCompactionDeferResetFtraceEventWire.IDX_WIRE, self.idx);
        }
        if (self.order != 0) {
            target.appendInt32(MmCompactionDeferResetFtraceEventWire.ORDER_WIRE, self.order);
        }
        if (self.considered != 0) {
            target.appendUint32(MmCompactionDeferResetFtraceEventWire.CONSIDERED_WIRE, self.considered);
        }
        if (self.defer_shift != 0) {
            target.appendUint32(MmCompactionDeferResetFtraceEventWire.DEFER_SHIFT_WIRE, self.defer_shift);
        }
        if (self.order_failed != 0) {
            target.appendInt32(MmCompactionDeferResetFtraceEventWire.ORDER_FAILED_WIRE, self.order_failed);
        }
    }
};
pub const MmCompactionDeferResetFtraceEventReader = struct {
    buf: gremlin.Reader,
    _nid: i32 = 0,
    _idx: u32 = 0,
    _order: i32 = 0,
    _considered: u32 = 0,
    _defer_shift: u32 = 0,
    _order_failed: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!MmCompactionDeferResetFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = MmCompactionDeferResetFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MmCompactionDeferResetFtraceEventWire.NID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._nid = result.value;
                },
                MmCompactionDeferResetFtraceEventWire.IDX_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._idx = result.value;
                },
                MmCompactionDeferResetFtraceEventWire.ORDER_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._order = result.value;
                },
                MmCompactionDeferResetFtraceEventWire.CONSIDERED_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._considered = result.value;
                },
                MmCompactionDeferResetFtraceEventWire.DEFER_SHIFT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._defer_shift = result.value;
                },
                MmCompactionDeferResetFtraceEventWire.ORDER_FAILED_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._order_failed = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getNid(self: *const MmCompactionDeferResetFtraceEventReader) i32 {
        return self._nid;
    }
    pub inline fn getIdx(self: *const MmCompactionDeferResetFtraceEventReader) u32 {
        return self._idx;
    }
    pub inline fn getOrder(self: *const MmCompactionDeferResetFtraceEventReader) i32 {
        return self._order;
    }
    pub inline fn getConsidered(self: *const MmCompactionDeferResetFtraceEventReader) u32 {
        return self._considered;
    }
    pub inline fn getDeferShift(self: *const MmCompactionDeferResetFtraceEventReader) u32 {
        return self._defer_shift;
    }
    pub inline fn getOrderFailed(self: *const MmCompactionDeferResetFtraceEventReader) i32 {
        return self._order_failed;
    }
};
const MmCompactionEndFtraceEventWire = struct {
    const ZONE_START_WIRE: gremlin.ProtoWireNumber = 1;
    const MIGRATE_PFN_WIRE: gremlin.ProtoWireNumber = 2;
    const FREE_PFN_WIRE: gremlin.ProtoWireNumber = 3;
    const ZONE_END_WIRE: gremlin.ProtoWireNumber = 4;
    const SYNC_WIRE: gremlin.ProtoWireNumber = 5;
    const STATUS_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const MmCompactionEndFtraceEvent = struct {
    // fields
    zone_start: u64 = 0,
    migrate_pfn: u64 = 0,
    free_pfn: u64 = 0,
    zone_end: u64 = 0,
    sync: u32 = 0,
    status: i32 = 0,
    pub fn calcProtobufSize(self: *const MmCompactionEndFtraceEvent) usize {
        var res: usize = 0;
        if (self.zone_start != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionEndFtraceEventWire.ZONE_START_WIRE) + gremlin.sizes.sizeU64(self.zone_start);
        }
        if (self.migrate_pfn != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionEndFtraceEventWire.MIGRATE_PFN_WIRE) + gremlin.sizes.sizeU64(self.migrate_pfn);
        }
        if (self.free_pfn != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionEndFtraceEventWire.FREE_PFN_WIRE) + gremlin.sizes.sizeU64(self.free_pfn);
        }
        if (self.zone_end != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionEndFtraceEventWire.ZONE_END_WIRE) + gremlin.sizes.sizeU64(self.zone_end);
        }
        if (self.sync != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionEndFtraceEventWire.SYNC_WIRE) + gremlin.sizes.sizeU32(self.sync);
        }
        if (self.status != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionEndFtraceEventWire.STATUS_WIRE) + gremlin.sizes.sizeI32(self.status);
        }
        return res;
    }
    pub fn encode(self: *const MmCompactionEndFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const MmCompactionEndFtraceEvent, target: *gremlin.Writer) void {
        if (self.zone_start != 0) {
            target.appendUint64(MmCompactionEndFtraceEventWire.ZONE_START_WIRE, self.zone_start);
        }
        if (self.migrate_pfn != 0) {
            target.appendUint64(MmCompactionEndFtraceEventWire.MIGRATE_PFN_WIRE, self.migrate_pfn);
        }
        if (self.free_pfn != 0) {
            target.appendUint64(MmCompactionEndFtraceEventWire.FREE_PFN_WIRE, self.free_pfn);
        }
        if (self.zone_end != 0) {
            target.appendUint64(MmCompactionEndFtraceEventWire.ZONE_END_WIRE, self.zone_end);
        }
        if (self.sync != 0) {
            target.appendUint32(MmCompactionEndFtraceEventWire.SYNC_WIRE, self.sync);
        }
        if (self.status != 0) {
            target.appendInt32(MmCompactionEndFtraceEventWire.STATUS_WIRE, self.status);
        }
    }
};
pub const MmCompactionEndFtraceEventReader = struct {
    buf: gremlin.Reader,
    _zone_start: u64 = 0,
    _migrate_pfn: u64 = 0,
    _free_pfn: u64 = 0,
    _zone_end: u64 = 0,
    _sync: u32 = 0,
    _status: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!MmCompactionEndFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = MmCompactionEndFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MmCompactionEndFtraceEventWire.ZONE_START_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._zone_start = result.value;
                },
                MmCompactionEndFtraceEventWire.MIGRATE_PFN_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._migrate_pfn = result.value;
                },
                MmCompactionEndFtraceEventWire.FREE_PFN_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._free_pfn = result.value;
                },
                MmCompactionEndFtraceEventWire.ZONE_END_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._zone_end = result.value;
                },
                MmCompactionEndFtraceEventWire.SYNC_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._sync = result.value;
                },
                MmCompactionEndFtraceEventWire.STATUS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._status = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getZoneStart(self: *const MmCompactionEndFtraceEventReader) u64 {
        return self._zone_start;
    }
    pub inline fn getMigratePfn(self: *const MmCompactionEndFtraceEventReader) u64 {
        return self._migrate_pfn;
    }
    pub inline fn getFreePfn(self: *const MmCompactionEndFtraceEventReader) u64 {
        return self._free_pfn;
    }
    pub inline fn getZoneEnd(self: *const MmCompactionEndFtraceEventReader) u64 {
        return self._zone_end;
    }
    pub inline fn getSync(self: *const MmCompactionEndFtraceEventReader) u32 {
        return self._sync;
    }
    pub inline fn getStatus(self: *const MmCompactionEndFtraceEventReader) i32 {
        return self._status;
    }
};
const MmCompactionFinishedFtraceEventWire = struct {
    const NID_WIRE: gremlin.ProtoWireNumber = 1;
    const IDX_WIRE: gremlin.ProtoWireNumber = 2;
    const ORDER_WIRE: gremlin.ProtoWireNumber = 3;
    const RET_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const MmCompactionFinishedFtraceEvent = struct {
    // fields
    nid: i32 = 0,
    idx: u32 = 0,
    order: i32 = 0,
    ret: i32 = 0,
    pub fn calcProtobufSize(self: *const MmCompactionFinishedFtraceEvent) usize {
        var res: usize = 0;
        if (self.nid != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionFinishedFtraceEventWire.NID_WIRE) + gremlin.sizes.sizeI32(self.nid);
        }
        if (self.idx != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionFinishedFtraceEventWire.IDX_WIRE) + gremlin.sizes.sizeU32(self.idx);
        }
        if (self.order != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionFinishedFtraceEventWire.ORDER_WIRE) + gremlin.sizes.sizeI32(self.order);
        }
        if (self.ret != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionFinishedFtraceEventWire.RET_WIRE) + gremlin.sizes.sizeI32(self.ret);
        }
        return res;
    }
    pub fn encode(self: *const MmCompactionFinishedFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const MmCompactionFinishedFtraceEvent, target: *gremlin.Writer) void {
        if (self.nid != 0) {
            target.appendInt32(MmCompactionFinishedFtraceEventWire.NID_WIRE, self.nid);
        }
        if (self.idx != 0) {
            target.appendUint32(MmCompactionFinishedFtraceEventWire.IDX_WIRE, self.idx);
        }
        if (self.order != 0) {
            target.appendInt32(MmCompactionFinishedFtraceEventWire.ORDER_WIRE, self.order);
        }
        if (self.ret != 0) {
            target.appendInt32(MmCompactionFinishedFtraceEventWire.RET_WIRE, self.ret);
        }
    }
};
pub const MmCompactionFinishedFtraceEventReader = struct {
    buf: gremlin.Reader,
    _nid: i32 = 0,
    _idx: u32 = 0,
    _order: i32 = 0,
    _ret: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!MmCompactionFinishedFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = MmCompactionFinishedFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MmCompactionFinishedFtraceEventWire.NID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._nid = result.value;
                },
                MmCompactionFinishedFtraceEventWire.IDX_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._idx = result.value;
                },
                MmCompactionFinishedFtraceEventWire.ORDER_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._order = result.value;
                },
                MmCompactionFinishedFtraceEventWire.RET_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._ret = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getNid(self: *const MmCompactionFinishedFtraceEventReader) i32 {
        return self._nid;
    }
    pub inline fn getIdx(self: *const MmCompactionFinishedFtraceEventReader) u32 {
        return self._idx;
    }
    pub inline fn getOrder(self: *const MmCompactionFinishedFtraceEventReader) i32 {
        return self._order;
    }
    pub inline fn getRet(self: *const MmCompactionFinishedFtraceEventReader) i32 {
        return self._ret;
    }
};
const MmCompactionIsolateFreepagesFtraceEventWire = struct {
    const START_PFN_WIRE: gremlin.ProtoWireNumber = 1;
    const END_PFN_WIRE: gremlin.ProtoWireNumber = 2;
    const NR_SCANNED_WIRE: gremlin.ProtoWireNumber = 3;
    const NR_TAKEN_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const MmCompactionIsolateFreepagesFtraceEvent = struct {
    // fields
    start_pfn: u64 = 0,
    end_pfn: u64 = 0,
    nr_scanned: u64 = 0,
    nr_taken: u64 = 0,
    pub fn calcProtobufSize(self: *const MmCompactionIsolateFreepagesFtraceEvent) usize {
        var res: usize = 0;
        if (self.start_pfn != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionIsolateFreepagesFtraceEventWire.START_PFN_WIRE) + gremlin.sizes.sizeU64(self.start_pfn);
        }
        if (self.end_pfn != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionIsolateFreepagesFtraceEventWire.END_PFN_WIRE) + gremlin.sizes.sizeU64(self.end_pfn);
        }
        if (self.nr_scanned != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionIsolateFreepagesFtraceEventWire.NR_SCANNED_WIRE) + gremlin.sizes.sizeU64(self.nr_scanned);
        }
        if (self.nr_taken != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionIsolateFreepagesFtraceEventWire.NR_TAKEN_WIRE) + gremlin.sizes.sizeU64(self.nr_taken);
        }
        return res;
    }
    pub fn encode(self: *const MmCompactionIsolateFreepagesFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const MmCompactionIsolateFreepagesFtraceEvent, target: *gremlin.Writer) void {
        if (self.start_pfn != 0) {
            target.appendUint64(MmCompactionIsolateFreepagesFtraceEventWire.START_PFN_WIRE, self.start_pfn);
        }
        if (self.end_pfn != 0) {
            target.appendUint64(MmCompactionIsolateFreepagesFtraceEventWire.END_PFN_WIRE, self.end_pfn);
        }
        if (self.nr_scanned != 0) {
            target.appendUint64(MmCompactionIsolateFreepagesFtraceEventWire.NR_SCANNED_WIRE, self.nr_scanned);
        }
        if (self.nr_taken != 0) {
            target.appendUint64(MmCompactionIsolateFreepagesFtraceEventWire.NR_TAKEN_WIRE, self.nr_taken);
        }
    }
};
pub const MmCompactionIsolateFreepagesFtraceEventReader = struct {
    buf: gremlin.Reader,
    _start_pfn: u64 = 0,
    _end_pfn: u64 = 0,
    _nr_scanned: u64 = 0,
    _nr_taken: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!MmCompactionIsolateFreepagesFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = MmCompactionIsolateFreepagesFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MmCompactionIsolateFreepagesFtraceEventWire.START_PFN_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._start_pfn = result.value;
                },
                MmCompactionIsolateFreepagesFtraceEventWire.END_PFN_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._end_pfn = result.value;
                },
                MmCompactionIsolateFreepagesFtraceEventWire.NR_SCANNED_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._nr_scanned = result.value;
                },
                MmCompactionIsolateFreepagesFtraceEventWire.NR_TAKEN_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._nr_taken = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getStartPfn(self: *const MmCompactionIsolateFreepagesFtraceEventReader) u64 {
        return self._start_pfn;
    }
    pub inline fn getEndPfn(self: *const MmCompactionIsolateFreepagesFtraceEventReader) u64 {
        return self._end_pfn;
    }
    pub inline fn getNrScanned(self: *const MmCompactionIsolateFreepagesFtraceEventReader) u64 {
        return self._nr_scanned;
    }
    pub inline fn getNrTaken(self: *const MmCompactionIsolateFreepagesFtraceEventReader) u64 {
        return self._nr_taken;
    }
};
const MmCompactionIsolateMigratepagesFtraceEventWire = struct {
    const START_PFN_WIRE: gremlin.ProtoWireNumber = 1;
    const END_PFN_WIRE: gremlin.ProtoWireNumber = 2;
    const NR_SCANNED_WIRE: gremlin.ProtoWireNumber = 3;
    const NR_TAKEN_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const MmCompactionIsolateMigratepagesFtraceEvent = struct {
    // fields
    start_pfn: u64 = 0,
    end_pfn: u64 = 0,
    nr_scanned: u64 = 0,
    nr_taken: u64 = 0,
    pub fn calcProtobufSize(self: *const MmCompactionIsolateMigratepagesFtraceEvent) usize {
        var res: usize = 0;
        if (self.start_pfn != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionIsolateMigratepagesFtraceEventWire.START_PFN_WIRE) + gremlin.sizes.sizeU64(self.start_pfn);
        }
        if (self.end_pfn != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionIsolateMigratepagesFtraceEventWire.END_PFN_WIRE) + gremlin.sizes.sizeU64(self.end_pfn);
        }
        if (self.nr_scanned != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionIsolateMigratepagesFtraceEventWire.NR_SCANNED_WIRE) + gremlin.sizes.sizeU64(self.nr_scanned);
        }
        if (self.nr_taken != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionIsolateMigratepagesFtraceEventWire.NR_TAKEN_WIRE) + gremlin.sizes.sizeU64(self.nr_taken);
        }
        return res;
    }
    pub fn encode(self: *const MmCompactionIsolateMigratepagesFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const MmCompactionIsolateMigratepagesFtraceEvent, target: *gremlin.Writer) void {
        if (self.start_pfn != 0) {
            target.appendUint64(MmCompactionIsolateMigratepagesFtraceEventWire.START_PFN_WIRE, self.start_pfn);
        }
        if (self.end_pfn != 0) {
            target.appendUint64(MmCompactionIsolateMigratepagesFtraceEventWire.END_PFN_WIRE, self.end_pfn);
        }
        if (self.nr_scanned != 0) {
            target.appendUint64(MmCompactionIsolateMigratepagesFtraceEventWire.NR_SCANNED_WIRE, self.nr_scanned);
        }
        if (self.nr_taken != 0) {
            target.appendUint64(MmCompactionIsolateMigratepagesFtraceEventWire.NR_TAKEN_WIRE, self.nr_taken);
        }
    }
};
pub const MmCompactionIsolateMigratepagesFtraceEventReader = struct {
    buf: gremlin.Reader,
    _start_pfn: u64 = 0,
    _end_pfn: u64 = 0,
    _nr_scanned: u64 = 0,
    _nr_taken: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!MmCompactionIsolateMigratepagesFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = MmCompactionIsolateMigratepagesFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MmCompactionIsolateMigratepagesFtraceEventWire.START_PFN_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._start_pfn = result.value;
                },
                MmCompactionIsolateMigratepagesFtraceEventWire.END_PFN_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._end_pfn = result.value;
                },
                MmCompactionIsolateMigratepagesFtraceEventWire.NR_SCANNED_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._nr_scanned = result.value;
                },
                MmCompactionIsolateMigratepagesFtraceEventWire.NR_TAKEN_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._nr_taken = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getStartPfn(self: *const MmCompactionIsolateMigratepagesFtraceEventReader) u64 {
        return self._start_pfn;
    }
    pub inline fn getEndPfn(self: *const MmCompactionIsolateMigratepagesFtraceEventReader) u64 {
        return self._end_pfn;
    }
    pub inline fn getNrScanned(self: *const MmCompactionIsolateMigratepagesFtraceEventReader) u64 {
        return self._nr_scanned;
    }
    pub inline fn getNrTaken(self: *const MmCompactionIsolateMigratepagesFtraceEventReader) u64 {
        return self._nr_taken;
    }
};
const MmCompactionKcompactdSleepFtraceEventWire = struct {
    const NID_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const MmCompactionKcompactdSleepFtraceEvent = struct {
    // fields
    nid: i32 = 0,
    pub fn calcProtobufSize(self: *const MmCompactionKcompactdSleepFtraceEvent) usize {
        var res: usize = 0;
        if (self.nid != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionKcompactdSleepFtraceEventWire.NID_WIRE) + gremlin.sizes.sizeI32(self.nid);
        }
        return res;
    }
    pub fn encode(self: *const MmCompactionKcompactdSleepFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const MmCompactionKcompactdSleepFtraceEvent, target: *gremlin.Writer) void {
        if (self.nid != 0) {
            target.appendInt32(MmCompactionKcompactdSleepFtraceEventWire.NID_WIRE, self.nid);
        }
    }
};
pub const MmCompactionKcompactdSleepFtraceEventReader = struct {
    buf: gremlin.Reader,
    _nid: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!MmCompactionKcompactdSleepFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = MmCompactionKcompactdSleepFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MmCompactionKcompactdSleepFtraceEventWire.NID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._nid = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getNid(self: *const MmCompactionKcompactdSleepFtraceEventReader) i32 {
        return self._nid;
    }
};
const MmCompactionKcompactdWakeFtraceEventWire = struct {
    const NID_WIRE: gremlin.ProtoWireNumber = 1;
    const ORDER_WIRE: gremlin.ProtoWireNumber = 2;
    const CLASSZONE_IDX_WIRE: gremlin.ProtoWireNumber = 3;
    const HIGHEST_ZONEIDX_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const MmCompactionKcompactdWakeFtraceEvent = struct {
    // fields
    nid: i32 = 0,
    order: i32 = 0,
    classzone_idx: u32 = 0,
    highest_zoneidx: u32 = 0,
    pub fn calcProtobufSize(self: *const MmCompactionKcompactdWakeFtraceEvent) usize {
        var res: usize = 0;
        if (self.nid != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionKcompactdWakeFtraceEventWire.NID_WIRE) + gremlin.sizes.sizeI32(self.nid);
        }
        if (self.order != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionKcompactdWakeFtraceEventWire.ORDER_WIRE) + gremlin.sizes.sizeI32(self.order);
        }
        if (self.classzone_idx != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionKcompactdWakeFtraceEventWire.CLASSZONE_IDX_WIRE) + gremlin.sizes.sizeU32(self.classzone_idx);
        }
        if (self.highest_zoneidx != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionKcompactdWakeFtraceEventWire.HIGHEST_ZONEIDX_WIRE) + gremlin.sizes.sizeU32(self.highest_zoneidx);
        }
        return res;
    }
    pub fn encode(self: *const MmCompactionKcompactdWakeFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const MmCompactionKcompactdWakeFtraceEvent, target: *gremlin.Writer) void {
        if (self.nid != 0) {
            target.appendInt32(MmCompactionKcompactdWakeFtraceEventWire.NID_WIRE, self.nid);
        }
        if (self.order != 0) {
            target.appendInt32(MmCompactionKcompactdWakeFtraceEventWire.ORDER_WIRE, self.order);
        }
        if (self.classzone_idx != 0) {
            target.appendUint32(MmCompactionKcompactdWakeFtraceEventWire.CLASSZONE_IDX_WIRE, self.classzone_idx);
        }
        if (self.highest_zoneidx != 0) {
            target.appendUint32(MmCompactionKcompactdWakeFtraceEventWire.HIGHEST_ZONEIDX_WIRE, self.highest_zoneidx);
        }
    }
};
pub const MmCompactionKcompactdWakeFtraceEventReader = struct {
    buf: gremlin.Reader,
    _nid: i32 = 0,
    _order: i32 = 0,
    _classzone_idx: u32 = 0,
    _highest_zoneidx: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!MmCompactionKcompactdWakeFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = MmCompactionKcompactdWakeFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MmCompactionKcompactdWakeFtraceEventWire.NID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._nid = result.value;
                },
                MmCompactionKcompactdWakeFtraceEventWire.ORDER_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._order = result.value;
                },
                MmCompactionKcompactdWakeFtraceEventWire.CLASSZONE_IDX_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._classzone_idx = result.value;
                },
                MmCompactionKcompactdWakeFtraceEventWire.HIGHEST_ZONEIDX_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._highest_zoneidx = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getNid(self: *const MmCompactionKcompactdWakeFtraceEventReader) i32 {
        return self._nid;
    }
    pub inline fn getOrder(self: *const MmCompactionKcompactdWakeFtraceEventReader) i32 {
        return self._order;
    }
    pub inline fn getClasszoneIdx(self: *const MmCompactionKcompactdWakeFtraceEventReader) u32 {
        return self._classzone_idx;
    }
    pub inline fn getHighestZoneidx(self: *const MmCompactionKcompactdWakeFtraceEventReader) u32 {
        return self._highest_zoneidx;
    }
};
const MmCompactionMigratepagesFtraceEventWire = struct {
    const NR_MIGRATED_WIRE: gremlin.ProtoWireNumber = 1;
    const NR_FAILED_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const MmCompactionMigratepagesFtraceEvent = struct {
    // fields
    nr_migrated: u64 = 0,
    nr_failed: u64 = 0,
    pub fn calcProtobufSize(self: *const MmCompactionMigratepagesFtraceEvent) usize {
        var res: usize = 0;
        if (self.nr_migrated != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionMigratepagesFtraceEventWire.NR_MIGRATED_WIRE) + gremlin.sizes.sizeU64(self.nr_migrated);
        }
        if (self.nr_failed != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionMigratepagesFtraceEventWire.NR_FAILED_WIRE) + gremlin.sizes.sizeU64(self.nr_failed);
        }
        return res;
    }
    pub fn encode(self: *const MmCompactionMigratepagesFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const MmCompactionMigratepagesFtraceEvent, target: *gremlin.Writer) void {
        if (self.nr_migrated != 0) {
            target.appendUint64(MmCompactionMigratepagesFtraceEventWire.NR_MIGRATED_WIRE, self.nr_migrated);
        }
        if (self.nr_failed != 0) {
            target.appendUint64(MmCompactionMigratepagesFtraceEventWire.NR_FAILED_WIRE, self.nr_failed);
        }
    }
};
pub const MmCompactionMigratepagesFtraceEventReader = struct {
    buf: gremlin.Reader,
    _nr_migrated: u64 = 0,
    _nr_failed: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!MmCompactionMigratepagesFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = MmCompactionMigratepagesFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MmCompactionMigratepagesFtraceEventWire.NR_MIGRATED_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._nr_migrated = result.value;
                },
                MmCompactionMigratepagesFtraceEventWire.NR_FAILED_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._nr_failed = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getNrMigrated(self: *const MmCompactionMigratepagesFtraceEventReader) u64 {
        return self._nr_migrated;
    }
    pub inline fn getNrFailed(self: *const MmCompactionMigratepagesFtraceEventReader) u64 {
        return self._nr_failed;
    }
};
const MmCompactionSuitableFtraceEventWire = struct {
    const NID_WIRE: gremlin.ProtoWireNumber = 1;
    const IDX_WIRE: gremlin.ProtoWireNumber = 2;
    const ORDER_WIRE: gremlin.ProtoWireNumber = 3;
    const RET_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const MmCompactionSuitableFtraceEvent = struct {
    // fields
    nid: i32 = 0,
    idx: u32 = 0,
    order: i32 = 0,
    ret: i32 = 0,
    pub fn calcProtobufSize(self: *const MmCompactionSuitableFtraceEvent) usize {
        var res: usize = 0;
        if (self.nid != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionSuitableFtraceEventWire.NID_WIRE) + gremlin.sizes.sizeI32(self.nid);
        }
        if (self.idx != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionSuitableFtraceEventWire.IDX_WIRE) + gremlin.sizes.sizeU32(self.idx);
        }
        if (self.order != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionSuitableFtraceEventWire.ORDER_WIRE) + gremlin.sizes.sizeI32(self.order);
        }
        if (self.ret != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionSuitableFtraceEventWire.RET_WIRE) + gremlin.sizes.sizeI32(self.ret);
        }
        return res;
    }
    pub fn encode(self: *const MmCompactionSuitableFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const MmCompactionSuitableFtraceEvent, target: *gremlin.Writer) void {
        if (self.nid != 0) {
            target.appendInt32(MmCompactionSuitableFtraceEventWire.NID_WIRE, self.nid);
        }
        if (self.idx != 0) {
            target.appendUint32(MmCompactionSuitableFtraceEventWire.IDX_WIRE, self.idx);
        }
        if (self.order != 0) {
            target.appendInt32(MmCompactionSuitableFtraceEventWire.ORDER_WIRE, self.order);
        }
        if (self.ret != 0) {
            target.appendInt32(MmCompactionSuitableFtraceEventWire.RET_WIRE, self.ret);
        }
    }
};
pub const MmCompactionSuitableFtraceEventReader = struct {
    buf: gremlin.Reader,
    _nid: i32 = 0,
    _idx: u32 = 0,
    _order: i32 = 0,
    _ret: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!MmCompactionSuitableFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = MmCompactionSuitableFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MmCompactionSuitableFtraceEventWire.NID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._nid = result.value;
                },
                MmCompactionSuitableFtraceEventWire.IDX_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._idx = result.value;
                },
                MmCompactionSuitableFtraceEventWire.ORDER_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._order = result.value;
                },
                MmCompactionSuitableFtraceEventWire.RET_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._ret = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getNid(self: *const MmCompactionSuitableFtraceEventReader) i32 {
        return self._nid;
    }
    pub inline fn getIdx(self: *const MmCompactionSuitableFtraceEventReader) u32 {
        return self._idx;
    }
    pub inline fn getOrder(self: *const MmCompactionSuitableFtraceEventReader) i32 {
        return self._order;
    }
    pub inline fn getRet(self: *const MmCompactionSuitableFtraceEventReader) i32 {
        return self._ret;
    }
};
const MmCompactionTryToCompactPagesFtraceEventWire = struct {
    const ORDER_WIRE: gremlin.ProtoWireNumber = 1;
    const GFP_MASK_WIRE: gremlin.ProtoWireNumber = 2;
    const MODE_WIRE: gremlin.ProtoWireNumber = 3;
    const PRIO_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const MmCompactionTryToCompactPagesFtraceEvent = struct {
    // fields
    order: i32 = 0,
    gfp_mask: u32 = 0,
    mode: u32 = 0,
    prio: i32 = 0,
    pub fn calcProtobufSize(self: *const MmCompactionTryToCompactPagesFtraceEvent) usize {
        var res: usize = 0;
        if (self.order != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionTryToCompactPagesFtraceEventWire.ORDER_WIRE) + gremlin.sizes.sizeI32(self.order);
        }
        if (self.gfp_mask != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionTryToCompactPagesFtraceEventWire.GFP_MASK_WIRE) + gremlin.sizes.sizeU32(self.gfp_mask);
        }
        if (self.mode != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionTryToCompactPagesFtraceEventWire.MODE_WIRE) + gremlin.sizes.sizeU32(self.mode);
        }
        if (self.prio != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionTryToCompactPagesFtraceEventWire.PRIO_WIRE) + gremlin.sizes.sizeI32(self.prio);
        }
        return res;
    }
    pub fn encode(self: *const MmCompactionTryToCompactPagesFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const MmCompactionTryToCompactPagesFtraceEvent, target: *gremlin.Writer) void {
        if (self.order != 0) {
            target.appendInt32(MmCompactionTryToCompactPagesFtraceEventWire.ORDER_WIRE, self.order);
        }
        if (self.gfp_mask != 0) {
            target.appendUint32(MmCompactionTryToCompactPagesFtraceEventWire.GFP_MASK_WIRE, self.gfp_mask);
        }
        if (self.mode != 0) {
            target.appendUint32(MmCompactionTryToCompactPagesFtraceEventWire.MODE_WIRE, self.mode);
        }
        if (self.prio != 0) {
            target.appendInt32(MmCompactionTryToCompactPagesFtraceEventWire.PRIO_WIRE, self.prio);
        }
    }
};
pub const MmCompactionTryToCompactPagesFtraceEventReader = struct {
    buf: gremlin.Reader,
    _order: i32 = 0,
    _gfp_mask: u32 = 0,
    _mode: u32 = 0,
    _prio: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!MmCompactionTryToCompactPagesFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = MmCompactionTryToCompactPagesFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MmCompactionTryToCompactPagesFtraceEventWire.ORDER_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._order = result.value;
                },
                MmCompactionTryToCompactPagesFtraceEventWire.GFP_MASK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._gfp_mask = result.value;
                },
                MmCompactionTryToCompactPagesFtraceEventWire.MODE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._mode = result.value;
                },
                MmCompactionTryToCompactPagesFtraceEventWire.PRIO_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._prio = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getOrder(self: *const MmCompactionTryToCompactPagesFtraceEventReader) i32 {
        return self._order;
    }
    pub inline fn getGfpMask(self: *const MmCompactionTryToCompactPagesFtraceEventReader) u32 {
        return self._gfp_mask;
    }
    pub inline fn getMode(self: *const MmCompactionTryToCompactPagesFtraceEventReader) u32 {
        return self._mode;
    }
    pub inline fn getPrio(self: *const MmCompactionTryToCompactPagesFtraceEventReader) i32 {
        return self._prio;
    }
};
const MmCompactionWakeupKcompactdFtraceEventWire = struct {
    const NID_WIRE: gremlin.ProtoWireNumber = 1;
    const ORDER_WIRE: gremlin.ProtoWireNumber = 2;
    const CLASSZONE_IDX_WIRE: gremlin.ProtoWireNumber = 3;
    const HIGHEST_ZONEIDX_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const MmCompactionWakeupKcompactdFtraceEvent = struct {
    // fields
    nid: i32 = 0,
    order: i32 = 0,
    classzone_idx: u32 = 0,
    highest_zoneidx: u32 = 0,
    pub fn calcProtobufSize(self: *const MmCompactionWakeupKcompactdFtraceEvent) usize {
        var res: usize = 0;
        if (self.nid != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionWakeupKcompactdFtraceEventWire.NID_WIRE) + gremlin.sizes.sizeI32(self.nid);
        }
        if (self.order != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionWakeupKcompactdFtraceEventWire.ORDER_WIRE) + gremlin.sizes.sizeI32(self.order);
        }
        if (self.classzone_idx != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionWakeupKcompactdFtraceEventWire.CLASSZONE_IDX_WIRE) + gremlin.sizes.sizeU32(self.classzone_idx);
        }
        if (self.highest_zoneidx != 0) {
            res += gremlin.sizes.sizeWireNumber(MmCompactionWakeupKcompactdFtraceEventWire.HIGHEST_ZONEIDX_WIRE) + gremlin.sizes.sizeU32(self.highest_zoneidx);
        }
        return res;
    }
    pub fn encode(self: *const MmCompactionWakeupKcompactdFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const MmCompactionWakeupKcompactdFtraceEvent, target: *gremlin.Writer) void {
        if (self.nid != 0) {
            target.appendInt32(MmCompactionWakeupKcompactdFtraceEventWire.NID_WIRE, self.nid);
        }
        if (self.order != 0) {
            target.appendInt32(MmCompactionWakeupKcompactdFtraceEventWire.ORDER_WIRE, self.order);
        }
        if (self.classzone_idx != 0) {
            target.appendUint32(MmCompactionWakeupKcompactdFtraceEventWire.CLASSZONE_IDX_WIRE, self.classzone_idx);
        }
        if (self.highest_zoneidx != 0) {
            target.appendUint32(MmCompactionWakeupKcompactdFtraceEventWire.HIGHEST_ZONEIDX_WIRE, self.highest_zoneidx);
        }
    }
};
pub const MmCompactionWakeupKcompactdFtraceEventReader = struct {
    buf: gremlin.Reader,
    _nid: i32 = 0,
    _order: i32 = 0,
    _classzone_idx: u32 = 0,
    _highest_zoneidx: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!MmCompactionWakeupKcompactdFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = MmCompactionWakeupKcompactdFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MmCompactionWakeupKcompactdFtraceEventWire.NID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._nid = result.value;
                },
                MmCompactionWakeupKcompactdFtraceEventWire.ORDER_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._order = result.value;
                },
                MmCompactionWakeupKcompactdFtraceEventWire.CLASSZONE_IDX_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._classzone_idx = result.value;
                },
                MmCompactionWakeupKcompactdFtraceEventWire.HIGHEST_ZONEIDX_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._highest_zoneidx = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getNid(self: *const MmCompactionWakeupKcompactdFtraceEventReader) i32 {
        return self._nid;
    }
    pub inline fn getOrder(self: *const MmCompactionWakeupKcompactdFtraceEventReader) i32 {
        return self._order;
    }
    pub inline fn getClasszoneIdx(self: *const MmCompactionWakeupKcompactdFtraceEventReader) u32 {
        return self._classzone_idx;
    }
    pub inline fn getHighestZoneidx(self: *const MmCompactionWakeupKcompactdFtraceEventReader) u32 {
        return self._highest_zoneidx;
    }
};
