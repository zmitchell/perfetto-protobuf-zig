// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const HypervisorHostHcallFtraceEventWire = struct {
    const ID_WIRE: gremlin.ProtoWireNumber = 1;
    const INVALID_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const HypervisorHostHcallFtraceEvent = struct {
    // fields
    id: u32 = 0,
    invalid: u32 = 0,
    pub fn calcProtobufSize(self: *const HypervisorHostHcallFtraceEvent) usize {
        var res: usize = 0;
        if (self.id != 0) {
            res += gremlin.sizes.sizeWireNumber(HypervisorHostHcallFtraceEventWire.ID_WIRE) + gremlin.sizes.sizeU32(self.id);
        }
        if (self.invalid != 0) {
            res += gremlin.sizes.sizeWireNumber(HypervisorHostHcallFtraceEventWire.INVALID_WIRE) + gremlin.sizes.sizeU32(self.invalid);
        }
        return res;
    }
    pub fn encode(self: *const HypervisorHostHcallFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const HypervisorHostHcallFtraceEvent, target: *gremlin.Writer) void {
        if (self.id != 0) {
            target.appendUint32(HypervisorHostHcallFtraceEventWire.ID_WIRE, self.id);
        }
        if (self.invalid != 0) {
            target.appendUint32(HypervisorHostHcallFtraceEventWire.INVALID_WIRE, self.invalid);
        }
    }
};
pub const HypervisorHostHcallFtraceEventReader = struct {
    buf: gremlin.Reader,
    _id: u32 = 0,
    _invalid: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!HypervisorHostHcallFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = HypervisorHostHcallFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                HypervisorHostHcallFtraceEventWire.ID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._id = result.value;
                },
                HypervisorHostHcallFtraceEventWire.INVALID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._invalid = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getId(self: *const HypervisorHostHcallFtraceEventReader) u32 {
        return self._id;
    }
    pub inline fn getInvalid(self: *const HypervisorHostHcallFtraceEventReader) u32 {
        return self._invalid;
    }
};
const HypervisorHostSmcFtraceEventWire = struct {
    const ID_WIRE: gremlin.ProtoWireNumber = 1;
    const FORWARDED_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const HypervisorHostSmcFtraceEvent = struct {
    // fields
    id: u64 = 0,
    forwarded: u32 = 0,
    pub fn calcProtobufSize(self: *const HypervisorHostSmcFtraceEvent) usize {
        var res: usize = 0;
        if (self.id != 0) {
            res += gremlin.sizes.sizeWireNumber(HypervisorHostSmcFtraceEventWire.ID_WIRE) + gremlin.sizes.sizeU64(self.id);
        }
        if (self.forwarded != 0) {
            res += gremlin.sizes.sizeWireNumber(HypervisorHostSmcFtraceEventWire.FORWARDED_WIRE) + gremlin.sizes.sizeU32(self.forwarded);
        }
        return res;
    }
    pub fn encode(self: *const HypervisorHostSmcFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const HypervisorHostSmcFtraceEvent, target: *gremlin.Writer) void {
        if (self.id != 0) {
            target.appendUint64(HypervisorHostSmcFtraceEventWire.ID_WIRE, self.id);
        }
        if (self.forwarded != 0) {
            target.appendUint32(HypervisorHostSmcFtraceEventWire.FORWARDED_WIRE, self.forwarded);
        }
    }
};
pub const HypervisorHostSmcFtraceEventReader = struct {
    buf: gremlin.Reader,
    _id: u64 = 0,
    _forwarded: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!HypervisorHostSmcFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = HypervisorHostSmcFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                HypervisorHostSmcFtraceEventWire.ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._id = result.value;
                },
                HypervisorHostSmcFtraceEventWire.FORWARDED_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._forwarded = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getId(self: *const HypervisorHostSmcFtraceEventReader) u64 {
        return self._id;
    }
    pub inline fn getForwarded(self: *const HypervisorHostSmcFtraceEventReader) u32 {
        return self._forwarded;
    }
};
pub const HypervisorHypExitFtraceEvent = struct {
    pub fn calcProtobufSize(_: *const HypervisorHypExitFtraceEvent) usize {
        return 0;
    }
    pub fn encode(self: *const HypervisorHypExitFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(_: *const HypervisorHypExitFtraceEvent, _: *gremlin.Writer) void {}
};
pub const HypervisorHypExitFtraceEventReader = struct {
    buf: gremlin.Reader,
    pub fn init(src: []const u8) gremlin.Error!HypervisorHypExitFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        return HypervisorHypExitFtraceEventReader{ .buf = buf };
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
};
const HypervisorIommuIdmapFtraceEventWire = struct {
    const FROM_WIRE: gremlin.ProtoWireNumber = 1;
    const TO_WIRE: gremlin.ProtoWireNumber = 2;
    const PROT_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const HypervisorIommuIdmapFtraceEvent = struct {
    // fields
    from: u64 = 0,
    to: u64 = 0,
    prot: i32 = 0,
    pub fn calcProtobufSize(self: *const HypervisorIommuIdmapFtraceEvent) usize {
        var res: usize = 0;
        if (self.from != 0) {
            res += gremlin.sizes.sizeWireNumber(HypervisorIommuIdmapFtraceEventWire.FROM_WIRE) + gremlin.sizes.sizeU64(self.from);
        }
        if (self.to != 0) {
            res += gremlin.sizes.sizeWireNumber(HypervisorIommuIdmapFtraceEventWire.TO_WIRE) + gremlin.sizes.sizeU64(self.to);
        }
        if (self.prot != 0) {
            res += gremlin.sizes.sizeWireNumber(HypervisorIommuIdmapFtraceEventWire.PROT_WIRE) + gremlin.sizes.sizeI32(self.prot);
        }
        return res;
    }
    pub fn encode(self: *const HypervisorIommuIdmapFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const HypervisorIommuIdmapFtraceEvent, target: *gremlin.Writer) void {
        if (self.from != 0) {
            target.appendUint64(HypervisorIommuIdmapFtraceEventWire.FROM_WIRE, self.from);
        }
        if (self.to != 0) {
            target.appendUint64(HypervisorIommuIdmapFtraceEventWire.TO_WIRE, self.to);
        }
        if (self.prot != 0) {
            target.appendInt32(HypervisorIommuIdmapFtraceEventWire.PROT_WIRE, self.prot);
        }
    }
};
pub const HypervisorIommuIdmapFtraceEventReader = struct {
    buf: gremlin.Reader,
    _from: u64 = 0,
    _to: u64 = 0,
    _prot: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!HypervisorIommuIdmapFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = HypervisorIommuIdmapFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                HypervisorIommuIdmapFtraceEventWire.FROM_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._from = result.value;
                },
                HypervisorIommuIdmapFtraceEventWire.TO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._to = result.value;
                },
                HypervisorIommuIdmapFtraceEventWire.PROT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._prot = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getFrom(self: *const HypervisorIommuIdmapFtraceEventReader) u64 {
        return self._from;
    }
    pub inline fn getTo(self: *const HypervisorIommuIdmapFtraceEventReader) u64 {
        return self._to;
    }
    pub inline fn getProt(self: *const HypervisorIommuIdmapFtraceEventReader) i32 {
        return self._prot;
    }
};
const HypervisorPsciMemProtectFtraceEventWire = struct {
    const COUNT_WIRE: gremlin.ProtoWireNumber = 1;
    const WAS_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const HypervisorPsciMemProtectFtraceEvent = struct {
    // fields
    count: u64 = 0,
    was: u64 = 0,
    pub fn calcProtobufSize(self: *const HypervisorPsciMemProtectFtraceEvent) usize {
        var res: usize = 0;
        if (self.count != 0) {
            res += gremlin.sizes.sizeWireNumber(HypervisorPsciMemProtectFtraceEventWire.COUNT_WIRE) + gremlin.sizes.sizeU64(self.count);
        }
        if (self.was != 0) {
            res += gremlin.sizes.sizeWireNumber(HypervisorPsciMemProtectFtraceEventWire.WAS_WIRE) + gremlin.sizes.sizeU64(self.was);
        }
        return res;
    }
    pub fn encode(self: *const HypervisorPsciMemProtectFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const HypervisorPsciMemProtectFtraceEvent, target: *gremlin.Writer) void {
        if (self.count != 0) {
            target.appendUint64(HypervisorPsciMemProtectFtraceEventWire.COUNT_WIRE, self.count);
        }
        if (self.was != 0) {
            target.appendUint64(HypervisorPsciMemProtectFtraceEventWire.WAS_WIRE, self.was);
        }
    }
};
pub const HypervisorPsciMemProtectFtraceEventReader = struct {
    buf: gremlin.Reader,
    _count: u64 = 0,
    _was: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!HypervisorPsciMemProtectFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = HypervisorPsciMemProtectFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                HypervisorPsciMemProtectFtraceEventWire.COUNT_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._count = result.value;
                },
                HypervisorPsciMemProtectFtraceEventWire.WAS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._was = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getCount(self: *const HypervisorPsciMemProtectFtraceEventReader) u64 {
        return self._count;
    }
    pub inline fn getWas(self: *const HypervisorPsciMemProtectFtraceEventReader) u64 {
        return self._was;
    }
};
const HypervisorHostMemAbortFtraceEventWire = struct {
    const ESR_WIRE: gremlin.ProtoWireNumber = 1;
    const ADDR_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const HypervisorHostMemAbortFtraceEvent = struct {
    // fields
    esr: u64 = 0,
    addr: u64 = 0,
    pub fn calcProtobufSize(self: *const HypervisorHostMemAbortFtraceEvent) usize {
        var res: usize = 0;
        if (self.esr != 0) {
            res += gremlin.sizes.sizeWireNumber(HypervisorHostMemAbortFtraceEventWire.ESR_WIRE) + gremlin.sizes.sizeU64(self.esr);
        }
        if (self.addr != 0) {
            res += gremlin.sizes.sizeWireNumber(HypervisorHostMemAbortFtraceEventWire.ADDR_WIRE) + gremlin.sizes.sizeU64(self.addr);
        }
        return res;
    }
    pub fn encode(self: *const HypervisorHostMemAbortFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const HypervisorHostMemAbortFtraceEvent, target: *gremlin.Writer) void {
        if (self.esr != 0) {
            target.appendUint64(HypervisorHostMemAbortFtraceEventWire.ESR_WIRE, self.esr);
        }
        if (self.addr != 0) {
            target.appendUint64(HypervisorHostMemAbortFtraceEventWire.ADDR_WIRE, self.addr);
        }
    }
};
pub const HypervisorHostMemAbortFtraceEventReader = struct {
    buf: gremlin.Reader,
    _esr: u64 = 0,
    _addr: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!HypervisorHostMemAbortFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = HypervisorHostMemAbortFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                HypervisorHostMemAbortFtraceEventWire.ESR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._esr = result.value;
                },
                HypervisorHostMemAbortFtraceEventWire.ADDR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._addr = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getEsr(self: *const HypervisorHostMemAbortFtraceEventReader) u64 {
        return self._esr;
    }
    pub inline fn getAddr(self: *const HypervisorHostMemAbortFtraceEventReader) u64 {
        return self._addr;
    }
};
pub const HypervisorHypEnterFtraceEvent = struct {
    pub fn calcProtobufSize(_: *const HypervisorHypEnterFtraceEvent) usize {
        return 0;
    }
    pub fn encode(self: *const HypervisorHypEnterFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(_: *const HypervisorHypEnterFtraceEvent, _: *gremlin.Writer) void {}
};
pub const HypervisorHypEnterFtraceEventReader = struct {
    buf: gremlin.Reader,
    pub fn init(src: []const u8) gremlin.Error!HypervisorHypEnterFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        return HypervisorHypEnterFtraceEventReader{ .buf = buf };
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
};
const HypervisorIommuIdmapCompleteFtraceEventWire = struct {
    const MAP_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const HypervisorIommuIdmapCompleteFtraceEvent = struct {
    // fields
    map: u32 = 0,
    pub fn calcProtobufSize(self: *const HypervisorIommuIdmapCompleteFtraceEvent) usize {
        var res: usize = 0;
        if (self.map != 0) {
            res += gremlin.sizes.sizeWireNumber(HypervisorIommuIdmapCompleteFtraceEventWire.MAP_WIRE) + gremlin.sizes.sizeU32(self.map);
        }
        return res;
    }
    pub fn encode(self: *const HypervisorIommuIdmapCompleteFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const HypervisorIommuIdmapCompleteFtraceEvent, target: *gremlin.Writer) void {
        if (self.map != 0) {
            target.appendUint32(HypervisorIommuIdmapCompleteFtraceEventWire.MAP_WIRE, self.map);
        }
    }
};
pub const HypervisorIommuIdmapCompleteFtraceEventReader = struct {
    buf: gremlin.Reader,
    _map: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!HypervisorIommuIdmapCompleteFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = HypervisorIommuIdmapCompleteFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                HypervisorIommuIdmapCompleteFtraceEventWire.MAP_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._map = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getMap(self: *const HypervisorIommuIdmapCompleteFtraceEventReader) u32 {
        return self._map;
    }
};
const HypervisorVcpuIllegalTrapFtraceEventWire = struct {
    const ESR_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const HypervisorVcpuIllegalTrapFtraceEvent = struct {
    // fields
    esr: u64 = 0,
    pub fn calcProtobufSize(self: *const HypervisorVcpuIllegalTrapFtraceEvent) usize {
        var res: usize = 0;
        if (self.esr != 0) {
            res += gremlin.sizes.sizeWireNumber(HypervisorVcpuIllegalTrapFtraceEventWire.ESR_WIRE) + gremlin.sizes.sizeU64(self.esr);
        }
        return res;
    }
    pub fn encode(self: *const HypervisorVcpuIllegalTrapFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const HypervisorVcpuIllegalTrapFtraceEvent, target: *gremlin.Writer) void {
        if (self.esr != 0) {
            target.appendUint64(HypervisorVcpuIllegalTrapFtraceEventWire.ESR_WIRE, self.esr);
        }
    }
};
pub const HypervisorVcpuIllegalTrapFtraceEventReader = struct {
    buf: gremlin.Reader,
    _esr: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!HypervisorVcpuIllegalTrapFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = HypervisorVcpuIllegalTrapFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                HypervisorVcpuIllegalTrapFtraceEventWire.ESR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._esr = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getEsr(self: *const HypervisorVcpuIllegalTrapFtraceEventReader) u64 {
        return self._esr;
    }
};
