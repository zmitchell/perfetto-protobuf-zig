// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
pub const HypEnterFtraceEvent = struct {
    pub fn calcProtobufSize(_: *const HypEnterFtraceEvent) usize {
        return 0;
    }
    pub fn encode(self: *const HypEnterFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(_: *const HypEnterFtraceEvent, _: *gremlin.Writer) void {}
};
pub const HypEnterFtraceEventReader = struct {
    buf: gremlin.Reader,
    pub fn init(src: []const u8) gremlin.Error!HypEnterFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        return HypEnterFtraceEventReader{ .buf = buf };
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
};
pub const HypExitFtraceEvent = struct {
    pub fn calcProtobufSize(_: *const HypExitFtraceEvent) usize {
        return 0;
    }
    pub fn encode(self: *const HypExitFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(_: *const HypExitFtraceEvent, _: *gremlin.Writer) void {}
};
pub const HypExitFtraceEventReader = struct {
    buf: gremlin.Reader,
    pub fn init(src: []const u8) gremlin.Error!HypExitFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        return HypExitFtraceEventReader{ .buf = buf };
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
};
const HostHcallFtraceEventWire = struct {
    const ID_WIRE: gremlin.ProtoWireNumber = 1;
    const INVALID_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const HostHcallFtraceEvent = struct {
    // fields
    id: u32 = 0,
    invalid: u32 = 0,
    pub fn calcProtobufSize(self: *const HostHcallFtraceEvent) usize {
        var res: usize = 0;
        if (self.id != 0) {
            res += gremlin.sizes.sizeWireNumber(HostHcallFtraceEventWire.ID_WIRE) + gremlin.sizes.sizeU32(self.id);
        }
        if (self.invalid != 0) {
            res += gremlin.sizes.sizeWireNumber(HostHcallFtraceEventWire.INVALID_WIRE) + gremlin.sizes.sizeU32(self.invalid);
        }
        return res;
    }
    pub fn encode(self: *const HostHcallFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const HostHcallFtraceEvent, target: *gremlin.Writer) void {
        if (self.id != 0) {
            target.appendUint32(HostHcallFtraceEventWire.ID_WIRE, self.id);
        }
        if (self.invalid != 0) {
            target.appendUint32(HostHcallFtraceEventWire.INVALID_WIRE, self.invalid);
        }
    }
};
pub const HostHcallFtraceEventReader = struct {
    buf: gremlin.Reader,
    _id: u32 = 0,
    _invalid: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!HostHcallFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = HostHcallFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                HostHcallFtraceEventWire.ID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._id = result.value;
                },
                HostHcallFtraceEventWire.INVALID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._invalid = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getId(self: *const HostHcallFtraceEventReader) u32 {
        return self._id;
    }
    pub inline fn getInvalid(self: *const HostHcallFtraceEventReader) u32 {
        return self._invalid;
    }
};
const HostSmcFtraceEventWire = struct {
    const ID_WIRE: gremlin.ProtoWireNumber = 1;
    const FORWARDED_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const HostSmcFtraceEvent = struct {
    // fields
    id: u64 = 0,
    forwarded: u32 = 0,
    pub fn calcProtobufSize(self: *const HostSmcFtraceEvent) usize {
        var res: usize = 0;
        if (self.id != 0) {
            res += gremlin.sizes.sizeWireNumber(HostSmcFtraceEventWire.ID_WIRE) + gremlin.sizes.sizeU64(self.id);
        }
        if (self.forwarded != 0) {
            res += gremlin.sizes.sizeWireNumber(HostSmcFtraceEventWire.FORWARDED_WIRE) + gremlin.sizes.sizeU32(self.forwarded);
        }
        return res;
    }
    pub fn encode(self: *const HostSmcFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const HostSmcFtraceEvent, target: *gremlin.Writer) void {
        if (self.id != 0) {
            target.appendUint64(HostSmcFtraceEventWire.ID_WIRE, self.id);
        }
        if (self.forwarded != 0) {
            target.appendUint32(HostSmcFtraceEventWire.FORWARDED_WIRE, self.forwarded);
        }
    }
};
pub const HostSmcFtraceEventReader = struct {
    buf: gremlin.Reader,
    _id: u64 = 0,
    _forwarded: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!HostSmcFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = HostSmcFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                HostSmcFtraceEventWire.ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._id = result.value;
                },
                HostSmcFtraceEventWire.FORWARDED_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._forwarded = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getId(self: *const HostSmcFtraceEventReader) u64 {
        return self._id;
    }
    pub inline fn getForwarded(self: *const HostSmcFtraceEventReader) u32 {
        return self._forwarded;
    }
};
const HostMemAbortFtraceEventWire = struct {
    const ESR_WIRE: gremlin.ProtoWireNumber = 1;
    const ADDR_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const HostMemAbortFtraceEvent = struct {
    // fields
    esr: u64 = 0,
    addr: u64 = 0,
    pub fn calcProtobufSize(self: *const HostMemAbortFtraceEvent) usize {
        var res: usize = 0;
        if (self.esr != 0) {
            res += gremlin.sizes.sizeWireNumber(HostMemAbortFtraceEventWire.ESR_WIRE) + gremlin.sizes.sizeU64(self.esr);
        }
        if (self.addr != 0) {
            res += gremlin.sizes.sizeWireNumber(HostMemAbortFtraceEventWire.ADDR_WIRE) + gremlin.sizes.sizeU64(self.addr);
        }
        return res;
    }
    pub fn encode(self: *const HostMemAbortFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const HostMemAbortFtraceEvent, target: *gremlin.Writer) void {
        if (self.esr != 0) {
            target.appendUint64(HostMemAbortFtraceEventWire.ESR_WIRE, self.esr);
        }
        if (self.addr != 0) {
            target.appendUint64(HostMemAbortFtraceEventWire.ADDR_WIRE, self.addr);
        }
    }
};
pub const HostMemAbortFtraceEventReader = struct {
    buf: gremlin.Reader,
    _esr: u64 = 0,
    _addr: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!HostMemAbortFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = HostMemAbortFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                HostMemAbortFtraceEventWire.ESR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._esr = result.value;
                },
                HostMemAbortFtraceEventWire.ADDR_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._addr = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getEsr(self: *const HostMemAbortFtraceEventReader) u64 {
        return self._esr;
    }
    pub inline fn getAddr(self: *const HostMemAbortFtraceEventReader) u64 {
        return self._addr;
    }
};
const HostFfaCallFtraceEventWire = struct {
    const FUNC_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const RES_A1_WIRE: gremlin.ProtoWireNumber = 2;
    const RES_A2_WIRE: gremlin.ProtoWireNumber = 3;
    const RES_A3_WIRE: gremlin.ProtoWireNumber = 4;
    const RES_A4_WIRE: gremlin.ProtoWireNumber = 5;
    const HANDLED_WIRE: gremlin.ProtoWireNumber = 6;
    const ERR_WIRE: gremlin.ProtoWireNumber = 7;
};
pub const HostFfaCallFtraceEvent = struct {
    // fields
    func_id: u64 = 0,
    res_a1: u64 = 0,
    res_a2: u64 = 0,
    res_a3: u64 = 0,
    res_a4: u64 = 0,
    handled: i32 = 0,
    err: i32 = 0,
    pub fn calcProtobufSize(self: *const HostFfaCallFtraceEvent) usize {
        var res: usize = 0;
        if (self.func_id != 0) {
            res += gremlin.sizes.sizeWireNumber(HostFfaCallFtraceEventWire.FUNC_ID_WIRE) + gremlin.sizes.sizeU64(self.func_id);
        }
        if (self.res_a1 != 0) {
            res += gremlin.sizes.sizeWireNumber(HostFfaCallFtraceEventWire.RES_A1_WIRE) + gremlin.sizes.sizeU64(self.res_a1);
        }
        if (self.res_a2 != 0) {
            res += gremlin.sizes.sizeWireNumber(HostFfaCallFtraceEventWire.RES_A2_WIRE) + gremlin.sizes.sizeU64(self.res_a2);
        }
        if (self.res_a3 != 0) {
            res += gremlin.sizes.sizeWireNumber(HostFfaCallFtraceEventWire.RES_A3_WIRE) + gremlin.sizes.sizeU64(self.res_a3);
        }
        if (self.res_a4 != 0) {
            res += gremlin.sizes.sizeWireNumber(HostFfaCallFtraceEventWire.RES_A4_WIRE) + gremlin.sizes.sizeU64(self.res_a4);
        }
        if (self.handled != 0) {
            res += gremlin.sizes.sizeWireNumber(HostFfaCallFtraceEventWire.HANDLED_WIRE) + gremlin.sizes.sizeI32(self.handled);
        }
        if (self.err != 0) {
            res += gremlin.sizes.sizeWireNumber(HostFfaCallFtraceEventWire.ERR_WIRE) + gremlin.sizes.sizeI32(self.err);
        }
        return res;
    }
    pub fn encode(self: *const HostFfaCallFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const HostFfaCallFtraceEvent, target: *gremlin.Writer) void {
        if (self.func_id != 0) {
            target.appendUint64(HostFfaCallFtraceEventWire.FUNC_ID_WIRE, self.func_id);
        }
        if (self.res_a1 != 0) {
            target.appendUint64(HostFfaCallFtraceEventWire.RES_A1_WIRE, self.res_a1);
        }
        if (self.res_a2 != 0) {
            target.appendUint64(HostFfaCallFtraceEventWire.RES_A2_WIRE, self.res_a2);
        }
        if (self.res_a3 != 0) {
            target.appendUint64(HostFfaCallFtraceEventWire.RES_A3_WIRE, self.res_a3);
        }
        if (self.res_a4 != 0) {
            target.appendUint64(HostFfaCallFtraceEventWire.RES_A4_WIRE, self.res_a4);
        }
        if (self.handled != 0) {
            target.appendInt32(HostFfaCallFtraceEventWire.HANDLED_WIRE, self.handled);
        }
        if (self.err != 0) {
            target.appendInt32(HostFfaCallFtraceEventWire.ERR_WIRE, self.err);
        }
    }
};
pub const HostFfaCallFtraceEventReader = struct {
    buf: gremlin.Reader,
    _func_id: u64 = 0,
    _res_a1: u64 = 0,
    _res_a2: u64 = 0,
    _res_a3: u64 = 0,
    _res_a4: u64 = 0,
    _handled: i32 = 0,
    _err: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!HostFfaCallFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = HostFfaCallFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                HostFfaCallFtraceEventWire.FUNC_ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._func_id = result.value;
                },
                HostFfaCallFtraceEventWire.RES_A1_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._res_a1 = result.value;
                },
                HostFfaCallFtraceEventWire.RES_A2_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._res_a2 = result.value;
                },
                HostFfaCallFtraceEventWire.RES_A3_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._res_a3 = result.value;
                },
                HostFfaCallFtraceEventWire.RES_A4_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._res_a4 = result.value;
                },
                HostFfaCallFtraceEventWire.HANDLED_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._handled = result.value;
                },
                HostFfaCallFtraceEventWire.ERR_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._err = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getFuncId(self: *const HostFfaCallFtraceEventReader) u64 {
        return self._func_id;
    }
    pub inline fn getResA1(self: *const HostFfaCallFtraceEventReader) u64 {
        return self._res_a1;
    }
    pub inline fn getResA2(self: *const HostFfaCallFtraceEventReader) u64 {
        return self._res_a2;
    }
    pub inline fn getResA3(self: *const HostFfaCallFtraceEventReader) u64 {
        return self._res_a3;
    }
    pub inline fn getResA4(self: *const HostFfaCallFtraceEventReader) u64 {
        return self._res_a4;
    }
    pub inline fn getHandled(self: *const HostFfaCallFtraceEventReader) i32 {
        return self._handled;
    }
    pub inline fn getErr(self: *const HostFfaCallFtraceEventReader) i32 {
        return self._err;
    }
};
const IommuIdmapFtraceEventWire = struct {
    const FROM_WIRE: gremlin.ProtoWireNumber = 1;
    const TO_WIRE: gremlin.ProtoWireNumber = 2;
    const PROT_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const IommuIdmapFtraceEvent = struct {
    // fields
    from: u64 = 0,
    to: u64 = 0,
    prot: i32 = 0,
    pub fn calcProtobufSize(self: *const IommuIdmapFtraceEvent) usize {
        var res: usize = 0;
        if (self.from != 0) {
            res += gremlin.sizes.sizeWireNumber(IommuIdmapFtraceEventWire.FROM_WIRE) + gremlin.sizes.sizeU64(self.from);
        }
        if (self.to != 0) {
            res += gremlin.sizes.sizeWireNumber(IommuIdmapFtraceEventWire.TO_WIRE) + gremlin.sizes.sizeU64(self.to);
        }
        if (self.prot != 0) {
            res += gremlin.sizes.sizeWireNumber(IommuIdmapFtraceEventWire.PROT_WIRE) + gremlin.sizes.sizeI32(self.prot);
        }
        return res;
    }
    pub fn encode(self: *const IommuIdmapFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const IommuIdmapFtraceEvent, target: *gremlin.Writer) void {
        if (self.from != 0) {
            target.appendUint64(IommuIdmapFtraceEventWire.FROM_WIRE, self.from);
        }
        if (self.to != 0) {
            target.appendUint64(IommuIdmapFtraceEventWire.TO_WIRE, self.to);
        }
        if (self.prot != 0) {
            target.appendInt32(IommuIdmapFtraceEventWire.PROT_WIRE, self.prot);
        }
    }
};
pub const IommuIdmapFtraceEventReader = struct {
    buf: gremlin.Reader,
    _from: u64 = 0,
    _to: u64 = 0,
    _prot: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!IommuIdmapFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = IommuIdmapFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                IommuIdmapFtraceEventWire.FROM_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._from = result.value;
                },
                IommuIdmapFtraceEventWire.TO_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._to = result.value;
                },
                IommuIdmapFtraceEventWire.PROT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._prot = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getFrom(self: *const IommuIdmapFtraceEventReader) u64 {
        return self._from;
    }
    pub inline fn getTo(self: *const IommuIdmapFtraceEventReader) u64 {
        return self._to;
    }
    pub inline fn getProt(self: *const IommuIdmapFtraceEventReader) i32 {
        return self._prot;
    }
};
const PsciMemProtectFtraceEventWire = struct {
    const COUNT_WIRE: gremlin.ProtoWireNumber = 1;
    const WAS_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const PsciMemProtectFtraceEvent = struct {
    // fields
    count: u64 = 0,
    was: u64 = 0,
    pub fn calcProtobufSize(self: *const PsciMemProtectFtraceEvent) usize {
        var res: usize = 0;
        if (self.count != 0) {
            res += gremlin.sizes.sizeWireNumber(PsciMemProtectFtraceEventWire.COUNT_WIRE) + gremlin.sizes.sizeU64(self.count);
        }
        if (self.was != 0) {
            res += gremlin.sizes.sizeWireNumber(PsciMemProtectFtraceEventWire.WAS_WIRE) + gremlin.sizes.sizeU64(self.was);
        }
        return res;
    }
    pub fn encode(self: *const PsciMemProtectFtraceEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const PsciMemProtectFtraceEvent, target: *gremlin.Writer) void {
        if (self.count != 0) {
            target.appendUint64(PsciMemProtectFtraceEventWire.COUNT_WIRE, self.count);
        }
        if (self.was != 0) {
            target.appendUint64(PsciMemProtectFtraceEventWire.WAS_WIRE, self.was);
        }
    }
};
pub const PsciMemProtectFtraceEventReader = struct {
    buf: gremlin.Reader,
    _count: u64 = 0,
    _was: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!PsciMemProtectFtraceEventReader {
        const buf = gremlin.Reader.init(src);
        var res = PsciMemProtectFtraceEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                PsciMemProtectFtraceEventWire.COUNT_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._count = result.value;
                },
                PsciMemProtectFtraceEventWire.WAS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._was = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getCount(self: *const PsciMemProtectFtraceEventReader) u64 {
        return self._count;
    }
    pub inline fn getWas(self: *const PsciMemProtectFtraceEventReader) u64 {
        return self._was;
    }
};
