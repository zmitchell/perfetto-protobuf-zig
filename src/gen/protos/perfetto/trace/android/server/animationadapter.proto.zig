// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
const remote_animation_target = @import("src/gen/protos/perfetto/trace/android/view/remote_animation_target.proto.zig");
const point = @import("src/gen/protos/perfetto/trace/android/graphics/point.proto.zig");
// structs
const AnimationAdapterProtoWire = struct {
    const LOCAL_WIRE: gremlin.ProtoWireNumber = 1;
    const REMOTE_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const AnimationAdapterProto = struct {
    // fields
    local: ?LocalAnimationAdapterProto = null,
    remote: ?RemoteAnimationAdapterWrapperProto = null,
    pub fn calcProtobufSize(self: *const AnimationAdapterProto) usize {
        var res: usize = 0;
        if (self.local) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AnimationAdapterProtoWire.LOCAL_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.remote) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AnimationAdapterProtoWire.REMOTE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const AnimationAdapterProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AnimationAdapterProto, target: *gremlin.Writer) void {
        if (self.local) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AnimationAdapterProtoWire.LOCAL_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.remote) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AnimationAdapterProtoWire.REMOTE_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const AnimationAdapterProtoReader = struct {
    buf: gremlin.Reader,
    _local_buf: ?[]const u8 = null,
    _remote_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!AnimationAdapterProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = AnimationAdapterProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AnimationAdapterProtoWire.LOCAL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._local_buf = result.value;
                },
                AnimationAdapterProtoWire.REMOTE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._remote_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getLocal(self: *const AnimationAdapterProtoReader) gremlin.Error!LocalAnimationAdapterProtoReader {
        if (self._local_buf) |buf| {
            return try LocalAnimationAdapterProtoReader.init(buf);
        }
        return try LocalAnimationAdapterProtoReader.init(&[_]u8{});
    }
    pub fn getRemote(self: *const AnimationAdapterProtoReader) gremlin.Error!RemoteAnimationAdapterWrapperProtoReader {
        if (self._remote_buf) |buf| {
            return try RemoteAnimationAdapterWrapperProtoReader.init(buf);
        }
        return try RemoteAnimationAdapterWrapperProtoReader.init(&[_]u8{});
    }
};
const RemoteAnimationAdapterWrapperProtoWire = struct {
    const TARGET_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const RemoteAnimationAdapterWrapperProto = struct {
    // fields
    target: ?remote_animation_target.RemoteAnimationTargetProto = null,
    pub fn calcProtobufSize(self: *const RemoteAnimationAdapterWrapperProto) usize {
        var res: usize = 0;
        if (self.target) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(RemoteAnimationAdapterWrapperProtoWire.TARGET_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const RemoteAnimationAdapterWrapperProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const RemoteAnimationAdapterWrapperProto, target: *gremlin.Writer) void {
        if (self.target) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(RemoteAnimationAdapterWrapperProtoWire.TARGET_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const RemoteAnimationAdapterWrapperProtoReader = struct {
    buf: gremlin.Reader,
    _target_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!RemoteAnimationAdapterWrapperProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = RemoteAnimationAdapterWrapperProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                RemoteAnimationAdapterWrapperProtoWire.TARGET_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._target_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getTarget(self: *const RemoteAnimationAdapterWrapperProtoReader) gremlin.Error!remote_animation_target.RemoteAnimationTargetProtoReader {
        if (self._target_buf) |buf| {
            return try remote_animation_target.RemoteAnimationTargetProtoReader.init(buf);
        }
        return try remote_animation_target.RemoteAnimationTargetProtoReader.init(&[_]u8{});
    }
};
const LocalAnimationAdapterProtoWire = struct {
    const ANIMATION_SPEC_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const LocalAnimationAdapterProto = struct {
    // fields
    animation_spec: ?AnimationSpecProto = null,
    pub fn calcProtobufSize(self: *const LocalAnimationAdapterProto) usize {
        var res: usize = 0;
        if (self.animation_spec) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LocalAnimationAdapterProtoWire.ANIMATION_SPEC_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const LocalAnimationAdapterProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const LocalAnimationAdapterProto, target: *gremlin.Writer) void {
        if (self.animation_spec) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LocalAnimationAdapterProtoWire.ANIMATION_SPEC_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const LocalAnimationAdapterProtoReader = struct {
    buf: gremlin.Reader,
    _animation_spec_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!LocalAnimationAdapterProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = LocalAnimationAdapterProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                LocalAnimationAdapterProtoWire.ANIMATION_SPEC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._animation_spec_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getAnimationSpec(self: *const LocalAnimationAdapterProtoReader) gremlin.Error!AnimationSpecProtoReader {
        if (self._animation_spec_buf) |buf| {
            return try AnimationSpecProtoReader.init(buf);
        }
        return try AnimationSpecProtoReader.init(&[_]u8{});
    }
};
const AnimationSpecProtoWire = struct {
    const WINDOW_WIRE: gremlin.ProtoWireNumber = 1;
    const MOVE_WIRE: gremlin.ProtoWireNumber = 2;
    const ALPHA_WIRE: gremlin.ProtoWireNumber = 3;
    const ROTATE_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const AnimationSpecProto = struct {
    // fields
    window: ?WindowAnimationSpecProto = null,
    move: ?MoveAnimationSpecProto = null,
    alpha: ?AlphaAnimationSpecProto = null,
    rotate: ?RotationAnimationSpecProto = null,
    pub fn calcProtobufSize(self: *const AnimationSpecProto) usize {
        var res: usize = 0;
        if (self.window) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AnimationSpecProtoWire.WINDOW_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.move) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AnimationSpecProtoWire.MOVE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.alpha) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AnimationSpecProtoWire.ALPHA_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.rotate) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AnimationSpecProtoWire.ROTATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const AnimationSpecProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AnimationSpecProto, target: *gremlin.Writer) void {
        if (self.window) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AnimationSpecProtoWire.WINDOW_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.move) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AnimationSpecProtoWire.MOVE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.alpha) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AnimationSpecProtoWire.ALPHA_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.rotate) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AnimationSpecProtoWire.ROTATE_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const AnimationSpecProtoReader = struct {
    buf: gremlin.Reader,
    _window_buf: ?[]const u8 = null,
    _move_buf: ?[]const u8 = null,
    _alpha_buf: ?[]const u8 = null,
    _rotate_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!AnimationSpecProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = AnimationSpecProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AnimationSpecProtoWire.WINDOW_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._window_buf = result.value;
                },
                AnimationSpecProtoWire.MOVE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._move_buf = result.value;
                },
                AnimationSpecProtoWire.ALPHA_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._alpha_buf = result.value;
                },
                AnimationSpecProtoWire.ROTATE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._rotate_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getWindow(self: *const AnimationSpecProtoReader) gremlin.Error!WindowAnimationSpecProtoReader {
        if (self._window_buf) |buf| {
            return try WindowAnimationSpecProtoReader.init(buf);
        }
        return try WindowAnimationSpecProtoReader.init(&[_]u8{});
    }
    pub fn getMove(self: *const AnimationSpecProtoReader) gremlin.Error!MoveAnimationSpecProtoReader {
        if (self._move_buf) |buf| {
            return try MoveAnimationSpecProtoReader.init(buf);
        }
        return try MoveAnimationSpecProtoReader.init(&[_]u8{});
    }
    pub fn getAlpha(self: *const AnimationSpecProtoReader) gremlin.Error!AlphaAnimationSpecProtoReader {
        if (self._alpha_buf) |buf| {
            return try AlphaAnimationSpecProtoReader.init(buf);
        }
        return try AlphaAnimationSpecProtoReader.init(&[_]u8{});
    }
    pub fn getRotate(self: *const AnimationSpecProtoReader) gremlin.Error!RotationAnimationSpecProtoReader {
        if (self._rotate_buf) |buf| {
            return try RotationAnimationSpecProtoReader.init(buf);
        }
        return try RotationAnimationSpecProtoReader.init(&[_]u8{});
    }
};
const WindowAnimationSpecProtoWire = struct {
    const ANIMATION_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const WindowAnimationSpecProto = struct {
    // fields
    animation: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const WindowAnimationSpecProto) usize {
        var res: usize = 0;
        if (self.animation) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowAnimationSpecProtoWire.ANIMATION_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const WindowAnimationSpecProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const WindowAnimationSpecProto, target: *gremlin.Writer) void {
        if (self.animation) |v| {
            if (v.len > 0) {
                target.appendBytes(WindowAnimationSpecProtoWire.ANIMATION_WIRE, v);
            }
        }
    }
};
pub const WindowAnimationSpecProtoReader = struct {
    buf: gremlin.Reader,
    _animation: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!WindowAnimationSpecProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = WindowAnimationSpecProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                WindowAnimationSpecProtoWire.ANIMATION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._animation = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getAnimation(self: *const WindowAnimationSpecProtoReader) []const u8 {
        return self._animation orelse &[_]u8{};
    }
};
const MoveAnimationSpecProtoWire = struct {
    const FROM_WIRE: gremlin.ProtoWireNumber = 1;
    const TO_WIRE: gremlin.ProtoWireNumber = 2;
    const DURATION_MS_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const MoveAnimationSpecProto = struct {
    // fields
    from: ?point.PointProto = null,
    to: ?point.PointProto = null,
    duration_ms: i64 = 0,
    pub fn calcProtobufSize(self: *const MoveAnimationSpecProto) usize {
        var res: usize = 0;
        if (self.from) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(MoveAnimationSpecProtoWire.FROM_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.to) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(MoveAnimationSpecProtoWire.TO_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.duration_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(MoveAnimationSpecProtoWire.DURATION_MS_WIRE) + gremlin.sizes.sizeI64(self.duration_ms);
        }
        return res;
    }
    pub fn encode(self: *const MoveAnimationSpecProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const MoveAnimationSpecProto, target: *gremlin.Writer) void {
        if (self.from) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(MoveAnimationSpecProtoWire.FROM_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.to) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(MoveAnimationSpecProtoWire.TO_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.duration_ms != 0) {
            target.appendInt64(MoveAnimationSpecProtoWire.DURATION_MS_WIRE, self.duration_ms);
        }
    }
};
pub const MoveAnimationSpecProtoReader = struct {
    buf: gremlin.Reader,
    _from_buf: ?[]const u8 = null,
    _to_buf: ?[]const u8 = null,
    _duration_ms: i64 = 0,
    pub fn init(src: []const u8) gremlin.Error!MoveAnimationSpecProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = MoveAnimationSpecProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                MoveAnimationSpecProtoWire.FROM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._from_buf = result.value;
                },
                MoveAnimationSpecProtoWire.TO_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._to_buf = result.value;
                },
                MoveAnimationSpecProtoWire.DURATION_MS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._duration_ms = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getFrom(self: *const MoveAnimationSpecProtoReader) gremlin.Error!point.PointProtoReader {
        if (self._from_buf) |buf| {
            return try point.PointProtoReader.init(buf);
        }
        return try point.PointProtoReader.init(&[_]u8{});
    }
    pub fn getTo(self: *const MoveAnimationSpecProtoReader) gremlin.Error!point.PointProtoReader {
        if (self._to_buf) |buf| {
            return try point.PointProtoReader.init(buf);
        }
        return try point.PointProtoReader.init(&[_]u8{});
    }
    pub inline fn getDurationMs(self: *const MoveAnimationSpecProtoReader) i64 {
        return self._duration_ms;
    }
};
const AlphaAnimationSpecProtoWire = struct {
    const FROM_WIRE: gremlin.ProtoWireNumber = 1;
    const TO_WIRE: gremlin.ProtoWireNumber = 2;
    const DURATION_MS_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const AlphaAnimationSpecProto = struct {
    // fields
    from: f32 = 0.0,
    to: f32 = 0.0,
    duration_ms: i64 = 0,
    pub fn calcProtobufSize(self: *const AlphaAnimationSpecProto) usize {
        var res: usize = 0;
        if (self.from != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AlphaAnimationSpecProtoWire.FROM_WIRE) + gremlin.sizes.sizeFloat(self.from);
        }
        if (self.to != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AlphaAnimationSpecProtoWire.TO_WIRE) + gremlin.sizes.sizeFloat(self.to);
        }
        if (self.duration_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(AlphaAnimationSpecProtoWire.DURATION_MS_WIRE) + gremlin.sizes.sizeI64(self.duration_ms);
        }
        return res;
    }
    pub fn encode(self: *const AlphaAnimationSpecProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AlphaAnimationSpecProto, target: *gremlin.Writer) void {
        if (self.from != 0.0) {
            target.appendFloat32(AlphaAnimationSpecProtoWire.FROM_WIRE, self.from);
        }
        if (self.to != 0.0) {
            target.appendFloat32(AlphaAnimationSpecProtoWire.TO_WIRE, self.to);
        }
        if (self.duration_ms != 0) {
            target.appendInt64(AlphaAnimationSpecProtoWire.DURATION_MS_WIRE, self.duration_ms);
        }
    }
};
pub const AlphaAnimationSpecProtoReader = struct {
    buf: gremlin.Reader,
    _from: f32 = 0.0,
    _to: f32 = 0.0,
    _duration_ms: i64 = 0,
    pub fn init(src: []const u8) gremlin.Error!AlphaAnimationSpecProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = AlphaAnimationSpecProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AlphaAnimationSpecProtoWire.FROM_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._from = result.value;
                },
                AlphaAnimationSpecProtoWire.TO_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._to = result.value;
                },
                AlphaAnimationSpecProtoWire.DURATION_MS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._duration_ms = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getFrom(self: *const AlphaAnimationSpecProtoReader) f32 {
        return self._from;
    }
    pub inline fn getTo(self: *const AlphaAnimationSpecProtoReader) f32 {
        return self._to;
    }
    pub inline fn getDurationMs(self: *const AlphaAnimationSpecProtoReader) i64 {
        return self._duration_ms;
    }
};
const RotationAnimationSpecProtoWire = struct {
    const START_LUMA_WIRE: gremlin.ProtoWireNumber = 1;
    const END_LUMA_WIRE: gremlin.ProtoWireNumber = 2;
    const DURATION_MS_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const RotationAnimationSpecProto = struct {
    // fields
    start_luma: f32 = 0.0,
    end_luma: f32 = 0.0,
    duration_ms: i64 = 0,
    pub fn calcProtobufSize(self: *const RotationAnimationSpecProto) usize {
        var res: usize = 0;
        if (self.start_luma != 0.0) {
            res += gremlin.sizes.sizeWireNumber(RotationAnimationSpecProtoWire.START_LUMA_WIRE) + gremlin.sizes.sizeFloat(self.start_luma);
        }
        if (self.end_luma != 0.0) {
            res += gremlin.sizes.sizeWireNumber(RotationAnimationSpecProtoWire.END_LUMA_WIRE) + gremlin.sizes.sizeFloat(self.end_luma);
        }
        if (self.duration_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(RotationAnimationSpecProtoWire.DURATION_MS_WIRE) + gremlin.sizes.sizeI64(self.duration_ms);
        }
        return res;
    }
    pub fn encode(self: *const RotationAnimationSpecProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const RotationAnimationSpecProto, target: *gremlin.Writer) void {
        if (self.start_luma != 0.0) {
            target.appendFloat32(RotationAnimationSpecProtoWire.START_LUMA_WIRE, self.start_luma);
        }
        if (self.end_luma != 0.0) {
            target.appendFloat32(RotationAnimationSpecProtoWire.END_LUMA_WIRE, self.end_luma);
        }
        if (self.duration_ms != 0) {
            target.appendInt64(RotationAnimationSpecProtoWire.DURATION_MS_WIRE, self.duration_ms);
        }
    }
};
pub const RotationAnimationSpecProtoReader = struct {
    buf: gremlin.Reader,
    _start_luma: f32 = 0.0,
    _end_luma: f32 = 0.0,
    _duration_ms: i64 = 0,
    pub fn init(src: []const u8) gremlin.Error!RotationAnimationSpecProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = RotationAnimationSpecProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                RotationAnimationSpecProtoWire.START_LUMA_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._start_luma = result.value;
                },
                RotationAnimationSpecProtoWire.END_LUMA_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._end_luma = result.value;
                },
                RotationAnimationSpecProtoWire.DURATION_MS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._duration_ms = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getStartLuma(self: *const RotationAnimationSpecProtoReader) f32 {
        return self._start_luma;
    }
    pub inline fn getEndLuma(self: *const RotationAnimationSpecProtoReader) f32 {
        return self._end_luma;
    }
    pub inline fn getDurationMs(self: *const RotationAnimationSpecProtoReader) i64 {
        return self._duration_ms;
    }
};
