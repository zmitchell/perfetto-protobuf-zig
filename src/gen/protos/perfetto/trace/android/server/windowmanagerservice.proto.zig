// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
const statusbarmanager = @import("src/gen/protos/perfetto/trace/android/app/statusbarmanager.proto.zig");
const surface = @import("src/gen/protos/perfetto/trace/android/view/surface.proto.zig");
const activityinfo = @import("src/gen/protos/perfetto/trace/android/content/activityinfo.proto.zig");
const enums = @import("src/gen/protos/perfetto/trace/android/view/enums.proto.zig");
const displayinfo = @import("src/gen/protos/perfetto/trace/android/view/displayinfo.proto.zig");
const rect = @import("src/gen/protos/perfetto/trace/android/graphics/rect.proto.zig");
const windowcontainerthumbnail = @import("windowcontainerthumbnail.proto.zig");
const windowlayoutparams = @import("src/gen/protos/perfetto/trace/android/view/windowlayoutparams.proto.zig");
const displaycutout = @import("src/gen/protos/perfetto/trace/android/view/displaycutout.proto.zig");
const insetssource = @import("src/gen/protos/perfetto/trace/android/view/insetssource.proto.zig");
const surfaceanimator = @import("surfaceanimator.proto.zig");
const surfacecontrol = @import("src/gen/protos/perfetto/trace/android/view/surfacecontrol.proto.zig");
const configuration = @import("src/gen/protos/perfetto/trace/android/content/configuration.proto.zig");
const insetssourcecontrol = @import("src/gen/protos/perfetto/trace/android/view/insetssourcecontrol.proto.zig");
// structs
const WindowManagerServiceDumpProtoWire = struct {
    const POLICY_WIRE: gremlin.ProtoWireNumber = 1;
    const ROOT_WINDOW_CONTAINER_WIRE: gremlin.ProtoWireNumber = 2;
    const FOCUSED_WINDOW_WIRE: gremlin.ProtoWireNumber = 3;
    const FOCUSED_APP_WIRE: gremlin.ProtoWireNumber = 4;
    const INPUT_METHOD_WINDOW_WIRE: gremlin.ProtoWireNumber = 5;
    const DISPLAY_FROZEN_WIRE: gremlin.ProtoWireNumber = 6;
    const ROTATION_WIRE: gremlin.ProtoWireNumber = 7;
    const LAST_ORIENTATION_WIRE: gremlin.ProtoWireNumber = 8;
    const FOCUSED_DISPLAY_ID_WIRE: gremlin.ProtoWireNumber = 9;
    const HARD_KEYBOARD_AVAILABLE_WIRE: gremlin.ProtoWireNumber = 10;
    const WINDOW_FRAMES_VALID_WIRE: gremlin.ProtoWireNumber = 11;
    const BACK_NAVIGATION_WIRE: gremlin.ProtoWireNumber = 12;
};
pub const WindowManagerServiceDumpProto = struct {
    // fields
    policy: ?WindowManagerPolicyProto = null,
    root_window_container: ?RootWindowContainerProto = null,
    focused_window: ?IdentifierProto = null,
    focused_app: ?[]const u8 = null,
    input_method_window: ?IdentifierProto = null,
    display_frozen: bool = false,
    rotation: i32 = 0,
    last_orientation: i32 = 0,
    focused_display_id: i32 = 0,
    hard_keyboard_available: bool = false,
    window_frames_valid: bool = false,
    back_navigation: ?BackNavigationProto = null,
    pub fn calcProtobufSize(self: *const WindowManagerServiceDumpProto) usize {
        var res: usize = 0;
        if (self.policy) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowManagerServiceDumpProtoWire.POLICY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.root_window_container) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowManagerServiceDumpProtoWire.ROOT_WINDOW_CONTAINER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.focused_window) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowManagerServiceDumpProtoWire.FOCUSED_WINDOW_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.focused_app) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowManagerServiceDumpProtoWire.FOCUSED_APP_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.input_method_window) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowManagerServiceDumpProtoWire.INPUT_METHOD_WINDOW_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.display_frozen != false) {
            res += gremlin.sizes.sizeWireNumber(WindowManagerServiceDumpProtoWire.DISPLAY_FROZEN_WIRE) + gremlin.sizes.sizeBool(self.display_frozen);
        }
        if (self.rotation != 0) {
            res += gremlin.sizes.sizeWireNumber(WindowManagerServiceDumpProtoWire.ROTATION_WIRE) + gremlin.sizes.sizeI32(self.rotation);
        }
        if (self.last_orientation != 0) {
            res += gremlin.sizes.sizeWireNumber(WindowManagerServiceDumpProtoWire.LAST_ORIENTATION_WIRE) + gremlin.sizes.sizeI32(self.last_orientation);
        }
        if (self.focused_display_id != 0) {
            res += gremlin.sizes.sizeWireNumber(WindowManagerServiceDumpProtoWire.FOCUSED_DISPLAY_ID_WIRE) + gremlin.sizes.sizeI32(self.focused_display_id);
        }
        if (self.hard_keyboard_available != false) {
            res += gremlin.sizes.sizeWireNumber(WindowManagerServiceDumpProtoWire.HARD_KEYBOARD_AVAILABLE_WIRE) + gremlin.sizes.sizeBool(self.hard_keyboard_available);
        }
        if (self.window_frames_valid != false) {
            res += gremlin.sizes.sizeWireNumber(WindowManagerServiceDumpProtoWire.WINDOW_FRAMES_VALID_WIRE) + gremlin.sizes.sizeBool(self.window_frames_valid);
        }
        if (self.back_navigation) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowManagerServiceDumpProtoWire.BACK_NAVIGATION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const WindowManagerServiceDumpProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const WindowManagerServiceDumpProto, target: *gremlin.Writer) void {
        if (self.policy) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowManagerServiceDumpProtoWire.POLICY_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.root_window_container) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowManagerServiceDumpProtoWire.ROOT_WINDOW_CONTAINER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.focused_window) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowManagerServiceDumpProtoWire.FOCUSED_WINDOW_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.focused_app) |v| {
            if (v.len > 0) {
                target.appendBytes(WindowManagerServiceDumpProtoWire.FOCUSED_APP_WIRE, v);
            }
        }
        if (self.input_method_window) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowManagerServiceDumpProtoWire.INPUT_METHOD_WINDOW_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.display_frozen != false) {
            target.appendBool(WindowManagerServiceDumpProtoWire.DISPLAY_FROZEN_WIRE, self.display_frozen);
        }
        if (self.rotation != 0) {
            target.appendInt32(WindowManagerServiceDumpProtoWire.ROTATION_WIRE, self.rotation);
        }
        if (self.last_orientation != 0) {
            target.appendInt32(WindowManagerServiceDumpProtoWire.LAST_ORIENTATION_WIRE, self.last_orientation);
        }
        if (self.focused_display_id != 0) {
            target.appendInt32(WindowManagerServiceDumpProtoWire.FOCUSED_DISPLAY_ID_WIRE, self.focused_display_id);
        }
        if (self.hard_keyboard_available != false) {
            target.appendBool(WindowManagerServiceDumpProtoWire.HARD_KEYBOARD_AVAILABLE_WIRE, self.hard_keyboard_available);
        }
        if (self.window_frames_valid != false) {
            target.appendBool(WindowManagerServiceDumpProtoWire.WINDOW_FRAMES_VALID_WIRE, self.window_frames_valid);
        }
        if (self.back_navigation) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowManagerServiceDumpProtoWire.BACK_NAVIGATION_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const WindowManagerServiceDumpProtoReader = struct {
    buf: gremlin.Reader,
    _policy_buf: ?[]const u8 = null,
    _root_window_container_buf: ?[]const u8 = null,
    _focused_window_buf: ?[]const u8 = null,
    _focused_app: ?[]const u8 = null,
    _input_method_window_buf: ?[]const u8 = null,
    _display_frozen: bool = false,
    _rotation: i32 = 0,
    _last_orientation: i32 = 0,
    _focused_display_id: i32 = 0,
    _hard_keyboard_available: bool = false,
    _window_frames_valid: bool = false,
    _back_navigation_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!WindowManagerServiceDumpProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = WindowManagerServiceDumpProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                WindowManagerServiceDumpProtoWire.POLICY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._policy_buf = result.value;
                },
                WindowManagerServiceDumpProtoWire.ROOT_WINDOW_CONTAINER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._root_window_container_buf = result.value;
                },
                WindowManagerServiceDumpProtoWire.FOCUSED_WINDOW_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._focused_window_buf = result.value;
                },
                WindowManagerServiceDumpProtoWire.FOCUSED_APP_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._focused_app = result.value;
                },
                WindowManagerServiceDumpProtoWire.INPUT_METHOD_WINDOW_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._input_method_window_buf = result.value;
                },
                WindowManagerServiceDumpProtoWire.DISPLAY_FROZEN_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._display_frozen = result.value;
                },
                WindowManagerServiceDumpProtoWire.ROTATION_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._rotation = result.value;
                },
                WindowManagerServiceDumpProtoWire.LAST_ORIENTATION_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._last_orientation = result.value;
                },
                WindowManagerServiceDumpProtoWire.FOCUSED_DISPLAY_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._focused_display_id = result.value;
                },
                WindowManagerServiceDumpProtoWire.HARD_KEYBOARD_AVAILABLE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._hard_keyboard_available = result.value;
                },
                WindowManagerServiceDumpProtoWire.WINDOW_FRAMES_VALID_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._window_frames_valid = result.value;
                },
                WindowManagerServiceDumpProtoWire.BACK_NAVIGATION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._back_navigation_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getPolicy(self: *const WindowManagerServiceDumpProtoReader) gremlin.Error!WindowManagerPolicyProtoReader {
        if (self._policy_buf) |buf| {
            return try WindowManagerPolicyProtoReader.init(buf);
        }
        return try WindowManagerPolicyProtoReader.init(&[_]u8{});
    }
    pub fn getRootWindowContainer(self: *const WindowManagerServiceDumpProtoReader) gremlin.Error!RootWindowContainerProtoReader {
        if (self._root_window_container_buf) |buf| {
            return try RootWindowContainerProtoReader.init(buf);
        }
        return try RootWindowContainerProtoReader.init(&[_]u8{});
    }
    pub fn getFocusedWindow(self: *const WindowManagerServiceDumpProtoReader) gremlin.Error!IdentifierProtoReader {
        if (self._focused_window_buf) |buf| {
            return try IdentifierProtoReader.init(buf);
        }
        return try IdentifierProtoReader.init(&[_]u8{});
    }
    pub inline fn getFocusedApp(self: *const WindowManagerServiceDumpProtoReader) []const u8 {
        return self._focused_app orelse &[_]u8{};
    }
    pub fn getInputMethodWindow(self: *const WindowManagerServiceDumpProtoReader) gremlin.Error!IdentifierProtoReader {
        if (self._input_method_window_buf) |buf| {
            return try IdentifierProtoReader.init(buf);
        }
        return try IdentifierProtoReader.init(&[_]u8{});
    }
    pub inline fn getDisplayFrozen(self: *const WindowManagerServiceDumpProtoReader) bool {
        return self._display_frozen;
    }
    pub inline fn getRotation(self: *const WindowManagerServiceDumpProtoReader) i32 {
        return self._rotation;
    }
    pub inline fn getLastOrientation(self: *const WindowManagerServiceDumpProtoReader) i32 {
        return self._last_orientation;
    }
    pub inline fn getFocusedDisplayId(self: *const WindowManagerServiceDumpProtoReader) i32 {
        return self._focused_display_id;
    }
    pub inline fn getHardKeyboardAvailable(self: *const WindowManagerServiceDumpProtoReader) bool {
        return self._hard_keyboard_available;
    }
    pub inline fn getWindowFramesValid(self: *const WindowManagerServiceDumpProtoReader) bool {
        return self._window_frames_valid;
    }
    pub fn getBackNavigation(self: *const WindowManagerServiceDumpProtoReader) gremlin.Error!BackNavigationProtoReader {
        if (self._back_navigation_buf) |buf| {
            return try BackNavigationProtoReader.init(buf);
        }
        return try BackNavigationProtoReader.init(&[_]u8{});
    }
};
const RootWindowContainerProtoWire = struct {
    const WINDOW_CONTAINER_WIRE: gremlin.ProtoWireNumber = 1;
    const DISPLAYS_WIRE: gremlin.ProtoWireNumber = 2;
    const WINDOWS_WIRE: gremlin.ProtoWireNumber = 4;
    const KEYGUARD_CONTROLLER_WIRE: gremlin.ProtoWireNumber = 5;
    const IS_HOME_RECENTS_COMPONENT_WIRE: gremlin.ProtoWireNumber = 6;
    const PENDING_ACTIVITIES_WIRE: gremlin.ProtoWireNumber = 7;
    const DEFAULT_MIN_SIZE_RESIZABLE_TASK_WIRE: gremlin.ProtoWireNumber = 8;
};
pub const RootWindowContainerProto = struct {
    // fields
    window_container: ?WindowContainerProto = null,
    displays: ?[]const ?DisplayContentProto = null,
    windows: ?[]const ?WindowStateProto = null,
    keyguard_controller: ?KeyguardControllerProto = null,
    is_home_recents_component: bool = false,
    pending_activities: ?[]const ?IdentifierProto = null,
    default_min_size_resizable_task: i32 = 0,
    pub fn calcProtobufSize(self: *const RootWindowContainerProto) usize {
        var res: usize = 0;
        if (self.window_container) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(RootWindowContainerProtoWire.WINDOW_CONTAINER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.displays) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(RootWindowContainerProtoWire.DISPLAYS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.windows) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(RootWindowContainerProtoWire.WINDOWS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.keyguard_controller) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(RootWindowContainerProtoWire.KEYGUARD_CONTROLLER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.is_home_recents_component != false) {
            res += gremlin.sizes.sizeWireNumber(RootWindowContainerProtoWire.IS_HOME_RECENTS_COMPONENT_WIRE) + gremlin.sizes.sizeBool(self.is_home_recents_component);
        }
        if (self.pending_activities) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(RootWindowContainerProtoWire.PENDING_ACTIVITIES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.default_min_size_resizable_task != 0) {
            res += gremlin.sizes.sizeWireNumber(RootWindowContainerProtoWire.DEFAULT_MIN_SIZE_RESIZABLE_TASK_WIRE) + gremlin.sizes.sizeI32(self.default_min_size_resizable_task);
        }
        return res;
    }
    pub fn encode(self: *const RootWindowContainerProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const RootWindowContainerProto, target: *gremlin.Writer) void {
        if (self.window_container) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(RootWindowContainerProtoWire.WINDOW_CONTAINER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.displays) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(RootWindowContainerProtoWire.DISPLAYS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(RootWindowContainerProtoWire.DISPLAYS_WIRE, 0);
                }
            }
        }
        if (self.windows) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(RootWindowContainerProtoWire.WINDOWS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(RootWindowContainerProtoWire.WINDOWS_WIRE, 0);
                }
            }
        }
        if (self.keyguard_controller) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(RootWindowContainerProtoWire.KEYGUARD_CONTROLLER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.is_home_recents_component != false) {
            target.appendBool(RootWindowContainerProtoWire.IS_HOME_RECENTS_COMPONENT_WIRE, self.is_home_recents_component);
        }
        if (self.pending_activities) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(RootWindowContainerProtoWire.PENDING_ACTIVITIES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(RootWindowContainerProtoWire.PENDING_ACTIVITIES_WIRE, 0);
                }
            }
        }
        if (self.default_min_size_resizable_task != 0) {
            target.appendInt32(RootWindowContainerProtoWire.DEFAULT_MIN_SIZE_RESIZABLE_TASK_WIRE, self.default_min_size_resizable_task);
        }
    }
};
pub const RootWindowContainerProtoReader = struct {
    buf: gremlin.Reader,
    _window_container_buf: ?[]const u8 = null,
    _displays_offset: ?usize = null,
    _displays_last_offset: ?usize = null,
    _displays_cnt: usize = 0,
    _windows_offset: ?usize = null,
    _windows_last_offset: ?usize = null,
    _windows_cnt: usize = 0,
    _keyguard_controller_buf: ?[]const u8 = null,
    _is_home_recents_component: bool = false,
    _pending_activities_offset: ?usize = null,
    _pending_activities_last_offset: ?usize = null,
    _pending_activities_cnt: usize = 0,
    _default_min_size_resizable_task: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!RootWindowContainerProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = RootWindowContainerProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                RootWindowContainerProtoWire.WINDOW_CONTAINER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._window_container_buf = result.value;
                },
                RootWindowContainerProtoWire.DISPLAYS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._displays_offset == null) {
                        res._displays_offset = offset - result.size;
                    }
                    res._displays_last_offset = offset;
                    res._displays_cnt += 1;
                },
                RootWindowContainerProtoWire.WINDOWS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._windows_offset == null) {
                        res._windows_offset = offset - result.size;
                    }
                    res._windows_last_offset = offset;
                    res._windows_cnt += 1;
                },
                RootWindowContainerProtoWire.KEYGUARD_CONTROLLER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._keyguard_controller_buf = result.value;
                },
                RootWindowContainerProtoWire.IS_HOME_RECENTS_COMPONENT_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_home_recents_component = result.value;
                },
                RootWindowContainerProtoWire.PENDING_ACTIVITIES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._pending_activities_offset == null) {
                        res._pending_activities_offset = offset - result.size;
                    }
                    res._pending_activities_last_offset = offset;
                    res._pending_activities_cnt += 1;
                },
                RootWindowContainerProtoWire.DEFAULT_MIN_SIZE_RESIZABLE_TASK_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._default_min_size_resizable_task = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getWindowContainer(self: *const RootWindowContainerProtoReader) gremlin.Error!WindowContainerProtoReader {
        if (self._window_container_buf) |buf| {
            return try WindowContainerProtoReader.init(buf);
        }
        return try WindowContainerProtoReader.init(&[_]u8{});
    }
    pub fn displaysCount(self: *const RootWindowContainerProtoReader) usize {
        return self._displays_cnt;
    }
    pub fn displaysNext(self: *RootWindowContainerProtoReader) ?DisplayContentProtoReader {
        if (self._displays_offset == null) return null;
        const current_offset = self._displays_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = DisplayContentProtoReader.init(result.value) catch return null;
        if (self._displays_last_offset != null and current_offset >= self._displays_last_offset.?) {
            self._displays_offset = null;
            return msg;
        }
        if (self._displays_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._displays_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == RootWindowContainerProtoWire.DISPLAYS_WIRE) {
                self._displays_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._displays_offset = null;
        return msg;
    }
    pub fn windowsCount(self: *const RootWindowContainerProtoReader) usize {
        return self._windows_cnt;
    }
    pub fn windowsNext(self: *RootWindowContainerProtoReader) ?WindowStateProtoReader {
        if (self._windows_offset == null) return null;
        const current_offset = self._windows_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = WindowStateProtoReader.init(result.value) catch return null;
        if (self._windows_last_offset != null and current_offset >= self._windows_last_offset.?) {
            self._windows_offset = null;
            return msg;
        }
        if (self._windows_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._windows_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == RootWindowContainerProtoWire.WINDOWS_WIRE) {
                self._windows_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._windows_offset = null;
        return msg;
    }
    pub fn getKeyguardController(self: *const RootWindowContainerProtoReader) gremlin.Error!KeyguardControllerProtoReader {
        if (self._keyguard_controller_buf) |buf| {
            return try KeyguardControllerProtoReader.init(buf);
        }
        return try KeyguardControllerProtoReader.init(&[_]u8{});
    }
    pub inline fn getIsHomeRecentsComponent(self: *const RootWindowContainerProtoReader) bool {
        return self._is_home_recents_component;
    }
    pub fn pendingActivitiesCount(self: *const RootWindowContainerProtoReader) usize {
        return self._pending_activities_cnt;
    }
    pub fn pendingActivitiesNext(self: *RootWindowContainerProtoReader) ?IdentifierProtoReader {
        if (self._pending_activities_offset == null) return null;
        const current_offset = self._pending_activities_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = IdentifierProtoReader.init(result.value) catch return null;
        if (self._pending_activities_last_offset != null and current_offset >= self._pending_activities_last_offset.?) {
            self._pending_activities_offset = null;
            return msg;
        }
        if (self._pending_activities_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._pending_activities_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == RootWindowContainerProtoWire.PENDING_ACTIVITIES_WIRE) {
                self._pending_activities_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._pending_activities_offset = null;
        return msg;
    }
    pub inline fn getDefaultMinSizeResizableTask(self: *const RootWindowContainerProtoReader) i32 {
        return self._default_min_size_resizable_task;
    }
};
const BarControllerProtoWire = struct {
    const STATE_WIRE: gremlin.ProtoWireNumber = 1;
    const TRANSIENT_STATE_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const BarControllerProto = struct {
    // fields
    state: statusbarmanager.StatusBarManagerProto.WindowState = @enumFromInt(0),
    transient_state: statusbarmanager.StatusBarManagerProto.TransientWindowState = @enumFromInt(0),
    pub fn calcProtobufSize(self: *const BarControllerProto) usize {
        var res: usize = 0;
        if (@intFromEnum(self.state) != 0) {
            res += gremlin.sizes.sizeWireNumber(BarControllerProtoWire.STATE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.state));
        }
        if (@intFromEnum(self.transient_state) != 0) {
            res += gremlin.sizes.sizeWireNumber(BarControllerProtoWire.TRANSIENT_STATE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.transient_state));
        }
        return res;
    }
    pub fn encode(self: *const BarControllerProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const BarControllerProto, target: *gremlin.Writer) void {
        if (@intFromEnum(self.state) != 0) {
            target.appendInt32(BarControllerProtoWire.STATE_WIRE, @intFromEnum(self.state));
        }
        if (@intFromEnum(self.transient_state) != 0) {
            target.appendInt32(BarControllerProtoWire.TRANSIENT_STATE_WIRE, @intFromEnum(self.transient_state));
        }
    }
};
pub const BarControllerProtoReader = struct {
    buf: gremlin.Reader,
    _state: statusbarmanager.StatusBarManagerProto.WindowState = @enumFromInt(0),
    _transient_state: statusbarmanager.StatusBarManagerProto.TransientWindowState = @enumFromInt(0),
    pub fn init(src: []const u8) gremlin.Error!BarControllerProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = BarControllerProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                BarControllerProtoWire.STATE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._state = @enumFromInt(result.value);
                },
                BarControllerProtoWire.TRANSIENT_STATE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._transient_state = @enumFromInt(result.value);
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getState(self: *const BarControllerProtoReader) statusbarmanager.StatusBarManagerProto.WindowState {
        return self._state;
    }
    pub inline fn getTransientState(self: *const BarControllerProtoReader) statusbarmanager.StatusBarManagerProto.TransientWindowState {
        return self._transient_state;
    }
};
const WindowOrientationListenerProtoWire = struct {
    const ENABLED_WIRE: gremlin.ProtoWireNumber = 1;
    const ROTATION_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const WindowOrientationListenerProto = struct {
    // fields
    enabled: bool = false,
    rotation: surface.SurfaceProto.Rotation = @enumFromInt(0),
    pub fn calcProtobufSize(self: *const WindowOrientationListenerProto) usize {
        var res: usize = 0;
        if (self.enabled != false) {
            res += gremlin.sizes.sizeWireNumber(WindowOrientationListenerProtoWire.ENABLED_WIRE) + gremlin.sizes.sizeBool(self.enabled);
        }
        if (@intFromEnum(self.rotation) != 0) {
            res += gremlin.sizes.sizeWireNumber(WindowOrientationListenerProtoWire.ROTATION_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.rotation));
        }
        return res;
    }
    pub fn encode(self: *const WindowOrientationListenerProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const WindowOrientationListenerProto, target: *gremlin.Writer) void {
        if (self.enabled != false) {
            target.appendBool(WindowOrientationListenerProtoWire.ENABLED_WIRE, self.enabled);
        }
        if (@intFromEnum(self.rotation) != 0) {
            target.appendInt32(WindowOrientationListenerProtoWire.ROTATION_WIRE, @intFromEnum(self.rotation));
        }
    }
};
pub const WindowOrientationListenerProtoReader = struct {
    buf: gremlin.Reader,
    _enabled: bool = false,
    _rotation: surface.SurfaceProto.Rotation = @enumFromInt(0),
    pub fn init(src: []const u8) gremlin.Error!WindowOrientationListenerProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = WindowOrientationListenerProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                WindowOrientationListenerProtoWire.ENABLED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._enabled = result.value;
                },
                WindowOrientationListenerProtoWire.ROTATION_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._rotation = @enumFromInt(result.value);
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getEnabled(self: *const WindowOrientationListenerProtoReader) bool {
        return self._enabled;
    }
    pub inline fn getRotation(self: *const WindowOrientationListenerProtoReader) surface.SurfaceProto.Rotation {
        return self._rotation;
    }
};
const KeyguardServiceDelegateProtoWire = struct {
    const SHOWING_WIRE: gremlin.ProtoWireNumber = 1;
    const OCCLUDED_WIRE: gremlin.ProtoWireNumber = 2;
    const SECURE_WIRE: gremlin.ProtoWireNumber = 3;
    const SCREEN_STATE_WIRE: gremlin.ProtoWireNumber = 4;
    const INTERACTIVE_STATE_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const KeyguardServiceDelegateProto = struct {
    // nested enums
    pub const ScreenState = enum(i32) {
        SCREEN_STATE_OFF = 0,
        SCREEN_STATE_TURNING_ON = 1,
        SCREEN_STATE_ON = 2,
        SCREEN_STATE_TURNING_OFF = 3,
    };
    pub const InteractiveState = enum(i32) {
        INTERACTIVE_STATE_SLEEP = 0,
        INTERACTIVE_STATE_WAKING = 1,
        INTERACTIVE_STATE_AWAKE = 2,
        INTERACTIVE_STATE_GOING_TO_SLEEP = 3,
    };
    // fields
    showing: bool = false,
    occluded: bool = false,
    secure: bool = false,
    screen_state: KeyguardServiceDelegateProto.ScreenState = @enumFromInt(0),
    interactive_state: KeyguardServiceDelegateProto.InteractiveState = @enumFromInt(0),
    pub fn calcProtobufSize(self: *const KeyguardServiceDelegateProto) usize {
        var res: usize = 0;
        if (self.showing != false) {
            res += gremlin.sizes.sizeWireNumber(KeyguardServiceDelegateProtoWire.SHOWING_WIRE) + gremlin.sizes.sizeBool(self.showing);
        }
        if (self.occluded != false) {
            res += gremlin.sizes.sizeWireNumber(KeyguardServiceDelegateProtoWire.OCCLUDED_WIRE) + gremlin.sizes.sizeBool(self.occluded);
        }
        if (self.secure != false) {
            res += gremlin.sizes.sizeWireNumber(KeyguardServiceDelegateProtoWire.SECURE_WIRE) + gremlin.sizes.sizeBool(self.secure);
        }
        if (@intFromEnum(self.screen_state) != 0) {
            res += gremlin.sizes.sizeWireNumber(KeyguardServiceDelegateProtoWire.SCREEN_STATE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.screen_state));
        }
        if (@intFromEnum(self.interactive_state) != 0) {
            res += gremlin.sizes.sizeWireNumber(KeyguardServiceDelegateProtoWire.INTERACTIVE_STATE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.interactive_state));
        }
        return res;
    }
    pub fn encode(self: *const KeyguardServiceDelegateProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const KeyguardServiceDelegateProto, target: *gremlin.Writer) void {
        if (self.showing != false) {
            target.appendBool(KeyguardServiceDelegateProtoWire.SHOWING_WIRE, self.showing);
        }
        if (self.occluded != false) {
            target.appendBool(KeyguardServiceDelegateProtoWire.OCCLUDED_WIRE, self.occluded);
        }
        if (self.secure != false) {
            target.appendBool(KeyguardServiceDelegateProtoWire.SECURE_WIRE, self.secure);
        }
        if (@intFromEnum(self.screen_state) != 0) {
            target.appendInt32(KeyguardServiceDelegateProtoWire.SCREEN_STATE_WIRE, @intFromEnum(self.screen_state));
        }
        if (@intFromEnum(self.interactive_state) != 0) {
            target.appendInt32(KeyguardServiceDelegateProtoWire.INTERACTIVE_STATE_WIRE, @intFromEnum(self.interactive_state));
        }
    }
};
pub const KeyguardServiceDelegateProtoReader = struct {
    buf: gremlin.Reader,
    _showing: bool = false,
    _occluded: bool = false,
    _secure: bool = false,
    _screen_state: KeyguardServiceDelegateProto.ScreenState = @enumFromInt(0),
    _interactive_state: KeyguardServiceDelegateProto.InteractiveState = @enumFromInt(0),
    pub fn init(src: []const u8) gremlin.Error!KeyguardServiceDelegateProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = KeyguardServiceDelegateProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                KeyguardServiceDelegateProtoWire.SHOWING_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._showing = result.value;
                },
                KeyguardServiceDelegateProtoWire.OCCLUDED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._occluded = result.value;
                },
                KeyguardServiceDelegateProtoWire.SECURE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._secure = result.value;
                },
                KeyguardServiceDelegateProtoWire.SCREEN_STATE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._screen_state = @enumFromInt(result.value);
                },
                KeyguardServiceDelegateProtoWire.INTERACTIVE_STATE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._interactive_state = @enumFromInt(result.value);
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getShowing(self: *const KeyguardServiceDelegateProtoReader) bool {
        return self._showing;
    }
    pub inline fn getOccluded(self: *const KeyguardServiceDelegateProtoReader) bool {
        return self._occluded;
    }
    pub inline fn getSecure(self: *const KeyguardServiceDelegateProtoReader) bool {
        return self._secure;
    }
    pub inline fn getScreenState(self: *const KeyguardServiceDelegateProtoReader) KeyguardServiceDelegateProto.ScreenState {
        return self._screen_state;
    }
    pub inline fn getInteractiveState(self: *const KeyguardServiceDelegateProtoReader) KeyguardServiceDelegateProto.InteractiveState {
        return self._interactive_state;
    }
};
const KeyguardControllerProtoWire = struct {
    const KEYGUARD_SHOWING_WIRE: gremlin.ProtoWireNumber = 1;
    const KEYGUARD_OCCLUDED_STATES_WIRE: gremlin.ProtoWireNumber = 2;
    const AOD_SHOWING_WIRE: gremlin.ProtoWireNumber = 3;
    const KEYGUARD_PER_DISPLAY_WIRE: gremlin.ProtoWireNumber = 4;
    const KEYGUARD_GOING_AWAY_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const KeyguardControllerProto = struct {
    // fields
    keyguard_showing: bool = false,
    keyguard_occluded_states: ?[]const ?KeyguardOccludedProto = null,
    aod_showing: bool = false,
    keyguard_per_display: ?[]const ?KeyguardPerDisplayProto = null,
    keyguard_going_away: bool = false,
    pub fn calcProtobufSize(self: *const KeyguardControllerProto) usize {
        var res: usize = 0;
        if (self.keyguard_showing != false) {
            res += gremlin.sizes.sizeWireNumber(KeyguardControllerProtoWire.KEYGUARD_SHOWING_WIRE) + gremlin.sizes.sizeBool(self.keyguard_showing);
        }
        if (self.keyguard_occluded_states) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(KeyguardControllerProtoWire.KEYGUARD_OCCLUDED_STATES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.aod_showing != false) {
            res += gremlin.sizes.sizeWireNumber(KeyguardControllerProtoWire.AOD_SHOWING_WIRE) + gremlin.sizes.sizeBool(self.aod_showing);
        }
        if (self.keyguard_per_display) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(KeyguardControllerProtoWire.KEYGUARD_PER_DISPLAY_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.keyguard_going_away != false) {
            res += gremlin.sizes.sizeWireNumber(KeyguardControllerProtoWire.KEYGUARD_GOING_AWAY_WIRE) + gremlin.sizes.sizeBool(self.keyguard_going_away);
        }
        return res;
    }
    pub fn encode(self: *const KeyguardControllerProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const KeyguardControllerProto, target: *gremlin.Writer) void {
        if (self.keyguard_showing != false) {
            target.appendBool(KeyguardControllerProtoWire.KEYGUARD_SHOWING_WIRE, self.keyguard_showing);
        }
        if (self.keyguard_occluded_states) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(KeyguardControllerProtoWire.KEYGUARD_OCCLUDED_STATES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(KeyguardControllerProtoWire.KEYGUARD_OCCLUDED_STATES_WIRE, 0);
                }
            }
        }
        if (self.aod_showing != false) {
            target.appendBool(KeyguardControllerProtoWire.AOD_SHOWING_WIRE, self.aod_showing);
        }
        if (self.keyguard_per_display) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(KeyguardControllerProtoWire.KEYGUARD_PER_DISPLAY_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(KeyguardControllerProtoWire.KEYGUARD_PER_DISPLAY_WIRE, 0);
                }
            }
        }
        if (self.keyguard_going_away != false) {
            target.appendBool(KeyguardControllerProtoWire.KEYGUARD_GOING_AWAY_WIRE, self.keyguard_going_away);
        }
    }
};
pub const KeyguardControllerProtoReader = struct {
    buf: gremlin.Reader,
    _keyguard_showing: bool = false,
    _keyguard_occluded_states_offset: ?usize = null,
    _keyguard_occluded_states_last_offset: ?usize = null,
    _keyguard_occluded_states_cnt: usize = 0,
    _aod_showing: bool = false,
    _keyguard_per_display_offset: ?usize = null,
    _keyguard_per_display_last_offset: ?usize = null,
    _keyguard_per_display_cnt: usize = 0,
    _keyguard_going_away: bool = false,
    pub fn init(src: []const u8) gremlin.Error!KeyguardControllerProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = KeyguardControllerProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                KeyguardControllerProtoWire.KEYGUARD_SHOWING_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._keyguard_showing = result.value;
                },
                KeyguardControllerProtoWire.KEYGUARD_OCCLUDED_STATES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._keyguard_occluded_states_offset == null) {
                        res._keyguard_occluded_states_offset = offset - result.size;
                    }
                    res._keyguard_occluded_states_last_offset = offset;
                    res._keyguard_occluded_states_cnt += 1;
                },
                KeyguardControllerProtoWire.AOD_SHOWING_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._aod_showing = result.value;
                },
                KeyguardControllerProtoWire.KEYGUARD_PER_DISPLAY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._keyguard_per_display_offset == null) {
                        res._keyguard_per_display_offset = offset - result.size;
                    }
                    res._keyguard_per_display_last_offset = offset;
                    res._keyguard_per_display_cnt += 1;
                },
                KeyguardControllerProtoWire.KEYGUARD_GOING_AWAY_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._keyguard_going_away = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getKeyguardShowing(self: *const KeyguardControllerProtoReader) bool {
        return self._keyguard_showing;
    }
    pub fn keyguardOccludedStatesCount(self: *const KeyguardControllerProtoReader) usize {
        return self._keyguard_occluded_states_cnt;
    }
    pub fn keyguardOccludedStatesNext(self: *KeyguardControllerProtoReader) ?KeyguardOccludedProtoReader {
        if (self._keyguard_occluded_states_offset == null) return null;
        const current_offset = self._keyguard_occluded_states_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = KeyguardOccludedProtoReader.init(result.value) catch return null;
        if (self._keyguard_occluded_states_last_offset != null and current_offset >= self._keyguard_occluded_states_last_offset.?) {
            self._keyguard_occluded_states_offset = null;
            return msg;
        }
        if (self._keyguard_occluded_states_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._keyguard_occluded_states_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == KeyguardControllerProtoWire.KEYGUARD_OCCLUDED_STATES_WIRE) {
                self._keyguard_occluded_states_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._keyguard_occluded_states_offset = null;
        return msg;
    }
    pub inline fn getAodShowing(self: *const KeyguardControllerProtoReader) bool {
        return self._aod_showing;
    }
    pub fn keyguardPerDisplayCount(self: *const KeyguardControllerProtoReader) usize {
        return self._keyguard_per_display_cnt;
    }
    pub fn keyguardPerDisplayNext(self: *KeyguardControllerProtoReader) ?KeyguardPerDisplayProtoReader {
        if (self._keyguard_per_display_offset == null) return null;
        const current_offset = self._keyguard_per_display_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = KeyguardPerDisplayProtoReader.init(result.value) catch return null;
        if (self._keyguard_per_display_last_offset != null and current_offset >= self._keyguard_per_display_last_offset.?) {
            self._keyguard_per_display_offset = null;
            return msg;
        }
        if (self._keyguard_per_display_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._keyguard_per_display_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == KeyguardControllerProtoWire.KEYGUARD_PER_DISPLAY_WIRE) {
                self._keyguard_per_display_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._keyguard_per_display_offset = null;
        return msg;
    }
    pub inline fn getKeyguardGoingAway(self: *const KeyguardControllerProtoReader) bool {
        return self._keyguard_going_away;
    }
};
const KeyguardOccludedProtoWire = struct {
    const DISPLAY_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const KEYGUARD_OCCLUDED_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const KeyguardOccludedProto = struct {
    // fields
    display_id: i32 = 0,
    keyguard_occluded: bool = false,
    pub fn calcProtobufSize(self: *const KeyguardOccludedProto) usize {
        var res: usize = 0;
        if (self.display_id != 0) {
            res += gremlin.sizes.sizeWireNumber(KeyguardOccludedProtoWire.DISPLAY_ID_WIRE) + gremlin.sizes.sizeI32(self.display_id);
        }
        if (self.keyguard_occluded != false) {
            res += gremlin.sizes.sizeWireNumber(KeyguardOccludedProtoWire.KEYGUARD_OCCLUDED_WIRE) + gremlin.sizes.sizeBool(self.keyguard_occluded);
        }
        return res;
    }
    pub fn encode(self: *const KeyguardOccludedProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const KeyguardOccludedProto, target: *gremlin.Writer) void {
        if (self.display_id != 0) {
            target.appendInt32(KeyguardOccludedProtoWire.DISPLAY_ID_WIRE, self.display_id);
        }
        if (self.keyguard_occluded != false) {
            target.appendBool(KeyguardOccludedProtoWire.KEYGUARD_OCCLUDED_WIRE, self.keyguard_occluded);
        }
    }
};
pub const KeyguardOccludedProtoReader = struct {
    buf: gremlin.Reader,
    _display_id: i32 = 0,
    _keyguard_occluded: bool = false,
    pub fn init(src: []const u8) gremlin.Error!KeyguardOccludedProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = KeyguardOccludedProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                KeyguardOccludedProtoWire.DISPLAY_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._display_id = result.value;
                },
                KeyguardOccludedProtoWire.KEYGUARD_OCCLUDED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._keyguard_occluded = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDisplayId(self: *const KeyguardOccludedProtoReader) i32 {
        return self._display_id;
    }
    pub inline fn getKeyguardOccluded(self: *const KeyguardOccludedProtoReader) bool {
        return self._keyguard_occluded;
    }
};
const KeyguardPerDisplayProtoWire = struct {
    const DISPLAY_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const KEYGUARD_SHOWING_WIRE: gremlin.ProtoWireNumber = 2;
    const AOD_SHOWING_WIRE: gremlin.ProtoWireNumber = 3;
    const KEYGUARD_OCCLUDED_WIRE: gremlin.ProtoWireNumber = 4;
    const KEYGUARD_GOING_AWAY_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const KeyguardPerDisplayProto = struct {
    // fields
    display_id: i32 = 0,
    keyguard_showing: bool = false,
    aod_showing: bool = false,
    keyguard_occluded: bool = false,
    keyguard_going_away: bool = false,
    pub fn calcProtobufSize(self: *const KeyguardPerDisplayProto) usize {
        var res: usize = 0;
        if (self.display_id != 0) {
            res += gremlin.sizes.sizeWireNumber(KeyguardPerDisplayProtoWire.DISPLAY_ID_WIRE) + gremlin.sizes.sizeI32(self.display_id);
        }
        if (self.keyguard_showing != false) {
            res += gremlin.sizes.sizeWireNumber(KeyguardPerDisplayProtoWire.KEYGUARD_SHOWING_WIRE) + gremlin.sizes.sizeBool(self.keyguard_showing);
        }
        if (self.aod_showing != false) {
            res += gremlin.sizes.sizeWireNumber(KeyguardPerDisplayProtoWire.AOD_SHOWING_WIRE) + gremlin.sizes.sizeBool(self.aod_showing);
        }
        if (self.keyguard_occluded != false) {
            res += gremlin.sizes.sizeWireNumber(KeyguardPerDisplayProtoWire.KEYGUARD_OCCLUDED_WIRE) + gremlin.sizes.sizeBool(self.keyguard_occluded);
        }
        if (self.keyguard_going_away != false) {
            res += gremlin.sizes.sizeWireNumber(KeyguardPerDisplayProtoWire.KEYGUARD_GOING_AWAY_WIRE) + gremlin.sizes.sizeBool(self.keyguard_going_away);
        }
        return res;
    }
    pub fn encode(self: *const KeyguardPerDisplayProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const KeyguardPerDisplayProto, target: *gremlin.Writer) void {
        if (self.display_id != 0) {
            target.appendInt32(KeyguardPerDisplayProtoWire.DISPLAY_ID_WIRE, self.display_id);
        }
        if (self.keyguard_showing != false) {
            target.appendBool(KeyguardPerDisplayProtoWire.KEYGUARD_SHOWING_WIRE, self.keyguard_showing);
        }
        if (self.aod_showing != false) {
            target.appendBool(KeyguardPerDisplayProtoWire.AOD_SHOWING_WIRE, self.aod_showing);
        }
        if (self.keyguard_occluded != false) {
            target.appendBool(KeyguardPerDisplayProtoWire.KEYGUARD_OCCLUDED_WIRE, self.keyguard_occluded);
        }
        if (self.keyguard_going_away != false) {
            target.appendBool(KeyguardPerDisplayProtoWire.KEYGUARD_GOING_AWAY_WIRE, self.keyguard_going_away);
        }
    }
};
pub const KeyguardPerDisplayProtoReader = struct {
    buf: gremlin.Reader,
    _display_id: i32 = 0,
    _keyguard_showing: bool = false,
    _aod_showing: bool = false,
    _keyguard_occluded: bool = false,
    _keyguard_going_away: bool = false,
    pub fn init(src: []const u8) gremlin.Error!KeyguardPerDisplayProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = KeyguardPerDisplayProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                KeyguardPerDisplayProtoWire.DISPLAY_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._display_id = result.value;
                },
                KeyguardPerDisplayProtoWire.KEYGUARD_SHOWING_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._keyguard_showing = result.value;
                },
                KeyguardPerDisplayProtoWire.AOD_SHOWING_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._aod_showing = result.value;
                },
                KeyguardPerDisplayProtoWire.KEYGUARD_OCCLUDED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._keyguard_occluded = result.value;
                },
                KeyguardPerDisplayProtoWire.KEYGUARD_GOING_AWAY_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._keyguard_going_away = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDisplayId(self: *const KeyguardPerDisplayProtoReader) i32 {
        return self._display_id;
    }
    pub inline fn getKeyguardShowing(self: *const KeyguardPerDisplayProtoReader) bool {
        return self._keyguard_showing;
    }
    pub inline fn getAodShowing(self: *const KeyguardPerDisplayProtoReader) bool {
        return self._aod_showing;
    }
    pub inline fn getKeyguardOccluded(self: *const KeyguardPerDisplayProtoReader) bool {
        return self._keyguard_occluded;
    }
    pub inline fn getKeyguardGoingAway(self: *const KeyguardPerDisplayProtoReader) bool {
        return self._keyguard_going_away;
    }
};
const WindowManagerPolicyProtoWire = struct {
    const LAST_SYSTEM_UI_FLAGS_WIRE: gremlin.ProtoWireNumber = 1;
    const ROTATION_MODE_WIRE: gremlin.ProtoWireNumber = 2;
    const ROTATION_WIRE: gremlin.ProtoWireNumber = 3;
    const ORIENTATION_WIRE: gremlin.ProtoWireNumber = 4;
    const SCREEN_ON_FULLY_WIRE: gremlin.ProtoWireNumber = 5;
    const KEYGUARD_DRAW_COMPLETE_WIRE: gremlin.ProtoWireNumber = 6;
    const WINDOW_MANAGER_DRAW_COMPLETE_WIRE: gremlin.ProtoWireNumber = 7;
    const FOCUSED_APP_TOKEN_WIRE: gremlin.ProtoWireNumber = 8;
    const FOCUSED_WINDOW_WIRE: gremlin.ProtoWireNumber = 9;
    const TOP_FULLSCREEN_OPAQUE_WINDOW_WIRE: gremlin.ProtoWireNumber = 10;
    const TOP_FULLSCREEN_OPAQUE_OR_DIMMING_WINDOW_WIRE: gremlin.ProtoWireNumber = 11;
    const KEYGUARD_OCCLUDED_WIRE: gremlin.ProtoWireNumber = 12;
    const KEYGUARD_OCCLUDED_CHANGED_WIRE: gremlin.ProtoWireNumber = 13;
    const KEYGUARD_OCCLUDED_PENDING_WIRE: gremlin.ProtoWireNumber = 14;
    const FORCE_STATUS_BAR_WIRE: gremlin.ProtoWireNumber = 15;
    const FORCE_STATUS_BAR_FROM_KEYGUARD_WIRE: gremlin.ProtoWireNumber = 16;
    const STATUS_BAR_WIRE: gremlin.ProtoWireNumber = 17;
    const NAVIGATION_BAR_WIRE: gremlin.ProtoWireNumber = 18;
    const ORIENTATION_LISTENER_WIRE: gremlin.ProtoWireNumber = 19;
    const KEYGUARD_DELEGATE_WIRE: gremlin.ProtoWireNumber = 20;
};
pub const WindowManagerPolicyProto = struct {
    // nested enums
    pub const UserRotationMode = enum(i32) {
        USER_ROTATION_FREE = 0,
        USER_ROTATION_LOCKED = 1,
    };
    // fields
    last_system_ui_flags: i32 = 0,
    rotation_mode: WindowManagerPolicyProto.UserRotationMode = @enumFromInt(0),
    rotation: surface.SurfaceProto.Rotation = @enumFromInt(0),
    orientation: activityinfo.ActivityInfoProto.ScreenOrientation = @enumFromInt(0),
    screen_on_fully: bool = false,
    keyguard_draw_complete: bool = false,
    window_manager_draw_complete: bool = false,
    focused_app_token: ?[]const u8 = null,
    focused_window: ?IdentifierProto = null,
    top_fullscreen_opaque_window: ?IdentifierProto = null,
    top_fullscreen_opaque_or_dimming_window: ?IdentifierProto = null,
    keyguard_occluded: bool = false,
    keyguard_occluded_changed: bool = false,
    keyguard_occluded_pending: bool = false,
    force_status_bar: bool = false,
    force_status_bar_from_keyguard: bool = false,
    status_bar: ?BarControllerProto = null,
    navigation_bar: ?BarControllerProto = null,
    orientation_listener: ?WindowOrientationListenerProto = null,
    keyguard_delegate: ?KeyguardServiceDelegateProto = null,
    pub fn calcProtobufSize(self: *const WindowManagerPolicyProto) usize {
        var res: usize = 0;
        if (self.last_system_ui_flags != 0) {
            res += gremlin.sizes.sizeWireNumber(WindowManagerPolicyProtoWire.LAST_SYSTEM_UI_FLAGS_WIRE) + gremlin.sizes.sizeI32(self.last_system_ui_flags);
        }
        if (@intFromEnum(self.rotation_mode) != 0) {
            res += gremlin.sizes.sizeWireNumber(WindowManagerPolicyProtoWire.ROTATION_MODE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.rotation_mode));
        }
        if (@intFromEnum(self.rotation) != 0) {
            res += gremlin.sizes.sizeWireNumber(WindowManagerPolicyProtoWire.ROTATION_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.rotation));
        }
        if (@intFromEnum(self.orientation) != 0) {
            res += gremlin.sizes.sizeWireNumber(WindowManagerPolicyProtoWire.ORIENTATION_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.orientation));
        }
        if (self.screen_on_fully != false) {
            res += gremlin.sizes.sizeWireNumber(WindowManagerPolicyProtoWire.SCREEN_ON_FULLY_WIRE) + gremlin.sizes.sizeBool(self.screen_on_fully);
        }
        if (self.keyguard_draw_complete != false) {
            res += gremlin.sizes.sizeWireNumber(WindowManagerPolicyProtoWire.KEYGUARD_DRAW_COMPLETE_WIRE) + gremlin.sizes.sizeBool(self.keyguard_draw_complete);
        }
        if (self.window_manager_draw_complete != false) {
            res += gremlin.sizes.sizeWireNumber(WindowManagerPolicyProtoWire.WINDOW_MANAGER_DRAW_COMPLETE_WIRE) + gremlin.sizes.sizeBool(self.window_manager_draw_complete);
        }
        if (self.focused_app_token) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowManagerPolicyProtoWire.FOCUSED_APP_TOKEN_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.focused_window) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowManagerPolicyProtoWire.FOCUSED_WINDOW_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.top_fullscreen_opaque_window) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowManagerPolicyProtoWire.TOP_FULLSCREEN_OPAQUE_WINDOW_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.top_fullscreen_opaque_or_dimming_window) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowManagerPolicyProtoWire.TOP_FULLSCREEN_OPAQUE_OR_DIMMING_WINDOW_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.keyguard_occluded != false) {
            res += gremlin.sizes.sizeWireNumber(WindowManagerPolicyProtoWire.KEYGUARD_OCCLUDED_WIRE) + gremlin.sizes.sizeBool(self.keyguard_occluded);
        }
        if (self.keyguard_occluded_changed != false) {
            res += gremlin.sizes.sizeWireNumber(WindowManagerPolicyProtoWire.KEYGUARD_OCCLUDED_CHANGED_WIRE) + gremlin.sizes.sizeBool(self.keyguard_occluded_changed);
        }
        if (self.keyguard_occluded_pending != false) {
            res += gremlin.sizes.sizeWireNumber(WindowManagerPolicyProtoWire.KEYGUARD_OCCLUDED_PENDING_WIRE) + gremlin.sizes.sizeBool(self.keyguard_occluded_pending);
        }
        if (self.force_status_bar != false) {
            res += gremlin.sizes.sizeWireNumber(WindowManagerPolicyProtoWire.FORCE_STATUS_BAR_WIRE) + gremlin.sizes.sizeBool(self.force_status_bar);
        }
        if (self.force_status_bar_from_keyguard != false) {
            res += gremlin.sizes.sizeWireNumber(WindowManagerPolicyProtoWire.FORCE_STATUS_BAR_FROM_KEYGUARD_WIRE) + gremlin.sizes.sizeBool(self.force_status_bar_from_keyguard);
        }
        if (self.status_bar) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowManagerPolicyProtoWire.STATUS_BAR_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.navigation_bar) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowManagerPolicyProtoWire.NAVIGATION_BAR_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.orientation_listener) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowManagerPolicyProtoWire.ORIENTATION_LISTENER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.keyguard_delegate) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowManagerPolicyProtoWire.KEYGUARD_DELEGATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const WindowManagerPolicyProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const WindowManagerPolicyProto, target: *gremlin.Writer) void {
        if (self.last_system_ui_flags != 0) {
            target.appendInt32(WindowManagerPolicyProtoWire.LAST_SYSTEM_UI_FLAGS_WIRE, self.last_system_ui_flags);
        }
        if (@intFromEnum(self.rotation_mode) != 0) {
            target.appendInt32(WindowManagerPolicyProtoWire.ROTATION_MODE_WIRE, @intFromEnum(self.rotation_mode));
        }
        if (@intFromEnum(self.rotation) != 0) {
            target.appendInt32(WindowManagerPolicyProtoWire.ROTATION_WIRE, @intFromEnum(self.rotation));
        }
        if (@intFromEnum(self.orientation) != 0) {
            target.appendInt32(WindowManagerPolicyProtoWire.ORIENTATION_WIRE, @intFromEnum(self.orientation));
        }
        if (self.screen_on_fully != false) {
            target.appendBool(WindowManagerPolicyProtoWire.SCREEN_ON_FULLY_WIRE, self.screen_on_fully);
        }
        if (self.keyguard_draw_complete != false) {
            target.appendBool(WindowManagerPolicyProtoWire.KEYGUARD_DRAW_COMPLETE_WIRE, self.keyguard_draw_complete);
        }
        if (self.window_manager_draw_complete != false) {
            target.appendBool(WindowManagerPolicyProtoWire.WINDOW_MANAGER_DRAW_COMPLETE_WIRE, self.window_manager_draw_complete);
        }
        if (self.focused_app_token) |v| {
            if (v.len > 0) {
                target.appendBytes(WindowManagerPolicyProtoWire.FOCUSED_APP_TOKEN_WIRE, v);
            }
        }
        if (self.focused_window) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowManagerPolicyProtoWire.FOCUSED_WINDOW_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.top_fullscreen_opaque_window) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowManagerPolicyProtoWire.TOP_FULLSCREEN_OPAQUE_WINDOW_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.top_fullscreen_opaque_or_dimming_window) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowManagerPolicyProtoWire.TOP_FULLSCREEN_OPAQUE_OR_DIMMING_WINDOW_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.keyguard_occluded != false) {
            target.appendBool(WindowManagerPolicyProtoWire.KEYGUARD_OCCLUDED_WIRE, self.keyguard_occluded);
        }
        if (self.keyguard_occluded_changed != false) {
            target.appendBool(WindowManagerPolicyProtoWire.KEYGUARD_OCCLUDED_CHANGED_WIRE, self.keyguard_occluded_changed);
        }
        if (self.keyguard_occluded_pending != false) {
            target.appendBool(WindowManagerPolicyProtoWire.KEYGUARD_OCCLUDED_PENDING_WIRE, self.keyguard_occluded_pending);
        }
        if (self.force_status_bar != false) {
            target.appendBool(WindowManagerPolicyProtoWire.FORCE_STATUS_BAR_WIRE, self.force_status_bar);
        }
        if (self.force_status_bar_from_keyguard != false) {
            target.appendBool(WindowManagerPolicyProtoWire.FORCE_STATUS_BAR_FROM_KEYGUARD_WIRE, self.force_status_bar_from_keyguard);
        }
        if (self.status_bar) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowManagerPolicyProtoWire.STATUS_BAR_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.navigation_bar) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowManagerPolicyProtoWire.NAVIGATION_BAR_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.orientation_listener) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowManagerPolicyProtoWire.ORIENTATION_LISTENER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.keyguard_delegate) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowManagerPolicyProtoWire.KEYGUARD_DELEGATE_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const WindowManagerPolicyProtoReader = struct {
    buf: gremlin.Reader,
    _last_system_ui_flags: i32 = 0,
    _rotation_mode: WindowManagerPolicyProto.UserRotationMode = @enumFromInt(0),
    _rotation: surface.SurfaceProto.Rotation = @enumFromInt(0),
    _orientation: activityinfo.ActivityInfoProto.ScreenOrientation = @enumFromInt(0),
    _screen_on_fully: bool = false,
    _keyguard_draw_complete: bool = false,
    _window_manager_draw_complete: bool = false,
    _focused_app_token: ?[]const u8 = null,
    _focused_window_buf: ?[]const u8 = null,
    _top_fullscreen_opaque_window_buf: ?[]const u8 = null,
    _top_fullscreen_opaque_or_dimming_window_buf: ?[]const u8 = null,
    _keyguard_occluded: bool = false,
    _keyguard_occluded_changed: bool = false,
    _keyguard_occluded_pending: bool = false,
    _force_status_bar: bool = false,
    _force_status_bar_from_keyguard: bool = false,
    _status_bar_buf: ?[]const u8 = null,
    _navigation_bar_buf: ?[]const u8 = null,
    _orientation_listener_buf: ?[]const u8 = null,
    _keyguard_delegate_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!WindowManagerPolicyProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = WindowManagerPolicyProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                WindowManagerPolicyProtoWire.LAST_SYSTEM_UI_FLAGS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._last_system_ui_flags = result.value;
                },
                WindowManagerPolicyProtoWire.ROTATION_MODE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._rotation_mode = @enumFromInt(result.value);
                },
                WindowManagerPolicyProtoWire.ROTATION_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._rotation = @enumFromInt(result.value);
                },
                WindowManagerPolicyProtoWire.ORIENTATION_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._orientation = @enumFromInt(result.value);
                },
                WindowManagerPolicyProtoWire.SCREEN_ON_FULLY_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._screen_on_fully = result.value;
                },
                WindowManagerPolicyProtoWire.KEYGUARD_DRAW_COMPLETE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._keyguard_draw_complete = result.value;
                },
                WindowManagerPolicyProtoWire.WINDOW_MANAGER_DRAW_COMPLETE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._window_manager_draw_complete = result.value;
                },
                WindowManagerPolicyProtoWire.FOCUSED_APP_TOKEN_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._focused_app_token = result.value;
                },
                WindowManagerPolicyProtoWire.FOCUSED_WINDOW_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._focused_window_buf = result.value;
                },
                WindowManagerPolicyProtoWire.TOP_FULLSCREEN_OPAQUE_WINDOW_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._top_fullscreen_opaque_window_buf = result.value;
                },
                WindowManagerPolicyProtoWire.TOP_FULLSCREEN_OPAQUE_OR_DIMMING_WINDOW_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._top_fullscreen_opaque_or_dimming_window_buf = result.value;
                },
                WindowManagerPolicyProtoWire.KEYGUARD_OCCLUDED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._keyguard_occluded = result.value;
                },
                WindowManagerPolicyProtoWire.KEYGUARD_OCCLUDED_CHANGED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._keyguard_occluded_changed = result.value;
                },
                WindowManagerPolicyProtoWire.KEYGUARD_OCCLUDED_PENDING_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._keyguard_occluded_pending = result.value;
                },
                WindowManagerPolicyProtoWire.FORCE_STATUS_BAR_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._force_status_bar = result.value;
                },
                WindowManagerPolicyProtoWire.FORCE_STATUS_BAR_FROM_KEYGUARD_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._force_status_bar_from_keyguard = result.value;
                },
                WindowManagerPolicyProtoWire.STATUS_BAR_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._status_bar_buf = result.value;
                },
                WindowManagerPolicyProtoWire.NAVIGATION_BAR_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._navigation_bar_buf = result.value;
                },
                WindowManagerPolicyProtoWire.ORIENTATION_LISTENER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._orientation_listener_buf = result.value;
                },
                WindowManagerPolicyProtoWire.KEYGUARD_DELEGATE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._keyguard_delegate_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getLastSystemUiFlags(self: *const WindowManagerPolicyProtoReader) i32 {
        return self._last_system_ui_flags;
    }
    pub inline fn getRotationMode(self: *const WindowManagerPolicyProtoReader) WindowManagerPolicyProto.UserRotationMode {
        return self._rotation_mode;
    }
    pub inline fn getRotation(self: *const WindowManagerPolicyProtoReader) surface.SurfaceProto.Rotation {
        return self._rotation;
    }
    pub inline fn getOrientation(self: *const WindowManagerPolicyProtoReader) activityinfo.ActivityInfoProto.ScreenOrientation {
        return self._orientation;
    }
    pub inline fn getScreenOnFully(self: *const WindowManagerPolicyProtoReader) bool {
        return self._screen_on_fully;
    }
    pub inline fn getKeyguardDrawComplete(self: *const WindowManagerPolicyProtoReader) bool {
        return self._keyguard_draw_complete;
    }
    pub inline fn getWindowManagerDrawComplete(self: *const WindowManagerPolicyProtoReader) bool {
        return self._window_manager_draw_complete;
    }
    pub inline fn getFocusedAppToken(self: *const WindowManagerPolicyProtoReader) []const u8 {
        return self._focused_app_token orelse &[_]u8{};
    }
    pub fn getFocusedWindow(self: *const WindowManagerPolicyProtoReader) gremlin.Error!IdentifierProtoReader {
        if (self._focused_window_buf) |buf| {
            return try IdentifierProtoReader.init(buf);
        }
        return try IdentifierProtoReader.init(&[_]u8{});
    }
    pub fn getTopFullscreenOpaqueWindow(self: *const WindowManagerPolicyProtoReader) gremlin.Error!IdentifierProtoReader {
        if (self._top_fullscreen_opaque_window_buf) |buf| {
            return try IdentifierProtoReader.init(buf);
        }
        return try IdentifierProtoReader.init(&[_]u8{});
    }
    pub fn getTopFullscreenOpaqueOrDimmingWindow(self: *const WindowManagerPolicyProtoReader) gremlin.Error!IdentifierProtoReader {
        if (self._top_fullscreen_opaque_or_dimming_window_buf) |buf| {
            return try IdentifierProtoReader.init(buf);
        }
        return try IdentifierProtoReader.init(&[_]u8{});
    }
    pub inline fn getKeyguardOccluded(self: *const WindowManagerPolicyProtoReader) bool {
        return self._keyguard_occluded;
    }
    pub inline fn getKeyguardOccludedChanged(self: *const WindowManagerPolicyProtoReader) bool {
        return self._keyguard_occluded_changed;
    }
    pub inline fn getKeyguardOccludedPending(self: *const WindowManagerPolicyProtoReader) bool {
        return self._keyguard_occluded_pending;
    }
    pub inline fn getForceStatusBar(self: *const WindowManagerPolicyProtoReader) bool {
        return self._force_status_bar;
    }
    pub inline fn getForceStatusBarFromKeyguard(self: *const WindowManagerPolicyProtoReader) bool {
        return self._force_status_bar_from_keyguard;
    }
    pub fn getStatusBar(self: *const WindowManagerPolicyProtoReader) gremlin.Error!BarControllerProtoReader {
        if (self._status_bar_buf) |buf| {
            return try BarControllerProtoReader.init(buf);
        }
        return try BarControllerProtoReader.init(&[_]u8{});
    }
    pub fn getNavigationBar(self: *const WindowManagerPolicyProtoReader) gremlin.Error!BarControllerProtoReader {
        if (self._navigation_bar_buf) |buf| {
            return try BarControllerProtoReader.init(buf);
        }
        return try BarControllerProtoReader.init(&[_]u8{});
    }
    pub fn getOrientationListener(self: *const WindowManagerPolicyProtoReader) gremlin.Error!WindowOrientationListenerProtoReader {
        if (self._orientation_listener_buf) |buf| {
            return try WindowOrientationListenerProtoReader.init(buf);
        }
        return try WindowOrientationListenerProtoReader.init(&[_]u8{});
    }
    pub fn getKeyguardDelegate(self: *const WindowManagerPolicyProtoReader) gremlin.Error!KeyguardServiceDelegateProtoReader {
        if (self._keyguard_delegate_buf) |buf| {
            return try KeyguardServiceDelegateProtoReader.init(buf);
        }
        return try KeyguardServiceDelegateProtoReader.init(&[_]u8{});
    }
};
const AppTransitionProtoWire = struct {
    const APP_TRANSITION_STATE_WIRE: gremlin.ProtoWireNumber = 1;
    const LAST_USED_APP_TRANSITION_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const AppTransitionProto = struct {
    // nested enums
    pub const AppState = enum(i32) {
        APP_STATE_IDLE = 0,
        APP_STATE_READY = 1,
        APP_STATE_RUNNING = 2,
        APP_STATE_TIMEOUT = 3,
    };
    // fields
    app_transition_state: AppTransitionProto.AppState = @enumFromInt(0),
    last_used_app_transition: enums.TransitionTypeEnum = @enumFromInt(0),
    pub fn calcProtobufSize(self: *const AppTransitionProto) usize {
        var res: usize = 0;
        if (@intFromEnum(self.app_transition_state) != 0) {
            res += gremlin.sizes.sizeWireNumber(AppTransitionProtoWire.APP_TRANSITION_STATE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.app_transition_state));
        }
        if (@intFromEnum(self.last_used_app_transition) != 0) {
            res += gremlin.sizes.sizeWireNumber(AppTransitionProtoWire.LAST_USED_APP_TRANSITION_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.last_used_app_transition));
        }
        return res;
    }
    pub fn encode(self: *const AppTransitionProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AppTransitionProto, target: *gremlin.Writer) void {
        if (@intFromEnum(self.app_transition_state) != 0) {
            target.appendInt32(AppTransitionProtoWire.APP_TRANSITION_STATE_WIRE, @intFromEnum(self.app_transition_state));
        }
        if (@intFromEnum(self.last_used_app_transition) != 0) {
            target.appendInt32(AppTransitionProtoWire.LAST_USED_APP_TRANSITION_WIRE, @intFromEnum(self.last_used_app_transition));
        }
    }
};
pub const AppTransitionProtoReader = struct {
    buf: gremlin.Reader,
    _app_transition_state: AppTransitionProto.AppState = @enumFromInt(0),
    _last_used_app_transition: enums.TransitionTypeEnum = @enumFromInt(0),
    pub fn init(src: []const u8) gremlin.Error!AppTransitionProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = AppTransitionProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AppTransitionProtoWire.APP_TRANSITION_STATE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._app_transition_state = @enumFromInt(result.value);
                },
                AppTransitionProtoWire.LAST_USED_APP_TRANSITION_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._last_used_app_transition = @enumFromInt(result.value);
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getAppTransitionState(self: *const AppTransitionProtoReader) AppTransitionProto.AppState {
        return self._app_transition_state;
    }
    pub inline fn getLastUsedAppTransition(self: *const AppTransitionProtoReader) enums.TransitionTypeEnum {
        return self._last_used_app_transition;
    }
};
const DisplayContentProtoWire = struct {
    const WINDOW_CONTAINER_WIRE: gremlin.ProtoWireNumber = 1;
    const ID_WIRE: gremlin.ProtoWireNumber = 2;
    const DOCKED_TASK_DIVIDER_CONTROLLER_WIRE: gremlin.ProtoWireNumber = 4;
    const PINNED_TASK_CONTROLLER_WIRE: gremlin.ProtoWireNumber = 5;
    const ABOVE_APP_WINDOWS_WIRE: gremlin.ProtoWireNumber = 6;
    const BELOW_APP_WINDOWS_WIRE: gremlin.ProtoWireNumber = 7;
    const IME_WINDOWS_WIRE: gremlin.ProtoWireNumber = 8;
    const DPI_WIRE: gremlin.ProtoWireNumber = 9;
    const DISPLAY_INFO_WIRE: gremlin.ProtoWireNumber = 10;
    const ROTATION_WIRE: gremlin.ProtoWireNumber = 11;
    const SCREEN_ROTATION_ANIMATION_WIRE: gremlin.ProtoWireNumber = 12;
    const DISPLAY_FRAMES_WIRE: gremlin.ProtoWireNumber = 13;
    const SURFACE_SIZE_WIRE: gremlin.ProtoWireNumber = 14;
    const FOCUSED_APP_WIRE: gremlin.ProtoWireNumber = 15;
    const APP_TRANSITION_WIRE: gremlin.ProtoWireNumber = 16;
    const OPENING_APPS_WIRE: gremlin.ProtoWireNumber = 17;
    const CLOSING_APPS_WIRE: gremlin.ProtoWireNumber = 18;
    const CHANGING_APPS_WIRE: gremlin.ProtoWireNumber = 19;
    const OVERLAY_WINDOWS_WIRE: gremlin.ProtoWireNumber = 20;
    const ROOT_DISPLAY_AREA_WIRE: gremlin.ProtoWireNumber = 21;
    const SINGLE_TASK_INSTANCE_WIRE: gremlin.ProtoWireNumber = 22;
    const FOCUSED_ROOT_TASK_ID_WIRE: gremlin.ProtoWireNumber = 23;
    const RESUMED_ACTIVITY_WIRE: gremlin.ProtoWireNumber = 24;
    const TASKS_WIRE: gremlin.ProtoWireNumber = 25;
    const DISPLAY_READY_WIRE: gremlin.ProtoWireNumber = 26;
    const INPUT_METHOD_TARGET_WIRE: gremlin.ProtoWireNumber = 27;
    const INPUT_METHOD_INPUT_TARGET_WIRE: gremlin.ProtoWireNumber = 28;
    const INPUT_METHOD_CONTROL_TARGET_WIRE: gremlin.ProtoWireNumber = 29;
    const CURRENT_FOCUS_WIRE: gremlin.ProtoWireNumber = 30;
    const IME_INSETS_SOURCE_PROVIDER_WIRE: gremlin.ProtoWireNumber = 31;
    const CAN_SHOW_IME_WIRE: gremlin.ProtoWireNumber = 32;
    const DISPLAY_ROTATION_WIRE: gremlin.ProtoWireNumber = 33;
    const IME_POLICY_WIRE: gremlin.ProtoWireNumber = 34;
    const INSETS_SOURCE_PROVIDERS_WIRE: gremlin.ProtoWireNumber = 35;
    const IS_SLEEPING_WIRE: gremlin.ProtoWireNumber = 36;
    const SLEEP_TOKENS_WIRE: gremlin.ProtoWireNumber = 37;
    const KEEP_CLEAR_AREAS_WIRE: gremlin.ProtoWireNumber = 38;
    const MIN_SIZE_OF_RESIZEABLE_TASK_DP_WIRE: gremlin.ProtoWireNumber = 39;
    const INPUT_METHOD_LAYERING_TARGET_IDENTIFIER_WIRE: gremlin.ProtoWireNumber = 40;
    const INPUT_METHOD_INPUT_TARGET_IDENTIFIER_WIRE: gremlin.ProtoWireNumber = 41;
    const INPUT_METHOD_CONTROL_TARGET_IDENTIFIER_WIRE: gremlin.ProtoWireNumber = 42;
    const CURRENT_FOCUS_IDENTIFIER_WIRE: gremlin.ProtoWireNumber = 43;
    const REMOTE_INSETS_CONTROL_TARGET_WIRE: gremlin.ProtoWireNumber = 44;
    const ENGAGEMENT_MODE_WIRE: gremlin.ProtoWireNumber = 45;
};
pub const DisplayContentProto = struct {
    // fields
    window_container: ?WindowContainerProto = null,
    id: i32 = 0,
    docked_task_divider_controller: ?DockedTaskDividerControllerProto = null,
    pinned_task_controller: ?PinnedTaskControllerProto = null,
    above_app_windows: ?[]const ?WindowTokenProto = null,
    below_app_windows: ?[]const ?WindowTokenProto = null,
    ime_windows: ?[]const ?WindowTokenProto = null,
    dpi: i32 = 0,
    display_info: ?displayinfo.DisplayInfoProto = null,
    rotation: i32 = 0,
    screen_rotation_animation: ?ScreenRotationAnimationProto = null,
    display_frames: ?DisplayFramesProto = null,
    surface_size: i32 = 0,
    focused_app: ?[]const u8 = null,
    app_transition: ?AppTransitionProto = null,
    opening_apps: ?[]const ?IdentifierProto = null,
    closing_apps: ?[]const ?IdentifierProto = null,
    changing_apps: ?[]const ?IdentifierProto = null,
    overlay_windows: ?[]const ?WindowTokenProto = null,
    root_display_area: ?DisplayAreaProto = null,
    single_task_instance: bool = false,
    focused_root_task_id: i32 = 0,
    resumed_activity: ?IdentifierProto = null,
    tasks: ?[]const ?TaskProto = null,
    display_ready: bool = false,
    input_method_target: ?WindowStateProto = null,
    input_method_input_target: ?WindowStateProto = null,
    input_method_control_target: ?WindowStateProto = null,
    current_focus: ?WindowStateProto = null,
    ime_insets_source_provider: ?ImeInsetsSourceProviderProto = null,
    can_show_ime: bool = false,
    display_rotation: ?DisplayRotationProto = null,
    ime_policy: i32 = 0,
    insets_source_providers: ?[]const ?InsetsSourceProviderProto = null,
    is_sleeping: bool = false,
    sleep_tokens: ?[]const ?[]const u8 = null,
    keep_clear_areas: ?[]const ?rect.RectProto = null,
    min_size_of_resizeable_task_dp: i32 = 0,
    input_method_layering_target_identifier: ?IdentifierProto = null,
    input_method_input_target_identifier: ?IdentifierProto = null,
    input_method_control_target_identifier: ?IdentifierProto = null,
    current_focus_identifier: ?IdentifierProto = null,
    remote_insets_control_target: ?RemoteInsetsControlTargetProto = null,
    engagement_mode: i32 = 0,
    pub fn calcProtobufSize(self: *const DisplayContentProto) usize {
        var res: usize = 0;
        if (self.window_container) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DisplayContentProtoWire.WINDOW_CONTAINER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.id != 0) {
            res += gremlin.sizes.sizeWireNumber(DisplayContentProtoWire.ID_WIRE) + gremlin.sizes.sizeI32(self.id);
        }
        if (self.docked_task_divider_controller) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DisplayContentProtoWire.DOCKED_TASK_DIVIDER_CONTROLLER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.pinned_task_controller) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DisplayContentProtoWire.PINNED_TASK_CONTROLLER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.above_app_windows) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(DisplayContentProtoWire.ABOVE_APP_WINDOWS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.below_app_windows) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(DisplayContentProtoWire.BELOW_APP_WINDOWS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.ime_windows) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(DisplayContentProtoWire.IME_WINDOWS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.dpi != 0) {
            res += gremlin.sizes.sizeWireNumber(DisplayContentProtoWire.DPI_WIRE) + gremlin.sizes.sizeI32(self.dpi);
        }
        if (self.display_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DisplayContentProtoWire.DISPLAY_INFO_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.rotation != 0) {
            res += gremlin.sizes.sizeWireNumber(DisplayContentProtoWire.ROTATION_WIRE) + gremlin.sizes.sizeI32(self.rotation);
        }
        if (self.screen_rotation_animation) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DisplayContentProtoWire.SCREEN_ROTATION_ANIMATION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.display_frames) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DisplayContentProtoWire.DISPLAY_FRAMES_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.surface_size != 0) {
            res += gremlin.sizes.sizeWireNumber(DisplayContentProtoWire.SURFACE_SIZE_WIRE) + gremlin.sizes.sizeI32(self.surface_size);
        }
        if (self.focused_app) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(DisplayContentProtoWire.FOCUSED_APP_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.app_transition) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DisplayContentProtoWire.APP_TRANSITION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.opening_apps) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(DisplayContentProtoWire.OPENING_APPS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.closing_apps) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(DisplayContentProtoWire.CLOSING_APPS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.changing_apps) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(DisplayContentProtoWire.CHANGING_APPS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.overlay_windows) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(DisplayContentProtoWire.OVERLAY_WINDOWS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.root_display_area) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DisplayContentProtoWire.ROOT_DISPLAY_AREA_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.single_task_instance != false) {
            res += gremlin.sizes.sizeWireNumber(DisplayContentProtoWire.SINGLE_TASK_INSTANCE_WIRE) + gremlin.sizes.sizeBool(self.single_task_instance);
        }
        if (self.focused_root_task_id != 0) {
            res += gremlin.sizes.sizeWireNumber(DisplayContentProtoWire.FOCUSED_ROOT_TASK_ID_WIRE) + gremlin.sizes.sizeI32(self.focused_root_task_id);
        }
        if (self.resumed_activity) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DisplayContentProtoWire.RESUMED_ACTIVITY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.tasks) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(DisplayContentProtoWire.TASKS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.display_ready != false) {
            res += gremlin.sizes.sizeWireNumber(DisplayContentProtoWire.DISPLAY_READY_WIRE) + gremlin.sizes.sizeBool(self.display_ready);
        }
        if (self.input_method_target) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DisplayContentProtoWire.INPUT_METHOD_TARGET_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.input_method_input_target) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DisplayContentProtoWire.INPUT_METHOD_INPUT_TARGET_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.input_method_control_target) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DisplayContentProtoWire.INPUT_METHOD_CONTROL_TARGET_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.current_focus) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DisplayContentProtoWire.CURRENT_FOCUS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ime_insets_source_provider) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DisplayContentProtoWire.IME_INSETS_SOURCE_PROVIDER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.can_show_ime != false) {
            res += gremlin.sizes.sizeWireNumber(DisplayContentProtoWire.CAN_SHOW_IME_WIRE) + gremlin.sizes.sizeBool(self.can_show_ime);
        }
        if (self.display_rotation) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DisplayContentProtoWire.DISPLAY_ROTATION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ime_policy != 0) {
            res += gremlin.sizes.sizeWireNumber(DisplayContentProtoWire.IME_POLICY_WIRE) + gremlin.sizes.sizeI32(self.ime_policy);
        }
        if (self.insets_source_providers) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(DisplayContentProtoWire.INSETS_SOURCE_PROVIDERS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.is_sleeping != false) {
            res += gremlin.sizes.sizeWireNumber(DisplayContentProtoWire.IS_SLEEPING_WIRE) + gremlin.sizes.sizeBool(self.is_sleeping);
        }
        if (self.sleep_tokens) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(DisplayContentProtoWire.SLEEP_TOKENS_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.keep_clear_areas) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(DisplayContentProtoWire.KEEP_CLEAR_AREAS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.min_size_of_resizeable_task_dp != 0) {
            res += gremlin.sizes.sizeWireNumber(DisplayContentProtoWire.MIN_SIZE_OF_RESIZEABLE_TASK_DP_WIRE) + gremlin.sizes.sizeI32(self.min_size_of_resizeable_task_dp);
        }
        if (self.input_method_layering_target_identifier) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DisplayContentProtoWire.INPUT_METHOD_LAYERING_TARGET_IDENTIFIER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.input_method_input_target_identifier) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DisplayContentProtoWire.INPUT_METHOD_INPUT_TARGET_IDENTIFIER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.input_method_control_target_identifier) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DisplayContentProtoWire.INPUT_METHOD_CONTROL_TARGET_IDENTIFIER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.current_focus_identifier) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DisplayContentProtoWire.CURRENT_FOCUS_IDENTIFIER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.remote_insets_control_target) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DisplayContentProtoWire.REMOTE_INSETS_CONTROL_TARGET_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.engagement_mode != 0) {
            res += gremlin.sizes.sizeWireNumber(DisplayContentProtoWire.ENGAGEMENT_MODE_WIRE) + gremlin.sizes.sizeI32(self.engagement_mode);
        }
        return res;
    }
    pub fn encode(self: *const DisplayContentProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const DisplayContentProto, target: *gremlin.Writer) void {
        if (self.window_container) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DisplayContentProtoWire.WINDOW_CONTAINER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.id != 0) {
            target.appendInt32(DisplayContentProtoWire.ID_WIRE, self.id);
        }
        if (self.docked_task_divider_controller) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DisplayContentProtoWire.DOCKED_TASK_DIVIDER_CONTROLLER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.pinned_task_controller) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DisplayContentProtoWire.PINNED_TASK_CONTROLLER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.above_app_windows) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(DisplayContentProtoWire.ABOVE_APP_WINDOWS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(DisplayContentProtoWire.ABOVE_APP_WINDOWS_WIRE, 0);
                }
            }
        }
        if (self.below_app_windows) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(DisplayContentProtoWire.BELOW_APP_WINDOWS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(DisplayContentProtoWire.BELOW_APP_WINDOWS_WIRE, 0);
                }
            }
        }
        if (self.ime_windows) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(DisplayContentProtoWire.IME_WINDOWS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(DisplayContentProtoWire.IME_WINDOWS_WIRE, 0);
                }
            }
        }
        if (self.dpi != 0) {
            target.appendInt32(DisplayContentProtoWire.DPI_WIRE, self.dpi);
        }
        if (self.display_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DisplayContentProtoWire.DISPLAY_INFO_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.rotation != 0) {
            target.appendInt32(DisplayContentProtoWire.ROTATION_WIRE, self.rotation);
        }
        if (self.screen_rotation_animation) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DisplayContentProtoWire.SCREEN_ROTATION_ANIMATION_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.display_frames) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DisplayContentProtoWire.DISPLAY_FRAMES_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.surface_size != 0) {
            target.appendInt32(DisplayContentProtoWire.SURFACE_SIZE_WIRE, self.surface_size);
        }
        if (self.focused_app) |v| {
            if (v.len > 0) {
                target.appendBytes(DisplayContentProtoWire.FOCUSED_APP_WIRE, v);
            }
        }
        if (self.app_transition) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DisplayContentProtoWire.APP_TRANSITION_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.opening_apps) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(DisplayContentProtoWire.OPENING_APPS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(DisplayContentProtoWire.OPENING_APPS_WIRE, 0);
                }
            }
        }
        if (self.closing_apps) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(DisplayContentProtoWire.CLOSING_APPS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(DisplayContentProtoWire.CLOSING_APPS_WIRE, 0);
                }
            }
        }
        if (self.changing_apps) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(DisplayContentProtoWire.CHANGING_APPS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(DisplayContentProtoWire.CHANGING_APPS_WIRE, 0);
                }
            }
        }
        if (self.overlay_windows) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(DisplayContentProtoWire.OVERLAY_WINDOWS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(DisplayContentProtoWire.OVERLAY_WINDOWS_WIRE, 0);
                }
            }
        }
        if (self.root_display_area) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DisplayContentProtoWire.ROOT_DISPLAY_AREA_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.single_task_instance != false) {
            target.appendBool(DisplayContentProtoWire.SINGLE_TASK_INSTANCE_WIRE, self.single_task_instance);
        }
        if (self.focused_root_task_id != 0) {
            target.appendInt32(DisplayContentProtoWire.FOCUSED_ROOT_TASK_ID_WIRE, self.focused_root_task_id);
        }
        if (self.resumed_activity) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DisplayContentProtoWire.RESUMED_ACTIVITY_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.tasks) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(DisplayContentProtoWire.TASKS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(DisplayContentProtoWire.TASKS_WIRE, 0);
                }
            }
        }
        if (self.display_ready != false) {
            target.appendBool(DisplayContentProtoWire.DISPLAY_READY_WIRE, self.display_ready);
        }
        if (self.input_method_target) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DisplayContentProtoWire.INPUT_METHOD_TARGET_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.input_method_input_target) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DisplayContentProtoWire.INPUT_METHOD_INPUT_TARGET_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.input_method_control_target) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DisplayContentProtoWire.INPUT_METHOD_CONTROL_TARGET_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.current_focus) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DisplayContentProtoWire.CURRENT_FOCUS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ime_insets_source_provider) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DisplayContentProtoWire.IME_INSETS_SOURCE_PROVIDER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.can_show_ime != false) {
            target.appendBool(DisplayContentProtoWire.CAN_SHOW_IME_WIRE, self.can_show_ime);
        }
        if (self.display_rotation) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DisplayContentProtoWire.DISPLAY_ROTATION_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ime_policy != 0) {
            target.appendInt32(DisplayContentProtoWire.IME_POLICY_WIRE, self.ime_policy);
        }
        if (self.insets_source_providers) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(DisplayContentProtoWire.INSETS_SOURCE_PROVIDERS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(DisplayContentProtoWire.INSETS_SOURCE_PROVIDERS_WIRE, 0);
                }
            }
        }
        if (self.is_sleeping != false) {
            target.appendBool(DisplayContentProtoWire.IS_SLEEPING_WIRE, self.is_sleeping);
        }
        if (self.sleep_tokens) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(DisplayContentProtoWire.SLEEP_TOKENS_WIRE, v);
                } else {
                    target.appendBytesTag(DisplayContentProtoWire.SLEEP_TOKENS_WIRE, 0);
                }
            }
        }
        if (self.keep_clear_areas) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(DisplayContentProtoWire.KEEP_CLEAR_AREAS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(DisplayContentProtoWire.KEEP_CLEAR_AREAS_WIRE, 0);
                }
            }
        }
        if (self.min_size_of_resizeable_task_dp != 0) {
            target.appendInt32(DisplayContentProtoWire.MIN_SIZE_OF_RESIZEABLE_TASK_DP_WIRE, self.min_size_of_resizeable_task_dp);
        }
        if (self.input_method_layering_target_identifier) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DisplayContentProtoWire.INPUT_METHOD_LAYERING_TARGET_IDENTIFIER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.input_method_input_target_identifier) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DisplayContentProtoWire.INPUT_METHOD_INPUT_TARGET_IDENTIFIER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.input_method_control_target_identifier) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DisplayContentProtoWire.INPUT_METHOD_CONTROL_TARGET_IDENTIFIER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.current_focus_identifier) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DisplayContentProtoWire.CURRENT_FOCUS_IDENTIFIER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.remote_insets_control_target) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DisplayContentProtoWire.REMOTE_INSETS_CONTROL_TARGET_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.engagement_mode != 0) {
            target.appendInt32(DisplayContentProtoWire.ENGAGEMENT_MODE_WIRE, self.engagement_mode);
        }
    }
};
pub const DisplayContentProtoReader = struct {
    buf: gremlin.Reader,
    _window_container_buf: ?[]const u8 = null,
    _id: i32 = 0,
    _docked_task_divider_controller_buf: ?[]const u8 = null,
    _pinned_task_controller_buf: ?[]const u8 = null,
    _above_app_windows_offset: ?usize = null,
    _above_app_windows_last_offset: ?usize = null,
    _above_app_windows_cnt: usize = 0,
    _below_app_windows_offset: ?usize = null,
    _below_app_windows_last_offset: ?usize = null,
    _below_app_windows_cnt: usize = 0,
    _ime_windows_offset: ?usize = null,
    _ime_windows_last_offset: ?usize = null,
    _ime_windows_cnt: usize = 0,
    _dpi: i32 = 0,
    _display_info_buf: ?[]const u8 = null,
    _rotation: i32 = 0,
    _screen_rotation_animation_buf: ?[]const u8 = null,
    _display_frames_buf: ?[]const u8 = null,
    _surface_size: i32 = 0,
    _focused_app: ?[]const u8 = null,
    _app_transition_buf: ?[]const u8 = null,
    _opening_apps_offset: ?usize = null,
    _opening_apps_last_offset: ?usize = null,
    _opening_apps_cnt: usize = 0,
    _closing_apps_offset: ?usize = null,
    _closing_apps_last_offset: ?usize = null,
    _closing_apps_cnt: usize = 0,
    _changing_apps_offset: ?usize = null,
    _changing_apps_last_offset: ?usize = null,
    _changing_apps_cnt: usize = 0,
    _overlay_windows_offset: ?usize = null,
    _overlay_windows_last_offset: ?usize = null,
    _overlay_windows_cnt: usize = 0,
    _root_display_area_buf: ?[]const u8 = null,
    _single_task_instance: bool = false,
    _focused_root_task_id: i32 = 0,
    _resumed_activity_buf: ?[]const u8 = null,
    _tasks_offset: ?usize = null,
    _tasks_last_offset: ?usize = null,
    _tasks_cnt: usize = 0,
    _display_ready: bool = false,
    _input_method_target_buf: ?[]const u8 = null,
    _input_method_input_target_buf: ?[]const u8 = null,
    _input_method_control_target_buf: ?[]const u8 = null,
    _current_focus_buf: ?[]const u8 = null,
    _ime_insets_source_provider_buf: ?[]const u8 = null,
    _can_show_ime: bool = false,
    _display_rotation_buf: ?[]const u8 = null,
    _ime_policy: i32 = 0,
    _insets_source_providers_offset: ?usize = null,
    _insets_source_providers_last_offset: ?usize = null,
    _insets_source_providers_cnt: usize = 0,
    _is_sleeping: bool = false,
    _sleep_tokens_offset: ?usize = null,
    _sleep_tokens_last_offset: ?usize = null,
    _sleep_tokens_cnt: usize = 0,
    _keep_clear_areas_offset: ?usize = null,
    _keep_clear_areas_last_offset: ?usize = null,
    _keep_clear_areas_cnt: usize = 0,
    _min_size_of_resizeable_task_dp: i32 = 0,
    _input_method_layering_target_identifier_buf: ?[]const u8 = null,
    _input_method_input_target_identifier_buf: ?[]const u8 = null,
    _input_method_control_target_identifier_buf: ?[]const u8 = null,
    _current_focus_identifier_buf: ?[]const u8 = null,
    _remote_insets_control_target_buf: ?[]const u8 = null,
    _engagement_mode: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!DisplayContentProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = DisplayContentProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                DisplayContentProtoWire.WINDOW_CONTAINER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._window_container_buf = result.value;
                },
                DisplayContentProtoWire.ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._id = result.value;
                },
                DisplayContentProtoWire.DOCKED_TASK_DIVIDER_CONTROLLER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._docked_task_divider_controller_buf = result.value;
                },
                DisplayContentProtoWire.PINNED_TASK_CONTROLLER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._pinned_task_controller_buf = result.value;
                },
                DisplayContentProtoWire.ABOVE_APP_WINDOWS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._above_app_windows_offset == null) {
                        res._above_app_windows_offset = offset - result.size;
                    }
                    res._above_app_windows_last_offset = offset;
                    res._above_app_windows_cnt += 1;
                },
                DisplayContentProtoWire.BELOW_APP_WINDOWS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._below_app_windows_offset == null) {
                        res._below_app_windows_offset = offset - result.size;
                    }
                    res._below_app_windows_last_offset = offset;
                    res._below_app_windows_cnt += 1;
                },
                DisplayContentProtoWire.IME_WINDOWS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._ime_windows_offset == null) {
                        res._ime_windows_offset = offset - result.size;
                    }
                    res._ime_windows_last_offset = offset;
                    res._ime_windows_cnt += 1;
                },
                DisplayContentProtoWire.DPI_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._dpi = result.value;
                },
                DisplayContentProtoWire.DISPLAY_INFO_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._display_info_buf = result.value;
                },
                DisplayContentProtoWire.ROTATION_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._rotation = result.value;
                },
                DisplayContentProtoWire.SCREEN_ROTATION_ANIMATION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._screen_rotation_animation_buf = result.value;
                },
                DisplayContentProtoWire.DISPLAY_FRAMES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._display_frames_buf = result.value;
                },
                DisplayContentProtoWire.SURFACE_SIZE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._surface_size = result.value;
                },
                DisplayContentProtoWire.FOCUSED_APP_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._focused_app = result.value;
                },
                DisplayContentProtoWire.APP_TRANSITION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._app_transition_buf = result.value;
                },
                DisplayContentProtoWire.OPENING_APPS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._opening_apps_offset == null) {
                        res._opening_apps_offset = offset - result.size;
                    }
                    res._opening_apps_last_offset = offset;
                    res._opening_apps_cnt += 1;
                },
                DisplayContentProtoWire.CLOSING_APPS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._closing_apps_offset == null) {
                        res._closing_apps_offset = offset - result.size;
                    }
                    res._closing_apps_last_offset = offset;
                    res._closing_apps_cnt += 1;
                },
                DisplayContentProtoWire.CHANGING_APPS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._changing_apps_offset == null) {
                        res._changing_apps_offset = offset - result.size;
                    }
                    res._changing_apps_last_offset = offset;
                    res._changing_apps_cnt += 1;
                },
                DisplayContentProtoWire.OVERLAY_WINDOWS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._overlay_windows_offset == null) {
                        res._overlay_windows_offset = offset - result.size;
                    }
                    res._overlay_windows_last_offset = offset;
                    res._overlay_windows_cnt += 1;
                },
                DisplayContentProtoWire.ROOT_DISPLAY_AREA_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._root_display_area_buf = result.value;
                },
                DisplayContentProtoWire.SINGLE_TASK_INSTANCE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._single_task_instance = result.value;
                },
                DisplayContentProtoWire.FOCUSED_ROOT_TASK_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._focused_root_task_id = result.value;
                },
                DisplayContentProtoWire.RESUMED_ACTIVITY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._resumed_activity_buf = result.value;
                },
                DisplayContentProtoWire.TASKS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._tasks_offset == null) {
                        res._tasks_offset = offset - result.size;
                    }
                    res._tasks_last_offset = offset;
                    res._tasks_cnt += 1;
                },
                DisplayContentProtoWire.DISPLAY_READY_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._display_ready = result.value;
                },
                DisplayContentProtoWire.INPUT_METHOD_TARGET_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._input_method_target_buf = result.value;
                },
                DisplayContentProtoWire.INPUT_METHOD_INPUT_TARGET_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._input_method_input_target_buf = result.value;
                },
                DisplayContentProtoWire.INPUT_METHOD_CONTROL_TARGET_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._input_method_control_target_buf = result.value;
                },
                DisplayContentProtoWire.CURRENT_FOCUS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._current_focus_buf = result.value;
                },
                DisplayContentProtoWire.IME_INSETS_SOURCE_PROVIDER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ime_insets_source_provider_buf = result.value;
                },
                DisplayContentProtoWire.CAN_SHOW_IME_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._can_show_ime = result.value;
                },
                DisplayContentProtoWire.DISPLAY_ROTATION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._display_rotation_buf = result.value;
                },
                DisplayContentProtoWire.IME_POLICY_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._ime_policy = result.value;
                },
                DisplayContentProtoWire.INSETS_SOURCE_PROVIDERS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._insets_source_providers_offset == null) {
                        res._insets_source_providers_offset = offset - result.size;
                    }
                    res._insets_source_providers_last_offset = offset;
                    res._insets_source_providers_cnt += 1;
                },
                DisplayContentProtoWire.IS_SLEEPING_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_sleeping = result.value;
                },
                DisplayContentProtoWire.SLEEP_TOKENS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._sleep_tokens_offset == null) {
                        res._sleep_tokens_offset = offset - result.size;
                    }
                    res._sleep_tokens_last_offset = offset;
                    res._sleep_tokens_cnt += 1;
                },
                DisplayContentProtoWire.KEEP_CLEAR_AREAS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._keep_clear_areas_offset == null) {
                        res._keep_clear_areas_offset = offset - result.size;
                    }
                    res._keep_clear_areas_last_offset = offset;
                    res._keep_clear_areas_cnt += 1;
                },
                DisplayContentProtoWire.MIN_SIZE_OF_RESIZEABLE_TASK_DP_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._min_size_of_resizeable_task_dp = result.value;
                },
                DisplayContentProtoWire.INPUT_METHOD_LAYERING_TARGET_IDENTIFIER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._input_method_layering_target_identifier_buf = result.value;
                },
                DisplayContentProtoWire.INPUT_METHOD_INPUT_TARGET_IDENTIFIER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._input_method_input_target_identifier_buf = result.value;
                },
                DisplayContentProtoWire.INPUT_METHOD_CONTROL_TARGET_IDENTIFIER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._input_method_control_target_identifier_buf = result.value;
                },
                DisplayContentProtoWire.CURRENT_FOCUS_IDENTIFIER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._current_focus_identifier_buf = result.value;
                },
                DisplayContentProtoWire.REMOTE_INSETS_CONTROL_TARGET_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._remote_insets_control_target_buf = result.value;
                },
                DisplayContentProtoWire.ENGAGEMENT_MODE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._engagement_mode = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getWindowContainer(self: *const DisplayContentProtoReader) gremlin.Error!WindowContainerProtoReader {
        if (self._window_container_buf) |buf| {
            return try WindowContainerProtoReader.init(buf);
        }
        return try WindowContainerProtoReader.init(&[_]u8{});
    }
    pub inline fn getId(self: *const DisplayContentProtoReader) i32 {
        return self._id;
    }
    pub fn getDockedTaskDividerController(self: *const DisplayContentProtoReader) gremlin.Error!DockedTaskDividerControllerProtoReader {
        if (self._docked_task_divider_controller_buf) |buf| {
            return try DockedTaskDividerControllerProtoReader.init(buf);
        }
        return try DockedTaskDividerControllerProtoReader.init(&[_]u8{});
    }
    pub fn getPinnedTaskController(self: *const DisplayContentProtoReader) gremlin.Error!PinnedTaskControllerProtoReader {
        if (self._pinned_task_controller_buf) |buf| {
            return try PinnedTaskControllerProtoReader.init(buf);
        }
        return try PinnedTaskControllerProtoReader.init(&[_]u8{});
    }
    pub fn aboveAppWindowsCount(self: *const DisplayContentProtoReader) usize {
        return self._above_app_windows_cnt;
    }
    pub fn aboveAppWindowsNext(self: *DisplayContentProtoReader) ?WindowTokenProtoReader {
        if (self._above_app_windows_offset == null) return null;
        const current_offset = self._above_app_windows_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = WindowTokenProtoReader.init(result.value) catch return null;
        if (self._above_app_windows_last_offset != null and current_offset >= self._above_app_windows_last_offset.?) {
            self._above_app_windows_offset = null;
            return msg;
        }
        if (self._above_app_windows_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._above_app_windows_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == DisplayContentProtoWire.ABOVE_APP_WINDOWS_WIRE) {
                self._above_app_windows_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._above_app_windows_offset = null;
        return msg;
    }
    pub fn belowAppWindowsCount(self: *const DisplayContentProtoReader) usize {
        return self._below_app_windows_cnt;
    }
    pub fn belowAppWindowsNext(self: *DisplayContentProtoReader) ?WindowTokenProtoReader {
        if (self._below_app_windows_offset == null) return null;
        const current_offset = self._below_app_windows_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = WindowTokenProtoReader.init(result.value) catch return null;
        if (self._below_app_windows_last_offset != null and current_offset >= self._below_app_windows_last_offset.?) {
            self._below_app_windows_offset = null;
            return msg;
        }
        if (self._below_app_windows_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._below_app_windows_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == DisplayContentProtoWire.BELOW_APP_WINDOWS_WIRE) {
                self._below_app_windows_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._below_app_windows_offset = null;
        return msg;
    }
    pub fn imeWindowsCount(self: *const DisplayContentProtoReader) usize {
        return self._ime_windows_cnt;
    }
    pub fn imeWindowsNext(self: *DisplayContentProtoReader) ?WindowTokenProtoReader {
        if (self._ime_windows_offset == null) return null;
        const current_offset = self._ime_windows_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = WindowTokenProtoReader.init(result.value) catch return null;
        if (self._ime_windows_last_offset != null and current_offset >= self._ime_windows_last_offset.?) {
            self._ime_windows_offset = null;
            return msg;
        }
        if (self._ime_windows_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._ime_windows_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == DisplayContentProtoWire.IME_WINDOWS_WIRE) {
                self._ime_windows_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._ime_windows_offset = null;
        return msg;
    }
    pub inline fn getDpi(self: *const DisplayContentProtoReader) i32 {
        return self._dpi;
    }
    pub fn getDisplayInfo(self: *const DisplayContentProtoReader) gremlin.Error!displayinfo.DisplayInfoProtoReader {
        if (self._display_info_buf) |buf| {
            return try displayinfo.DisplayInfoProtoReader.init(buf);
        }
        return try displayinfo.DisplayInfoProtoReader.init(&[_]u8{});
    }
    pub inline fn getRotation(self: *const DisplayContentProtoReader) i32 {
        return self._rotation;
    }
    pub fn getScreenRotationAnimation(self: *const DisplayContentProtoReader) gremlin.Error!ScreenRotationAnimationProtoReader {
        if (self._screen_rotation_animation_buf) |buf| {
            return try ScreenRotationAnimationProtoReader.init(buf);
        }
        return try ScreenRotationAnimationProtoReader.init(&[_]u8{});
    }
    pub fn getDisplayFrames(self: *const DisplayContentProtoReader) gremlin.Error!DisplayFramesProtoReader {
        if (self._display_frames_buf) |buf| {
            return try DisplayFramesProtoReader.init(buf);
        }
        return try DisplayFramesProtoReader.init(&[_]u8{});
    }
    pub inline fn getSurfaceSize(self: *const DisplayContentProtoReader) i32 {
        return self._surface_size;
    }
    pub inline fn getFocusedApp(self: *const DisplayContentProtoReader) []const u8 {
        return self._focused_app orelse &[_]u8{};
    }
    pub fn getAppTransition(self: *const DisplayContentProtoReader) gremlin.Error!AppTransitionProtoReader {
        if (self._app_transition_buf) |buf| {
            return try AppTransitionProtoReader.init(buf);
        }
        return try AppTransitionProtoReader.init(&[_]u8{});
    }
    pub fn openingAppsCount(self: *const DisplayContentProtoReader) usize {
        return self._opening_apps_cnt;
    }
    pub fn openingAppsNext(self: *DisplayContentProtoReader) ?IdentifierProtoReader {
        if (self._opening_apps_offset == null) return null;
        const current_offset = self._opening_apps_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = IdentifierProtoReader.init(result.value) catch return null;
        if (self._opening_apps_last_offset != null and current_offset >= self._opening_apps_last_offset.?) {
            self._opening_apps_offset = null;
            return msg;
        }
        if (self._opening_apps_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._opening_apps_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == DisplayContentProtoWire.OPENING_APPS_WIRE) {
                self._opening_apps_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._opening_apps_offset = null;
        return msg;
    }
    pub fn closingAppsCount(self: *const DisplayContentProtoReader) usize {
        return self._closing_apps_cnt;
    }
    pub fn closingAppsNext(self: *DisplayContentProtoReader) ?IdentifierProtoReader {
        if (self._closing_apps_offset == null) return null;
        const current_offset = self._closing_apps_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = IdentifierProtoReader.init(result.value) catch return null;
        if (self._closing_apps_last_offset != null and current_offset >= self._closing_apps_last_offset.?) {
            self._closing_apps_offset = null;
            return msg;
        }
        if (self._closing_apps_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._closing_apps_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == DisplayContentProtoWire.CLOSING_APPS_WIRE) {
                self._closing_apps_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._closing_apps_offset = null;
        return msg;
    }
    pub fn changingAppsCount(self: *const DisplayContentProtoReader) usize {
        return self._changing_apps_cnt;
    }
    pub fn changingAppsNext(self: *DisplayContentProtoReader) ?IdentifierProtoReader {
        if (self._changing_apps_offset == null) return null;
        const current_offset = self._changing_apps_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = IdentifierProtoReader.init(result.value) catch return null;
        if (self._changing_apps_last_offset != null and current_offset >= self._changing_apps_last_offset.?) {
            self._changing_apps_offset = null;
            return msg;
        }
        if (self._changing_apps_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._changing_apps_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == DisplayContentProtoWire.CHANGING_APPS_WIRE) {
                self._changing_apps_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._changing_apps_offset = null;
        return msg;
    }
    pub fn overlayWindowsCount(self: *const DisplayContentProtoReader) usize {
        return self._overlay_windows_cnt;
    }
    pub fn overlayWindowsNext(self: *DisplayContentProtoReader) ?WindowTokenProtoReader {
        if (self._overlay_windows_offset == null) return null;
        const current_offset = self._overlay_windows_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = WindowTokenProtoReader.init(result.value) catch return null;
        if (self._overlay_windows_last_offset != null and current_offset >= self._overlay_windows_last_offset.?) {
            self._overlay_windows_offset = null;
            return msg;
        }
        if (self._overlay_windows_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._overlay_windows_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == DisplayContentProtoWire.OVERLAY_WINDOWS_WIRE) {
                self._overlay_windows_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._overlay_windows_offset = null;
        return msg;
    }
    pub fn getRootDisplayArea(self: *const DisplayContentProtoReader) gremlin.Error!DisplayAreaProtoReader {
        if (self._root_display_area_buf) |buf| {
            return try DisplayAreaProtoReader.init(buf);
        }
        return try DisplayAreaProtoReader.init(&[_]u8{});
    }
    pub inline fn getSingleTaskInstance(self: *const DisplayContentProtoReader) bool {
        return self._single_task_instance;
    }
    pub inline fn getFocusedRootTaskId(self: *const DisplayContentProtoReader) i32 {
        return self._focused_root_task_id;
    }
    pub fn getResumedActivity(self: *const DisplayContentProtoReader) gremlin.Error!IdentifierProtoReader {
        if (self._resumed_activity_buf) |buf| {
            return try IdentifierProtoReader.init(buf);
        }
        return try IdentifierProtoReader.init(&[_]u8{});
    }
    pub fn tasksCount(self: *const DisplayContentProtoReader) usize {
        return self._tasks_cnt;
    }
    pub fn tasksNext(self: *DisplayContentProtoReader) ?TaskProtoReader {
        if (self._tasks_offset == null) return null;
        const current_offset = self._tasks_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = TaskProtoReader.init(result.value) catch return null;
        if (self._tasks_last_offset != null and current_offset >= self._tasks_last_offset.?) {
            self._tasks_offset = null;
            return msg;
        }
        if (self._tasks_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._tasks_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == DisplayContentProtoWire.TASKS_WIRE) {
                self._tasks_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._tasks_offset = null;
        return msg;
    }
    pub inline fn getDisplayReady(self: *const DisplayContentProtoReader) bool {
        return self._display_ready;
    }
    pub fn getInputMethodTarget(self: *const DisplayContentProtoReader) gremlin.Error!WindowStateProtoReader {
        if (self._input_method_target_buf) |buf| {
            return try WindowStateProtoReader.init(buf);
        }
        return try WindowStateProtoReader.init(&[_]u8{});
    }
    pub fn getInputMethodInputTarget(self: *const DisplayContentProtoReader) gremlin.Error!WindowStateProtoReader {
        if (self._input_method_input_target_buf) |buf| {
            return try WindowStateProtoReader.init(buf);
        }
        return try WindowStateProtoReader.init(&[_]u8{});
    }
    pub fn getInputMethodControlTarget(self: *const DisplayContentProtoReader) gremlin.Error!WindowStateProtoReader {
        if (self._input_method_control_target_buf) |buf| {
            return try WindowStateProtoReader.init(buf);
        }
        return try WindowStateProtoReader.init(&[_]u8{});
    }
    pub fn getCurrentFocus(self: *const DisplayContentProtoReader) gremlin.Error!WindowStateProtoReader {
        if (self._current_focus_buf) |buf| {
            return try WindowStateProtoReader.init(buf);
        }
        return try WindowStateProtoReader.init(&[_]u8{});
    }
    pub fn getImeInsetsSourceProvider(self: *const DisplayContentProtoReader) gremlin.Error!ImeInsetsSourceProviderProtoReader {
        if (self._ime_insets_source_provider_buf) |buf| {
            return try ImeInsetsSourceProviderProtoReader.init(buf);
        }
        return try ImeInsetsSourceProviderProtoReader.init(&[_]u8{});
    }
    pub inline fn getCanShowIme(self: *const DisplayContentProtoReader) bool {
        return self._can_show_ime;
    }
    pub fn getDisplayRotation(self: *const DisplayContentProtoReader) gremlin.Error!DisplayRotationProtoReader {
        if (self._display_rotation_buf) |buf| {
            return try DisplayRotationProtoReader.init(buf);
        }
        return try DisplayRotationProtoReader.init(&[_]u8{});
    }
    pub inline fn getImePolicy(self: *const DisplayContentProtoReader) i32 {
        return self._ime_policy;
    }
    pub fn insetsSourceProvidersCount(self: *const DisplayContentProtoReader) usize {
        return self._insets_source_providers_cnt;
    }
    pub fn insetsSourceProvidersNext(self: *DisplayContentProtoReader) ?InsetsSourceProviderProtoReader {
        if (self._insets_source_providers_offset == null) return null;
        const current_offset = self._insets_source_providers_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = InsetsSourceProviderProtoReader.init(result.value) catch return null;
        if (self._insets_source_providers_last_offset != null and current_offset >= self._insets_source_providers_last_offset.?) {
            self._insets_source_providers_offset = null;
            return msg;
        }
        if (self._insets_source_providers_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._insets_source_providers_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == DisplayContentProtoWire.INSETS_SOURCE_PROVIDERS_WIRE) {
                self._insets_source_providers_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._insets_source_providers_offset = null;
        return msg;
    }
    pub inline fn getIsSleeping(self: *const DisplayContentProtoReader) bool {
        return self._is_sleeping;
    }
    pub fn sleepTokensCount(self: *const DisplayContentProtoReader) usize {
        return self._sleep_tokens_cnt;
    }
    pub fn sleepTokensNext(self: *DisplayContentProtoReader) ?[]const u8 {
        if (self._sleep_tokens_offset == null) return null;
        const current_offset = self._sleep_tokens_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._sleep_tokens_last_offset != null and current_offset >= self._sleep_tokens_last_offset.?) {
            self._sleep_tokens_offset = null;
            return result.value;
        }
        if (self._sleep_tokens_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._sleep_tokens_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == DisplayContentProtoWire.SLEEP_TOKENS_WIRE) {
                self._sleep_tokens_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._sleep_tokens_offset = null;
        return result.value;
    }
    pub fn keepClearAreasCount(self: *const DisplayContentProtoReader) usize {
        return self._keep_clear_areas_cnt;
    }
    pub fn keepClearAreasNext(self: *DisplayContentProtoReader) ?rect.RectProtoReader {
        if (self._keep_clear_areas_offset == null) return null;
        const current_offset = self._keep_clear_areas_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = rect.RectProtoReader.init(result.value) catch return null;
        if (self._keep_clear_areas_last_offset != null and current_offset >= self._keep_clear_areas_last_offset.?) {
            self._keep_clear_areas_offset = null;
            return msg;
        }
        if (self._keep_clear_areas_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._keep_clear_areas_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == DisplayContentProtoWire.KEEP_CLEAR_AREAS_WIRE) {
                self._keep_clear_areas_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._keep_clear_areas_offset = null;
        return msg;
    }
    pub inline fn getMinSizeOfResizeableTaskDp(self: *const DisplayContentProtoReader) i32 {
        return self._min_size_of_resizeable_task_dp;
    }
    pub fn getInputMethodLayeringTargetIdentifier(self: *const DisplayContentProtoReader) gremlin.Error!IdentifierProtoReader {
        if (self._input_method_layering_target_identifier_buf) |buf| {
            return try IdentifierProtoReader.init(buf);
        }
        return try IdentifierProtoReader.init(&[_]u8{});
    }
    pub fn getInputMethodInputTargetIdentifier(self: *const DisplayContentProtoReader) gremlin.Error!IdentifierProtoReader {
        if (self._input_method_input_target_identifier_buf) |buf| {
            return try IdentifierProtoReader.init(buf);
        }
        return try IdentifierProtoReader.init(&[_]u8{});
    }
    pub fn getInputMethodControlTargetIdentifier(self: *const DisplayContentProtoReader) gremlin.Error!IdentifierProtoReader {
        if (self._input_method_control_target_identifier_buf) |buf| {
            return try IdentifierProtoReader.init(buf);
        }
        return try IdentifierProtoReader.init(&[_]u8{});
    }
    pub fn getCurrentFocusIdentifier(self: *const DisplayContentProtoReader) gremlin.Error!IdentifierProtoReader {
        if (self._current_focus_identifier_buf) |buf| {
            return try IdentifierProtoReader.init(buf);
        }
        return try IdentifierProtoReader.init(&[_]u8{});
    }
    pub fn getRemoteInsetsControlTarget(self: *const DisplayContentProtoReader) gremlin.Error!RemoteInsetsControlTargetProtoReader {
        if (self._remote_insets_control_target_buf) |buf| {
            return try RemoteInsetsControlTargetProtoReader.init(buf);
        }
        return try RemoteInsetsControlTargetProtoReader.init(&[_]u8{});
    }
    pub inline fn getEngagementMode(self: *const DisplayContentProtoReader) i32 {
        return self._engagement_mode;
    }
};
const DisplayAreaProtoWire = struct {
    const WINDOW_CONTAINER_WIRE: gremlin.ProtoWireNumber = 1;
    const NAME_WIRE: gremlin.ProtoWireNumber = 2;
    const CHILDREN_WIRE: gremlin.ProtoWireNumber = 3;
    const IS_TASK_DISPLAY_AREA_WIRE: gremlin.ProtoWireNumber = 4;
    const IS_ROOT_DISPLAY_AREA_WIRE: gremlin.ProtoWireNumber = 5;
    const FEATURE_ID_WIRE: gremlin.ProtoWireNumber = 6;
    const IS_ORGANIZED_WIRE: gremlin.ProtoWireNumber = 7;
    const IS_IGNORING_ORIENTATION_REQUEST_WIRE: gremlin.ProtoWireNumber = 8;
};
pub const DisplayAreaProto = struct {
    // fields
    window_container: ?WindowContainerProto = null,
    name: ?[]const u8 = null,
    children: ?[]const ?DisplayAreaChildProto = null,
    is_task_display_area: bool = false,
    is_root_display_area: bool = false,
    feature_id: i32 = 0,
    is_organized: bool = false,
    is_ignoring_orientation_request: bool = false,
    pub fn calcProtobufSize(self: *const DisplayAreaProto) usize {
        var res: usize = 0;
        if (self.window_container) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DisplayAreaProtoWire.WINDOW_CONTAINER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(DisplayAreaProtoWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.children) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(DisplayAreaProtoWire.CHILDREN_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.is_task_display_area != false) {
            res += gremlin.sizes.sizeWireNumber(DisplayAreaProtoWire.IS_TASK_DISPLAY_AREA_WIRE) + gremlin.sizes.sizeBool(self.is_task_display_area);
        }
        if (self.is_root_display_area != false) {
            res += gremlin.sizes.sizeWireNumber(DisplayAreaProtoWire.IS_ROOT_DISPLAY_AREA_WIRE) + gremlin.sizes.sizeBool(self.is_root_display_area);
        }
        if (self.feature_id != 0) {
            res += gremlin.sizes.sizeWireNumber(DisplayAreaProtoWire.FEATURE_ID_WIRE) + gremlin.sizes.sizeI32(self.feature_id);
        }
        if (self.is_organized != false) {
            res += gremlin.sizes.sizeWireNumber(DisplayAreaProtoWire.IS_ORGANIZED_WIRE) + gremlin.sizes.sizeBool(self.is_organized);
        }
        if (self.is_ignoring_orientation_request != false) {
            res += gremlin.sizes.sizeWireNumber(DisplayAreaProtoWire.IS_IGNORING_ORIENTATION_REQUEST_WIRE) + gremlin.sizes.sizeBool(self.is_ignoring_orientation_request);
        }
        return res;
    }
    pub fn encode(self: *const DisplayAreaProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const DisplayAreaProto, target: *gremlin.Writer) void {
        if (self.window_container) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DisplayAreaProtoWire.WINDOW_CONTAINER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(DisplayAreaProtoWire.NAME_WIRE, v);
            }
        }
        if (self.children) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(DisplayAreaProtoWire.CHILDREN_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(DisplayAreaProtoWire.CHILDREN_WIRE, 0);
                }
            }
        }
        if (self.is_task_display_area != false) {
            target.appendBool(DisplayAreaProtoWire.IS_TASK_DISPLAY_AREA_WIRE, self.is_task_display_area);
        }
        if (self.is_root_display_area != false) {
            target.appendBool(DisplayAreaProtoWire.IS_ROOT_DISPLAY_AREA_WIRE, self.is_root_display_area);
        }
        if (self.feature_id != 0) {
            target.appendInt32(DisplayAreaProtoWire.FEATURE_ID_WIRE, self.feature_id);
        }
        if (self.is_organized != false) {
            target.appendBool(DisplayAreaProtoWire.IS_ORGANIZED_WIRE, self.is_organized);
        }
        if (self.is_ignoring_orientation_request != false) {
            target.appendBool(DisplayAreaProtoWire.IS_IGNORING_ORIENTATION_REQUEST_WIRE, self.is_ignoring_orientation_request);
        }
    }
};
pub const DisplayAreaProtoReader = struct {
    buf: gremlin.Reader,
    _window_container_buf: ?[]const u8 = null,
    _name: ?[]const u8 = null,
    _children_offset: ?usize = null,
    _children_last_offset: ?usize = null,
    _children_cnt: usize = 0,
    _is_task_display_area: bool = false,
    _is_root_display_area: bool = false,
    _feature_id: i32 = 0,
    _is_organized: bool = false,
    _is_ignoring_orientation_request: bool = false,
    pub fn init(src: []const u8) gremlin.Error!DisplayAreaProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = DisplayAreaProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                DisplayAreaProtoWire.WINDOW_CONTAINER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._window_container_buf = result.value;
                },
                DisplayAreaProtoWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                DisplayAreaProtoWire.CHILDREN_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._children_offset == null) {
                        res._children_offset = offset - result.size;
                    }
                    res._children_last_offset = offset;
                    res._children_cnt += 1;
                },
                DisplayAreaProtoWire.IS_TASK_DISPLAY_AREA_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_task_display_area = result.value;
                },
                DisplayAreaProtoWire.IS_ROOT_DISPLAY_AREA_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_root_display_area = result.value;
                },
                DisplayAreaProtoWire.FEATURE_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._feature_id = result.value;
                },
                DisplayAreaProtoWire.IS_ORGANIZED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_organized = result.value;
                },
                DisplayAreaProtoWire.IS_IGNORING_ORIENTATION_REQUEST_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_ignoring_orientation_request = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getWindowContainer(self: *const DisplayAreaProtoReader) gremlin.Error!WindowContainerProtoReader {
        if (self._window_container_buf) |buf| {
            return try WindowContainerProtoReader.init(buf);
        }
        return try WindowContainerProtoReader.init(&[_]u8{});
    }
    pub inline fn getName(self: *const DisplayAreaProtoReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub fn childrenCount(self: *const DisplayAreaProtoReader) usize {
        return self._children_cnt;
    }
    pub fn childrenNext(self: *DisplayAreaProtoReader) ?DisplayAreaChildProtoReader {
        if (self._children_offset == null) return null;
        const current_offset = self._children_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = DisplayAreaChildProtoReader.init(result.value) catch return null;
        if (self._children_last_offset != null and current_offset >= self._children_last_offset.?) {
            self._children_offset = null;
            return msg;
        }
        if (self._children_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._children_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == DisplayAreaProtoWire.CHILDREN_WIRE) {
                self._children_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._children_offset = null;
        return msg;
    }
    pub inline fn getIsTaskDisplayArea(self: *const DisplayAreaProtoReader) bool {
        return self._is_task_display_area;
    }
    pub inline fn getIsRootDisplayArea(self: *const DisplayAreaProtoReader) bool {
        return self._is_root_display_area;
    }
    pub inline fn getFeatureId(self: *const DisplayAreaProtoReader) i32 {
        return self._feature_id;
    }
    pub inline fn getIsOrganized(self: *const DisplayAreaProtoReader) bool {
        return self._is_organized;
    }
    pub inline fn getIsIgnoringOrientationRequest(self: *const DisplayAreaProtoReader) bool {
        return self._is_ignoring_orientation_request;
    }
};
const DisplayAreaChildProtoWire = struct {
    const DISPLAY_AREA_WIRE: gremlin.ProtoWireNumber = 1;
    const WINDOW_WIRE: gremlin.ProtoWireNumber = 2;
    const UNKNOWN_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const DisplayAreaChildProto = struct {
    // fields
    display_area: ?DisplayAreaProto = null,
    window: ?WindowTokenProto = null,
    unknown: ?[]const ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const DisplayAreaChildProto) usize {
        var res: usize = 0;
        if (self.display_area) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DisplayAreaChildProtoWire.DISPLAY_AREA_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.window) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DisplayAreaChildProtoWire.WINDOW_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.unknown) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(DisplayAreaChildProtoWire.UNKNOWN_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const DisplayAreaChildProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const DisplayAreaChildProto, target: *gremlin.Writer) void {
        if (self.display_area) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DisplayAreaChildProtoWire.DISPLAY_AREA_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.window) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DisplayAreaChildProtoWire.WINDOW_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.unknown) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(DisplayAreaChildProtoWire.UNKNOWN_WIRE, v);
                } else {
                    target.appendBytesTag(DisplayAreaChildProtoWire.UNKNOWN_WIRE, 0);
                }
            }
        }
    }
};
pub const DisplayAreaChildProtoReader = struct {
    buf: gremlin.Reader,
    _display_area_buf: ?[]const u8 = null,
    _window_buf: ?[]const u8 = null,
    _unknown_offset: ?usize = null,
    _unknown_last_offset: ?usize = null,
    _unknown_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!DisplayAreaChildProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = DisplayAreaChildProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                DisplayAreaChildProtoWire.DISPLAY_AREA_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._display_area_buf = result.value;
                },
                DisplayAreaChildProtoWire.WINDOW_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._window_buf = result.value;
                },
                DisplayAreaChildProtoWire.UNKNOWN_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._unknown_offset == null) {
                        res._unknown_offset = offset - result.size;
                    }
                    res._unknown_last_offset = offset;
                    res._unknown_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getDisplayArea(self: *const DisplayAreaChildProtoReader) gremlin.Error!DisplayAreaProtoReader {
        if (self._display_area_buf) |buf| {
            return try DisplayAreaProtoReader.init(buf);
        }
        return try DisplayAreaProtoReader.init(&[_]u8{});
    }
    pub fn getWindow(self: *const DisplayAreaChildProtoReader) gremlin.Error!WindowTokenProtoReader {
        if (self._window_buf) |buf| {
            return try WindowTokenProtoReader.init(buf);
        }
        return try WindowTokenProtoReader.init(&[_]u8{});
    }
    pub fn unknownCount(self: *const DisplayAreaChildProtoReader) usize {
        return self._unknown_cnt;
    }
    pub fn unknownNext(self: *DisplayAreaChildProtoReader) ?[]const u8 {
        if (self._unknown_offset == null) return null;
        const current_offset = self._unknown_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._unknown_last_offset != null and current_offset >= self._unknown_last_offset.?) {
            self._unknown_offset = null;
            return result.value;
        }
        if (self._unknown_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._unknown_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == DisplayAreaChildProtoWire.UNKNOWN_WIRE) {
                self._unknown_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._unknown_offset = null;
        return result.value;
    }
};
const DisplayFramesProtoWire = struct {
    const STABLE_BOUNDS_WIRE: gremlin.ProtoWireNumber = 1;
    const DOCK_WIRE: gremlin.ProtoWireNumber = 2;
    const CURRENT_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const DisplayFramesProto = struct {
    // fields
    stable_bounds: ?rect.RectProto = null,
    dock: ?rect.RectProto = null,
    current: ?rect.RectProto = null,
    pub fn calcProtobufSize(self: *const DisplayFramesProto) usize {
        var res: usize = 0;
        if (self.stable_bounds) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DisplayFramesProtoWire.STABLE_BOUNDS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.dock) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DisplayFramesProtoWire.DOCK_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.current) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DisplayFramesProtoWire.CURRENT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const DisplayFramesProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const DisplayFramesProto, target: *gremlin.Writer) void {
        if (self.stable_bounds) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DisplayFramesProtoWire.STABLE_BOUNDS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.dock) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DisplayFramesProtoWire.DOCK_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.current) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DisplayFramesProtoWire.CURRENT_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const DisplayFramesProtoReader = struct {
    buf: gremlin.Reader,
    _stable_bounds_buf: ?[]const u8 = null,
    _dock_buf: ?[]const u8 = null,
    _current_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!DisplayFramesProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = DisplayFramesProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                DisplayFramesProtoWire.STABLE_BOUNDS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._stable_bounds_buf = result.value;
                },
                DisplayFramesProtoWire.DOCK_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dock_buf = result.value;
                },
                DisplayFramesProtoWire.CURRENT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._current_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getStableBounds(self: *const DisplayFramesProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._stable_bounds_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getDock(self: *const DisplayFramesProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._dock_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getCurrent(self: *const DisplayFramesProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._current_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
};
const DisplayRotationProtoWire = struct {
    const ROTATION_WIRE: gremlin.ProtoWireNumber = 1;
    const FROZEN_TO_USER_ROTATION_WIRE: gremlin.ProtoWireNumber = 2;
    const USER_ROTATION_WIRE: gremlin.ProtoWireNumber = 3;
    const FIXED_TO_USER_ROTATION_MODE_WIRE: gremlin.ProtoWireNumber = 4;
    const LAST_ORIENTATION_WIRE: gremlin.ProtoWireNumber = 5;
    const IS_FIXED_TO_USER_ROTATION_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const DisplayRotationProto = struct {
    // fields
    rotation: i32 = 0,
    frozen_to_user_rotation: bool = false,
    user_rotation: i32 = 0,
    fixed_to_user_rotation_mode: i32 = 0,
    last_orientation: i32 = 0,
    is_fixed_to_user_rotation: bool = false,
    pub fn calcProtobufSize(self: *const DisplayRotationProto) usize {
        var res: usize = 0;
        if (self.rotation != 0) {
            res += gremlin.sizes.sizeWireNumber(DisplayRotationProtoWire.ROTATION_WIRE) + gremlin.sizes.sizeI32(self.rotation);
        }
        if (self.frozen_to_user_rotation != false) {
            res += gremlin.sizes.sizeWireNumber(DisplayRotationProtoWire.FROZEN_TO_USER_ROTATION_WIRE) + gremlin.sizes.sizeBool(self.frozen_to_user_rotation);
        }
        if (self.user_rotation != 0) {
            res += gremlin.sizes.sizeWireNumber(DisplayRotationProtoWire.USER_ROTATION_WIRE) + gremlin.sizes.sizeI32(self.user_rotation);
        }
        if (self.fixed_to_user_rotation_mode != 0) {
            res += gremlin.sizes.sizeWireNumber(DisplayRotationProtoWire.FIXED_TO_USER_ROTATION_MODE_WIRE) + gremlin.sizes.sizeI32(self.fixed_to_user_rotation_mode);
        }
        if (self.last_orientation != 0) {
            res += gremlin.sizes.sizeWireNumber(DisplayRotationProtoWire.LAST_ORIENTATION_WIRE) + gremlin.sizes.sizeI32(self.last_orientation);
        }
        if (self.is_fixed_to_user_rotation != false) {
            res += gremlin.sizes.sizeWireNumber(DisplayRotationProtoWire.IS_FIXED_TO_USER_ROTATION_WIRE) + gremlin.sizes.sizeBool(self.is_fixed_to_user_rotation);
        }
        return res;
    }
    pub fn encode(self: *const DisplayRotationProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const DisplayRotationProto, target: *gremlin.Writer) void {
        if (self.rotation != 0) {
            target.appendInt32(DisplayRotationProtoWire.ROTATION_WIRE, self.rotation);
        }
        if (self.frozen_to_user_rotation != false) {
            target.appendBool(DisplayRotationProtoWire.FROZEN_TO_USER_ROTATION_WIRE, self.frozen_to_user_rotation);
        }
        if (self.user_rotation != 0) {
            target.appendInt32(DisplayRotationProtoWire.USER_ROTATION_WIRE, self.user_rotation);
        }
        if (self.fixed_to_user_rotation_mode != 0) {
            target.appendInt32(DisplayRotationProtoWire.FIXED_TO_USER_ROTATION_MODE_WIRE, self.fixed_to_user_rotation_mode);
        }
        if (self.last_orientation != 0) {
            target.appendInt32(DisplayRotationProtoWire.LAST_ORIENTATION_WIRE, self.last_orientation);
        }
        if (self.is_fixed_to_user_rotation != false) {
            target.appendBool(DisplayRotationProtoWire.IS_FIXED_TO_USER_ROTATION_WIRE, self.is_fixed_to_user_rotation);
        }
    }
};
pub const DisplayRotationProtoReader = struct {
    buf: gremlin.Reader,
    _rotation: i32 = 0,
    _frozen_to_user_rotation: bool = false,
    _user_rotation: i32 = 0,
    _fixed_to_user_rotation_mode: i32 = 0,
    _last_orientation: i32 = 0,
    _is_fixed_to_user_rotation: bool = false,
    pub fn init(src: []const u8) gremlin.Error!DisplayRotationProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = DisplayRotationProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                DisplayRotationProtoWire.ROTATION_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._rotation = result.value;
                },
                DisplayRotationProtoWire.FROZEN_TO_USER_ROTATION_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._frozen_to_user_rotation = result.value;
                },
                DisplayRotationProtoWire.USER_ROTATION_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._user_rotation = result.value;
                },
                DisplayRotationProtoWire.FIXED_TO_USER_ROTATION_MODE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._fixed_to_user_rotation_mode = result.value;
                },
                DisplayRotationProtoWire.LAST_ORIENTATION_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._last_orientation = result.value;
                },
                DisplayRotationProtoWire.IS_FIXED_TO_USER_ROTATION_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_fixed_to_user_rotation = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getRotation(self: *const DisplayRotationProtoReader) i32 {
        return self._rotation;
    }
    pub inline fn getFrozenToUserRotation(self: *const DisplayRotationProtoReader) bool {
        return self._frozen_to_user_rotation;
    }
    pub inline fn getUserRotation(self: *const DisplayRotationProtoReader) i32 {
        return self._user_rotation;
    }
    pub inline fn getFixedToUserRotationMode(self: *const DisplayRotationProtoReader) i32 {
        return self._fixed_to_user_rotation_mode;
    }
    pub inline fn getLastOrientation(self: *const DisplayRotationProtoReader) i32 {
        return self._last_orientation;
    }
    pub inline fn getIsFixedToUserRotation(self: *const DisplayRotationProtoReader) bool {
        return self._is_fixed_to_user_rotation;
    }
};
const DockedTaskDividerControllerProtoWire = struct {
    const MINIMIZED_DOCK_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const DockedTaskDividerControllerProto = struct {
    // fields
    minimized_dock: bool = false,
    pub fn calcProtobufSize(self: *const DockedTaskDividerControllerProto) usize {
        var res: usize = 0;
        if (self.minimized_dock != false) {
            res += gremlin.sizes.sizeWireNumber(DockedTaskDividerControllerProtoWire.MINIMIZED_DOCK_WIRE) + gremlin.sizes.sizeBool(self.minimized_dock);
        }
        return res;
    }
    pub fn encode(self: *const DockedTaskDividerControllerProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const DockedTaskDividerControllerProto, target: *gremlin.Writer) void {
        if (self.minimized_dock != false) {
            target.appendBool(DockedTaskDividerControllerProtoWire.MINIMIZED_DOCK_WIRE, self.minimized_dock);
        }
    }
};
pub const DockedTaskDividerControllerProtoReader = struct {
    buf: gremlin.Reader,
    _minimized_dock: bool = false,
    pub fn init(src: []const u8) gremlin.Error!DockedTaskDividerControllerProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = DockedTaskDividerControllerProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                DockedTaskDividerControllerProtoWire.MINIMIZED_DOCK_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._minimized_dock = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getMinimizedDock(self: *const DockedTaskDividerControllerProtoReader) bool {
        return self._minimized_dock;
    }
};
const PinnedTaskControllerProtoWire = struct {
    const DEFAULT_BOUNDS_WIRE: gremlin.ProtoWireNumber = 1;
    const MOVEMENT_BOUNDS_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const PinnedTaskControllerProto = struct {
    // fields
    default_bounds: ?rect.RectProto = null,
    movement_bounds: ?rect.RectProto = null,
    pub fn calcProtobufSize(self: *const PinnedTaskControllerProto) usize {
        var res: usize = 0;
        if (self.default_bounds) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(PinnedTaskControllerProtoWire.DEFAULT_BOUNDS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.movement_bounds) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(PinnedTaskControllerProtoWire.MOVEMENT_BOUNDS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const PinnedTaskControllerProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const PinnedTaskControllerProto, target: *gremlin.Writer) void {
        if (self.default_bounds) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(PinnedTaskControllerProtoWire.DEFAULT_BOUNDS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.movement_bounds) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(PinnedTaskControllerProtoWire.MOVEMENT_BOUNDS_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const PinnedTaskControllerProtoReader = struct {
    buf: gremlin.Reader,
    _default_bounds_buf: ?[]const u8 = null,
    _movement_bounds_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!PinnedTaskControllerProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = PinnedTaskControllerProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                PinnedTaskControllerProtoWire.DEFAULT_BOUNDS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._default_bounds_buf = result.value;
                },
                PinnedTaskControllerProtoWire.MOVEMENT_BOUNDS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._movement_bounds_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getDefaultBounds(self: *const PinnedTaskControllerProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._default_bounds_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getMovementBounds(self: *const PinnedTaskControllerProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._movement_bounds_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
};
const TaskProtoWire = struct {
    const WINDOW_CONTAINER_WIRE: gremlin.ProtoWireNumber = 1;
    const ID_WIRE: gremlin.ProtoWireNumber = 2;
    const FILLS_PARENT_WIRE: gremlin.ProtoWireNumber = 4;
    const BOUNDS_WIRE: gremlin.ProtoWireNumber = 5;
    const DISPLAYED_BOUNDS_WIRE: gremlin.ProtoWireNumber = 6;
    const DEFER_REMOVAL_WIRE: gremlin.ProtoWireNumber = 7;
    const SURFACE_WIDTH_WIRE: gremlin.ProtoWireNumber = 8;
    const SURFACE_HEIGHT_WIRE: gremlin.ProtoWireNumber = 9;
    const TASKS_WIRE: gremlin.ProtoWireNumber = 10;
    const ACTIVITIES_WIRE: gremlin.ProtoWireNumber = 11;
    const RESUMED_ACTIVITY_WIRE: gremlin.ProtoWireNumber = 12;
    const REAL_ACTIVITY_WIRE: gremlin.ProtoWireNumber = 13;
    const ORIG_ACTIVITY_WIRE: gremlin.ProtoWireNumber = 14;
    const DISPLAY_ID_WIRE: gremlin.ProtoWireNumber = 15;
    const ROOT_TASK_ID_WIRE: gremlin.ProtoWireNumber = 16;
    const ACTIVITY_TYPE_WIRE: gremlin.ProtoWireNumber = 17;
    const RESIZE_MODE_WIRE: gremlin.ProtoWireNumber = 18;
    const MIN_WIDTH_WIRE: gremlin.ProtoWireNumber = 19;
    const MIN_HEIGHT_WIRE: gremlin.ProtoWireNumber = 20;
    const ADJUSTED_BOUNDS_WIRE: gremlin.ProtoWireNumber = 21;
    const LAST_NON_FULLSCREEN_BOUNDS_WIRE: gremlin.ProtoWireNumber = 22;
    const ADJUSTED_FOR_IME_WIRE: gremlin.ProtoWireNumber = 23;
    const ADJUST_IME_AMOUNT_WIRE: gremlin.ProtoWireNumber = 24;
    const ADJUST_DIVIDER_AMOUNT_WIRE: gremlin.ProtoWireNumber = 25;
    const ANIMATING_BOUNDS_WIRE: gremlin.ProtoWireNumber = 26;
    const MINIMIZE_AMOUNT_WIRE: gremlin.ProtoWireNumber = 27;
    const CREATED_BY_ORGANIZER_WIRE: gremlin.ProtoWireNumber = 28;
    const AFFINITY_WIRE: gremlin.ProtoWireNumber = 29;
    const HAS_CHILD_PIP_ACTIVITY_WIRE: gremlin.ProtoWireNumber = 30;
    const TASK_FRAGMENT_WIRE: gremlin.ProtoWireNumber = 31;
    const TASK_NAME_WIRE: gremlin.ProtoWireNumber = 32;
};
pub const TaskProto = struct {
    // fields
    window_container: ?WindowContainerProto = null,
    id: i32 = 0,
    fills_parent: bool = false,
    bounds: ?rect.RectProto = null,
    displayed_bounds: ?rect.RectProto = null,
    defer_removal: bool = false,
    surface_width: i32 = 0,
    surface_height: i32 = 0,
    tasks: ?[]const ?TaskProto = null,
    activities: ?[]const ?ActivityRecordProto = null,
    resumed_activity: ?IdentifierProto = null,
    real_activity: ?[]const u8 = null,
    orig_activity: ?[]const u8 = null,
    display_id: i32 = 0,
    root_task_id: i32 = 0,
    activity_type: i32 = 0,
    resize_mode: i32 = 0,
    min_width: i32 = 0,
    min_height: i32 = 0,
    adjusted_bounds: ?rect.RectProto = null,
    last_non_fullscreen_bounds: ?rect.RectProto = null,
    adjusted_for_ime: bool = false,
    adjust_ime_amount: f32 = 0.0,
    adjust_divider_amount: f32 = 0.0,
    animating_bounds: bool = false,
    minimize_amount: f32 = 0.0,
    created_by_organizer: bool = false,
    affinity: ?[]const u8 = null,
    has_child_pip_activity: bool = false,
    task_fragment: ?TaskFragmentProto = null,
    task_name: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const TaskProto) usize {
        var res: usize = 0;
        if (self.window_container) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TaskProtoWire.WINDOW_CONTAINER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.id != 0) {
            res += gremlin.sizes.sizeWireNumber(TaskProtoWire.ID_WIRE) + gremlin.sizes.sizeI32(self.id);
        }
        if (self.fills_parent != false) {
            res += gremlin.sizes.sizeWireNumber(TaskProtoWire.FILLS_PARENT_WIRE) + gremlin.sizes.sizeBool(self.fills_parent);
        }
        if (self.bounds) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TaskProtoWire.BOUNDS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.displayed_bounds) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TaskProtoWire.DISPLAYED_BOUNDS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.defer_removal != false) {
            res += gremlin.sizes.sizeWireNumber(TaskProtoWire.DEFER_REMOVAL_WIRE) + gremlin.sizes.sizeBool(self.defer_removal);
        }
        if (self.surface_width != 0) {
            res += gremlin.sizes.sizeWireNumber(TaskProtoWire.SURFACE_WIDTH_WIRE) + gremlin.sizes.sizeI32(self.surface_width);
        }
        if (self.surface_height != 0) {
            res += gremlin.sizes.sizeWireNumber(TaskProtoWire.SURFACE_HEIGHT_WIRE) + gremlin.sizes.sizeI32(self.surface_height);
        }
        if (self.tasks) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TaskProtoWire.TASKS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.activities) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TaskProtoWire.ACTIVITIES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.resumed_activity) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TaskProtoWire.RESUMED_ACTIVITY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.real_activity) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TaskProtoWire.REAL_ACTIVITY_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.orig_activity) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TaskProtoWire.ORIG_ACTIVITY_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.display_id != 0) {
            res += gremlin.sizes.sizeWireNumber(TaskProtoWire.DISPLAY_ID_WIRE) + gremlin.sizes.sizeI32(self.display_id);
        }
        if (self.root_task_id != 0) {
            res += gremlin.sizes.sizeWireNumber(TaskProtoWire.ROOT_TASK_ID_WIRE) + gremlin.sizes.sizeI32(self.root_task_id);
        }
        if (self.activity_type != 0) {
            res += gremlin.sizes.sizeWireNumber(TaskProtoWire.ACTIVITY_TYPE_WIRE) + gremlin.sizes.sizeI32(self.activity_type);
        }
        if (self.resize_mode != 0) {
            res += gremlin.sizes.sizeWireNumber(TaskProtoWire.RESIZE_MODE_WIRE) + gremlin.sizes.sizeI32(self.resize_mode);
        }
        if (self.min_width != 0) {
            res += gremlin.sizes.sizeWireNumber(TaskProtoWire.MIN_WIDTH_WIRE) + gremlin.sizes.sizeI32(self.min_width);
        }
        if (self.min_height != 0) {
            res += gremlin.sizes.sizeWireNumber(TaskProtoWire.MIN_HEIGHT_WIRE) + gremlin.sizes.sizeI32(self.min_height);
        }
        if (self.adjusted_bounds) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TaskProtoWire.ADJUSTED_BOUNDS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.last_non_fullscreen_bounds) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TaskProtoWire.LAST_NON_FULLSCREEN_BOUNDS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.adjusted_for_ime != false) {
            res += gremlin.sizes.sizeWireNumber(TaskProtoWire.ADJUSTED_FOR_IME_WIRE) + gremlin.sizes.sizeBool(self.adjusted_for_ime);
        }
        if (self.adjust_ime_amount != 0.0) {
            res += gremlin.sizes.sizeWireNumber(TaskProtoWire.ADJUST_IME_AMOUNT_WIRE) + gremlin.sizes.sizeFloat(self.adjust_ime_amount);
        }
        if (self.adjust_divider_amount != 0.0) {
            res += gremlin.sizes.sizeWireNumber(TaskProtoWire.ADJUST_DIVIDER_AMOUNT_WIRE) + gremlin.sizes.sizeFloat(self.adjust_divider_amount);
        }
        if (self.animating_bounds != false) {
            res += gremlin.sizes.sizeWireNumber(TaskProtoWire.ANIMATING_BOUNDS_WIRE) + gremlin.sizes.sizeBool(self.animating_bounds);
        }
        if (self.minimize_amount != 0.0) {
            res += gremlin.sizes.sizeWireNumber(TaskProtoWire.MINIMIZE_AMOUNT_WIRE) + gremlin.sizes.sizeFloat(self.minimize_amount);
        }
        if (self.created_by_organizer != false) {
            res += gremlin.sizes.sizeWireNumber(TaskProtoWire.CREATED_BY_ORGANIZER_WIRE) + gremlin.sizes.sizeBool(self.created_by_organizer);
        }
        if (self.affinity) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TaskProtoWire.AFFINITY_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.has_child_pip_activity != false) {
            res += gremlin.sizes.sizeWireNumber(TaskProtoWire.HAS_CHILD_PIP_ACTIVITY_WIRE) + gremlin.sizes.sizeBool(self.has_child_pip_activity);
        }
        if (self.task_fragment) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TaskProtoWire.TASK_FRAGMENT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.task_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TaskProtoWire.TASK_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const TaskProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TaskProto, target: *gremlin.Writer) void {
        if (self.window_container) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TaskProtoWire.WINDOW_CONTAINER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.id != 0) {
            target.appendInt32(TaskProtoWire.ID_WIRE, self.id);
        }
        if (self.fills_parent != false) {
            target.appendBool(TaskProtoWire.FILLS_PARENT_WIRE, self.fills_parent);
        }
        if (self.bounds) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TaskProtoWire.BOUNDS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.displayed_bounds) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TaskProtoWire.DISPLAYED_BOUNDS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.defer_removal != false) {
            target.appendBool(TaskProtoWire.DEFER_REMOVAL_WIRE, self.defer_removal);
        }
        if (self.surface_width != 0) {
            target.appendInt32(TaskProtoWire.SURFACE_WIDTH_WIRE, self.surface_width);
        }
        if (self.surface_height != 0) {
            target.appendInt32(TaskProtoWire.SURFACE_HEIGHT_WIRE, self.surface_height);
        }
        if (self.tasks) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(TaskProtoWire.TASKS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(TaskProtoWire.TASKS_WIRE, 0);
                }
            }
        }
        if (self.activities) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(TaskProtoWire.ACTIVITIES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(TaskProtoWire.ACTIVITIES_WIRE, 0);
                }
            }
        }
        if (self.resumed_activity) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TaskProtoWire.RESUMED_ACTIVITY_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.real_activity) |v| {
            if (v.len > 0) {
                target.appendBytes(TaskProtoWire.REAL_ACTIVITY_WIRE, v);
            }
        }
        if (self.orig_activity) |v| {
            if (v.len > 0) {
                target.appendBytes(TaskProtoWire.ORIG_ACTIVITY_WIRE, v);
            }
        }
        if (self.display_id != 0) {
            target.appendInt32(TaskProtoWire.DISPLAY_ID_WIRE, self.display_id);
        }
        if (self.root_task_id != 0) {
            target.appendInt32(TaskProtoWire.ROOT_TASK_ID_WIRE, self.root_task_id);
        }
        if (self.activity_type != 0) {
            target.appendInt32(TaskProtoWire.ACTIVITY_TYPE_WIRE, self.activity_type);
        }
        if (self.resize_mode != 0) {
            target.appendInt32(TaskProtoWire.RESIZE_MODE_WIRE, self.resize_mode);
        }
        if (self.min_width != 0) {
            target.appendInt32(TaskProtoWire.MIN_WIDTH_WIRE, self.min_width);
        }
        if (self.min_height != 0) {
            target.appendInt32(TaskProtoWire.MIN_HEIGHT_WIRE, self.min_height);
        }
        if (self.adjusted_bounds) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TaskProtoWire.ADJUSTED_BOUNDS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.last_non_fullscreen_bounds) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TaskProtoWire.LAST_NON_FULLSCREEN_BOUNDS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.adjusted_for_ime != false) {
            target.appendBool(TaskProtoWire.ADJUSTED_FOR_IME_WIRE, self.adjusted_for_ime);
        }
        if (self.adjust_ime_amount != 0.0) {
            target.appendFloat32(TaskProtoWire.ADJUST_IME_AMOUNT_WIRE, self.adjust_ime_amount);
        }
        if (self.adjust_divider_amount != 0.0) {
            target.appendFloat32(TaskProtoWire.ADJUST_DIVIDER_AMOUNT_WIRE, self.adjust_divider_amount);
        }
        if (self.animating_bounds != false) {
            target.appendBool(TaskProtoWire.ANIMATING_BOUNDS_WIRE, self.animating_bounds);
        }
        if (self.minimize_amount != 0.0) {
            target.appendFloat32(TaskProtoWire.MINIMIZE_AMOUNT_WIRE, self.minimize_amount);
        }
        if (self.created_by_organizer != false) {
            target.appendBool(TaskProtoWire.CREATED_BY_ORGANIZER_WIRE, self.created_by_organizer);
        }
        if (self.affinity) |v| {
            if (v.len > 0) {
                target.appendBytes(TaskProtoWire.AFFINITY_WIRE, v);
            }
        }
        if (self.has_child_pip_activity != false) {
            target.appendBool(TaskProtoWire.HAS_CHILD_PIP_ACTIVITY_WIRE, self.has_child_pip_activity);
        }
        if (self.task_fragment) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TaskProtoWire.TASK_FRAGMENT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.task_name) |v| {
            if (v.len > 0) {
                target.appendBytes(TaskProtoWire.TASK_NAME_WIRE, v);
            }
        }
    }
};
pub const TaskProtoReader = struct {
    buf: gremlin.Reader,
    _window_container_buf: ?[]const u8 = null,
    _id: i32 = 0,
    _fills_parent: bool = false,
    _bounds_buf: ?[]const u8 = null,
    _displayed_bounds_buf: ?[]const u8 = null,
    _defer_removal: bool = false,
    _surface_width: i32 = 0,
    _surface_height: i32 = 0,
    _tasks_offset: ?usize = null,
    _tasks_last_offset: ?usize = null,
    _tasks_cnt: usize = 0,
    _activities_offset: ?usize = null,
    _activities_last_offset: ?usize = null,
    _activities_cnt: usize = 0,
    _resumed_activity_buf: ?[]const u8 = null,
    _real_activity: ?[]const u8 = null,
    _orig_activity: ?[]const u8 = null,
    _display_id: i32 = 0,
    _root_task_id: i32 = 0,
    _activity_type: i32 = 0,
    _resize_mode: i32 = 0,
    _min_width: i32 = 0,
    _min_height: i32 = 0,
    _adjusted_bounds_buf: ?[]const u8 = null,
    _last_non_fullscreen_bounds_buf: ?[]const u8 = null,
    _adjusted_for_ime: bool = false,
    _adjust_ime_amount: f32 = 0.0,
    _adjust_divider_amount: f32 = 0.0,
    _animating_bounds: bool = false,
    _minimize_amount: f32 = 0.0,
    _created_by_organizer: bool = false,
    _affinity: ?[]const u8 = null,
    _has_child_pip_activity: bool = false,
    _task_fragment_buf: ?[]const u8 = null,
    _task_name: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!TaskProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = TaskProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TaskProtoWire.WINDOW_CONTAINER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._window_container_buf = result.value;
                },
                TaskProtoWire.ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._id = result.value;
                },
                TaskProtoWire.FILLS_PARENT_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._fills_parent = result.value;
                },
                TaskProtoWire.BOUNDS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._bounds_buf = result.value;
                },
                TaskProtoWire.DISPLAYED_BOUNDS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._displayed_bounds_buf = result.value;
                },
                TaskProtoWire.DEFER_REMOVAL_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._defer_removal = result.value;
                },
                TaskProtoWire.SURFACE_WIDTH_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._surface_width = result.value;
                },
                TaskProtoWire.SURFACE_HEIGHT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._surface_height = result.value;
                },
                TaskProtoWire.TASKS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._tasks_offset == null) {
                        res._tasks_offset = offset - result.size;
                    }
                    res._tasks_last_offset = offset;
                    res._tasks_cnt += 1;
                },
                TaskProtoWire.ACTIVITIES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._activities_offset == null) {
                        res._activities_offset = offset - result.size;
                    }
                    res._activities_last_offset = offset;
                    res._activities_cnt += 1;
                },
                TaskProtoWire.RESUMED_ACTIVITY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._resumed_activity_buf = result.value;
                },
                TaskProtoWire.REAL_ACTIVITY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._real_activity = result.value;
                },
                TaskProtoWire.ORIG_ACTIVITY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._orig_activity = result.value;
                },
                TaskProtoWire.DISPLAY_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._display_id = result.value;
                },
                TaskProtoWire.ROOT_TASK_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._root_task_id = result.value;
                },
                TaskProtoWire.ACTIVITY_TYPE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._activity_type = result.value;
                },
                TaskProtoWire.RESIZE_MODE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._resize_mode = result.value;
                },
                TaskProtoWire.MIN_WIDTH_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._min_width = result.value;
                },
                TaskProtoWire.MIN_HEIGHT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._min_height = result.value;
                },
                TaskProtoWire.ADJUSTED_BOUNDS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._adjusted_bounds_buf = result.value;
                },
                TaskProtoWire.LAST_NON_FULLSCREEN_BOUNDS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._last_non_fullscreen_bounds_buf = result.value;
                },
                TaskProtoWire.ADJUSTED_FOR_IME_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._adjusted_for_ime = result.value;
                },
                TaskProtoWire.ADJUST_IME_AMOUNT_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._adjust_ime_amount = result.value;
                },
                TaskProtoWire.ADJUST_DIVIDER_AMOUNT_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._adjust_divider_amount = result.value;
                },
                TaskProtoWire.ANIMATING_BOUNDS_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._animating_bounds = result.value;
                },
                TaskProtoWire.MINIMIZE_AMOUNT_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._minimize_amount = result.value;
                },
                TaskProtoWire.CREATED_BY_ORGANIZER_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._created_by_organizer = result.value;
                },
                TaskProtoWire.AFFINITY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._affinity = result.value;
                },
                TaskProtoWire.HAS_CHILD_PIP_ACTIVITY_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._has_child_pip_activity = result.value;
                },
                TaskProtoWire.TASK_FRAGMENT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._task_fragment_buf = result.value;
                },
                TaskProtoWire.TASK_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._task_name = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getWindowContainer(self: *const TaskProtoReader) gremlin.Error!WindowContainerProtoReader {
        if (self._window_container_buf) |buf| {
            return try WindowContainerProtoReader.init(buf);
        }
        return try WindowContainerProtoReader.init(&[_]u8{});
    }
    pub inline fn getId(self: *const TaskProtoReader) i32 {
        return self._id;
    }
    pub inline fn getFillsParent(self: *const TaskProtoReader) bool {
        return self._fills_parent;
    }
    pub fn getBounds(self: *const TaskProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._bounds_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getDisplayedBounds(self: *const TaskProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._displayed_bounds_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub inline fn getDeferRemoval(self: *const TaskProtoReader) bool {
        return self._defer_removal;
    }
    pub inline fn getSurfaceWidth(self: *const TaskProtoReader) i32 {
        return self._surface_width;
    }
    pub inline fn getSurfaceHeight(self: *const TaskProtoReader) i32 {
        return self._surface_height;
    }
    pub fn tasksCount(self: *const TaskProtoReader) usize {
        return self._tasks_cnt;
    }
    pub fn tasksNext(self: *TaskProtoReader) ?TaskProtoReader {
        if (self._tasks_offset == null) return null;
        const current_offset = self._tasks_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = TaskProtoReader.init(result.value) catch return null;
        if (self._tasks_last_offset != null and current_offset >= self._tasks_last_offset.?) {
            self._tasks_offset = null;
            return msg;
        }
        if (self._tasks_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._tasks_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TaskProtoWire.TASKS_WIRE) {
                self._tasks_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._tasks_offset = null;
        return msg;
    }
    pub fn activitiesCount(self: *const TaskProtoReader) usize {
        return self._activities_cnt;
    }
    pub fn activitiesNext(self: *TaskProtoReader) ?ActivityRecordProtoReader {
        if (self._activities_offset == null) return null;
        const current_offset = self._activities_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = ActivityRecordProtoReader.init(result.value) catch return null;
        if (self._activities_last_offset != null and current_offset >= self._activities_last_offset.?) {
            self._activities_offset = null;
            return msg;
        }
        if (self._activities_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._activities_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TaskProtoWire.ACTIVITIES_WIRE) {
                self._activities_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._activities_offset = null;
        return msg;
    }
    pub fn getResumedActivity(self: *const TaskProtoReader) gremlin.Error!IdentifierProtoReader {
        if (self._resumed_activity_buf) |buf| {
            return try IdentifierProtoReader.init(buf);
        }
        return try IdentifierProtoReader.init(&[_]u8{});
    }
    pub inline fn getRealActivity(self: *const TaskProtoReader) []const u8 {
        return self._real_activity orelse &[_]u8{};
    }
    pub inline fn getOrigActivity(self: *const TaskProtoReader) []const u8 {
        return self._orig_activity orelse &[_]u8{};
    }
    pub inline fn getDisplayId(self: *const TaskProtoReader) i32 {
        return self._display_id;
    }
    pub inline fn getRootTaskId(self: *const TaskProtoReader) i32 {
        return self._root_task_id;
    }
    pub inline fn getActivityType(self: *const TaskProtoReader) i32 {
        return self._activity_type;
    }
    pub inline fn getResizeMode(self: *const TaskProtoReader) i32 {
        return self._resize_mode;
    }
    pub inline fn getMinWidth(self: *const TaskProtoReader) i32 {
        return self._min_width;
    }
    pub inline fn getMinHeight(self: *const TaskProtoReader) i32 {
        return self._min_height;
    }
    pub fn getAdjustedBounds(self: *const TaskProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._adjusted_bounds_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getLastNonFullscreenBounds(self: *const TaskProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._last_non_fullscreen_bounds_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub inline fn getAdjustedForIme(self: *const TaskProtoReader) bool {
        return self._adjusted_for_ime;
    }
    pub inline fn getAdjustImeAmount(self: *const TaskProtoReader) f32 {
        return self._adjust_ime_amount;
    }
    pub inline fn getAdjustDividerAmount(self: *const TaskProtoReader) f32 {
        return self._adjust_divider_amount;
    }
    pub inline fn getAnimatingBounds(self: *const TaskProtoReader) bool {
        return self._animating_bounds;
    }
    pub inline fn getMinimizeAmount(self: *const TaskProtoReader) f32 {
        return self._minimize_amount;
    }
    pub inline fn getCreatedByOrganizer(self: *const TaskProtoReader) bool {
        return self._created_by_organizer;
    }
    pub inline fn getAffinity(self: *const TaskProtoReader) []const u8 {
        return self._affinity orelse &[_]u8{};
    }
    pub inline fn getHasChildPipActivity(self: *const TaskProtoReader) bool {
        return self._has_child_pip_activity;
    }
    pub fn getTaskFragment(self: *const TaskProtoReader) gremlin.Error!TaskFragmentProtoReader {
        if (self._task_fragment_buf) |buf| {
            return try TaskFragmentProtoReader.init(buf);
        }
        return try TaskFragmentProtoReader.init(&[_]u8{});
    }
    pub inline fn getTaskName(self: *const TaskProtoReader) []const u8 {
        return self._task_name orelse &[_]u8{};
    }
};
const TaskFragmentProtoWire = struct {
    const WINDOW_CONTAINER_WIRE: gremlin.ProtoWireNumber = 1;
    const DISPLAY_ID_WIRE: gremlin.ProtoWireNumber = 2;
    const ACTIVITY_TYPE_WIRE: gremlin.ProtoWireNumber = 3;
    const MIN_WIDTH_WIRE: gremlin.ProtoWireNumber = 4;
    const MIN_HEIGHT_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const TaskFragmentProto = struct {
    // fields
    window_container: ?WindowContainerProto = null,
    display_id: i32 = 0,
    activity_type: i32 = 0,
    min_width: i32 = 0,
    min_height: i32 = 0,
    pub fn calcProtobufSize(self: *const TaskFragmentProto) usize {
        var res: usize = 0;
        if (self.window_container) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TaskFragmentProtoWire.WINDOW_CONTAINER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.display_id != 0) {
            res += gremlin.sizes.sizeWireNumber(TaskFragmentProtoWire.DISPLAY_ID_WIRE) + gremlin.sizes.sizeI32(self.display_id);
        }
        if (self.activity_type != 0) {
            res += gremlin.sizes.sizeWireNumber(TaskFragmentProtoWire.ACTIVITY_TYPE_WIRE) + gremlin.sizes.sizeI32(self.activity_type);
        }
        if (self.min_width != 0) {
            res += gremlin.sizes.sizeWireNumber(TaskFragmentProtoWire.MIN_WIDTH_WIRE) + gremlin.sizes.sizeI32(self.min_width);
        }
        if (self.min_height != 0) {
            res += gremlin.sizes.sizeWireNumber(TaskFragmentProtoWire.MIN_HEIGHT_WIRE) + gremlin.sizes.sizeI32(self.min_height);
        }
        return res;
    }
    pub fn encode(self: *const TaskFragmentProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TaskFragmentProto, target: *gremlin.Writer) void {
        if (self.window_container) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TaskFragmentProtoWire.WINDOW_CONTAINER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.display_id != 0) {
            target.appendInt32(TaskFragmentProtoWire.DISPLAY_ID_WIRE, self.display_id);
        }
        if (self.activity_type != 0) {
            target.appendInt32(TaskFragmentProtoWire.ACTIVITY_TYPE_WIRE, self.activity_type);
        }
        if (self.min_width != 0) {
            target.appendInt32(TaskFragmentProtoWire.MIN_WIDTH_WIRE, self.min_width);
        }
        if (self.min_height != 0) {
            target.appendInt32(TaskFragmentProtoWire.MIN_HEIGHT_WIRE, self.min_height);
        }
    }
};
pub const TaskFragmentProtoReader = struct {
    buf: gremlin.Reader,
    _window_container_buf: ?[]const u8 = null,
    _display_id: i32 = 0,
    _activity_type: i32 = 0,
    _min_width: i32 = 0,
    _min_height: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!TaskFragmentProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = TaskFragmentProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TaskFragmentProtoWire.WINDOW_CONTAINER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._window_container_buf = result.value;
                },
                TaskFragmentProtoWire.DISPLAY_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._display_id = result.value;
                },
                TaskFragmentProtoWire.ACTIVITY_TYPE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._activity_type = result.value;
                },
                TaskFragmentProtoWire.MIN_WIDTH_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._min_width = result.value;
                },
                TaskFragmentProtoWire.MIN_HEIGHT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._min_height = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getWindowContainer(self: *const TaskFragmentProtoReader) gremlin.Error!WindowContainerProtoReader {
        if (self._window_container_buf) |buf| {
            return try WindowContainerProtoReader.init(buf);
        }
        return try WindowContainerProtoReader.init(&[_]u8{});
    }
    pub inline fn getDisplayId(self: *const TaskFragmentProtoReader) i32 {
        return self._display_id;
    }
    pub inline fn getActivityType(self: *const TaskFragmentProtoReader) i32 {
        return self._activity_type;
    }
    pub inline fn getMinWidth(self: *const TaskFragmentProtoReader) i32 {
        return self._min_width;
    }
    pub inline fn getMinHeight(self: *const TaskFragmentProtoReader) i32 {
        return self._min_height;
    }
};
const ActivityRecordProtoWire = struct {
    const NAME_WIRE: gremlin.ProtoWireNumber = 1;
    const WINDOW_TOKEN_WIRE: gremlin.ProtoWireNumber = 2;
    const LAST_SURFACE_SHOWING_WIRE: gremlin.ProtoWireNumber = 3;
    const IS_WAITING_FOR_TRANSITION_START_WIRE: gremlin.ProtoWireNumber = 4;
    const IS_ANIMATING_WIRE: gremlin.ProtoWireNumber = 5;
    const THUMBNAIL_WIRE: gremlin.ProtoWireNumber = 6;
    const FILLS_PARENT_WIRE: gremlin.ProtoWireNumber = 7;
    const APP_STOPPED_WIRE: gremlin.ProtoWireNumber = 8;
    const VISIBLE_REQUESTED_WIRE: gremlin.ProtoWireNumber = 9;
    const CLIENT_VISIBLE_WIRE: gremlin.ProtoWireNumber = 10;
    const DEFER_HIDING_CLIENT_WIRE: gremlin.ProtoWireNumber = 11;
    const REPORTED_DRAWN_WIRE: gremlin.ProtoWireNumber = 12;
    const REPORTED_VISIBLE_WIRE: gremlin.ProtoWireNumber = 13;
    const NUM_INTERESTING_WINDOWS_WIRE: gremlin.ProtoWireNumber = 14;
    const NUM_DRAWN_WINDOWS_WIRE: gremlin.ProtoWireNumber = 15;
    const ALL_DRAWN_WIRE: gremlin.ProtoWireNumber = 16;
    const LAST_ALL_DRAWN_WIRE: gremlin.ProtoWireNumber = 17;
    const STARTING_WINDOW_WIRE: gremlin.ProtoWireNumber = 19;
    const STARTING_DISPLAYED_WIRE: gremlin.ProtoWireNumber = 20;
    const STARTING_MOVED_WIRE: gremlin.ProtoWireNumber = 201;
    const VISIBLE_SET_FROM_TRANSFERRED_STARTING_WINDOW_WIRE: gremlin.ProtoWireNumber = 22;
    const FROZEN_BOUNDS_WIRE: gremlin.ProtoWireNumber = 23;
    const VISIBLE_WIRE: gremlin.ProtoWireNumber = 24;
    const IDENTIFIER_WIRE: gremlin.ProtoWireNumber = 26;
    const STATE_WIRE: gremlin.ProtoWireNumber = 27;
    const FRONT_OF_TASK_WIRE: gremlin.ProtoWireNumber = 28;
    const PROC_ID_WIRE: gremlin.ProtoWireNumber = 29;
    const TRANSLUCENT_WIRE: gremlin.ProtoWireNumber = 30;
    const PIP_AUTO_ENTER_ENABLED_WIRE: gremlin.ProtoWireNumber = 31;
    const IN_SIZE_COMPAT_MODE_WIRE: gremlin.ProtoWireNumber = 32;
    const MIN_ASPECT_RATIO_WIRE: gremlin.ProtoWireNumber = 33;
    const PROVIDES_MAX_BOUNDS_WIRE: gremlin.ProtoWireNumber = 34;
    const ENABLE_RECENTS_SCREENSHOT_WIRE: gremlin.ProtoWireNumber = 35;
    const LAST_DROP_INPUT_MODE_WIRE: gremlin.ProtoWireNumber = 36;
    const OVERRIDE_ORIENTATION_WIRE: gremlin.ProtoWireNumber = 37;
    const SHOULD_SEND_COMPAT_FAKE_FOCUS_WIRE: gremlin.ProtoWireNumber = 38;
    const SHOULD_FORCE_ROTATE_FOR_CAMERA_COMPAT_WIRE: gremlin.ProtoWireNumber = 39;
    const SHOULD_REFRESH_ACTIVITY_FOR_CAMERA_COMPAT_WIRE: gremlin.ProtoWireNumber = 40;
    const SHOULD_REFRESH_ACTIVITY_VIA_PAUSE_FOR_CAMERA_COMPAT_WIRE: gremlin.ProtoWireNumber = 41;
    const SHOULD_OVERRIDE_MIN_ASPECT_RATIO_WIRE: gremlin.ProtoWireNumber = 42;
    const SHOULD_IGNORE_ORIENTATION_REQUEST_LOOP_WIRE: gremlin.ProtoWireNumber = 43;
    const SHOULD_OVERRIDE_FORCE_RESIZE_APP_WIRE: gremlin.ProtoWireNumber = 44;
    const SHOULD_ENABLE_USER_ASPECT_RATIO_SETTINGS_WIRE: gremlin.ProtoWireNumber = 45;
    const IS_USER_FULLSCREEN_OVERRIDE_ENABLED_WIRE: gremlin.ProtoWireNumber = 46;
    const REQUEST_OPEN_IN_BROWSER_EDUCATION_TIMESTAMP_WIRE: gremlin.ProtoWireNumber = 47;
    const SHOULD_ALLOW_SIMULATE_REQUESTED_ORIENTATION_FOR_CAMERA_COMPAT_WIRE: gremlin.ProtoWireNumber = 48;
    const SAFE_REGION_BOUNDS_WIRE: gremlin.ProtoWireNumber = 49;
};
pub const ActivityRecordProto = struct {
    // fields
    name: ?[]const u8 = null,
    window_token: ?WindowTokenProto = null,
    last_surface_showing: bool = false,
    is_waiting_for_transition_start: bool = false,
    is_animating: bool = false,
    thumbnail: ?windowcontainerthumbnail.WindowContainerThumbnailProto = null,
    fills_parent: bool = false,
    app_stopped: bool = false,
    visible_requested: bool = false,
    client_visible: bool = false,
    defer_hiding_client: bool = false,
    reported_drawn: bool = false,
    reported_visible: bool = false,
    num_interesting_windows: i32 = 0,
    num_drawn_windows: i32 = 0,
    all_drawn: bool = false,
    last_all_drawn: bool = false,
    starting_window: ?IdentifierProto = null,
    starting_displayed: bool = false,
    starting_moved: bool = false,
    visible_set_from_transferred_starting_window: bool = false,
    frozen_bounds: ?[]const ?rect.RectProto = null,
    visible: bool = false,
    identifier: ?IdentifierProto = null,
    state: ?[]const u8 = null,
    front_of_task: bool = false,
    proc_id: i32 = 0,
    translucent: bool = false,
    pip_auto_enter_enabled: bool = false,
    in_size_compat_mode: bool = false,
    min_aspect_ratio: f32 = 0.0,
    provides_max_bounds: bool = false,
    enable_recents_screenshot: bool = false,
    last_drop_input_mode: i32 = 0,
    override_orientation: i32 = 0,
    should_send_compat_fake_focus: bool = false,
    should_force_rotate_for_camera_compat: bool = false,
    should_refresh_activity_for_camera_compat: bool = false,
    should_refresh_activity_via_pause_for_camera_compat: bool = false,
    should_override_min_aspect_ratio: bool = false,
    should_ignore_orientation_request_loop: bool = false,
    should_override_force_resize_app: bool = false,
    should_enable_user_aspect_ratio_settings: bool = false,
    is_user_fullscreen_override_enabled: bool = false,
    request_open_in_browser_education_timestamp: i64 = 0,
    should_allow_simulate_requested_orientation_for_camera_compat: bool = false,
    safe_region_bounds: ?rect.RectProto = null,
    pub fn calcProtobufSize(self: *const ActivityRecordProto) usize {
        var res: usize = 0;
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.window_token) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.WINDOW_TOKEN_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.last_surface_showing != false) {
            res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.LAST_SURFACE_SHOWING_WIRE) + gremlin.sizes.sizeBool(self.last_surface_showing);
        }
        if (self.is_waiting_for_transition_start != false) {
            res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.IS_WAITING_FOR_TRANSITION_START_WIRE) + gremlin.sizes.sizeBool(self.is_waiting_for_transition_start);
        }
        if (self.is_animating != false) {
            res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.IS_ANIMATING_WIRE) + gremlin.sizes.sizeBool(self.is_animating);
        }
        if (self.thumbnail) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.THUMBNAIL_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.fills_parent != false) {
            res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.FILLS_PARENT_WIRE) + gremlin.sizes.sizeBool(self.fills_parent);
        }
        if (self.app_stopped != false) {
            res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.APP_STOPPED_WIRE) + gremlin.sizes.sizeBool(self.app_stopped);
        }
        if (self.visible_requested != false) {
            res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.VISIBLE_REQUESTED_WIRE) + gremlin.sizes.sizeBool(self.visible_requested);
        }
        if (self.client_visible != false) {
            res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.CLIENT_VISIBLE_WIRE) + gremlin.sizes.sizeBool(self.client_visible);
        }
        if (self.defer_hiding_client != false) {
            res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.DEFER_HIDING_CLIENT_WIRE) + gremlin.sizes.sizeBool(self.defer_hiding_client);
        }
        if (self.reported_drawn != false) {
            res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.REPORTED_DRAWN_WIRE) + gremlin.sizes.sizeBool(self.reported_drawn);
        }
        if (self.reported_visible != false) {
            res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.REPORTED_VISIBLE_WIRE) + gremlin.sizes.sizeBool(self.reported_visible);
        }
        if (self.num_interesting_windows != 0) {
            res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.NUM_INTERESTING_WINDOWS_WIRE) + gremlin.sizes.sizeI32(self.num_interesting_windows);
        }
        if (self.num_drawn_windows != 0) {
            res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.NUM_DRAWN_WINDOWS_WIRE) + gremlin.sizes.sizeI32(self.num_drawn_windows);
        }
        if (self.all_drawn != false) {
            res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.ALL_DRAWN_WIRE) + gremlin.sizes.sizeBool(self.all_drawn);
        }
        if (self.last_all_drawn != false) {
            res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.LAST_ALL_DRAWN_WIRE) + gremlin.sizes.sizeBool(self.last_all_drawn);
        }
        if (self.starting_window) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.STARTING_WINDOW_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.starting_displayed != false) {
            res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.STARTING_DISPLAYED_WIRE) + gremlin.sizes.sizeBool(self.starting_displayed);
        }
        if (self.starting_moved != false) {
            res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.STARTING_MOVED_WIRE) + gremlin.sizes.sizeBool(self.starting_moved);
        }
        if (self.visible_set_from_transferred_starting_window != false) {
            res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.VISIBLE_SET_FROM_TRANSFERRED_STARTING_WINDOW_WIRE) + gremlin.sizes.sizeBool(self.visible_set_from_transferred_starting_window);
        }
        if (self.frozen_bounds) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.FROZEN_BOUNDS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.visible != false) {
            res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.VISIBLE_WIRE) + gremlin.sizes.sizeBool(self.visible);
        }
        if (self.identifier) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.IDENTIFIER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.state) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.STATE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.front_of_task != false) {
            res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.FRONT_OF_TASK_WIRE) + gremlin.sizes.sizeBool(self.front_of_task);
        }
        if (self.proc_id != 0) {
            res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.PROC_ID_WIRE) + gremlin.sizes.sizeI32(self.proc_id);
        }
        if (self.translucent != false) {
            res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.TRANSLUCENT_WIRE) + gremlin.sizes.sizeBool(self.translucent);
        }
        if (self.pip_auto_enter_enabled != false) {
            res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.PIP_AUTO_ENTER_ENABLED_WIRE) + gremlin.sizes.sizeBool(self.pip_auto_enter_enabled);
        }
        if (self.in_size_compat_mode != false) {
            res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.IN_SIZE_COMPAT_MODE_WIRE) + gremlin.sizes.sizeBool(self.in_size_compat_mode);
        }
        if (self.min_aspect_ratio != 0.0) {
            res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.MIN_ASPECT_RATIO_WIRE) + gremlin.sizes.sizeFloat(self.min_aspect_ratio);
        }
        if (self.provides_max_bounds != false) {
            res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.PROVIDES_MAX_BOUNDS_WIRE) + gremlin.sizes.sizeBool(self.provides_max_bounds);
        }
        if (self.enable_recents_screenshot != false) {
            res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.ENABLE_RECENTS_SCREENSHOT_WIRE) + gremlin.sizes.sizeBool(self.enable_recents_screenshot);
        }
        if (self.last_drop_input_mode != 0) {
            res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.LAST_DROP_INPUT_MODE_WIRE) + gremlin.sizes.sizeI32(self.last_drop_input_mode);
        }
        if (self.override_orientation != 0) {
            res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.OVERRIDE_ORIENTATION_WIRE) + gremlin.sizes.sizeI32(self.override_orientation);
        }
        if (self.should_send_compat_fake_focus != false) {
            res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.SHOULD_SEND_COMPAT_FAKE_FOCUS_WIRE) + gremlin.sizes.sizeBool(self.should_send_compat_fake_focus);
        }
        if (self.should_force_rotate_for_camera_compat != false) {
            res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.SHOULD_FORCE_ROTATE_FOR_CAMERA_COMPAT_WIRE) + gremlin.sizes.sizeBool(self.should_force_rotate_for_camera_compat);
        }
        if (self.should_refresh_activity_for_camera_compat != false) {
            res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.SHOULD_REFRESH_ACTIVITY_FOR_CAMERA_COMPAT_WIRE) + gremlin.sizes.sizeBool(self.should_refresh_activity_for_camera_compat);
        }
        if (self.should_refresh_activity_via_pause_for_camera_compat != false) {
            res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.SHOULD_REFRESH_ACTIVITY_VIA_PAUSE_FOR_CAMERA_COMPAT_WIRE) + gremlin.sizes.sizeBool(self.should_refresh_activity_via_pause_for_camera_compat);
        }
        if (self.should_override_min_aspect_ratio != false) {
            res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.SHOULD_OVERRIDE_MIN_ASPECT_RATIO_WIRE) + gremlin.sizes.sizeBool(self.should_override_min_aspect_ratio);
        }
        if (self.should_ignore_orientation_request_loop != false) {
            res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.SHOULD_IGNORE_ORIENTATION_REQUEST_LOOP_WIRE) + gremlin.sizes.sizeBool(self.should_ignore_orientation_request_loop);
        }
        if (self.should_override_force_resize_app != false) {
            res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.SHOULD_OVERRIDE_FORCE_RESIZE_APP_WIRE) + gremlin.sizes.sizeBool(self.should_override_force_resize_app);
        }
        if (self.should_enable_user_aspect_ratio_settings != false) {
            res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.SHOULD_ENABLE_USER_ASPECT_RATIO_SETTINGS_WIRE) + gremlin.sizes.sizeBool(self.should_enable_user_aspect_ratio_settings);
        }
        if (self.is_user_fullscreen_override_enabled != false) {
            res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.IS_USER_FULLSCREEN_OVERRIDE_ENABLED_WIRE) + gremlin.sizes.sizeBool(self.is_user_fullscreen_override_enabled);
        }
        if (self.request_open_in_browser_education_timestamp != 0) {
            res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.REQUEST_OPEN_IN_BROWSER_EDUCATION_TIMESTAMP_WIRE) + gremlin.sizes.sizeI64(self.request_open_in_browser_education_timestamp);
        }
        if (self.should_allow_simulate_requested_orientation_for_camera_compat != false) {
            res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.SHOULD_ALLOW_SIMULATE_REQUESTED_ORIENTATION_FOR_CAMERA_COMPAT_WIRE) + gremlin.sizes.sizeBool(self.should_allow_simulate_requested_orientation_for_camera_compat);
        }
        if (self.safe_region_bounds) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ActivityRecordProtoWire.SAFE_REGION_BOUNDS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const ActivityRecordProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ActivityRecordProto, target: *gremlin.Writer) void {
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(ActivityRecordProtoWire.NAME_WIRE, v);
            }
        }
        if (self.window_token) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ActivityRecordProtoWire.WINDOW_TOKEN_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.last_surface_showing != false) {
            target.appendBool(ActivityRecordProtoWire.LAST_SURFACE_SHOWING_WIRE, self.last_surface_showing);
        }
        if (self.is_waiting_for_transition_start != false) {
            target.appendBool(ActivityRecordProtoWire.IS_WAITING_FOR_TRANSITION_START_WIRE, self.is_waiting_for_transition_start);
        }
        if (self.is_animating != false) {
            target.appendBool(ActivityRecordProtoWire.IS_ANIMATING_WIRE, self.is_animating);
        }
        if (self.thumbnail) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ActivityRecordProtoWire.THUMBNAIL_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.fills_parent != false) {
            target.appendBool(ActivityRecordProtoWire.FILLS_PARENT_WIRE, self.fills_parent);
        }
        if (self.app_stopped != false) {
            target.appendBool(ActivityRecordProtoWire.APP_STOPPED_WIRE, self.app_stopped);
        }
        if (self.visible_requested != false) {
            target.appendBool(ActivityRecordProtoWire.VISIBLE_REQUESTED_WIRE, self.visible_requested);
        }
        if (self.client_visible != false) {
            target.appendBool(ActivityRecordProtoWire.CLIENT_VISIBLE_WIRE, self.client_visible);
        }
        if (self.defer_hiding_client != false) {
            target.appendBool(ActivityRecordProtoWire.DEFER_HIDING_CLIENT_WIRE, self.defer_hiding_client);
        }
        if (self.reported_drawn != false) {
            target.appendBool(ActivityRecordProtoWire.REPORTED_DRAWN_WIRE, self.reported_drawn);
        }
        if (self.reported_visible != false) {
            target.appendBool(ActivityRecordProtoWire.REPORTED_VISIBLE_WIRE, self.reported_visible);
        }
        if (self.num_interesting_windows != 0) {
            target.appendInt32(ActivityRecordProtoWire.NUM_INTERESTING_WINDOWS_WIRE, self.num_interesting_windows);
        }
        if (self.num_drawn_windows != 0) {
            target.appendInt32(ActivityRecordProtoWire.NUM_DRAWN_WINDOWS_WIRE, self.num_drawn_windows);
        }
        if (self.all_drawn != false) {
            target.appendBool(ActivityRecordProtoWire.ALL_DRAWN_WIRE, self.all_drawn);
        }
        if (self.last_all_drawn != false) {
            target.appendBool(ActivityRecordProtoWire.LAST_ALL_DRAWN_WIRE, self.last_all_drawn);
        }
        if (self.starting_window) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ActivityRecordProtoWire.STARTING_WINDOW_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.starting_displayed != false) {
            target.appendBool(ActivityRecordProtoWire.STARTING_DISPLAYED_WIRE, self.starting_displayed);
        }
        if (self.starting_moved != false) {
            target.appendBool(ActivityRecordProtoWire.STARTING_MOVED_WIRE, self.starting_moved);
        }
        if (self.visible_set_from_transferred_starting_window != false) {
            target.appendBool(ActivityRecordProtoWire.VISIBLE_SET_FROM_TRANSFERRED_STARTING_WINDOW_WIRE, self.visible_set_from_transferred_starting_window);
        }
        if (self.frozen_bounds) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(ActivityRecordProtoWire.FROZEN_BOUNDS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(ActivityRecordProtoWire.FROZEN_BOUNDS_WIRE, 0);
                }
            }
        }
        if (self.visible != false) {
            target.appendBool(ActivityRecordProtoWire.VISIBLE_WIRE, self.visible);
        }
        if (self.identifier) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ActivityRecordProtoWire.IDENTIFIER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.state) |v| {
            if (v.len > 0) {
                target.appendBytes(ActivityRecordProtoWire.STATE_WIRE, v);
            }
        }
        if (self.front_of_task != false) {
            target.appendBool(ActivityRecordProtoWire.FRONT_OF_TASK_WIRE, self.front_of_task);
        }
        if (self.proc_id != 0) {
            target.appendInt32(ActivityRecordProtoWire.PROC_ID_WIRE, self.proc_id);
        }
        if (self.translucent != false) {
            target.appendBool(ActivityRecordProtoWire.TRANSLUCENT_WIRE, self.translucent);
        }
        if (self.pip_auto_enter_enabled != false) {
            target.appendBool(ActivityRecordProtoWire.PIP_AUTO_ENTER_ENABLED_WIRE, self.pip_auto_enter_enabled);
        }
        if (self.in_size_compat_mode != false) {
            target.appendBool(ActivityRecordProtoWire.IN_SIZE_COMPAT_MODE_WIRE, self.in_size_compat_mode);
        }
        if (self.min_aspect_ratio != 0.0) {
            target.appendFloat32(ActivityRecordProtoWire.MIN_ASPECT_RATIO_WIRE, self.min_aspect_ratio);
        }
        if (self.provides_max_bounds != false) {
            target.appendBool(ActivityRecordProtoWire.PROVIDES_MAX_BOUNDS_WIRE, self.provides_max_bounds);
        }
        if (self.enable_recents_screenshot != false) {
            target.appendBool(ActivityRecordProtoWire.ENABLE_RECENTS_SCREENSHOT_WIRE, self.enable_recents_screenshot);
        }
        if (self.last_drop_input_mode != 0) {
            target.appendInt32(ActivityRecordProtoWire.LAST_DROP_INPUT_MODE_WIRE, self.last_drop_input_mode);
        }
        if (self.override_orientation != 0) {
            target.appendInt32(ActivityRecordProtoWire.OVERRIDE_ORIENTATION_WIRE, self.override_orientation);
        }
        if (self.should_send_compat_fake_focus != false) {
            target.appendBool(ActivityRecordProtoWire.SHOULD_SEND_COMPAT_FAKE_FOCUS_WIRE, self.should_send_compat_fake_focus);
        }
        if (self.should_force_rotate_for_camera_compat != false) {
            target.appendBool(ActivityRecordProtoWire.SHOULD_FORCE_ROTATE_FOR_CAMERA_COMPAT_WIRE, self.should_force_rotate_for_camera_compat);
        }
        if (self.should_refresh_activity_for_camera_compat != false) {
            target.appendBool(ActivityRecordProtoWire.SHOULD_REFRESH_ACTIVITY_FOR_CAMERA_COMPAT_WIRE, self.should_refresh_activity_for_camera_compat);
        }
        if (self.should_refresh_activity_via_pause_for_camera_compat != false) {
            target.appendBool(ActivityRecordProtoWire.SHOULD_REFRESH_ACTIVITY_VIA_PAUSE_FOR_CAMERA_COMPAT_WIRE, self.should_refresh_activity_via_pause_for_camera_compat);
        }
        if (self.should_override_min_aspect_ratio != false) {
            target.appendBool(ActivityRecordProtoWire.SHOULD_OVERRIDE_MIN_ASPECT_RATIO_WIRE, self.should_override_min_aspect_ratio);
        }
        if (self.should_ignore_orientation_request_loop != false) {
            target.appendBool(ActivityRecordProtoWire.SHOULD_IGNORE_ORIENTATION_REQUEST_LOOP_WIRE, self.should_ignore_orientation_request_loop);
        }
        if (self.should_override_force_resize_app != false) {
            target.appendBool(ActivityRecordProtoWire.SHOULD_OVERRIDE_FORCE_RESIZE_APP_WIRE, self.should_override_force_resize_app);
        }
        if (self.should_enable_user_aspect_ratio_settings != false) {
            target.appendBool(ActivityRecordProtoWire.SHOULD_ENABLE_USER_ASPECT_RATIO_SETTINGS_WIRE, self.should_enable_user_aspect_ratio_settings);
        }
        if (self.is_user_fullscreen_override_enabled != false) {
            target.appendBool(ActivityRecordProtoWire.IS_USER_FULLSCREEN_OVERRIDE_ENABLED_WIRE, self.is_user_fullscreen_override_enabled);
        }
        if (self.request_open_in_browser_education_timestamp != 0) {
            target.appendInt64(ActivityRecordProtoWire.REQUEST_OPEN_IN_BROWSER_EDUCATION_TIMESTAMP_WIRE, self.request_open_in_browser_education_timestamp);
        }
        if (self.should_allow_simulate_requested_orientation_for_camera_compat != false) {
            target.appendBool(ActivityRecordProtoWire.SHOULD_ALLOW_SIMULATE_REQUESTED_ORIENTATION_FOR_CAMERA_COMPAT_WIRE, self.should_allow_simulate_requested_orientation_for_camera_compat);
        }
        if (self.safe_region_bounds) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ActivityRecordProtoWire.SAFE_REGION_BOUNDS_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const ActivityRecordProtoReader = struct {
    buf: gremlin.Reader,
    _name: ?[]const u8 = null,
    _window_token_buf: ?[]const u8 = null,
    _last_surface_showing: bool = false,
    _is_waiting_for_transition_start: bool = false,
    _is_animating: bool = false,
    _thumbnail_buf: ?[]const u8 = null,
    _fills_parent: bool = false,
    _app_stopped: bool = false,
    _visible_requested: bool = false,
    _client_visible: bool = false,
    _defer_hiding_client: bool = false,
    _reported_drawn: bool = false,
    _reported_visible: bool = false,
    _num_interesting_windows: i32 = 0,
    _num_drawn_windows: i32 = 0,
    _all_drawn: bool = false,
    _last_all_drawn: bool = false,
    _starting_window_buf: ?[]const u8 = null,
    _starting_displayed: bool = false,
    _starting_moved: bool = false,
    _visible_set_from_transferred_starting_window: bool = false,
    _frozen_bounds_offset: ?usize = null,
    _frozen_bounds_last_offset: ?usize = null,
    _frozen_bounds_cnt: usize = 0,
    _visible: bool = false,
    _identifier_buf: ?[]const u8 = null,
    _state: ?[]const u8 = null,
    _front_of_task: bool = false,
    _proc_id: i32 = 0,
    _translucent: bool = false,
    _pip_auto_enter_enabled: bool = false,
    _in_size_compat_mode: bool = false,
    _min_aspect_ratio: f32 = 0.0,
    _provides_max_bounds: bool = false,
    _enable_recents_screenshot: bool = false,
    _last_drop_input_mode: i32 = 0,
    _override_orientation: i32 = 0,
    _should_send_compat_fake_focus: bool = false,
    _should_force_rotate_for_camera_compat: bool = false,
    _should_refresh_activity_for_camera_compat: bool = false,
    _should_refresh_activity_via_pause_for_camera_compat: bool = false,
    _should_override_min_aspect_ratio: bool = false,
    _should_ignore_orientation_request_loop: bool = false,
    _should_override_force_resize_app: bool = false,
    _should_enable_user_aspect_ratio_settings: bool = false,
    _is_user_fullscreen_override_enabled: bool = false,
    _request_open_in_browser_education_timestamp: i64 = 0,
    _should_allow_simulate_requested_orientation_for_camera_compat: bool = false,
    _safe_region_bounds_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!ActivityRecordProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = ActivityRecordProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ActivityRecordProtoWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                ActivityRecordProtoWire.WINDOW_TOKEN_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._window_token_buf = result.value;
                },
                ActivityRecordProtoWire.LAST_SURFACE_SHOWING_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._last_surface_showing = result.value;
                },
                ActivityRecordProtoWire.IS_WAITING_FOR_TRANSITION_START_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_waiting_for_transition_start = result.value;
                },
                ActivityRecordProtoWire.IS_ANIMATING_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_animating = result.value;
                },
                ActivityRecordProtoWire.THUMBNAIL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._thumbnail_buf = result.value;
                },
                ActivityRecordProtoWire.FILLS_PARENT_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._fills_parent = result.value;
                },
                ActivityRecordProtoWire.APP_STOPPED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._app_stopped = result.value;
                },
                ActivityRecordProtoWire.VISIBLE_REQUESTED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._visible_requested = result.value;
                },
                ActivityRecordProtoWire.CLIENT_VISIBLE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._client_visible = result.value;
                },
                ActivityRecordProtoWire.DEFER_HIDING_CLIENT_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._defer_hiding_client = result.value;
                },
                ActivityRecordProtoWire.REPORTED_DRAWN_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._reported_drawn = result.value;
                },
                ActivityRecordProtoWire.REPORTED_VISIBLE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._reported_visible = result.value;
                },
                ActivityRecordProtoWire.NUM_INTERESTING_WINDOWS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._num_interesting_windows = result.value;
                },
                ActivityRecordProtoWire.NUM_DRAWN_WINDOWS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._num_drawn_windows = result.value;
                },
                ActivityRecordProtoWire.ALL_DRAWN_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._all_drawn = result.value;
                },
                ActivityRecordProtoWire.LAST_ALL_DRAWN_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._last_all_drawn = result.value;
                },
                ActivityRecordProtoWire.STARTING_WINDOW_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._starting_window_buf = result.value;
                },
                ActivityRecordProtoWire.STARTING_DISPLAYED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._starting_displayed = result.value;
                },
                ActivityRecordProtoWire.STARTING_MOVED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._starting_moved = result.value;
                },
                ActivityRecordProtoWire.VISIBLE_SET_FROM_TRANSFERRED_STARTING_WINDOW_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._visible_set_from_transferred_starting_window = result.value;
                },
                ActivityRecordProtoWire.FROZEN_BOUNDS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._frozen_bounds_offset == null) {
                        res._frozen_bounds_offset = offset - result.size;
                    }
                    res._frozen_bounds_last_offset = offset;
                    res._frozen_bounds_cnt += 1;
                },
                ActivityRecordProtoWire.VISIBLE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._visible = result.value;
                },
                ActivityRecordProtoWire.IDENTIFIER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._identifier_buf = result.value;
                },
                ActivityRecordProtoWire.STATE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._state = result.value;
                },
                ActivityRecordProtoWire.FRONT_OF_TASK_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._front_of_task = result.value;
                },
                ActivityRecordProtoWire.PROC_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._proc_id = result.value;
                },
                ActivityRecordProtoWire.TRANSLUCENT_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._translucent = result.value;
                },
                ActivityRecordProtoWire.PIP_AUTO_ENTER_ENABLED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._pip_auto_enter_enabled = result.value;
                },
                ActivityRecordProtoWire.IN_SIZE_COMPAT_MODE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._in_size_compat_mode = result.value;
                },
                ActivityRecordProtoWire.MIN_ASPECT_RATIO_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._min_aspect_ratio = result.value;
                },
                ActivityRecordProtoWire.PROVIDES_MAX_BOUNDS_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._provides_max_bounds = result.value;
                },
                ActivityRecordProtoWire.ENABLE_RECENTS_SCREENSHOT_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._enable_recents_screenshot = result.value;
                },
                ActivityRecordProtoWire.LAST_DROP_INPUT_MODE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._last_drop_input_mode = result.value;
                },
                ActivityRecordProtoWire.OVERRIDE_ORIENTATION_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._override_orientation = result.value;
                },
                ActivityRecordProtoWire.SHOULD_SEND_COMPAT_FAKE_FOCUS_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._should_send_compat_fake_focus = result.value;
                },
                ActivityRecordProtoWire.SHOULD_FORCE_ROTATE_FOR_CAMERA_COMPAT_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._should_force_rotate_for_camera_compat = result.value;
                },
                ActivityRecordProtoWire.SHOULD_REFRESH_ACTIVITY_FOR_CAMERA_COMPAT_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._should_refresh_activity_for_camera_compat = result.value;
                },
                ActivityRecordProtoWire.SHOULD_REFRESH_ACTIVITY_VIA_PAUSE_FOR_CAMERA_COMPAT_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._should_refresh_activity_via_pause_for_camera_compat = result.value;
                },
                ActivityRecordProtoWire.SHOULD_OVERRIDE_MIN_ASPECT_RATIO_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._should_override_min_aspect_ratio = result.value;
                },
                ActivityRecordProtoWire.SHOULD_IGNORE_ORIENTATION_REQUEST_LOOP_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._should_ignore_orientation_request_loop = result.value;
                },
                ActivityRecordProtoWire.SHOULD_OVERRIDE_FORCE_RESIZE_APP_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._should_override_force_resize_app = result.value;
                },
                ActivityRecordProtoWire.SHOULD_ENABLE_USER_ASPECT_RATIO_SETTINGS_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._should_enable_user_aspect_ratio_settings = result.value;
                },
                ActivityRecordProtoWire.IS_USER_FULLSCREEN_OVERRIDE_ENABLED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_user_fullscreen_override_enabled = result.value;
                },
                ActivityRecordProtoWire.REQUEST_OPEN_IN_BROWSER_EDUCATION_TIMESTAMP_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._request_open_in_browser_education_timestamp = result.value;
                },
                ActivityRecordProtoWire.SHOULD_ALLOW_SIMULATE_REQUESTED_ORIENTATION_FOR_CAMERA_COMPAT_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._should_allow_simulate_requested_orientation_for_camera_compat = result.value;
                },
                ActivityRecordProtoWire.SAFE_REGION_BOUNDS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._safe_region_bounds_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getName(self: *const ActivityRecordProtoReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub fn getWindowToken(self: *const ActivityRecordProtoReader) gremlin.Error!WindowTokenProtoReader {
        if (self._window_token_buf) |buf| {
            return try WindowTokenProtoReader.init(buf);
        }
        return try WindowTokenProtoReader.init(&[_]u8{});
    }
    pub inline fn getLastSurfaceShowing(self: *const ActivityRecordProtoReader) bool {
        return self._last_surface_showing;
    }
    pub inline fn getIsWaitingForTransitionStart(self: *const ActivityRecordProtoReader) bool {
        return self._is_waiting_for_transition_start;
    }
    pub inline fn getIsAnimating(self: *const ActivityRecordProtoReader) bool {
        return self._is_animating;
    }
    pub fn getThumbnail(self: *const ActivityRecordProtoReader) gremlin.Error!windowcontainerthumbnail.WindowContainerThumbnailProtoReader {
        if (self._thumbnail_buf) |buf| {
            return try windowcontainerthumbnail.WindowContainerThumbnailProtoReader.init(buf);
        }
        return try windowcontainerthumbnail.WindowContainerThumbnailProtoReader.init(&[_]u8{});
    }
    pub inline fn getFillsParent(self: *const ActivityRecordProtoReader) bool {
        return self._fills_parent;
    }
    pub inline fn getAppStopped(self: *const ActivityRecordProtoReader) bool {
        return self._app_stopped;
    }
    pub inline fn getVisibleRequested(self: *const ActivityRecordProtoReader) bool {
        return self._visible_requested;
    }
    pub inline fn getClientVisible(self: *const ActivityRecordProtoReader) bool {
        return self._client_visible;
    }
    pub inline fn getDeferHidingClient(self: *const ActivityRecordProtoReader) bool {
        return self._defer_hiding_client;
    }
    pub inline fn getReportedDrawn(self: *const ActivityRecordProtoReader) bool {
        return self._reported_drawn;
    }
    pub inline fn getReportedVisible(self: *const ActivityRecordProtoReader) bool {
        return self._reported_visible;
    }
    pub inline fn getNumInterestingWindows(self: *const ActivityRecordProtoReader) i32 {
        return self._num_interesting_windows;
    }
    pub inline fn getNumDrawnWindows(self: *const ActivityRecordProtoReader) i32 {
        return self._num_drawn_windows;
    }
    pub inline fn getAllDrawn(self: *const ActivityRecordProtoReader) bool {
        return self._all_drawn;
    }
    pub inline fn getLastAllDrawn(self: *const ActivityRecordProtoReader) bool {
        return self._last_all_drawn;
    }
    pub fn getStartingWindow(self: *const ActivityRecordProtoReader) gremlin.Error!IdentifierProtoReader {
        if (self._starting_window_buf) |buf| {
            return try IdentifierProtoReader.init(buf);
        }
        return try IdentifierProtoReader.init(&[_]u8{});
    }
    pub inline fn getStartingDisplayed(self: *const ActivityRecordProtoReader) bool {
        return self._starting_displayed;
    }
    pub inline fn getStartingMoved(self: *const ActivityRecordProtoReader) bool {
        return self._starting_moved;
    }
    pub inline fn getVisibleSetFromTransferredStartingWindow(self: *const ActivityRecordProtoReader) bool {
        return self._visible_set_from_transferred_starting_window;
    }
    pub fn frozenBoundsCount(self: *const ActivityRecordProtoReader) usize {
        return self._frozen_bounds_cnt;
    }
    pub fn frozenBoundsNext(self: *ActivityRecordProtoReader) ?rect.RectProtoReader {
        if (self._frozen_bounds_offset == null) return null;
        const current_offset = self._frozen_bounds_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = rect.RectProtoReader.init(result.value) catch return null;
        if (self._frozen_bounds_last_offset != null and current_offset >= self._frozen_bounds_last_offset.?) {
            self._frozen_bounds_offset = null;
            return msg;
        }
        if (self._frozen_bounds_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._frozen_bounds_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ActivityRecordProtoWire.FROZEN_BOUNDS_WIRE) {
                self._frozen_bounds_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._frozen_bounds_offset = null;
        return msg;
    }
    pub inline fn getVisible(self: *const ActivityRecordProtoReader) bool {
        return self._visible;
    }
    pub fn getIdentifier(self: *const ActivityRecordProtoReader) gremlin.Error!IdentifierProtoReader {
        if (self._identifier_buf) |buf| {
            return try IdentifierProtoReader.init(buf);
        }
        return try IdentifierProtoReader.init(&[_]u8{});
    }
    pub inline fn getState(self: *const ActivityRecordProtoReader) []const u8 {
        return self._state orelse &[_]u8{};
    }
    pub inline fn getFrontOfTask(self: *const ActivityRecordProtoReader) bool {
        return self._front_of_task;
    }
    pub inline fn getProcId(self: *const ActivityRecordProtoReader) i32 {
        return self._proc_id;
    }
    pub inline fn getTranslucent(self: *const ActivityRecordProtoReader) bool {
        return self._translucent;
    }
    pub inline fn getPipAutoEnterEnabled(self: *const ActivityRecordProtoReader) bool {
        return self._pip_auto_enter_enabled;
    }
    pub inline fn getInSizeCompatMode(self: *const ActivityRecordProtoReader) bool {
        return self._in_size_compat_mode;
    }
    pub inline fn getMinAspectRatio(self: *const ActivityRecordProtoReader) f32 {
        return self._min_aspect_ratio;
    }
    pub inline fn getProvidesMaxBounds(self: *const ActivityRecordProtoReader) bool {
        return self._provides_max_bounds;
    }
    pub inline fn getEnableRecentsScreenshot(self: *const ActivityRecordProtoReader) bool {
        return self._enable_recents_screenshot;
    }
    pub inline fn getLastDropInputMode(self: *const ActivityRecordProtoReader) i32 {
        return self._last_drop_input_mode;
    }
    pub inline fn getOverrideOrientation(self: *const ActivityRecordProtoReader) i32 {
        return self._override_orientation;
    }
    pub inline fn getShouldSendCompatFakeFocus(self: *const ActivityRecordProtoReader) bool {
        return self._should_send_compat_fake_focus;
    }
    pub inline fn getShouldForceRotateForCameraCompat(self: *const ActivityRecordProtoReader) bool {
        return self._should_force_rotate_for_camera_compat;
    }
    pub inline fn getShouldRefreshActivityForCameraCompat(self: *const ActivityRecordProtoReader) bool {
        return self._should_refresh_activity_for_camera_compat;
    }
    pub inline fn getShouldRefreshActivityViaPauseForCameraCompat(self: *const ActivityRecordProtoReader) bool {
        return self._should_refresh_activity_via_pause_for_camera_compat;
    }
    pub inline fn getShouldOverrideMinAspectRatio(self: *const ActivityRecordProtoReader) bool {
        return self._should_override_min_aspect_ratio;
    }
    pub inline fn getShouldIgnoreOrientationRequestLoop(self: *const ActivityRecordProtoReader) bool {
        return self._should_ignore_orientation_request_loop;
    }
    pub inline fn getShouldOverrideForceResizeApp(self: *const ActivityRecordProtoReader) bool {
        return self._should_override_force_resize_app;
    }
    pub inline fn getShouldEnableUserAspectRatioSettings(self: *const ActivityRecordProtoReader) bool {
        return self._should_enable_user_aspect_ratio_settings;
    }
    pub inline fn getIsUserFullscreenOverrideEnabled(self: *const ActivityRecordProtoReader) bool {
        return self._is_user_fullscreen_override_enabled;
    }
    pub inline fn getRequestOpenInBrowserEducationTimestamp(self: *const ActivityRecordProtoReader) i64 {
        return self._request_open_in_browser_education_timestamp;
    }
    pub inline fn getShouldAllowSimulateRequestedOrientationForCameraCompat(self: *const ActivityRecordProtoReader) bool {
        return self._should_allow_simulate_requested_orientation_for_camera_compat;
    }
    pub fn getSafeRegionBounds(self: *const ActivityRecordProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._safe_region_bounds_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
};
const WindowTokenProtoWire = struct {
    const WINDOW_CONTAINER_WIRE: gremlin.ProtoWireNumber = 1;
    const HASH_CODE_WIRE: gremlin.ProtoWireNumber = 2;
    const WINDOWS_WIRE: gremlin.ProtoWireNumber = 3;
    const WAITING_TO_SHOW_WIRE: gremlin.ProtoWireNumber = 5;
    const PAUSED_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const WindowTokenProto = struct {
    // fields
    window_container: ?WindowContainerProto = null,
    hash_code: i32 = 0,
    windows: ?[]const ?WindowStateProto = null,
    waiting_to_show: bool = false,
    paused: bool = false,
    pub fn calcProtobufSize(self: *const WindowTokenProto) usize {
        var res: usize = 0;
        if (self.window_container) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowTokenProtoWire.WINDOW_CONTAINER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.hash_code != 0) {
            res += gremlin.sizes.sizeWireNumber(WindowTokenProtoWire.HASH_CODE_WIRE) + gremlin.sizes.sizeI32(self.hash_code);
        }
        if (self.windows) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(WindowTokenProtoWire.WINDOWS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.waiting_to_show != false) {
            res += gremlin.sizes.sizeWireNumber(WindowTokenProtoWire.WAITING_TO_SHOW_WIRE) + gremlin.sizes.sizeBool(self.waiting_to_show);
        }
        if (self.paused != false) {
            res += gremlin.sizes.sizeWireNumber(WindowTokenProtoWire.PAUSED_WIRE) + gremlin.sizes.sizeBool(self.paused);
        }
        return res;
    }
    pub fn encode(self: *const WindowTokenProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const WindowTokenProto, target: *gremlin.Writer) void {
        if (self.window_container) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowTokenProtoWire.WINDOW_CONTAINER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.hash_code != 0) {
            target.appendInt32(WindowTokenProtoWire.HASH_CODE_WIRE, self.hash_code);
        }
        if (self.windows) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(WindowTokenProtoWire.WINDOWS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(WindowTokenProtoWire.WINDOWS_WIRE, 0);
                }
            }
        }
        if (self.waiting_to_show != false) {
            target.appendBool(WindowTokenProtoWire.WAITING_TO_SHOW_WIRE, self.waiting_to_show);
        }
        if (self.paused != false) {
            target.appendBool(WindowTokenProtoWire.PAUSED_WIRE, self.paused);
        }
    }
};
pub const WindowTokenProtoReader = struct {
    buf: gremlin.Reader,
    _window_container_buf: ?[]const u8 = null,
    _hash_code: i32 = 0,
    _windows_offset: ?usize = null,
    _windows_last_offset: ?usize = null,
    _windows_cnt: usize = 0,
    _waiting_to_show: bool = false,
    _paused: bool = false,
    pub fn init(src: []const u8) gremlin.Error!WindowTokenProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = WindowTokenProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                WindowTokenProtoWire.WINDOW_CONTAINER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._window_container_buf = result.value;
                },
                WindowTokenProtoWire.HASH_CODE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._hash_code = result.value;
                },
                WindowTokenProtoWire.WINDOWS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._windows_offset == null) {
                        res._windows_offset = offset - result.size;
                    }
                    res._windows_last_offset = offset;
                    res._windows_cnt += 1;
                },
                WindowTokenProtoWire.WAITING_TO_SHOW_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._waiting_to_show = result.value;
                },
                WindowTokenProtoWire.PAUSED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._paused = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getWindowContainer(self: *const WindowTokenProtoReader) gremlin.Error!WindowContainerProtoReader {
        if (self._window_container_buf) |buf| {
            return try WindowContainerProtoReader.init(buf);
        }
        return try WindowContainerProtoReader.init(&[_]u8{});
    }
    pub inline fn getHashCode(self: *const WindowTokenProtoReader) i32 {
        return self._hash_code;
    }
    pub fn windowsCount(self: *const WindowTokenProtoReader) usize {
        return self._windows_cnt;
    }
    pub fn windowsNext(self: *WindowTokenProtoReader) ?WindowStateProtoReader {
        if (self._windows_offset == null) return null;
        const current_offset = self._windows_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = WindowStateProtoReader.init(result.value) catch return null;
        if (self._windows_last_offset != null and current_offset >= self._windows_last_offset.?) {
            self._windows_offset = null;
            return msg;
        }
        if (self._windows_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._windows_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == WindowTokenProtoWire.WINDOWS_WIRE) {
                self._windows_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._windows_offset = null;
        return msg;
    }
    pub inline fn getWaitingToShow(self: *const WindowTokenProtoReader) bool {
        return self._waiting_to_show;
    }
    pub inline fn getPaused(self: *const WindowTokenProtoReader) bool {
        return self._paused;
    }
};
const WindowStateProtoWire = struct {
    const WINDOW_CONTAINER_WIRE: gremlin.ProtoWireNumber = 1;
    const IDENTIFIER_WIRE: gremlin.ProtoWireNumber = 2;
    const DISPLAY_ID_WIRE: gremlin.ProtoWireNumber = 3;
    const STACK_ID_WIRE: gremlin.ProtoWireNumber = 4;
    const ATTRIBUTES_WIRE: gremlin.ProtoWireNumber = 5;
    const GIVEN_CONTENT_INSETS_WIRE: gremlin.ProtoWireNumber = 6;
    const FRAME_WIRE: gremlin.ProtoWireNumber = 7;
    const CONTAINING_FRAME_WIRE: gremlin.ProtoWireNumber = 8;
    const PARENT_FRAME_WIRE: gremlin.ProtoWireNumber = 9;
    const CONTENT_FRAME_WIRE: gremlin.ProtoWireNumber = 10;
    const CONTENT_INSETS_WIRE: gremlin.ProtoWireNumber = 11;
    const SURFACE_INSETS_WIRE: gremlin.ProtoWireNumber = 12;
    const ANIMATOR_WIRE: gremlin.ProtoWireNumber = 13;
    const ANIMATING_EXIT_WIRE: gremlin.ProtoWireNumber = 14;
    const CHILD_WINDOWS_WIRE: gremlin.ProtoWireNumber = 15;
    const SURFACE_POSITION_WIRE: gremlin.ProtoWireNumber = 16;
    const REQUESTED_WIDTH_WIRE: gremlin.ProtoWireNumber = 18;
    const REQUESTED_HEIGHT_WIRE: gremlin.ProtoWireNumber = 19;
    const VIEW_VISIBILITY_WIRE: gremlin.ProtoWireNumber = 20;
    const SYSTEM_UI_VISIBILITY_WIRE: gremlin.ProtoWireNumber = 21;
    const HAS_SURFACE_WIRE: gremlin.ProtoWireNumber = 22;
    const IS_READY_FOR_DISPLAY_WIRE: gremlin.ProtoWireNumber = 23;
    const DISPLAY_FRAME_WIRE: gremlin.ProtoWireNumber = 24;
    const OVERSCAN_FRAME_WIRE: gremlin.ProtoWireNumber = 25;
    const VISIBLE_FRAME_WIRE: gremlin.ProtoWireNumber = 26;
    const DECOR_FRAME_WIRE: gremlin.ProtoWireNumber = 27;
    const OUTSET_FRAME_WIRE: gremlin.ProtoWireNumber = 28;
    const OVERSCAN_INSETS_WIRE: gremlin.ProtoWireNumber = 29;
    const VISIBLE_INSETS_WIRE: gremlin.ProtoWireNumber = 30;
    const STABLE_INSETS_WIRE: gremlin.ProtoWireNumber = 31;
    const OUTSETS_WIRE: gremlin.ProtoWireNumber = 32;
    const CUTOUT_WIRE: gremlin.ProtoWireNumber = 33;
    const REMOVE_ON_EXIT_WIRE: gremlin.ProtoWireNumber = 34;
    const DESTROYING_WIRE: gremlin.ProtoWireNumber = 35;
    const REMOVED_WIRE: gremlin.ProtoWireNumber = 36;
    const IS_ON_SCREEN_WIRE: gremlin.ProtoWireNumber = 37;
    const IS_VISIBLE_WIRE: gremlin.ProtoWireNumber = 38;
    const PENDING_SEAMLESS_ROTATION_WIRE: gremlin.ProtoWireNumber = 39;
    const FINISHED_SEAMLESS_ROTATION_FRAME_WIRE: gremlin.ProtoWireNumber = 40;
    const WINDOW_FRAMES_WIRE: gremlin.ProtoWireNumber = 41;
    const FORCE_SEAMLESS_ROTATION_WIRE: gremlin.ProtoWireNumber = 42;
    const HAS_COMPAT_SCALE_WIRE: gremlin.ProtoWireNumber = 43;
    const GLOBAL_SCALE_WIRE: gremlin.ProtoWireNumber = 44;
    const KEEP_CLEAR_AREAS_WIRE: gremlin.ProtoWireNumber = 45;
    const UNRESTRICTED_KEEP_CLEAR_AREAS_WIRE: gremlin.ProtoWireNumber = 46;
    const MERGED_LOCAL_INSETS_SOURCES_WIRE: gremlin.ProtoWireNumber = 47;
    const REQUESTED_VISIBLE_TYPES_WIRE: gremlin.ProtoWireNumber = 48;
    const DIM_BOUNDS_WIRE: gremlin.ProtoWireNumber = 49;
    const BUFFER_SEQ_ID_WIRE: gremlin.ProtoWireNumber = 50;
    const SYNC_SEQ_ID_WIRE: gremlin.ProtoWireNumber = 51;
    const ANIMATING_TYPES_WIRE: gremlin.ProtoWireNumber = 52;
};
pub const WindowStateProto = struct {
    // fields
    window_container: ?WindowContainerProto = null,
    identifier: ?IdentifierProto = null,
    display_id: i32 = 0,
    stack_id: i32 = 0,
    attributes: ?windowlayoutparams.WindowLayoutParamsProto = null,
    given_content_insets: ?rect.RectProto = null,
    frame: ?rect.RectProto = null,
    containing_frame: ?rect.RectProto = null,
    parent_frame: ?rect.RectProto = null,
    content_frame: ?rect.RectProto = null,
    content_insets: ?rect.RectProto = null,
    surface_insets: ?rect.RectProto = null,
    animator: ?WindowStateAnimatorProto = null,
    animating_exit: bool = false,
    child_windows: ?[]const ?WindowStateProto = null,
    surface_position: ?rect.RectProto = null,
    requested_width: i32 = 0,
    requested_height: i32 = 0,
    view_visibility: i32 = 0,
    system_ui_visibility: i32 = 0,
    has_surface: bool = false,
    is_ready_for_display: bool = false,
    display_frame: ?rect.RectProto = null,
    overscan_frame: ?rect.RectProto = null,
    visible_frame: ?rect.RectProto = null,
    decor_frame: ?rect.RectProto = null,
    outset_frame: ?rect.RectProto = null,
    overscan_insets: ?rect.RectProto = null,
    visible_insets: ?rect.RectProto = null,
    stable_insets: ?rect.RectProto = null,
    outsets: ?rect.RectProto = null,
    cutout: ?displaycutout.DisplayCutoutProto = null,
    remove_on_exit: bool = false,
    destroying: bool = false,
    removed: bool = false,
    is_on_screen: bool = false,
    is_visible: bool = false,
    pending_seamless_rotation: bool = false,
    finished_seamless_rotation_frame: i64 = 0,
    window_frames: ?WindowFramesProto = null,
    force_seamless_rotation: bool = false,
    has_compat_scale: bool = false,
    global_scale: f32 = 0.0,
    keep_clear_areas: ?[]const ?rect.RectProto = null,
    unrestricted_keep_clear_areas: ?[]const ?rect.RectProto = null,
    merged_local_insets_sources: ?[]const ?insetssource.InsetsSourceProto = null,
    requested_visible_types: i32 = 0,
    dim_bounds: ?rect.RectProto = null,
    buffer_seq_id: i32 = 0,
    sync_seq_id: i32 = 0,
    animating_types: i32 = 0,
    pub fn calcProtobufSize(self: *const WindowStateProto) usize {
        var res: usize = 0;
        if (self.window_container) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.WINDOW_CONTAINER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.identifier) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.IDENTIFIER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.display_id != 0) {
            res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.DISPLAY_ID_WIRE) + gremlin.sizes.sizeI32(self.display_id);
        }
        if (self.stack_id != 0) {
            res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.STACK_ID_WIRE) + gremlin.sizes.sizeI32(self.stack_id);
        }
        if (self.attributes) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.ATTRIBUTES_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.given_content_insets) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.GIVEN_CONTENT_INSETS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.FRAME_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.containing_frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.CONTAINING_FRAME_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.parent_frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.PARENT_FRAME_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.content_frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.CONTENT_FRAME_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.content_insets) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.CONTENT_INSETS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.surface_insets) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.SURFACE_INSETS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.animator) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.ANIMATOR_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.animating_exit != false) {
            res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.ANIMATING_EXIT_WIRE) + gremlin.sizes.sizeBool(self.animating_exit);
        }
        if (self.child_windows) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.CHILD_WINDOWS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.surface_position) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.SURFACE_POSITION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.requested_width != 0) {
            res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.REQUESTED_WIDTH_WIRE) + gremlin.sizes.sizeI32(self.requested_width);
        }
        if (self.requested_height != 0) {
            res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.REQUESTED_HEIGHT_WIRE) + gremlin.sizes.sizeI32(self.requested_height);
        }
        if (self.view_visibility != 0) {
            res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.VIEW_VISIBILITY_WIRE) + gremlin.sizes.sizeI32(self.view_visibility);
        }
        if (self.system_ui_visibility != 0) {
            res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.SYSTEM_UI_VISIBILITY_WIRE) + gremlin.sizes.sizeI32(self.system_ui_visibility);
        }
        if (self.has_surface != false) {
            res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.HAS_SURFACE_WIRE) + gremlin.sizes.sizeBool(self.has_surface);
        }
        if (self.is_ready_for_display != false) {
            res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.IS_READY_FOR_DISPLAY_WIRE) + gremlin.sizes.sizeBool(self.is_ready_for_display);
        }
        if (self.display_frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.DISPLAY_FRAME_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.overscan_frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.OVERSCAN_FRAME_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.visible_frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.VISIBLE_FRAME_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.decor_frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.DECOR_FRAME_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.outset_frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.OUTSET_FRAME_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.overscan_insets) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.OVERSCAN_INSETS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.visible_insets) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.VISIBLE_INSETS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.stable_insets) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.STABLE_INSETS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.outsets) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.OUTSETS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cutout) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.CUTOUT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.remove_on_exit != false) {
            res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.REMOVE_ON_EXIT_WIRE) + gremlin.sizes.sizeBool(self.remove_on_exit);
        }
        if (self.destroying != false) {
            res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.DESTROYING_WIRE) + gremlin.sizes.sizeBool(self.destroying);
        }
        if (self.removed != false) {
            res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.REMOVED_WIRE) + gremlin.sizes.sizeBool(self.removed);
        }
        if (self.is_on_screen != false) {
            res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.IS_ON_SCREEN_WIRE) + gremlin.sizes.sizeBool(self.is_on_screen);
        }
        if (self.is_visible != false) {
            res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.IS_VISIBLE_WIRE) + gremlin.sizes.sizeBool(self.is_visible);
        }
        if (self.pending_seamless_rotation != false) {
            res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.PENDING_SEAMLESS_ROTATION_WIRE) + gremlin.sizes.sizeBool(self.pending_seamless_rotation);
        }
        if (self.finished_seamless_rotation_frame != 0) {
            res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.FINISHED_SEAMLESS_ROTATION_FRAME_WIRE) + gremlin.sizes.sizeI64(self.finished_seamless_rotation_frame);
        }
        if (self.window_frames) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.WINDOW_FRAMES_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.force_seamless_rotation != false) {
            res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.FORCE_SEAMLESS_ROTATION_WIRE) + gremlin.sizes.sizeBool(self.force_seamless_rotation);
        }
        if (self.has_compat_scale != false) {
            res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.HAS_COMPAT_SCALE_WIRE) + gremlin.sizes.sizeBool(self.has_compat_scale);
        }
        if (self.global_scale != 0.0) {
            res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.GLOBAL_SCALE_WIRE) + gremlin.sizes.sizeFloat(self.global_scale);
        }
        if (self.keep_clear_areas) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.KEEP_CLEAR_AREAS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.unrestricted_keep_clear_areas) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.UNRESTRICTED_KEEP_CLEAR_AREAS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.merged_local_insets_sources) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.MERGED_LOCAL_INSETS_SOURCES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.requested_visible_types != 0) {
            res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.REQUESTED_VISIBLE_TYPES_WIRE) + gremlin.sizes.sizeI32(self.requested_visible_types);
        }
        if (self.dim_bounds) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.DIM_BOUNDS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.buffer_seq_id != 0) {
            res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.BUFFER_SEQ_ID_WIRE) + gremlin.sizes.sizeI32(self.buffer_seq_id);
        }
        if (self.sync_seq_id != 0) {
            res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.SYNC_SEQ_ID_WIRE) + gremlin.sizes.sizeI32(self.sync_seq_id);
        }
        if (self.animating_types != 0) {
            res += gremlin.sizes.sizeWireNumber(WindowStateProtoWire.ANIMATING_TYPES_WIRE) + gremlin.sizes.sizeI32(self.animating_types);
        }
        return res;
    }
    pub fn encode(self: *const WindowStateProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const WindowStateProto, target: *gremlin.Writer) void {
        if (self.window_container) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowStateProtoWire.WINDOW_CONTAINER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.identifier) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowStateProtoWire.IDENTIFIER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.display_id != 0) {
            target.appendInt32(WindowStateProtoWire.DISPLAY_ID_WIRE, self.display_id);
        }
        if (self.stack_id != 0) {
            target.appendInt32(WindowStateProtoWire.STACK_ID_WIRE, self.stack_id);
        }
        if (self.attributes) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowStateProtoWire.ATTRIBUTES_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.given_content_insets) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowStateProtoWire.GIVEN_CONTENT_INSETS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowStateProtoWire.FRAME_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.containing_frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowStateProtoWire.CONTAINING_FRAME_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.parent_frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowStateProtoWire.PARENT_FRAME_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.content_frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowStateProtoWire.CONTENT_FRAME_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.content_insets) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowStateProtoWire.CONTENT_INSETS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.surface_insets) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowStateProtoWire.SURFACE_INSETS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.animator) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowStateProtoWire.ANIMATOR_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.animating_exit != false) {
            target.appendBool(WindowStateProtoWire.ANIMATING_EXIT_WIRE, self.animating_exit);
        }
        if (self.child_windows) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(WindowStateProtoWire.CHILD_WINDOWS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(WindowStateProtoWire.CHILD_WINDOWS_WIRE, 0);
                }
            }
        }
        if (self.surface_position) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowStateProtoWire.SURFACE_POSITION_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.requested_width != 0) {
            target.appendInt32(WindowStateProtoWire.REQUESTED_WIDTH_WIRE, self.requested_width);
        }
        if (self.requested_height != 0) {
            target.appendInt32(WindowStateProtoWire.REQUESTED_HEIGHT_WIRE, self.requested_height);
        }
        if (self.view_visibility != 0) {
            target.appendInt32(WindowStateProtoWire.VIEW_VISIBILITY_WIRE, self.view_visibility);
        }
        if (self.system_ui_visibility != 0) {
            target.appendInt32(WindowStateProtoWire.SYSTEM_UI_VISIBILITY_WIRE, self.system_ui_visibility);
        }
        if (self.has_surface != false) {
            target.appendBool(WindowStateProtoWire.HAS_SURFACE_WIRE, self.has_surface);
        }
        if (self.is_ready_for_display != false) {
            target.appendBool(WindowStateProtoWire.IS_READY_FOR_DISPLAY_WIRE, self.is_ready_for_display);
        }
        if (self.display_frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowStateProtoWire.DISPLAY_FRAME_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.overscan_frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowStateProtoWire.OVERSCAN_FRAME_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.visible_frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowStateProtoWire.VISIBLE_FRAME_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.decor_frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowStateProtoWire.DECOR_FRAME_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.outset_frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowStateProtoWire.OUTSET_FRAME_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.overscan_insets) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowStateProtoWire.OVERSCAN_INSETS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.visible_insets) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowStateProtoWire.VISIBLE_INSETS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.stable_insets) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowStateProtoWire.STABLE_INSETS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.outsets) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowStateProtoWire.OUTSETS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cutout) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowStateProtoWire.CUTOUT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.remove_on_exit != false) {
            target.appendBool(WindowStateProtoWire.REMOVE_ON_EXIT_WIRE, self.remove_on_exit);
        }
        if (self.destroying != false) {
            target.appendBool(WindowStateProtoWire.DESTROYING_WIRE, self.destroying);
        }
        if (self.removed != false) {
            target.appendBool(WindowStateProtoWire.REMOVED_WIRE, self.removed);
        }
        if (self.is_on_screen != false) {
            target.appendBool(WindowStateProtoWire.IS_ON_SCREEN_WIRE, self.is_on_screen);
        }
        if (self.is_visible != false) {
            target.appendBool(WindowStateProtoWire.IS_VISIBLE_WIRE, self.is_visible);
        }
        if (self.pending_seamless_rotation != false) {
            target.appendBool(WindowStateProtoWire.PENDING_SEAMLESS_ROTATION_WIRE, self.pending_seamless_rotation);
        }
        if (self.finished_seamless_rotation_frame != 0) {
            target.appendInt64(WindowStateProtoWire.FINISHED_SEAMLESS_ROTATION_FRAME_WIRE, self.finished_seamless_rotation_frame);
        }
        if (self.window_frames) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowStateProtoWire.WINDOW_FRAMES_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.force_seamless_rotation != false) {
            target.appendBool(WindowStateProtoWire.FORCE_SEAMLESS_ROTATION_WIRE, self.force_seamless_rotation);
        }
        if (self.has_compat_scale != false) {
            target.appendBool(WindowStateProtoWire.HAS_COMPAT_SCALE_WIRE, self.has_compat_scale);
        }
        if (self.global_scale != 0.0) {
            target.appendFloat32(WindowStateProtoWire.GLOBAL_SCALE_WIRE, self.global_scale);
        }
        if (self.keep_clear_areas) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(WindowStateProtoWire.KEEP_CLEAR_AREAS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(WindowStateProtoWire.KEEP_CLEAR_AREAS_WIRE, 0);
                }
            }
        }
        if (self.unrestricted_keep_clear_areas) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(WindowStateProtoWire.UNRESTRICTED_KEEP_CLEAR_AREAS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(WindowStateProtoWire.UNRESTRICTED_KEEP_CLEAR_AREAS_WIRE, 0);
                }
            }
        }
        if (self.merged_local_insets_sources) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(WindowStateProtoWire.MERGED_LOCAL_INSETS_SOURCES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(WindowStateProtoWire.MERGED_LOCAL_INSETS_SOURCES_WIRE, 0);
                }
            }
        }
        if (self.requested_visible_types != 0) {
            target.appendInt32(WindowStateProtoWire.REQUESTED_VISIBLE_TYPES_WIRE, self.requested_visible_types);
        }
        if (self.dim_bounds) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowStateProtoWire.DIM_BOUNDS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.buffer_seq_id != 0) {
            target.appendInt32(WindowStateProtoWire.BUFFER_SEQ_ID_WIRE, self.buffer_seq_id);
        }
        if (self.sync_seq_id != 0) {
            target.appendInt32(WindowStateProtoWire.SYNC_SEQ_ID_WIRE, self.sync_seq_id);
        }
        if (self.animating_types != 0) {
            target.appendInt32(WindowStateProtoWire.ANIMATING_TYPES_WIRE, self.animating_types);
        }
    }
};
pub const WindowStateProtoReader = struct {
    buf: gremlin.Reader,
    _window_container_buf: ?[]const u8 = null,
    _identifier_buf: ?[]const u8 = null,
    _display_id: i32 = 0,
    _stack_id: i32 = 0,
    _attributes_buf: ?[]const u8 = null,
    _given_content_insets_buf: ?[]const u8 = null,
    _frame_buf: ?[]const u8 = null,
    _containing_frame_buf: ?[]const u8 = null,
    _parent_frame_buf: ?[]const u8 = null,
    _content_frame_buf: ?[]const u8 = null,
    _content_insets_buf: ?[]const u8 = null,
    _surface_insets_buf: ?[]const u8 = null,
    _animator_buf: ?[]const u8 = null,
    _animating_exit: bool = false,
    _child_windows_offset: ?usize = null,
    _child_windows_last_offset: ?usize = null,
    _child_windows_cnt: usize = 0,
    _surface_position_buf: ?[]const u8 = null,
    _requested_width: i32 = 0,
    _requested_height: i32 = 0,
    _view_visibility: i32 = 0,
    _system_ui_visibility: i32 = 0,
    _has_surface: bool = false,
    _is_ready_for_display: bool = false,
    _display_frame_buf: ?[]const u8 = null,
    _overscan_frame_buf: ?[]const u8 = null,
    _visible_frame_buf: ?[]const u8 = null,
    _decor_frame_buf: ?[]const u8 = null,
    _outset_frame_buf: ?[]const u8 = null,
    _overscan_insets_buf: ?[]const u8 = null,
    _visible_insets_buf: ?[]const u8 = null,
    _stable_insets_buf: ?[]const u8 = null,
    _outsets_buf: ?[]const u8 = null,
    _cutout_buf: ?[]const u8 = null,
    _remove_on_exit: bool = false,
    _destroying: bool = false,
    _removed: bool = false,
    _is_on_screen: bool = false,
    _is_visible: bool = false,
    _pending_seamless_rotation: bool = false,
    _finished_seamless_rotation_frame: i64 = 0,
    _window_frames_buf: ?[]const u8 = null,
    _force_seamless_rotation: bool = false,
    _has_compat_scale: bool = false,
    _global_scale: f32 = 0.0,
    _keep_clear_areas_offset: ?usize = null,
    _keep_clear_areas_last_offset: ?usize = null,
    _keep_clear_areas_cnt: usize = 0,
    _unrestricted_keep_clear_areas_offset: ?usize = null,
    _unrestricted_keep_clear_areas_last_offset: ?usize = null,
    _unrestricted_keep_clear_areas_cnt: usize = 0,
    _merged_local_insets_sources_offset: ?usize = null,
    _merged_local_insets_sources_last_offset: ?usize = null,
    _merged_local_insets_sources_cnt: usize = 0,
    _requested_visible_types: i32 = 0,
    _dim_bounds_buf: ?[]const u8 = null,
    _buffer_seq_id: i32 = 0,
    _sync_seq_id: i32 = 0,
    _animating_types: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!WindowStateProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = WindowStateProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                WindowStateProtoWire.WINDOW_CONTAINER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._window_container_buf = result.value;
                },
                WindowStateProtoWire.IDENTIFIER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._identifier_buf = result.value;
                },
                WindowStateProtoWire.DISPLAY_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._display_id = result.value;
                },
                WindowStateProtoWire.STACK_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._stack_id = result.value;
                },
                WindowStateProtoWire.ATTRIBUTES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._attributes_buf = result.value;
                },
                WindowStateProtoWire.GIVEN_CONTENT_INSETS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._given_content_insets_buf = result.value;
                },
                WindowStateProtoWire.FRAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._frame_buf = result.value;
                },
                WindowStateProtoWire.CONTAINING_FRAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._containing_frame_buf = result.value;
                },
                WindowStateProtoWire.PARENT_FRAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._parent_frame_buf = result.value;
                },
                WindowStateProtoWire.CONTENT_FRAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._content_frame_buf = result.value;
                },
                WindowStateProtoWire.CONTENT_INSETS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._content_insets_buf = result.value;
                },
                WindowStateProtoWire.SURFACE_INSETS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._surface_insets_buf = result.value;
                },
                WindowStateProtoWire.ANIMATOR_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._animator_buf = result.value;
                },
                WindowStateProtoWire.ANIMATING_EXIT_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._animating_exit = result.value;
                },
                WindowStateProtoWire.CHILD_WINDOWS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._child_windows_offset == null) {
                        res._child_windows_offset = offset - result.size;
                    }
                    res._child_windows_last_offset = offset;
                    res._child_windows_cnt += 1;
                },
                WindowStateProtoWire.SURFACE_POSITION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._surface_position_buf = result.value;
                },
                WindowStateProtoWire.REQUESTED_WIDTH_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._requested_width = result.value;
                },
                WindowStateProtoWire.REQUESTED_HEIGHT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._requested_height = result.value;
                },
                WindowStateProtoWire.VIEW_VISIBILITY_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._view_visibility = result.value;
                },
                WindowStateProtoWire.SYSTEM_UI_VISIBILITY_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._system_ui_visibility = result.value;
                },
                WindowStateProtoWire.HAS_SURFACE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._has_surface = result.value;
                },
                WindowStateProtoWire.IS_READY_FOR_DISPLAY_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_ready_for_display = result.value;
                },
                WindowStateProtoWire.DISPLAY_FRAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._display_frame_buf = result.value;
                },
                WindowStateProtoWire.OVERSCAN_FRAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._overscan_frame_buf = result.value;
                },
                WindowStateProtoWire.VISIBLE_FRAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._visible_frame_buf = result.value;
                },
                WindowStateProtoWire.DECOR_FRAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._decor_frame_buf = result.value;
                },
                WindowStateProtoWire.OUTSET_FRAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._outset_frame_buf = result.value;
                },
                WindowStateProtoWire.OVERSCAN_INSETS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._overscan_insets_buf = result.value;
                },
                WindowStateProtoWire.VISIBLE_INSETS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._visible_insets_buf = result.value;
                },
                WindowStateProtoWire.STABLE_INSETS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._stable_insets_buf = result.value;
                },
                WindowStateProtoWire.OUTSETS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._outsets_buf = result.value;
                },
                WindowStateProtoWire.CUTOUT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cutout_buf = result.value;
                },
                WindowStateProtoWire.REMOVE_ON_EXIT_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._remove_on_exit = result.value;
                },
                WindowStateProtoWire.DESTROYING_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._destroying = result.value;
                },
                WindowStateProtoWire.REMOVED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._removed = result.value;
                },
                WindowStateProtoWire.IS_ON_SCREEN_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_on_screen = result.value;
                },
                WindowStateProtoWire.IS_VISIBLE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_visible = result.value;
                },
                WindowStateProtoWire.PENDING_SEAMLESS_ROTATION_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._pending_seamless_rotation = result.value;
                },
                WindowStateProtoWire.FINISHED_SEAMLESS_ROTATION_FRAME_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._finished_seamless_rotation_frame = result.value;
                },
                WindowStateProtoWire.WINDOW_FRAMES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._window_frames_buf = result.value;
                },
                WindowStateProtoWire.FORCE_SEAMLESS_ROTATION_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._force_seamless_rotation = result.value;
                },
                WindowStateProtoWire.HAS_COMPAT_SCALE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._has_compat_scale = result.value;
                },
                WindowStateProtoWire.GLOBAL_SCALE_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._global_scale = result.value;
                },
                WindowStateProtoWire.KEEP_CLEAR_AREAS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._keep_clear_areas_offset == null) {
                        res._keep_clear_areas_offset = offset - result.size;
                    }
                    res._keep_clear_areas_last_offset = offset;
                    res._keep_clear_areas_cnt += 1;
                },
                WindowStateProtoWire.UNRESTRICTED_KEEP_CLEAR_AREAS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._unrestricted_keep_clear_areas_offset == null) {
                        res._unrestricted_keep_clear_areas_offset = offset - result.size;
                    }
                    res._unrestricted_keep_clear_areas_last_offset = offset;
                    res._unrestricted_keep_clear_areas_cnt += 1;
                },
                WindowStateProtoWire.MERGED_LOCAL_INSETS_SOURCES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._merged_local_insets_sources_offset == null) {
                        res._merged_local_insets_sources_offset = offset - result.size;
                    }
                    res._merged_local_insets_sources_last_offset = offset;
                    res._merged_local_insets_sources_cnt += 1;
                },
                WindowStateProtoWire.REQUESTED_VISIBLE_TYPES_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._requested_visible_types = result.value;
                },
                WindowStateProtoWire.DIM_BOUNDS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dim_bounds_buf = result.value;
                },
                WindowStateProtoWire.BUFFER_SEQ_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._buffer_seq_id = result.value;
                },
                WindowStateProtoWire.SYNC_SEQ_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._sync_seq_id = result.value;
                },
                WindowStateProtoWire.ANIMATING_TYPES_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._animating_types = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getWindowContainer(self: *const WindowStateProtoReader) gremlin.Error!WindowContainerProtoReader {
        if (self._window_container_buf) |buf| {
            return try WindowContainerProtoReader.init(buf);
        }
        return try WindowContainerProtoReader.init(&[_]u8{});
    }
    pub fn getIdentifier(self: *const WindowStateProtoReader) gremlin.Error!IdentifierProtoReader {
        if (self._identifier_buf) |buf| {
            return try IdentifierProtoReader.init(buf);
        }
        return try IdentifierProtoReader.init(&[_]u8{});
    }
    pub inline fn getDisplayId(self: *const WindowStateProtoReader) i32 {
        return self._display_id;
    }
    pub inline fn getStackId(self: *const WindowStateProtoReader) i32 {
        return self._stack_id;
    }
    pub fn getAttributes(self: *const WindowStateProtoReader) gremlin.Error!windowlayoutparams.WindowLayoutParamsProtoReader {
        if (self._attributes_buf) |buf| {
            return try windowlayoutparams.WindowLayoutParamsProtoReader.init(buf);
        }
        return try windowlayoutparams.WindowLayoutParamsProtoReader.init(&[_]u8{});
    }
    pub fn getGivenContentInsets(self: *const WindowStateProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._given_content_insets_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getFrame(self: *const WindowStateProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._frame_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getContainingFrame(self: *const WindowStateProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._containing_frame_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getParentFrame(self: *const WindowStateProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._parent_frame_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getContentFrame(self: *const WindowStateProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._content_frame_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getContentInsets(self: *const WindowStateProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._content_insets_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getSurfaceInsets(self: *const WindowStateProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._surface_insets_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getAnimator(self: *const WindowStateProtoReader) gremlin.Error!WindowStateAnimatorProtoReader {
        if (self._animator_buf) |buf| {
            return try WindowStateAnimatorProtoReader.init(buf);
        }
        return try WindowStateAnimatorProtoReader.init(&[_]u8{});
    }
    pub inline fn getAnimatingExit(self: *const WindowStateProtoReader) bool {
        return self._animating_exit;
    }
    pub fn childWindowsCount(self: *const WindowStateProtoReader) usize {
        return self._child_windows_cnt;
    }
    pub fn childWindowsNext(self: *WindowStateProtoReader) ?WindowStateProtoReader {
        if (self._child_windows_offset == null) return null;
        const current_offset = self._child_windows_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = WindowStateProtoReader.init(result.value) catch return null;
        if (self._child_windows_last_offset != null and current_offset >= self._child_windows_last_offset.?) {
            self._child_windows_offset = null;
            return msg;
        }
        if (self._child_windows_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._child_windows_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == WindowStateProtoWire.CHILD_WINDOWS_WIRE) {
                self._child_windows_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._child_windows_offset = null;
        return msg;
    }
    pub fn getSurfacePosition(self: *const WindowStateProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._surface_position_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub inline fn getRequestedWidth(self: *const WindowStateProtoReader) i32 {
        return self._requested_width;
    }
    pub inline fn getRequestedHeight(self: *const WindowStateProtoReader) i32 {
        return self._requested_height;
    }
    pub inline fn getViewVisibility(self: *const WindowStateProtoReader) i32 {
        return self._view_visibility;
    }
    pub inline fn getSystemUiVisibility(self: *const WindowStateProtoReader) i32 {
        return self._system_ui_visibility;
    }
    pub inline fn getHasSurface(self: *const WindowStateProtoReader) bool {
        return self._has_surface;
    }
    pub inline fn getIsReadyForDisplay(self: *const WindowStateProtoReader) bool {
        return self._is_ready_for_display;
    }
    pub fn getDisplayFrame(self: *const WindowStateProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._display_frame_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getOverscanFrame(self: *const WindowStateProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._overscan_frame_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getVisibleFrame(self: *const WindowStateProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._visible_frame_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getDecorFrame(self: *const WindowStateProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._decor_frame_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getOutsetFrame(self: *const WindowStateProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._outset_frame_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getOverscanInsets(self: *const WindowStateProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._overscan_insets_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getVisibleInsets(self: *const WindowStateProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._visible_insets_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getStableInsets(self: *const WindowStateProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._stable_insets_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getOutsets(self: *const WindowStateProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._outsets_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getCutout(self: *const WindowStateProtoReader) gremlin.Error!displaycutout.DisplayCutoutProtoReader {
        if (self._cutout_buf) |buf| {
            return try displaycutout.DisplayCutoutProtoReader.init(buf);
        }
        return try displaycutout.DisplayCutoutProtoReader.init(&[_]u8{});
    }
    pub inline fn getRemoveOnExit(self: *const WindowStateProtoReader) bool {
        return self._remove_on_exit;
    }
    pub inline fn getDestroying(self: *const WindowStateProtoReader) bool {
        return self._destroying;
    }
    pub inline fn getRemoved(self: *const WindowStateProtoReader) bool {
        return self._removed;
    }
    pub inline fn getIsOnScreen(self: *const WindowStateProtoReader) bool {
        return self._is_on_screen;
    }
    pub inline fn getIsVisible(self: *const WindowStateProtoReader) bool {
        return self._is_visible;
    }
    pub inline fn getPendingSeamlessRotation(self: *const WindowStateProtoReader) bool {
        return self._pending_seamless_rotation;
    }
    pub inline fn getFinishedSeamlessRotationFrame(self: *const WindowStateProtoReader) i64 {
        return self._finished_seamless_rotation_frame;
    }
    pub fn getWindowFrames(self: *const WindowStateProtoReader) gremlin.Error!WindowFramesProtoReader {
        if (self._window_frames_buf) |buf| {
            return try WindowFramesProtoReader.init(buf);
        }
        return try WindowFramesProtoReader.init(&[_]u8{});
    }
    pub inline fn getForceSeamlessRotation(self: *const WindowStateProtoReader) bool {
        return self._force_seamless_rotation;
    }
    pub inline fn getHasCompatScale(self: *const WindowStateProtoReader) bool {
        return self._has_compat_scale;
    }
    pub inline fn getGlobalScale(self: *const WindowStateProtoReader) f32 {
        return self._global_scale;
    }
    pub fn keepClearAreasCount(self: *const WindowStateProtoReader) usize {
        return self._keep_clear_areas_cnt;
    }
    pub fn keepClearAreasNext(self: *WindowStateProtoReader) ?rect.RectProtoReader {
        if (self._keep_clear_areas_offset == null) return null;
        const current_offset = self._keep_clear_areas_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = rect.RectProtoReader.init(result.value) catch return null;
        if (self._keep_clear_areas_last_offset != null and current_offset >= self._keep_clear_areas_last_offset.?) {
            self._keep_clear_areas_offset = null;
            return msg;
        }
        if (self._keep_clear_areas_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._keep_clear_areas_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == WindowStateProtoWire.KEEP_CLEAR_AREAS_WIRE) {
                self._keep_clear_areas_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._keep_clear_areas_offset = null;
        return msg;
    }
    pub fn unrestrictedKeepClearAreasCount(self: *const WindowStateProtoReader) usize {
        return self._unrestricted_keep_clear_areas_cnt;
    }
    pub fn unrestrictedKeepClearAreasNext(self: *WindowStateProtoReader) ?rect.RectProtoReader {
        if (self._unrestricted_keep_clear_areas_offset == null) return null;
        const current_offset = self._unrestricted_keep_clear_areas_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = rect.RectProtoReader.init(result.value) catch return null;
        if (self._unrestricted_keep_clear_areas_last_offset != null and current_offset >= self._unrestricted_keep_clear_areas_last_offset.?) {
            self._unrestricted_keep_clear_areas_offset = null;
            return msg;
        }
        if (self._unrestricted_keep_clear_areas_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._unrestricted_keep_clear_areas_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == WindowStateProtoWire.UNRESTRICTED_KEEP_CLEAR_AREAS_WIRE) {
                self._unrestricted_keep_clear_areas_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._unrestricted_keep_clear_areas_offset = null;
        return msg;
    }
    pub fn mergedLocalInsetsSourcesCount(self: *const WindowStateProtoReader) usize {
        return self._merged_local_insets_sources_cnt;
    }
    pub fn mergedLocalInsetsSourcesNext(self: *WindowStateProtoReader) ?insetssource.InsetsSourceProtoReader {
        if (self._merged_local_insets_sources_offset == null) return null;
        const current_offset = self._merged_local_insets_sources_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = insetssource.InsetsSourceProtoReader.init(result.value) catch return null;
        if (self._merged_local_insets_sources_last_offset != null and current_offset >= self._merged_local_insets_sources_last_offset.?) {
            self._merged_local_insets_sources_offset = null;
            return msg;
        }
        if (self._merged_local_insets_sources_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._merged_local_insets_sources_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == WindowStateProtoWire.MERGED_LOCAL_INSETS_SOURCES_WIRE) {
                self._merged_local_insets_sources_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._merged_local_insets_sources_offset = null;
        return msg;
    }
    pub inline fn getRequestedVisibleTypes(self: *const WindowStateProtoReader) i32 {
        return self._requested_visible_types;
    }
    pub fn getDimBounds(self: *const WindowStateProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._dim_bounds_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub inline fn getBufferSeqId(self: *const WindowStateProtoReader) i32 {
        return self._buffer_seq_id;
    }
    pub inline fn getSyncSeqId(self: *const WindowStateProtoReader) i32 {
        return self._sync_seq_id;
    }
    pub inline fn getAnimatingTypes(self: *const WindowStateProtoReader) i32 {
        return self._animating_types;
    }
};
const RemoteInsetsControlTargetProtoWire = struct {
    const IDENTIFIER_WIRE: gremlin.ProtoWireNumber = 1;
    const REQUESTED_VISIBLE_TYPES_WIRE: gremlin.ProtoWireNumber = 2;
    const ANIMATING_TYPES_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const RemoteInsetsControlTargetProto = struct {
    // fields
    identifier: ?IdentifierProto = null,
    requested_visible_types: i32 = 0,
    animating_types: i32 = 0,
    pub fn calcProtobufSize(self: *const RemoteInsetsControlTargetProto) usize {
        var res: usize = 0;
        if (self.identifier) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(RemoteInsetsControlTargetProtoWire.IDENTIFIER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.requested_visible_types != 0) {
            res += gremlin.sizes.sizeWireNumber(RemoteInsetsControlTargetProtoWire.REQUESTED_VISIBLE_TYPES_WIRE) + gremlin.sizes.sizeI32(self.requested_visible_types);
        }
        if (self.animating_types != 0) {
            res += gremlin.sizes.sizeWireNumber(RemoteInsetsControlTargetProtoWire.ANIMATING_TYPES_WIRE) + gremlin.sizes.sizeI32(self.animating_types);
        }
        return res;
    }
    pub fn encode(self: *const RemoteInsetsControlTargetProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const RemoteInsetsControlTargetProto, target: *gremlin.Writer) void {
        if (self.identifier) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(RemoteInsetsControlTargetProtoWire.IDENTIFIER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.requested_visible_types != 0) {
            target.appendInt32(RemoteInsetsControlTargetProtoWire.REQUESTED_VISIBLE_TYPES_WIRE, self.requested_visible_types);
        }
        if (self.animating_types != 0) {
            target.appendInt32(RemoteInsetsControlTargetProtoWire.ANIMATING_TYPES_WIRE, self.animating_types);
        }
    }
};
pub const RemoteInsetsControlTargetProtoReader = struct {
    buf: gremlin.Reader,
    _identifier_buf: ?[]const u8 = null,
    _requested_visible_types: i32 = 0,
    _animating_types: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!RemoteInsetsControlTargetProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = RemoteInsetsControlTargetProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                RemoteInsetsControlTargetProtoWire.IDENTIFIER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._identifier_buf = result.value;
                },
                RemoteInsetsControlTargetProtoWire.REQUESTED_VISIBLE_TYPES_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._requested_visible_types = result.value;
                },
                RemoteInsetsControlTargetProtoWire.ANIMATING_TYPES_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._animating_types = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getIdentifier(self: *const RemoteInsetsControlTargetProtoReader) gremlin.Error!IdentifierProtoReader {
        if (self._identifier_buf) |buf| {
            return try IdentifierProtoReader.init(buf);
        }
        return try IdentifierProtoReader.init(&[_]u8{});
    }
    pub inline fn getRequestedVisibleTypes(self: *const RemoteInsetsControlTargetProtoReader) i32 {
        return self._requested_visible_types;
    }
    pub inline fn getAnimatingTypes(self: *const RemoteInsetsControlTargetProtoReader) i32 {
        return self._animating_types;
    }
};
const IdentifierProtoWire = struct {
    const HASH_CODE_WIRE: gremlin.ProtoWireNumber = 1;
    const USER_ID_WIRE: gremlin.ProtoWireNumber = 2;
    const TITLE_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const IdentifierProto = struct {
    // fields
    hash_code: i32 = 0,
    user_id: i32 = 0,
    title: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const IdentifierProto) usize {
        var res: usize = 0;
        if (self.hash_code != 0) {
            res += gremlin.sizes.sizeWireNumber(IdentifierProtoWire.HASH_CODE_WIRE) + gremlin.sizes.sizeI32(self.hash_code);
        }
        if (self.user_id != 0) {
            res += gremlin.sizes.sizeWireNumber(IdentifierProtoWire.USER_ID_WIRE) + gremlin.sizes.sizeI32(self.user_id);
        }
        if (self.title) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(IdentifierProtoWire.TITLE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const IdentifierProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const IdentifierProto, target: *gremlin.Writer) void {
        if (self.hash_code != 0) {
            target.appendInt32(IdentifierProtoWire.HASH_CODE_WIRE, self.hash_code);
        }
        if (self.user_id != 0) {
            target.appendInt32(IdentifierProtoWire.USER_ID_WIRE, self.user_id);
        }
        if (self.title) |v| {
            if (v.len > 0) {
                target.appendBytes(IdentifierProtoWire.TITLE_WIRE, v);
            }
        }
    }
};
pub const IdentifierProtoReader = struct {
    buf: gremlin.Reader,
    _hash_code: i32 = 0,
    _user_id: i32 = 0,
    _title: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!IdentifierProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = IdentifierProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                IdentifierProtoWire.HASH_CODE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._hash_code = result.value;
                },
                IdentifierProtoWire.USER_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._user_id = result.value;
                },
                IdentifierProtoWire.TITLE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._title = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getHashCode(self: *const IdentifierProtoReader) i32 {
        return self._hash_code;
    }
    pub inline fn getUserId(self: *const IdentifierProtoReader) i32 {
        return self._user_id;
    }
    pub inline fn getTitle(self: *const IdentifierProtoReader) []const u8 {
        return self._title orelse &[_]u8{};
    }
};
const WindowStateAnimatorProtoWire = struct {
    const LAST_CLIP_RECT_WIRE: gremlin.ProtoWireNumber = 1;
    const SURFACE_WIRE: gremlin.ProtoWireNumber = 2;
    const DRAW_STATE_WIRE: gremlin.ProtoWireNumber = 3;
    const SYSTEM_DECOR_RECT_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const WindowStateAnimatorProto = struct {
    // nested enums
    pub const DrawState = enum(i32) {
        NO_SURFACE = 0,
        DRAW_PENDING = 1,
        COMMIT_DRAW_PENDING = 2,
        READY_TO_SHOW = 3,
        HAS_DRAWN = 4,
    };
    // fields
    last_clip_rect: ?rect.RectProto = null,
    surface: ?WindowSurfaceControllerProto = null,
    draw_state: WindowStateAnimatorProto.DrawState = @enumFromInt(0),
    system_decor_rect: ?rect.RectProto = null,
    pub fn calcProtobufSize(self: *const WindowStateAnimatorProto) usize {
        var res: usize = 0;
        if (self.last_clip_rect) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowStateAnimatorProtoWire.LAST_CLIP_RECT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.surface) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowStateAnimatorProtoWire.SURFACE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (@intFromEnum(self.draw_state) != 0) {
            res += gremlin.sizes.sizeWireNumber(WindowStateAnimatorProtoWire.DRAW_STATE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.draw_state));
        }
        if (self.system_decor_rect) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowStateAnimatorProtoWire.SYSTEM_DECOR_RECT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const WindowStateAnimatorProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const WindowStateAnimatorProto, target: *gremlin.Writer) void {
        if (self.last_clip_rect) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowStateAnimatorProtoWire.LAST_CLIP_RECT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.surface) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowStateAnimatorProtoWire.SURFACE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (@intFromEnum(self.draw_state) != 0) {
            target.appendInt32(WindowStateAnimatorProtoWire.DRAW_STATE_WIRE, @intFromEnum(self.draw_state));
        }
        if (self.system_decor_rect) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowStateAnimatorProtoWire.SYSTEM_DECOR_RECT_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const WindowStateAnimatorProtoReader = struct {
    buf: gremlin.Reader,
    _last_clip_rect_buf: ?[]const u8 = null,
    _surface_buf: ?[]const u8 = null,
    _draw_state: WindowStateAnimatorProto.DrawState = @enumFromInt(0),
    _system_decor_rect_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!WindowStateAnimatorProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = WindowStateAnimatorProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                WindowStateAnimatorProtoWire.LAST_CLIP_RECT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._last_clip_rect_buf = result.value;
                },
                WindowStateAnimatorProtoWire.SURFACE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._surface_buf = result.value;
                },
                WindowStateAnimatorProtoWire.DRAW_STATE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._draw_state = @enumFromInt(result.value);
                },
                WindowStateAnimatorProtoWire.SYSTEM_DECOR_RECT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._system_decor_rect_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getLastClipRect(self: *const WindowStateAnimatorProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._last_clip_rect_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getSurface(self: *const WindowStateAnimatorProtoReader) gremlin.Error!WindowSurfaceControllerProtoReader {
        if (self._surface_buf) |buf| {
            return try WindowSurfaceControllerProtoReader.init(buf);
        }
        return try WindowSurfaceControllerProtoReader.init(&[_]u8{});
    }
    pub inline fn getDrawState(self: *const WindowStateAnimatorProtoReader) WindowStateAnimatorProto.DrawState {
        return self._draw_state;
    }
    pub fn getSystemDecorRect(self: *const WindowStateAnimatorProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._system_decor_rect_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
};
const WindowSurfaceControllerProtoWire = struct {
    const SHOWN_WIRE: gremlin.ProtoWireNumber = 1;
    const LAYER_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const WindowSurfaceControllerProto = struct {
    // fields
    shown: bool = false,
    layer: i32 = 0,
    pub fn calcProtobufSize(self: *const WindowSurfaceControllerProto) usize {
        var res: usize = 0;
        if (self.shown != false) {
            res += gremlin.sizes.sizeWireNumber(WindowSurfaceControllerProtoWire.SHOWN_WIRE) + gremlin.sizes.sizeBool(self.shown);
        }
        if (self.layer != 0) {
            res += gremlin.sizes.sizeWireNumber(WindowSurfaceControllerProtoWire.LAYER_WIRE) + gremlin.sizes.sizeI32(self.layer);
        }
        return res;
    }
    pub fn encode(self: *const WindowSurfaceControllerProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const WindowSurfaceControllerProto, target: *gremlin.Writer) void {
        if (self.shown != false) {
            target.appendBool(WindowSurfaceControllerProtoWire.SHOWN_WIRE, self.shown);
        }
        if (self.layer != 0) {
            target.appendInt32(WindowSurfaceControllerProtoWire.LAYER_WIRE, self.layer);
        }
    }
};
pub const WindowSurfaceControllerProtoReader = struct {
    buf: gremlin.Reader,
    _shown: bool = false,
    _layer: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!WindowSurfaceControllerProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = WindowSurfaceControllerProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                WindowSurfaceControllerProtoWire.SHOWN_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._shown = result.value;
                },
                WindowSurfaceControllerProtoWire.LAYER_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._layer = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getShown(self: *const WindowSurfaceControllerProtoReader) bool {
        return self._shown;
    }
    pub inline fn getLayer(self: *const WindowSurfaceControllerProtoReader) i32 {
        return self._layer;
    }
};
const ScreenRotationAnimationProtoWire = struct {
    const STARTED_WIRE: gremlin.ProtoWireNumber = 1;
    const ANIMATION_RUNNING_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const ScreenRotationAnimationProto = struct {
    // fields
    started: bool = false,
    animation_running: bool = false,
    pub fn calcProtobufSize(self: *const ScreenRotationAnimationProto) usize {
        var res: usize = 0;
        if (self.started != false) {
            res += gremlin.sizes.sizeWireNumber(ScreenRotationAnimationProtoWire.STARTED_WIRE) + gremlin.sizes.sizeBool(self.started);
        }
        if (self.animation_running != false) {
            res += gremlin.sizes.sizeWireNumber(ScreenRotationAnimationProtoWire.ANIMATION_RUNNING_WIRE) + gremlin.sizes.sizeBool(self.animation_running);
        }
        return res;
    }
    pub fn encode(self: *const ScreenRotationAnimationProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ScreenRotationAnimationProto, target: *gremlin.Writer) void {
        if (self.started != false) {
            target.appendBool(ScreenRotationAnimationProtoWire.STARTED_WIRE, self.started);
        }
        if (self.animation_running != false) {
            target.appendBool(ScreenRotationAnimationProtoWire.ANIMATION_RUNNING_WIRE, self.animation_running);
        }
    }
};
pub const ScreenRotationAnimationProtoReader = struct {
    buf: gremlin.Reader,
    _started: bool = false,
    _animation_running: bool = false,
    pub fn init(src: []const u8) gremlin.Error!ScreenRotationAnimationProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = ScreenRotationAnimationProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ScreenRotationAnimationProtoWire.STARTED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._started = result.value;
                },
                ScreenRotationAnimationProtoWire.ANIMATION_RUNNING_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._animation_running = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getStarted(self: *const ScreenRotationAnimationProtoReader) bool {
        return self._started;
    }
    pub inline fn getAnimationRunning(self: *const ScreenRotationAnimationProtoReader) bool {
        return self._animation_running;
    }
};
const WindowContainerProtoWire = struct {
    const CONFIGURATION_CONTAINER_WIRE: gremlin.ProtoWireNumber = 1;
    const ORIENTATION_WIRE: gremlin.ProtoWireNumber = 2;
    const VISIBLE_WIRE: gremlin.ProtoWireNumber = 3;
    const SURFACE_ANIMATOR_WIRE: gremlin.ProtoWireNumber = 4;
    const CHILDREN_WIRE: gremlin.ProtoWireNumber = 5;
    const IDENTIFIER_WIRE: gremlin.ProtoWireNumber = 6;
    const SURFACE_CONTROL_WIRE: gremlin.ProtoWireNumber = 7;
};
pub const WindowContainerProto = struct {
    // fields
    configuration_container: ?ConfigurationContainerProto = null,
    orientation: i32 = 0,
    visible: bool = false,
    surface_animator: ?surfaceanimator.SurfaceAnimatorProto = null,
    children: ?[]const ?WindowContainerChildProto = null,
    identifier: ?IdentifierProto = null,
    surface_control: ?surfacecontrol.SurfaceControlProto = null,
    pub fn calcProtobufSize(self: *const WindowContainerProto) usize {
        var res: usize = 0;
        if (self.configuration_container) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowContainerProtoWire.CONFIGURATION_CONTAINER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.orientation != 0) {
            res += gremlin.sizes.sizeWireNumber(WindowContainerProtoWire.ORIENTATION_WIRE) + gremlin.sizes.sizeI32(self.orientation);
        }
        if (self.visible != false) {
            res += gremlin.sizes.sizeWireNumber(WindowContainerProtoWire.VISIBLE_WIRE) + gremlin.sizes.sizeBool(self.visible);
        }
        if (self.surface_animator) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowContainerProtoWire.SURFACE_ANIMATOR_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.children) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(WindowContainerProtoWire.CHILDREN_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.identifier) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowContainerProtoWire.IDENTIFIER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.surface_control) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowContainerProtoWire.SURFACE_CONTROL_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const WindowContainerProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const WindowContainerProto, target: *gremlin.Writer) void {
        if (self.configuration_container) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowContainerProtoWire.CONFIGURATION_CONTAINER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.orientation != 0) {
            target.appendInt32(WindowContainerProtoWire.ORIENTATION_WIRE, self.orientation);
        }
        if (self.visible != false) {
            target.appendBool(WindowContainerProtoWire.VISIBLE_WIRE, self.visible);
        }
        if (self.surface_animator) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowContainerProtoWire.SURFACE_ANIMATOR_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.children) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(WindowContainerProtoWire.CHILDREN_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(WindowContainerProtoWire.CHILDREN_WIRE, 0);
                }
            }
        }
        if (self.identifier) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowContainerProtoWire.IDENTIFIER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.surface_control) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowContainerProtoWire.SURFACE_CONTROL_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const WindowContainerProtoReader = struct {
    buf: gremlin.Reader,
    _configuration_container_buf: ?[]const u8 = null,
    _orientation: i32 = 0,
    _visible: bool = false,
    _surface_animator_buf: ?[]const u8 = null,
    _children_offset: ?usize = null,
    _children_last_offset: ?usize = null,
    _children_cnt: usize = 0,
    _identifier_buf: ?[]const u8 = null,
    _surface_control_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!WindowContainerProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = WindowContainerProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                WindowContainerProtoWire.CONFIGURATION_CONTAINER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._configuration_container_buf = result.value;
                },
                WindowContainerProtoWire.ORIENTATION_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._orientation = result.value;
                },
                WindowContainerProtoWire.VISIBLE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._visible = result.value;
                },
                WindowContainerProtoWire.SURFACE_ANIMATOR_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._surface_animator_buf = result.value;
                },
                WindowContainerProtoWire.CHILDREN_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._children_offset == null) {
                        res._children_offset = offset - result.size;
                    }
                    res._children_last_offset = offset;
                    res._children_cnt += 1;
                },
                WindowContainerProtoWire.IDENTIFIER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._identifier_buf = result.value;
                },
                WindowContainerProtoWire.SURFACE_CONTROL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._surface_control_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getConfigurationContainer(self: *const WindowContainerProtoReader) gremlin.Error!ConfigurationContainerProtoReader {
        if (self._configuration_container_buf) |buf| {
            return try ConfigurationContainerProtoReader.init(buf);
        }
        return try ConfigurationContainerProtoReader.init(&[_]u8{});
    }
    pub inline fn getOrientation(self: *const WindowContainerProtoReader) i32 {
        return self._orientation;
    }
    pub inline fn getVisible(self: *const WindowContainerProtoReader) bool {
        return self._visible;
    }
    pub fn getSurfaceAnimator(self: *const WindowContainerProtoReader) gremlin.Error!surfaceanimator.SurfaceAnimatorProtoReader {
        if (self._surface_animator_buf) |buf| {
            return try surfaceanimator.SurfaceAnimatorProtoReader.init(buf);
        }
        return try surfaceanimator.SurfaceAnimatorProtoReader.init(&[_]u8{});
    }
    pub fn childrenCount(self: *const WindowContainerProtoReader) usize {
        return self._children_cnt;
    }
    pub fn childrenNext(self: *WindowContainerProtoReader) ?WindowContainerChildProtoReader {
        if (self._children_offset == null) return null;
        const current_offset = self._children_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = WindowContainerChildProtoReader.init(result.value) catch return null;
        if (self._children_last_offset != null and current_offset >= self._children_last_offset.?) {
            self._children_offset = null;
            return msg;
        }
        if (self._children_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._children_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == WindowContainerProtoWire.CHILDREN_WIRE) {
                self._children_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._children_offset = null;
        return msg;
    }
    pub fn getIdentifier(self: *const WindowContainerProtoReader) gremlin.Error!IdentifierProtoReader {
        if (self._identifier_buf) |buf| {
            return try IdentifierProtoReader.init(buf);
        }
        return try IdentifierProtoReader.init(&[_]u8{});
    }
    pub fn getSurfaceControl(self: *const WindowContainerProtoReader) gremlin.Error!surfacecontrol.SurfaceControlProtoReader {
        if (self._surface_control_buf) |buf| {
            return try surfacecontrol.SurfaceControlProtoReader.init(buf);
        }
        return try surfacecontrol.SurfaceControlProtoReader.init(&[_]u8{});
    }
};
const WindowContainerChildProtoWire = struct {
    const WINDOW_CONTAINER_WIRE: gremlin.ProtoWireNumber = 2;
    const DISPLAY_CONTENT_WIRE: gremlin.ProtoWireNumber = 3;
    const DISPLAY_AREA_WIRE: gremlin.ProtoWireNumber = 4;
    const TASK_WIRE: gremlin.ProtoWireNumber = 5;
    const ACTIVITY_WIRE: gremlin.ProtoWireNumber = 6;
    const WINDOW_TOKEN_WIRE: gremlin.ProtoWireNumber = 7;
    const WINDOW_WIRE: gremlin.ProtoWireNumber = 8;
    const TASK_FRAGMENT_WIRE: gremlin.ProtoWireNumber = 9;
};
pub const WindowContainerChildProto = struct {
    // fields
    window_container: ?WindowContainerProto = null,
    display_content: ?DisplayContentProto = null,
    display_area: ?DisplayAreaProto = null,
    task: ?TaskProto = null,
    activity: ?ActivityRecordProto = null,
    window_token: ?WindowTokenProto = null,
    window: ?WindowStateProto = null,
    task_fragment: ?TaskFragmentProto = null,
    pub fn calcProtobufSize(self: *const WindowContainerChildProto) usize {
        var res: usize = 0;
        if (self.window_container) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowContainerChildProtoWire.WINDOW_CONTAINER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.display_content) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowContainerChildProtoWire.DISPLAY_CONTENT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.display_area) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowContainerChildProtoWire.DISPLAY_AREA_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.task) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowContainerChildProtoWire.TASK_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.activity) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowContainerChildProtoWire.ACTIVITY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.window_token) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowContainerChildProtoWire.WINDOW_TOKEN_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.window) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowContainerChildProtoWire.WINDOW_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.task_fragment) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowContainerChildProtoWire.TASK_FRAGMENT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const WindowContainerChildProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const WindowContainerChildProto, target: *gremlin.Writer) void {
        if (self.window_container) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowContainerChildProtoWire.WINDOW_CONTAINER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.display_content) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowContainerChildProtoWire.DISPLAY_CONTENT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.display_area) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowContainerChildProtoWire.DISPLAY_AREA_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.task) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowContainerChildProtoWire.TASK_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.activity) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowContainerChildProtoWire.ACTIVITY_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.window_token) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowContainerChildProtoWire.WINDOW_TOKEN_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.window) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowContainerChildProtoWire.WINDOW_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.task_fragment) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowContainerChildProtoWire.TASK_FRAGMENT_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const WindowContainerChildProtoReader = struct {
    buf: gremlin.Reader,
    _window_container_buf: ?[]const u8 = null,
    _display_content_buf: ?[]const u8 = null,
    _display_area_buf: ?[]const u8 = null,
    _task_buf: ?[]const u8 = null,
    _activity_buf: ?[]const u8 = null,
    _window_token_buf: ?[]const u8 = null,
    _window_buf: ?[]const u8 = null,
    _task_fragment_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!WindowContainerChildProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = WindowContainerChildProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                WindowContainerChildProtoWire.WINDOW_CONTAINER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._window_container_buf = result.value;
                },
                WindowContainerChildProtoWire.DISPLAY_CONTENT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._display_content_buf = result.value;
                },
                WindowContainerChildProtoWire.DISPLAY_AREA_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._display_area_buf = result.value;
                },
                WindowContainerChildProtoWire.TASK_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._task_buf = result.value;
                },
                WindowContainerChildProtoWire.ACTIVITY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._activity_buf = result.value;
                },
                WindowContainerChildProtoWire.WINDOW_TOKEN_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._window_token_buf = result.value;
                },
                WindowContainerChildProtoWire.WINDOW_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._window_buf = result.value;
                },
                WindowContainerChildProtoWire.TASK_FRAGMENT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._task_fragment_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getWindowContainer(self: *const WindowContainerChildProtoReader) gremlin.Error!WindowContainerProtoReader {
        if (self._window_container_buf) |buf| {
            return try WindowContainerProtoReader.init(buf);
        }
        return try WindowContainerProtoReader.init(&[_]u8{});
    }
    pub fn getDisplayContent(self: *const WindowContainerChildProtoReader) gremlin.Error!DisplayContentProtoReader {
        if (self._display_content_buf) |buf| {
            return try DisplayContentProtoReader.init(buf);
        }
        return try DisplayContentProtoReader.init(&[_]u8{});
    }
    pub fn getDisplayArea(self: *const WindowContainerChildProtoReader) gremlin.Error!DisplayAreaProtoReader {
        if (self._display_area_buf) |buf| {
            return try DisplayAreaProtoReader.init(buf);
        }
        return try DisplayAreaProtoReader.init(&[_]u8{});
    }
    pub fn getTask(self: *const WindowContainerChildProtoReader) gremlin.Error!TaskProtoReader {
        if (self._task_buf) |buf| {
            return try TaskProtoReader.init(buf);
        }
        return try TaskProtoReader.init(&[_]u8{});
    }
    pub fn getActivity(self: *const WindowContainerChildProtoReader) gremlin.Error!ActivityRecordProtoReader {
        if (self._activity_buf) |buf| {
            return try ActivityRecordProtoReader.init(buf);
        }
        return try ActivityRecordProtoReader.init(&[_]u8{});
    }
    pub fn getWindowToken(self: *const WindowContainerChildProtoReader) gremlin.Error!WindowTokenProtoReader {
        if (self._window_token_buf) |buf| {
            return try WindowTokenProtoReader.init(buf);
        }
        return try WindowTokenProtoReader.init(&[_]u8{});
    }
    pub fn getWindow(self: *const WindowContainerChildProtoReader) gremlin.Error!WindowStateProtoReader {
        if (self._window_buf) |buf| {
            return try WindowStateProtoReader.init(buf);
        }
        return try WindowStateProtoReader.init(&[_]u8{});
    }
    pub fn getTaskFragment(self: *const WindowContainerChildProtoReader) gremlin.Error!TaskFragmentProtoReader {
        if (self._task_fragment_buf) |buf| {
            return try TaskFragmentProtoReader.init(buf);
        }
        return try TaskFragmentProtoReader.init(&[_]u8{});
    }
};
const ConfigurationContainerProtoWire = struct {
    const OVERRIDE_CONFIGURATION_WIRE: gremlin.ProtoWireNumber = 1;
    const FULL_CONFIGURATION_WIRE: gremlin.ProtoWireNumber = 2;
    const MERGED_OVERRIDE_CONFIGURATION_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const ConfigurationContainerProto = struct {
    // fields
    override_configuration: ?configuration.ConfigurationProto = null,
    full_configuration: ?configuration.ConfigurationProto = null,
    merged_override_configuration: ?configuration.ConfigurationProto = null,
    pub fn calcProtobufSize(self: *const ConfigurationContainerProto) usize {
        var res: usize = 0;
        if (self.override_configuration) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ConfigurationContainerProtoWire.OVERRIDE_CONFIGURATION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.full_configuration) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ConfigurationContainerProtoWire.FULL_CONFIGURATION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.merged_override_configuration) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ConfigurationContainerProtoWire.MERGED_OVERRIDE_CONFIGURATION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const ConfigurationContainerProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ConfigurationContainerProto, target: *gremlin.Writer) void {
        if (self.override_configuration) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ConfigurationContainerProtoWire.OVERRIDE_CONFIGURATION_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.full_configuration) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ConfigurationContainerProtoWire.FULL_CONFIGURATION_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.merged_override_configuration) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ConfigurationContainerProtoWire.MERGED_OVERRIDE_CONFIGURATION_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const ConfigurationContainerProtoReader = struct {
    buf: gremlin.Reader,
    _override_configuration_buf: ?[]const u8 = null,
    _full_configuration_buf: ?[]const u8 = null,
    _merged_override_configuration_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!ConfigurationContainerProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = ConfigurationContainerProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ConfigurationContainerProtoWire.OVERRIDE_CONFIGURATION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._override_configuration_buf = result.value;
                },
                ConfigurationContainerProtoWire.FULL_CONFIGURATION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._full_configuration_buf = result.value;
                },
                ConfigurationContainerProtoWire.MERGED_OVERRIDE_CONFIGURATION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._merged_override_configuration_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getOverrideConfiguration(self: *const ConfigurationContainerProtoReader) gremlin.Error!configuration.ConfigurationProtoReader {
        if (self._override_configuration_buf) |buf| {
            return try configuration.ConfigurationProtoReader.init(buf);
        }
        return try configuration.ConfigurationProtoReader.init(&[_]u8{});
    }
    pub fn getFullConfiguration(self: *const ConfigurationContainerProtoReader) gremlin.Error!configuration.ConfigurationProtoReader {
        if (self._full_configuration_buf) |buf| {
            return try configuration.ConfigurationProtoReader.init(buf);
        }
        return try configuration.ConfigurationProtoReader.init(&[_]u8{});
    }
    pub fn getMergedOverrideConfiguration(self: *const ConfigurationContainerProtoReader) gremlin.Error!configuration.ConfigurationProtoReader {
        if (self._merged_override_configuration_buf) |buf| {
            return try configuration.ConfigurationProtoReader.init(buf);
        }
        return try configuration.ConfigurationProtoReader.init(&[_]u8{});
    }
};
const WindowFramesProtoWire = struct {
    const CONTAINING_FRAME_WIRE: gremlin.ProtoWireNumber = 1;
    const CONTENT_FRAME_WIRE: gremlin.ProtoWireNumber = 2;
    const DECOR_FRAME_WIRE: gremlin.ProtoWireNumber = 3;
    const DISPLAY_FRAME_WIRE: gremlin.ProtoWireNumber = 4;
    const FRAME_WIRE: gremlin.ProtoWireNumber = 5;
    const OUTSET_FRAME_WIRE: gremlin.ProtoWireNumber = 6;
    const OVERSCAN_FRAME_WIRE: gremlin.ProtoWireNumber = 7;
    const PARENT_FRAME_WIRE: gremlin.ProtoWireNumber = 8;
    const VISIBLE_FRAME_WIRE: gremlin.ProtoWireNumber = 9;
    const CUTOUT_WIRE: gremlin.ProtoWireNumber = 10;
    const CONTENT_INSETS_WIRE: gremlin.ProtoWireNumber = 11;
    const OVERSCAN_INSETS_WIRE: gremlin.ProtoWireNumber = 12;
    const VISIBLE_INSETS_WIRE: gremlin.ProtoWireNumber = 13;
    const STABLE_INSETS_WIRE: gremlin.ProtoWireNumber = 14;
    const OUTSETS_WIRE: gremlin.ProtoWireNumber = 15;
    const COMPAT_FRAME_WIRE: gremlin.ProtoWireNumber = 16;
};
pub const WindowFramesProto = struct {
    // fields
    containing_frame: ?rect.RectProto = null,
    content_frame: ?rect.RectProto = null,
    decor_frame: ?rect.RectProto = null,
    display_frame: ?rect.RectProto = null,
    frame: ?rect.RectProto = null,
    outset_frame: ?rect.RectProto = null,
    overscan_frame: ?rect.RectProto = null,
    parent_frame: ?rect.RectProto = null,
    visible_frame: ?rect.RectProto = null,
    cutout: ?displaycutout.DisplayCutoutProto = null,
    content_insets: ?rect.RectProto = null,
    overscan_insets: ?rect.RectProto = null,
    visible_insets: ?rect.RectProto = null,
    stable_insets: ?rect.RectProto = null,
    outsets: ?rect.RectProto = null,
    compat_frame: ?rect.RectProto = null,
    pub fn calcProtobufSize(self: *const WindowFramesProto) usize {
        var res: usize = 0;
        if (self.containing_frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowFramesProtoWire.CONTAINING_FRAME_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.content_frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowFramesProtoWire.CONTENT_FRAME_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.decor_frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowFramesProtoWire.DECOR_FRAME_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.display_frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowFramesProtoWire.DISPLAY_FRAME_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowFramesProtoWire.FRAME_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.outset_frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowFramesProtoWire.OUTSET_FRAME_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.overscan_frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowFramesProtoWire.OVERSCAN_FRAME_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.parent_frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowFramesProtoWire.PARENT_FRAME_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.visible_frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowFramesProtoWire.VISIBLE_FRAME_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cutout) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowFramesProtoWire.CUTOUT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.content_insets) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowFramesProtoWire.CONTENT_INSETS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.overscan_insets) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowFramesProtoWire.OVERSCAN_INSETS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.visible_insets) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowFramesProtoWire.VISIBLE_INSETS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.stable_insets) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowFramesProtoWire.STABLE_INSETS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.outsets) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowFramesProtoWire.OUTSETS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.compat_frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WindowFramesProtoWire.COMPAT_FRAME_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const WindowFramesProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const WindowFramesProto, target: *gremlin.Writer) void {
        if (self.containing_frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowFramesProtoWire.CONTAINING_FRAME_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.content_frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowFramesProtoWire.CONTENT_FRAME_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.decor_frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowFramesProtoWire.DECOR_FRAME_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.display_frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowFramesProtoWire.DISPLAY_FRAME_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowFramesProtoWire.FRAME_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.outset_frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowFramesProtoWire.OUTSET_FRAME_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.overscan_frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowFramesProtoWire.OVERSCAN_FRAME_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.parent_frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowFramesProtoWire.PARENT_FRAME_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.visible_frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowFramesProtoWire.VISIBLE_FRAME_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cutout) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowFramesProtoWire.CUTOUT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.content_insets) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowFramesProtoWire.CONTENT_INSETS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.overscan_insets) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowFramesProtoWire.OVERSCAN_INSETS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.visible_insets) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowFramesProtoWire.VISIBLE_INSETS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.stable_insets) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowFramesProtoWire.STABLE_INSETS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.outsets) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowFramesProtoWire.OUTSETS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.compat_frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WindowFramesProtoWire.COMPAT_FRAME_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const WindowFramesProtoReader = struct {
    buf: gremlin.Reader,
    _containing_frame_buf: ?[]const u8 = null,
    _content_frame_buf: ?[]const u8 = null,
    _decor_frame_buf: ?[]const u8 = null,
    _display_frame_buf: ?[]const u8 = null,
    _frame_buf: ?[]const u8 = null,
    _outset_frame_buf: ?[]const u8 = null,
    _overscan_frame_buf: ?[]const u8 = null,
    _parent_frame_buf: ?[]const u8 = null,
    _visible_frame_buf: ?[]const u8 = null,
    _cutout_buf: ?[]const u8 = null,
    _content_insets_buf: ?[]const u8 = null,
    _overscan_insets_buf: ?[]const u8 = null,
    _visible_insets_buf: ?[]const u8 = null,
    _stable_insets_buf: ?[]const u8 = null,
    _outsets_buf: ?[]const u8 = null,
    _compat_frame_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!WindowFramesProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = WindowFramesProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                WindowFramesProtoWire.CONTAINING_FRAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._containing_frame_buf = result.value;
                },
                WindowFramesProtoWire.CONTENT_FRAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._content_frame_buf = result.value;
                },
                WindowFramesProtoWire.DECOR_FRAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._decor_frame_buf = result.value;
                },
                WindowFramesProtoWire.DISPLAY_FRAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._display_frame_buf = result.value;
                },
                WindowFramesProtoWire.FRAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._frame_buf = result.value;
                },
                WindowFramesProtoWire.OUTSET_FRAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._outset_frame_buf = result.value;
                },
                WindowFramesProtoWire.OVERSCAN_FRAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._overscan_frame_buf = result.value;
                },
                WindowFramesProtoWire.PARENT_FRAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._parent_frame_buf = result.value;
                },
                WindowFramesProtoWire.VISIBLE_FRAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._visible_frame_buf = result.value;
                },
                WindowFramesProtoWire.CUTOUT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cutout_buf = result.value;
                },
                WindowFramesProtoWire.CONTENT_INSETS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._content_insets_buf = result.value;
                },
                WindowFramesProtoWire.OVERSCAN_INSETS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._overscan_insets_buf = result.value;
                },
                WindowFramesProtoWire.VISIBLE_INSETS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._visible_insets_buf = result.value;
                },
                WindowFramesProtoWire.STABLE_INSETS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._stable_insets_buf = result.value;
                },
                WindowFramesProtoWire.OUTSETS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._outsets_buf = result.value;
                },
                WindowFramesProtoWire.COMPAT_FRAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._compat_frame_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getContainingFrame(self: *const WindowFramesProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._containing_frame_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getContentFrame(self: *const WindowFramesProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._content_frame_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getDecorFrame(self: *const WindowFramesProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._decor_frame_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getDisplayFrame(self: *const WindowFramesProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._display_frame_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getFrame(self: *const WindowFramesProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._frame_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getOutsetFrame(self: *const WindowFramesProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._outset_frame_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getOverscanFrame(self: *const WindowFramesProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._overscan_frame_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getParentFrame(self: *const WindowFramesProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._parent_frame_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getVisibleFrame(self: *const WindowFramesProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._visible_frame_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getCutout(self: *const WindowFramesProtoReader) gremlin.Error!displaycutout.DisplayCutoutProtoReader {
        if (self._cutout_buf) |buf| {
            return try displaycutout.DisplayCutoutProtoReader.init(buf);
        }
        return try displaycutout.DisplayCutoutProtoReader.init(&[_]u8{});
    }
    pub fn getContentInsets(self: *const WindowFramesProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._content_insets_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getOverscanInsets(self: *const WindowFramesProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._overscan_insets_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getVisibleInsets(self: *const WindowFramesProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._visible_insets_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getStableInsets(self: *const WindowFramesProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._stable_insets_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getOutsets(self: *const WindowFramesProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._outsets_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getCompatFrame(self: *const WindowFramesProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._compat_frame_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
};
const InsetsSourceProviderProtoWire = struct {
    const SOURCE_WIRE: gremlin.ProtoWireNumber = 1;
    const FRAME_WIRE: gremlin.ProtoWireNumber = 2;
    const FAKE_CONTROL_WIRE: gremlin.ProtoWireNumber = 3;
    const CONTROL_WIRE: gremlin.ProtoWireNumber = 4;
    const CONTROL_TARGET_WIRE: gremlin.ProtoWireNumber = 5;
    const PENDING_CONTROL_TARGET_WIRE: gremlin.ProtoWireNumber = 6;
    const FAKE_CONTROL_TARGET_WIRE: gremlin.ProtoWireNumber = 7;
    const CAPTURED_LEASH_WIRE: gremlin.ProtoWireNumber = 8;
    const IME_OVERRIDDEN_FRAME_WIRE: gremlin.ProtoWireNumber = 9;
    const IS_LEASH_READY_FOR_DISPATCHING_WIRE: gremlin.ProtoWireNumber = 10;
    const CLIENT_VISIBLE_WIRE: gremlin.ProtoWireNumber = 11;
    const SERVER_VISIBLE_WIRE: gremlin.ProtoWireNumber = 12;
    const SEAMLESS_ROTATING_WIRE: gremlin.ProtoWireNumber = 13;
    const FINISH_SEAMLESS_ROTATE_FRAME_NUMBER_WIRE: gremlin.ProtoWireNumber = 14;
    const CONTROLLABLE_WIRE: gremlin.ProtoWireNumber = 15;
    const SOURCE_WINDOW_STATE_WIRE: gremlin.ProtoWireNumber = 16;
    const CONTROL_TARGET_IDENTIFIER_WIRE: gremlin.ProtoWireNumber = 17;
    const PENDING_CONTROL_TARGET_IDENTIFIER_WIRE: gremlin.ProtoWireNumber = 18;
    const FAKE_CONTROL_TARGET_IDENTIFIER_WIRE: gremlin.ProtoWireNumber = 19;
    const SOURCE_WINDOW_STATE_IDENTIFIER_WIRE: gremlin.ProtoWireNumber = 20;
};
pub const InsetsSourceProviderProto = struct {
    // fields
    source: ?insetssource.InsetsSourceProto = null,
    frame: ?rect.RectProto = null,
    fake_control: ?insetssourcecontrol.InsetsSourceControlProto = null,
    control: ?insetssourcecontrol.InsetsSourceControlProto = null,
    control_target: ?WindowStateProto = null,
    pending_control_target: ?WindowStateProto = null,
    fake_control_target: ?WindowStateProto = null,
    captured_leash: ?surfacecontrol.SurfaceControlProto = null,
    ime_overridden_frame: ?rect.RectProto = null,
    is_leash_ready_for_dispatching: bool = false,
    client_visible: bool = false,
    server_visible: bool = false,
    seamless_rotating: bool = false,
    finish_seamless_rotate_frame_number: i64 = 0,
    controllable: bool = false,
    source_window_state: ?WindowStateProto = null,
    control_target_identifier: ?IdentifierProto = null,
    pending_control_target_identifier: ?IdentifierProto = null,
    fake_control_target_identifier: ?IdentifierProto = null,
    source_window_state_identifier: ?IdentifierProto = null,
    pub fn calcProtobufSize(self: *const InsetsSourceProviderProto) usize {
        var res: usize = 0;
        if (self.source) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(InsetsSourceProviderProtoWire.SOURCE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(InsetsSourceProviderProtoWire.FRAME_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.fake_control) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(InsetsSourceProviderProtoWire.FAKE_CONTROL_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.control) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(InsetsSourceProviderProtoWire.CONTROL_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.control_target) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(InsetsSourceProviderProtoWire.CONTROL_TARGET_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.pending_control_target) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(InsetsSourceProviderProtoWire.PENDING_CONTROL_TARGET_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.fake_control_target) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(InsetsSourceProviderProtoWire.FAKE_CONTROL_TARGET_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.captured_leash) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(InsetsSourceProviderProtoWire.CAPTURED_LEASH_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ime_overridden_frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(InsetsSourceProviderProtoWire.IME_OVERRIDDEN_FRAME_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.is_leash_ready_for_dispatching != false) {
            res += gremlin.sizes.sizeWireNumber(InsetsSourceProviderProtoWire.IS_LEASH_READY_FOR_DISPATCHING_WIRE) + gremlin.sizes.sizeBool(self.is_leash_ready_for_dispatching);
        }
        if (self.client_visible != false) {
            res += gremlin.sizes.sizeWireNumber(InsetsSourceProviderProtoWire.CLIENT_VISIBLE_WIRE) + gremlin.sizes.sizeBool(self.client_visible);
        }
        if (self.server_visible != false) {
            res += gremlin.sizes.sizeWireNumber(InsetsSourceProviderProtoWire.SERVER_VISIBLE_WIRE) + gremlin.sizes.sizeBool(self.server_visible);
        }
        if (self.seamless_rotating != false) {
            res += gremlin.sizes.sizeWireNumber(InsetsSourceProviderProtoWire.SEAMLESS_ROTATING_WIRE) + gremlin.sizes.sizeBool(self.seamless_rotating);
        }
        if (self.finish_seamless_rotate_frame_number != 0) {
            res += gremlin.sizes.sizeWireNumber(InsetsSourceProviderProtoWire.FINISH_SEAMLESS_ROTATE_FRAME_NUMBER_WIRE) + gremlin.sizes.sizeI64(self.finish_seamless_rotate_frame_number);
        }
        if (self.controllable != false) {
            res += gremlin.sizes.sizeWireNumber(InsetsSourceProviderProtoWire.CONTROLLABLE_WIRE) + gremlin.sizes.sizeBool(self.controllable);
        }
        if (self.source_window_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(InsetsSourceProviderProtoWire.SOURCE_WINDOW_STATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.control_target_identifier) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(InsetsSourceProviderProtoWire.CONTROL_TARGET_IDENTIFIER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.pending_control_target_identifier) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(InsetsSourceProviderProtoWire.PENDING_CONTROL_TARGET_IDENTIFIER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.fake_control_target_identifier) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(InsetsSourceProviderProtoWire.FAKE_CONTROL_TARGET_IDENTIFIER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.source_window_state_identifier) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(InsetsSourceProviderProtoWire.SOURCE_WINDOW_STATE_IDENTIFIER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const InsetsSourceProviderProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const InsetsSourceProviderProto, target: *gremlin.Writer) void {
        if (self.source) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(InsetsSourceProviderProtoWire.SOURCE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(InsetsSourceProviderProtoWire.FRAME_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.fake_control) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(InsetsSourceProviderProtoWire.FAKE_CONTROL_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.control) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(InsetsSourceProviderProtoWire.CONTROL_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.control_target) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(InsetsSourceProviderProtoWire.CONTROL_TARGET_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.pending_control_target) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(InsetsSourceProviderProtoWire.PENDING_CONTROL_TARGET_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.fake_control_target) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(InsetsSourceProviderProtoWire.FAKE_CONTROL_TARGET_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.captured_leash) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(InsetsSourceProviderProtoWire.CAPTURED_LEASH_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ime_overridden_frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(InsetsSourceProviderProtoWire.IME_OVERRIDDEN_FRAME_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.is_leash_ready_for_dispatching != false) {
            target.appendBool(InsetsSourceProviderProtoWire.IS_LEASH_READY_FOR_DISPATCHING_WIRE, self.is_leash_ready_for_dispatching);
        }
        if (self.client_visible != false) {
            target.appendBool(InsetsSourceProviderProtoWire.CLIENT_VISIBLE_WIRE, self.client_visible);
        }
        if (self.server_visible != false) {
            target.appendBool(InsetsSourceProviderProtoWire.SERVER_VISIBLE_WIRE, self.server_visible);
        }
        if (self.seamless_rotating != false) {
            target.appendBool(InsetsSourceProviderProtoWire.SEAMLESS_ROTATING_WIRE, self.seamless_rotating);
        }
        if (self.finish_seamless_rotate_frame_number != 0) {
            target.appendInt64(InsetsSourceProviderProtoWire.FINISH_SEAMLESS_ROTATE_FRAME_NUMBER_WIRE, self.finish_seamless_rotate_frame_number);
        }
        if (self.controllable != false) {
            target.appendBool(InsetsSourceProviderProtoWire.CONTROLLABLE_WIRE, self.controllable);
        }
        if (self.source_window_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(InsetsSourceProviderProtoWire.SOURCE_WINDOW_STATE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.control_target_identifier) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(InsetsSourceProviderProtoWire.CONTROL_TARGET_IDENTIFIER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.pending_control_target_identifier) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(InsetsSourceProviderProtoWire.PENDING_CONTROL_TARGET_IDENTIFIER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.fake_control_target_identifier) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(InsetsSourceProviderProtoWire.FAKE_CONTROL_TARGET_IDENTIFIER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.source_window_state_identifier) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(InsetsSourceProviderProtoWire.SOURCE_WINDOW_STATE_IDENTIFIER_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const InsetsSourceProviderProtoReader = struct {
    buf: gremlin.Reader,
    _source_buf: ?[]const u8 = null,
    _frame_buf: ?[]const u8 = null,
    _fake_control_buf: ?[]const u8 = null,
    _control_buf: ?[]const u8 = null,
    _control_target_buf: ?[]const u8 = null,
    _pending_control_target_buf: ?[]const u8 = null,
    _fake_control_target_buf: ?[]const u8 = null,
    _captured_leash_buf: ?[]const u8 = null,
    _ime_overridden_frame_buf: ?[]const u8 = null,
    _is_leash_ready_for_dispatching: bool = false,
    _client_visible: bool = false,
    _server_visible: bool = false,
    _seamless_rotating: bool = false,
    _finish_seamless_rotate_frame_number: i64 = 0,
    _controllable: bool = false,
    _source_window_state_buf: ?[]const u8 = null,
    _control_target_identifier_buf: ?[]const u8 = null,
    _pending_control_target_identifier_buf: ?[]const u8 = null,
    _fake_control_target_identifier_buf: ?[]const u8 = null,
    _source_window_state_identifier_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!InsetsSourceProviderProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = InsetsSourceProviderProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                InsetsSourceProviderProtoWire.SOURCE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._source_buf = result.value;
                },
                InsetsSourceProviderProtoWire.FRAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._frame_buf = result.value;
                },
                InsetsSourceProviderProtoWire.FAKE_CONTROL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._fake_control_buf = result.value;
                },
                InsetsSourceProviderProtoWire.CONTROL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._control_buf = result.value;
                },
                InsetsSourceProviderProtoWire.CONTROL_TARGET_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._control_target_buf = result.value;
                },
                InsetsSourceProviderProtoWire.PENDING_CONTROL_TARGET_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._pending_control_target_buf = result.value;
                },
                InsetsSourceProviderProtoWire.FAKE_CONTROL_TARGET_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._fake_control_target_buf = result.value;
                },
                InsetsSourceProviderProtoWire.CAPTURED_LEASH_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._captured_leash_buf = result.value;
                },
                InsetsSourceProviderProtoWire.IME_OVERRIDDEN_FRAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ime_overridden_frame_buf = result.value;
                },
                InsetsSourceProviderProtoWire.IS_LEASH_READY_FOR_DISPATCHING_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_leash_ready_for_dispatching = result.value;
                },
                InsetsSourceProviderProtoWire.CLIENT_VISIBLE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._client_visible = result.value;
                },
                InsetsSourceProviderProtoWire.SERVER_VISIBLE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._server_visible = result.value;
                },
                InsetsSourceProviderProtoWire.SEAMLESS_ROTATING_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._seamless_rotating = result.value;
                },
                InsetsSourceProviderProtoWire.FINISH_SEAMLESS_ROTATE_FRAME_NUMBER_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._finish_seamless_rotate_frame_number = result.value;
                },
                InsetsSourceProviderProtoWire.CONTROLLABLE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._controllable = result.value;
                },
                InsetsSourceProviderProtoWire.SOURCE_WINDOW_STATE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._source_window_state_buf = result.value;
                },
                InsetsSourceProviderProtoWire.CONTROL_TARGET_IDENTIFIER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._control_target_identifier_buf = result.value;
                },
                InsetsSourceProviderProtoWire.PENDING_CONTROL_TARGET_IDENTIFIER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._pending_control_target_identifier_buf = result.value;
                },
                InsetsSourceProviderProtoWire.FAKE_CONTROL_TARGET_IDENTIFIER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._fake_control_target_identifier_buf = result.value;
                },
                InsetsSourceProviderProtoWire.SOURCE_WINDOW_STATE_IDENTIFIER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._source_window_state_identifier_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getSource(self: *const InsetsSourceProviderProtoReader) gremlin.Error!insetssource.InsetsSourceProtoReader {
        if (self._source_buf) |buf| {
            return try insetssource.InsetsSourceProtoReader.init(buf);
        }
        return try insetssource.InsetsSourceProtoReader.init(&[_]u8{});
    }
    pub fn getFrame(self: *const InsetsSourceProviderProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._frame_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getFakeControl(self: *const InsetsSourceProviderProtoReader) gremlin.Error!insetssourcecontrol.InsetsSourceControlProtoReader {
        if (self._fake_control_buf) |buf| {
            return try insetssourcecontrol.InsetsSourceControlProtoReader.init(buf);
        }
        return try insetssourcecontrol.InsetsSourceControlProtoReader.init(&[_]u8{});
    }
    pub fn getControl(self: *const InsetsSourceProviderProtoReader) gremlin.Error!insetssourcecontrol.InsetsSourceControlProtoReader {
        if (self._control_buf) |buf| {
            return try insetssourcecontrol.InsetsSourceControlProtoReader.init(buf);
        }
        return try insetssourcecontrol.InsetsSourceControlProtoReader.init(&[_]u8{});
    }
    pub fn getControlTarget(self: *const InsetsSourceProviderProtoReader) gremlin.Error!WindowStateProtoReader {
        if (self._control_target_buf) |buf| {
            return try WindowStateProtoReader.init(buf);
        }
        return try WindowStateProtoReader.init(&[_]u8{});
    }
    pub fn getPendingControlTarget(self: *const InsetsSourceProviderProtoReader) gremlin.Error!WindowStateProtoReader {
        if (self._pending_control_target_buf) |buf| {
            return try WindowStateProtoReader.init(buf);
        }
        return try WindowStateProtoReader.init(&[_]u8{});
    }
    pub fn getFakeControlTarget(self: *const InsetsSourceProviderProtoReader) gremlin.Error!WindowStateProtoReader {
        if (self._fake_control_target_buf) |buf| {
            return try WindowStateProtoReader.init(buf);
        }
        return try WindowStateProtoReader.init(&[_]u8{});
    }
    pub fn getCapturedLeash(self: *const InsetsSourceProviderProtoReader) gremlin.Error!surfacecontrol.SurfaceControlProtoReader {
        if (self._captured_leash_buf) |buf| {
            return try surfacecontrol.SurfaceControlProtoReader.init(buf);
        }
        return try surfacecontrol.SurfaceControlProtoReader.init(&[_]u8{});
    }
    pub fn getImeOverriddenFrame(self: *const InsetsSourceProviderProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._ime_overridden_frame_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub inline fn getIsLeashReadyForDispatching(self: *const InsetsSourceProviderProtoReader) bool {
        return self._is_leash_ready_for_dispatching;
    }
    pub inline fn getClientVisible(self: *const InsetsSourceProviderProtoReader) bool {
        return self._client_visible;
    }
    pub inline fn getServerVisible(self: *const InsetsSourceProviderProtoReader) bool {
        return self._server_visible;
    }
    pub inline fn getSeamlessRotating(self: *const InsetsSourceProviderProtoReader) bool {
        return self._seamless_rotating;
    }
    pub inline fn getFinishSeamlessRotateFrameNumber(self: *const InsetsSourceProviderProtoReader) i64 {
        return self._finish_seamless_rotate_frame_number;
    }
    pub inline fn getControllable(self: *const InsetsSourceProviderProtoReader) bool {
        return self._controllable;
    }
    pub fn getSourceWindowState(self: *const InsetsSourceProviderProtoReader) gremlin.Error!WindowStateProtoReader {
        if (self._source_window_state_buf) |buf| {
            return try WindowStateProtoReader.init(buf);
        }
        return try WindowStateProtoReader.init(&[_]u8{});
    }
    pub fn getControlTargetIdentifier(self: *const InsetsSourceProviderProtoReader) gremlin.Error!IdentifierProtoReader {
        if (self._control_target_identifier_buf) |buf| {
            return try IdentifierProtoReader.init(buf);
        }
        return try IdentifierProtoReader.init(&[_]u8{});
    }
    pub fn getPendingControlTargetIdentifier(self: *const InsetsSourceProviderProtoReader) gremlin.Error!IdentifierProtoReader {
        if (self._pending_control_target_identifier_buf) |buf| {
            return try IdentifierProtoReader.init(buf);
        }
        return try IdentifierProtoReader.init(&[_]u8{});
    }
    pub fn getFakeControlTargetIdentifier(self: *const InsetsSourceProviderProtoReader) gremlin.Error!IdentifierProtoReader {
        if (self._fake_control_target_identifier_buf) |buf| {
            return try IdentifierProtoReader.init(buf);
        }
        return try IdentifierProtoReader.init(&[_]u8{});
    }
    pub fn getSourceWindowStateIdentifier(self: *const InsetsSourceProviderProtoReader) gremlin.Error!IdentifierProtoReader {
        if (self._source_window_state_identifier_buf) |buf| {
            return try IdentifierProtoReader.init(buf);
        }
        return try IdentifierProtoReader.init(&[_]u8{});
    }
};
const ImeInsetsSourceProviderProtoWire = struct {
    const INSETS_SOURCE_PROVIDER_WIRE: gremlin.ProtoWireNumber = 1;
    const IME_TARGET_FROM_IME_WIRE: gremlin.ProtoWireNumber = 2;
    const IS_IME_LAYOUT_DRAWN_WIRE: gremlin.ProtoWireNumber = 3;
    const IME_TARGET_FROM_IME_IDENTIFIER_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const ImeInsetsSourceProviderProto = struct {
    // fields
    insets_source_provider: ?InsetsSourceProviderProto = null,
    ime_target_from_ime: ?WindowStateProto = null,
    is_ime_layout_drawn: bool = false,
    ime_target_from_ime_identifier: ?IdentifierProto = null,
    pub fn calcProtobufSize(self: *const ImeInsetsSourceProviderProto) usize {
        var res: usize = 0;
        if (self.insets_source_provider) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ImeInsetsSourceProviderProtoWire.INSETS_SOURCE_PROVIDER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ime_target_from_ime) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ImeInsetsSourceProviderProtoWire.IME_TARGET_FROM_IME_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.is_ime_layout_drawn != false) {
            res += gremlin.sizes.sizeWireNumber(ImeInsetsSourceProviderProtoWire.IS_IME_LAYOUT_DRAWN_WIRE) + gremlin.sizes.sizeBool(self.is_ime_layout_drawn);
        }
        if (self.ime_target_from_ime_identifier) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ImeInsetsSourceProviderProtoWire.IME_TARGET_FROM_IME_IDENTIFIER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const ImeInsetsSourceProviderProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ImeInsetsSourceProviderProto, target: *gremlin.Writer) void {
        if (self.insets_source_provider) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ImeInsetsSourceProviderProtoWire.INSETS_SOURCE_PROVIDER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ime_target_from_ime) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ImeInsetsSourceProviderProtoWire.IME_TARGET_FROM_IME_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.is_ime_layout_drawn != false) {
            target.appendBool(ImeInsetsSourceProviderProtoWire.IS_IME_LAYOUT_DRAWN_WIRE, self.is_ime_layout_drawn);
        }
        if (self.ime_target_from_ime_identifier) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ImeInsetsSourceProviderProtoWire.IME_TARGET_FROM_IME_IDENTIFIER_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const ImeInsetsSourceProviderProtoReader = struct {
    buf: gremlin.Reader,
    _insets_source_provider_buf: ?[]const u8 = null,
    _ime_target_from_ime_buf: ?[]const u8 = null,
    _is_ime_layout_drawn: bool = false,
    _ime_target_from_ime_identifier_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!ImeInsetsSourceProviderProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = ImeInsetsSourceProviderProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ImeInsetsSourceProviderProtoWire.INSETS_SOURCE_PROVIDER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._insets_source_provider_buf = result.value;
                },
                ImeInsetsSourceProviderProtoWire.IME_TARGET_FROM_IME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ime_target_from_ime_buf = result.value;
                },
                ImeInsetsSourceProviderProtoWire.IS_IME_LAYOUT_DRAWN_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_ime_layout_drawn = result.value;
                },
                ImeInsetsSourceProviderProtoWire.IME_TARGET_FROM_IME_IDENTIFIER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ime_target_from_ime_identifier_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getInsetsSourceProvider(self: *const ImeInsetsSourceProviderProtoReader) gremlin.Error!InsetsSourceProviderProtoReader {
        if (self._insets_source_provider_buf) |buf| {
            return try InsetsSourceProviderProtoReader.init(buf);
        }
        return try InsetsSourceProviderProtoReader.init(&[_]u8{});
    }
    pub fn getImeTargetFromIme(self: *const ImeInsetsSourceProviderProtoReader) gremlin.Error!WindowStateProtoReader {
        if (self._ime_target_from_ime_buf) |buf| {
            return try WindowStateProtoReader.init(buf);
        }
        return try WindowStateProtoReader.init(&[_]u8{});
    }
    pub inline fn getIsImeLayoutDrawn(self: *const ImeInsetsSourceProviderProtoReader) bool {
        return self._is_ime_layout_drawn;
    }
    pub fn getImeTargetFromImeIdentifier(self: *const ImeInsetsSourceProviderProtoReader) gremlin.Error!IdentifierProtoReader {
        if (self._ime_target_from_ime_identifier_buf) |buf| {
            return try IdentifierProtoReader.init(buf);
        }
        return try IdentifierProtoReader.init(&[_]u8{});
    }
};
const BackNavigationProtoWire = struct {
    const ANIMATION_IN_PROGRESS_WIRE: gremlin.ProtoWireNumber = 1;
    const LAST_BACK_TYPE_WIRE: gremlin.ProtoWireNumber = 2;
    const SHOW_WALLPAPER_WIRE: gremlin.ProtoWireNumber = 3;
    const MAIN_OPEN_ACTIVITY_WIRE: gremlin.ProtoWireNumber = 4;
    const ANIMATION_RUNNING_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const BackNavigationProto = struct {
    // fields
    animation_in_progress: bool = false,
    last_back_type: i32 = 0,
    show_wallpaper: bool = false,
    main_open_activity: ?[]const u8 = null,
    animation_running: bool = false,
    pub fn calcProtobufSize(self: *const BackNavigationProto) usize {
        var res: usize = 0;
        if (self.animation_in_progress != false) {
            res += gremlin.sizes.sizeWireNumber(BackNavigationProtoWire.ANIMATION_IN_PROGRESS_WIRE) + gremlin.sizes.sizeBool(self.animation_in_progress);
        }
        if (self.last_back_type != 0) {
            res += gremlin.sizes.sizeWireNumber(BackNavigationProtoWire.LAST_BACK_TYPE_WIRE) + gremlin.sizes.sizeI32(self.last_back_type);
        }
        if (self.show_wallpaper != false) {
            res += gremlin.sizes.sizeWireNumber(BackNavigationProtoWire.SHOW_WALLPAPER_WIRE) + gremlin.sizes.sizeBool(self.show_wallpaper);
        }
        if (self.main_open_activity) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(BackNavigationProtoWire.MAIN_OPEN_ACTIVITY_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.animation_running != false) {
            res += gremlin.sizes.sizeWireNumber(BackNavigationProtoWire.ANIMATION_RUNNING_WIRE) + gremlin.sizes.sizeBool(self.animation_running);
        }
        return res;
    }
    pub fn encode(self: *const BackNavigationProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const BackNavigationProto, target: *gremlin.Writer) void {
        if (self.animation_in_progress != false) {
            target.appendBool(BackNavigationProtoWire.ANIMATION_IN_PROGRESS_WIRE, self.animation_in_progress);
        }
        if (self.last_back_type != 0) {
            target.appendInt32(BackNavigationProtoWire.LAST_BACK_TYPE_WIRE, self.last_back_type);
        }
        if (self.show_wallpaper != false) {
            target.appendBool(BackNavigationProtoWire.SHOW_WALLPAPER_WIRE, self.show_wallpaper);
        }
        if (self.main_open_activity) |v| {
            if (v.len > 0) {
                target.appendBytes(BackNavigationProtoWire.MAIN_OPEN_ACTIVITY_WIRE, v);
            }
        }
        if (self.animation_running != false) {
            target.appendBool(BackNavigationProtoWire.ANIMATION_RUNNING_WIRE, self.animation_running);
        }
    }
};
pub const BackNavigationProtoReader = struct {
    buf: gremlin.Reader,
    _animation_in_progress: bool = false,
    _last_back_type: i32 = 0,
    _show_wallpaper: bool = false,
    _main_open_activity: ?[]const u8 = null,
    _animation_running: bool = false,
    pub fn init(src: []const u8) gremlin.Error!BackNavigationProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = BackNavigationProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                BackNavigationProtoWire.ANIMATION_IN_PROGRESS_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._animation_in_progress = result.value;
                },
                BackNavigationProtoWire.LAST_BACK_TYPE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._last_back_type = result.value;
                },
                BackNavigationProtoWire.SHOW_WALLPAPER_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._show_wallpaper = result.value;
                },
                BackNavigationProtoWire.MAIN_OPEN_ACTIVITY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._main_open_activity = result.value;
                },
                BackNavigationProtoWire.ANIMATION_RUNNING_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._animation_running = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getAnimationInProgress(self: *const BackNavigationProtoReader) bool {
        return self._animation_in_progress;
    }
    pub inline fn getLastBackType(self: *const BackNavigationProtoReader) i32 {
        return self._last_back_type;
    }
    pub inline fn getShowWallpaper(self: *const BackNavigationProtoReader) bool {
        return self._show_wallpaper;
    }
    pub inline fn getMainOpenActivity(self: *const BackNavigationProtoReader) []const u8 {
        return self._main_open_activity orelse &[_]u8{};
    }
    pub inline fn getAnimationRunning(self: *const BackNavigationProtoReader) bool {
        return self._animation_running;
    }
};
