// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
const editorinfo = @import("src/gen/protos/perfetto/trace/android/view/inputmethod/editorinfo.proto.zig");
// structs
const InputMethodManagerServiceProtoWire = struct {
    const CUR_METHOD_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const CUR_SEQ_WIRE: gremlin.ProtoWireNumber = 2;
    const CUR_CLIENT_WIRE: gremlin.ProtoWireNumber = 3;
    const CUR_FOCUSED_WINDOW_NAME_WIRE: gremlin.ProtoWireNumber = 4;
    const LAST_IME_TARGET_WINDOW_NAME_WIRE: gremlin.ProtoWireNumber = 5;
    const CUR_FOCUSED_WINDOW_SOFT_INPUT_MODE_WIRE: gremlin.ProtoWireNumber = 6;
    const CUR_ATTRIBUTE_WIRE: gremlin.ProtoWireNumber = 7;
    const CUR_ID_WIRE: gremlin.ProtoWireNumber = 8;
    const SHOW_EXPLICITLY_REQUESTED_WIRE: gremlin.ProtoWireNumber = 10;
    const SHOW_FORCED_WIRE: gremlin.ProtoWireNumber = 11;
    const INPUT_SHOWN_WIRE: gremlin.ProtoWireNumber = 12;
    const IN_FULLSCREEN_MODE_WIRE: gremlin.ProtoWireNumber = 13;
    const CUR_TOKEN_WIRE: gremlin.ProtoWireNumber = 14;
    const CUR_TOKEN_DISPLAY_ID_WIRE: gremlin.ProtoWireNumber = 15;
    const SYSTEM_READY_WIRE: gremlin.ProtoWireNumber = 16;
    const LAST_SWITCH_USER_ID_WIRE: gremlin.ProtoWireNumber = 17;
    const HAVE_CONNECTION_WIRE: gremlin.ProtoWireNumber = 18;
    const BOUND_TO_METHOD_WIRE: gremlin.ProtoWireNumber = 19;
    const IS_INTERACTIVE_WIRE: gremlin.ProtoWireNumber = 20;
    const BACK_DISPOSITION_WIRE: gremlin.ProtoWireNumber = 21;
    const IME_WINDOW_VISIBILITY_WIRE: gremlin.ProtoWireNumber = 22;
    const SHOW_IME_WITH_HARD_KEYBOARD_WIRE: gremlin.ProtoWireNumber = 23;
    const ACCESSIBILITY_REQUESTING_NO_SOFT_KEYBOARD_WIRE: gremlin.ProtoWireNumber = 24;
    const CONCURRENT_MULTI_USER_MODE_ENABLED_WIRE: gremlin.ProtoWireNumber = 25;
    const PREVENT_IME_STARTUP_UNLESS_TEXT_EDITOR_WIRE: gremlin.ProtoWireNumber = 26;
};
pub const InputMethodManagerServiceProto = struct {
    // fields
    cur_method_id: ?[]const u8 = null,
    cur_seq: i32 = 0,
    cur_client: ?[]const u8 = null,
    cur_focused_window_name: ?[]const u8 = null,
    last_ime_target_window_name: ?[]const u8 = null,
    cur_focused_window_soft_input_mode: ?[]const u8 = null,
    cur_attribute: ?editorinfo.EditorInfoProto = null,
    cur_id: ?[]const u8 = null,
    show_explicitly_requested: bool = false,
    show_forced: bool = false,
    input_shown: bool = false,
    in_fullscreen_mode: bool = false,
    cur_token: ?[]const u8 = null,
    cur_token_display_id: i32 = 0,
    system_ready: bool = false,
    last_switch_user_id: i32 = 0,
    have_connection: bool = false,
    bound_to_method: bool = false,
    is_interactive: bool = false,
    back_disposition: i32 = 0,
    ime_window_visibility: i32 = 0,
    show_ime_with_hard_keyboard: bool = false,
    accessibility_requesting_no_soft_keyboard: bool = false,
    concurrent_multi_user_mode_enabled: bool = false,
    prevent_ime_startup_unless_text_editor: bool = false,
    pub fn calcProtobufSize(self: *const InputMethodManagerServiceProto) usize {
        var res: usize = 0;
        if (self.cur_method_id) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(InputMethodManagerServiceProtoWire.CUR_METHOD_ID_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.cur_seq != 0) {
            res += gremlin.sizes.sizeWireNumber(InputMethodManagerServiceProtoWire.CUR_SEQ_WIRE) + gremlin.sizes.sizeI32(self.cur_seq);
        }
        if (self.cur_client) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(InputMethodManagerServiceProtoWire.CUR_CLIENT_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.cur_focused_window_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(InputMethodManagerServiceProtoWire.CUR_FOCUSED_WINDOW_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.last_ime_target_window_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(InputMethodManagerServiceProtoWire.LAST_IME_TARGET_WINDOW_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.cur_focused_window_soft_input_mode) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(InputMethodManagerServiceProtoWire.CUR_FOCUSED_WINDOW_SOFT_INPUT_MODE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.cur_attribute) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(InputMethodManagerServiceProtoWire.CUR_ATTRIBUTE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cur_id) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(InputMethodManagerServiceProtoWire.CUR_ID_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.show_explicitly_requested != false) {
            res += gremlin.sizes.sizeWireNumber(InputMethodManagerServiceProtoWire.SHOW_EXPLICITLY_REQUESTED_WIRE) + gremlin.sizes.sizeBool(self.show_explicitly_requested);
        }
        if (self.show_forced != false) {
            res += gremlin.sizes.sizeWireNumber(InputMethodManagerServiceProtoWire.SHOW_FORCED_WIRE) + gremlin.sizes.sizeBool(self.show_forced);
        }
        if (self.input_shown != false) {
            res += gremlin.sizes.sizeWireNumber(InputMethodManagerServiceProtoWire.INPUT_SHOWN_WIRE) + gremlin.sizes.sizeBool(self.input_shown);
        }
        if (self.in_fullscreen_mode != false) {
            res += gremlin.sizes.sizeWireNumber(InputMethodManagerServiceProtoWire.IN_FULLSCREEN_MODE_WIRE) + gremlin.sizes.sizeBool(self.in_fullscreen_mode);
        }
        if (self.cur_token) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(InputMethodManagerServiceProtoWire.CUR_TOKEN_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.cur_token_display_id != 0) {
            res += gremlin.sizes.sizeWireNumber(InputMethodManagerServiceProtoWire.CUR_TOKEN_DISPLAY_ID_WIRE) + gremlin.sizes.sizeI32(self.cur_token_display_id);
        }
        if (self.system_ready != false) {
            res += gremlin.sizes.sizeWireNumber(InputMethodManagerServiceProtoWire.SYSTEM_READY_WIRE) + gremlin.sizes.sizeBool(self.system_ready);
        }
        if (self.last_switch_user_id != 0) {
            res += gremlin.sizes.sizeWireNumber(InputMethodManagerServiceProtoWire.LAST_SWITCH_USER_ID_WIRE) + gremlin.sizes.sizeI32(self.last_switch_user_id);
        }
        if (self.have_connection != false) {
            res += gremlin.sizes.sizeWireNumber(InputMethodManagerServiceProtoWire.HAVE_CONNECTION_WIRE) + gremlin.sizes.sizeBool(self.have_connection);
        }
        if (self.bound_to_method != false) {
            res += gremlin.sizes.sizeWireNumber(InputMethodManagerServiceProtoWire.BOUND_TO_METHOD_WIRE) + gremlin.sizes.sizeBool(self.bound_to_method);
        }
        if (self.is_interactive != false) {
            res += gremlin.sizes.sizeWireNumber(InputMethodManagerServiceProtoWire.IS_INTERACTIVE_WIRE) + gremlin.sizes.sizeBool(self.is_interactive);
        }
        if (self.back_disposition != 0) {
            res += gremlin.sizes.sizeWireNumber(InputMethodManagerServiceProtoWire.BACK_DISPOSITION_WIRE) + gremlin.sizes.sizeI32(self.back_disposition);
        }
        if (self.ime_window_visibility != 0) {
            res += gremlin.sizes.sizeWireNumber(InputMethodManagerServiceProtoWire.IME_WINDOW_VISIBILITY_WIRE) + gremlin.sizes.sizeI32(self.ime_window_visibility);
        }
        if (self.show_ime_with_hard_keyboard != false) {
            res += gremlin.sizes.sizeWireNumber(InputMethodManagerServiceProtoWire.SHOW_IME_WITH_HARD_KEYBOARD_WIRE) + gremlin.sizes.sizeBool(self.show_ime_with_hard_keyboard);
        }
        if (self.accessibility_requesting_no_soft_keyboard != false) {
            res += gremlin.sizes.sizeWireNumber(InputMethodManagerServiceProtoWire.ACCESSIBILITY_REQUESTING_NO_SOFT_KEYBOARD_WIRE) + gremlin.sizes.sizeBool(self.accessibility_requesting_no_soft_keyboard);
        }
        if (self.concurrent_multi_user_mode_enabled != false) {
            res += gremlin.sizes.sizeWireNumber(InputMethodManagerServiceProtoWire.CONCURRENT_MULTI_USER_MODE_ENABLED_WIRE) + gremlin.sizes.sizeBool(self.concurrent_multi_user_mode_enabled);
        }
        if (self.prevent_ime_startup_unless_text_editor != false) {
            res += gremlin.sizes.sizeWireNumber(InputMethodManagerServiceProtoWire.PREVENT_IME_STARTUP_UNLESS_TEXT_EDITOR_WIRE) + gremlin.sizes.sizeBool(self.prevent_ime_startup_unless_text_editor);
        }
        return res;
    }
    pub fn encode(self: *const InputMethodManagerServiceProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const InputMethodManagerServiceProto, target: *gremlin.Writer) void {
        if (self.cur_method_id) |v| {
            if (v.len > 0) {
                target.appendBytes(InputMethodManagerServiceProtoWire.CUR_METHOD_ID_WIRE, v);
            }
        }
        if (self.cur_seq != 0) {
            target.appendInt32(InputMethodManagerServiceProtoWire.CUR_SEQ_WIRE, self.cur_seq);
        }
        if (self.cur_client) |v| {
            if (v.len > 0) {
                target.appendBytes(InputMethodManagerServiceProtoWire.CUR_CLIENT_WIRE, v);
            }
        }
        if (self.cur_focused_window_name) |v| {
            if (v.len > 0) {
                target.appendBytes(InputMethodManagerServiceProtoWire.CUR_FOCUSED_WINDOW_NAME_WIRE, v);
            }
        }
        if (self.last_ime_target_window_name) |v| {
            if (v.len > 0) {
                target.appendBytes(InputMethodManagerServiceProtoWire.LAST_IME_TARGET_WINDOW_NAME_WIRE, v);
            }
        }
        if (self.cur_focused_window_soft_input_mode) |v| {
            if (v.len > 0) {
                target.appendBytes(InputMethodManagerServiceProtoWire.CUR_FOCUSED_WINDOW_SOFT_INPUT_MODE_WIRE, v);
            }
        }
        if (self.cur_attribute) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(InputMethodManagerServiceProtoWire.CUR_ATTRIBUTE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cur_id) |v| {
            if (v.len > 0) {
                target.appendBytes(InputMethodManagerServiceProtoWire.CUR_ID_WIRE, v);
            }
        }
        if (self.show_explicitly_requested != false) {
            target.appendBool(InputMethodManagerServiceProtoWire.SHOW_EXPLICITLY_REQUESTED_WIRE, self.show_explicitly_requested);
        }
        if (self.show_forced != false) {
            target.appendBool(InputMethodManagerServiceProtoWire.SHOW_FORCED_WIRE, self.show_forced);
        }
        if (self.input_shown != false) {
            target.appendBool(InputMethodManagerServiceProtoWire.INPUT_SHOWN_WIRE, self.input_shown);
        }
        if (self.in_fullscreen_mode != false) {
            target.appendBool(InputMethodManagerServiceProtoWire.IN_FULLSCREEN_MODE_WIRE, self.in_fullscreen_mode);
        }
        if (self.cur_token) |v| {
            if (v.len > 0) {
                target.appendBytes(InputMethodManagerServiceProtoWire.CUR_TOKEN_WIRE, v);
            }
        }
        if (self.cur_token_display_id != 0) {
            target.appendInt32(InputMethodManagerServiceProtoWire.CUR_TOKEN_DISPLAY_ID_WIRE, self.cur_token_display_id);
        }
        if (self.system_ready != false) {
            target.appendBool(InputMethodManagerServiceProtoWire.SYSTEM_READY_WIRE, self.system_ready);
        }
        if (self.last_switch_user_id != 0) {
            target.appendInt32(InputMethodManagerServiceProtoWire.LAST_SWITCH_USER_ID_WIRE, self.last_switch_user_id);
        }
        if (self.have_connection != false) {
            target.appendBool(InputMethodManagerServiceProtoWire.HAVE_CONNECTION_WIRE, self.have_connection);
        }
        if (self.bound_to_method != false) {
            target.appendBool(InputMethodManagerServiceProtoWire.BOUND_TO_METHOD_WIRE, self.bound_to_method);
        }
        if (self.is_interactive != false) {
            target.appendBool(InputMethodManagerServiceProtoWire.IS_INTERACTIVE_WIRE, self.is_interactive);
        }
        if (self.back_disposition != 0) {
            target.appendInt32(InputMethodManagerServiceProtoWire.BACK_DISPOSITION_WIRE, self.back_disposition);
        }
        if (self.ime_window_visibility != 0) {
            target.appendInt32(InputMethodManagerServiceProtoWire.IME_WINDOW_VISIBILITY_WIRE, self.ime_window_visibility);
        }
        if (self.show_ime_with_hard_keyboard != false) {
            target.appendBool(InputMethodManagerServiceProtoWire.SHOW_IME_WITH_HARD_KEYBOARD_WIRE, self.show_ime_with_hard_keyboard);
        }
        if (self.accessibility_requesting_no_soft_keyboard != false) {
            target.appendBool(InputMethodManagerServiceProtoWire.ACCESSIBILITY_REQUESTING_NO_SOFT_KEYBOARD_WIRE, self.accessibility_requesting_no_soft_keyboard);
        }
        if (self.concurrent_multi_user_mode_enabled != false) {
            target.appendBool(InputMethodManagerServiceProtoWire.CONCURRENT_MULTI_USER_MODE_ENABLED_WIRE, self.concurrent_multi_user_mode_enabled);
        }
        if (self.prevent_ime_startup_unless_text_editor != false) {
            target.appendBool(InputMethodManagerServiceProtoWire.PREVENT_IME_STARTUP_UNLESS_TEXT_EDITOR_WIRE, self.prevent_ime_startup_unless_text_editor);
        }
    }
};
pub const InputMethodManagerServiceProtoReader = struct {
    buf: gremlin.Reader,
    _cur_method_id: ?[]const u8 = null,
    _cur_seq: i32 = 0,
    _cur_client: ?[]const u8 = null,
    _cur_focused_window_name: ?[]const u8 = null,
    _last_ime_target_window_name: ?[]const u8 = null,
    _cur_focused_window_soft_input_mode: ?[]const u8 = null,
    _cur_attribute_buf: ?[]const u8 = null,
    _cur_id: ?[]const u8 = null,
    _show_explicitly_requested: bool = false,
    _show_forced: bool = false,
    _input_shown: bool = false,
    _in_fullscreen_mode: bool = false,
    _cur_token: ?[]const u8 = null,
    _cur_token_display_id: i32 = 0,
    _system_ready: bool = false,
    _last_switch_user_id: i32 = 0,
    _have_connection: bool = false,
    _bound_to_method: bool = false,
    _is_interactive: bool = false,
    _back_disposition: i32 = 0,
    _ime_window_visibility: i32 = 0,
    _show_ime_with_hard_keyboard: bool = false,
    _accessibility_requesting_no_soft_keyboard: bool = false,
    _concurrent_multi_user_mode_enabled: bool = false,
    _prevent_ime_startup_unless_text_editor: bool = false,
    pub fn init(src: []const u8) gremlin.Error!InputMethodManagerServiceProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = InputMethodManagerServiceProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                InputMethodManagerServiceProtoWire.CUR_METHOD_ID_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cur_method_id = result.value;
                },
                InputMethodManagerServiceProtoWire.CUR_SEQ_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._cur_seq = result.value;
                },
                InputMethodManagerServiceProtoWire.CUR_CLIENT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cur_client = result.value;
                },
                InputMethodManagerServiceProtoWire.CUR_FOCUSED_WINDOW_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cur_focused_window_name = result.value;
                },
                InputMethodManagerServiceProtoWire.LAST_IME_TARGET_WINDOW_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._last_ime_target_window_name = result.value;
                },
                InputMethodManagerServiceProtoWire.CUR_FOCUSED_WINDOW_SOFT_INPUT_MODE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cur_focused_window_soft_input_mode = result.value;
                },
                InputMethodManagerServiceProtoWire.CUR_ATTRIBUTE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cur_attribute_buf = result.value;
                },
                InputMethodManagerServiceProtoWire.CUR_ID_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cur_id = result.value;
                },
                InputMethodManagerServiceProtoWire.SHOW_EXPLICITLY_REQUESTED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._show_explicitly_requested = result.value;
                },
                InputMethodManagerServiceProtoWire.SHOW_FORCED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._show_forced = result.value;
                },
                InputMethodManagerServiceProtoWire.INPUT_SHOWN_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._input_shown = result.value;
                },
                InputMethodManagerServiceProtoWire.IN_FULLSCREEN_MODE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._in_fullscreen_mode = result.value;
                },
                InputMethodManagerServiceProtoWire.CUR_TOKEN_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cur_token = result.value;
                },
                InputMethodManagerServiceProtoWire.CUR_TOKEN_DISPLAY_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._cur_token_display_id = result.value;
                },
                InputMethodManagerServiceProtoWire.SYSTEM_READY_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._system_ready = result.value;
                },
                InputMethodManagerServiceProtoWire.LAST_SWITCH_USER_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._last_switch_user_id = result.value;
                },
                InputMethodManagerServiceProtoWire.HAVE_CONNECTION_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._have_connection = result.value;
                },
                InputMethodManagerServiceProtoWire.BOUND_TO_METHOD_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._bound_to_method = result.value;
                },
                InputMethodManagerServiceProtoWire.IS_INTERACTIVE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_interactive = result.value;
                },
                InputMethodManagerServiceProtoWire.BACK_DISPOSITION_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._back_disposition = result.value;
                },
                InputMethodManagerServiceProtoWire.IME_WINDOW_VISIBILITY_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._ime_window_visibility = result.value;
                },
                InputMethodManagerServiceProtoWire.SHOW_IME_WITH_HARD_KEYBOARD_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._show_ime_with_hard_keyboard = result.value;
                },
                InputMethodManagerServiceProtoWire.ACCESSIBILITY_REQUESTING_NO_SOFT_KEYBOARD_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._accessibility_requesting_no_soft_keyboard = result.value;
                },
                InputMethodManagerServiceProtoWire.CONCURRENT_MULTI_USER_MODE_ENABLED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._concurrent_multi_user_mode_enabled = result.value;
                },
                InputMethodManagerServiceProtoWire.PREVENT_IME_STARTUP_UNLESS_TEXT_EDITOR_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._prevent_ime_startup_unless_text_editor = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getCurMethodId(self: *const InputMethodManagerServiceProtoReader) []const u8 {
        return self._cur_method_id orelse &[_]u8{};
    }
    pub inline fn getCurSeq(self: *const InputMethodManagerServiceProtoReader) i32 {
        return self._cur_seq;
    }
    pub inline fn getCurClient(self: *const InputMethodManagerServiceProtoReader) []const u8 {
        return self._cur_client orelse &[_]u8{};
    }
    pub inline fn getCurFocusedWindowName(self: *const InputMethodManagerServiceProtoReader) []const u8 {
        return self._cur_focused_window_name orelse &[_]u8{};
    }
    pub inline fn getLastImeTargetWindowName(self: *const InputMethodManagerServiceProtoReader) []const u8 {
        return self._last_ime_target_window_name orelse &[_]u8{};
    }
    pub inline fn getCurFocusedWindowSoftInputMode(self: *const InputMethodManagerServiceProtoReader) []const u8 {
        return self._cur_focused_window_soft_input_mode orelse &[_]u8{};
    }
    pub fn getCurAttribute(self: *const InputMethodManagerServiceProtoReader) gremlin.Error!editorinfo.EditorInfoProtoReader {
        if (self._cur_attribute_buf) |buf| {
            return try editorinfo.EditorInfoProtoReader.init(buf);
        }
        return try editorinfo.EditorInfoProtoReader.init(&[_]u8{});
    }
    pub inline fn getCurId(self: *const InputMethodManagerServiceProtoReader) []const u8 {
        return self._cur_id orelse &[_]u8{};
    }
    pub inline fn getShowExplicitlyRequested(self: *const InputMethodManagerServiceProtoReader) bool {
        return self._show_explicitly_requested;
    }
    pub inline fn getShowForced(self: *const InputMethodManagerServiceProtoReader) bool {
        return self._show_forced;
    }
    pub inline fn getInputShown(self: *const InputMethodManagerServiceProtoReader) bool {
        return self._input_shown;
    }
    pub inline fn getInFullscreenMode(self: *const InputMethodManagerServiceProtoReader) bool {
        return self._in_fullscreen_mode;
    }
    pub inline fn getCurToken(self: *const InputMethodManagerServiceProtoReader) []const u8 {
        return self._cur_token orelse &[_]u8{};
    }
    pub inline fn getCurTokenDisplayId(self: *const InputMethodManagerServiceProtoReader) i32 {
        return self._cur_token_display_id;
    }
    pub inline fn getSystemReady(self: *const InputMethodManagerServiceProtoReader) bool {
        return self._system_ready;
    }
    pub inline fn getLastSwitchUserId(self: *const InputMethodManagerServiceProtoReader) i32 {
        return self._last_switch_user_id;
    }
    pub inline fn getHaveConnection(self: *const InputMethodManagerServiceProtoReader) bool {
        return self._have_connection;
    }
    pub inline fn getBoundToMethod(self: *const InputMethodManagerServiceProtoReader) bool {
        return self._bound_to_method;
    }
    pub inline fn getIsInteractive(self: *const InputMethodManagerServiceProtoReader) bool {
        return self._is_interactive;
    }
    pub inline fn getBackDisposition(self: *const InputMethodManagerServiceProtoReader) i32 {
        return self._back_disposition;
    }
    pub inline fn getImeWindowVisibility(self: *const InputMethodManagerServiceProtoReader) i32 {
        return self._ime_window_visibility;
    }
    pub inline fn getShowImeWithHardKeyboard(self: *const InputMethodManagerServiceProtoReader) bool {
        return self._show_ime_with_hard_keyboard;
    }
    pub inline fn getAccessibilityRequestingNoSoftKeyboard(self: *const InputMethodManagerServiceProtoReader) bool {
        return self._accessibility_requesting_no_soft_keyboard;
    }
    pub inline fn getConcurrentMultiUserModeEnabled(self: *const InputMethodManagerServiceProtoReader) bool {
        return self._concurrent_multi_user_mode_enabled;
    }
    pub inline fn getPreventImeStartupUnlessTextEditor(self: *const InputMethodManagerServiceProtoReader) bool {
        return self._prevent_ime_startup_unless_text_editor;
    }
};
