// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const FrameTimelineEventWire = struct {
    const EXPECTED_DISPLAY_FRAME_START_WIRE: gremlin.ProtoWireNumber = 1;
    const ACTUAL_DISPLAY_FRAME_START_WIRE: gremlin.ProtoWireNumber = 2;
    const EXPECTED_SURFACE_FRAME_START_WIRE: gremlin.ProtoWireNumber = 3;
    const ACTUAL_SURFACE_FRAME_START_WIRE: gremlin.ProtoWireNumber = 4;
    const FRAME_END_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const FrameTimelineEvent = struct {
    // nested enums
    pub const JankType = enum(i32) {
        JANK_UNSPECIFIED = 0,
        JANK_NONE = 1,
        JANK_SF_SCHEDULING = 2,
        JANK_PREDICTION_ERROR = 4,
        JANK_DISPLAY_HAL = 8,
        JANK_SF_CPU_DEADLINE_MISSED = 16,
        JANK_SF_GPU_DEADLINE_MISSED = 32,
        JANK_APP_DEADLINE_MISSED = 64,
        JANK_BUFFER_STUFFING = 128,
        JANK_UNKNOWN = 256,
        JANK_SF_STUFFING = 512,
        JANK_DROPPED = 1024,
        JANK_NON_ANIMATING = 2048,
        JANK_APP_RESYNCED_JITTER = 4096,
        JANK_DISPLAY_NOT_ON = 8192,
    };
    pub const JankSeverityType = enum(i32) {
        SEVERITY_UNKNOWN = 0,
        SEVERITY_NONE = 1,
        SEVERITY_PARTIAL = 2,
        SEVERITY_FULL = 3,
    };
    pub const PresentType = enum(i32) {
        PRESENT_UNSPECIFIED = 0,
        PRESENT_ON_TIME = 1,
        PRESENT_LATE = 2,
        PRESENT_EARLY = 3,
        PRESENT_DROPPED = 4,
        PRESENT_UNKNOWN = 5,
    };
    pub const PredictionType = enum(i32) {
        PREDICTION_UNSPECIFIED = 0,
        PREDICTION_VALID = 1,
        PREDICTION_EXPIRED = 2,
        PREDICTION_UNKNOWN = 3,
    };
    // nested structs
    const ExpectedSurfaceFrameStartWire = struct {
        const COOKIE_WIRE: gremlin.ProtoWireNumber = 1;
        const TOKEN_WIRE: gremlin.ProtoWireNumber = 2;
        const DISPLAY_FRAME_TOKEN_WIRE: gremlin.ProtoWireNumber = 3;
        const PID_WIRE: gremlin.ProtoWireNumber = 4;
        const LAYER_NAME_WIRE: gremlin.ProtoWireNumber = 5;
    };
    pub const ExpectedSurfaceFrameStart = struct {
        // fields
        cookie: i64 = 0,
        token: i64 = 0,
        display_frame_token: i64 = 0,
        pid: i32 = 0,
        layer_name: ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const FrameTimelineEvent.ExpectedSurfaceFrameStart) usize {
            var res: usize = 0;
            if (self.cookie != 0) {
                res += gremlin.sizes.sizeWireNumber(FrameTimelineEvent.ExpectedSurfaceFrameStartWire.COOKIE_WIRE) + gremlin.sizes.sizeI64(self.cookie);
            }
            if (self.token != 0) {
                res += gremlin.sizes.sizeWireNumber(FrameTimelineEvent.ExpectedSurfaceFrameStartWire.TOKEN_WIRE) + gremlin.sizes.sizeI64(self.token);
            }
            if (self.display_frame_token != 0) {
                res += gremlin.sizes.sizeWireNumber(FrameTimelineEvent.ExpectedSurfaceFrameStartWire.DISPLAY_FRAME_TOKEN_WIRE) + gremlin.sizes.sizeI64(self.display_frame_token);
            }
            if (self.pid != 0) {
                res += gremlin.sizes.sizeWireNumber(FrameTimelineEvent.ExpectedSurfaceFrameStartWire.PID_WIRE) + gremlin.sizes.sizeI32(self.pid);
            }
            if (self.layer_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(FrameTimelineEvent.ExpectedSurfaceFrameStartWire.LAYER_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            return res;
        }
        pub fn encode(self: *const FrameTimelineEvent.ExpectedSurfaceFrameStart, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const FrameTimelineEvent.ExpectedSurfaceFrameStart, target: *gremlin.Writer) void {
            if (self.cookie != 0) {
                target.appendInt64(FrameTimelineEvent.ExpectedSurfaceFrameStartWire.COOKIE_WIRE, self.cookie);
            }
            if (self.token != 0) {
                target.appendInt64(FrameTimelineEvent.ExpectedSurfaceFrameStartWire.TOKEN_WIRE, self.token);
            }
            if (self.display_frame_token != 0) {
                target.appendInt64(FrameTimelineEvent.ExpectedSurfaceFrameStartWire.DISPLAY_FRAME_TOKEN_WIRE, self.display_frame_token);
            }
            if (self.pid != 0) {
                target.appendInt32(FrameTimelineEvent.ExpectedSurfaceFrameStartWire.PID_WIRE, self.pid);
            }
            if (self.layer_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(FrameTimelineEvent.ExpectedSurfaceFrameStartWire.LAYER_NAME_WIRE, v);
                }
            }
        }
    };
    pub const ExpectedSurfaceFrameStartReader = struct {
        buf: gremlin.Reader,
        _cookie: i64 = 0,
        _token: i64 = 0,
        _display_frame_token: i64 = 0,
        _pid: i32 = 0,
        _layer_name: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!FrameTimelineEvent.ExpectedSurfaceFrameStartReader {
            const buf = gremlin.Reader.init(src);
            var res = FrameTimelineEvent.ExpectedSurfaceFrameStartReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    FrameTimelineEvent.ExpectedSurfaceFrameStartWire.COOKIE_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._cookie = result.value;
                    },
                    FrameTimelineEvent.ExpectedSurfaceFrameStartWire.TOKEN_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._token = result.value;
                    },
                    FrameTimelineEvent.ExpectedSurfaceFrameStartWire.DISPLAY_FRAME_TOKEN_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._display_frame_token = result.value;
                    },
                    FrameTimelineEvent.ExpectedSurfaceFrameStartWire.PID_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._pid = result.value;
                    },
                    FrameTimelineEvent.ExpectedSurfaceFrameStartWire.LAYER_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._layer_name = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getCookie(self: *const FrameTimelineEvent.ExpectedSurfaceFrameStartReader) i64 {
            return self._cookie;
        }
        pub inline fn getToken(self: *const FrameTimelineEvent.ExpectedSurfaceFrameStartReader) i64 {
            return self._token;
        }
        pub inline fn getDisplayFrameToken(self: *const FrameTimelineEvent.ExpectedSurfaceFrameStartReader) i64 {
            return self._display_frame_token;
        }
        pub inline fn getPid(self: *const FrameTimelineEvent.ExpectedSurfaceFrameStartReader) i32 {
            return self._pid;
        }
        pub inline fn getLayerName(self: *const FrameTimelineEvent.ExpectedSurfaceFrameStartReader) []const u8 {
            return self._layer_name orelse &[_]u8{};
        }
    };
    const ActualSurfaceFrameStartWire = struct {
        const COOKIE_WIRE: gremlin.ProtoWireNumber = 1;
        const TOKEN_WIRE: gremlin.ProtoWireNumber = 2;
        const DISPLAY_FRAME_TOKEN_WIRE: gremlin.ProtoWireNumber = 3;
        const PID_WIRE: gremlin.ProtoWireNumber = 4;
        const LAYER_NAME_WIRE: gremlin.ProtoWireNumber = 5;
        const PRESENT_TYPE_WIRE: gremlin.ProtoWireNumber = 6;
        const ON_TIME_FINISH_WIRE: gremlin.ProtoWireNumber = 7;
        const GPU_COMPOSITION_WIRE: gremlin.ProtoWireNumber = 8;
        const JANK_TYPE_WIRE: gremlin.ProtoWireNumber = 9;
        const PREDICTION_TYPE_WIRE: gremlin.ProtoWireNumber = 10;
        const IS_BUFFER_WIRE: gremlin.ProtoWireNumber = 11;
        const JANK_SEVERITY_TYPE_WIRE: gremlin.ProtoWireNumber = 12;
        const PRESENT_DELAY_MILLIS_WIRE: gremlin.ProtoWireNumber = 13;
        const VSYNC_RESYNCED_JITTER_MILLIS_WIRE: gremlin.ProtoWireNumber = 14;
        const JANK_SEVERITY_SCORE_WIRE: gremlin.ProtoWireNumber = 15;
        const JANK_TYPE_EXPERIMENTAL_WIRE: gremlin.ProtoWireNumber = 16;
        const PRESENT_TYPE_EXPERIMENTAL_WIRE: gremlin.ProtoWireNumber = 17;
    };
    pub const ActualSurfaceFrameStart = struct {
        // fields
        cookie: i64 = 0,
        token: i64 = 0,
        display_frame_token: i64 = 0,
        pid: i32 = 0,
        layer_name: ?[]const u8 = null,
        present_type: FrameTimelineEvent.PresentType = @enumFromInt(0),
        on_time_finish: bool = false,
        gpu_composition: bool = false,
        jank_type: i32 = 0,
        prediction_type: FrameTimelineEvent.PredictionType = @enumFromInt(0),
        is_buffer: bool = false,
        jank_severity_type: FrameTimelineEvent.JankSeverityType = @enumFromInt(0),
        present_delay_millis: f32 = 0.0,
        vsync_resynced_jitter_millis: f32 = 0.0,
        jank_severity_score: f32 = 0.0,
        jank_type_experimental: i32 = 0,
        present_type_experimental: FrameTimelineEvent.PresentType = @enumFromInt(0),
        pub fn calcProtobufSize(self: *const FrameTimelineEvent.ActualSurfaceFrameStart) usize {
            var res: usize = 0;
            if (self.cookie != 0) {
                res += gremlin.sizes.sizeWireNumber(FrameTimelineEvent.ActualSurfaceFrameStartWire.COOKIE_WIRE) + gremlin.sizes.sizeI64(self.cookie);
            }
            if (self.token != 0) {
                res += gremlin.sizes.sizeWireNumber(FrameTimelineEvent.ActualSurfaceFrameStartWire.TOKEN_WIRE) + gremlin.sizes.sizeI64(self.token);
            }
            if (self.display_frame_token != 0) {
                res += gremlin.sizes.sizeWireNumber(FrameTimelineEvent.ActualSurfaceFrameStartWire.DISPLAY_FRAME_TOKEN_WIRE) + gremlin.sizes.sizeI64(self.display_frame_token);
            }
            if (self.pid != 0) {
                res += gremlin.sizes.sizeWireNumber(FrameTimelineEvent.ActualSurfaceFrameStartWire.PID_WIRE) + gremlin.sizes.sizeI32(self.pid);
            }
            if (self.layer_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(FrameTimelineEvent.ActualSurfaceFrameStartWire.LAYER_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (@intFromEnum(self.present_type) != 0) {
                res += gremlin.sizes.sizeWireNumber(FrameTimelineEvent.ActualSurfaceFrameStartWire.PRESENT_TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.present_type));
            }
            if (self.on_time_finish != false) {
                res += gremlin.sizes.sizeWireNumber(FrameTimelineEvent.ActualSurfaceFrameStartWire.ON_TIME_FINISH_WIRE) + gremlin.sizes.sizeBool(self.on_time_finish);
            }
            if (self.gpu_composition != false) {
                res += gremlin.sizes.sizeWireNumber(FrameTimelineEvent.ActualSurfaceFrameStartWire.GPU_COMPOSITION_WIRE) + gremlin.sizes.sizeBool(self.gpu_composition);
            }
            if (self.jank_type != 0) {
                res += gremlin.sizes.sizeWireNumber(FrameTimelineEvent.ActualSurfaceFrameStartWire.JANK_TYPE_WIRE) + gremlin.sizes.sizeI32(self.jank_type);
            }
            if (@intFromEnum(self.prediction_type) != 0) {
                res += gremlin.sizes.sizeWireNumber(FrameTimelineEvent.ActualSurfaceFrameStartWire.PREDICTION_TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.prediction_type));
            }
            if (self.is_buffer != false) {
                res += gremlin.sizes.sizeWireNumber(FrameTimelineEvent.ActualSurfaceFrameStartWire.IS_BUFFER_WIRE) + gremlin.sizes.sizeBool(self.is_buffer);
            }
            if (@intFromEnum(self.jank_severity_type) != 0) {
                res += gremlin.sizes.sizeWireNumber(FrameTimelineEvent.ActualSurfaceFrameStartWire.JANK_SEVERITY_TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.jank_severity_type));
            }
            if (self.present_delay_millis != 0.0) {
                res += gremlin.sizes.sizeWireNumber(FrameTimelineEvent.ActualSurfaceFrameStartWire.PRESENT_DELAY_MILLIS_WIRE) + gremlin.sizes.sizeFloat(self.present_delay_millis);
            }
            if (self.vsync_resynced_jitter_millis != 0.0) {
                res += gremlin.sizes.sizeWireNumber(FrameTimelineEvent.ActualSurfaceFrameStartWire.VSYNC_RESYNCED_JITTER_MILLIS_WIRE) + gremlin.sizes.sizeFloat(self.vsync_resynced_jitter_millis);
            }
            if (self.jank_severity_score != 0.0) {
                res += gremlin.sizes.sizeWireNumber(FrameTimelineEvent.ActualSurfaceFrameStartWire.JANK_SEVERITY_SCORE_WIRE) + gremlin.sizes.sizeFloat(self.jank_severity_score);
            }
            if (self.jank_type_experimental != 0) {
                res += gremlin.sizes.sizeWireNumber(FrameTimelineEvent.ActualSurfaceFrameStartWire.JANK_TYPE_EXPERIMENTAL_WIRE) + gremlin.sizes.sizeI32(self.jank_type_experimental);
            }
            if (@intFromEnum(self.present_type_experimental) != 0) {
                res += gremlin.sizes.sizeWireNumber(FrameTimelineEvent.ActualSurfaceFrameStartWire.PRESENT_TYPE_EXPERIMENTAL_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.present_type_experimental));
            }
            return res;
        }
        pub fn encode(self: *const FrameTimelineEvent.ActualSurfaceFrameStart, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const FrameTimelineEvent.ActualSurfaceFrameStart, target: *gremlin.Writer) void {
            if (self.cookie != 0) {
                target.appendInt64(FrameTimelineEvent.ActualSurfaceFrameStartWire.COOKIE_WIRE, self.cookie);
            }
            if (self.token != 0) {
                target.appendInt64(FrameTimelineEvent.ActualSurfaceFrameStartWire.TOKEN_WIRE, self.token);
            }
            if (self.display_frame_token != 0) {
                target.appendInt64(FrameTimelineEvent.ActualSurfaceFrameStartWire.DISPLAY_FRAME_TOKEN_WIRE, self.display_frame_token);
            }
            if (self.pid != 0) {
                target.appendInt32(FrameTimelineEvent.ActualSurfaceFrameStartWire.PID_WIRE, self.pid);
            }
            if (self.layer_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(FrameTimelineEvent.ActualSurfaceFrameStartWire.LAYER_NAME_WIRE, v);
                }
            }
            if (@intFromEnum(self.present_type) != 0) {
                target.appendInt32(FrameTimelineEvent.ActualSurfaceFrameStartWire.PRESENT_TYPE_WIRE, @intFromEnum(self.present_type));
            }
            if (self.on_time_finish != false) {
                target.appendBool(FrameTimelineEvent.ActualSurfaceFrameStartWire.ON_TIME_FINISH_WIRE, self.on_time_finish);
            }
            if (self.gpu_composition != false) {
                target.appendBool(FrameTimelineEvent.ActualSurfaceFrameStartWire.GPU_COMPOSITION_WIRE, self.gpu_composition);
            }
            if (self.jank_type != 0) {
                target.appendInt32(FrameTimelineEvent.ActualSurfaceFrameStartWire.JANK_TYPE_WIRE, self.jank_type);
            }
            if (@intFromEnum(self.prediction_type) != 0) {
                target.appendInt32(FrameTimelineEvent.ActualSurfaceFrameStartWire.PREDICTION_TYPE_WIRE, @intFromEnum(self.prediction_type));
            }
            if (self.is_buffer != false) {
                target.appendBool(FrameTimelineEvent.ActualSurfaceFrameStartWire.IS_BUFFER_WIRE, self.is_buffer);
            }
            if (@intFromEnum(self.jank_severity_type) != 0) {
                target.appendInt32(FrameTimelineEvent.ActualSurfaceFrameStartWire.JANK_SEVERITY_TYPE_WIRE, @intFromEnum(self.jank_severity_type));
            }
            if (self.present_delay_millis != 0.0) {
                target.appendFloat32(FrameTimelineEvent.ActualSurfaceFrameStartWire.PRESENT_DELAY_MILLIS_WIRE, self.present_delay_millis);
            }
            if (self.vsync_resynced_jitter_millis != 0.0) {
                target.appendFloat32(FrameTimelineEvent.ActualSurfaceFrameStartWire.VSYNC_RESYNCED_JITTER_MILLIS_WIRE, self.vsync_resynced_jitter_millis);
            }
            if (self.jank_severity_score != 0.0) {
                target.appendFloat32(FrameTimelineEvent.ActualSurfaceFrameStartWire.JANK_SEVERITY_SCORE_WIRE, self.jank_severity_score);
            }
            if (self.jank_type_experimental != 0) {
                target.appendInt32(FrameTimelineEvent.ActualSurfaceFrameStartWire.JANK_TYPE_EXPERIMENTAL_WIRE, self.jank_type_experimental);
            }
            if (@intFromEnum(self.present_type_experimental) != 0) {
                target.appendInt32(FrameTimelineEvent.ActualSurfaceFrameStartWire.PRESENT_TYPE_EXPERIMENTAL_WIRE, @intFromEnum(self.present_type_experimental));
            }
        }
    };
    pub const ActualSurfaceFrameStartReader = struct {
        buf: gremlin.Reader,
        _cookie: i64 = 0,
        _token: i64 = 0,
        _display_frame_token: i64 = 0,
        _pid: i32 = 0,
        _layer_name: ?[]const u8 = null,
        _present_type: FrameTimelineEvent.PresentType = @enumFromInt(0),
        _on_time_finish: bool = false,
        _gpu_composition: bool = false,
        _jank_type: i32 = 0,
        _prediction_type: FrameTimelineEvent.PredictionType = @enumFromInt(0),
        _is_buffer: bool = false,
        _jank_severity_type: FrameTimelineEvent.JankSeverityType = @enumFromInt(0),
        _present_delay_millis: f32 = 0.0,
        _vsync_resynced_jitter_millis: f32 = 0.0,
        _jank_severity_score: f32 = 0.0,
        _jank_type_experimental: i32 = 0,
        _present_type_experimental: FrameTimelineEvent.PresentType = @enumFromInt(0),
        pub fn init(src: []const u8) gremlin.Error!FrameTimelineEvent.ActualSurfaceFrameStartReader {
            const buf = gremlin.Reader.init(src);
            var res = FrameTimelineEvent.ActualSurfaceFrameStartReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    FrameTimelineEvent.ActualSurfaceFrameStartWire.COOKIE_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._cookie = result.value;
                    },
                    FrameTimelineEvent.ActualSurfaceFrameStartWire.TOKEN_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._token = result.value;
                    },
                    FrameTimelineEvent.ActualSurfaceFrameStartWire.DISPLAY_FRAME_TOKEN_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._display_frame_token = result.value;
                    },
                    FrameTimelineEvent.ActualSurfaceFrameStartWire.PID_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._pid = result.value;
                    },
                    FrameTimelineEvent.ActualSurfaceFrameStartWire.LAYER_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._layer_name = result.value;
                    },
                    FrameTimelineEvent.ActualSurfaceFrameStartWire.PRESENT_TYPE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._present_type = @enumFromInt(result.value);
                    },
                    FrameTimelineEvent.ActualSurfaceFrameStartWire.ON_TIME_FINISH_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._on_time_finish = result.value;
                    },
                    FrameTimelineEvent.ActualSurfaceFrameStartWire.GPU_COMPOSITION_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._gpu_composition = result.value;
                    },
                    FrameTimelineEvent.ActualSurfaceFrameStartWire.JANK_TYPE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._jank_type = result.value;
                    },
                    FrameTimelineEvent.ActualSurfaceFrameStartWire.PREDICTION_TYPE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._prediction_type = @enumFromInt(result.value);
                    },
                    FrameTimelineEvent.ActualSurfaceFrameStartWire.IS_BUFFER_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._is_buffer = result.value;
                    },
                    FrameTimelineEvent.ActualSurfaceFrameStartWire.JANK_SEVERITY_TYPE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._jank_severity_type = @enumFromInt(result.value);
                    },
                    FrameTimelineEvent.ActualSurfaceFrameStartWire.PRESENT_DELAY_MILLIS_WIRE => {
                        const result = try buf.readFloat32(offset);
                        offset += result.size;
                        res._present_delay_millis = result.value;
                    },
                    FrameTimelineEvent.ActualSurfaceFrameStartWire.VSYNC_RESYNCED_JITTER_MILLIS_WIRE => {
                        const result = try buf.readFloat32(offset);
                        offset += result.size;
                        res._vsync_resynced_jitter_millis = result.value;
                    },
                    FrameTimelineEvent.ActualSurfaceFrameStartWire.JANK_SEVERITY_SCORE_WIRE => {
                        const result = try buf.readFloat32(offset);
                        offset += result.size;
                        res._jank_severity_score = result.value;
                    },
                    FrameTimelineEvent.ActualSurfaceFrameStartWire.JANK_TYPE_EXPERIMENTAL_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._jank_type_experimental = result.value;
                    },
                    FrameTimelineEvent.ActualSurfaceFrameStartWire.PRESENT_TYPE_EXPERIMENTAL_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._present_type_experimental = @enumFromInt(result.value);
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getCookie(self: *const FrameTimelineEvent.ActualSurfaceFrameStartReader) i64 {
            return self._cookie;
        }
        pub inline fn getToken(self: *const FrameTimelineEvent.ActualSurfaceFrameStartReader) i64 {
            return self._token;
        }
        pub inline fn getDisplayFrameToken(self: *const FrameTimelineEvent.ActualSurfaceFrameStartReader) i64 {
            return self._display_frame_token;
        }
        pub inline fn getPid(self: *const FrameTimelineEvent.ActualSurfaceFrameStartReader) i32 {
            return self._pid;
        }
        pub inline fn getLayerName(self: *const FrameTimelineEvent.ActualSurfaceFrameStartReader) []const u8 {
            return self._layer_name orelse &[_]u8{};
        }
        pub inline fn getPresentType(self: *const FrameTimelineEvent.ActualSurfaceFrameStartReader) FrameTimelineEvent.PresentType {
            return self._present_type;
        }
        pub inline fn getOnTimeFinish(self: *const FrameTimelineEvent.ActualSurfaceFrameStartReader) bool {
            return self._on_time_finish;
        }
        pub inline fn getGpuComposition(self: *const FrameTimelineEvent.ActualSurfaceFrameStartReader) bool {
            return self._gpu_composition;
        }
        pub inline fn getJankType(self: *const FrameTimelineEvent.ActualSurfaceFrameStartReader) i32 {
            return self._jank_type;
        }
        pub inline fn getPredictionType(self: *const FrameTimelineEvent.ActualSurfaceFrameStartReader) FrameTimelineEvent.PredictionType {
            return self._prediction_type;
        }
        pub inline fn getIsBuffer(self: *const FrameTimelineEvent.ActualSurfaceFrameStartReader) bool {
            return self._is_buffer;
        }
        pub inline fn getJankSeverityType(self: *const FrameTimelineEvent.ActualSurfaceFrameStartReader) FrameTimelineEvent.JankSeverityType {
            return self._jank_severity_type;
        }
        pub inline fn getPresentDelayMillis(self: *const FrameTimelineEvent.ActualSurfaceFrameStartReader) f32 {
            return self._present_delay_millis;
        }
        pub inline fn getVsyncResyncedJitterMillis(self: *const FrameTimelineEvent.ActualSurfaceFrameStartReader) f32 {
            return self._vsync_resynced_jitter_millis;
        }
        pub inline fn getJankSeverityScore(self: *const FrameTimelineEvent.ActualSurfaceFrameStartReader) f32 {
            return self._jank_severity_score;
        }
        pub inline fn getJankTypeExperimental(self: *const FrameTimelineEvent.ActualSurfaceFrameStartReader) i32 {
            return self._jank_type_experimental;
        }
        pub inline fn getPresentTypeExperimental(self: *const FrameTimelineEvent.ActualSurfaceFrameStartReader) FrameTimelineEvent.PresentType {
            return self._present_type_experimental;
        }
    };
    const ExpectedDisplayFrameStartWire = struct {
        const COOKIE_WIRE: gremlin.ProtoWireNumber = 1;
        const TOKEN_WIRE: gremlin.ProtoWireNumber = 2;
        const PID_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const ExpectedDisplayFrameStart = struct {
        // fields
        cookie: i64 = 0,
        token: i64 = 0,
        pid: i32 = 0,
        pub fn calcProtobufSize(self: *const FrameTimelineEvent.ExpectedDisplayFrameStart) usize {
            var res: usize = 0;
            if (self.cookie != 0) {
                res += gremlin.sizes.sizeWireNumber(FrameTimelineEvent.ExpectedDisplayFrameStartWire.COOKIE_WIRE) + gremlin.sizes.sizeI64(self.cookie);
            }
            if (self.token != 0) {
                res += gremlin.sizes.sizeWireNumber(FrameTimelineEvent.ExpectedDisplayFrameStartWire.TOKEN_WIRE) + gremlin.sizes.sizeI64(self.token);
            }
            if (self.pid != 0) {
                res += gremlin.sizes.sizeWireNumber(FrameTimelineEvent.ExpectedDisplayFrameStartWire.PID_WIRE) + gremlin.sizes.sizeI32(self.pid);
            }
            return res;
        }
        pub fn encode(self: *const FrameTimelineEvent.ExpectedDisplayFrameStart, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const FrameTimelineEvent.ExpectedDisplayFrameStart, target: *gremlin.Writer) void {
            if (self.cookie != 0) {
                target.appendInt64(FrameTimelineEvent.ExpectedDisplayFrameStartWire.COOKIE_WIRE, self.cookie);
            }
            if (self.token != 0) {
                target.appendInt64(FrameTimelineEvent.ExpectedDisplayFrameStartWire.TOKEN_WIRE, self.token);
            }
            if (self.pid != 0) {
                target.appendInt32(FrameTimelineEvent.ExpectedDisplayFrameStartWire.PID_WIRE, self.pid);
            }
        }
    };
    pub const ExpectedDisplayFrameStartReader = struct {
        buf: gremlin.Reader,
        _cookie: i64 = 0,
        _token: i64 = 0,
        _pid: i32 = 0,
        pub fn init(src: []const u8) gremlin.Error!FrameTimelineEvent.ExpectedDisplayFrameStartReader {
            const buf = gremlin.Reader.init(src);
            var res = FrameTimelineEvent.ExpectedDisplayFrameStartReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    FrameTimelineEvent.ExpectedDisplayFrameStartWire.COOKIE_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._cookie = result.value;
                    },
                    FrameTimelineEvent.ExpectedDisplayFrameStartWire.TOKEN_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._token = result.value;
                    },
                    FrameTimelineEvent.ExpectedDisplayFrameStartWire.PID_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._pid = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getCookie(self: *const FrameTimelineEvent.ExpectedDisplayFrameStartReader) i64 {
            return self._cookie;
        }
        pub inline fn getToken(self: *const FrameTimelineEvent.ExpectedDisplayFrameStartReader) i64 {
            return self._token;
        }
        pub inline fn getPid(self: *const FrameTimelineEvent.ExpectedDisplayFrameStartReader) i32 {
            return self._pid;
        }
    };
    const ActualDisplayFrameStartWire = struct {
        const COOKIE_WIRE: gremlin.ProtoWireNumber = 1;
        const TOKEN_WIRE: gremlin.ProtoWireNumber = 2;
        const PID_WIRE: gremlin.ProtoWireNumber = 3;
        const PRESENT_TYPE_WIRE: gremlin.ProtoWireNumber = 4;
        const ON_TIME_FINISH_WIRE: gremlin.ProtoWireNumber = 5;
        const GPU_COMPOSITION_WIRE: gremlin.ProtoWireNumber = 6;
        const JANK_TYPE_WIRE: gremlin.ProtoWireNumber = 7;
        const PREDICTION_TYPE_WIRE: gremlin.ProtoWireNumber = 8;
        const JANK_SEVERITY_TYPE_WIRE: gremlin.ProtoWireNumber = 9;
        const PRESENT_DELAY_MILLIS_WIRE: gremlin.ProtoWireNumber = 10;
        const JANK_SEVERITY_SCORE_WIRE: gremlin.ProtoWireNumber = 11;
        const JANK_TYPE_EXPERIMENTAL_WIRE: gremlin.ProtoWireNumber = 12;
        const PRESENT_TYPE_EXPERIMENTAL_WIRE: gremlin.ProtoWireNumber = 13;
    };
    pub const ActualDisplayFrameStart = struct {
        // fields
        cookie: i64 = 0,
        token: i64 = 0,
        pid: i32 = 0,
        present_type: FrameTimelineEvent.PresentType = @enumFromInt(0),
        on_time_finish: bool = false,
        gpu_composition: bool = false,
        jank_type: i32 = 0,
        prediction_type: FrameTimelineEvent.PredictionType = @enumFromInt(0),
        jank_severity_type: FrameTimelineEvent.JankSeverityType = @enumFromInt(0),
        present_delay_millis: f32 = 0.0,
        jank_severity_score: f32 = 0.0,
        jank_type_experimental: i32 = 0,
        present_type_experimental: FrameTimelineEvent.PresentType = @enumFromInt(0),
        pub fn calcProtobufSize(self: *const FrameTimelineEvent.ActualDisplayFrameStart) usize {
            var res: usize = 0;
            if (self.cookie != 0) {
                res += gremlin.sizes.sizeWireNumber(FrameTimelineEvent.ActualDisplayFrameStartWire.COOKIE_WIRE) + gremlin.sizes.sizeI64(self.cookie);
            }
            if (self.token != 0) {
                res += gremlin.sizes.sizeWireNumber(FrameTimelineEvent.ActualDisplayFrameStartWire.TOKEN_WIRE) + gremlin.sizes.sizeI64(self.token);
            }
            if (self.pid != 0) {
                res += gremlin.sizes.sizeWireNumber(FrameTimelineEvent.ActualDisplayFrameStartWire.PID_WIRE) + gremlin.sizes.sizeI32(self.pid);
            }
            if (@intFromEnum(self.present_type) != 0) {
                res += gremlin.sizes.sizeWireNumber(FrameTimelineEvent.ActualDisplayFrameStartWire.PRESENT_TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.present_type));
            }
            if (self.on_time_finish != false) {
                res += gremlin.sizes.sizeWireNumber(FrameTimelineEvent.ActualDisplayFrameStartWire.ON_TIME_FINISH_WIRE) + gremlin.sizes.sizeBool(self.on_time_finish);
            }
            if (self.gpu_composition != false) {
                res += gremlin.sizes.sizeWireNumber(FrameTimelineEvent.ActualDisplayFrameStartWire.GPU_COMPOSITION_WIRE) + gremlin.sizes.sizeBool(self.gpu_composition);
            }
            if (self.jank_type != 0) {
                res += gremlin.sizes.sizeWireNumber(FrameTimelineEvent.ActualDisplayFrameStartWire.JANK_TYPE_WIRE) + gremlin.sizes.sizeI32(self.jank_type);
            }
            if (@intFromEnum(self.prediction_type) != 0) {
                res += gremlin.sizes.sizeWireNumber(FrameTimelineEvent.ActualDisplayFrameStartWire.PREDICTION_TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.prediction_type));
            }
            if (@intFromEnum(self.jank_severity_type) != 0) {
                res += gremlin.sizes.sizeWireNumber(FrameTimelineEvent.ActualDisplayFrameStartWire.JANK_SEVERITY_TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.jank_severity_type));
            }
            if (self.present_delay_millis != 0.0) {
                res += gremlin.sizes.sizeWireNumber(FrameTimelineEvent.ActualDisplayFrameStartWire.PRESENT_DELAY_MILLIS_WIRE) + gremlin.sizes.sizeFloat(self.present_delay_millis);
            }
            if (self.jank_severity_score != 0.0) {
                res += gremlin.sizes.sizeWireNumber(FrameTimelineEvent.ActualDisplayFrameStartWire.JANK_SEVERITY_SCORE_WIRE) + gremlin.sizes.sizeFloat(self.jank_severity_score);
            }
            if (self.jank_type_experimental != 0) {
                res += gremlin.sizes.sizeWireNumber(FrameTimelineEvent.ActualDisplayFrameStartWire.JANK_TYPE_EXPERIMENTAL_WIRE) + gremlin.sizes.sizeI32(self.jank_type_experimental);
            }
            if (@intFromEnum(self.present_type_experimental) != 0) {
                res += gremlin.sizes.sizeWireNumber(FrameTimelineEvent.ActualDisplayFrameStartWire.PRESENT_TYPE_EXPERIMENTAL_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.present_type_experimental));
            }
            return res;
        }
        pub fn encode(self: *const FrameTimelineEvent.ActualDisplayFrameStart, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const FrameTimelineEvent.ActualDisplayFrameStart, target: *gremlin.Writer) void {
            if (self.cookie != 0) {
                target.appendInt64(FrameTimelineEvent.ActualDisplayFrameStartWire.COOKIE_WIRE, self.cookie);
            }
            if (self.token != 0) {
                target.appendInt64(FrameTimelineEvent.ActualDisplayFrameStartWire.TOKEN_WIRE, self.token);
            }
            if (self.pid != 0) {
                target.appendInt32(FrameTimelineEvent.ActualDisplayFrameStartWire.PID_WIRE, self.pid);
            }
            if (@intFromEnum(self.present_type) != 0) {
                target.appendInt32(FrameTimelineEvent.ActualDisplayFrameStartWire.PRESENT_TYPE_WIRE, @intFromEnum(self.present_type));
            }
            if (self.on_time_finish != false) {
                target.appendBool(FrameTimelineEvent.ActualDisplayFrameStartWire.ON_TIME_FINISH_WIRE, self.on_time_finish);
            }
            if (self.gpu_composition != false) {
                target.appendBool(FrameTimelineEvent.ActualDisplayFrameStartWire.GPU_COMPOSITION_WIRE, self.gpu_composition);
            }
            if (self.jank_type != 0) {
                target.appendInt32(FrameTimelineEvent.ActualDisplayFrameStartWire.JANK_TYPE_WIRE, self.jank_type);
            }
            if (@intFromEnum(self.prediction_type) != 0) {
                target.appendInt32(FrameTimelineEvent.ActualDisplayFrameStartWire.PREDICTION_TYPE_WIRE, @intFromEnum(self.prediction_type));
            }
            if (@intFromEnum(self.jank_severity_type) != 0) {
                target.appendInt32(FrameTimelineEvent.ActualDisplayFrameStartWire.JANK_SEVERITY_TYPE_WIRE, @intFromEnum(self.jank_severity_type));
            }
            if (self.present_delay_millis != 0.0) {
                target.appendFloat32(FrameTimelineEvent.ActualDisplayFrameStartWire.PRESENT_DELAY_MILLIS_WIRE, self.present_delay_millis);
            }
            if (self.jank_severity_score != 0.0) {
                target.appendFloat32(FrameTimelineEvent.ActualDisplayFrameStartWire.JANK_SEVERITY_SCORE_WIRE, self.jank_severity_score);
            }
            if (self.jank_type_experimental != 0) {
                target.appendInt32(FrameTimelineEvent.ActualDisplayFrameStartWire.JANK_TYPE_EXPERIMENTAL_WIRE, self.jank_type_experimental);
            }
            if (@intFromEnum(self.present_type_experimental) != 0) {
                target.appendInt32(FrameTimelineEvent.ActualDisplayFrameStartWire.PRESENT_TYPE_EXPERIMENTAL_WIRE, @intFromEnum(self.present_type_experimental));
            }
        }
    };
    pub const ActualDisplayFrameStartReader = struct {
        buf: gremlin.Reader,
        _cookie: i64 = 0,
        _token: i64 = 0,
        _pid: i32 = 0,
        _present_type: FrameTimelineEvent.PresentType = @enumFromInt(0),
        _on_time_finish: bool = false,
        _gpu_composition: bool = false,
        _jank_type: i32 = 0,
        _prediction_type: FrameTimelineEvent.PredictionType = @enumFromInt(0),
        _jank_severity_type: FrameTimelineEvent.JankSeverityType = @enumFromInt(0),
        _present_delay_millis: f32 = 0.0,
        _jank_severity_score: f32 = 0.0,
        _jank_type_experimental: i32 = 0,
        _present_type_experimental: FrameTimelineEvent.PresentType = @enumFromInt(0),
        pub fn init(src: []const u8) gremlin.Error!FrameTimelineEvent.ActualDisplayFrameStartReader {
            const buf = gremlin.Reader.init(src);
            var res = FrameTimelineEvent.ActualDisplayFrameStartReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    FrameTimelineEvent.ActualDisplayFrameStartWire.COOKIE_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._cookie = result.value;
                    },
                    FrameTimelineEvent.ActualDisplayFrameStartWire.TOKEN_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._token = result.value;
                    },
                    FrameTimelineEvent.ActualDisplayFrameStartWire.PID_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._pid = result.value;
                    },
                    FrameTimelineEvent.ActualDisplayFrameStartWire.PRESENT_TYPE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._present_type = @enumFromInt(result.value);
                    },
                    FrameTimelineEvent.ActualDisplayFrameStartWire.ON_TIME_FINISH_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._on_time_finish = result.value;
                    },
                    FrameTimelineEvent.ActualDisplayFrameStartWire.GPU_COMPOSITION_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._gpu_composition = result.value;
                    },
                    FrameTimelineEvent.ActualDisplayFrameStartWire.JANK_TYPE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._jank_type = result.value;
                    },
                    FrameTimelineEvent.ActualDisplayFrameStartWire.PREDICTION_TYPE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._prediction_type = @enumFromInt(result.value);
                    },
                    FrameTimelineEvent.ActualDisplayFrameStartWire.JANK_SEVERITY_TYPE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._jank_severity_type = @enumFromInt(result.value);
                    },
                    FrameTimelineEvent.ActualDisplayFrameStartWire.PRESENT_DELAY_MILLIS_WIRE => {
                        const result = try buf.readFloat32(offset);
                        offset += result.size;
                        res._present_delay_millis = result.value;
                    },
                    FrameTimelineEvent.ActualDisplayFrameStartWire.JANK_SEVERITY_SCORE_WIRE => {
                        const result = try buf.readFloat32(offset);
                        offset += result.size;
                        res._jank_severity_score = result.value;
                    },
                    FrameTimelineEvent.ActualDisplayFrameStartWire.JANK_TYPE_EXPERIMENTAL_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._jank_type_experimental = result.value;
                    },
                    FrameTimelineEvent.ActualDisplayFrameStartWire.PRESENT_TYPE_EXPERIMENTAL_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._present_type_experimental = @enumFromInt(result.value);
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getCookie(self: *const FrameTimelineEvent.ActualDisplayFrameStartReader) i64 {
            return self._cookie;
        }
        pub inline fn getToken(self: *const FrameTimelineEvent.ActualDisplayFrameStartReader) i64 {
            return self._token;
        }
        pub inline fn getPid(self: *const FrameTimelineEvent.ActualDisplayFrameStartReader) i32 {
            return self._pid;
        }
        pub inline fn getPresentType(self: *const FrameTimelineEvent.ActualDisplayFrameStartReader) FrameTimelineEvent.PresentType {
            return self._present_type;
        }
        pub inline fn getOnTimeFinish(self: *const FrameTimelineEvent.ActualDisplayFrameStartReader) bool {
            return self._on_time_finish;
        }
        pub inline fn getGpuComposition(self: *const FrameTimelineEvent.ActualDisplayFrameStartReader) bool {
            return self._gpu_composition;
        }
        pub inline fn getJankType(self: *const FrameTimelineEvent.ActualDisplayFrameStartReader) i32 {
            return self._jank_type;
        }
        pub inline fn getPredictionType(self: *const FrameTimelineEvent.ActualDisplayFrameStartReader) FrameTimelineEvent.PredictionType {
            return self._prediction_type;
        }
        pub inline fn getJankSeverityType(self: *const FrameTimelineEvent.ActualDisplayFrameStartReader) FrameTimelineEvent.JankSeverityType {
            return self._jank_severity_type;
        }
        pub inline fn getPresentDelayMillis(self: *const FrameTimelineEvent.ActualDisplayFrameStartReader) f32 {
            return self._present_delay_millis;
        }
        pub inline fn getJankSeverityScore(self: *const FrameTimelineEvent.ActualDisplayFrameStartReader) f32 {
            return self._jank_severity_score;
        }
        pub inline fn getJankTypeExperimental(self: *const FrameTimelineEvent.ActualDisplayFrameStartReader) i32 {
            return self._jank_type_experimental;
        }
        pub inline fn getPresentTypeExperimental(self: *const FrameTimelineEvent.ActualDisplayFrameStartReader) FrameTimelineEvent.PresentType {
            return self._present_type_experimental;
        }
    };
    const FrameEndWire = struct {
        const COOKIE_WIRE: gremlin.ProtoWireNumber = 1;
    };
    pub const FrameEnd = struct {
        // fields
        cookie: i64 = 0,
        pub fn calcProtobufSize(self: *const FrameTimelineEvent.FrameEnd) usize {
            var res: usize = 0;
            if (self.cookie != 0) {
                res += gremlin.sizes.sizeWireNumber(FrameTimelineEvent.FrameEndWire.COOKIE_WIRE) + gremlin.sizes.sizeI64(self.cookie);
            }
            return res;
        }
        pub fn encode(self: *const FrameTimelineEvent.FrameEnd, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const FrameTimelineEvent.FrameEnd, target: *gremlin.Writer) void {
            if (self.cookie != 0) {
                target.appendInt64(FrameTimelineEvent.FrameEndWire.COOKIE_WIRE, self.cookie);
            }
        }
    };
    pub const FrameEndReader = struct {
        buf: gremlin.Reader,
        _cookie: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!FrameTimelineEvent.FrameEndReader {
            const buf = gremlin.Reader.init(src);
            var res = FrameTimelineEvent.FrameEndReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    FrameTimelineEvent.FrameEndWire.COOKIE_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._cookie = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getCookie(self: *const FrameTimelineEvent.FrameEndReader) i64 {
            return self._cookie;
        }
    };
    // fields
    expected_display_frame_start: ?FrameTimelineEvent.ExpectedDisplayFrameStart = null,
    actual_display_frame_start: ?FrameTimelineEvent.ActualDisplayFrameStart = null,
    expected_surface_frame_start: ?FrameTimelineEvent.ExpectedSurfaceFrameStart = null,
    actual_surface_frame_start: ?FrameTimelineEvent.ActualSurfaceFrameStart = null,
    frame_end: ?FrameTimelineEvent.FrameEnd = null,
    pub fn calcProtobufSize(self: *const FrameTimelineEvent) usize {
        var res: usize = 0;
        if (self.expected_display_frame_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FrameTimelineEventWire.EXPECTED_DISPLAY_FRAME_START_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.actual_display_frame_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FrameTimelineEventWire.ACTUAL_DISPLAY_FRAME_START_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.expected_surface_frame_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FrameTimelineEventWire.EXPECTED_SURFACE_FRAME_START_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.actual_surface_frame_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FrameTimelineEventWire.ACTUAL_SURFACE_FRAME_START_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.frame_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FrameTimelineEventWire.FRAME_END_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const FrameTimelineEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const FrameTimelineEvent, target: *gremlin.Writer) void {
        if (self.expected_display_frame_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FrameTimelineEventWire.EXPECTED_DISPLAY_FRAME_START_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.actual_display_frame_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FrameTimelineEventWire.ACTUAL_DISPLAY_FRAME_START_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.expected_surface_frame_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FrameTimelineEventWire.EXPECTED_SURFACE_FRAME_START_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.actual_surface_frame_start) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FrameTimelineEventWire.ACTUAL_SURFACE_FRAME_START_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.frame_end) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FrameTimelineEventWire.FRAME_END_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const FrameTimelineEventReader = struct {
    buf: gremlin.Reader,
    _expected_display_frame_start_buf: ?[]const u8 = null,
    _actual_display_frame_start_buf: ?[]const u8 = null,
    _expected_surface_frame_start_buf: ?[]const u8 = null,
    _actual_surface_frame_start_buf: ?[]const u8 = null,
    _frame_end_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!FrameTimelineEventReader {
        const buf = gremlin.Reader.init(src);
        var res = FrameTimelineEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                FrameTimelineEventWire.EXPECTED_DISPLAY_FRAME_START_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._expected_display_frame_start_buf = result.value;
                },
                FrameTimelineEventWire.ACTUAL_DISPLAY_FRAME_START_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._actual_display_frame_start_buf = result.value;
                },
                FrameTimelineEventWire.EXPECTED_SURFACE_FRAME_START_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._expected_surface_frame_start_buf = result.value;
                },
                FrameTimelineEventWire.ACTUAL_SURFACE_FRAME_START_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._actual_surface_frame_start_buf = result.value;
                },
                FrameTimelineEventWire.FRAME_END_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._frame_end_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getExpectedDisplayFrameStart(self: *const FrameTimelineEventReader) gremlin.Error!FrameTimelineEvent.ExpectedDisplayFrameStartReader {
        if (self._expected_display_frame_start_buf) |buf| {
            return try FrameTimelineEvent.ExpectedDisplayFrameStartReader.init(buf);
        }
        return try FrameTimelineEvent.ExpectedDisplayFrameStartReader.init(&[_]u8{});
    }
    pub fn getActualDisplayFrameStart(self: *const FrameTimelineEventReader) gremlin.Error!FrameTimelineEvent.ActualDisplayFrameStartReader {
        if (self._actual_display_frame_start_buf) |buf| {
            return try FrameTimelineEvent.ActualDisplayFrameStartReader.init(buf);
        }
        return try FrameTimelineEvent.ActualDisplayFrameStartReader.init(&[_]u8{});
    }
    pub fn getExpectedSurfaceFrameStart(self: *const FrameTimelineEventReader) gremlin.Error!FrameTimelineEvent.ExpectedSurfaceFrameStartReader {
        if (self._expected_surface_frame_start_buf) |buf| {
            return try FrameTimelineEvent.ExpectedSurfaceFrameStartReader.init(buf);
        }
        return try FrameTimelineEvent.ExpectedSurfaceFrameStartReader.init(&[_]u8{});
    }
    pub fn getActualSurfaceFrameStart(self: *const FrameTimelineEventReader) gremlin.Error!FrameTimelineEvent.ActualSurfaceFrameStartReader {
        if (self._actual_surface_frame_start_buf) |buf| {
            return try FrameTimelineEvent.ActualSurfaceFrameStartReader.init(buf);
        }
        return try FrameTimelineEvent.ActualSurfaceFrameStartReader.init(&[_]u8{});
    }
    pub fn getFrameEnd(self: *const FrameTimelineEventReader) gremlin.Error!FrameTimelineEvent.FrameEndReader {
        if (self._frame_end_buf) |buf| {
            return try FrameTimelineEvent.FrameEndReader.init(buf);
        }
        return try FrameTimelineEvent.FrameEndReader.init(&[_]u8{});
    }
};
