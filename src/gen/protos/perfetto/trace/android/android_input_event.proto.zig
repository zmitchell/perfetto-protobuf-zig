// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const AndroidMotionEventWire = struct {
    const EVENT_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const EVENT_TIME_NANOS_WIRE: gremlin.ProtoWireNumber = 2;
    const SOURCE_WIRE: gremlin.ProtoWireNumber = 3;
    const ACTION_WIRE: gremlin.ProtoWireNumber = 4;
    const DEVICE_ID_WIRE: gremlin.ProtoWireNumber = 5;
    const DISPLAY_ID_WIRE: gremlin.ProtoWireNumber = 6;
    const CLASSIFICATION_WIRE: gremlin.ProtoWireNumber = 7;
    const FLAGS_WIRE: gremlin.ProtoWireNumber = 8;
    const POINTER_WIRE: gremlin.ProtoWireNumber = 9;
    const ORIGINAL_EVENT_ID_WIRE: gremlin.ProtoWireNumber = 16;
    const DOWN_TIME_NANOS_WIRE: gremlin.ProtoWireNumber = 17;
    const CURSOR_POSITION_X_WIRE: gremlin.ProtoWireNumber = 18;
    const CURSOR_POSITION_Y_WIRE: gremlin.ProtoWireNumber = 19;
    const ACTION_BUTTON_WIRE: gremlin.ProtoWireNumber = 20;
    const BUTTON_STATE_WIRE: gremlin.ProtoWireNumber = 21;
    const META_STATE_WIRE: gremlin.ProtoWireNumber = 22;
    const POLICY_FLAGS_WIRE: gremlin.ProtoWireNumber = 23;
    const PRECISION_X_WIRE: gremlin.ProtoWireNumber = 24;
    const PRECISION_Y_WIRE: gremlin.ProtoWireNumber = 25;
};
pub const AndroidMotionEvent = struct {
    // nested structs
    const PointerWire = struct {
        const AXIS_VALUE_WIRE: gremlin.ProtoWireNumber = 1;
        const POINTER_ID_WIRE: gremlin.ProtoWireNumber = 2;
        const TOOL_TYPE_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const Pointer = struct {
        // nested structs
        const AxisValueWire = struct {
            const AXIS_WIRE: gremlin.ProtoWireNumber = 1;
            const VALUE_WIRE: gremlin.ProtoWireNumber = 2;
        };
        pub const AxisValue = struct {
            // fields
            axis: i32 = 0,
            value: f32 = 0.0,
            pub fn calcProtobufSize(self: *const AndroidMotionEvent.Pointer.AxisValue) usize {
                var res: usize = 0;
                if (self.axis != 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidMotionEvent.Pointer.AxisValueWire.AXIS_WIRE) + gremlin.sizes.sizeI32(self.axis);
                }
                if (self.value != 0.0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidMotionEvent.Pointer.AxisValueWire.VALUE_WIRE) + gremlin.sizes.sizeFloat(self.value);
                }
                return res;
            }
            pub fn encode(self: *const AndroidMotionEvent.Pointer.AxisValue, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const AndroidMotionEvent.Pointer.AxisValue, target: *gremlin.Writer) void {
                if (self.axis != 0) {
                    target.appendInt32(AndroidMotionEvent.Pointer.AxisValueWire.AXIS_WIRE, self.axis);
                }
                if (self.value != 0.0) {
                    target.appendFloat32(AndroidMotionEvent.Pointer.AxisValueWire.VALUE_WIRE, self.value);
                }
            }
        };
        pub const AxisValueReader = struct {
            buf: gremlin.Reader,
            _axis: i32 = 0,
            _value: f32 = 0.0,
            pub fn init(src: []const u8) gremlin.Error!AndroidMotionEvent.Pointer.AxisValueReader {
                const buf = gremlin.Reader.init(src);
                var res = AndroidMotionEvent.Pointer.AxisValueReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        AndroidMotionEvent.Pointer.AxisValueWire.AXIS_WIRE => {
                            const result = try buf.readInt32(offset);
                            offset += result.size;
                            res._axis = result.value;
                        },
                        AndroidMotionEvent.Pointer.AxisValueWire.VALUE_WIRE => {
                            const result = try buf.readFloat32(offset);
                            offset += result.size;
                            res._value = result.value;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub inline fn getAxis(self: *const AndroidMotionEvent.Pointer.AxisValueReader) i32 {
                return self._axis;
            }
            pub inline fn getValue(self: *const AndroidMotionEvent.Pointer.AxisValueReader) f32 {
                return self._value;
            }
        };
        // fields
        axis_value: ?[]const ?AndroidMotionEvent.Pointer.AxisValue = null,
        pointer_id: i32 = 0,
        tool_type: i32 = 0,
        pub fn calcProtobufSize(self: *const AndroidMotionEvent.Pointer) usize {
            var res: usize = 0;
            if (self.axis_value) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidMotionEvent.PointerWire.AXIS_VALUE_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.pointer_id != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidMotionEvent.PointerWire.POINTER_ID_WIRE) + gremlin.sizes.sizeI32(self.pointer_id);
            }
            if (self.tool_type != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidMotionEvent.PointerWire.TOOL_TYPE_WIRE) + gremlin.sizes.sizeI32(self.tool_type);
            }
            return res;
        }
        pub fn encode(self: *const AndroidMotionEvent.Pointer, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidMotionEvent.Pointer, target: *gremlin.Writer) void {
            if (self.axis_value) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidMotionEvent.PointerWire.AXIS_VALUE_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidMotionEvent.PointerWire.AXIS_VALUE_WIRE, 0);
                    }
                }
            }
            if (self.pointer_id != 0) {
                target.appendInt32(AndroidMotionEvent.PointerWire.POINTER_ID_WIRE, self.pointer_id);
            }
            if (self.tool_type != 0) {
                target.appendInt32(AndroidMotionEvent.PointerWire.TOOL_TYPE_WIRE, self.tool_type);
            }
        }
    };
    pub const PointerReader = struct {
        buf: gremlin.Reader,
        _axis_value_offset: ?usize = null,
        _axis_value_last_offset: ?usize = null,
        _axis_value_cnt: usize = 0,
        _pointer_id: i32 = 0,
        _tool_type: i32 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidMotionEvent.PointerReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidMotionEvent.PointerReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidMotionEvent.PointerWire.AXIS_VALUE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._axis_value_offset == null) {
                            res._axis_value_offset = offset - result.size;
                        }
                        res._axis_value_last_offset = offset;
                        res._axis_value_cnt += 1;
                    },
                    AndroidMotionEvent.PointerWire.POINTER_ID_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._pointer_id = result.value;
                    },
                    AndroidMotionEvent.PointerWire.TOOL_TYPE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._tool_type = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn axisValueCount(self: *const AndroidMotionEvent.PointerReader) usize {
            return self._axis_value_cnt;
        }
        pub fn axisValueNext(self: *AndroidMotionEvent.PointerReader) ?AndroidMotionEvent.Pointer.AxisValueReader {
            if (self._axis_value_offset == null) return null;
            const current_offset = self._axis_value_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidMotionEvent.Pointer.AxisValueReader.init(result.value) catch return null;
            if (self._axis_value_last_offset != null and current_offset >= self._axis_value_last_offset.?) {
                self._axis_value_offset = null;
                return msg;
            }
            if (self._axis_value_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._axis_value_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidMotionEvent.PointerWire.AXIS_VALUE_WIRE) {
                    self._axis_value_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._axis_value_offset = null;
            return msg;
        }
        pub inline fn getPointerId(self: *const AndroidMotionEvent.PointerReader) i32 {
            return self._pointer_id;
        }
        pub inline fn getToolType(self: *const AndroidMotionEvent.PointerReader) i32 {
            return self._tool_type;
        }
    };
    // fields
    event_id: u32 = 0,
    event_time_nanos: i64 = 0,
    source: u32 = 0,
    action: i32 = 0,
    device_id: i32 = 0,
    display_id: i32 = 0,
    classification: i32 = 0,
    flags: u32 = 0,
    pointer: ?[]const ?AndroidMotionEvent.Pointer = null,
    original_event_id: ?[]const u32 = null,
    down_time_nanos: i64 = 0,
    cursor_position_x: f32 = 0.0,
    cursor_position_y: f32 = 0.0,
    action_button: i32 = 0,
    button_state: u32 = 0,
    meta_state: u32 = 0,
    policy_flags: u32 = 0,
    precision_x: f32 = 0.0,
    precision_y: f32 = 0.0,
    pub fn calcProtobufSize(self: *const AndroidMotionEvent) usize {
        var res: usize = 0;
        if (self.event_id != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidMotionEventWire.EVENT_ID_WIRE) + gremlin.sizes.sizeFixed32(self.event_id);
        }
        if (self.event_time_nanos != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidMotionEventWire.EVENT_TIME_NANOS_WIRE) + gremlin.sizes.sizeI64(self.event_time_nanos);
        }
        if (self.source != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidMotionEventWire.SOURCE_WIRE) + gremlin.sizes.sizeU32(self.source);
        }
        if (self.action != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidMotionEventWire.ACTION_WIRE) + gremlin.sizes.sizeI32(self.action);
        }
        if (self.device_id != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidMotionEventWire.DEVICE_ID_WIRE) + gremlin.sizes.sizeI32(self.device_id);
        }
        if (self.display_id != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidMotionEventWire.DISPLAY_ID_WIRE) + gremlin.sizes.sizeSI32(self.display_id);
        }
        if (self.classification != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidMotionEventWire.CLASSIFICATION_WIRE) + gremlin.sizes.sizeI32(self.classification);
        }
        if (self.flags != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidMotionEventWire.FLAGS_WIRE) + gremlin.sizes.sizeU32(self.flags);
        }
        if (self.pointer) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidMotionEventWire.POINTER_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.original_event_id) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(AndroidMotionEventWire.ORIGINAL_EVENT_ID_WIRE) + gremlin.sizes.sizeFixed32(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeFixed32(v);
                }
                res += gremlin.sizes.sizeWireNumber(AndroidMotionEventWire.ORIGINAL_EVENT_ID_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.down_time_nanos != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidMotionEventWire.DOWN_TIME_NANOS_WIRE) + gremlin.sizes.sizeI64(self.down_time_nanos);
        }
        if (self.cursor_position_x != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidMotionEventWire.CURSOR_POSITION_X_WIRE) + gremlin.sizes.sizeFloat(self.cursor_position_x);
        }
        if (self.cursor_position_y != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidMotionEventWire.CURSOR_POSITION_Y_WIRE) + gremlin.sizes.sizeFloat(self.cursor_position_y);
        }
        if (self.action_button != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidMotionEventWire.ACTION_BUTTON_WIRE) + gremlin.sizes.sizeI32(self.action_button);
        }
        if (self.button_state != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidMotionEventWire.BUTTON_STATE_WIRE) + gremlin.sizes.sizeU32(self.button_state);
        }
        if (self.meta_state != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidMotionEventWire.META_STATE_WIRE) + gremlin.sizes.sizeU32(self.meta_state);
        }
        if (self.policy_flags != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidMotionEventWire.POLICY_FLAGS_WIRE) + gremlin.sizes.sizeU32(self.policy_flags);
        }
        if (self.precision_x != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidMotionEventWire.PRECISION_X_WIRE) + gremlin.sizes.sizeFloat(self.precision_x);
        }
        if (self.precision_y != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidMotionEventWire.PRECISION_Y_WIRE) + gremlin.sizes.sizeFloat(self.precision_y);
        }
        return res;
    }
    pub fn encode(self: *const AndroidMotionEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidMotionEvent, target: *gremlin.Writer) void {
        if (self.event_id != 0) {
            target.appendFixed32(AndroidMotionEventWire.EVENT_ID_WIRE, self.event_id);
        }
        if (self.event_time_nanos != 0) {
            target.appendInt64(AndroidMotionEventWire.EVENT_TIME_NANOS_WIRE, self.event_time_nanos);
        }
        if (self.source != 0) {
            target.appendUint32(AndroidMotionEventWire.SOURCE_WIRE, self.source);
        }
        if (self.action != 0) {
            target.appendInt32(AndroidMotionEventWire.ACTION_WIRE, self.action);
        }
        if (self.device_id != 0) {
            target.appendInt32(AndroidMotionEventWire.DEVICE_ID_WIRE, self.device_id);
        }
        if (self.display_id != 0) {
            target.appendSint32(AndroidMotionEventWire.DISPLAY_ID_WIRE, self.display_id);
        }
        if (self.classification != 0) {
            target.appendInt32(AndroidMotionEventWire.CLASSIFICATION_WIRE, self.classification);
        }
        if (self.flags != 0) {
            target.appendUint32(AndroidMotionEventWire.FLAGS_WIRE, self.flags);
        }
        if (self.pointer) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidMotionEventWire.POINTER_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidMotionEventWire.POINTER_WIRE, 0);
                }
            }
        }
        if (self.original_event_id) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendFixed32(AndroidMotionEventWire.ORIGINAL_EVENT_ID_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeFixed32(v);
                }
                target.appendBytesTag(AndroidMotionEventWire.ORIGINAL_EVENT_ID_WIRE, packed_size);
                for (arr) |v| {
                    target.appendFixed32WithoutTag(v);
                }
            }
        }
        if (self.down_time_nanos != 0) {
            target.appendInt64(AndroidMotionEventWire.DOWN_TIME_NANOS_WIRE, self.down_time_nanos);
        }
        if (self.cursor_position_x != 0.0) {
            target.appendFloat32(AndroidMotionEventWire.CURSOR_POSITION_X_WIRE, self.cursor_position_x);
        }
        if (self.cursor_position_y != 0.0) {
            target.appendFloat32(AndroidMotionEventWire.CURSOR_POSITION_Y_WIRE, self.cursor_position_y);
        }
        if (self.action_button != 0) {
            target.appendInt32(AndroidMotionEventWire.ACTION_BUTTON_WIRE, self.action_button);
        }
        if (self.button_state != 0) {
            target.appendUint32(AndroidMotionEventWire.BUTTON_STATE_WIRE, self.button_state);
        }
        if (self.meta_state != 0) {
            target.appendUint32(AndroidMotionEventWire.META_STATE_WIRE, self.meta_state);
        }
        if (self.policy_flags != 0) {
            target.appendUint32(AndroidMotionEventWire.POLICY_FLAGS_WIRE, self.policy_flags);
        }
        if (self.precision_x != 0.0) {
            target.appendFloat32(AndroidMotionEventWire.PRECISION_X_WIRE, self.precision_x);
        }
        if (self.precision_y != 0.0) {
            target.appendFloat32(AndroidMotionEventWire.PRECISION_Y_WIRE, self.precision_y);
        }
    }
};
pub const AndroidMotionEventReader = struct {
    buf: gremlin.Reader,
    _event_id: u32 = 0,
    _event_time_nanos: i64 = 0,
    _source: u32 = 0,
    _action: i32 = 0,
    _device_id: i32 = 0,
    _display_id: i32 = 0,
    _classification: i32 = 0,
    _flags: u32 = 0,
    _pointer_offset: ?usize = null,
    _pointer_last_offset: ?usize = null,
    _pointer_cnt: usize = 0,
    _original_event_id_offset: ?usize = null,
    _original_event_id_last_offset: ?usize = null,
    _original_event_id_packed: bool = false,
    _down_time_nanos: i64 = 0,
    _cursor_position_x: f32 = 0.0,
    _cursor_position_y: f32 = 0.0,
    _action_button: i32 = 0,
    _button_state: u32 = 0,
    _meta_state: u32 = 0,
    _policy_flags: u32 = 0,
    _precision_x: f32 = 0.0,
    _precision_y: f32 = 0.0,
    pub fn init(src: []const u8) gremlin.Error!AndroidMotionEventReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidMotionEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidMotionEventWire.EVENT_ID_WIRE => {
                    const result = try buf.readFixed32(offset);
                    offset += result.size;
                    res._event_id = result.value;
                },
                AndroidMotionEventWire.EVENT_TIME_NANOS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._event_time_nanos = result.value;
                },
                AndroidMotionEventWire.SOURCE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._source = result.value;
                },
                AndroidMotionEventWire.ACTION_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._action = result.value;
                },
                AndroidMotionEventWire.DEVICE_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._device_id = result.value;
                },
                AndroidMotionEventWire.DISPLAY_ID_WIRE => {
                    const result = try buf.readSInt32(offset);
                    offset += result.size;
                    res._display_id = result.value;
                },
                AndroidMotionEventWire.CLASSIFICATION_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._classification = result.value;
                },
                AndroidMotionEventWire.FLAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._flags = result.value;
                },
                AndroidMotionEventWire.POINTER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._pointer_offset == null) {
                        res._pointer_offset = offset - result.size;
                    }
                    res._pointer_last_offset = offset;
                    res._pointer_cnt += 1;
                },
                AndroidMotionEventWire.ORIGINAL_EVENT_ID_WIRE => {
                    if (res._original_event_id_offset == null) {
                        res._original_event_id_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._original_event_id_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._original_event_id_offset = offset + length_result.size;
                        res._original_event_id_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._original_event_id_last_offset.?;
                    } else {
                        const result = try buf.readFixed32(offset);
                        offset += result.size;
                        res._original_event_id_last_offset = offset;
                    }
                },
                AndroidMotionEventWire.DOWN_TIME_NANOS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._down_time_nanos = result.value;
                },
                AndroidMotionEventWire.CURSOR_POSITION_X_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._cursor_position_x = result.value;
                },
                AndroidMotionEventWire.CURSOR_POSITION_Y_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._cursor_position_y = result.value;
                },
                AndroidMotionEventWire.ACTION_BUTTON_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._action_button = result.value;
                },
                AndroidMotionEventWire.BUTTON_STATE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._button_state = result.value;
                },
                AndroidMotionEventWire.META_STATE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._meta_state = result.value;
                },
                AndroidMotionEventWire.POLICY_FLAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._policy_flags = result.value;
                },
                AndroidMotionEventWire.PRECISION_X_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._precision_x = result.value;
                },
                AndroidMotionEventWire.PRECISION_Y_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._precision_y = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getEventId(self: *const AndroidMotionEventReader) u32 {
        return self._event_id;
    }
    pub inline fn getEventTimeNanos(self: *const AndroidMotionEventReader) i64 {
        return self._event_time_nanos;
    }
    pub inline fn getSource(self: *const AndroidMotionEventReader) u32 {
        return self._source;
    }
    pub inline fn getAction(self: *const AndroidMotionEventReader) i32 {
        return self._action;
    }
    pub inline fn getDeviceId(self: *const AndroidMotionEventReader) i32 {
        return self._device_id;
    }
    pub inline fn getDisplayId(self: *const AndroidMotionEventReader) i32 {
        return self._display_id;
    }
    pub inline fn getClassification(self: *const AndroidMotionEventReader) i32 {
        return self._classification;
    }
    pub inline fn getFlags(self: *const AndroidMotionEventReader) u32 {
        return self._flags;
    }
    pub fn pointerCount(self: *const AndroidMotionEventReader) usize {
        return self._pointer_cnt;
    }
    pub fn pointerNext(self: *AndroidMotionEventReader) ?AndroidMotionEvent.PointerReader {
        if (self._pointer_offset == null) return null;
        const current_offset = self._pointer_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidMotionEvent.PointerReader.init(result.value) catch return null;
        if (self._pointer_last_offset != null and current_offset >= self._pointer_last_offset.?) {
            self._pointer_offset = null;
            return msg;
        }
        if (self._pointer_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._pointer_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidMotionEventWire.POINTER_WIRE) {
                self._pointer_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._pointer_offset = null;
        return msg;
    }
    pub fn originalEventIdNext(self: *AndroidMotionEventReader) gremlin.Error!?u32 {
        if (self._original_event_id_offset == null) return null;
        const current_offset = self._original_event_id_offset.?;
        if (current_offset >= self._original_event_id_last_offset.?) {
            self._original_event_id_offset = null;
            return null;
        }
        if (self._original_event_id_packed) {
            const value_result = try self.buf.readFixed32(current_offset);
            self._original_event_id_offset = current_offset + value_result.size;
            if (self._original_event_id_offset.? >= self._original_event_id_last_offset.?) {
                self._original_event_id_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readFixed32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._original_event_id_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == AndroidMotionEventWire.ORIGINAL_EVENT_ID_WIRE) {
                    self._original_event_id_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._original_event_id_offset = null;
            return value_result.value;
        }
    }
    pub inline fn getDownTimeNanos(self: *const AndroidMotionEventReader) i64 {
        return self._down_time_nanos;
    }
    pub inline fn getCursorPositionX(self: *const AndroidMotionEventReader) f32 {
        return self._cursor_position_x;
    }
    pub inline fn getCursorPositionY(self: *const AndroidMotionEventReader) f32 {
        return self._cursor_position_y;
    }
    pub inline fn getActionButton(self: *const AndroidMotionEventReader) i32 {
        return self._action_button;
    }
    pub inline fn getButtonState(self: *const AndroidMotionEventReader) u32 {
        return self._button_state;
    }
    pub inline fn getMetaState(self: *const AndroidMotionEventReader) u32 {
        return self._meta_state;
    }
    pub inline fn getPolicyFlags(self: *const AndroidMotionEventReader) u32 {
        return self._policy_flags;
    }
    pub inline fn getPrecisionX(self: *const AndroidMotionEventReader) f32 {
        return self._precision_x;
    }
    pub inline fn getPrecisionY(self: *const AndroidMotionEventReader) f32 {
        return self._precision_y;
    }
};
const AndroidKeyEventWire = struct {
    const EVENT_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const EVENT_TIME_NANOS_WIRE: gremlin.ProtoWireNumber = 2;
    const DOWN_TIME_NANOS_WIRE: gremlin.ProtoWireNumber = 3;
    const SOURCE_WIRE: gremlin.ProtoWireNumber = 4;
    const ACTION_WIRE: gremlin.ProtoWireNumber = 5;
    const DEVICE_ID_WIRE: gremlin.ProtoWireNumber = 6;
    const DISPLAY_ID_WIRE: gremlin.ProtoWireNumber = 7;
    const KEY_CODE_WIRE: gremlin.ProtoWireNumber = 8;
    const SCAN_CODE_WIRE: gremlin.ProtoWireNumber = 9;
    const META_STATE_WIRE: gremlin.ProtoWireNumber = 10;
    const REPEAT_COUNT_WIRE: gremlin.ProtoWireNumber = 11;
    const FLAGS_WIRE: gremlin.ProtoWireNumber = 12;
    const POLICY_FLAGS_WIRE: gremlin.ProtoWireNumber = 13;
};
pub const AndroidKeyEvent = struct {
    // fields
    event_id: u32 = 0,
    event_time_nanos: i64 = 0,
    down_time_nanos: i64 = 0,
    source: u32 = 0,
    action: i32 = 0,
    device_id: i32 = 0,
    display_id: i32 = 0,
    key_code: i32 = 0,
    scan_code: u32 = 0,
    meta_state: u32 = 0,
    repeat_count: i32 = 0,
    flags: u32 = 0,
    policy_flags: u32 = 0,
    pub fn calcProtobufSize(self: *const AndroidKeyEvent) usize {
        var res: usize = 0;
        if (self.event_id != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidKeyEventWire.EVENT_ID_WIRE) + gremlin.sizes.sizeFixed32(self.event_id);
        }
        if (self.event_time_nanos != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidKeyEventWire.EVENT_TIME_NANOS_WIRE) + gremlin.sizes.sizeI64(self.event_time_nanos);
        }
        if (self.down_time_nanos != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidKeyEventWire.DOWN_TIME_NANOS_WIRE) + gremlin.sizes.sizeI64(self.down_time_nanos);
        }
        if (self.source != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidKeyEventWire.SOURCE_WIRE) + gremlin.sizes.sizeU32(self.source);
        }
        if (self.action != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidKeyEventWire.ACTION_WIRE) + gremlin.sizes.sizeI32(self.action);
        }
        if (self.device_id != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidKeyEventWire.DEVICE_ID_WIRE) + gremlin.sizes.sizeI32(self.device_id);
        }
        if (self.display_id != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidKeyEventWire.DISPLAY_ID_WIRE) + gremlin.sizes.sizeSI32(self.display_id);
        }
        if (self.key_code != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidKeyEventWire.KEY_CODE_WIRE) + gremlin.sizes.sizeI32(self.key_code);
        }
        if (self.scan_code != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidKeyEventWire.SCAN_CODE_WIRE) + gremlin.sizes.sizeU32(self.scan_code);
        }
        if (self.meta_state != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidKeyEventWire.META_STATE_WIRE) + gremlin.sizes.sizeU32(self.meta_state);
        }
        if (self.repeat_count != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidKeyEventWire.REPEAT_COUNT_WIRE) + gremlin.sizes.sizeI32(self.repeat_count);
        }
        if (self.flags != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidKeyEventWire.FLAGS_WIRE) + gremlin.sizes.sizeU32(self.flags);
        }
        if (self.policy_flags != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidKeyEventWire.POLICY_FLAGS_WIRE) + gremlin.sizes.sizeU32(self.policy_flags);
        }
        return res;
    }
    pub fn encode(self: *const AndroidKeyEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidKeyEvent, target: *gremlin.Writer) void {
        if (self.event_id != 0) {
            target.appendFixed32(AndroidKeyEventWire.EVENT_ID_WIRE, self.event_id);
        }
        if (self.event_time_nanos != 0) {
            target.appendInt64(AndroidKeyEventWire.EVENT_TIME_NANOS_WIRE, self.event_time_nanos);
        }
        if (self.down_time_nanos != 0) {
            target.appendInt64(AndroidKeyEventWire.DOWN_TIME_NANOS_WIRE, self.down_time_nanos);
        }
        if (self.source != 0) {
            target.appendUint32(AndroidKeyEventWire.SOURCE_WIRE, self.source);
        }
        if (self.action != 0) {
            target.appendInt32(AndroidKeyEventWire.ACTION_WIRE, self.action);
        }
        if (self.device_id != 0) {
            target.appendInt32(AndroidKeyEventWire.DEVICE_ID_WIRE, self.device_id);
        }
        if (self.display_id != 0) {
            target.appendSint32(AndroidKeyEventWire.DISPLAY_ID_WIRE, self.display_id);
        }
        if (self.key_code != 0) {
            target.appendInt32(AndroidKeyEventWire.KEY_CODE_WIRE, self.key_code);
        }
        if (self.scan_code != 0) {
            target.appendUint32(AndroidKeyEventWire.SCAN_CODE_WIRE, self.scan_code);
        }
        if (self.meta_state != 0) {
            target.appendUint32(AndroidKeyEventWire.META_STATE_WIRE, self.meta_state);
        }
        if (self.repeat_count != 0) {
            target.appendInt32(AndroidKeyEventWire.REPEAT_COUNT_WIRE, self.repeat_count);
        }
        if (self.flags != 0) {
            target.appendUint32(AndroidKeyEventWire.FLAGS_WIRE, self.flags);
        }
        if (self.policy_flags != 0) {
            target.appendUint32(AndroidKeyEventWire.POLICY_FLAGS_WIRE, self.policy_flags);
        }
    }
};
pub const AndroidKeyEventReader = struct {
    buf: gremlin.Reader,
    _event_id: u32 = 0,
    _event_time_nanos: i64 = 0,
    _down_time_nanos: i64 = 0,
    _source: u32 = 0,
    _action: i32 = 0,
    _device_id: i32 = 0,
    _display_id: i32 = 0,
    _key_code: i32 = 0,
    _scan_code: u32 = 0,
    _meta_state: u32 = 0,
    _repeat_count: i32 = 0,
    _flags: u32 = 0,
    _policy_flags: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidKeyEventReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidKeyEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidKeyEventWire.EVENT_ID_WIRE => {
                    const result = try buf.readFixed32(offset);
                    offset += result.size;
                    res._event_id = result.value;
                },
                AndroidKeyEventWire.EVENT_TIME_NANOS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._event_time_nanos = result.value;
                },
                AndroidKeyEventWire.DOWN_TIME_NANOS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._down_time_nanos = result.value;
                },
                AndroidKeyEventWire.SOURCE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._source = result.value;
                },
                AndroidKeyEventWire.ACTION_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._action = result.value;
                },
                AndroidKeyEventWire.DEVICE_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._device_id = result.value;
                },
                AndroidKeyEventWire.DISPLAY_ID_WIRE => {
                    const result = try buf.readSInt32(offset);
                    offset += result.size;
                    res._display_id = result.value;
                },
                AndroidKeyEventWire.KEY_CODE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._key_code = result.value;
                },
                AndroidKeyEventWire.SCAN_CODE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._scan_code = result.value;
                },
                AndroidKeyEventWire.META_STATE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._meta_state = result.value;
                },
                AndroidKeyEventWire.REPEAT_COUNT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._repeat_count = result.value;
                },
                AndroidKeyEventWire.FLAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._flags = result.value;
                },
                AndroidKeyEventWire.POLICY_FLAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._policy_flags = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getEventId(self: *const AndroidKeyEventReader) u32 {
        return self._event_id;
    }
    pub inline fn getEventTimeNanos(self: *const AndroidKeyEventReader) i64 {
        return self._event_time_nanos;
    }
    pub inline fn getDownTimeNanos(self: *const AndroidKeyEventReader) i64 {
        return self._down_time_nanos;
    }
    pub inline fn getSource(self: *const AndroidKeyEventReader) u32 {
        return self._source;
    }
    pub inline fn getAction(self: *const AndroidKeyEventReader) i32 {
        return self._action;
    }
    pub inline fn getDeviceId(self: *const AndroidKeyEventReader) i32 {
        return self._device_id;
    }
    pub inline fn getDisplayId(self: *const AndroidKeyEventReader) i32 {
        return self._display_id;
    }
    pub inline fn getKeyCode(self: *const AndroidKeyEventReader) i32 {
        return self._key_code;
    }
    pub inline fn getScanCode(self: *const AndroidKeyEventReader) u32 {
        return self._scan_code;
    }
    pub inline fn getMetaState(self: *const AndroidKeyEventReader) u32 {
        return self._meta_state;
    }
    pub inline fn getRepeatCount(self: *const AndroidKeyEventReader) i32 {
        return self._repeat_count;
    }
    pub inline fn getFlags(self: *const AndroidKeyEventReader) u32 {
        return self._flags;
    }
    pub inline fn getPolicyFlags(self: *const AndroidKeyEventReader) u32 {
        return self._policy_flags;
    }
};
const AndroidWindowInputDispatchEventWire = struct {
    const EVENT_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const VSYNC_ID_WIRE: gremlin.ProtoWireNumber = 2;
    const WINDOW_ID_WIRE: gremlin.ProtoWireNumber = 3;
    const DISPATCHED_POINTER_WIRE: gremlin.ProtoWireNumber = 4;
    const RESOLVED_FLAGS_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const AndroidWindowInputDispatchEvent = struct {
    // nested structs
    const DispatchedPointerWire = struct {
        const POINTER_ID_WIRE: gremlin.ProtoWireNumber = 1;
        const X_IN_DISPLAY_WIRE: gremlin.ProtoWireNumber = 2;
        const Y_IN_DISPLAY_WIRE: gremlin.ProtoWireNumber = 3;
        const AXIS_VALUE_IN_WINDOW_WIRE: gremlin.ProtoWireNumber = 4;
    };
    pub const DispatchedPointer = struct {
        // fields
        pointer_id: i32 = 0,
        x_in_display: f32 = 0.0,
        y_in_display: f32 = 0.0,
        axis_value_in_window: ?[]const ?AndroidMotionEvent.Pointer.AxisValue = null,
        pub fn calcProtobufSize(self: *const AndroidWindowInputDispatchEvent.DispatchedPointer) usize {
            var res: usize = 0;
            if (self.pointer_id != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWindowInputDispatchEvent.DispatchedPointerWire.POINTER_ID_WIRE) + gremlin.sizes.sizeI32(self.pointer_id);
            }
            if (self.x_in_display != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWindowInputDispatchEvent.DispatchedPointerWire.X_IN_DISPLAY_WIRE) + gremlin.sizes.sizeFloat(self.x_in_display);
            }
            if (self.y_in_display != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWindowInputDispatchEvent.DispatchedPointerWire.Y_IN_DISPLAY_WIRE) + gremlin.sizes.sizeFloat(self.y_in_display);
            }
            if (self.axis_value_in_window) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidWindowInputDispatchEvent.DispatchedPointerWire.AXIS_VALUE_IN_WINDOW_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidWindowInputDispatchEvent.DispatchedPointer, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidWindowInputDispatchEvent.DispatchedPointer, target: *gremlin.Writer) void {
            if (self.pointer_id != 0) {
                target.appendInt32(AndroidWindowInputDispatchEvent.DispatchedPointerWire.POINTER_ID_WIRE, self.pointer_id);
            }
            if (self.x_in_display != 0.0) {
                target.appendFloat32(AndroidWindowInputDispatchEvent.DispatchedPointerWire.X_IN_DISPLAY_WIRE, self.x_in_display);
            }
            if (self.y_in_display != 0.0) {
                target.appendFloat32(AndroidWindowInputDispatchEvent.DispatchedPointerWire.Y_IN_DISPLAY_WIRE, self.y_in_display);
            }
            if (self.axis_value_in_window) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidWindowInputDispatchEvent.DispatchedPointerWire.AXIS_VALUE_IN_WINDOW_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidWindowInputDispatchEvent.DispatchedPointerWire.AXIS_VALUE_IN_WINDOW_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const DispatchedPointerReader = struct {
        buf: gremlin.Reader,
        _pointer_id: i32 = 0,
        _x_in_display: f32 = 0.0,
        _y_in_display: f32 = 0.0,
        _axis_value_in_window_offset: ?usize = null,
        _axis_value_in_window_last_offset: ?usize = null,
        _axis_value_in_window_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidWindowInputDispatchEvent.DispatchedPointerReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidWindowInputDispatchEvent.DispatchedPointerReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidWindowInputDispatchEvent.DispatchedPointerWire.POINTER_ID_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._pointer_id = result.value;
                    },
                    AndroidWindowInputDispatchEvent.DispatchedPointerWire.X_IN_DISPLAY_WIRE => {
                        const result = try buf.readFloat32(offset);
                        offset += result.size;
                        res._x_in_display = result.value;
                    },
                    AndroidWindowInputDispatchEvent.DispatchedPointerWire.Y_IN_DISPLAY_WIRE => {
                        const result = try buf.readFloat32(offset);
                        offset += result.size;
                        res._y_in_display = result.value;
                    },
                    AndroidWindowInputDispatchEvent.DispatchedPointerWire.AXIS_VALUE_IN_WINDOW_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._axis_value_in_window_offset == null) {
                            res._axis_value_in_window_offset = offset - result.size;
                        }
                        res._axis_value_in_window_last_offset = offset;
                        res._axis_value_in_window_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getPointerId(self: *const AndroidWindowInputDispatchEvent.DispatchedPointerReader) i32 {
            return self._pointer_id;
        }
        pub inline fn getXInDisplay(self: *const AndroidWindowInputDispatchEvent.DispatchedPointerReader) f32 {
            return self._x_in_display;
        }
        pub inline fn getYInDisplay(self: *const AndroidWindowInputDispatchEvent.DispatchedPointerReader) f32 {
            return self._y_in_display;
        }
        pub fn axisValueInWindowCount(self: *const AndroidWindowInputDispatchEvent.DispatchedPointerReader) usize {
            return self._axis_value_in_window_cnt;
        }
        pub fn axisValueInWindowNext(self: *AndroidWindowInputDispatchEvent.DispatchedPointerReader) ?AndroidMotionEvent.Pointer.AxisValueReader {
            if (self._axis_value_in_window_offset == null) return null;
            const current_offset = self._axis_value_in_window_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidMotionEvent.Pointer.AxisValueReader.init(result.value) catch return null;
            if (self._axis_value_in_window_last_offset != null and current_offset >= self._axis_value_in_window_last_offset.?) {
                self._axis_value_in_window_offset = null;
                return msg;
            }
            if (self._axis_value_in_window_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._axis_value_in_window_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidWindowInputDispatchEvent.DispatchedPointerWire.AXIS_VALUE_IN_WINDOW_WIRE) {
                    self._axis_value_in_window_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._axis_value_in_window_offset = null;
            return msg;
        }
    };
    // fields
    event_id: u32 = 0,
    vsync_id: i64 = 0,
    window_id: i32 = 0,
    dispatched_pointer: ?[]const ?AndroidWindowInputDispatchEvent.DispatchedPointer = null,
    resolved_flags: u32 = 0,
    pub fn calcProtobufSize(self: *const AndroidWindowInputDispatchEvent) usize {
        var res: usize = 0;
        if (self.event_id != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWindowInputDispatchEventWire.EVENT_ID_WIRE) + gremlin.sizes.sizeFixed32(self.event_id);
        }
        if (self.vsync_id != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWindowInputDispatchEventWire.VSYNC_ID_WIRE) + gremlin.sizes.sizeI64(self.vsync_id);
        }
        if (self.window_id != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWindowInputDispatchEventWire.WINDOW_ID_WIRE) + gremlin.sizes.sizeI32(self.window_id);
        }
        if (self.dispatched_pointer) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidWindowInputDispatchEventWire.DISPATCHED_POINTER_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.resolved_flags != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWindowInputDispatchEventWire.RESOLVED_FLAGS_WIRE) + gremlin.sizes.sizeU32(self.resolved_flags);
        }
        return res;
    }
    pub fn encode(self: *const AndroidWindowInputDispatchEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidWindowInputDispatchEvent, target: *gremlin.Writer) void {
        if (self.event_id != 0) {
            target.appendFixed32(AndroidWindowInputDispatchEventWire.EVENT_ID_WIRE, self.event_id);
        }
        if (self.vsync_id != 0) {
            target.appendInt64(AndroidWindowInputDispatchEventWire.VSYNC_ID_WIRE, self.vsync_id);
        }
        if (self.window_id != 0) {
            target.appendInt32(AndroidWindowInputDispatchEventWire.WINDOW_ID_WIRE, self.window_id);
        }
        if (self.dispatched_pointer) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidWindowInputDispatchEventWire.DISPATCHED_POINTER_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidWindowInputDispatchEventWire.DISPATCHED_POINTER_WIRE, 0);
                }
            }
        }
        if (self.resolved_flags != 0) {
            target.appendUint32(AndroidWindowInputDispatchEventWire.RESOLVED_FLAGS_WIRE, self.resolved_flags);
        }
    }
};
pub const AndroidWindowInputDispatchEventReader = struct {
    buf: gremlin.Reader,
    _event_id: u32 = 0,
    _vsync_id: i64 = 0,
    _window_id: i32 = 0,
    _dispatched_pointer_offset: ?usize = null,
    _dispatched_pointer_last_offset: ?usize = null,
    _dispatched_pointer_cnt: usize = 0,
    _resolved_flags: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidWindowInputDispatchEventReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidWindowInputDispatchEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidWindowInputDispatchEventWire.EVENT_ID_WIRE => {
                    const result = try buf.readFixed32(offset);
                    offset += result.size;
                    res._event_id = result.value;
                },
                AndroidWindowInputDispatchEventWire.VSYNC_ID_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._vsync_id = result.value;
                },
                AndroidWindowInputDispatchEventWire.WINDOW_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._window_id = result.value;
                },
                AndroidWindowInputDispatchEventWire.DISPATCHED_POINTER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._dispatched_pointer_offset == null) {
                        res._dispatched_pointer_offset = offset - result.size;
                    }
                    res._dispatched_pointer_last_offset = offset;
                    res._dispatched_pointer_cnt += 1;
                },
                AndroidWindowInputDispatchEventWire.RESOLVED_FLAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._resolved_flags = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getEventId(self: *const AndroidWindowInputDispatchEventReader) u32 {
        return self._event_id;
    }
    pub inline fn getVsyncId(self: *const AndroidWindowInputDispatchEventReader) i64 {
        return self._vsync_id;
    }
    pub inline fn getWindowId(self: *const AndroidWindowInputDispatchEventReader) i32 {
        return self._window_id;
    }
    pub fn dispatchedPointerCount(self: *const AndroidWindowInputDispatchEventReader) usize {
        return self._dispatched_pointer_cnt;
    }
    pub fn dispatchedPointerNext(self: *AndroidWindowInputDispatchEventReader) ?AndroidWindowInputDispatchEvent.DispatchedPointerReader {
        if (self._dispatched_pointer_offset == null) return null;
        const current_offset = self._dispatched_pointer_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidWindowInputDispatchEvent.DispatchedPointerReader.init(result.value) catch return null;
        if (self._dispatched_pointer_last_offset != null and current_offset >= self._dispatched_pointer_last_offset.?) {
            self._dispatched_pointer_offset = null;
            return msg;
        }
        if (self._dispatched_pointer_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._dispatched_pointer_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidWindowInputDispatchEventWire.DISPATCHED_POINTER_WIRE) {
                self._dispatched_pointer_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._dispatched_pointer_offset = null;
        return msg;
    }
    pub inline fn getResolvedFlags(self: *const AndroidWindowInputDispatchEventReader) u32 {
        return self._resolved_flags;
    }
};
const AndroidInputEventWire = struct {
    const DISPATCHER_MOTION_EVENT_WIRE: gremlin.ProtoWireNumber = 1;
    const DISPATCHER_MOTION_EVENT_REDACTED_WIRE: gremlin.ProtoWireNumber = 2;
    const DISPATCHER_KEY_EVENT_WIRE: gremlin.ProtoWireNumber = 3;
    const DISPATCHER_KEY_EVENT_REDACTED_WIRE: gremlin.ProtoWireNumber = 4;
    const DISPATCHER_WINDOW_DISPATCH_EVENT_WIRE: gremlin.ProtoWireNumber = 5;
    const DISPATCHER_WINDOW_DISPATCH_EVENT_REDACTED_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const AndroidInputEvent = struct {
    // fields
    dispatcher_motion_event: ?AndroidMotionEvent = null,
    dispatcher_motion_event_redacted: ?AndroidMotionEvent = null,
    dispatcher_key_event: ?AndroidKeyEvent = null,
    dispatcher_key_event_redacted: ?AndroidKeyEvent = null,
    dispatcher_window_dispatch_event: ?AndroidWindowInputDispatchEvent = null,
    dispatcher_window_dispatch_event_redacted: ?AndroidWindowInputDispatchEvent = null,
    pub fn calcProtobufSize(self: *const AndroidInputEvent) usize {
        var res: usize = 0;
        if (self.dispatcher_motion_event) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidInputEventWire.DISPATCHER_MOTION_EVENT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.dispatcher_motion_event_redacted) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidInputEventWire.DISPATCHER_MOTION_EVENT_REDACTED_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.dispatcher_key_event) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidInputEventWire.DISPATCHER_KEY_EVENT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.dispatcher_key_event_redacted) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidInputEventWire.DISPATCHER_KEY_EVENT_REDACTED_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.dispatcher_window_dispatch_event) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidInputEventWire.DISPATCHER_WINDOW_DISPATCH_EVENT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.dispatcher_window_dispatch_event_redacted) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidInputEventWire.DISPATCHER_WINDOW_DISPATCH_EVENT_REDACTED_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidInputEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidInputEvent, target: *gremlin.Writer) void {
        if (self.dispatcher_motion_event) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidInputEventWire.DISPATCHER_MOTION_EVENT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.dispatcher_motion_event_redacted) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidInputEventWire.DISPATCHER_MOTION_EVENT_REDACTED_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.dispatcher_key_event) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidInputEventWire.DISPATCHER_KEY_EVENT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.dispatcher_key_event_redacted) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidInputEventWire.DISPATCHER_KEY_EVENT_REDACTED_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.dispatcher_window_dispatch_event) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidInputEventWire.DISPATCHER_WINDOW_DISPATCH_EVENT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.dispatcher_window_dispatch_event_redacted) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidInputEventWire.DISPATCHER_WINDOW_DISPATCH_EVENT_REDACTED_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const AndroidInputEventReader = struct {
    buf: gremlin.Reader,
    _dispatcher_motion_event_buf: ?[]const u8 = null,
    _dispatcher_motion_event_redacted_buf: ?[]const u8 = null,
    _dispatcher_key_event_buf: ?[]const u8 = null,
    _dispatcher_key_event_redacted_buf: ?[]const u8 = null,
    _dispatcher_window_dispatch_event_buf: ?[]const u8 = null,
    _dispatcher_window_dispatch_event_redacted_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!AndroidInputEventReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidInputEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidInputEventWire.DISPATCHER_MOTION_EVENT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dispatcher_motion_event_buf = result.value;
                },
                AndroidInputEventWire.DISPATCHER_MOTION_EVENT_REDACTED_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dispatcher_motion_event_redacted_buf = result.value;
                },
                AndroidInputEventWire.DISPATCHER_KEY_EVENT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dispatcher_key_event_buf = result.value;
                },
                AndroidInputEventWire.DISPATCHER_KEY_EVENT_REDACTED_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dispatcher_key_event_redacted_buf = result.value;
                },
                AndroidInputEventWire.DISPATCHER_WINDOW_DISPATCH_EVENT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dispatcher_window_dispatch_event_buf = result.value;
                },
                AndroidInputEventWire.DISPATCHER_WINDOW_DISPATCH_EVENT_REDACTED_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dispatcher_window_dispatch_event_redacted_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getDispatcherMotionEvent(self: *const AndroidInputEventReader) gremlin.Error!AndroidMotionEventReader {
        if (self._dispatcher_motion_event_buf) |buf| {
            return try AndroidMotionEventReader.init(buf);
        }
        return try AndroidMotionEventReader.init(&[_]u8{});
    }
    pub fn getDispatcherMotionEventRedacted(self: *const AndroidInputEventReader) gremlin.Error!AndroidMotionEventReader {
        if (self._dispatcher_motion_event_redacted_buf) |buf| {
            return try AndroidMotionEventReader.init(buf);
        }
        return try AndroidMotionEventReader.init(&[_]u8{});
    }
    pub fn getDispatcherKeyEvent(self: *const AndroidInputEventReader) gremlin.Error!AndroidKeyEventReader {
        if (self._dispatcher_key_event_buf) |buf| {
            return try AndroidKeyEventReader.init(buf);
        }
        return try AndroidKeyEventReader.init(&[_]u8{});
    }
    pub fn getDispatcherKeyEventRedacted(self: *const AndroidInputEventReader) gremlin.Error!AndroidKeyEventReader {
        if (self._dispatcher_key_event_redacted_buf) |buf| {
            return try AndroidKeyEventReader.init(buf);
        }
        return try AndroidKeyEventReader.init(&[_]u8{});
    }
    pub fn getDispatcherWindowDispatchEvent(self: *const AndroidInputEventReader) gremlin.Error!AndroidWindowInputDispatchEventReader {
        if (self._dispatcher_window_dispatch_event_buf) |buf| {
            return try AndroidWindowInputDispatchEventReader.init(buf);
        }
        return try AndroidWindowInputDispatchEventReader.init(&[_]u8{});
    }
    pub fn getDispatcherWindowDispatchEventRedacted(self: *const AndroidInputEventReader) gremlin.Error!AndroidWindowInputDispatchEventReader {
        if (self._dispatcher_window_dispatch_event_redacted_buf) |buf| {
            return try AndroidWindowInputDispatchEventReader.init(buf);
        }
        return try AndroidWindowInputDispatchEventReader.init(&[_]u8{});
    }
};
