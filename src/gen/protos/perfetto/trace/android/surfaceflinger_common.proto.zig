// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
const rect = @import("src/gen/protos/perfetto/trace/android/graphics/rect.proto.zig");
// enums
pub const TrustedOverlay = enum(i32) {
    UNSET = 0,
    DISABLED = 1,
    ENABLED = 2,
};
// structs
const RegionProtoWire = struct {
    const RECT_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const RegionProto = struct {
    // fields
    rect: ?[]const ?rect.RectProto = null,
    pub fn calcProtobufSize(self: *const RegionProto) usize {
        var res: usize = 0;
        if (self.rect) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(RegionProtoWire.RECT_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const RegionProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const RegionProto, target: *gremlin.Writer) void {
        if (self.rect) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(RegionProtoWire.RECT_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(RegionProtoWire.RECT_WIRE, 0);
                }
            }
        }
    }
};
pub const RegionProtoReader = struct {
    buf: gremlin.Reader,
    _rect_offset: ?usize = null,
    _rect_last_offset: ?usize = null,
    _rect_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!RegionProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = RegionProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                RegionProtoWire.RECT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._rect_offset == null) {
                        res._rect_offset = offset - result.size;
                    }
                    res._rect_last_offset = offset;
                    res._rect_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn rectCount(self: *const RegionProtoReader) usize {
        return self._rect_cnt;
    }
    pub fn rectNext(self: *RegionProtoReader) ?rect.RectProtoReader {
        if (self._rect_offset == null) return null;
        const current_offset = self._rect_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = rect.RectProtoReader.init(result.value) catch return null;
        if (self._rect_last_offset != null and current_offset >= self._rect_last_offset.?) {
            self._rect_offset = null;
            return msg;
        }
        if (self._rect_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._rect_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == RegionProtoWire.RECT_WIRE) {
                self._rect_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._rect_offset = null;
        return msg;
    }
};
const SizeProtoWire = struct {
    const W_WIRE: gremlin.ProtoWireNumber = 1;
    const H_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const SizeProto = struct {
    // fields
    w: i32 = 0,
    h: i32 = 0,
    pub fn calcProtobufSize(self: *const SizeProto) usize {
        var res: usize = 0;
        if (self.w != 0) {
            res += gremlin.sizes.sizeWireNumber(SizeProtoWire.W_WIRE) + gremlin.sizes.sizeI32(self.w);
        }
        if (self.h != 0) {
            res += gremlin.sizes.sizeWireNumber(SizeProtoWire.H_WIRE) + gremlin.sizes.sizeI32(self.h);
        }
        return res;
    }
    pub fn encode(self: *const SizeProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SizeProto, target: *gremlin.Writer) void {
        if (self.w != 0) {
            target.appendInt32(SizeProtoWire.W_WIRE, self.w);
        }
        if (self.h != 0) {
            target.appendInt32(SizeProtoWire.H_WIRE, self.h);
        }
    }
};
pub const SizeProtoReader = struct {
    buf: gremlin.Reader,
    _w: i32 = 0,
    _h: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!SizeProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = SizeProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SizeProtoWire.W_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._w = result.value;
                },
                SizeProtoWire.H_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._h = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getW(self: *const SizeProtoReader) i32 {
        return self._w;
    }
    pub inline fn getH(self: *const SizeProtoReader) i32 {
        return self._h;
    }
};
const TransformProtoWire = struct {
    const DSDX_WIRE: gremlin.ProtoWireNumber = 1;
    const DTDX_WIRE: gremlin.ProtoWireNumber = 2;
    const DSDY_WIRE: gremlin.ProtoWireNumber = 3;
    const DTDY_WIRE: gremlin.ProtoWireNumber = 4;
    const TYPE_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const TransformProto = struct {
    // fields
    dsdx: f32 = 0.0,
    dtdx: f32 = 0.0,
    dsdy: f32 = 0.0,
    dtdy: f32 = 0.0,
    type: i32 = 0,
    pub fn calcProtobufSize(self: *const TransformProto) usize {
        var res: usize = 0;
        if (self.dsdx != 0.0) {
            res += gremlin.sizes.sizeWireNumber(TransformProtoWire.DSDX_WIRE) + gremlin.sizes.sizeFloat(self.dsdx);
        }
        if (self.dtdx != 0.0) {
            res += gremlin.sizes.sizeWireNumber(TransformProtoWire.DTDX_WIRE) + gremlin.sizes.sizeFloat(self.dtdx);
        }
        if (self.dsdy != 0.0) {
            res += gremlin.sizes.sizeWireNumber(TransformProtoWire.DSDY_WIRE) + gremlin.sizes.sizeFloat(self.dsdy);
        }
        if (self.dtdy != 0.0) {
            res += gremlin.sizes.sizeWireNumber(TransformProtoWire.DTDY_WIRE) + gremlin.sizes.sizeFloat(self.dtdy);
        }
        if (self.type != 0) {
            res += gremlin.sizes.sizeWireNumber(TransformProtoWire.TYPE_WIRE) + gremlin.sizes.sizeI32(self.type);
        }
        return res;
    }
    pub fn encode(self: *const TransformProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TransformProto, target: *gremlin.Writer) void {
        if (self.dsdx != 0.0) {
            target.appendFloat32(TransformProtoWire.DSDX_WIRE, self.dsdx);
        }
        if (self.dtdx != 0.0) {
            target.appendFloat32(TransformProtoWire.DTDX_WIRE, self.dtdx);
        }
        if (self.dsdy != 0.0) {
            target.appendFloat32(TransformProtoWire.DSDY_WIRE, self.dsdy);
        }
        if (self.dtdy != 0.0) {
            target.appendFloat32(TransformProtoWire.DTDY_WIRE, self.dtdy);
        }
        if (self.type != 0) {
            target.appendInt32(TransformProtoWire.TYPE_WIRE, self.type);
        }
    }
};
pub const TransformProtoReader = struct {
    buf: gremlin.Reader,
    _dsdx: f32 = 0.0,
    _dtdx: f32 = 0.0,
    _dsdy: f32 = 0.0,
    _dtdy: f32 = 0.0,
    _type: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!TransformProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = TransformProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TransformProtoWire.DSDX_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._dsdx = result.value;
                },
                TransformProtoWire.DTDX_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._dtdx = result.value;
                },
                TransformProtoWire.DSDY_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._dsdy = result.value;
                },
                TransformProtoWire.DTDY_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._dtdy = result.value;
                },
                TransformProtoWire.TYPE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._type = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDsdx(self: *const TransformProtoReader) f32 {
        return self._dsdx;
    }
    pub inline fn getDtdx(self: *const TransformProtoReader) f32 {
        return self._dtdx;
    }
    pub inline fn getDsdy(self: *const TransformProtoReader) f32 {
        return self._dsdy;
    }
    pub inline fn getDtdy(self: *const TransformProtoReader) f32 {
        return self._dtdy;
    }
    pub inline fn getType(self: *const TransformProtoReader) i32 {
        return self._type;
    }
};
const ColorProtoWire = struct {
    const R_WIRE: gremlin.ProtoWireNumber = 1;
    const G_WIRE: gremlin.ProtoWireNumber = 2;
    const B_WIRE: gremlin.ProtoWireNumber = 3;
    const A_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const ColorProto = struct {
    // fields
    r: f32 = 0.0,
    g: f32 = 0.0,
    b: f32 = 0.0,
    a: f32 = 0.0,
    pub fn calcProtobufSize(self: *const ColorProto) usize {
        var res: usize = 0;
        if (self.r != 0.0) {
            res += gremlin.sizes.sizeWireNumber(ColorProtoWire.R_WIRE) + gremlin.sizes.sizeFloat(self.r);
        }
        if (self.g != 0.0) {
            res += gremlin.sizes.sizeWireNumber(ColorProtoWire.G_WIRE) + gremlin.sizes.sizeFloat(self.g);
        }
        if (self.b != 0.0) {
            res += gremlin.sizes.sizeWireNumber(ColorProtoWire.B_WIRE) + gremlin.sizes.sizeFloat(self.b);
        }
        if (self.a != 0.0) {
            res += gremlin.sizes.sizeWireNumber(ColorProtoWire.A_WIRE) + gremlin.sizes.sizeFloat(self.a);
        }
        return res;
    }
    pub fn encode(self: *const ColorProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ColorProto, target: *gremlin.Writer) void {
        if (self.r != 0.0) {
            target.appendFloat32(ColorProtoWire.R_WIRE, self.r);
        }
        if (self.g != 0.0) {
            target.appendFloat32(ColorProtoWire.G_WIRE, self.g);
        }
        if (self.b != 0.0) {
            target.appendFloat32(ColorProtoWire.B_WIRE, self.b);
        }
        if (self.a != 0.0) {
            target.appendFloat32(ColorProtoWire.A_WIRE, self.a);
        }
    }
};
pub const ColorProtoReader = struct {
    buf: gremlin.Reader,
    _r: f32 = 0.0,
    _g: f32 = 0.0,
    _b: f32 = 0.0,
    _a: f32 = 0.0,
    pub fn init(src: []const u8) gremlin.Error!ColorProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = ColorProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ColorProtoWire.R_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._r = result.value;
                },
                ColorProtoWire.G_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._g = result.value;
                },
                ColorProtoWire.B_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._b = result.value;
                },
                ColorProtoWire.A_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._a = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getR(self: *const ColorProtoReader) f32 {
        return self._r;
    }
    pub inline fn getG(self: *const ColorProtoReader) f32 {
        return self._g;
    }
    pub inline fn getB(self: *const ColorProtoReader) f32 {
        return self._b;
    }
    pub inline fn getA(self: *const ColorProtoReader) f32 {
        return self._a;
    }
};
const InputWindowInfoProtoWire = struct {
    const LAYOUT_PARAMS_FLAGS_WIRE: gremlin.ProtoWireNumber = 1;
    const LAYOUT_PARAMS_TYPE_WIRE: gremlin.ProtoWireNumber = 2;
    const FRAME_WIRE: gremlin.ProtoWireNumber = 3;
    const TOUCHABLE_REGION_WIRE: gremlin.ProtoWireNumber = 4;
    const SURFACE_INSET_WIRE: gremlin.ProtoWireNumber = 5;
    const VISIBLE_WIRE: gremlin.ProtoWireNumber = 6;
    const CAN_RECEIVE_KEYS_WIRE: gremlin.ProtoWireNumber = 7;
    const FOCUSABLE_WIRE: gremlin.ProtoWireNumber = 8;
    const HAS_WALLPAPER_WIRE: gremlin.ProtoWireNumber = 9;
    const GLOBAL_SCALE_FACTOR_WIRE: gremlin.ProtoWireNumber = 10;
    const WINDOW_X_SCALE_WIRE: gremlin.ProtoWireNumber = 11;
    const WINDOW_Y_SCALE_WIRE: gremlin.ProtoWireNumber = 12;
    const CROP_LAYER_ID_WIRE: gremlin.ProtoWireNumber = 13;
    const REPLACE_TOUCHABLE_REGION_WITH_CROP_WIRE: gremlin.ProtoWireNumber = 14;
    const TOUCHABLE_REGION_CROP_WIRE: gremlin.ProtoWireNumber = 15;
    const TRANSFORM_WIRE: gremlin.ProtoWireNumber = 16;
    const INPUT_CONFIG_WIRE: gremlin.ProtoWireNumber = 17;
};
pub const InputWindowInfoProto = struct {
    // fields
    layout_params_flags: u32 = 0,
    layout_params_type: i32 = 0,
    frame: ?rect.RectProto = null,
    touchable_region: ?RegionProto = null,
    surface_inset: i32 = 0,
    visible: bool = false,
    can_receive_keys: bool = false,
    focusable: bool = false,
    has_wallpaper: bool = false,
    global_scale_factor: f32 = 0.0,
    window_x_scale: f32 = 0.0,
    window_y_scale: f32 = 0.0,
    crop_layer_id: i32 = 0,
    replace_touchable_region_with_crop: bool = false,
    touchable_region_crop: ?rect.RectProto = null,
    transform: ?TransformProto = null,
    input_config: u32 = 0,
    pub fn calcProtobufSize(self: *const InputWindowInfoProto) usize {
        var res: usize = 0;
        if (self.layout_params_flags != 0) {
            res += gremlin.sizes.sizeWireNumber(InputWindowInfoProtoWire.LAYOUT_PARAMS_FLAGS_WIRE) + gremlin.sizes.sizeU32(self.layout_params_flags);
        }
        if (self.layout_params_type != 0) {
            res += gremlin.sizes.sizeWireNumber(InputWindowInfoProtoWire.LAYOUT_PARAMS_TYPE_WIRE) + gremlin.sizes.sizeI32(self.layout_params_type);
        }
        if (self.frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(InputWindowInfoProtoWire.FRAME_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.touchable_region) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(InputWindowInfoProtoWire.TOUCHABLE_REGION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.surface_inset != 0) {
            res += gremlin.sizes.sizeWireNumber(InputWindowInfoProtoWire.SURFACE_INSET_WIRE) + gremlin.sizes.sizeI32(self.surface_inset);
        }
        if (self.visible != false) {
            res += gremlin.sizes.sizeWireNumber(InputWindowInfoProtoWire.VISIBLE_WIRE) + gremlin.sizes.sizeBool(self.visible);
        }
        if (self.can_receive_keys != false) {
            res += gremlin.sizes.sizeWireNumber(InputWindowInfoProtoWire.CAN_RECEIVE_KEYS_WIRE) + gremlin.sizes.sizeBool(self.can_receive_keys);
        }
        if (self.focusable != false) {
            res += gremlin.sizes.sizeWireNumber(InputWindowInfoProtoWire.FOCUSABLE_WIRE) + gremlin.sizes.sizeBool(self.focusable);
        }
        if (self.has_wallpaper != false) {
            res += gremlin.sizes.sizeWireNumber(InputWindowInfoProtoWire.HAS_WALLPAPER_WIRE) + gremlin.sizes.sizeBool(self.has_wallpaper);
        }
        if (self.global_scale_factor != 0.0) {
            res += gremlin.sizes.sizeWireNumber(InputWindowInfoProtoWire.GLOBAL_SCALE_FACTOR_WIRE) + gremlin.sizes.sizeFloat(self.global_scale_factor);
        }
        if (self.window_x_scale != 0.0) {
            res += gremlin.sizes.sizeWireNumber(InputWindowInfoProtoWire.WINDOW_X_SCALE_WIRE) + gremlin.sizes.sizeFloat(self.window_x_scale);
        }
        if (self.window_y_scale != 0.0) {
            res += gremlin.sizes.sizeWireNumber(InputWindowInfoProtoWire.WINDOW_Y_SCALE_WIRE) + gremlin.sizes.sizeFloat(self.window_y_scale);
        }
        if (self.crop_layer_id != 0) {
            res += gremlin.sizes.sizeWireNumber(InputWindowInfoProtoWire.CROP_LAYER_ID_WIRE) + gremlin.sizes.sizeI32(self.crop_layer_id);
        }
        if (self.replace_touchable_region_with_crop != false) {
            res += gremlin.sizes.sizeWireNumber(InputWindowInfoProtoWire.REPLACE_TOUCHABLE_REGION_WITH_CROP_WIRE) + gremlin.sizes.sizeBool(self.replace_touchable_region_with_crop);
        }
        if (self.touchable_region_crop) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(InputWindowInfoProtoWire.TOUCHABLE_REGION_CROP_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.transform) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(InputWindowInfoProtoWire.TRANSFORM_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.input_config != 0) {
            res += gremlin.sizes.sizeWireNumber(InputWindowInfoProtoWire.INPUT_CONFIG_WIRE) + gremlin.sizes.sizeU32(self.input_config);
        }
        return res;
    }
    pub fn encode(self: *const InputWindowInfoProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const InputWindowInfoProto, target: *gremlin.Writer) void {
        if (self.layout_params_flags != 0) {
            target.appendUint32(InputWindowInfoProtoWire.LAYOUT_PARAMS_FLAGS_WIRE, self.layout_params_flags);
        }
        if (self.layout_params_type != 0) {
            target.appendInt32(InputWindowInfoProtoWire.LAYOUT_PARAMS_TYPE_WIRE, self.layout_params_type);
        }
        if (self.frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(InputWindowInfoProtoWire.FRAME_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.touchable_region) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(InputWindowInfoProtoWire.TOUCHABLE_REGION_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.surface_inset != 0) {
            target.appendInt32(InputWindowInfoProtoWire.SURFACE_INSET_WIRE, self.surface_inset);
        }
        if (self.visible != false) {
            target.appendBool(InputWindowInfoProtoWire.VISIBLE_WIRE, self.visible);
        }
        if (self.can_receive_keys != false) {
            target.appendBool(InputWindowInfoProtoWire.CAN_RECEIVE_KEYS_WIRE, self.can_receive_keys);
        }
        if (self.focusable != false) {
            target.appendBool(InputWindowInfoProtoWire.FOCUSABLE_WIRE, self.focusable);
        }
        if (self.has_wallpaper != false) {
            target.appendBool(InputWindowInfoProtoWire.HAS_WALLPAPER_WIRE, self.has_wallpaper);
        }
        if (self.global_scale_factor != 0.0) {
            target.appendFloat32(InputWindowInfoProtoWire.GLOBAL_SCALE_FACTOR_WIRE, self.global_scale_factor);
        }
        if (self.window_x_scale != 0.0) {
            target.appendFloat32(InputWindowInfoProtoWire.WINDOW_X_SCALE_WIRE, self.window_x_scale);
        }
        if (self.window_y_scale != 0.0) {
            target.appendFloat32(InputWindowInfoProtoWire.WINDOW_Y_SCALE_WIRE, self.window_y_scale);
        }
        if (self.crop_layer_id != 0) {
            target.appendInt32(InputWindowInfoProtoWire.CROP_LAYER_ID_WIRE, self.crop_layer_id);
        }
        if (self.replace_touchable_region_with_crop != false) {
            target.appendBool(InputWindowInfoProtoWire.REPLACE_TOUCHABLE_REGION_WITH_CROP_WIRE, self.replace_touchable_region_with_crop);
        }
        if (self.touchable_region_crop) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(InputWindowInfoProtoWire.TOUCHABLE_REGION_CROP_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.transform) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(InputWindowInfoProtoWire.TRANSFORM_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.input_config != 0) {
            target.appendUint32(InputWindowInfoProtoWire.INPUT_CONFIG_WIRE, self.input_config);
        }
    }
};
pub const InputWindowInfoProtoReader = struct {
    buf: gremlin.Reader,
    _layout_params_flags: u32 = 0,
    _layout_params_type: i32 = 0,
    _frame_buf: ?[]const u8 = null,
    _touchable_region_buf: ?[]const u8 = null,
    _surface_inset: i32 = 0,
    _visible: bool = false,
    _can_receive_keys: bool = false,
    _focusable: bool = false,
    _has_wallpaper: bool = false,
    _global_scale_factor: f32 = 0.0,
    _window_x_scale: f32 = 0.0,
    _window_y_scale: f32 = 0.0,
    _crop_layer_id: i32 = 0,
    _replace_touchable_region_with_crop: bool = false,
    _touchable_region_crop_buf: ?[]const u8 = null,
    _transform_buf: ?[]const u8 = null,
    _input_config: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!InputWindowInfoProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = InputWindowInfoProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                InputWindowInfoProtoWire.LAYOUT_PARAMS_FLAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._layout_params_flags = result.value;
                },
                InputWindowInfoProtoWire.LAYOUT_PARAMS_TYPE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._layout_params_type = result.value;
                },
                InputWindowInfoProtoWire.FRAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._frame_buf = result.value;
                },
                InputWindowInfoProtoWire.TOUCHABLE_REGION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._touchable_region_buf = result.value;
                },
                InputWindowInfoProtoWire.SURFACE_INSET_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._surface_inset = result.value;
                },
                InputWindowInfoProtoWire.VISIBLE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._visible = result.value;
                },
                InputWindowInfoProtoWire.CAN_RECEIVE_KEYS_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._can_receive_keys = result.value;
                },
                InputWindowInfoProtoWire.FOCUSABLE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._focusable = result.value;
                },
                InputWindowInfoProtoWire.HAS_WALLPAPER_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._has_wallpaper = result.value;
                },
                InputWindowInfoProtoWire.GLOBAL_SCALE_FACTOR_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._global_scale_factor = result.value;
                },
                InputWindowInfoProtoWire.WINDOW_X_SCALE_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._window_x_scale = result.value;
                },
                InputWindowInfoProtoWire.WINDOW_Y_SCALE_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._window_y_scale = result.value;
                },
                InputWindowInfoProtoWire.CROP_LAYER_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._crop_layer_id = result.value;
                },
                InputWindowInfoProtoWire.REPLACE_TOUCHABLE_REGION_WITH_CROP_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._replace_touchable_region_with_crop = result.value;
                },
                InputWindowInfoProtoWire.TOUCHABLE_REGION_CROP_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._touchable_region_crop_buf = result.value;
                },
                InputWindowInfoProtoWire.TRANSFORM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._transform_buf = result.value;
                },
                InputWindowInfoProtoWire.INPUT_CONFIG_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._input_config = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getLayoutParamsFlags(self: *const InputWindowInfoProtoReader) u32 {
        return self._layout_params_flags;
    }
    pub inline fn getLayoutParamsType(self: *const InputWindowInfoProtoReader) i32 {
        return self._layout_params_type;
    }
    pub fn getFrame(self: *const InputWindowInfoProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._frame_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getTouchableRegion(self: *const InputWindowInfoProtoReader) gremlin.Error!RegionProtoReader {
        if (self._touchable_region_buf) |buf| {
            return try RegionProtoReader.init(buf);
        }
        return try RegionProtoReader.init(&[_]u8{});
    }
    pub inline fn getSurfaceInset(self: *const InputWindowInfoProtoReader) i32 {
        return self._surface_inset;
    }
    pub inline fn getVisible(self: *const InputWindowInfoProtoReader) bool {
        return self._visible;
    }
    pub inline fn getCanReceiveKeys(self: *const InputWindowInfoProtoReader) bool {
        return self._can_receive_keys;
    }
    pub inline fn getFocusable(self: *const InputWindowInfoProtoReader) bool {
        return self._focusable;
    }
    pub inline fn getHasWallpaper(self: *const InputWindowInfoProtoReader) bool {
        return self._has_wallpaper;
    }
    pub inline fn getGlobalScaleFactor(self: *const InputWindowInfoProtoReader) f32 {
        return self._global_scale_factor;
    }
    pub inline fn getWindowXScale(self: *const InputWindowInfoProtoReader) f32 {
        return self._window_x_scale;
    }
    pub inline fn getWindowYScale(self: *const InputWindowInfoProtoReader) f32 {
        return self._window_y_scale;
    }
    pub inline fn getCropLayerId(self: *const InputWindowInfoProtoReader) i32 {
        return self._crop_layer_id;
    }
    pub inline fn getReplaceTouchableRegionWithCrop(self: *const InputWindowInfoProtoReader) bool {
        return self._replace_touchable_region_with_crop;
    }
    pub fn getTouchableRegionCrop(self: *const InputWindowInfoProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._touchable_region_crop_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getTransform(self: *const InputWindowInfoProtoReader) gremlin.Error!TransformProtoReader {
        if (self._transform_buf) |buf| {
            return try TransformProtoReader.init(buf);
        }
        return try TransformProtoReader.init(&[_]u8{});
    }
    pub inline fn getInputConfig(self: *const InputWindowInfoProtoReader) u32 {
        return self._input_config;
    }
};
const BlurRegionWire = struct {
    const BLUR_RADIUS_WIRE: gremlin.ProtoWireNumber = 1;
    const CORNER_RADIUS_TL_WIRE: gremlin.ProtoWireNumber = 2;
    const CORNER_RADIUS_TR_WIRE: gremlin.ProtoWireNumber = 3;
    const CORNER_RADIUS_BL_WIRE: gremlin.ProtoWireNumber = 4;
    const CORNER_RADIUS_BR_WIRE: gremlin.ProtoWireNumber = 5;
    const CORNER_RADIUS_TLX_WIRE: gremlin.ProtoWireNumber = 11;
    const CORNER_RADIUS_TLY_WIRE: gremlin.ProtoWireNumber = 12;
    const CORNER_RADIUS_TRX_WIRE: gremlin.ProtoWireNumber = 13;
    const CORNER_RADIUS_TRY_WIRE: gremlin.ProtoWireNumber = 14;
    const CORNER_RADIUS_BLX_WIRE: gremlin.ProtoWireNumber = 15;
    const CORNER_RADIUS_BLY_WIRE: gremlin.ProtoWireNumber = 16;
    const CORNER_RADIUS_BRX_WIRE: gremlin.ProtoWireNumber = 17;
    const CORNER_RADIUS_BRY_WIRE: gremlin.ProtoWireNumber = 18;
    const ALPHA_WIRE: gremlin.ProtoWireNumber = 6;
    const LEFT_WIRE: gremlin.ProtoWireNumber = 7;
    const TOP_WIRE: gremlin.ProtoWireNumber = 8;
    const RIGHT_WIRE: gremlin.ProtoWireNumber = 9;
    const BOTTOM_WIRE: gremlin.ProtoWireNumber = 10;
};
pub const BlurRegion = struct {
    // fields
    blur_radius: u32 = 0,
    corner_radius_tl: u32 = 0,
    corner_radius_tr: u32 = 0,
    corner_radius_bl: u32 = 0,
    corner_radius_br: f32 = 0.0,
    corner_radius_tlx: f32 = 0.0,
    corner_radius_tly: f32 = 0.0,
    corner_radius_trx: f32 = 0.0,
    corner_radius_try: f32 = 0.0,
    corner_radius_blx: f32 = 0.0,
    corner_radius_bly: f32 = 0.0,
    corner_radius_brx: f32 = 0.0,
    corner_radius_bry: f32 = 0.0,
    alpha: f32 = 0.0,
    left: i32 = 0,
    top: i32 = 0,
    right: i32 = 0,
    bottom: i32 = 0,
    pub fn calcProtobufSize(self: *const BlurRegion) usize {
        var res: usize = 0;
        if (self.blur_radius != 0) {
            res += gremlin.sizes.sizeWireNumber(BlurRegionWire.BLUR_RADIUS_WIRE) + gremlin.sizes.sizeU32(self.blur_radius);
        }
        if (self.corner_radius_tl != 0) {
            res += gremlin.sizes.sizeWireNumber(BlurRegionWire.CORNER_RADIUS_TL_WIRE) + gremlin.sizes.sizeU32(self.corner_radius_tl);
        }
        if (self.corner_radius_tr != 0) {
            res += gremlin.sizes.sizeWireNumber(BlurRegionWire.CORNER_RADIUS_TR_WIRE) + gremlin.sizes.sizeU32(self.corner_radius_tr);
        }
        if (self.corner_radius_bl != 0) {
            res += gremlin.sizes.sizeWireNumber(BlurRegionWire.CORNER_RADIUS_BL_WIRE) + gremlin.sizes.sizeU32(self.corner_radius_bl);
        }
        if (self.corner_radius_br != 0.0) {
            res += gremlin.sizes.sizeWireNumber(BlurRegionWire.CORNER_RADIUS_BR_WIRE) + gremlin.sizes.sizeFloat(self.corner_radius_br);
        }
        if (self.corner_radius_tlx != 0.0) {
            res += gremlin.sizes.sizeWireNumber(BlurRegionWire.CORNER_RADIUS_TLX_WIRE) + gremlin.sizes.sizeFloat(self.corner_radius_tlx);
        }
        if (self.corner_radius_tly != 0.0) {
            res += gremlin.sizes.sizeWireNumber(BlurRegionWire.CORNER_RADIUS_TLY_WIRE) + gremlin.sizes.sizeFloat(self.corner_radius_tly);
        }
        if (self.corner_radius_trx != 0.0) {
            res += gremlin.sizes.sizeWireNumber(BlurRegionWire.CORNER_RADIUS_TRX_WIRE) + gremlin.sizes.sizeFloat(self.corner_radius_trx);
        }
        if (self.corner_radius_try != 0.0) {
            res += gremlin.sizes.sizeWireNumber(BlurRegionWire.CORNER_RADIUS_TRY_WIRE) + gremlin.sizes.sizeFloat(self.corner_radius_try);
        }
        if (self.corner_radius_blx != 0.0) {
            res += gremlin.sizes.sizeWireNumber(BlurRegionWire.CORNER_RADIUS_BLX_WIRE) + gremlin.sizes.sizeFloat(self.corner_radius_blx);
        }
        if (self.corner_radius_bly != 0.0) {
            res += gremlin.sizes.sizeWireNumber(BlurRegionWire.CORNER_RADIUS_BLY_WIRE) + gremlin.sizes.sizeFloat(self.corner_radius_bly);
        }
        if (self.corner_radius_brx != 0.0) {
            res += gremlin.sizes.sizeWireNumber(BlurRegionWire.CORNER_RADIUS_BRX_WIRE) + gremlin.sizes.sizeFloat(self.corner_radius_brx);
        }
        if (self.corner_radius_bry != 0.0) {
            res += gremlin.sizes.sizeWireNumber(BlurRegionWire.CORNER_RADIUS_BRY_WIRE) + gremlin.sizes.sizeFloat(self.corner_radius_bry);
        }
        if (self.alpha != 0.0) {
            res += gremlin.sizes.sizeWireNumber(BlurRegionWire.ALPHA_WIRE) + gremlin.sizes.sizeFloat(self.alpha);
        }
        if (self.left != 0) {
            res += gremlin.sizes.sizeWireNumber(BlurRegionWire.LEFT_WIRE) + gremlin.sizes.sizeI32(self.left);
        }
        if (self.top != 0) {
            res += gremlin.sizes.sizeWireNumber(BlurRegionWire.TOP_WIRE) + gremlin.sizes.sizeI32(self.top);
        }
        if (self.right != 0) {
            res += gremlin.sizes.sizeWireNumber(BlurRegionWire.RIGHT_WIRE) + gremlin.sizes.sizeI32(self.right);
        }
        if (self.bottom != 0) {
            res += gremlin.sizes.sizeWireNumber(BlurRegionWire.BOTTOM_WIRE) + gremlin.sizes.sizeI32(self.bottom);
        }
        return res;
    }
    pub fn encode(self: *const BlurRegion, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const BlurRegion, target: *gremlin.Writer) void {
        if (self.blur_radius != 0) {
            target.appendUint32(BlurRegionWire.BLUR_RADIUS_WIRE, self.blur_radius);
        }
        if (self.corner_radius_tl != 0) {
            target.appendUint32(BlurRegionWire.CORNER_RADIUS_TL_WIRE, self.corner_radius_tl);
        }
        if (self.corner_radius_tr != 0) {
            target.appendUint32(BlurRegionWire.CORNER_RADIUS_TR_WIRE, self.corner_radius_tr);
        }
        if (self.corner_radius_bl != 0) {
            target.appendUint32(BlurRegionWire.CORNER_RADIUS_BL_WIRE, self.corner_radius_bl);
        }
        if (self.corner_radius_br != 0.0) {
            target.appendFloat32(BlurRegionWire.CORNER_RADIUS_BR_WIRE, self.corner_radius_br);
        }
        if (self.corner_radius_tlx != 0.0) {
            target.appendFloat32(BlurRegionWire.CORNER_RADIUS_TLX_WIRE, self.corner_radius_tlx);
        }
        if (self.corner_radius_tly != 0.0) {
            target.appendFloat32(BlurRegionWire.CORNER_RADIUS_TLY_WIRE, self.corner_radius_tly);
        }
        if (self.corner_radius_trx != 0.0) {
            target.appendFloat32(BlurRegionWire.CORNER_RADIUS_TRX_WIRE, self.corner_radius_trx);
        }
        if (self.corner_radius_try != 0.0) {
            target.appendFloat32(BlurRegionWire.CORNER_RADIUS_TRY_WIRE, self.corner_radius_try);
        }
        if (self.corner_radius_blx != 0.0) {
            target.appendFloat32(BlurRegionWire.CORNER_RADIUS_BLX_WIRE, self.corner_radius_blx);
        }
        if (self.corner_radius_bly != 0.0) {
            target.appendFloat32(BlurRegionWire.CORNER_RADIUS_BLY_WIRE, self.corner_radius_bly);
        }
        if (self.corner_radius_brx != 0.0) {
            target.appendFloat32(BlurRegionWire.CORNER_RADIUS_BRX_WIRE, self.corner_radius_brx);
        }
        if (self.corner_radius_bry != 0.0) {
            target.appendFloat32(BlurRegionWire.CORNER_RADIUS_BRY_WIRE, self.corner_radius_bry);
        }
        if (self.alpha != 0.0) {
            target.appendFloat32(BlurRegionWire.ALPHA_WIRE, self.alpha);
        }
        if (self.left != 0) {
            target.appendInt32(BlurRegionWire.LEFT_WIRE, self.left);
        }
        if (self.top != 0) {
            target.appendInt32(BlurRegionWire.TOP_WIRE, self.top);
        }
        if (self.right != 0) {
            target.appendInt32(BlurRegionWire.RIGHT_WIRE, self.right);
        }
        if (self.bottom != 0) {
            target.appendInt32(BlurRegionWire.BOTTOM_WIRE, self.bottom);
        }
    }
};
pub const BlurRegionReader = struct {
    buf: gremlin.Reader,
    _blur_radius: u32 = 0,
    _corner_radius_tl: u32 = 0,
    _corner_radius_tr: u32 = 0,
    _corner_radius_bl: u32 = 0,
    _corner_radius_br: f32 = 0.0,
    _corner_radius_tlx: f32 = 0.0,
    _corner_radius_tly: f32 = 0.0,
    _corner_radius_trx: f32 = 0.0,
    _corner_radius_try: f32 = 0.0,
    _corner_radius_blx: f32 = 0.0,
    _corner_radius_bly: f32 = 0.0,
    _corner_radius_brx: f32 = 0.0,
    _corner_radius_bry: f32 = 0.0,
    _alpha: f32 = 0.0,
    _left: i32 = 0,
    _top: i32 = 0,
    _right: i32 = 0,
    _bottom: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!BlurRegionReader {
        const buf = gremlin.Reader.init(src);
        var res = BlurRegionReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                BlurRegionWire.BLUR_RADIUS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._blur_radius = result.value;
                },
                BlurRegionWire.CORNER_RADIUS_TL_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._corner_radius_tl = result.value;
                },
                BlurRegionWire.CORNER_RADIUS_TR_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._corner_radius_tr = result.value;
                },
                BlurRegionWire.CORNER_RADIUS_BL_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._corner_radius_bl = result.value;
                },
                BlurRegionWire.CORNER_RADIUS_BR_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._corner_radius_br = result.value;
                },
                BlurRegionWire.CORNER_RADIUS_TLX_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._corner_radius_tlx = result.value;
                },
                BlurRegionWire.CORNER_RADIUS_TLY_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._corner_radius_tly = result.value;
                },
                BlurRegionWire.CORNER_RADIUS_TRX_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._corner_radius_trx = result.value;
                },
                BlurRegionWire.CORNER_RADIUS_TRY_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._corner_radius_try = result.value;
                },
                BlurRegionWire.CORNER_RADIUS_BLX_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._corner_radius_blx = result.value;
                },
                BlurRegionWire.CORNER_RADIUS_BLY_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._corner_radius_bly = result.value;
                },
                BlurRegionWire.CORNER_RADIUS_BRX_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._corner_radius_brx = result.value;
                },
                BlurRegionWire.CORNER_RADIUS_BRY_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._corner_radius_bry = result.value;
                },
                BlurRegionWire.ALPHA_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._alpha = result.value;
                },
                BlurRegionWire.LEFT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._left = result.value;
                },
                BlurRegionWire.TOP_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._top = result.value;
                },
                BlurRegionWire.RIGHT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._right = result.value;
                },
                BlurRegionWire.BOTTOM_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._bottom = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getBlurRadius(self: *const BlurRegionReader) u32 {
        return self._blur_radius;
    }
    pub inline fn getCornerRadiusTl(self: *const BlurRegionReader) u32 {
        return self._corner_radius_tl;
    }
    pub inline fn getCornerRadiusTr(self: *const BlurRegionReader) u32 {
        return self._corner_radius_tr;
    }
    pub inline fn getCornerRadiusBl(self: *const BlurRegionReader) u32 {
        return self._corner_radius_bl;
    }
    pub inline fn getCornerRadiusBr(self: *const BlurRegionReader) f32 {
        return self._corner_radius_br;
    }
    pub inline fn getCornerRadiusTlx(self: *const BlurRegionReader) f32 {
        return self._corner_radius_tlx;
    }
    pub inline fn getCornerRadiusTly(self: *const BlurRegionReader) f32 {
        return self._corner_radius_tly;
    }
    pub inline fn getCornerRadiusTrx(self: *const BlurRegionReader) f32 {
        return self._corner_radius_trx;
    }
    pub inline fn getCornerRadiusTry(self: *const BlurRegionReader) f32 {
        return self._corner_radius_try;
    }
    pub inline fn getCornerRadiusBlx(self: *const BlurRegionReader) f32 {
        return self._corner_radius_blx;
    }
    pub inline fn getCornerRadiusBly(self: *const BlurRegionReader) f32 {
        return self._corner_radius_bly;
    }
    pub inline fn getCornerRadiusBrx(self: *const BlurRegionReader) f32 {
        return self._corner_radius_brx;
    }
    pub inline fn getCornerRadiusBry(self: *const BlurRegionReader) f32 {
        return self._corner_radius_bry;
    }
    pub inline fn getAlpha(self: *const BlurRegionReader) f32 {
        return self._alpha;
    }
    pub inline fn getLeft(self: *const BlurRegionReader) i32 {
        return self._left;
    }
    pub inline fn getTop(self: *const BlurRegionReader) i32 {
        return self._top;
    }
    pub inline fn getRight(self: *const BlurRegionReader) i32 {
        return self._right;
    }
    pub inline fn getBottom(self: *const BlurRegionReader) i32 {
        return self._bottom;
    }
};
const ColorTransformProtoWire = struct {
    const VAL_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const ColorTransformProto = struct {
    // fields
    val: ?[]const f32 = null,
    pub fn calcProtobufSize(self: *const ColorTransformProto) usize {
        var res: usize = 0;
        if (self.val) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(ColorTransformProtoWire.VAL_WIRE) + gremlin.sizes.sizeFloat(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeFloat(v);
                }
                res += gremlin.sizes.sizeWireNumber(ColorTransformProtoWire.VAL_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        return res;
    }
    pub fn encode(self: *const ColorTransformProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ColorTransformProto, target: *gremlin.Writer) void {
        if (self.val) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendFloat32(ColorTransformProtoWire.VAL_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeFloat(v);
                }
                target.appendBytesTag(ColorTransformProtoWire.VAL_WIRE, packed_size);
                for (arr) |v| {
                    target.appendFloat32WithoutTag(v);
                }
            }
        }
    }
};
pub const ColorTransformProtoReader = struct {
    buf: gremlin.Reader,
    _val_offset: ?usize = null,
    _val_last_offset: ?usize = null,
    _val_packed: bool = false,
    pub fn init(src: []const u8) gremlin.Error!ColorTransformProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = ColorTransformProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ColorTransformProtoWire.VAL_WIRE => {
                    if (res._val_offset == null) {
                        res._val_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._val_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._val_offset = offset + length_result.size;
                        res._val_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._val_last_offset.?;
                    } else {
                        const result = try buf.readFloat32(offset);
                        offset += result.size;
                        res._val_last_offset = offset;
                    }
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn valNext(self: *ColorTransformProtoReader) gremlin.Error!?f32 {
        if (self._val_offset == null) return null;
        const current_offset = self._val_offset.?;
        if (current_offset >= self._val_last_offset.?) {
            self._val_offset = null;
            return null;
        }
        if (self._val_packed) {
            const value_result = try self.buf.readFloat32(current_offset);
            self._val_offset = current_offset + value_result.size;
            if (self._val_offset.? >= self._val_last_offset.?) {
                self._val_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readFloat32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._val_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == ColorTransformProtoWire.VAL_WIRE) {
                    self._val_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._val_offset = null;
            return value_result.value;
        }
    }
};
const BoxShadowSettingsWire = struct {
    const BOX_SHADOWS_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const BoxShadowSettings = struct {
    // nested structs
    const BoxShadowParamsWire = struct {
        const BLUR_RADIUS_WIRE: gremlin.ProtoWireNumber = 1;
        const SPREAD_RADIUS_WIRE: gremlin.ProtoWireNumber = 2;
        const COLOR_WIRE: gremlin.ProtoWireNumber = 3;
        const OFFSET_X_WIRE: gremlin.ProtoWireNumber = 4;
        const OFFSET_Y_WIRE: gremlin.ProtoWireNumber = 5;
    };
    pub const BoxShadowParams = struct {
        // fields
        blur_radius: f32 = 0.0,
        spread_radius: f32 = 0.0,
        color: i32 = 0,
        offset_x: f32 = 0.0,
        offset_y: f32 = 0.0,
        pub fn calcProtobufSize(self: *const BoxShadowSettings.BoxShadowParams) usize {
            var res: usize = 0;
            if (self.blur_radius != 0.0) {
                res += gremlin.sizes.sizeWireNumber(BoxShadowSettings.BoxShadowParamsWire.BLUR_RADIUS_WIRE) + gremlin.sizes.sizeFloat(self.blur_radius);
            }
            if (self.spread_radius != 0.0) {
                res += gremlin.sizes.sizeWireNumber(BoxShadowSettings.BoxShadowParamsWire.SPREAD_RADIUS_WIRE) + gremlin.sizes.sizeFloat(self.spread_radius);
            }
            if (self.color != 0) {
                res += gremlin.sizes.sizeWireNumber(BoxShadowSettings.BoxShadowParamsWire.COLOR_WIRE) + gremlin.sizes.sizeI32(self.color);
            }
            if (self.offset_x != 0.0) {
                res += gremlin.sizes.sizeWireNumber(BoxShadowSettings.BoxShadowParamsWire.OFFSET_X_WIRE) + gremlin.sizes.sizeFloat(self.offset_x);
            }
            if (self.offset_y != 0.0) {
                res += gremlin.sizes.sizeWireNumber(BoxShadowSettings.BoxShadowParamsWire.OFFSET_Y_WIRE) + gremlin.sizes.sizeFloat(self.offset_y);
            }
            return res;
        }
        pub fn encode(self: *const BoxShadowSettings.BoxShadowParams, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const BoxShadowSettings.BoxShadowParams, target: *gremlin.Writer) void {
            if (self.blur_radius != 0.0) {
                target.appendFloat32(BoxShadowSettings.BoxShadowParamsWire.BLUR_RADIUS_WIRE, self.blur_radius);
            }
            if (self.spread_radius != 0.0) {
                target.appendFloat32(BoxShadowSettings.BoxShadowParamsWire.SPREAD_RADIUS_WIRE, self.spread_radius);
            }
            if (self.color != 0) {
                target.appendInt32(BoxShadowSettings.BoxShadowParamsWire.COLOR_WIRE, self.color);
            }
            if (self.offset_x != 0.0) {
                target.appendFloat32(BoxShadowSettings.BoxShadowParamsWire.OFFSET_X_WIRE, self.offset_x);
            }
            if (self.offset_y != 0.0) {
                target.appendFloat32(BoxShadowSettings.BoxShadowParamsWire.OFFSET_Y_WIRE, self.offset_y);
            }
        }
    };
    pub const BoxShadowParamsReader = struct {
        buf: gremlin.Reader,
        _blur_radius: f32 = 0.0,
        _spread_radius: f32 = 0.0,
        _color: i32 = 0,
        _offset_x: f32 = 0.0,
        _offset_y: f32 = 0.0,
        pub fn init(src: []const u8) gremlin.Error!BoxShadowSettings.BoxShadowParamsReader {
            const buf = gremlin.Reader.init(src);
            var res = BoxShadowSettings.BoxShadowParamsReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    BoxShadowSettings.BoxShadowParamsWire.BLUR_RADIUS_WIRE => {
                        const result = try buf.readFloat32(offset);
                        offset += result.size;
                        res._blur_radius = result.value;
                    },
                    BoxShadowSettings.BoxShadowParamsWire.SPREAD_RADIUS_WIRE => {
                        const result = try buf.readFloat32(offset);
                        offset += result.size;
                        res._spread_radius = result.value;
                    },
                    BoxShadowSettings.BoxShadowParamsWire.COLOR_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._color = result.value;
                    },
                    BoxShadowSettings.BoxShadowParamsWire.OFFSET_X_WIRE => {
                        const result = try buf.readFloat32(offset);
                        offset += result.size;
                        res._offset_x = result.value;
                    },
                    BoxShadowSettings.BoxShadowParamsWire.OFFSET_Y_WIRE => {
                        const result = try buf.readFloat32(offset);
                        offset += result.size;
                        res._offset_y = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getBlurRadius(self: *const BoxShadowSettings.BoxShadowParamsReader) f32 {
            return self._blur_radius;
        }
        pub inline fn getSpreadRadius(self: *const BoxShadowSettings.BoxShadowParamsReader) f32 {
            return self._spread_radius;
        }
        pub inline fn getColor(self: *const BoxShadowSettings.BoxShadowParamsReader) i32 {
            return self._color;
        }
        pub inline fn getOffsetX(self: *const BoxShadowSettings.BoxShadowParamsReader) f32 {
            return self._offset_x;
        }
        pub inline fn getOffsetY(self: *const BoxShadowSettings.BoxShadowParamsReader) f32 {
            return self._offset_y;
        }
    };
    // fields
    box_shadows: ?[]const ?BoxShadowSettings.BoxShadowParams = null,
    pub fn calcProtobufSize(self: *const BoxShadowSettings) usize {
        var res: usize = 0;
        if (self.box_shadows) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(BoxShadowSettingsWire.BOX_SHADOWS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const BoxShadowSettings, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const BoxShadowSettings, target: *gremlin.Writer) void {
        if (self.box_shadows) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(BoxShadowSettingsWire.BOX_SHADOWS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(BoxShadowSettingsWire.BOX_SHADOWS_WIRE, 0);
                }
            }
        }
    }
};
pub const BoxShadowSettingsReader = struct {
    buf: gremlin.Reader,
    _box_shadows_offset: ?usize = null,
    _box_shadows_last_offset: ?usize = null,
    _box_shadows_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!BoxShadowSettingsReader {
        const buf = gremlin.Reader.init(src);
        var res = BoxShadowSettingsReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                BoxShadowSettingsWire.BOX_SHADOWS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._box_shadows_offset == null) {
                        res._box_shadows_offset = offset - result.size;
                    }
                    res._box_shadows_last_offset = offset;
                    res._box_shadows_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn boxShadowsCount(self: *const BoxShadowSettingsReader) usize {
        return self._box_shadows_cnt;
    }
    pub fn boxShadowsNext(self: *BoxShadowSettingsReader) ?BoxShadowSettings.BoxShadowParamsReader {
        if (self._box_shadows_offset == null) return null;
        const current_offset = self._box_shadows_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = BoxShadowSettings.BoxShadowParamsReader.init(result.value) catch return null;
        if (self._box_shadows_last_offset != null and current_offset >= self._box_shadows_last_offset.?) {
            self._box_shadows_offset = null;
            return msg;
        }
        if (self._box_shadows_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._box_shadows_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == BoxShadowSettingsWire.BOX_SHADOWS_WIRE) {
                self._box_shadows_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._box_shadows_offset = null;
        return msg;
    }
};
const BorderSettingsWire = struct {
    const STROKE_WIDTH_WIRE: gremlin.ProtoWireNumber = 1;
    const COLOR_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const BorderSettings = struct {
    // fields
    stroke_width: f32 = 0.0,
    color: i32 = 0,
    pub fn calcProtobufSize(self: *const BorderSettings) usize {
        var res: usize = 0;
        if (self.stroke_width != 0.0) {
            res += gremlin.sizes.sizeWireNumber(BorderSettingsWire.STROKE_WIDTH_WIRE) + gremlin.sizes.sizeFloat(self.stroke_width);
        }
        if (self.color != 0) {
            res += gremlin.sizes.sizeWireNumber(BorderSettingsWire.COLOR_WIRE) + gremlin.sizes.sizeI32(self.color);
        }
        return res;
    }
    pub fn encode(self: *const BorderSettings, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const BorderSettings, target: *gremlin.Writer) void {
        if (self.stroke_width != 0.0) {
            target.appendFloat32(BorderSettingsWire.STROKE_WIDTH_WIRE, self.stroke_width);
        }
        if (self.color != 0) {
            target.appendInt32(BorderSettingsWire.COLOR_WIRE, self.color);
        }
    }
};
pub const BorderSettingsReader = struct {
    buf: gremlin.Reader,
    _stroke_width: f32 = 0.0,
    _color: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!BorderSettingsReader {
        const buf = gremlin.Reader.init(src);
        var res = BorderSettingsReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                BorderSettingsWire.STROKE_WIDTH_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._stroke_width = result.value;
                },
                BorderSettingsWire.COLOR_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._color = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getStrokeWidth(self: *const BorderSettingsReader) f32 {
        return self._stroke_width;
    }
    pub inline fn getColor(self: *const BorderSettingsReader) i32 {
        return self._color;
    }
};
