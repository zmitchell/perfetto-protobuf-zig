// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
const surfaceflinger_common = @import("surfaceflinger_common.proto.zig");
const rect = @import("src/gen/protos/perfetto/trace/android/graphics/rect.proto.zig");
// enums
pub const HwcCompositionType = enum(i32) {
    HWC_TYPE_UNSPECIFIED = 0,
    HWC_TYPE_CLIENT = 1,
    HWC_TYPE_DEVICE = 2,
    HWC_TYPE_SOLID_COLOR = 3,
    HWC_TYPE_CURSOR = 4,
    HWC_TYPE_SIDEBAND = 5,
    HWC_TYPE_DISPLAY_DECORATION = 6,
};
// structs
const LayersTraceFileProtoWire = struct {
    const MAGIC_NUMBER_WIRE: gremlin.ProtoWireNumber = 1;
    const ENTRY_WIRE: gremlin.ProtoWireNumber = 2;
    const REAL_TO_ELAPSED_TIME_OFFSET_NANOS_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const LayersTraceFileProto = struct {
    // nested enums
    pub const MagicNumber = enum(i32) {
        INVALID = 0,
        MAGIC_NUMBER_L = 1414682956,
        MAGIC_NUMBER_H = 1162035538,
    };
    // fields
    magic_number: u64 = 0,
    entry: ?[]const ?LayersSnapshotProto = null,
    real_to_elapsed_time_offset_nanos: u64 = 0,
    pub fn calcProtobufSize(self: *const LayersTraceFileProto) usize {
        var res: usize = 0;
        if (self.magic_number != 0) {
            res += gremlin.sizes.sizeWireNumber(LayersTraceFileProtoWire.MAGIC_NUMBER_WIRE) + gremlin.sizes.sizeFixed64(self.magic_number);
        }
        if (self.entry) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(LayersTraceFileProtoWire.ENTRY_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.real_to_elapsed_time_offset_nanos != 0) {
            res += gremlin.sizes.sizeWireNumber(LayersTraceFileProtoWire.REAL_TO_ELAPSED_TIME_OFFSET_NANOS_WIRE) + gremlin.sizes.sizeFixed64(self.real_to_elapsed_time_offset_nanos);
        }
        return res;
    }
    pub fn encode(self: *const LayersTraceFileProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const LayersTraceFileProto, target: *gremlin.Writer) void {
        if (self.magic_number != 0) {
            target.appendFixed64(LayersTraceFileProtoWire.MAGIC_NUMBER_WIRE, self.magic_number);
        }
        if (self.entry) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(LayersTraceFileProtoWire.ENTRY_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(LayersTraceFileProtoWire.ENTRY_WIRE, 0);
                }
            }
        }
        if (self.real_to_elapsed_time_offset_nanos != 0) {
            target.appendFixed64(LayersTraceFileProtoWire.REAL_TO_ELAPSED_TIME_OFFSET_NANOS_WIRE, self.real_to_elapsed_time_offset_nanos);
        }
    }
};
pub const LayersTraceFileProtoReader = struct {
    buf: gremlin.Reader,
    _magic_number: u64 = 0,
    _entry_offset: ?usize = null,
    _entry_last_offset: ?usize = null,
    _entry_cnt: usize = 0,
    _real_to_elapsed_time_offset_nanos: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!LayersTraceFileProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = LayersTraceFileProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                LayersTraceFileProtoWire.MAGIC_NUMBER_WIRE => {
                    const result = try buf.readFixed64(offset);
                    offset += result.size;
                    res._magic_number = result.value;
                },
                LayersTraceFileProtoWire.ENTRY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._entry_offset == null) {
                        res._entry_offset = offset - result.size;
                    }
                    res._entry_last_offset = offset;
                    res._entry_cnt += 1;
                },
                LayersTraceFileProtoWire.REAL_TO_ELAPSED_TIME_OFFSET_NANOS_WIRE => {
                    const result = try buf.readFixed64(offset);
                    offset += result.size;
                    res._real_to_elapsed_time_offset_nanos = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getMagicNumber(self: *const LayersTraceFileProtoReader) u64 {
        return self._magic_number;
    }
    pub fn entryCount(self: *const LayersTraceFileProtoReader) usize {
        return self._entry_cnt;
    }
    pub fn entryNext(self: *LayersTraceFileProtoReader) ?LayersSnapshotProtoReader {
        if (self._entry_offset == null) return null;
        const current_offset = self._entry_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = LayersSnapshotProtoReader.init(result.value) catch return null;
        if (self._entry_last_offset != null and current_offset >= self._entry_last_offset.?) {
            self._entry_offset = null;
            return msg;
        }
        if (self._entry_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._entry_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == LayersTraceFileProtoWire.ENTRY_WIRE) {
                self._entry_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._entry_offset = null;
        return msg;
    }
    pub inline fn getRealToElapsedTimeOffsetNanos(self: *const LayersTraceFileProtoReader) u64 {
        return self._real_to_elapsed_time_offset_nanos;
    }
};
const LayersSnapshotProtoWire = struct {
    const ELAPSED_REALTIME_NANOS_WIRE: gremlin.ProtoWireNumber = 1;
    const WHERE_WIRE: gremlin.ProtoWireNumber = 2;
    const LAYERS_WIRE: gremlin.ProtoWireNumber = 3;
    const HWC_BLOB_WIRE: gremlin.ProtoWireNumber = 4;
    const EXCLUDES_COMPOSITION_STATE_WIRE: gremlin.ProtoWireNumber = 5;
    const MISSED_ENTRIES_WIRE: gremlin.ProtoWireNumber = 6;
    const DISPLAYS_WIRE: gremlin.ProtoWireNumber = 7;
    const VSYNC_ID_WIRE: gremlin.ProtoWireNumber = 8;
};
pub const LayersSnapshotProto = struct {
    // fields
    elapsed_realtime_nanos: i64 = 0,
    where: ?[]const u8 = null,
    layers: ?LayersProto = null,
    hwc_blob: ?[]const u8 = null,
    excludes_composition_state: bool = false,
    missed_entries: u32 = 0,
    displays: ?[]const ?DisplayProto = null,
    vsync_id: i64 = 0,
    pub fn calcProtobufSize(self: *const LayersSnapshotProto) usize {
        var res: usize = 0;
        if (self.elapsed_realtime_nanos != 0) {
            res += gremlin.sizes.sizeWireNumber(LayersSnapshotProtoWire.ELAPSED_REALTIME_NANOS_WIRE) + gremlin.sizes.sizeSFixed64(self.elapsed_realtime_nanos);
        }
        if (self.where) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(LayersSnapshotProtoWire.WHERE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.layers) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LayersSnapshotProtoWire.LAYERS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.hwc_blob) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(LayersSnapshotProtoWire.HWC_BLOB_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.excludes_composition_state != false) {
            res += gremlin.sizes.sizeWireNumber(LayersSnapshotProtoWire.EXCLUDES_COMPOSITION_STATE_WIRE) + gremlin.sizes.sizeBool(self.excludes_composition_state);
        }
        if (self.missed_entries != 0) {
            res += gremlin.sizes.sizeWireNumber(LayersSnapshotProtoWire.MISSED_ENTRIES_WIRE) + gremlin.sizes.sizeU32(self.missed_entries);
        }
        if (self.displays) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(LayersSnapshotProtoWire.DISPLAYS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.vsync_id != 0) {
            res += gremlin.sizes.sizeWireNumber(LayersSnapshotProtoWire.VSYNC_ID_WIRE) + gremlin.sizes.sizeI64(self.vsync_id);
        }
        return res;
    }
    pub fn encode(self: *const LayersSnapshotProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const LayersSnapshotProto, target: *gremlin.Writer) void {
        if (self.elapsed_realtime_nanos != 0) {
            target.appendSfixed64(LayersSnapshotProtoWire.ELAPSED_REALTIME_NANOS_WIRE, self.elapsed_realtime_nanos);
        }
        if (self.where) |v| {
            if (v.len > 0) {
                target.appendBytes(LayersSnapshotProtoWire.WHERE_WIRE, v);
            }
        }
        if (self.layers) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LayersSnapshotProtoWire.LAYERS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.hwc_blob) |v| {
            if (v.len > 0) {
                target.appendBytes(LayersSnapshotProtoWire.HWC_BLOB_WIRE, v);
            }
        }
        if (self.excludes_composition_state != false) {
            target.appendBool(LayersSnapshotProtoWire.EXCLUDES_COMPOSITION_STATE_WIRE, self.excludes_composition_state);
        }
        if (self.missed_entries != 0) {
            target.appendUint32(LayersSnapshotProtoWire.MISSED_ENTRIES_WIRE, self.missed_entries);
        }
        if (self.displays) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(LayersSnapshotProtoWire.DISPLAYS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(LayersSnapshotProtoWire.DISPLAYS_WIRE, 0);
                }
            }
        }
        if (self.vsync_id != 0) {
            target.appendInt64(LayersSnapshotProtoWire.VSYNC_ID_WIRE, self.vsync_id);
        }
    }
};
pub const LayersSnapshotProtoReader = struct {
    buf: gremlin.Reader,
    _elapsed_realtime_nanos: i64 = 0,
    _where: ?[]const u8 = null,
    _layers_buf: ?[]const u8 = null,
    _hwc_blob: ?[]const u8 = null,
    _excludes_composition_state: bool = false,
    _missed_entries: u32 = 0,
    _displays_offset: ?usize = null,
    _displays_last_offset: ?usize = null,
    _displays_cnt: usize = 0,
    _vsync_id: i64 = 0,
    pub fn init(src: []const u8) gremlin.Error!LayersSnapshotProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = LayersSnapshotProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                LayersSnapshotProtoWire.ELAPSED_REALTIME_NANOS_WIRE => {
                    const result = try buf.readSFixed64(offset);
                    offset += result.size;
                    res._elapsed_realtime_nanos = result.value;
                },
                LayersSnapshotProtoWire.WHERE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._where = result.value;
                },
                LayersSnapshotProtoWire.LAYERS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._layers_buf = result.value;
                },
                LayersSnapshotProtoWire.HWC_BLOB_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._hwc_blob = result.value;
                },
                LayersSnapshotProtoWire.EXCLUDES_COMPOSITION_STATE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._excludes_composition_state = result.value;
                },
                LayersSnapshotProtoWire.MISSED_ENTRIES_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._missed_entries = result.value;
                },
                LayersSnapshotProtoWire.DISPLAYS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._displays_offset == null) {
                        res._displays_offset = offset - result.size;
                    }
                    res._displays_last_offset = offset;
                    res._displays_cnt += 1;
                },
                LayersSnapshotProtoWire.VSYNC_ID_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._vsync_id = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getElapsedRealtimeNanos(self: *const LayersSnapshotProtoReader) i64 {
        return self._elapsed_realtime_nanos;
    }
    pub inline fn getWhere(self: *const LayersSnapshotProtoReader) []const u8 {
        return self._where orelse &[_]u8{};
    }
    pub fn getLayers(self: *const LayersSnapshotProtoReader) gremlin.Error!LayersProtoReader {
        if (self._layers_buf) |buf| {
            return try LayersProtoReader.init(buf);
        }
        return try LayersProtoReader.init(&[_]u8{});
    }
    pub inline fn getHwcBlob(self: *const LayersSnapshotProtoReader) []const u8 {
        return self._hwc_blob orelse &[_]u8{};
    }
    pub inline fn getExcludesCompositionState(self: *const LayersSnapshotProtoReader) bool {
        return self._excludes_composition_state;
    }
    pub inline fn getMissedEntries(self: *const LayersSnapshotProtoReader) u32 {
        return self._missed_entries;
    }
    pub fn displaysCount(self: *const LayersSnapshotProtoReader) usize {
        return self._displays_cnt;
    }
    pub fn displaysNext(self: *LayersSnapshotProtoReader) ?DisplayProtoReader {
        if (self._displays_offset == null) return null;
        const current_offset = self._displays_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = DisplayProtoReader.init(result.value) catch return null;
        if (self._displays_last_offset != null and current_offset >= self._displays_last_offset.?) {
            self._displays_offset = null;
            return msg;
        }
        if (self._displays_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._displays_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == LayersSnapshotProtoWire.DISPLAYS_WIRE) {
                self._displays_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._displays_offset = null;
        return msg;
    }
    pub inline fn getVsyncId(self: *const LayersSnapshotProtoReader) i64 {
        return self._vsync_id;
    }
};
const LayersProtoWire = struct {
    const LAYERS_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const LayersProto = struct {
    // fields
    layers: ?[]const ?LayerProto = null,
    pub fn calcProtobufSize(self: *const LayersProto) usize {
        var res: usize = 0;
        if (self.layers) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(LayersProtoWire.LAYERS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const LayersProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const LayersProto, target: *gremlin.Writer) void {
        if (self.layers) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(LayersProtoWire.LAYERS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(LayersProtoWire.LAYERS_WIRE, 0);
                }
            }
        }
    }
};
pub const LayersProtoReader = struct {
    buf: gremlin.Reader,
    _layers_offset: ?usize = null,
    _layers_last_offset: ?usize = null,
    _layers_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!LayersProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = LayersProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                LayersProtoWire.LAYERS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._layers_offset == null) {
                        res._layers_offset = offset - result.size;
                    }
                    res._layers_last_offset = offset;
                    res._layers_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn layersCount(self: *const LayersProtoReader) usize {
        return self._layers_cnt;
    }
    pub fn layersNext(self: *LayersProtoReader) ?LayerProtoReader {
        if (self._layers_offset == null) return null;
        const current_offset = self._layers_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = LayerProtoReader.init(result.value) catch return null;
        if (self._layers_last_offset != null and current_offset >= self._layers_last_offset.?) {
            self._layers_offset = null;
            return msg;
        }
        if (self._layers_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._layers_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == LayersProtoWire.LAYERS_WIRE) {
                self._layers_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._layers_offset = null;
        return msg;
    }
};
const DisplayProtoWire = struct {
    const ID_WIRE: gremlin.ProtoWireNumber = 1;
    const NAME_WIRE: gremlin.ProtoWireNumber = 2;
    const LAYER_STACK_WIRE: gremlin.ProtoWireNumber = 3;
    const SIZE_WIRE: gremlin.ProtoWireNumber = 4;
    const LAYER_STACK_SPACE_RECT_WIRE: gremlin.ProtoWireNumber = 5;
    const TRANSFORM_WIRE: gremlin.ProtoWireNumber = 6;
    const IS_VIRTUAL_WIRE: gremlin.ProtoWireNumber = 7;
    const DPI_X_WIRE: gremlin.ProtoWireNumber = 8;
    const DPI_Y_WIRE: gremlin.ProtoWireNumber = 9;
};
pub const DisplayProto = struct {
    // fields
    id: u64 = 0,
    name: ?[]const u8 = null,
    layer_stack: u32 = 0,
    size: ?surfaceflinger_common.SizeProto = null,
    layer_stack_space_rect: ?rect.RectProto = null,
    transform: ?surfaceflinger_common.TransformProto = null,
    is_virtual: bool = false,
    dpi_x: f64 = 0.0,
    dpi_y: f64 = 0.0,
    pub fn calcProtobufSize(self: *const DisplayProto) usize {
        var res: usize = 0;
        if (self.id != 0) {
            res += gremlin.sizes.sizeWireNumber(DisplayProtoWire.ID_WIRE) + gremlin.sizes.sizeU64(self.id);
        }
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(DisplayProtoWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.layer_stack != 0) {
            res += gremlin.sizes.sizeWireNumber(DisplayProtoWire.LAYER_STACK_WIRE) + gremlin.sizes.sizeU32(self.layer_stack);
        }
        if (self.size) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DisplayProtoWire.SIZE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.layer_stack_space_rect) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DisplayProtoWire.LAYER_STACK_SPACE_RECT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.transform) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DisplayProtoWire.TRANSFORM_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.is_virtual != false) {
            res += gremlin.sizes.sizeWireNumber(DisplayProtoWire.IS_VIRTUAL_WIRE) + gremlin.sizes.sizeBool(self.is_virtual);
        }
        if (self.dpi_x != 0.0) {
            res += gremlin.sizes.sizeWireNumber(DisplayProtoWire.DPI_X_WIRE) + gremlin.sizes.sizeDouble(self.dpi_x);
        }
        if (self.dpi_y != 0.0) {
            res += gremlin.sizes.sizeWireNumber(DisplayProtoWire.DPI_Y_WIRE) + gremlin.sizes.sizeDouble(self.dpi_y);
        }
        return res;
    }
    pub fn encode(self: *const DisplayProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const DisplayProto, target: *gremlin.Writer) void {
        if (self.id != 0) {
            target.appendUint64(DisplayProtoWire.ID_WIRE, self.id);
        }
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(DisplayProtoWire.NAME_WIRE, v);
            }
        }
        if (self.layer_stack != 0) {
            target.appendUint32(DisplayProtoWire.LAYER_STACK_WIRE, self.layer_stack);
        }
        if (self.size) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DisplayProtoWire.SIZE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.layer_stack_space_rect) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DisplayProtoWire.LAYER_STACK_SPACE_RECT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.transform) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DisplayProtoWire.TRANSFORM_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.is_virtual != false) {
            target.appendBool(DisplayProtoWire.IS_VIRTUAL_WIRE, self.is_virtual);
        }
        if (self.dpi_x != 0.0) {
            target.appendFloat64(DisplayProtoWire.DPI_X_WIRE, self.dpi_x);
        }
        if (self.dpi_y != 0.0) {
            target.appendFloat64(DisplayProtoWire.DPI_Y_WIRE, self.dpi_y);
        }
    }
};
pub const DisplayProtoReader = struct {
    buf: gremlin.Reader,
    _id: u64 = 0,
    _name: ?[]const u8 = null,
    _layer_stack: u32 = 0,
    _size_buf: ?[]const u8 = null,
    _layer_stack_space_rect_buf: ?[]const u8 = null,
    _transform_buf: ?[]const u8 = null,
    _is_virtual: bool = false,
    _dpi_x: f64 = 0.0,
    _dpi_y: f64 = 0.0,
    pub fn init(src: []const u8) gremlin.Error!DisplayProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = DisplayProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                DisplayProtoWire.ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._id = result.value;
                },
                DisplayProtoWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                DisplayProtoWire.LAYER_STACK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._layer_stack = result.value;
                },
                DisplayProtoWire.SIZE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._size_buf = result.value;
                },
                DisplayProtoWire.LAYER_STACK_SPACE_RECT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._layer_stack_space_rect_buf = result.value;
                },
                DisplayProtoWire.TRANSFORM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._transform_buf = result.value;
                },
                DisplayProtoWire.IS_VIRTUAL_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_virtual = result.value;
                },
                DisplayProtoWire.DPI_X_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._dpi_x = result.value;
                },
                DisplayProtoWire.DPI_Y_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._dpi_y = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getId(self: *const DisplayProtoReader) u64 {
        return self._id;
    }
    pub inline fn getName(self: *const DisplayProtoReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub inline fn getLayerStack(self: *const DisplayProtoReader) u32 {
        return self._layer_stack;
    }
    pub fn getSize(self: *const DisplayProtoReader) gremlin.Error!surfaceflinger_common.SizeProtoReader {
        if (self._size_buf) |buf| {
            return try surfaceflinger_common.SizeProtoReader.init(buf);
        }
        return try surfaceflinger_common.SizeProtoReader.init(&[_]u8{});
    }
    pub fn getLayerStackSpaceRect(self: *const DisplayProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._layer_stack_space_rect_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getTransform(self: *const DisplayProtoReader) gremlin.Error!surfaceflinger_common.TransformProtoReader {
        if (self._transform_buf) |buf| {
            return try surfaceflinger_common.TransformProtoReader.init(buf);
        }
        return try surfaceflinger_common.TransformProtoReader.init(&[_]u8{});
    }
    pub inline fn getIsVirtual(self: *const DisplayProtoReader) bool {
        return self._is_virtual;
    }
    pub inline fn getDpiX(self: *const DisplayProtoReader) f64 {
        return self._dpi_x;
    }
    pub inline fn getDpiY(self: *const DisplayProtoReader) f64 {
        return self._dpi_y;
    }
};
const LayerProtoWire = struct {
    const ID_WIRE: gremlin.ProtoWireNumber = 1;
    const NAME_WIRE: gremlin.ProtoWireNumber = 2;
    const CHILDREN_WIRE: gremlin.ProtoWireNumber = 3;
    const RELATIVES_WIRE: gremlin.ProtoWireNumber = 4;
    const TYPE_WIRE: gremlin.ProtoWireNumber = 5;
    const TRANSPARENT_REGION_WIRE: gremlin.ProtoWireNumber = 6;
    const VISIBLE_REGION_WIRE: gremlin.ProtoWireNumber = 7;
    const DAMAGE_REGION_WIRE: gremlin.ProtoWireNumber = 8;
    const LAYER_STACK_WIRE: gremlin.ProtoWireNumber = 9;
    const Z_WIRE: gremlin.ProtoWireNumber = 10;
    const POSITION_WIRE: gremlin.ProtoWireNumber = 11;
    const REQUESTED_POSITION_WIRE: gremlin.ProtoWireNumber = 12;
    const SIZE_WIRE: gremlin.ProtoWireNumber = 13;
    const CROP_WIRE: gremlin.ProtoWireNumber = 14;
    const FINAL_CROP_WIRE: gremlin.ProtoWireNumber = 15;
    const IS_OPAQUE_WIRE: gremlin.ProtoWireNumber = 16;
    const INVALIDATE_WIRE: gremlin.ProtoWireNumber = 17;
    const DATASPACE_WIRE: gremlin.ProtoWireNumber = 18;
    const PIXEL_FORMAT_WIRE: gremlin.ProtoWireNumber = 19;
    const COLOR_WIRE: gremlin.ProtoWireNumber = 20;
    const REQUESTED_COLOR_WIRE: gremlin.ProtoWireNumber = 21;
    const FLAGS_WIRE: gremlin.ProtoWireNumber = 22;
    const TRANSFORM_WIRE: gremlin.ProtoWireNumber = 23;
    const REQUESTED_TRANSFORM_WIRE: gremlin.ProtoWireNumber = 24;
    const PARENT_WIRE: gremlin.ProtoWireNumber = 25;
    const Z_ORDER_RELATIVE_OF_WIRE: gremlin.ProtoWireNumber = 26;
    const ACTIVE_BUFFER_WIRE: gremlin.ProtoWireNumber = 27;
    const QUEUED_FRAMES_WIRE: gremlin.ProtoWireNumber = 28;
    const REFRESH_PENDING_WIRE: gremlin.ProtoWireNumber = 29;
    const HWC_FRAME_WIRE: gremlin.ProtoWireNumber = 30;
    const HWC_CROP_WIRE: gremlin.ProtoWireNumber = 31;
    const HWC_TRANSFORM_WIRE: gremlin.ProtoWireNumber = 32;
    const WINDOW_TYPE_WIRE: gremlin.ProtoWireNumber = 33;
    const APP_ID_WIRE: gremlin.ProtoWireNumber = 34;
    const HWC_COMPOSITION_TYPE_WIRE: gremlin.ProtoWireNumber = 35;
    const IS_PROTECTED_WIRE: gremlin.ProtoWireNumber = 36;
    const CURR_FRAME_WIRE: gremlin.ProtoWireNumber = 37;
    const BARRIER_LAYER_WIRE: gremlin.ProtoWireNumber = 38;
    const BUFFER_TRANSFORM_WIRE: gremlin.ProtoWireNumber = 39;
    const EFFECTIVE_SCALING_MODE_WIRE: gremlin.ProtoWireNumber = 40;
    const CORNER_RADIUS_WIRE: gremlin.ProtoWireNumber = 41;
    const EFFECTIVE_TRANSFORM_WIRE: gremlin.ProtoWireNumber = 43;
    const SOURCE_BOUNDS_WIRE: gremlin.ProtoWireNumber = 44;
    const BOUNDS_WIRE: gremlin.ProtoWireNumber = 45;
    const SCREEN_BOUNDS_WIRE: gremlin.ProtoWireNumber = 46;
    const INPUT_WINDOW_INFO_WIRE: gremlin.ProtoWireNumber = 47;
    const CORNER_RADIUS_CROP_WIRE: gremlin.ProtoWireNumber = 48;
    const SHADOW_RADIUS_WIRE: gremlin.ProtoWireNumber = 49;
    const COLOR_TRANSFORM_WIRE: gremlin.ProtoWireNumber = 50;
    const IS_RELATIVE_OF_WIRE: gremlin.ProtoWireNumber = 51;
    const BACKGROUND_BLUR_RADIUS_WIRE: gremlin.ProtoWireNumber = 52;
    const OWNER_UID_WIRE: gremlin.ProtoWireNumber = 53;
    const BLUR_REGIONS_WIRE: gremlin.ProtoWireNumber = 54;
    const IS_TRUSTED_OVERLAY_WIRE: gremlin.ProtoWireNumber = 55;
    const REQUESTED_CORNER_RADIUS_WIRE: gremlin.ProtoWireNumber = 56;
    const DESTINATION_FRAME_WIRE: gremlin.ProtoWireNumber = 57;
    const ORIGINAL_ID_WIRE: gremlin.ProtoWireNumber = 58;
    const TRUSTED_OVERLAY_WIRE: gremlin.ProtoWireNumber = 59;
    const BACKGROUND_BLUR_SCALE_WIRE: gremlin.ProtoWireNumber = 60;
    const CORNER_RADII_WIRE: gremlin.ProtoWireNumber = 61;
    const REQUESTED_CORNER_RADII_WIRE: gremlin.ProtoWireNumber = 62;
    const CLIENT_DRAWN_CORNER_RADII_WIRE: gremlin.ProtoWireNumber = 63;
    const SYSTEM_CONTENT_PRIORITY_WIRE: gremlin.ProtoWireNumber = 64;
    const BOX_SHADOW_SETTINGS_WIRE: gremlin.ProtoWireNumber = 65;
    const BORDER_SETTINGS_WIRE: gremlin.ProtoWireNumber = 66;
    const EFFECTIVE_RADII_WIRE: gremlin.ProtoWireNumber = 67;
    const METADATA_WIRE: gremlin.ProtoWireNumber = 42;
};
pub const LayerProto = struct {
    // fields
    id: i32 = 0,
    name: ?[]const u8 = null,
    children: ?[]const i32 = null,
    relatives: ?[]const i32 = null,
    type: ?[]const u8 = null,
    transparent_region: ?surfaceflinger_common.RegionProto = null,
    visible_region: ?surfaceflinger_common.RegionProto = null,
    damage_region: ?surfaceflinger_common.RegionProto = null,
    layer_stack: u32 = 0,
    z: i32 = 0,
    position: ?PositionProto = null,
    requested_position: ?PositionProto = null,
    size: ?surfaceflinger_common.SizeProto = null,
    crop: ?rect.RectProto = null,
    final_crop: ?rect.RectProto = null,
    is_opaque: bool = false,
    invalidate: bool = false,
    dataspace: ?[]const u8 = null,
    pixel_format: ?[]const u8 = null,
    color: ?surfaceflinger_common.ColorProto = null,
    requested_color: ?surfaceflinger_common.ColorProto = null,
    flags: u32 = 0,
    transform: ?surfaceflinger_common.TransformProto = null,
    requested_transform: ?surfaceflinger_common.TransformProto = null,
    parent: i32 = 0,
    z_order_relative_of: i32 = 0,
    active_buffer: ?ActiveBufferProto = null,
    queued_frames: i32 = 0,
    refresh_pending: bool = false,
    hwc_frame: ?rect.RectProto = null,
    hwc_crop: ?FloatRectProto = null,
    hwc_transform: i32 = 0,
    window_type: i32 = 0,
    app_id: i32 = 0,
    hwc_composition_type: HwcCompositionType = @enumFromInt(0),
    is_protected: bool = false,
    curr_frame: u64 = 0,
    barrier_layer: ?[]const ?BarrierLayerProto = null,
    buffer_transform: ?surfaceflinger_common.TransformProto = null,
    effective_scaling_mode: i32 = 0,
    corner_radius: f32 = 0.0,
    effective_transform: ?surfaceflinger_common.TransformProto = null,
    source_bounds: ?FloatRectProto = null,
    bounds: ?FloatRectProto = null,
    screen_bounds: ?FloatRectProto = null,
    input_window_info: ?surfaceflinger_common.InputWindowInfoProto = null,
    corner_radius_crop: ?FloatRectProto = null,
    shadow_radius: f32 = 0.0,
    color_transform: ?surfaceflinger_common.ColorTransformProto = null,
    is_relative_of: bool = false,
    background_blur_radius: i32 = 0,
    owner_uid: u32 = 0,
    blur_regions: ?[]const ?surfaceflinger_common.BlurRegion = null,
    is_trusted_overlay: bool = false,
    requested_corner_radius: f32 = 0.0,
    destination_frame: ?rect.RectProto = null,
    original_id: u32 = 0,
    trusted_overlay: surfaceflinger_common.TrustedOverlay = @enumFromInt(0),
    background_blur_scale: f32 = 0.0,
    corner_radii: ?CornerRadiiProto = null,
    requested_corner_radii: ?CornerRadiiProto = null,
    client_drawn_corner_radii: ?CornerRadiiProto = null,
    system_content_priority: i32 = 0,
    box_shadow_settings: ?surfaceflinger_common.BoxShadowSettings = null,
    border_settings: ?surfaceflinger_common.BorderSettings = null,
    effective_radii: ?CornerRadiiProto = null,
    metadata: ?*std.AutoHashMap(i32, []const u8) = null,
    pub fn calcProtobufSize(self: *const LayerProto) usize {
        var res: usize = 0;
        if (self.id != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerProtoWire.ID_WIRE) + gremlin.sizes.sizeI32(self.id);
        }
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerProtoWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.children) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(LayerProtoWire.CHILDREN_WIRE) + gremlin.sizes.sizeI32(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(v);
                }
                res += gremlin.sizes.sizeWireNumber(LayerProtoWire.CHILDREN_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.relatives) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(LayerProtoWire.RELATIVES_WIRE) + gremlin.sizes.sizeI32(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(v);
                }
                res += gremlin.sizes.sizeWireNumber(LayerProtoWire.RELATIVES_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.type) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerProtoWire.TYPE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.transparent_region) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerProtoWire.TRANSPARENT_REGION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.visible_region) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerProtoWire.VISIBLE_REGION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.damage_region) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerProtoWire.DAMAGE_REGION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.layer_stack != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerProtoWire.LAYER_STACK_WIRE) + gremlin.sizes.sizeU32(self.layer_stack);
        }
        if (self.z != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerProtoWire.Z_WIRE) + gremlin.sizes.sizeI32(self.z);
        }
        if (self.position) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerProtoWire.POSITION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.requested_position) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerProtoWire.REQUESTED_POSITION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.size) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerProtoWire.SIZE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.crop) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerProtoWire.CROP_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.final_crop) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerProtoWire.FINAL_CROP_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.is_opaque != false) {
            res += gremlin.sizes.sizeWireNumber(LayerProtoWire.IS_OPAQUE_WIRE) + gremlin.sizes.sizeBool(self.is_opaque);
        }
        if (self.invalidate != false) {
            res += gremlin.sizes.sizeWireNumber(LayerProtoWire.INVALIDATE_WIRE) + gremlin.sizes.sizeBool(self.invalidate);
        }
        if (self.dataspace) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerProtoWire.DATASPACE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.pixel_format) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerProtoWire.PIXEL_FORMAT_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.color) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerProtoWire.COLOR_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.requested_color) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerProtoWire.REQUESTED_COLOR_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.flags != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerProtoWire.FLAGS_WIRE) + gremlin.sizes.sizeU32(self.flags);
        }
        if (self.transform) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerProtoWire.TRANSFORM_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.requested_transform) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerProtoWire.REQUESTED_TRANSFORM_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.parent != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerProtoWire.PARENT_WIRE) + gremlin.sizes.sizeI32(self.parent);
        }
        if (self.z_order_relative_of != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerProtoWire.Z_ORDER_RELATIVE_OF_WIRE) + gremlin.sizes.sizeI32(self.z_order_relative_of);
        }
        if (self.active_buffer) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerProtoWire.ACTIVE_BUFFER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.queued_frames != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerProtoWire.QUEUED_FRAMES_WIRE) + gremlin.sizes.sizeI32(self.queued_frames);
        }
        if (self.refresh_pending != false) {
            res += gremlin.sizes.sizeWireNumber(LayerProtoWire.REFRESH_PENDING_WIRE) + gremlin.sizes.sizeBool(self.refresh_pending);
        }
        if (self.hwc_frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerProtoWire.HWC_FRAME_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.hwc_crop) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerProtoWire.HWC_CROP_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.hwc_transform != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerProtoWire.HWC_TRANSFORM_WIRE) + gremlin.sizes.sizeI32(self.hwc_transform);
        }
        if (self.window_type != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerProtoWire.WINDOW_TYPE_WIRE) + gremlin.sizes.sizeI32(self.window_type);
        }
        if (self.app_id != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerProtoWire.APP_ID_WIRE) + gremlin.sizes.sizeI32(self.app_id);
        }
        if (@intFromEnum(self.hwc_composition_type) != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerProtoWire.HWC_COMPOSITION_TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.hwc_composition_type));
        }
        if (self.is_protected != false) {
            res += gremlin.sizes.sizeWireNumber(LayerProtoWire.IS_PROTECTED_WIRE) + gremlin.sizes.sizeBool(self.is_protected);
        }
        if (self.curr_frame != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerProtoWire.CURR_FRAME_WIRE) + gremlin.sizes.sizeU64(self.curr_frame);
        }
        if (self.barrier_layer) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(LayerProtoWire.BARRIER_LAYER_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.buffer_transform) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerProtoWire.BUFFER_TRANSFORM_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.effective_scaling_mode != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerProtoWire.EFFECTIVE_SCALING_MODE_WIRE) + gremlin.sizes.sizeI32(self.effective_scaling_mode);
        }
        if (self.corner_radius != 0.0) {
            res += gremlin.sizes.sizeWireNumber(LayerProtoWire.CORNER_RADIUS_WIRE) + gremlin.sizes.sizeFloat(self.corner_radius);
        }
        if (self.effective_transform) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerProtoWire.EFFECTIVE_TRANSFORM_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.source_bounds) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerProtoWire.SOURCE_BOUNDS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.bounds) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerProtoWire.BOUNDS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.screen_bounds) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerProtoWire.SCREEN_BOUNDS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.input_window_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerProtoWire.INPUT_WINDOW_INFO_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.corner_radius_crop) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerProtoWire.CORNER_RADIUS_CROP_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.shadow_radius != 0.0) {
            res += gremlin.sizes.sizeWireNumber(LayerProtoWire.SHADOW_RADIUS_WIRE) + gremlin.sizes.sizeFloat(self.shadow_radius);
        }
        if (self.color_transform) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerProtoWire.COLOR_TRANSFORM_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.is_relative_of != false) {
            res += gremlin.sizes.sizeWireNumber(LayerProtoWire.IS_RELATIVE_OF_WIRE) + gremlin.sizes.sizeBool(self.is_relative_of);
        }
        if (self.background_blur_radius != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerProtoWire.BACKGROUND_BLUR_RADIUS_WIRE) + gremlin.sizes.sizeI32(self.background_blur_radius);
        }
        if (self.owner_uid != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerProtoWire.OWNER_UID_WIRE) + gremlin.sizes.sizeU32(self.owner_uid);
        }
        if (self.blur_regions) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(LayerProtoWire.BLUR_REGIONS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.is_trusted_overlay != false) {
            res += gremlin.sizes.sizeWireNumber(LayerProtoWire.IS_TRUSTED_OVERLAY_WIRE) + gremlin.sizes.sizeBool(self.is_trusted_overlay);
        }
        if (self.requested_corner_radius != 0.0) {
            res += gremlin.sizes.sizeWireNumber(LayerProtoWire.REQUESTED_CORNER_RADIUS_WIRE) + gremlin.sizes.sizeFloat(self.requested_corner_radius);
        }
        if (self.destination_frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerProtoWire.DESTINATION_FRAME_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.original_id != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerProtoWire.ORIGINAL_ID_WIRE) + gremlin.sizes.sizeU32(self.original_id);
        }
        if (@intFromEnum(self.trusted_overlay) != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerProtoWire.TRUSTED_OVERLAY_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.trusted_overlay));
        }
        if (self.background_blur_scale != 0.0) {
            res += gremlin.sizes.sizeWireNumber(LayerProtoWire.BACKGROUND_BLUR_SCALE_WIRE) + gremlin.sizes.sizeFloat(self.background_blur_scale);
        }
        if (self.corner_radii) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerProtoWire.CORNER_RADII_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.requested_corner_radii) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerProtoWire.REQUESTED_CORNER_RADII_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.client_drawn_corner_radii) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerProtoWire.CLIENT_DRAWN_CORNER_RADII_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.system_content_priority != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerProtoWire.SYSTEM_CONTENT_PRIORITY_WIRE) + gremlin.sizes.sizeI32(self.system_content_priority);
        }
        if (self.box_shadow_settings) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerProtoWire.BOX_SHADOW_SETTINGS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.border_settings) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerProtoWire.BORDER_SETTINGS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.effective_radii) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerProtoWire.EFFECTIVE_RADII_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.metadata) |v| {
            var it = v.iterator();
            const entry_wire = gremlin.sizes.sizeWireNumber(LayerProtoWire.METADATA_WIRE);
            while (it.next()) |entry| {
                const key = entry.key_ptr.*;
                const key_size = gremlin.sizes.sizeI32(key);
                const value = entry.value_ptr.*;
                const value_size = gremlin.sizes.sizeUsize(value.len) + value.len;
                const entry_size = key_size + value_size + gremlin.sizes.sizeWireNumber(1) + gremlin.sizes.sizeWireNumber(2);
                res += entry_wire + gremlin.sizes.sizeUsize(entry_size) + entry_size;
            }
        }
        return res;
    }
    pub fn encode(self: *const LayerProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const LayerProto, target: *gremlin.Writer) void {
        if (self.id != 0) {
            target.appendInt32(LayerProtoWire.ID_WIRE, self.id);
        }
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(LayerProtoWire.NAME_WIRE, v);
            }
        }
        if (self.children) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt32(LayerProtoWire.CHILDREN_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(v);
                }
                target.appendBytesTag(LayerProtoWire.CHILDREN_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt32WithoutTag(v);
                }
            }
        }
        if (self.relatives) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt32(LayerProtoWire.RELATIVES_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(v);
                }
                target.appendBytesTag(LayerProtoWire.RELATIVES_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt32WithoutTag(v);
                }
            }
        }
        if (self.type) |v| {
            if (v.len > 0) {
                target.appendBytes(LayerProtoWire.TYPE_WIRE, v);
            }
        }
        if (self.transparent_region) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LayerProtoWire.TRANSPARENT_REGION_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.visible_region) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LayerProtoWire.VISIBLE_REGION_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.damage_region) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LayerProtoWire.DAMAGE_REGION_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.layer_stack != 0) {
            target.appendUint32(LayerProtoWire.LAYER_STACK_WIRE, self.layer_stack);
        }
        if (self.z != 0) {
            target.appendInt32(LayerProtoWire.Z_WIRE, self.z);
        }
        if (self.position) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LayerProtoWire.POSITION_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.requested_position) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LayerProtoWire.REQUESTED_POSITION_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.size) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LayerProtoWire.SIZE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.crop) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LayerProtoWire.CROP_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.final_crop) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LayerProtoWire.FINAL_CROP_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.is_opaque != false) {
            target.appendBool(LayerProtoWire.IS_OPAQUE_WIRE, self.is_opaque);
        }
        if (self.invalidate != false) {
            target.appendBool(LayerProtoWire.INVALIDATE_WIRE, self.invalidate);
        }
        if (self.dataspace) |v| {
            if (v.len > 0) {
                target.appendBytes(LayerProtoWire.DATASPACE_WIRE, v);
            }
        }
        if (self.pixel_format) |v| {
            if (v.len > 0) {
                target.appendBytes(LayerProtoWire.PIXEL_FORMAT_WIRE, v);
            }
        }
        if (self.color) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LayerProtoWire.COLOR_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.requested_color) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LayerProtoWire.REQUESTED_COLOR_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.flags != 0) {
            target.appendUint32(LayerProtoWire.FLAGS_WIRE, self.flags);
        }
        if (self.transform) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LayerProtoWire.TRANSFORM_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.requested_transform) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LayerProtoWire.REQUESTED_TRANSFORM_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.parent != 0) {
            target.appendInt32(LayerProtoWire.PARENT_WIRE, self.parent);
        }
        if (self.z_order_relative_of != 0) {
            target.appendInt32(LayerProtoWire.Z_ORDER_RELATIVE_OF_WIRE, self.z_order_relative_of);
        }
        if (self.active_buffer) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LayerProtoWire.ACTIVE_BUFFER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.queued_frames != 0) {
            target.appendInt32(LayerProtoWire.QUEUED_FRAMES_WIRE, self.queued_frames);
        }
        if (self.refresh_pending != false) {
            target.appendBool(LayerProtoWire.REFRESH_PENDING_WIRE, self.refresh_pending);
        }
        if (self.hwc_frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LayerProtoWire.HWC_FRAME_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.hwc_crop) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LayerProtoWire.HWC_CROP_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.hwc_transform != 0) {
            target.appendInt32(LayerProtoWire.HWC_TRANSFORM_WIRE, self.hwc_transform);
        }
        if (self.window_type != 0) {
            target.appendInt32(LayerProtoWire.WINDOW_TYPE_WIRE, self.window_type);
        }
        if (self.app_id != 0) {
            target.appendInt32(LayerProtoWire.APP_ID_WIRE, self.app_id);
        }
        if (@intFromEnum(self.hwc_composition_type) != 0) {
            target.appendInt32(LayerProtoWire.HWC_COMPOSITION_TYPE_WIRE, @intFromEnum(self.hwc_composition_type));
        }
        if (self.is_protected != false) {
            target.appendBool(LayerProtoWire.IS_PROTECTED_WIRE, self.is_protected);
        }
        if (self.curr_frame != 0) {
            target.appendUint64(LayerProtoWire.CURR_FRAME_WIRE, self.curr_frame);
        }
        if (self.barrier_layer) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(LayerProtoWire.BARRIER_LAYER_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(LayerProtoWire.BARRIER_LAYER_WIRE, 0);
                }
            }
        }
        if (self.buffer_transform) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LayerProtoWire.BUFFER_TRANSFORM_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.effective_scaling_mode != 0) {
            target.appendInt32(LayerProtoWire.EFFECTIVE_SCALING_MODE_WIRE, self.effective_scaling_mode);
        }
        if (self.corner_radius != 0.0) {
            target.appendFloat32(LayerProtoWire.CORNER_RADIUS_WIRE, self.corner_radius);
        }
        if (self.effective_transform) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LayerProtoWire.EFFECTIVE_TRANSFORM_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.source_bounds) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LayerProtoWire.SOURCE_BOUNDS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.bounds) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LayerProtoWire.BOUNDS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.screen_bounds) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LayerProtoWire.SCREEN_BOUNDS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.input_window_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LayerProtoWire.INPUT_WINDOW_INFO_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.corner_radius_crop) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LayerProtoWire.CORNER_RADIUS_CROP_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.shadow_radius != 0.0) {
            target.appendFloat32(LayerProtoWire.SHADOW_RADIUS_WIRE, self.shadow_radius);
        }
        if (self.color_transform) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LayerProtoWire.COLOR_TRANSFORM_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.is_relative_of != false) {
            target.appendBool(LayerProtoWire.IS_RELATIVE_OF_WIRE, self.is_relative_of);
        }
        if (self.background_blur_radius != 0) {
            target.appendInt32(LayerProtoWire.BACKGROUND_BLUR_RADIUS_WIRE, self.background_blur_radius);
        }
        if (self.owner_uid != 0) {
            target.appendUint32(LayerProtoWire.OWNER_UID_WIRE, self.owner_uid);
        }
        if (self.blur_regions) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(LayerProtoWire.BLUR_REGIONS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(LayerProtoWire.BLUR_REGIONS_WIRE, 0);
                }
            }
        }
        if (self.is_trusted_overlay != false) {
            target.appendBool(LayerProtoWire.IS_TRUSTED_OVERLAY_WIRE, self.is_trusted_overlay);
        }
        if (self.requested_corner_radius != 0.0) {
            target.appendFloat32(LayerProtoWire.REQUESTED_CORNER_RADIUS_WIRE, self.requested_corner_radius);
        }
        if (self.destination_frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LayerProtoWire.DESTINATION_FRAME_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.original_id != 0) {
            target.appendUint32(LayerProtoWire.ORIGINAL_ID_WIRE, self.original_id);
        }
        if (@intFromEnum(self.trusted_overlay) != 0) {
            target.appendInt32(LayerProtoWire.TRUSTED_OVERLAY_WIRE, @intFromEnum(self.trusted_overlay));
        }
        if (self.background_blur_scale != 0.0) {
            target.appendFloat32(LayerProtoWire.BACKGROUND_BLUR_SCALE_WIRE, self.background_blur_scale);
        }
        if (self.corner_radii) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LayerProtoWire.CORNER_RADII_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.requested_corner_radii) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LayerProtoWire.REQUESTED_CORNER_RADII_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.client_drawn_corner_radii) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LayerProtoWire.CLIENT_DRAWN_CORNER_RADII_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.system_content_priority != 0) {
            target.appendInt32(LayerProtoWire.SYSTEM_CONTENT_PRIORITY_WIRE, self.system_content_priority);
        }
        if (self.box_shadow_settings) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LayerProtoWire.BOX_SHADOW_SETTINGS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.border_settings) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LayerProtoWire.BORDER_SETTINGS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.effective_radii) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LayerProtoWire.EFFECTIVE_RADII_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.metadata) |v| {
            var it = v.iterator();
            while (it.next()) |entry| {
                const key = entry.key_ptr.*;
                const key_size = gremlin.sizes.sizeI32(key);
                const value = entry.value_ptr.*;
                const value_size = gremlin.sizes.sizeUsize(value.len) + value.len;
                const entry_size = key_size + value_size + gremlin.sizes.sizeWireNumber(1) + gremlin.sizes.sizeWireNumber(2);
                target.appendBytesTag(LayerProtoWire.METADATA_WIRE, entry_size);
                target.appendInt32(1, key);
                target.appendBytes(2, value);
            }
        }
    }
};
pub const LayerProtoReader = struct {
    pub const MetadataEntry = struct {
        key: i32,
        value: []const u8,
    };
    buf: gremlin.Reader,
    _id: i32 = 0,
    _name: ?[]const u8 = null,
    _children_offset: ?usize = null,
    _children_last_offset: ?usize = null,
    _children_packed: bool = false,
    _relatives_offset: ?usize = null,
    _relatives_last_offset: ?usize = null,
    _relatives_packed: bool = false,
    _type: ?[]const u8 = null,
    _transparent_region_buf: ?[]const u8 = null,
    _visible_region_buf: ?[]const u8 = null,
    _damage_region_buf: ?[]const u8 = null,
    _layer_stack: u32 = 0,
    _z: i32 = 0,
    _position_buf: ?[]const u8 = null,
    _requested_position_buf: ?[]const u8 = null,
    _size_buf: ?[]const u8 = null,
    _crop_buf: ?[]const u8 = null,
    _final_crop_buf: ?[]const u8 = null,
    _is_opaque: bool = false,
    _invalidate: bool = false,
    _dataspace: ?[]const u8 = null,
    _pixel_format: ?[]const u8 = null,
    _color_buf: ?[]const u8 = null,
    _requested_color_buf: ?[]const u8 = null,
    _flags: u32 = 0,
    _transform_buf: ?[]const u8 = null,
    _requested_transform_buf: ?[]const u8 = null,
    _parent: i32 = 0,
    _z_order_relative_of: i32 = 0,
    _active_buffer_buf: ?[]const u8 = null,
    _queued_frames: i32 = 0,
    _refresh_pending: bool = false,
    _hwc_frame_buf: ?[]const u8 = null,
    _hwc_crop_buf: ?[]const u8 = null,
    _hwc_transform: i32 = 0,
    _window_type: i32 = 0,
    _app_id: i32 = 0,
    _hwc_composition_type: HwcCompositionType = @enumFromInt(0),
    _is_protected: bool = false,
    _curr_frame: u64 = 0,
    _barrier_layer_offset: ?usize = null,
    _barrier_layer_last_offset: ?usize = null,
    _barrier_layer_cnt: usize = 0,
    _buffer_transform_buf: ?[]const u8 = null,
    _effective_scaling_mode: i32 = 0,
    _corner_radius: f32 = 0.0,
    _effective_transform_buf: ?[]const u8 = null,
    _source_bounds_buf: ?[]const u8 = null,
    _bounds_buf: ?[]const u8 = null,
    _screen_bounds_buf: ?[]const u8 = null,
    _input_window_info_buf: ?[]const u8 = null,
    _corner_radius_crop_buf: ?[]const u8 = null,
    _shadow_radius: f32 = 0.0,
    _color_transform_buf: ?[]const u8 = null,
    _is_relative_of: bool = false,
    _background_blur_radius: i32 = 0,
    _owner_uid: u32 = 0,
    _blur_regions_offset: ?usize = null,
    _blur_regions_last_offset: ?usize = null,
    _blur_regions_cnt: usize = 0,
    _is_trusted_overlay: bool = false,
    _requested_corner_radius: f32 = 0.0,
    _destination_frame_buf: ?[]const u8 = null,
    _original_id: u32 = 0,
    _trusted_overlay: surfaceflinger_common.TrustedOverlay = @enumFromInt(0),
    _background_blur_scale: f32 = 0.0,
    _corner_radii_buf: ?[]const u8 = null,
    _requested_corner_radii_buf: ?[]const u8 = null,
    _client_drawn_corner_radii_buf: ?[]const u8 = null,
    _system_content_priority: i32 = 0,
    _box_shadow_settings_buf: ?[]const u8 = null,
    _border_settings_buf: ?[]const u8 = null,
    _effective_radii_buf: ?[]const u8 = null,
    _metadata_offset: ?usize = null,
    _metadata_last_offset: ?usize = null,
    _metadata_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!LayerProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = LayerProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                LayerProtoWire.ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._id = result.value;
                },
                LayerProtoWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                LayerProtoWire.CHILDREN_WIRE => {
                    if (res._children_offset == null) {
                        res._children_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._children_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._children_offset = offset + length_result.size;
                        res._children_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._children_last_offset.?;
                    } else {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._children_last_offset = offset;
                    }
                },
                LayerProtoWire.RELATIVES_WIRE => {
                    if (res._relatives_offset == null) {
                        res._relatives_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._relatives_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._relatives_offset = offset + length_result.size;
                        res._relatives_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._relatives_last_offset.?;
                    } else {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._relatives_last_offset = offset;
                    }
                },
                LayerProtoWire.TYPE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._type = result.value;
                },
                LayerProtoWire.TRANSPARENT_REGION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._transparent_region_buf = result.value;
                },
                LayerProtoWire.VISIBLE_REGION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._visible_region_buf = result.value;
                },
                LayerProtoWire.DAMAGE_REGION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._damage_region_buf = result.value;
                },
                LayerProtoWire.LAYER_STACK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._layer_stack = result.value;
                },
                LayerProtoWire.Z_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._z = result.value;
                },
                LayerProtoWire.POSITION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._position_buf = result.value;
                },
                LayerProtoWire.REQUESTED_POSITION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._requested_position_buf = result.value;
                },
                LayerProtoWire.SIZE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._size_buf = result.value;
                },
                LayerProtoWire.CROP_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._crop_buf = result.value;
                },
                LayerProtoWire.FINAL_CROP_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._final_crop_buf = result.value;
                },
                LayerProtoWire.IS_OPAQUE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_opaque = result.value;
                },
                LayerProtoWire.INVALIDATE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._invalidate = result.value;
                },
                LayerProtoWire.DATASPACE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dataspace = result.value;
                },
                LayerProtoWire.PIXEL_FORMAT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._pixel_format = result.value;
                },
                LayerProtoWire.COLOR_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._color_buf = result.value;
                },
                LayerProtoWire.REQUESTED_COLOR_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._requested_color_buf = result.value;
                },
                LayerProtoWire.FLAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._flags = result.value;
                },
                LayerProtoWire.TRANSFORM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._transform_buf = result.value;
                },
                LayerProtoWire.REQUESTED_TRANSFORM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._requested_transform_buf = result.value;
                },
                LayerProtoWire.PARENT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._parent = result.value;
                },
                LayerProtoWire.Z_ORDER_RELATIVE_OF_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._z_order_relative_of = result.value;
                },
                LayerProtoWire.ACTIVE_BUFFER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._active_buffer_buf = result.value;
                },
                LayerProtoWire.QUEUED_FRAMES_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._queued_frames = result.value;
                },
                LayerProtoWire.REFRESH_PENDING_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._refresh_pending = result.value;
                },
                LayerProtoWire.HWC_FRAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._hwc_frame_buf = result.value;
                },
                LayerProtoWire.HWC_CROP_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._hwc_crop_buf = result.value;
                },
                LayerProtoWire.HWC_TRANSFORM_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._hwc_transform = result.value;
                },
                LayerProtoWire.WINDOW_TYPE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._window_type = result.value;
                },
                LayerProtoWire.APP_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._app_id = result.value;
                },
                LayerProtoWire.HWC_COMPOSITION_TYPE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._hwc_composition_type = @enumFromInt(result.value);
                },
                LayerProtoWire.IS_PROTECTED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_protected = result.value;
                },
                LayerProtoWire.CURR_FRAME_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._curr_frame = result.value;
                },
                LayerProtoWire.BARRIER_LAYER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._barrier_layer_offset == null) {
                        res._barrier_layer_offset = offset - result.size;
                    }
                    res._barrier_layer_last_offset = offset;
                    res._barrier_layer_cnt += 1;
                },
                LayerProtoWire.BUFFER_TRANSFORM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._buffer_transform_buf = result.value;
                },
                LayerProtoWire.EFFECTIVE_SCALING_MODE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._effective_scaling_mode = result.value;
                },
                LayerProtoWire.CORNER_RADIUS_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._corner_radius = result.value;
                },
                LayerProtoWire.EFFECTIVE_TRANSFORM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._effective_transform_buf = result.value;
                },
                LayerProtoWire.SOURCE_BOUNDS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._source_bounds_buf = result.value;
                },
                LayerProtoWire.BOUNDS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._bounds_buf = result.value;
                },
                LayerProtoWire.SCREEN_BOUNDS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._screen_bounds_buf = result.value;
                },
                LayerProtoWire.INPUT_WINDOW_INFO_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._input_window_info_buf = result.value;
                },
                LayerProtoWire.CORNER_RADIUS_CROP_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._corner_radius_crop_buf = result.value;
                },
                LayerProtoWire.SHADOW_RADIUS_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._shadow_radius = result.value;
                },
                LayerProtoWire.COLOR_TRANSFORM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._color_transform_buf = result.value;
                },
                LayerProtoWire.IS_RELATIVE_OF_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_relative_of = result.value;
                },
                LayerProtoWire.BACKGROUND_BLUR_RADIUS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._background_blur_radius = result.value;
                },
                LayerProtoWire.OWNER_UID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._owner_uid = result.value;
                },
                LayerProtoWire.BLUR_REGIONS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._blur_regions_offset == null) {
                        res._blur_regions_offset = offset - result.size;
                    }
                    res._blur_regions_last_offset = offset;
                    res._blur_regions_cnt += 1;
                },
                LayerProtoWire.IS_TRUSTED_OVERLAY_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_trusted_overlay = result.value;
                },
                LayerProtoWire.REQUESTED_CORNER_RADIUS_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._requested_corner_radius = result.value;
                },
                LayerProtoWire.DESTINATION_FRAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._destination_frame_buf = result.value;
                },
                LayerProtoWire.ORIGINAL_ID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._original_id = result.value;
                },
                LayerProtoWire.TRUSTED_OVERLAY_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._trusted_overlay = @enumFromInt(result.value);
                },
                LayerProtoWire.BACKGROUND_BLUR_SCALE_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._background_blur_scale = result.value;
                },
                LayerProtoWire.CORNER_RADII_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._corner_radii_buf = result.value;
                },
                LayerProtoWire.REQUESTED_CORNER_RADII_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._requested_corner_radii_buf = result.value;
                },
                LayerProtoWire.CLIENT_DRAWN_CORNER_RADII_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._client_drawn_corner_radii_buf = result.value;
                },
                LayerProtoWire.SYSTEM_CONTENT_PRIORITY_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._system_content_priority = result.value;
                },
                LayerProtoWire.BOX_SHADOW_SETTINGS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._box_shadow_settings_buf = result.value;
                },
                LayerProtoWire.BORDER_SETTINGS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._border_settings_buf = result.value;
                },
                LayerProtoWire.EFFECTIVE_RADII_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._effective_radii_buf = result.value;
                },
                LayerProtoWire.METADATA_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._metadata_offset == null) {
                        res._metadata_offset = offset - result.size;
                    }
                    res._metadata_last_offset = offset;
                    res._metadata_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getId(self: *const LayerProtoReader) i32 {
        return self._id;
    }
    pub inline fn getName(self: *const LayerProtoReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub fn childrenNext(self: *LayerProtoReader) gremlin.Error!?i32 {
        if (self._children_offset == null) return null;
        const current_offset = self._children_offset.?;
        if (current_offset >= self._children_last_offset.?) {
            self._children_offset = null;
            return null;
        }
        if (self._children_packed) {
            const value_result = try self.buf.readInt32(current_offset);
            self._children_offset = current_offset + value_result.size;
            if (self._children_offset.? >= self._children_last_offset.?) {
                self._children_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._children_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == LayerProtoWire.CHILDREN_WIRE) {
                    self._children_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._children_offset = null;
            return value_result.value;
        }
    }
    pub fn relativesNext(self: *LayerProtoReader) gremlin.Error!?i32 {
        if (self._relatives_offset == null) return null;
        const current_offset = self._relatives_offset.?;
        if (current_offset >= self._relatives_last_offset.?) {
            self._relatives_offset = null;
            return null;
        }
        if (self._relatives_packed) {
            const value_result = try self.buf.readInt32(current_offset);
            self._relatives_offset = current_offset + value_result.size;
            if (self._relatives_offset.? >= self._relatives_last_offset.?) {
                self._relatives_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._relatives_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == LayerProtoWire.RELATIVES_WIRE) {
                    self._relatives_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._relatives_offset = null;
            return value_result.value;
        }
    }
    pub inline fn getType(self: *const LayerProtoReader) []const u8 {
        return self._type orelse &[_]u8{};
    }
    pub fn getTransparentRegion(self: *const LayerProtoReader) gremlin.Error!surfaceflinger_common.RegionProtoReader {
        if (self._transparent_region_buf) |buf| {
            return try surfaceflinger_common.RegionProtoReader.init(buf);
        }
        return try surfaceflinger_common.RegionProtoReader.init(&[_]u8{});
    }
    pub fn getVisibleRegion(self: *const LayerProtoReader) gremlin.Error!surfaceflinger_common.RegionProtoReader {
        if (self._visible_region_buf) |buf| {
            return try surfaceflinger_common.RegionProtoReader.init(buf);
        }
        return try surfaceflinger_common.RegionProtoReader.init(&[_]u8{});
    }
    pub fn getDamageRegion(self: *const LayerProtoReader) gremlin.Error!surfaceflinger_common.RegionProtoReader {
        if (self._damage_region_buf) |buf| {
            return try surfaceflinger_common.RegionProtoReader.init(buf);
        }
        return try surfaceflinger_common.RegionProtoReader.init(&[_]u8{});
    }
    pub inline fn getLayerStack(self: *const LayerProtoReader) u32 {
        return self._layer_stack;
    }
    pub inline fn getZ(self: *const LayerProtoReader) i32 {
        return self._z;
    }
    pub fn getPosition(self: *const LayerProtoReader) gremlin.Error!PositionProtoReader {
        if (self._position_buf) |buf| {
            return try PositionProtoReader.init(buf);
        }
        return try PositionProtoReader.init(&[_]u8{});
    }
    pub fn getRequestedPosition(self: *const LayerProtoReader) gremlin.Error!PositionProtoReader {
        if (self._requested_position_buf) |buf| {
            return try PositionProtoReader.init(buf);
        }
        return try PositionProtoReader.init(&[_]u8{});
    }
    pub fn getSize(self: *const LayerProtoReader) gremlin.Error!surfaceflinger_common.SizeProtoReader {
        if (self._size_buf) |buf| {
            return try surfaceflinger_common.SizeProtoReader.init(buf);
        }
        return try surfaceflinger_common.SizeProtoReader.init(&[_]u8{});
    }
    pub fn getCrop(self: *const LayerProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._crop_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getFinalCrop(self: *const LayerProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._final_crop_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub inline fn getIsOpaque(self: *const LayerProtoReader) bool {
        return self._is_opaque;
    }
    pub inline fn getInvalidate(self: *const LayerProtoReader) bool {
        return self._invalidate;
    }
    pub inline fn getDataspace(self: *const LayerProtoReader) []const u8 {
        return self._dataspace orelse &[_]u8{};
    }
    pub inline fn getPixelFormat(self: *const LayerProtoReader) []const u8 {
        return self._pixel_format orelse &[_]u8{};
    }
    pub fn getColor(self: *const LayerProtoReader) gremlin.Error!surfaceflinger_common.ColorProtoReader {
        if (self._color_buf) |buf| {
            return try surfaceflinger_common.ColorProtoReader.init(buf);
        }
        return try surfaceflinger_common.ColorProtoReader.init(&[_]u8{});
    }
    pub fn getRequestedColor(self: *const LayerProtoReader) gremlin.Error!surfaceflinger_common.ColorProtoReader {
        if (self._requested_color_buf) |buf| {
            return try surfaceflinger_common.ColorProtoReader.init(buf);
        }
        return try surfaceflinger_common.ColorProtoReader.init(&[_]u8{});
    }
    pub inline fn getFlags(self: *const LayerProtoReader) u32 {
        return self._flags;
    }
    pub fn getTransform(self: *const LayerProtoReader) gremlin.Error!surfaceflinger_common.TransformProtoReader {
        if (self._transform_buf) |buf| {
            return try surfaceflinger_common.TransformProtoReader.init(buf);
        }
        return try surfaceflinger_common.TransformProtoReader.init(&[_]u8{});
    }
    pub fn getRequestedTransform(self: *const LayerProtoReader) gremlin.Error!surfaceflinger_common.TransformProtoReader {
        if (self._requested_transform_buf) |buf| {
            return try surfaceflinger_common.TransformProtoReader.init(buf);
        }
        return try surfaceflinger_common.TransformProtoReader.init(&[_]u8{});
    }
    pub inline fn getParent(self: *const LayerProtoReader) i32 {
        return self._parent;
    }
    pub inline fn getZOrderRelativeOf(self: *const LayerProtoReader) i32 {
        return self._z_order_relative_of;
    }
    pub fn getActiveBuffer(self: *const LayerProtoReader) gremlin.Error!ActiveBufferProtoReader {
        if (self._active_buffer_buf) |buf| {
            return try ActiveBufferProtoReader.init(buf);
        }
        return try ActiveBufferProtoReader.init(&[_]u8{});
    }
    pub inline fn getQueuedFrames(self: *const LayerProtoReader) i32 {
        return self._queued_frames;
    }
    pub inline fn getRefreshPending(self: *const LayerProtoReader) bool {
        return self._refresh_pending;
    }
    pub fn getHwcFrame(self: *const LayerProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._hwc_frame_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getHwcCrop(self: *const LayerProtoReader) gremlin.Error!FloatRectProtoReader {
        if (self._hwc_crop_buf) |buf| {
            return try FloatRectProtoReader.init(buf);
        }
        return try FloatRectProtoReader.init(&[_]u8{});
    }
    pub inline fn getHwcTransform(self: *const LayerProtoReader) i32 {
        return self._hwc_transform;
    }
    pub inline fn getWindowType(self: *const LayerProtoReader) i32 {
        return self._window_type;
    }
    pub inline fn getAppId(self: *const LayerProtoReader) i32 {
        return self._app_id;
    }
    pub inline fn getHwcCompositionType(self: *const LayerProtoReader) HwcCompositionType {
        return self._hwc_composition_type;
    }
    pub inline fn getIsProtected(self: *const LayerProtoReader) bool {
        return self._is_protected;
    }
    pub inline fn getCurrFrame(self: *const LayerProtoReader) u64 {
        return self._curr_frame;
    }
    pub fn barrierLayerCount(self: *const LayerProtoReader) usize {
        return self._barrier_layer_cnt;
    }
    pub fn barrierLayerNext(self: *LayerProtoReader) ?BarrierLayerProtoReader {
        if (self._barrier_layer_offset == null) return null;
        const current_offset = self._barrier_layer_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = BarrierLayerProtoReader.init(result.value) catch return null;
        if (self._barrier_layer_last_offset != null and current_offset >= self._barrier_layer_last_offset.?) {
            self._barrier_layer_offset = null;
            return msg;
        }
        if (self._barrier_layer_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._barrier_layer_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == LayerProtoWire.BARRIER_LAYER_WIRE) {
                self._barrier_layer_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._barrier_layer_offset = null;
        return msg;
    }
    pub fn getBufferTransform(self: *const LayerProtoReader) gremlin.Error!surfaceflinger_common.TransformProtoReader {
        if (self._buffer_transform_buf) |buf| {
            return try surfaceflinger_common.TransformProtoReader.init(buf);
        }
        return try surfaceflinger_common.TransformProtoReader.init(&[_]u8{});
    }
    pub inline fn getEffectiveScalingMode(self: *const LayerProtoReader) i32 {
        return self._effective_scaling_mode;
    }
    pub inline fn getCornerRadius(self: *const LayerProtoReader) f32 {
        return self._corner_radius;
    }
    pub fn getEffectiveTransform(self: *const LayerProtoReader) gremlin.Error!surfaceflinger_common.TransformProtoReader {
        if (self._effective_transform_buf) |buf| {
            return try surfaceflinger_common.TransformProtoReader.init(buf);
        }
        return try surfaceflinger_common.TransformProtoReader.init(&[_]u8{});
    }
    pub fn getSourceBounds(self: *const LayerProtoReader) gremlin.Error!FloatRectProtoReader {
        if (self._source_bounds_buf) |buf| {
            return try FloatRectProtoReader.init(buf);
        }
        return try FloatRectProtoReader.init(&[_]u8{});
    }
    pub fn getBounds(self: *const LayerProtoReader) gremlin.Error!FloatRectProtoReader {
        if (self._bounds_buf) |buf| {
            return try FloatRectProtoReader.init(buf);
        }
        return try FloatRectProtoReader.init(&[_]u8{});
    }
    pub fn getScreenBounds(self: *const LayerProtoReader) gremlin.Error!FloatRectProtoReader {
        if (self._screen_bounds_buf) |buf| {
            return try FloatRectProtoReader.init(buf);
        }
        return try FloatRectProtoReader.init(&[_]u8{});
    }
    pub fn getInputWindowInfo(self: *const LayerProtoReader) gremlin.Error!surfaceflinger_common.InputWindowInfoProtoReader {
        if (self._input_window_info_buf) |buf| {
            return try surfaceflinger_common.InputWindowInfoProtoReader.init(buf);
        }
        return try surfaceflinger_common.InputWindowInfoProtoReader.init(&[_]u8{});
    }
    pub fn getCornerRadiusCrop(self: *const LayerProtoReader) gremlin.Error!FloatRectProtoReader {
        if (self._corner_radius_crop_buf) |buf| {
            return try FloatRectProtoReader.init(buf);
        }
        return try FloatRectProtoReader.init(&[_]u8{});
    }
    pub inline fn getShadowRadius(self: *const LayerProtoReader) f32 {
        return self._shadow_radius;
    }
    pub fn getColorTransform(self: *const LayerProtoReader) gremlin.Error!surfaceflinger_common.ColorTransformProtoReader {
        if (self._color_transform_buf) |buf| {
            return try surfaceflinger_common.ColorTransformProtoReader.init(buf);
        }
        return try surfaceflinger_common.ColorTransformProtoReader.init(&[_]u8{});
    }
    pub inline fn getIsRelativeOf(self: *const LayerProtoReader) bool {
        return self._is_relative_of;
    }
    pub inline fn getBackgroundBlurRadius(self: *const LayerProtoReader) i32 {
        return self._background_blur_radius;
    }
    pub inline fn getOwnerUid(self: *const LayerProtoReader) u32 {
        return self._owner_uid;
    }
    pub fn blurRegionsCount(self: *const LayerProtoReader) usize {
        return self._blur_regions_cnt;
    }
    pub fn blurRegionsNext(self: *LayerProtoReader) ?surfaceflinger_common.BlurRegionReader {
        if (self._blur_regions_offset == null) return null;
        const current_offset = self._blur_regions_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = surfaceflinger_common.BlurRegionReader.init(result.value) catch return null;
        if (self._blur_regions_last_offset != null and current_offset >= self._blur_regions_last_offset.?) {
            self._blur_regions_offset = null;
            return msg;
        }
        if (self._blur_regions_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._blur_regions_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == LayerProtoWire.BLUR_REGIONS_WIRE) {
                self._blur_regions_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._blur_regions_offset = null;
        return msg;
    }
    pub inline fn getIsTrustedOverlay(self: *const LayerProtoReader) bool {
        return self._is_trusted_overlay;
    }
    pub inline fn getRequestedCornerRadius(self: *const LayerProtoReader) f32 {
        return self._requested_corner_radius;
    }
    pub fn getDestinationFrame(self: *const LayerProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._destination_frame_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub inline fn getOriginalId(self: *const LayerProtoReader) u32 {
        return self._original_id;
    }
    pub inline fn getTrustedOverlay(self: *const LayerProtoReader) surfaceflinger_common.TrustedOverlay {
        return self._trusted_overlay;
    }
    pub inline fn getBackgroundBlurScale(self: *const LayerProtoReader) f32 {
        return self._background_blur_scale;
    }
    pub fn getCornerRadii(self: *const LayerProtoReader) gremlin.Error!CornerRadiiProtoReader {
        if (self._corner_radii_buf) |buf| {
            return try CornerRadiiProtoReader.init(buf);
        }
        return try CornerRadiiProtoReader.init(&[_]u8{});
    }
    pub fn getRequestedCornerRadii(self: *const LayerProtoReader) gremlin.Error!CornerRadiiProtoReader {
        if (self._requested_corner_radii_buf) |buf| {
            return try CornerRadiiProtoReader.init(buf);
        }
        return try CornerRadiiProtoReader.init(&[_]u8{});
    }
    pub fn getClientDrawnCornerRadii(self: *const LayerProtoReader) gremlin.Error!CornerRadiiProtoReader {
        if (self._client_drawn_corner_radii_buf) |buf| {
            return try CornerRadiiProtoReader.init(buf);
        }
        return try CornerRadiiProtoReader.init(&[_]u8{});
    }
    pub inline fn getSystemContentPriority(self: *const LayerProtoReader) i32 {
        return self._system_content_priority;
    }
    pub fn getBoxShadowSettings(self: *const LayerProtoReader) gremlin.Error!surfaceflinger_common.BoxShadowSettingsReader {
        if (self._box_shadow_settings_buf) |buf| {
            return try surfaceflinger_common.BoxShadowSettingsReader.init(buf);
        }
        return try surfaceflinger_common.BoxShadowSettingsReader.init(&[_]u8{});
    }
    pub fn getBorderSettings(self: *const LayerProtoReader) gremlin.Error!surfaceflinger_common.BorderSettingsReader {
        if (self._border_settings_buf) |buf| {
            return try surfaceflinger_common.BorderSettingsReader.init(buf);
        }
        return try surfaceflinger_common.BorderSettingsReader.init(&[_]u8{});
    }
    pub fn getEffectiveRadii(self: *const LayerProtoReader) gremlin.Error!CornerRadiiProtoReader {
        if (self._effective_radii_buf) |buf| {
            return try CornerRadiiProtoReader.init(buf);
        }
        return try CornerRadiiProtoReader.init(&[_]u8{});
    }
    pub fn countMetadata(self: *const LayerProtoReader) usize {
        return self._metadata_cnt;
    }
    pub fn nextMetadata(self: *LayerProtoReader) gremlin.Error!?MetadataEntry {
        if (self._metadata_offset) |current_offset| {
            if (self._metadata_last_offset) |last_offset| {
                if (current_offset >= last_offset) {
                    self._metadata_offset = null;
                    return null;
                }
            }
            var offset = current_offset;
            const result = try self.buf.readBytes(offset);
            offset += result.size;
            const entry_buf = gremlin.Reader.init(result.value);
            var entry_offset: usize = 0;
            var key: i32 = undefined;
            var has_key = false;
            var value: []const u8 = undefined;
            var has_value = false;
            while (entry_buf.hasNext(entry_offset, 0)) {
                const entry_tag = try entry_buf.readTagAt(entry_offset);
                entry_offset += entry_tag.size;
                switch (entry_tag.number) {
                    1 => {
                        const sized_key = try entry_buf.readInt32(entry_offset);
                        key = sized_key.value;
                        entry_offset += sized_key.size;
                        has_key = true;
                    },
                    2 => {
                        const sized_value = try entry_buf.readBytes(entry_offset);
                        value = sized_value.value;
                        entry_offset += sized_value.size;
                        has_value = true;
                    },
                    else => {
                        entry_offset = try entry_buf.skipData(entry_offset, entry_tag.wire);
                    },
                }
            }
            // Find next map entry in the main buffer
            var next_offset = offset;
            const max_offset = self._metadata_last_offset.?;
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = try self.buf.readTagAt(next_offset);
                next_offset += tag.size;
                if (tag.number == LayerProtoWire.METADATA_WIRE) {
                    self._metadata_offset = next_offset;
                    break;
                } else {
                    next_offset = try self.buf.skipData(next_offset, tag.wire);
                }
            } else {
                self._metadata_offset = null;
            }
            if (has_key and has_value) {
                return MetadataEntry{ .key = key, .value = value };
            }
            return null;
        }
        return null;
    }
};
const PositionProtoWire = struct {
    const X_WIRE: gremlin.ProtoWireNumber = 1;
    const Y_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const PositionProto = struct {
    // fields
    x: f32 = 0.0,
    y: f32 = 0.0,
    pub fn calcProtobufSize(self: *const PositionProto) usize {
        var res: usize = 0;
        if (self.x != 0.0) {
            res += gremlin.sizes.sizeWireNumber(PositionProtoWire.X_WIRE) + gremlin.sizes.sizeFloat(self.x);
        }
        if (self.y != 0.0) {
            res += gremlin.sizes.sizeWireNumber(PositionProtoWire.Y_WIRE) + gremlin.sizes.sizeFloat(self.y);
        }
        return res;
    }
    pub fn encode(self: *const PositionProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const PositionProto, target: *gremlin.Writer) void {
        if (self.x != 0.0) {
            target.appendFloat32(PositionProtoWire.X_WIRE, self.x);
        }
        if (self.y != 0.0) {
            target.appendFloat32(PositionProtoWire.Y_WIRE, self.y);
        }
    }
};
pub const PositionProtoReader = struct {
    buf: gremlin.Reader,
    _x: f32 = 0.0,
    _y: f32 = 0.0,
    pub fn init(src: []const u8) gremlin.Error!PositionProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = PositionProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                PositionProtoWire.X_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._x = result.value;
                },
                PositionProtoWire.Y_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._y = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getX(self: *const PositionProtoReader) f32 {
        return self._x;
    }
    pub inline fn getY(self: *const PositionProtoReader) f32 {
        return self._y;
    }
};
const FloatRectProtoWire = struct {
    const LEFT_WIRE: gremlin.ProtoWireNumber = 1;
    const TOP_WIRE: gremlin.ProtoWireNumber = 2;
    const RIGHT_WIRE: gremlin.ProtoWireNumber = 3;
    const BOTTOM_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const FloatRectProto = struct {
    // fields
    left: f32 = 0.0,
    top: f32 = 0.0,
    right: f32 = 0.0,
    bottom: f32 = 0.0,
    pub fn calcProtobufSize(self: *const FloatRectProto) usize {
        var res: usize = 0;
        if (self.left != 0.0) {
            res += gremlin.sizes.sizeWireNumber(FloatRectProtoWire.LEFT_WIRE) + gremlin.sizes.sizeFloat(self.left);
        }
        if (self.top != 0.0) {
            res += gremlin.sizes.sizeWireNumber(FloatRectProtoWire.TOP_WIRE) + gremlin.sizes.sizeFloat(self.top);
        }
        if (self.right != 0.0) {
            res += gremlin.sizes.sizeWireNumber(FloatRectProtoWire.RIGHT_WIRE) + gremlin.sizes.sizeFloat(self.right);
        }
        if (self.bottom != 0.0) {
            res += gremlin.sizes.sizeWireNumber(FloatRectProtoWire.BOTTOM_WIRE) + gremlin.sizes.sizeFloat(self.bottom);
        }
        return res;
    }
    pub fn encode(self: *const FloatRectProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const FloatRectProto, target: *gremlin.Writer) void {
        if (self.left != 0.0) {
            target.appendFloat32(FloatRectProtoWire.LEFT_WIRE, self.left);
        }
        if (self.top != 0.0) {
            target.appendFloat32(FloatRectProtoWire.TOP_WIRE, self.top);
        }
        if (self.right != 0.0) {
            target.appendFloat32(FloatRectProtoWire.RIGHT_WIRE, self.right);
        }
        if (self.bottom != 0.0) {
            target.appendFloat32(FloatRectProtoWire.BOTTOM_WIRE, self.bottom);
        }
    }
};
pub const FloatRectProtoReader = struct {
    buf: gremlin.Reader,
    _left: f32 = 0.0,
    _top: f32 = 0.0,
    _right: f32 = 0.0,
    _bottom: f32 = 0.0,
    pub fn init(src: []const u8) gremlin.Error!FloatRectProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = FloatRectProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                FloatRectProtoWire.LEFT_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._left = result.value;
                },
                FloatRectProtoWire.TOP_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._top = result.value;
                },
                FloatRectProtoWire.RIGHT_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._right = result.value;
                },
                FloatRectProtoWire.BOTTOM_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._bottom = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getLeft(self: *const FloatRectProtoReader) f32 {
        return self._left;
    }
    pub inline fn getTop(self: *const FloatRectProtoReader) f32 {
        return self._top;
    }
    pub inline fn getRight(self: *const FloatRectProtoReader) f32 {
        return self._right;
    }
    pub inline fn getBottom(self: *const FloatRectProtoReader) f32 {
        return self._bottom;
    }
};
const CornerRadiiProtoWire = struct {
    const TL_WIRE: gremlin.ProtoWireNumber = 1;
    const TR_WIRE: gremlin.ProtoWireNumber = 2;
    const BL_WIRE: gremlin.ProtoWireNumber = 3;
    const BR_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const CornerRadiiProto = struct {
    // fields
    tl: f32 = 0.0,
    tr: f32 = 0.0,
    bl: f32 = 0.0,
    br: f32 = 0.0,
    pub fn calcProtobufSize(self: *const CornerRadiiProto) usize {
        var res: usize = 0;
        if (self.tl != 0.0) {
            res += gremlin.sizes.sizeWireNumber(CornerRadiiProtoWire.TL_WIRE) + gremlin.sizes.sizeFloat(self.tl);
        }
        if (self.tr != 0.0) {
            res += gremlin.sizes.sizeWireNumber(CornerRadiiProtoWire.TR_WIRE) + gremlin.sizes.sizeFloat(self.tr);
        }
        if (self.bl != 0.0) {
            res += gremlin.sizes.sizeWireNumber(CornerRadiiProtoWire.BL_WIRE) + gremlin.sizes.sizeFloat(self.bl);
        }
        if (self.br != 0.0) {
            res += gremlin.sizes.sizeWireNumber(CornerRadiiProtoWire.BR_WIRE) + gremlin.sizes.sizeFloat(self.br);
        }
        return res;
    }
    pub fn encode(self: *const CornerRadiiProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const CornerRadiiProto, target: *gremlin.Writer) void {
        if (self.tl != 0.0) {
            target.appendFloat32(CornerRadiiProtoWire.TL_WIRE, self.tl);
        }
        if (self.tr != 0.0) {
            target.appendFloat32(CornerRadiiProtoWire.TR_WIRE, self.tr);
        }
        if (self.bl != 0.0) {
            target.appendFloat32(CornerRadiiProtoWire.BL_WIRE, self.bl);
        }
        if (self.br != 0.0) {
            target.appendFloat32(CornerRadiiProtoWire.BR_WIRE, self.br);
        }
    }
};
pub const CornerRadiiProtoReader = struct {
    buf: gremlin.Reader,
    _tl: f32 = 0.0,
    _tr: f32 = 0.0,
    _bl: f32 = 0.0,
    _br: f32 = 0.0,
    pub fn init(src: []const u8) gremlin.Error!CornerRadiiProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = CornerRadiiProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                CornerRadiiProtoWire.TL_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._tl = result.value;
                },
                CornerRadiiProtoWire.TR_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._tr = result.value;
                },
                CornerRadiiProtoWire.BL_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._bl = result.value;
                },
                CornerRadiiProtoWire.BR_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._br = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getTl(self: *const CornerRadiiProtoReader) f32 {
        return self._tl;
    }
    pub inline fn getTr(self: *const CornerRadiiProtoReader) f32 {
        return self._tr;
    }
    pub inline fn getBl(self: *const CornerRadiiProtoReader) f32 {
        return self._bl;
    }
    pub inline fn getBr(self: *const CornerRadiiProtoReader) f32 {
        return self._br;
    }
};
const ActiveBufferProtoWire = struct {
    const WIDTH_WIRE: gremlin.ProtoWireNumber = 1;
    const HEIGHT_WIRE: gremlin.ProtoWireNumber = 2;
    const STRIDE_WIRE: gremlin.ProtoWireNumber = 3;
    const FORMAT_WIRE: gremlin.ProtoWireNumber = 4;
    const USAGE_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const ActiveBufferProto = struct {
    // fields
    width: u32 = 0,
    height: u32 = 0,
    stride: u32 = 0,
    format: i32 = 0,
    usage: u64 = 0,
    pub fn calcProtobufSize(self: *const ActiveBufferProto) usize {
        var res: usize = 0;
        if (self.width != 0) {
            res += gremlin.sizes.sizeWireNumber(ActiveBufferProtoWire.WIDTH_WIRE) + gremlin.sizes.sizeU32(self.width);
        }
        if (self.height != 0) {
            res += gremlin.sizes.sizeWireNumber(ActiveBufferProtoWire.HEIGHT_WIRE) + gremlin.sizes.sizeU32(self.height);
        }
        if (self.stride != 0) {
            res += gremlin.sizes.sizeWireNumber(ActiveBufferProtoWire.STRIDE_WIRE) + gremlin.sizes.sizeU32(self.stride);
        }
        if (self.format != 0) {
            res += gremlin.sizes.sizeWireNumber(ActiveBufferProtoWire.FORMAT_WIRE) + gremlin.sizes.sizeI32(self.format);
        }
        if (self.usage != 0) {
            res += gremlin.sizes.sizeWireNumber(ActiveBufferProtoWire.USAGE_WIRE) + gremlin.sizes.sizeU64(self.usage);
        }
        return res;
    }
    pub fn encode(self: *const ActiveBufferProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ActiveBufferProto, target: *gremlin.Writer) void {
        if (self.width != 0) {
            target.appendUint32(ActiveBufferProtoWire.WIDTH_WIRE, self.width);
        }
        if (self.height != 0) {
            target.appendUint32(ActiveBufferProtoWire.HEIGHT_WIRE, self.height);
        }
        if (self.stride != 0) {
            target.appendUint32(ActiveBufferProtoWire.STRIDE_WIRE, self.stride);
        }
        if (self.format != 0) {
            target.appendInt32(ActiveBufferProtoWire.FORMAT_WIRE, self.format);
        }
        if (self.usage != 0) {
            target.appendUint64(ActiveBufferProtoWire.USAGE_WIRE, self.usage);
        }
    }
};
pub const ActiveBufferProtoReader = struct {
    buf: gremlin.Reader,
    _width: u32 = 0,
    _height: u32 = 0,
    _stride: u32 = 0,
    _format: i32 = 0,
    _usage: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!ActiveBufferProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = ActiveBufferProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ActiveBufferProtoWire.WIDTH_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._width = result.value;
                },
                ActiveBufferProtoWire.HEIGHT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._height = result.value;
                },
                ActiveBufferProtoWire.STRIDE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._stride = result.value;
                },
                ActiveBufferProtoWire.FORMAT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._format = result.value;
                },
                ActiveBufferProtoWire.USAGE_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._usage = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getWidth(self: *const ActiveBufferProtoReader) u32 {
        return self._width;
    }
    pub inline fn getHeight(self: *const ActiveBufferProtoReader) u32 {
        return self._height;
    }
    pub inline fn getStride(self: *const ActiveBufferProtoReader) u32 {
        return self._stride;
    }
    pub inline fn getFormat(self: *const ActiveBufferProtoReader) i32 {
        return self._format;
    }
    pub inline fn getUsage(self: *const ActiveBufferProtoReader) u64 {
        return self._usage;
    }
};
const BarrierLayerProtoWire = struct {
    const ID_WIRE: gremlin.ProtoWireNumber = 1;
    const FRAME_NUMBER_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const BarrierLayerProto = struct {
    // fields
    id: i32 = 0,
    frame_number: u64 = 0,
    pub fn calcProtobufSize(self: *const BarrierLayerProto) usize {
        var res: usize = 0;
        if (self.id != 0) {
            res += gremlin.sizes.sizeWireNumber(BarrierLayerProtoWire.ID_WIRE) + gremlin.sizes.sizeI32(self.id);
        }
        if (self.frame_number != 0) {
            res += gremlin.sizes.sizeWireNumber(BarrierLayerProtoWire.FRAME_NUMBER_WIRE) + gremlin.sizes.sizeU64(self.frame_number);
        }
        return res;
    }
    pub fn encode(self: *const BarrierLayerProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const BarrierLayerProto, target: *gremlin.Writer) void {
        if (self.id != 0) {
            target.appendInt32(BarrierLayerProtoWire.ID_WIRE, self.id);
        }
        if (self.frame_number != 0) {
            target.appendUint64(BarrierLayerProtoWire.FRAME_NUMBER_WIRE, self.frame_number);
        }
    }
};
pub const BarrierLayerProtoReader = struct {
    buf: gremlin.Reader,
    _id: i32 = 0,
    _frame_number: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!BarrierLayerProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = BarrierLayerProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                BarrierLayerProtoWire.ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._id = result.value;
                },
                BarrierLayerProtoWire.FRAME_NUMBER_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._frame_number = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getId(self: *const BarrierLayerProtoReader) i32 {
        return self._id;
    }
    pub inline fn getFrameNumber(self: *const BarrierLayerProtoReader) u64 {
        return self._frame_number;
    }
};
