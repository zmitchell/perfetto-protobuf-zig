// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
const surfaceflinger_layers = @import("surfaceflinger_layers.proto.zig");
const surfaceflinger_transactions = @import("surfaceflinger_transactions.proto.zig");
const shell_transition = @import("shell_transition.proto.zig");
const protolog = @import("protolog.proto.zig");
const winscope_extensions_impl = @import("winscope_extensions_impl.proto.zig");
const viewcapture = @import("viewcapture.proto.zig");
const android_input_event = @import("android_input_event.proto.zig");
// structs
const WinscopeTraceDataWire = struct {
    const LAYERS_SNAPSHOT_WIRE: gremlin.ProtoWireNumber = 1;
    const TRANSACTIONS_WIRE: gremlin.ProtoWireNumber = 2;
    const SHELL_TRANSITION_WIRE: gremlin.ProtoWireNumber = 3;
    const PROTOLOG_MESSAGE_WIRE: gremlin.ProtoWireNumber = 4;
    const WINSCOPE_EXTENSIONS_WIRE: gremlin.ProtoWireNumber = 5;
    const VIEWCAPTURE_WIRE: gremlin.ProtoWireNumber = 6;
    const ANDROID_INPUT_EVENT_WIRE: gremlin.ProtoWireNumber = 7;
};
pub const WinscopeTraceData = struct {
    // fields
    layers_snapshot: ?surfaceflinger_layers.LayersSnapshotProto = null,
    transactions: ?surfaceflinger_transactions.TransactionTraceEntry = null,
    shell_transition: ?shell_transition.ShellTransition = null,
    protolog_message: ?protolog.ProtoLogMessage = null,
    winscope_extensions: ?winscope_extensions_impl.WinscopeExtensionsImpl = null,
    viewcapture: ?viewcapture.ViewCapture = null,
    android_input_event: ?android_input_event.AndroidInputEvent = null,
    pub fn calcProtobufSize(self: *const WinscopeTraceData) usize {
        var res: usize = 0;
        if (self.layers_snapshot) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WinscopeTraceDataWire.LAYERS_SNAPSHOT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.transactions) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WinscopeTraceDataWire.TRANSACTIONS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.shell_transition) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WinscopeTraceDataWire.SHELL_TRANSITION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.protolog_message) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WinscopeTraceDataWire.PROTOLOG_MESSAGE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.winscope_extensions) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WinscopeTraceDataWire.WINSCOPE_EXTENSIONS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.viewcapture) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WinscopeTraceDataWire.VIEWCAPTURE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_input_event) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(WinscopeTraceDataWire.ANDROID_INPUT_EVENT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const WinscopeTraceData, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const WinscopeTraceData, target: *gremlin.Writer) void {
        if (self.layers_snapshot) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WinscopeTraceDataWire.LAYERS_SNAPSHOT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.transactions) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WinscopeTraceDataWire.TRANSACTIONS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.shell_transition) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WinscopeTraceDataWire.SHELL_TRANSITION_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.protolog_message) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WinscopeTraceDataWire.PROTOLOG_MESSAGE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.winscope_extensions) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WinscopeTraceDataWire.WINSCOPE_EXTENSIONS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.viewcapture) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WinscopeTraceDataWire.VIEWCAPTURE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_input_event) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(WinscopeTraceDataWire.ANDROID_INPUT_EVENT_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const WinscopeTraceDataReader = struct {
    buf: gremlin.Reader,
    _layers_snapshot_buf: ?[]const u8 = null,
    _transactions_buf: ?[]const u8 = null,
    _shell_transition_buf: ?[]const u8 = null,
    _protolog_message_buf: ?[]const u8 = null,
    _winscope_extensions_buf: ?[]const u8 = null,
    _viewcapture_buf: ?[]const u8 = null,
    _android_input_event_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!WinscopeTraceDataReader {
        const buf = gremlin.Reader.init(src);
        var res = WinscopeTraceDataReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                WinscopeTraceDataWire.LAYERS_SNAPSHOT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._layers_snapshot_buf = result.value;
                },
                WinscopeTraceDataWire.TRANSACTIONS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._transactions_buf = result.value;
                },
                WinscopeTraceDataWire.SHELL_TRANSITION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._shell_transition_buf = result.value;
                },
                WinscopeTraceDataWire.PROTOLOG_MESSAGE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._protolog_message_buf = result.value;
                },
                WinscopeTraceDataWire.WINSCOPE_EXTENSIONS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._winscope_extensions_buf = result.value;
                },
                WinscopeTraceDataWire.VIEWCAPTURE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._viewcapture_buf = result.value;
                },
                WinscopeTraceDataWire.ANDROID_INPUT_EVENT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_input_event_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getLayersSnapshot(self: *const WinscopeTraceDataReader) gremlin.Error!surfaceflinger_layers.LayersSnapshotProtoReader {
        if (self._layers_snapshot_buf) |buf| {
            return try surfaceflinger_layers.LayersSnapshotProtoReader.init(buf);
        }
        return try surfaceflinger_layers.LayersSnapshotProtoReader.init(&[_]u8{});
    }
    pub fn getTransactions(self: *const WinscopeTraceDataReader) gremlin.Error!surfaceflinger_transactions.TransactionTraceEntryReader {
        if (self._transactions_buf) |buf| {
            return try surfaceflinger_transactions.TransactionTraceEntryReader.init(buf);
        }
        return try surfaceflinger_transactions.TransactionTraceEntryReader.init(&[_]u8{});
    }
    pub fn getShellTransition(self: *const WinscopeTraceDataReader) gremlin.Error!shell_transition.ShellTransitionReader {
        if (self._shell_transition_buf) |buf| {
            return try shell_transition.ShellTransitionReader.init(buf);
        }
        return try shell_transition.ShellTransitionReader.init(&[_]u8{});
    }
    pub fn getProtologMessage(self: *const WinscopeTraceDataReader) gremlin.Error!protolog.ProtoLogMessageReader {
        if (self._protolog_message_buf) |buf| {
            return try protolog.ProtoLogMessageReader.init(buf);
        }
        return try protolog.ProtoLogMessageReader.init(&[_]u8{});
    }
    pub fn getWinscopeExtensions(self: *const WinscopeTraceDataReader) gremlin.Error!winscope_extensions_impl.WinscopeExtensionsImplReader {
        if (self._winscope_extensions_buf) |buf| {
            return try winscope_extensions_impl.WinscopeExtensionsImplReader.init(buf);
        }
        return try winscope_extensions_impl.WinscopeExtensionsImplReader.init(&[_]u8{});
    }
    pub fn getViewcapture(self: *const WinscopeTraceDataReader) gremlin.Error!viewcapture.ViewCaptureReader {
        if (self._viewcapture_buf) |buf| {
            return try viewcapture.ViewCaptureReader.init(buf);
        }
        return try viewcapture.ViewCaptureReader.init(&[_]u8{});
    }
    pub fn getAndroidInputEvent(self: *const WinscopeTraceDataReader) gremlin.Error!android_input_event.AndroidInputEventReader {
        if (self._android_input_event_buf) |buf| {
            return try android_input_event.AndroidInputEventReader.init(buf);
        }
        return try android_input_event.AndroidInputEventReader.init(&[_]u8{});
    }
};
