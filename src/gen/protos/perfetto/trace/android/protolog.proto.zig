// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
const protolog_common = @import("src/gen/protos/perfetto/common/protolog_common.proto.zig");
// structs
const ProtoLogMessageWire = struct {
    const MESSAGE_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const STR_PARAM_IIDS_WIRE: gremlin.ProtoWireNumber = 2;
    const SINT64_PARAMS_WIRE: gremlin.ProtoWireNumber = 3;
    const DOUBLE_PARAMS_WIRE: gremlin.ProtoWireNumber = 4;
    const BOOLEAN_PARAMS_WIRE: gremlin.ProtoWireNumber = 5;
    const STACKTRACE_IID_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const ProtoLogMessage = struct {
    // fields
    message_id: u64 = 0,
    str_param_iids: ?[]const u32 = null,
    sint64_params: ?[]const i64 = null,
    double_params: ?[]const f64 = null,
    boolean_params: ?[]const i32 = null,
    stacktrace_iid: u32 = 0,
    pub fn calcProtobufSize(self: *const ProtoLogMessage) usize {
        var res: usize = 0;
        if (self.message_id != 0) {
            res += gremlin.sizes.sizeWireNumber(ProtoLogMessageWire.MESSAGE_ID_WIRE) + gremlin.sizes.sizeFixed64(self.message_id);
        }
        if (self.str_param_iids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(ProtoLogMessageWire.STR_PARAM_IIDS_WIRE) + gremlin.sizes.sizeU32(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU32(v);
                }
                res += gremlin.sizes.sizeWireNumber(ProtoLogMessageWire.STR_PARAM_IIDS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.sint64_params) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(ProtoLogMessageWire.SINT64_PARAMS_WIRE) + gremlin.sizes.sizeSI64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeSI64(v);
                }
                res += gremlin.sizes.sizeWireNumber(ProtoLogMessageWire.SINT64_PARAMS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.double_params) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(ProtoLogMessageWire.DOUBLE_PARAMS_WIRE) + gremlin.sizes.sizeDouble(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeDouble(v);
                }
                res += gremlin.sizes.sizeWireNumber(ProtoLogMessageWire.DOUBLE_PARAMS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.boolean_params) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(ProtoLogMessageWire.BOOLEAN_PARAMS_WIRE) + gremlin.sizes.sizeI32(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(v);
                }
                res += gremlin.sizes.sizeWireNumber(ProtoLogMessageWire.BOOLEAN_PARAMS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.stacktrace_iid != 0) {
            res += gremlin.sizes.sizeWireNumber(ProtoLogMessageWire.STACKTRACE_IID_WIRE) + gremlin.sizes.sizeU32(self.stacktrace_iid);
        }
        return res;
    }
    pub fn encode(self: *const ProtoLogMessage, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ProtoLogMessage, target: *gremlin.Writer) void {
        if (self.message_id != 0) {
            target.appendFixed64(ProtoLogMessageWire.MESSAGE_ID_WIRE, self.message_id);
        }
        if (self.str_param_iids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint32(ProtoLogMessageWire.STR_PARAM_IIDS_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU32(v);
                }
                target.appendBytesTag(ProtoLogMessageWire.STR_PARAM_IIDS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint32WithoutTag(v);
                }
            }
        }
        if (self.sint64_params) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendSint64(ProtoLogMessageWire.SINT64_PARAMS_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeSI64(v);
                }
                target.appendBytesTag(ProtoLogMessageWire.SINT64_PARAMS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendSint64WithoutTag(v);
                }
            }
        }
        if (self.double_params) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendFloat64(ProtoLogMessageWire.DOUBLE_PARAMS_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeDouble(v);
                }
                target.appendBytesTag(ProtoLogMessageWire.DOUBLE_PARAMS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendFloat64WithoutTag(v);
                }
            }
        }
        if (self.boolean_params) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt32(ProtoLogMessageWire.BOOLEAN_PARAMS_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(v);
                }
                target.appendBytesTag(ProtoLogMessageWire.BOOLEAN_PARAMS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt32WithoutTag(v);
                }
            }
        }
        if (self.stacktrace_iid != 0) {
            target.appendUint32(ProtoLogMessageWire.STACKTRACE_IID_WIRE, self.stacktrace_iid);
        }
    }
};
pub const ProtoLogMessageReader = struct {
    buf: gremlin.Reader,
    _message_id: u64 = 0,
    _str_param_iids_offset: ?usize = null,
    _str_param_iids_last_offset: ?usize = null,
    _str_param_iids_packed: bool = false,
    _sint64_params_offset: ?usize = null,
    _sint64_params_last_offset: ?usize = null,
    _sint64_params_packed: bool = false,
    _double_params_offset: ?usize = null,
    _double_params_last_offset: ?usize = null,
    _double_params_packed: bool = false,
    _boolean_params_offset: ?usize = null,
    _boolean_params_last_offset: ?usize = null,
    _boolean_params_packed: bool = false,
    _stacktrace_iid: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!ProtoLogMessageReader {
        const buf = gremlin.Reader.init(src);
        var res = ProtoLogMessageReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ProtoLogMessageWire.MESSAGE_ID_WIRE => {
                    const result = try buf.readFixed64(offset);
                    offset += result.size;
                    res._message_id = result.value;
                },
                ProtoLogMessageWire.STR_PARAM_IIDS_WIRE => {
                    if (res._str_param_iids_offset == null) {
                        res._str_param_iids_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._str_param_iids_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._str_param_iids_offset = offset + length_result.size;
                        res._str_param_iids_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._str_param_iids_last_offset.?;
                    } else {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._str_param_iids_last_offset = offset;
                    }
                },
                ProtoLogMessageWire.SINT64_PARAMS_WIRE => {
                    if (res._sint64_params_offset == null) {
                        res._sint64_params_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._sint64_params_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._sint64_params_offset = offset + length_result.size;
                        res._sint64_params_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._sint64_params_last_offset.?;
                    } else {
                        const result = try buf.readSInt64(offset);
                        offset += result.size;
                        res._sint64_params_last_offset = offset;
                    }
                },
                ProtoLogMessageWire.DOUBLE_PARAMS_WIRE => {
                    if (res._double_params_offset == null) {
                        res._double_params_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._double_params_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._double_params_offset = offset + length_result.size;
                        res._double_params_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._double_params_last_offset.?;
                    } else {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._double_params_last_offset = offset;
                    }
                },
                ProtoLogMessageWire.BOOLEAN_PARAMS_WIRE => {
                    if (res._boolean_params_offset == null) {
                        res._boolean_params_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._boolean_params_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._boolean_params_offset = offset + length_result.size;
                        res._boolean_params_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._boolean_params_last_offset.?;
                    } else {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._boolean_params_last_offset = offset;
                    }
                },
                ProtoLogMessageWire.STACKTRACE_IID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._stacktrace_iid = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getMessageId(self: *const ProtoLogMessageReader) u64 {
        return self._message_id;
    }
    pub fn strParamIidsNext(self: *ProtoLogMessageReader) gremlin.Error!?u32 {
        if (self._str_param_iids_offset == null) return null;
        const current_offset = self._str_param_iids_offset.?;
        if (current_offset >= self._str_param_iids_last_offset.?) {
            self._str_param_iids_offset = null;
            return null;
        }
        if (self._str_param_iids_packed) {
            const value_result = try self.buf.readUInt32(current_offset);
            self._str_param_iids_offset = current_offset + value_result.size;
            if (self._str_param_iids_offset.? >= self._str_param_iids_last_offset.?) {
                self._str_param_iids_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._str_param_iids_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == ProtoLogMessageWire.STR_PARAM_IIDS_WIRE) {
                    self._str_param_iids_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._str_param_iids_offset = null;
            return value_result.value;
        }
    }
    pub fn sint64ParamsNext(self: *ProtoLogMessageReader) gremlin.Error!?i64 {
        if (self._sint64_params_offset == null) return null;
        const current_offset = self._sint64_params_offset.?;
        if (current_offset >= self._sint64_params_last_offset.?) {
            self._sint64_params_offset = null;
            return null;
        }
        if (self._sint64_params_packed) {
            const value_result = try self.buf.readSInt64(current_offset);
            self._sint64_params_offset = current_offset + value_result.size;
            if (self._sint64_params_offset.? >= self._sint64_params_last_offset.?) {
                self._sint64_params_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readSInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._sint64_params_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == ProtoLogMessageWire.SINT64_PARAMS_WIRE) {
                    self._sint64_params_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._sint64_params_offset = null;
            return value_result.value;
        }
    }
    pub fn doubleParamsNext(self: *ProtoLogMessageReader) gremlin.Error!?f64 {
        if (self._double_params_offset == null) return null;
        const current_offset = self._double_params_offset.?;
        if (current_offset >= self._double_params_last_offset.?) {
            self._double_params_offset = null;
            return null;
        }
        if (self._double_params_packed) {
            const value_result = try self.buf.readFloat64(current_offset);
            self._double_params_offset = current_offset + value_result.size;
            if (self._double_params_offset.? >= self._double_params_last_offset.?) {
                self._double_params_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readFloat64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._double_params_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == ProtoLogMessageWire.DOUBLE_PARAMS_WIRE) {
                    self._double_params_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._double_params_offset = null;
            return value_result.value;
        }
    }
    pub fn booleanParamsNext(self: *ProtoLogMessageReader) gremlin.Error!?i32 {
        if (self._boolean_params_offset == null) return null;
        const current_offset = self._boolean_params_offset.?;
        if (current_offset >= self._boolean_params_last_offset.?) {
            self._boolean_params_offset = null;
            return null;
        }
        if (self._boolean_params_packed) {
            const value_result = try self.buf.readInt32(current_offset);
            self._boolean_params_offset = current_offset + value_result.size;
            if (self._boolean_params_offset.? >= self._boolean_params_last_offset.?) {
                self._boolean_params_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._boolean_params_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == ProtoLogMessageWire.BOOLEAN_PARAMS_WIRE) {
                    self._boolean_params_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._boolean_params_offset = null;
            return value_result.value;
        }
    }
    pub inline fn getStacktraceIid(self: *const ProtoLogMessageReader) u32 {
        return self._stacktrace_iid;
    }
};
const ProtoLogViewerConfigWire = struct {
    const MESSAGES_WIRE: gremlin.ProtoWireNumber = 1;
    const GROUPS_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const ProtoLogViewerConfig = struct {
    // nested structs
    const MessageDataWire = struct {
        const MESSAGE_ID_WIRE: gremlin.ProtoWireNumber = 1;
        const MESSAGE_WIRE: gremlin.ProtoWireNumber = 2;
        const LEVEL_WIRE: gremlin.ProtoWireNumber = 3;
        const GROUP_ID_WIRE: gremlin.ProtoWireNumber = 4;
        const LOCATION_WIRE: gremlin.ProtoWireNumber = 5;
    };
    pub const MessageData = struct {
        // fields
        message_id: u64 = 0,
        message: ?[]const u8 = null,
        level: protolog_common.ProtoLogLevel = @enumFromInt(0),
        group_id: u32 = 0,
        location: ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const ProtoLogViewerConfig.MessageData) usize {
            var res: usize = 0;
            if (self.message_id != 0) {
                res += gremlin.sizes.sizeWireNumber(ProtoLogViewerConfig.MessageDataWire.MESSAGE_ID_WIRE) + gremlin.sizes.sizeFixed64(self.message_id);
            }
            if (self.message) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(ProtoLogViewerConfig.MessageDataWire.MESSAGE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (@intFromEnum(self.level) != 0) {
                res += gremlin.sizes.sizeWireNumber(ProtoLogViewerConfig.MessageDataWire.LEVEL_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.level));
            }
            if (self.group_id != 0) {
                res += gremlin.sizes.sizeWireNumber(ProtoLogViewerConfig.MessageDataWire.GROUP_ID_WIRE) + gremlin.sizes.sizeU32(self.group_id);
            }
            if (self.location) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(ProtoLogViewerConfig.MessageDataWire.LOCATION_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            return res;
        }
        pub fn encode(self: *const ProtoLogViewerConfig.MessageData, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const ProtoLogViewerConfig.MessageData, target: *gremlin.Writer) void {
            if (self.message_id != 0) {
                target.appendFixed64(ProtoLogViewerConfig.MessageDataWire.MESSAGE_ID_WIRE, self.message_id);
            }
            if (self.message) |v| {
                if (v.len > 0) {
                    target.appendBytes(ProtoLogViewerConfig.MessageDataWire.MESSAGE_WIRE, v);
                }
            }
            if (@intFromEnum(self.level) != 0) {
                target.appendInt32(ProtoLogViewerConfig.MessageDataWire.LEVEL_WIRE, @intFromEnum(self.level));
            }
            if (self.group_id != 0) {
                target.appendUint32(ProtoLogViewerConfig.MessageDataWire.GROUP_ID_WIRE, self.group_id);
            }
            if (self.location) |v| {
                if (v.len > 0) {
                    target.appendBytes(ProtoLogViewerConfig.MessageDataWire.LOCATION_WIRE, v);
                }
            }
        }
    };
    pub const MessageDataReader = struct {
        buf: gremlin.Reader,
        _message_id: u64 = 0,
        _message: ?[]const u8 = null,
        _level: protolog_common.ProtoLogLevel = @enumFromInt(0),
        _group_id: u32 = 0,
        _location: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!ProtoLogViewerConfig.MessageDataReader {
            const buf = gremlin.Reader.init(src);
            var res = ProtoLogViewerConfig.MessageDataReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    ProtoLogViewerConfig.MessageDataWire.MESSAGE_ID_WIRE => {
                        const result = try buf.readFixed64(offset);
                        offset += result.size;
                        res._message_id = result.value;
                    },
                    ProtoLogViewerConfig.MessageDataWire.MESSAGE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._message = result.value;
                    },
                    ProtoLogViewerConfig.MessageDataWire.LEVEL_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._level = @enumFromInt(result.value);
                    },
                    ProtoLogViewerConfig.MessageDataWire.GROUP_ID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._group_id = result.value;
                    },
                    ProtoLogViewerConfig.MessageDataWire.LOCATION_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._location = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getMessageId(self: *const ProtoLogViewerConfig.MessageDataReader) u64 {
            return self._message_id;
        }
        pub inline fn getMessage(self: *const ProtoLogViewerConfig.MessageDataReader) []const u8 {
            return self._message orelse &[_]u8{};
        }
        pub inline fn getLevel(self: *const ProtoLogViewerConfig.MessageDataReader) protolog_common.ProtoLogLevel {
            return self._level;
        }
        pub inline fn getGroupId(self: *const ProtoLogViewerConfig.MessageDataReader) u32 {
            return self._group_id;
        }
        pub inline fn getLocation(self: *const ProtoLogViewerConfig.MessageDataReader) []const u8 {
            return self._location orelse &[_]u8{};
        }
    };
    const GroupWire = struct {
        const ID_WIRE: gremlin.ProtoWireNumber = 1;
        const NAME_WIRE: gremlin.ProtoWireNumber = 2;
        const TAG_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const Group = struct {
        // fields
        id: u32 = 0,
        name: ?[]const u8 = null,
        tag: ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const ProtoLogViewerConfig.Group) usize {
            var res: usize = 0;
            if (self.id != 0) {
                res += gremlin.sizes.sizeWireNumber(ProtoLogViewerConfig.GroupWire.ID_WIRE) + gremlin.sizes.sizeU32(self.id);
            }
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(ProtoLogViewerConfig.GroupWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.tag) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(ProtoLogViewerConfig.GroupWire.TAG_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            return res;
        }
        pub fn encode(self: *const ProtoLogViewerConfig.Group, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const ProtoLogViewerConfig.Group, target: *gremlin.Writer) void {
            if (self.id != 0) {
                target.appendUint32(ProtoLogViewerConfig.GroupWire.ID_WIRE, self.id);
            }
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(ProtoLogViewerConfig.GroupWire.NAME_WIRE, v);
                }
            }
            if (self.tag) |v| {
                if (v.len > 0) {
                    target.appendBytes(ProtoLogViewerConfig.GroupWire.TAG_WIRE, v);
                }
            }
        }
    };
    pub const GroupReader = struct {
        buf: gremlin.Reader,
        _id: u32 = 0,
        _name: ?[]const u8 = null,
        _tag: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!ProtoLogViewerConfig.GroupReader {
            const buf = gremlin.Reader.init(src);
            var res = ProtoLogViewerConfig.GroupReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    ProtoLogViewerConfig.GroupWire.ID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._id = result.value;
                    },
                    ProtoLogViewerConfig.GroupWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    ProtoLogViewerConfig.GroupWire.TAG_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._tag = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getId(self: *const ProtoLogViewerConfig.GroupReader) u32 {
            return self._id;
        }
        pub inline fn getName(self: *const ProtoLogViewerConfig.GroupReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub inline fn getTag(self: *const ProtoLogViewerConfig.GroupReader) []const u8 {
            return self._tag orelse &[_]u8{};
        }
    };
    // fields
    messages: ?[]const ?ProtoLogViewerConfig.MessageData = null,
    groups: ?[]const ?ProtoLogViewerConfig.Group = null,
    pub fn calcProtobufSize(self: *const ProtoLogViewerConfig) usize {
        var res: usize = 0;
        if (self.messages) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ProtoLogViewerConfigWire.MESSAGES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.groups) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ProtoLogViewerConfigWire.GROUPS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const ProtoLogViewerConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ProtoLogViewerConfig, target: *gremlin.Writer) void {
        if (self.messages) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(ProtoLogViewerConfigWire.MESSAGES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(ProtoLogViewerConfigWire.MESSAGES_WIRE, 0);
                }
            }
        }
        if (self.groups) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(ProtoLogViewerConfigWire.GROUPS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(ProtoLogViewerConfigWire.GROUPS_WIRE, 0);
                }
            }
        }
    }
};
pub const ProtoLogViewerConfigReader = struct {
    buf: gremlin.Reader,
    _messages_offset: ?usize = null,
    _messages_last_offset: ?usize = null,
    _messages_cnt: usize = 0,
    _groups_offset: ?usize = null,
    _groups_last_offset: ?usize = null,
    _groups_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!ProtoLogViewerConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = ProtoLogViewerConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ProtoLogViewerConfigWire.MESSAGES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._messages_offset == null) {
                        res._messages_offset = offset - result.size;
                    }
                    res._messages_last_offset = offset;
                    res._messages_cnt += 1;
                },
                ProtoLogViewerConfigWire.GROUPS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._groups_offset == null) {
                        res._groups_offset = offset - result.size;
                    }
                    res._groups_last_offset = offset;
                    res._groups_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn messagesCount(self: *const ProtoLogViewerConfigReader) usize {
        return self._messages_cnt;
    }
    pub fn messagesNext(self: *ProtoLogViewerConfigReader) ?ProtoLogViewerConfig.MessageDataReader {
        if (self._messages_offset == null) return null;
        const current_offset = self._messages_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = ProtoLogViewerConfig.MessageDataReader.init(result.value) catch return null;
        if (self._messages_last_offset != null and current_offset >= self._messages_last_offset.?) {
            self._messages_offset = null;
            return msg;
        }
        if (self._messages_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._messages_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ProtoLogViewerConfigWire.MESSAGES_WIRE) {
                self._messages_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._messages_offset = null;
        return msg;
    }
    pub fn groupsCount(self: *const ProtoLogViewerConfigReader) usize {
        return self._groups_cnt;
    }
    pub fn groupsNext(self: *ProtoLogViewerConfigReader) ?ProtoLogViewerConfig.GroupReader {
        if (self._groups_offset == null) return null;
        const current_offset = self._groups_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = ProtoLogViewerConfig.GroupReader.init(result.value) catch return null;
        if (self._groups_last_offset != null and current_offset >= self._groups_last_offset.?) {
            self._groups_offset = null;
            return msg;
        }
        if (self._groups_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._groups_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ProtoLogViewerConfigWire.GROUPS_WIRE) {
                self._groups_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._groups_offset = null;
        return msg;
    }
};
