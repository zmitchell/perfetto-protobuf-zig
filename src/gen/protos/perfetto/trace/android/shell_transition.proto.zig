// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const ShellTransitionWire = struct {
    const ID_WIRE: gremlin.ProtoWireNumber = 1;
    const CREATE_TIME_NS_WIRE: gremlin.ProtoWireNumber = 2;
    const SEND_TIME_NS_WIRE: gremlin.ProtoWireNumber = 3;
    const DISPATCH_TIME_NS_WIRE: gremlin.ProtoWireNumber = 4;
    const MERGE_TIME_NS_WIRE: gremlin.ProtoWireNumber = 5;
    const MERGE_REQUEST_TIME_NS_WIRE: gremlin.ProtoWireNumber = 6;
    const SHELL_ABORT_TIME_NS_WIRE: gremlin.ProtoWireNumber = 7;
    const WM_ABORT_TIME_NS_WIRE: gremlin.ProtoWireNumber = 8;
    const FINISH_TIME_NS_WIRE: gremlin.ProtoWireNumber = 9;
    const START_TRANSACTION_ID_WIRE: gremlin.ProtoWireNumber = 10;
    const FINISH_TRANSACTION_ID_WIRE: gremlin.ProtoWireNumber = 11;
    const HANDLER_WIRE: gremlin.ProtoWireNumber = 12;
    const TYPE_WIRE: gremlin.ProtoWireNumber = 13;
    const TARGETS_WIRE: gremlin.ProtoWireNumber = 14;
    const MERGE_TARGET_WIRE: gremlin.ProtoWireNumber = 15;
    const FLAGS_WIRE: gremlin.ProtoWireNumber = 16;
    const STARTING_WINDOW_REMOVE_TIME_NS_WIRE: gremlin.ProtoWireNumber = 17;
};
pub const ShellTransition = struct {
    // nested structs
    const TargetWire = struct {
        const MODE_WIRE: gremlin.ProtoWireNumber = 1;
        const LAYER_ID_WIRE: gremlin.ProtoWireNumber = 2;
        const WINDOW_ID_WIRE: gremlin.ProtoWireNumber = 3;
        const FLAGS_WIRE: gremlin.ProtoWireNumber = 4;
    };
    pub const Target = struct {
        // fields
        mode: i32 = 0,
        layer_id: i32 = 0,
        window_id: i32 = 0,
        flags: i32 = 0,
        pub fn calcProtobufSize(self: *const ShellTransition.Target) usize {
            var res: usize = 0;
            if (self.mode != 0) {
                res += gremlin.sizes.sizeWireNumber(ShellTransition.TargetWire.MODE_WIRE) + gremlin.sizes.sizeI32(self.mode);
            }
            if (self.layer_id != 0) {
                res += gremlin.sizes.sizeWireNumber(ShellTransition.TargetWire.LAYER_ID_WIRE) + gremlin.sizes.sizeI32(self.layer_id);
            }
            if (self.window_id != 0) {
                res += gremlin.sizes.sizeWireNumber(ShellTransition.TargetWire.WINDOW_ID_WIRE) + gremlin.sizes.sizeI32(self.window_id);
            }
            if (self.flags != 0) {
                res += gremlin.sizes.sizeWireNumber(ShellTransition.TargetWire.FLAGS_WIRE) + gremlin.sizes.sizeI32(self.flags);
            }
            return res;
        }
        pub fn encode(self: *const ShellTransition.Target, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const ShellTransition.Target, target: *gremlin.Writer) void {
            if (self.mode != 0) {
                target.appendInt32(ShellTransition.TargetWire.MODE_WIRE, self.mode);
            }
            if (self.layer_id != 0) {
                target.appendInt32(ShellTransition.TargetWire.LAYER_ID_WIRE, self.layer_id);
            }
            if (self.window_id != 0) {
                target.appendInt32(ShellTransition.TargetWire.WINDOW_ID_WIRE, self.window_id);
            }
            if (self.flags != 0) {
                target.appendInt32(ShellTransition.TargetWire.FLAGS_WIRE, self.flags);
            }
        }
    };
    pub const TargetReader = struct {
        buf: gremlin.Reader,
        _mode: i32 = 0,
        _layer_id: i32 = 0,
        _window_id: i32 = 0,
        _flags: i32 = 0,
        pub fn init(src: []const u8) gremlin.Error!ShellTransition.TargetReader {
            const buf = gremlin.Reader.init(src);
            var res = ShellTransition.TargetReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    ShellTransition.TargetWire.MODE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._mode = result.value;
                    },
                    ShellTransition.TargetWire.LAYER_ID_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._layer_id = result.value;
                    },
                    ShellTransition.TargetWire.WINDOW_ID_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._window_id = result.value;
                    },
                    ShellTransition.TargetWire.FLAGS_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._flags = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getMode(self: *const ShellTransition.TargetReader) i32 {
            return self._mode;
        }
        pub inline fn getLayerId(self: *const ShellTransition.TargetReader) i32 {
            return self._layer_id;
        }
        pub inline fn getWindowId(self: *const ShellTransition.TargetReader) i32 {
            return self._window_id;
        }
        pub inline fn getFlags(self: *const ShellTransition.TargetReader) i32 {
            return self._flags;
        }
    };
    // fields
    id: i32 = 0,
    create_time_ns: i64 = 0,
    send_time_ns: i64 = 0,
    dispatch_time_ns: i64 = 0,
    merge_time_ns: i64 = 0,
    merge_request_time_ns: i64 = 0,
    shell_abort_time_ns: i64 = 0,
    wm_abort_time_ns: i64 = 0,
    finish_time_ns: i64 = 0,
    start_transaction_id: u64 = 0,
    finish_transaction_id: u64 = 0,
    handler: i32 = 0,
    type: i32 = 0,
    targets: ?[]const ?ShellTransition.Target = null,
    merge_target: i32 = 0,
    flags: i32 = 0,
    starting_window_remove_time_ns: i64 = 0,
    pub fn calcProtobufSize(self: *const ShellTransition) usize {
        var res: usize = 0;
        if (self.id != 0) {
            res += gremlin.sizes.sizeWireNumber(ShellTransitionWire.ID_WIRE) + gremlin.sizes.sizeI32(self.id);
        }
        if (self.create_time_ns != 0) {
            res += gremlin.sizes.sizeWireNumber(ShellTransitionWire.CREATE_TIME_NS_WIRE) + gremlin.sizes.sizeI64(self.create_time_ns);
        }
        if (self.send_time_ns != 0) {
            res += gremlin.sizes.sizeWireNumber(ShellTransitionWire.SEND_TIME_NS_WIRE) + gremlin.sizes.sizeI64(self.send_time_ns);
        }
        if (self.dispatch_time_ns != 0) {
            res += gremlin.sizes.sizeWireNumber(ShellTransitionWire.DISPATCH_TIME_NS_WIRE) + gremlin.sizes.sizeI64(self.dispatch_time_ns);
        }
        if (self.merge_time_ns != 0) {
            res += gremlin.sizes.sizeWireNumber(ShellTransitionWire.MERGE_TIME_NS_WIRE) + gremlin.sizes.sizeI64(self.merge_time_ns);
        }
        if (self.merge_request_time_ns != 0) {
            res += gremlin.sizes.sizeWireNumber(ShellTransitionWire.MERGE_REQUEST_TIME_NS_WIRE) + gremlin.sizes.sizeI64(self.merge_request_time_ns);
        }
        if (self.shell_abort_time_ns != 0) {
            res += gremlin.sizes.sizeWireNumber(ShellTransitionWire.SHELL_ABORT_TIME_NS_WIRE) + gremlin.sizes.sizeI64(self.shell_abort_time_ns);
        }
        if (self.wm_abort_time_ns != 0) {
            res += gremlin.sizes.sizeWireNumber(ShellTransitionWire.WM_ABORT_TIME_NS_WIRE) + gremlin.sizes.sizeI64(self.wm_abort_time_ns);
        }
        if (self.finish_time_ns != 0) {
            res += gremlin.sizes.sizeWireNumber(ShellTransitionWire.FINISH_TIME_NS_WIRE) + gremlin.sizes.sizeI64(self.finish_time_ns);
        }
        if (self.start_transaction_id != 0) {
            res += gremlin.sizes.sizeWireNumber(ShellTransitionWire.START_TRANSACTION_ID_WIRE) + gremlin.sizes.sizeU64(self.start_transaction_id);
        }
        if (self.finish_transaction_id != 0) {
            res += gremlin.sizes.sizeWireNumber(ShellTransitionWire.FINISH_TRANSACTION_ID_WIRE) + gremlin.sizes.sizeU64(self.finish_transaction_id);
        }
        if (self.handler != 0) {
            res += gremlin.sizes.sizeWireNumber(ShellTransitionWire.HANDLER_WIRE) + gremlin.sizes.sizeI32(self.handler);
        }
        if (self.type != 0) {
            res += gremlin.sizes.sizeWireNumber(ShellTransitionWire.TYPE_WIRE) + gremlin.sizes.sizeI32(self.type);
        }
        if (self.targets) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ShellTransitionWire.TARGETS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.merge_target != 0) {
            res += gremlin.sizes.sizeWireNumber(ShellTransitionWire.MERGE_TARGET_WIRE) + gremlin.sizes.sizeI32(self.merge_target);
        }
        if (self.flags != 0) {
            res += gremlin.sizes.sizeWireNumber(ShellTransitionWire.FLAGS_WIRE) + gremlin.sizes.sizeI32(self.flags);
        }
        if (self.starting_window_remove_time_ns != 0) {
            res += gremlin.sizes.sizeWireNumber(ShellTransitionWire.STARTING_WINDOW_REMOVE_TIME_NS_WIRE) + gremlin.sizes.sizeI64(self.starting_window_remove_time_ns);
        }
        return res;
    }
    pub fn encode(self: *const ShellTransition, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ShellTransition, target: *gremlin.Writer) void {
        if (self.id != 0) {
            target.appendInt32(ShellTransitionWire.ID_WIRE, self.id);
        }
        if (self.create_time_ns != 0) {
            target.appendInt64(ShellTransitionWire.CREATE_TIME_NS_WIRE, self.create_time_ns);
        }
        if (self.send_time_ns != 0) {
            target.appendInt64(ShellTransitionWire.SEND_TIME_NS_WIRE, self.send_time_ns);
        }
        if (self.dispatch_time_ns != 0) {
            target.appendInt64(ShellTransitionWire.DISPATCH_TIME_NS_WIRE, self.dispatch_time_ns);
        }
        if (self.merge_time_ns != 0) {
            target.appendInt64(ShellTransitionWire.MERGE_TIME_NS_WIRE, self.merge_time_ns);
        }
        if (self.merge_request_time_ns != 0) {
            target.appendInt64(ShellTransitionWire.MERGE_REQUEST_TIME_NS_WIRE, self.merge_request_time_ns);
        }
        if (self.shell_abort_time_ns != 0) {
            target.appendInt64(ShellTransitionWire.SHELL_ABORT_TIME_NS_WIRE, self.shell_abort_time_ns);
        }
        if (self.wm_abort_time_ns != 0) {
            target.appendInt64(ShellTransitionWire.WM_ABORT_TIME_NS_WIRE, self.wm_abort_time_ns);
        }
        if (self.finish_time_ns != 0) {
            target.appendInt64(ShellTransitionWire.FINISH_TIME_NS_WIRE, self.finish_time_ns);
        }
        if (self.start_transaction_id != 0) {
            target.appendUint64(ShellTransitionWire.START_TRANSACTION_ID_WIRE, self.start_transaction_id);
        }
        if (self.finish_transaction_id != 0) {
            target.appendUint64(ShellTransitionWire.FINISH_TRANSACTION_ID_WIRE, self.finish_transaction_id);
        }
        if (self.handler != 0) {
            target.appendInt32(ShellTransitionWire.HANDLER_WIRE, self.handler);
        }
        if (self.type != 0) {
            target.appendInt32(ShellTransitionWire.TYPE_WIRE, self.type);
        }
        if (self.targets) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(ShellTransitionWire.TARGETS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(ShellTransitionWire.TARGETS_WIRE, 0);
                }
            }
        }
        if (self.merge_target != 0) {
            target.appendInt32(ShellTransitionWire.MERGE_TARGET_WIRE, self.merge_target);
        }
        if (self.flags != 0) {
            target.appendInt32(ShellTransitionWire.FLAGS_WIRE, self.flags);
        }
        if (self.starting_window_remove_time_ns != 0) {
            target.appendInt64(ShellTransitionWire.STARTING_WINDOW_REMOVE_TIME_NS_WIRE, self.starting_window_remove_time_ns);
        }
    }
};
pub const ShellTransitionReader = struct {
    buf: gremlin.Reader,
    _id: i32 = 0,
    _create_time_ns: i64 = 0,
    _send_time_ns: i64 = 0,
    _dispatch_time_ns: i64 = 0,
    _merge_time_ns: i64 = 0,
    _merge_request_time_ns: i64 = 0,
    _shell_abort_time_ns: i64 = 0,
    _wm_abort_time_ns: i64 = 0,
    _finish_time_ns: i64 = 0,
    _start_transaction_id: u64 = 0,
    _finish_transaction_id: u64 = 0,
    _handler: i32 = 0,
    _type: i32 = 0,
    _targets_offset: ?usize = null,
    _targets_last_offset: ?usize = null,
    _targets_cnt: usize = 0,
    _merge_target: i32 = 0,
    _flags: i32 = 0,
    _starting_window_remove_time_ns: i64 = 0,
    pub fn init(src: []const u8) gremlin.Error!ShellTransitionReader {
        const buf = gremlin.Reader.init(src);
        var res = ShellTransitionReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ShellTransitionWire.ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._id = result.value;
                },
                ShellTransitionWire.CREATE_TIME_NS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._create_time_ns = result.value;
                },
                ShellTransitionWire.SEND_TIME_NS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._send_time_ns = result.value;
                },
                ShellTransitionWire.DISPATCH_TIME_NS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._dispatch_time_ns = result.value;
                },
                ShellTransitionWire.MERGE_TIME_NS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._merge_time_ns = result.value;
                },
                ShellTransitionWire.MERGE_REQUEST_TIME_NS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._merge_request_time_ns = result.value;
                },
                ShellTransitionWire.SHELL_ABORT_TIME_NS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._shell_abort_time_ns = result.value;
                },
                ShellTransitionWire.WM_ABORT_TIME_NS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._wm_abort_time_ns = result.value;
                },
                ShellTransitionWire.FINISH_TIME_NS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._finish_time_ns = result.value;
                },
                ShellTransitionWire.START_TRANSACTION_ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._start_transaction_id = result.value;
                },
                ShellTransitionWire.FINISH_TRANSACTION_ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._finish_transaction_id = result.value;
                },
                ShellTransitionWire.HANDLER_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._handler = result.value;
                },
                ShellTransitionWire.TYPE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._type = result.value;
                },
                ShellTransitionWire.TARGETS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._targets_offset == null) {
                        res._targets_offset = offset - result.size;
                    }
                    res._targets_last_offset = offset;
                    res._targets_cnt += 1;
                },
                ShellTransitionWire.MERGE_TARGET_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._merge_target = result.value;
                },
                ShellTransitionWire.FLAGS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._flags = result.value;
                },
                ShellTransitionWire.STARTING_WINDOW_REMOVE_TIME_NS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._starting_window_remove_time_ns = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getId(self: *const ShellTransitionReader) i32 {
        return self._id;
    }
    pub inline fn getCreateTimeNs(self: *const ShellTransitionReader) i64 {
        return self._create_time_ns;
    }
    pub inline fn getSendTimeNs(self: *const ShellTransitionReader) i64 {
        return self._send_time_ns;
    }
    pub inline fn getDispatchTimeNs(self: *const ShellTransitionReader) i64 {
        return self._dispatch_time_ns;
    }
    pub inline fn getMergeTimeNs(self: *const ShellTransitionReader) i64 {
        return self._merge_time_ns;
    }
    pub inline fn getMergeRequestTimeNs(self: *const ShellTransitionReader) i64 {
        return self._merge_request_time_ns;
    }
    pub inline fn getShellAbortTimeNs(self: *const ShellTransitionReader) i64 {
        return self._shell_abort_time_ns;
    }
    pub inline fn getWmAbortTimeNs(self: *const ShellTransitionReader) i64 {
        return self._wm_abort_time_ns;
    }
    pub inline fn getFinishTimeNs(self: *const ShellTransitionReader) i64 {
        return self._finish_time_ns;
    }
    pub inline fn getStartTransactionId(self: *const ShellTransitionReader) u64 {
        return self._start_transaction_id;
    }
    pub inline fn getFinishTransactionId(self: *const ShellTransitionReader) u64 {
        return self._finish_transaction_id;
    }
    pub inline fn getHandler(self: *const ShellTransitionReader) i32 {
        return self._handler;
    }
    pub inline fn getType(self: *const ShellTransitionReader) i32 {
        return self._type;
    }
    pub fn targetsCount(self: *const ShellTransitionReader) usize {
        return self._targets_cnt;
    }
    pub fn targetsNext(self: *ShellTransitionReader) ?ShellTransition.TargetReader {
        if (self._targets_offset == null) return null;
        const current_offset = self._targets_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = ShellTransition.TargetReader.init(result.value) catch return null;
        if (self._targets_last_offset != null and current_offset >= self._targets_last_offset.?) {
            self._targets_offset = null;
            return msg;
        }
        if (self._targets_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._targets_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ShellTransitionWire.TARGETS_WIRE) {
                self._targets_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._targets_offset = null;
        return msg;
    }
    pub inline fn getMergeTarget(self: *const ShellTransitionReader) i32 {
        return self._merge_target;
    }
    pub inline fn getFlags(self: *const ShellTransitionReader) i32 {
        return self._flags;
    }
    pub inline fn getStartingWindowRemoveTimeNs(self: *const ShellTransitionReader) i64 {
        return self._starting_window_remove_time_ns;
    }
};
const ShellHandlerMappingsWire = struct {
    const MAPPING_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const ShellHandlerMappings = struct {
    // fields
    mapping: ?[]const ?ShellHandlerMapping = null,
    pub fn calcProtobufSize(self: *const ShellHandlerMappings) usize {
        var res: usize = 0;
        if (self.mapping) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ShellHandlerMappingsWire.MAPPING_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const ShellHandlerMappings, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ShellHandlerMappings, target: *gremlin.Writer) void {
        if (self.mapping) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(ShellHandlerMappingsWire.MAPPING_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(ShellHandlerMappingsWire.MAPPING_WIRE, 0);
                }
            }
        }
    }
};
pub const ShellHandlerMappingsReader = struct {
    buf: gremlin.Reader,
    _mapping_offset: ?usize = null,
    _mapping_last_offset: ?usize = null,
    _mapping_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!ShellHandlerMappingsReader {
        const buf = gremlin.Reader.init(src);
        var res = ShellHandlerMappingsReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ShellHandlerMappingsWire.MAPPING_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._mapping_offset == null) {
                        res._mapping_offset = offset - result.size;
                    }
                    res._mapping_last_offset = offset;
                    res._mapping_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn mappingCount(self: *const ShellHandlerMappingsReader) usize {
        return self._mapping_cnt;
    }
    pub fn mappingNext(self: *ShellHandlerMappingsReader) ?ShellHandlerMappingReader {
        if (self._mapping_offset == null) return null;
        const current_offset = self._mapping_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = ShellHandlerMappingReader.init(result.value) catch return null;
        if (self._mapping_last_offset != null and current_offset >= self._mapping_last_offset.?) {
            self._mapping_offset = null;
            return msg;
        }
        if (self._mapping_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._mapping_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ShellHandlerMappingsWire.MAPPING_WIRE) {
                self._mapping_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._mapping_offset = null;
        return msg;
    }
};
const ShellHandlerMappingWire = struct {
    const ID_WIRE: gremlin.ProtoWireNumber = 1;
    const NAME_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const ShellHandlerMapping = struct {
    // fields
    id: i32 = 0,
    name: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const ShellHandlerMapping) usize {
        var res: usize = 0;
        if (self.id != 0) {
            res += gremlin.sizes.sizeWireNumber(ShellHandlerMappingWire.ID_WIRE) + gremlin.sizes.sizeI32(self.id);
        }
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(ShellHandlerMappingWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const ShellHandlerMapping, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ShellHandlerMapping, target: *gremlin.Writer) void {
        if (self.id != 0) {
            target.appendInt32(ShellHandlerMappingWire.ID_WIRE, self.id);
        }
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(ShellHandlerMappingWire.NAME_WIRE, v);
            }
        }
    }
};
pub const ShellHandlerMappingReader = struct {
    buf: gremlin.Reader,
    _id: i32 = 0,
    _name: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!ShellHandlerMappingReader {
        const buf = gremlin.Reader.init(src);
        var res = ShellHandlerMappingReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ShellHandlerMappingWire.ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._id = result.value;
                },
                ShellHandlerMappingWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getId(self: *const ShellHandlerMappingReader) i32 {
        return self._id;
    }
    pub inline fn getName(self: *const ShellHandlerMappingReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
};
