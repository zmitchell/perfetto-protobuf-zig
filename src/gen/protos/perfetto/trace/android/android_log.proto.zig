// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
const android_log_constants = @import("src/gen/protos/perfetto/common/android_log_constants.proto.zig");
// structs
const AndroidLogPacketWire = struct {
    const EVENTS_WIRE: gremlin.ProtoWireNumber = 1;
    const STATS_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const AndroidLogPacket = struct {
    // nested structs
    const LogEventWire = struct {
        const LOG_ID_WIRE: gremlin.ProtoWireNumber = 1;
        const PID_WIRE: gremlin.ProtoWireNumber = 2;
        const TID_WIRE: gremlin.ProtoWireNumber = 3;
        const UID_WIRE: gremlin.ProtoWireNumber = 4;
        const TIMESTAMP_WIRE: gremlin.ProtoWireNumber = 5;
        const TAG_WIRE: gremlin.ProtoWireNumber = 6;
        const PRIO_WIRE: gremlin.ProtoWireNumber = 7;
        const MESSAGE_WIRE: gremlin.ProtoWireNumber = 8;
        const ARGS_WIRE: gremlin.ProtoWireNumber = 9;
    };
    pub const LogEvent = struct {
        // nested structs
        const ArgWire = struct {
            const NAME_WIRE: gremlin.ProtoWireNumber = 1;
            const INT_VALUE_WIRE: gremlin.ProtoWireNumber = 2;
            const FLOAT_VALUE_WIRE: gremlin.ProtoWireNumber = 3;
            const STRING_VALUE_WIRE: gremlin.ProtoWireNumber = 4;
        };
        pub const Arg = struct {
            // fields
            name: ?[]const u8 = null,
            int_value: i64 = 0,
            float_value: f32 = 0.0,
            string_value: ?[]const u8 = null,
            pub fn calcProtobufSize(self: *const AndroidLogPacket.LogEvent.Arg) usize {
                var res: usize = 0;
                if (self.name) |v| {
                    if (v.len > 0) {
                        res += gremlin.sizes.sizeWireNumber(AndroidLogPacket.LogEvent.ArgWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                    }
                }
                if (self.int_value != 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidLogPacket.LogEvent.ArgWire.INT_VALUE_WIRE) + gremlin.sizes.sizeI64(self.int_value);
                }
                if (self.float_value != 0.0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidLogPacket.LogEvent.ArgWire.FLOAT_VALUE_WIRE) + gremlin.sizes.sizeFloat(self.float_value);
                }
                if (self.string_value) |v| {
                    if (v.len > 0) {
                        res += gremlin.sizes.sizeWireNumber(AndroidLogPacket.LogEvent.ArgWire.STRING_VALUE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                    }
                }
                return res;
            }
            pub fn encode(self: *const AndroidLogPacket.LogEvent.Arg, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const AndroidLogPacket.LogEvent.Arg, target: *gremlin.Writer) void {
                if (self.name) |v| {
                    if (v.len > 0) {
                        target.appendBytes(AndroidLogPacket.LogEvent.ArgWire.NAME_WIRE, v);
                    }
                }
                if (self.int_value != 0) {
                    target.appendInt64(AndroidLogPacket.LogEvent.ArgWire.INT_VALUE_WIRE, self.int_value);
                }
                if (self.float_value != 0.0) {
                    target.appendFloat32(AndroidLogPacket.LogEvent.ArgWire.FLOAT_VALUE_WIRE, self.float_value);
                }
                if (self.string_value) |v| {
                    if (v.len > 0) {
                        target.appendBytes(AndroidLogPacket.LogEvent.ArgWire.STRING_VALUE_WIRE, v);
                    }
                }
            }
        };
        pub const ArgReader = struct {
            buf: gremlin.Reader,
            _name: ?[]const u8 = null,
            _int_value: i64 = 0,
            _float_value: f32 = 0.0,
            _string_value: ?[]const u8 = null,
            pub fn init(src: []const u8) gremlin.Error!AndroidLogPacket.LogEvent.ArgReader {
                const buf = gremlin.Reader.init(src);
                var res = AndroidLogPacket.LogEvent.ArgReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        AndroidLogPacket.LogEvent.ArgWire.NAME_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._name = result.value;
                        },
                        AndroidLogPacket.LogEvent.ArgWire.INT_VALUE_WIRE => {
                            const result = try buf.readInt64(offset);
                            offset += result.size;
                            res._int_value = result.value;
                        },
                        AndroidLogPacket.LogEvent.ArgWire.FLOAT_VALUE_WIRE => {
                            const result = try buf.readFloat32(offset);
                            offset += result.size;
                            res._float_value = result.value;
                        },
                        AndroidLogPacket.LogEvent.ArgWire.STRING_VALUE_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._string_value = result.value;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub inline fn getName(self: *const AndroidLogPacket.LogEvent.ArgReader) []const u8 {
                return self._name orelse &[_]u8{};
            }
            pub inline fn getIntValue(self: *const AndroidLogPacket.LogEvent.ArgReader) i64 {
                return self._int_value;
            }
            pub inline fn getFloatValue(self: *const AndroidLogPacket.LogEvent.ArgReader) f32 {
                return self._float_value;
            }
            pub inline fn getStringValue(self: *const AndroidLogPacket.LogEvent.ArgReader) []const u8 {
                return self._string_value orelse &[_]u8{};
            }
        };
        // fields
        log_id: android_log_constants.AndroidLogId = @enumFromInt(0),
        pid: i32 = 0,
        tid: i32 = 0,
        uid: i32 = 0,
        timestamp: u64 = 0,
        tag: ?[]const u8 = null,
        prio: android_log_constants.AndroidLogPriority = @enumFromInt(0),
        message: ?[]const u8 = null,
        args: ?[]const ?AndroidLogPacket.LogEvent.Arg = null,
        pub fn calcProtobufSize(self: *const AndroidLogPacket.LogEvent) usize {
            var res: usize = 0;
            if (@intFromEnum(self.log_id) != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidLogPacket.LogEventWire.LOG_ID_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.log_id));
            }
            if (self.pid != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidLogPacket.LogEventWire.PID_WIRE) + gremlin.sizes.sizeI32(self.pid);
            }
            if (self.tid != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidLogPacket.LogEventWire.TID_WIRE) + gremlin.sizes.sizeI32(self.tid);
            }
            if (self.uid != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidLogPacket.LogEventWire.UID_WIRE) + gremlin.sizes.sizeI32(self.uid);
            }
            if (self.timestamp != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidLogPacket.LogEventWire.TIMESTAMP_WIRE) + gremlin.sizes.sizeU64(self.timestamp);
            }
            if (self.tag) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidLogPacket.LogEventWire.TAG_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (@intFromEnum(self.prio) != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidLogPacket.LogEventWire.PRIO_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.prio));
            }
            if (self.message) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidLogPacket.LogEventWire.MESSAGE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.args) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidLogPacket.LogEventWire.ARGS_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidLogPacket.LogEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidLogPacket.LogEvent, target: *gremlin.Writer) void {
            if (@intFromEnum(self.log_id) != 0) {
                target.appendInt32(AndroidLogPacket.LogEventWire.LOG_ID_WIRE, @intFromEnum(self.log_id));
            }
            if (self.pid != 0) {
                target.appendInt32(AndroidLogPacket.LogEventWire.PID_WIRE, self.pid);
            }
            if (self.tid != 0) {
                target.appendInt32(AndroidLogPacket.LogEventWire.TID_WIRE, self.tid);
            }
            if (self.uid != 0) {
                target.appendInt32(AndroidLogPacket.LogEventWire.UID_WIRE, self.uid);
            }
            if (self.timestamp != 0) {
                target.appendUint64(AndroidLogPacket.LogEventWire.TIMESTAMP_WIRE, self.timestamp);
            }
            if (self.tag) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidLogPacket.LogEventWire.TAG_WIRE, v);
                }
            }
            if (@intFromEnum(self.prio) != 0) {
                target.appendInt32(AndroidLogPacket.LogEventWire.PRIO_WIRE, @intFromEnum(self.prio));
            }
            if (self.message) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidLogPacket.LogEventWire.MESSAGE_WIRE, v);
                }
            }
            if (self.args) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidLogPacket.LogEventWire.ARGS_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidLogPacket.LogEventWire.ARGS_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const LogEventReader = struct {
        buf: gremlin.Reader,
        _log_id: android_log_constants.AndroidLogId = @enumFromInt(0),
        _pid: i32 = 0,
        _tid: i32 = 0,
        _uid: i32 = 0,
        _timestamp: u64 = 0,
        _tag: ?[]const u8 = null,
        _prio: android_log_constants.AndroidLogPriority = @enumFromInt(0),
        _message: ?[]const u8 = null,
        _args_offset: ?usize = null,
        _args_last_offset: ?usize = null,
        _args_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidLogPacket.LogEventReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidLogPacket.LogEventReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidLogPacket.LogEventWire.LOG_ID_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._log_id = @enumFromInt(result.value);
                    },
                    AndroidLogPacket.LogEventWire.PID_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._pid = result.value;
                    },
                    AndroidLogPacket.LogEventWire.TID_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._tid = result.value;
                    },
                    AndroidLogPacket.LogEventWire.UID_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._uid = result.value;
                    },
                    AndroidLogPacket.LogEventWire.TIMESTAMP_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._timestamp = result.value;
                    },
                    AndroidLogPacket.LogEventWire.TAG_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._tag = result.value;
                    },
                    AndroidLogPacket.LogEventWire.PRIO_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._prio = @enumFromInt(result.value);
                    },
                    AndroidLogPacket.LogEventWire.MESSAGE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._message = result.value;
                    },
                    AndroidLogPacket.LogEventWire.ARGS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._args_offset == null) {
                            res._args_offset = offset - result.size;
                        }
                        res._args_last_offset = offset;
                        res._args_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getLogId(self: *const AndroidLogPacket.LogEventReader) android_log_constants.AndroidLogId {
            return self._log_id;
        }
        pub inline fn getPid(self: *const AndroidLogPacket.LogEventReader) i32 {
            return self._pid;
        }
        pub inline fn getTid(self: *const AndroidLogPacket.LogEventReader) i32 {
            return self._tid;
        }
        pub inline fn getUid(self: *const AndroidLogPacket.LogEventReader) i32 {
            return self._uid;
        }
        pub inline fn getTimestamp(self: *const AndroidLogPacket.LogEventReader) u64 {
            return self._timestamp;
        }
        pub inline fn getTag(self: *const AndroidLogPacket.LogEventReader) []const u8 {
            return self._tag orelse &[_]u8{};
        }
        pub inline fn getPrio(self: *const AndroidLogPacket.LogEventReader) android_log_constants.AndroidLogPriority {
            return self._prio;
        }
        pub inline fn getMessage(self: *const AndroidLogPacket.LogEventReader) []const u8 {
            return self._message orelse &[_]u8{};
        }
        pub fn argsCount(self: *const AndroidLogPacket.LogEventReader) usize {
            return self._args_cnt;
        }
        pub fn argsNext(self: *AndroidLogPacket.LogEventReader) ?AndroidLogPacket.LogEvent.ArgReader {
            if (self._args_offset == null) return null;
            const current_offset = self._args_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidLogPacket.LogEvent.ArgReader.init(result.value) catch return null;
            if (self._args_last_offset != null and current_offset >= self._args_last_offset.?) {
                self._args_offset = null;
                return msg;
            }
            if (self._args_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._args_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidLogPacket.LogEventWire.ARGS_WIRE) {
                    self._args_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._args_offset = null;
            return msg;
        }
    };
    const StatsWire = struct {
        const NUM_TOTAL_WIRE: gremlin.ProtoWireNumber = 1;
        const NUM_FAILED_WIRE: gremlin.ProtoWireNumber = 2;
        const NUM_SKIPPED_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const Stats = struct {
        // fields
        num_total: u64 = 0,
        num_failed: u64 = 0,
        num_skipped: u64 = 0,
        pub fn calcProtobufSize(self: *const AndroidLogPacket.Stats) usize {
            var res: usize = 0;
            if (self.num_total != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidLogPacket.StatsWire.NUM_TOTAL_WIRE) + gremlin.sizes.sizeU64(self.num_total);
            }
            if (self.num_failed != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidLogPacket.StatsWire.NUM_FAILED_WIRE) + gremlin.sizes.sizeU64(self.num_failed);
            }
            if (self.num_skipped != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidLogPacket.StatsWire.NUM_SKIPPED_WIRE) + gremlin.sizes.sizeU64(self.num_skipped);
            }
            return res;
        }
        pub fn encode(self: *const AndroidLogPacket.Stats, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidLogPacket.Stats, target: *gremlin.Writer) void {
            if (self.num_total != 0) {
                target.appendUint64(AndroidLogPacket.StatsWire.NUM_TOTAL_WIRE, self.num_total);
            }
            if (self.num_failed != 0) {
                target.appendUint64(AndroidLogPacket.StatsWire.NUM_FAILED_WIRE, self.num_failed);
            }
            if (self.num_skipped != 0) {
                target.appendUint64(AndroidLogPacket.StatsWire.NUM_SKIPPED_WIRE, self.num_skipped);
            }
        }
    };
    pub const StatsReader = struct {
        buf: gremlin.Reader,
        _num_total: u64 = 0,
        _num_failed: u64 = 0,
        _num_skipped: u64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidLogPacket.StatsReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidLogPacket.StatsReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidLogPacket.StatsWire.NUM_TOTAL_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._num_total = result.value;
                    },
                    AndroidLogPacket.StatsWire.NUM_FAILED_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._num_failed = result.value;
                    },
                    AndroidLogPacket.StatsWire.NUM_SKIPPED_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._num_skipped = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getNumTotal(self: *const AndroidLogPacket.StatsReader) u64 {
            return self._num_total;
        }
        pub inline fn getNumFailed(self: *const AndroidLogPacket.StatsReader) u64 {
            return self._num_failed;
        }
        pub inline fn getNumSkipped(self: *const AndroidLogPacket.StatsReader) u64 {
            return self._num_skipped;
        }
    };
    // fields
    events: ?[]const ?AndroidLogPacket.LogEvent = null,
    stats: ?AndroidLogPacket.Stats = null,
    pub fn calcProtobufSize(self: *const AndroidLogPacket) usize {
        var res: usize = 0;
        if (self.events) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidLogPacketWire.EVENTS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.stats) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidLogPacketWire.STATS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidLogPacket, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidLogPacket, target: *gremlin.Writer) void {
        if (self.events) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidLogPacketWire.EVENTS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidLogPacketWire.EVENTS_WIRE, 0);
                }
            }
        }
        if (self.stats) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidLogPacketWire.STATS_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const AndroidLogPacketReader = struct {
    buf: gremlin.Reader,
    _events_offset: ?usize = null,
    _events_last_offset: ?usize = null,
    _events_cnt: usize = 0,
    _stats_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!AndroidLogPacketReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidLogPacketReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidLogPacketWire.EVENTS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._events_offset == null) {
                        res._events_offset = offset - result.size;
                    }
                    res._events_last_offset = offset;
                    res._events_cnt += 1;
                },
                AndroidLogPacketWire.STATS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._stats_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn eventsCount(self: *const AndroidLogPacketReader) usize {
        return self._events_cnt;
    }
    pub fn eventsNext(self: *AndroidLogPacketReader) ?AndroidLogPacket.LogEventReader {
        if (self._events_offset == null) return null;
        const current_offset = self._events_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidLogPacket.LogEventReader.init(result.value) catch return null;
        if (self._events_last_offset != null and current_offset >= self._events_last_offset.?) {
            self._events_offset = null;
            return msg;
        }
        if (self._events_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._events_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidLogPacketWire.EVENTS_WIRE) {
                self._events_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._events_offset = null;
        return msg;
    }
    pub fn getStats(self: *const AndroidLogPacketReader) gremlin.Error!AndroidLogPacket.StatsReader {
        if (self._stats_buf) |buf| {
            return try AndroidLogPacket.StatsReader.init(buf);
        }
        return try AndroidLogPacket.StatsReader.init(&[_]u8{});
    }
};
