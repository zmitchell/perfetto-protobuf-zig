// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
const softinputwindow = @import("softinputwindow.proto.zig");
const editorinfo = @import("src/gen/protos/perfetto/trace/android/view/inputmethod/editorinfo.proto.zig");
const inputconnection = @import("src/gen/protos/perfetto/trace/android/view/inputmethod/inputconnection.proto.zig");
// structs
const InputMethodServiceProtoWire = struct {
    const SOFT_INPUT_WINDOW_WIRE: gremlin.ProtoWireNumber = 1;
    const VIEWS_CREATED_WIRE: gremlin.ProtoWireNumber = 2;
    const DECOR_VIEW_VISIBLE_WIRE: gremlin.ProtoWireNumber = 3;
    const DECOR_VIEW_WAS_VISIBLE_WIRE: gremlin.ProtoWireNumber = 4;
    const WINDOW_VISIBLE_WIRE: gremlin.ProtoWireNumber = 5;
    const IN_SHOW_WINDOW_WIRE: gremlin.ProtoWireNumber = 6;
    const CONFIGURATION_WIRE: gremlin.ProtoWireNumber = 7;
    const TOKEN_WIRE: gremlin.ProtoWireNumber = 8;
    const INPUT_BINDING_WIRE: gremlin.ProtoWireNumber = 9;
    const INPUT_STARTED_WIRE: gremlin.ProtoWireNumber = 10;
    const INPUT_VIEW_STARTED_WIRE: gremlin.ProtoWireNumber = 11;
    const CANDIDATES_VIEW_STARTED_WIRE: gremlin.ProtoWireNumber = 12;
    const INPUT_EDITOR_INFO_WIRE: gremlin.ProtoWireNumber = 13;
    const SHOW_INPUT_REQUESTED_WIRE: gremlin.ProtoWireNumber = 14;
    const LAST_SHOW_INPUT_REQUESTED_WIRE: gremlin.ProtoWireNumber = 15;
    const SHOW_INPUT_FLAGS_WIRE: gremlin.ProtoWireNumber = 18;
    const CANDIDATES_VISIBILITY_WIRE: gremlin.ProtoWireNumber = 19;
    const FULLSCREEN_APPLIED_WIRE: gremlin.ProtoWireNumber = 20;
    const IS_FULLSCREEN_WIRE: gremlin.ProtoWireNumber = 21;
    const EXTRACT_VIEW_HIDDEN_WIRE: gremlin.ProtoWireNumber = 22;
    const EXTRACTED_TOKEN_WIRE: gremlin.ProtoWireNumber = 23;
    const IS_INPUT_VIEW_SHOWN_WIRE: gremlin.ProtoWireNumber = 24;
    const STATUS_ICON_WIRE: gremlin.ProtoWireNumber = 25;
    const LAST_COMPUTED_INSETS_WIRE: gremlin.ProtoWireNumber = 26;
    const SETTINGS_OBSERVER_WIRE: gremlin.ProtoWireNumber = 27;
    const INPUT_CONNECTION_CALL_WIRE: gremlin.ProtoWireNumber = 28;
};
pub const InputMethodServiceProto = struct {
    // nested structs
    const InsetsProtoWire = struct {
        const CONTENT_TOP_INSETS_WIRE: gremlin.ProtoWireNumber = 1;
        const VISIBLE_TOP_INSETS_WIRE: gremlin.ProtoWireNumber = 2;
        const TOUCHABLE_INSETS_WIRE: gremlin.ProtoWireNumber = 3;
        const TOUCHABLE_REGION_WIRE: gremlin.ProtoWireNumber = 4;
    };
    pub const InsetsProto = struct {
        // fields
        content_top_insets: i32 = 0,
        visible_top_insets: i32 = 0,
        touchable_insets: i32 = 0,
        touchable_region: ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const InputMethodServiceProto.InsetsProto) usize {
            var res: usize = 0;
            if (self.content_top_insets != 0) {
                res += gremlin.sizes.sizeWireNumber(InputMethodServiceProto.InsetsProtoWire.CONTENT_TOP_INSETS_WIRE) + gremlin.sizes.sizeI32(self.content_top_insets);
            }
            if (self.visible_top_insets != 0) {
                res += gremlin.sizes.sizeWireNumber(InputMethodServiceProto.InsetsProtoWire.VISIBLE_TOP_INSETS_WIRE) + gremlin.sizes.sizeI32(self.visible_top_insets);
            }
            if (self.touchable_insets != 0) {
                res += gremlin.sizes.sizeWireNumber(InputMethodServiceProto.InsetsProtoWire.TOUCHABLE_INSETS_WIRE) + gremlin.sizes.sizeI32(self.touchable_insets);
            }
            if (self.touchable_region) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(InputMethodServiceProto.InsetsProtoWire.TOUCHABLE_REGION_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            return res;
        }
        pub fn encode(self: *const InputMethodServiceProto.InsetsProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const InputMethodServiceProto.InsetsProto, target: *gremlin.Writer) void {
            if (self.content_top_insets != 0) {
                target.appendInt32(InputMethodServiceProto.InsetsProtoWire.CONTENT_TOP_INSETS_WIRE, self.content_top_insets);
            }
            if (self.visible_top_insets != 0) {
                target.appendInt32(InputMethodServiceProto.InsetsProtoWire.VISIBLE_TOP_INSETS_WIRE, self.visible_top_insets);
            }
            if (self.touchable_insets != 0) {
                target.appendInt32(InputMethodServiceProto.InsetsProtoWire.TOUCHABLE_INSETS_WIRE, self.touchable_insets);
            }
            if (self.touchable_region) |v| {
                if (v.len > 0) {
                    target.appendBytes(InputMethodServiceProto.InsetsProtoWire.TOUCHABLE_REGION_WIRE, v);
                }
            }
        }
    };
    pub const InsetsProtoReader = struct {
        buf: gremlin.Reader,
        _content_top_insets: i32 = 0,
        _visible_top_insets: i32 = 0,
        _touchable_insets: i32 = 0,
        _touchable_region: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!InputMethodServiceProto.InsetsProtoReader {
            const buf = gremlin.Reader.init(src);
            var res = InputMethodServiceProto.InsetsProtoReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    InputMethodServiceProto.InsetsProtoWire.CONTENT_TOP_INSETS_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._content_top_insets = result.value;
                    },
                    InputMethodServiceProto.InsetsProtoWire.VISIBLE_TOP_INSETS_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._visible_top_insets = result.value;
                    },
                    InputMethodServiceProto.InsetsProtoWire.TOUCHABLE_INSETS_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._touchable_insets = result.value;
                    },
                    InputMethodServiceProto.InsetsProtoWire.TOUCHABLE_REGION_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._touchable_region = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getContentTopInsets(self: *const InputMethodServiceProto.InsetsProtoReader) i32 {
            return self._content_top_insets;
        }
        pub inline fn getVisibleTopInsets(self: *const InputMethodServiceProto.InsetsProtoReader) i32 {
            return self._visible_top_insets;
        }
        pub inline fn getTouchableInsets(self: *const InputMethodServiceProto.InsetsProtoReader) i32 {
            return self._touchable_insets;
        }
        pub inline fn getTouchableRegion(self: *const InputMethodServiceProto.InsetsProtoReader) []const u8 {
            return self._touchable_region orelse &[_]u8{};
        }
    };
    // fields
    soft_input_window: ?softinputwindow.SoftInputWindowProto = null,
    views_created: bool = false,
    decor_view_visible: bool = false,
    decor_view_was_visible: bool = false,
    window_visible: bool = false,
    in_show_window: bool = false,
    configuration: ?[]const u8 = null,
    token: ?[]const u8 = null,
    input_binding: ?[]const u8 = null,
    input_started: bool = false,
    input_view_started: bool = false,
    candidates_view_started: bool = false,
    input_editor_info: ?editorinfo.EditorInfoProto = null,
    show_input_requested: bool = false,
    last_show_input_requested: bool = false,
    show_input_flags: i32 = 0,
    candidates_visibility: i32 = 0,
    fullscreen_applied: bool = false,
    is_fullscreen: bool = false,
    extract_view_hidden: bool = false,
    extracted_token: i32 = 0,
    is_input_view_shown: bool = false,
    status_icon: i32 = 0,
    last_computed_insets: ?InputMethodServiceProto.InsetsProto = null,
    settings_observer: ?[]const u8 = null,
    input_connection_call: ?inputconnection.InputConnectionCallProto = null,
    pub fn calcProtobufSize(self: *const InputMethodServiceProto) usize {
        var res: usize = 0;
        if (self.soft_input_window) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(InputMethodServiceProtoWire.SOFT_INPUT_WINDOW_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.views_created != false) {
            res += gremlin.sizes.sizeWireNumber(InputMethodServiceProtoWire.VIEWS_CREATED_WIRE) + gremlin.sizes.sizeBool(self.views_created);
        }
        if (self.decor_view_visible != false) {
            res += gremlin.sizes.sizeWireNumber(InputMethodServiceProtoWire.DECOR_VIEW_VISIBLE_WIRE) + gremlin.sizes.sizeBool(self.decor_view_visible);
        }
        if (self.decor_view_was_visible != false) {
            res += gremlin.sizes.sizeWireNumber(InputMethodServiceProtoWire.DECOR_VIEW_WAS_VISIBLE_WIRE) + gremlin.sizes.sizeBool(self.decor_view_was_visible);
        }
        if (self.window_visible != false) {
            res += gremlin.sizes.sizeWireNumber(InputMethodServiceProtoWire.WINDOW_VISIBLE_WIRE) + gremlin.sizes.sizeBool(self.window_visible);
        }
        if (self.in_show_window != false) {
            res += gremlin.sizes.sizeWireNumber(InputMethodServiceProtoWire.IN_SHOW_WINDOW_WIRE) + gremlin.sizes.sizeBool(self.in_show_window);
        }
        if (self.configuration) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(InputMethodServiceProtoWire.CONFIGURATION_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.token) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(InputMethodServiceProtoWire.TOKEN_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.input_binding) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(InputMethodServiceProtoWire.INPUT_BINDING_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.input_started != false) {
            res += gremlin.sizes.sizeWireNumber(InputMethodServiceProtoWire.INPUT_STARTED_WIRE) + gremlin.sizes.sizeBool(self.input_started);
        }
        if (self.input_view_started != false) {
            res += gremlin.sizes.sizeWireNumber(InputMethodServiceProtoWire.INPUT_VIEW_STARTED_WIRE) + gremlin.sizes.sizeBool(self.input_view_started);
        }
        if (self.candidates_view_started != false) {
            res += gremlin.sizes.sizeWireNumber(InputMethodServiceProtoWire.CANDIDATES_VIEW_STARTED_WIRE) + gremlin.sizes.sizeBool(self.candidates_view_started);
        }
        if (self.input_editor_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(InputMethodServiceProtoWire.INPUT_EDITOR_INFO_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.show_input_requested != false) {
            res += gremlin.sizes.sizeWireNumber(InputMethodServiceProtoWire.SHOW_INPUT_REQUESTED_WIRE) + gremlin.sizes.sizeBool(self.show_input_requested);
        }
        if (self.last_show_input_requested != false) {
            res += gremlin.sizes.sizeWireNumber(InputMethodServiceProtoWire.LAST_SHOW_INPUT_REQUESTED_WIRE) + gremlin.sizes.sizeBool(self.last_show_input_requested);
        }
        if (self.show_input_flags != 0) {
            res += gremlin.sizes.sizeWireNumber(InputMethodServiceProtoWire.SHOW_INPUT_FLAGS_WIRE) + gremlin.sizes.sizeI32(self.show_input_flags);
        }
        if (self.candidates_visibility != 0) {
            res += gremlin.sizes.sizeWireNumber(InputMethodServiceProtoWire.CANDIDATES_VISIBILITY_WIRE) + gremlin.sizes.sizeI32(self.candidates_visibility);
        }
        if (self.fullscreen_applied != false) {
            res += gremlin.sizes.sizeWireNumber(InputMethodServiceProtoWire.FULLSCREEN_APPLIED_WIRE) + gremlin.sizes.sizeBool(self.fullscreen_applied);
        }
        if (self.is_fullscreen != false) {
            res += gremlin.sizes.sizeWireNumber(InputMethodServiceProtoWire.IS_FULLSCREEN_WIRE) + gremlin.sizes.sizeBool(self.is_fullscreen);
        }
        if (self.extract_view_hidden != false) {
            res += gremlin.sizes.sizeWireNumber(InputMethodServiceProtoWire.EXTRACT_VIEW_HIDDEN_WIRE) + gremlin.sizes.sizeBool(self.extract_view_hidden);
        }
        if (self.extracted_token != 0) {
            res += gremlin.sizes.sizeWireNumber(InputMethodServiceProtoWire.EXTRACTED_TOKEN_WIRE) + gremlin.sizes.sizeI32(self.extracted_token);
        }
        if (self.is_input_view_shown != false) {
            res += gremlin.sizes.sizeWireNumber(InputMethodServiceProtoWire.IS_INPUT_VIEW_SHOWN_WIRE) + gremlin.sizes.sizeBool(self.is_input_view_shown);
        }
        if (self.status_icon != 0) {
            res += gremlin.sizes.sizeWireNumber(InputMethodServiceProtoWire.STATUS_ICON_WIRE) + gremlin.sizes.sizeI32(self.status_icon);
        }
        if (self.last_computed_insets) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(InputMethodServiceProtoWire.LAST_COMPUTED_INSETS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.settings_observer) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(InputMethodServiceProtoWire.SETTINGS_OBSERVER_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.input_connection_call) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(InputMethodServiceProtoWire.INPUT_CONNECTION_CALL_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const InputMethodServiceProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const InputMethodServiceProto, target: *gremlin.Writer) void {
        if (self.soft_input_window) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(InputMethodServiceProtoWire.SOFT_INPUT_WINDOW_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.views_created != false) {
            target.appendBool(InputMethodServiceProtoWire.VIEWS_CREATED_WIRE, self.views_created);
        }
        if (self.decor_view_visible != false) {
            target.appendBool(InputMethodServiceProtoWire.DECOR_VIEW_VISIBLE_WIRE, self.decor_view_visible);
        }
        if (self.decor_view_was_visible != false) {
            target.appendBool(InputMethodServiceProtoWire.DECOR_VIEW_WAS_VISIBLE_WIRE, self.decor_view_was_visible);
        }
        if (self.window_visible != false) {
            target.appendBool(InputMethodServiceProtoWire.WINDOW_VISIBLE_WIRE, self.window_visible);
        }
        if (self.in_show_window != false) {
            target.appendBool(InputMethodServiceProtoWire.IN_SHOW_WINDOW_WIRE, self.in_show_window);
        }
        if (self.configuration) |v| {
            if (v.len > 0) {
                target.appendBytes(InputMethodServiceProtoWire.CONFIGURATION_WIRE, v);
            }
        }
        if (self.token) |v| {
            if (v.len > 0) {
                target.appendBytes(InputMethodServiceProtoWire.TOKEN_WIRE, v);
            }
        }
        if (self.input_binding) |v| {
            if (v.len > 0) {
                target.appendBytes(InputMethodServiceProtoWire.INPUT_BINDING_WIRE, v);
            }
        }
        if (self.input_started != false) {
            target.appendBool(InputMethodServiceProtoWire.INPUT_STARTED_WIRE, self.input_started);
        }
        if (self.input_view_started != false) {
            target.appendBool(InputMethodServiceProtoWire.INPUT_VIEW_STARTED_WIRE, self.input_view_started);
        }
        if (self.candidates_view_started != false) {
            target.appendBool(InputMethodServiceProtoWire.CANDIDATES_VIEW_STARTED_WIRE, self.candidates_view_started);
        }
        if (self.input_editor_info) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(InputMethodServiceProtoWire.INPUT_EDITOR_INFO_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.show_input_requested != false) {
            target.appendBool(InputMethodServiceProtoWire.SHOW_INPUT_REQUESTED_WIRE, self.show_input_requested);
        }
        if (self.last_show_input_requested != false) {
            target.appendBool(InputMethodServiceProtoWire.LAST_SHOW_INPUT_REQUESTED_WIRE, self.last_show_input_requested);
        }
        if (self.show_input_flags != 0) {
            target.appendInt32(InputMethodServiceProtoWire.SHOW_INPUT_FLAGS_WIRE, self.show_input_flags);
        }
        if (self.candidates_visibility != 0) {
            target.appendInt32(InputMethodServiceProtoWire.CANDIDATES_VISIBILITY_WIRE, self.candidates_visibility);
        }
        if (self.fullscreen_applied != false) {
            target.appendBool(InputMethodServiceProtoWire.FULLSCREEN_APPLIED_WIRE, self.fullscreen_applied);
        }
        if (self.is_fullscreen != false) {
            target.appendBool(InputMethodServiceProtoWire.IS_FULLSCREEN_WIRE, self.is_fullscreen);
        }
        if (self.extract_view_hidden != false) {
            target.appendBool(InputMethodServiceProtoWire.EXTRACT_VIEW_HIDDEN_WIRE, self.extract_view_hidden);
        }
        if (self.extracted_token != 0) {
            target.appendInt32(InputMethodServiceProtoWire.EXTRACTED_TOKEN_WIRE, self.extracted_token);
        }
        if (self.is_input_view_shown != false) {
            target.appendBool(InputMethodServiceProtoWire.IS_INPUT_VIEW_SHOWN_WIRE, self.is_input_view_shown);
        }
        if (self.status_icon != 0) {
            target.appendInt32(InputMethodServiceProtoWire.STATUS_ICON_WIRE, self.status_icon);
        }
        if (self.last_computed_insets) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(InputMethodServiceProtoWire.LAST_COMPUTED_INSETS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.settings_observer) |v| {
            if (v.len > 0) {
                target.appendBytes(InputMethodServiceProtoWire.SETTINGS_OBSERVER_WIRE, v);
            }
        }
        if (self.input_connection_call) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(InputMethodServiceProtoWire.INPUT_CONNECTION_CALL_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const InputMethodServiceProtoReader = struct {
    buf: gremlin.Reader,
    _soft_input_window_buf: ?[]const u8 = null,
    _views_created: bool = false,
    _decor_view_visible: bool = false,
    _decor_view_was_visible: bool = false,
    _window_visible: bool = false,
    _in_show_window: bool = false,
    _configuration: ?[]const u8 = null,
    _token: ?[]const u8 = null,
    _input_binding: ?[]const u8 = null,
    _input_started: bool = false,
    _input_view_started: bool = false,
    _candidates_view_started: bool = false,
    _input_editor_info_buf: ?[]const u8 = null,
    _show_input_requested: bool = false,
    _last_show_input_requested: bool = false,
    _show_input_flags: i32 = 0,
    _candidates_visibility: i32 = 0,
    _fullscreen_applied: bool = false,
    _is_fullscreen: bool = false,
    _extract_view_hidden: bool = false,
    _extracted_token: i32 = 0,
    _is_input_view_shown: bool = false,
    _status_icon: i32 = 0,
    _last_computed_insets_buf: ?[]const u8 = null,
    _settings_observer: ?[]const u8 = null,
    _input_connection_call_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!InputMethodServiceProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = InputMethodServiceProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                InputMethodServiceProtoWire.SOFT_INPUT_WINDOW_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._soft_input_window_buf = result.value;
                },
                InputMethodServiceProtoWire.VIEWS_CREATED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._views_created = result.value;
                },
                InputMethodServiceProtoWire.DECOR_VIEW_VISIBLE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._decor_view_visible = result.value;
                },
                InputMethodServiceProtoWire.DECOR_VIEW_WAS_VISIBLE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._decor_view_was_visible = result.value;
                },
                InputMethodServiceProtoWire.WINDOW_VISIBLE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._window_visible = result.value;
                },
                InputMethodServiceProtoWire.IN_SHOW_WINDOW_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._in_show_window = result.value;
                },
                InputMethodServiceProtoWire.CONFIGURATION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._configuration = result.value;
                },
                InputMethodServiceProtoWire.TOKEN_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._token = result.value;
                },
                InputMethodServiceProtoWire.INPUT_BINDING_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._input_binding = result.value;
                },
                InputMethodServiceProtoWire.INPUT_STARTED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._input_started = result.value;
                },
                InputMethodServiceProtoWire.INPUT_VIEW_STARTED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._input_view_started = result.value;
                },
                InputMethodServiceProtoWire.CANDIDATES_VIEW_STARTED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._candidates_view_started = result.value;
                },
                InputMethodServiceProtoWire.INPUT_EDITOR_INFO_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._input_editor_info_buf = result.value;
                },
                InputMethodServiceProtoWire.SHOW_INPUT_REQUESTED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._show_input_requested = result.value;
                },
                InputMethodServiceProtoWire.LAST_SHOW_INPUT_REQUESTED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._last_show_input_requested = result.value;
                },
                InputMethodServiceProtoWire.SHOW_INPUT_FLAGS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._show_input_flags = result.value;
                },
                InputMethodServiceProtoWire.CANDIDATES_VISIBILITY_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._candidates_visibility = result.value;
                },
                InputMethodServiceProtoWire.FULLSCREEN_APPLIED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._fullscreen_applied = result.value;
                },
                InputMethodServiceProtoWire.IS_FULLSCREEN_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_fullscreen = result.value;
                },
                InputMethodServiceProtoWire.EXTRACT_VIEW_HIDDEN_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._extract_view_hidden = result.value;
                },
                InputMethodServiceProtoWire.EXTRACTED_TOKEN_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._extracted_token = result.value;
                },
                InputMethodServiceProtoWire.IS_INPUT_VIEW_SHOWN_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_input_view_shown = result.value;
                },
                InputMethodServiceProtoWire.STATUS_ICON_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._status_icon = result.value;
                },
                InputMethodServiceProtoWire.LAST_COMPUTED_INSETS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._last_computed_insets_buf = result.value;
                },
                InputMethodServiceProtoWire.SETTINGS_OBSERVER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._settings_observer = result.value;
                },
                InputMethodServiceProtoWire.INPUT_CONNECTION_CALL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._input_connection_call_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getSoftInputWindow(self: *const InputMethodServiceProtoReader) gremlin.Error!softinputwindow.SoftInputWindowProtoReader {
        if (self._soft_input_window_buf) |buf| {
            return try softinputwindow.SoftInputWindowProtoReader.init(buf);
        }
        return try softinputwindow.SoftInputWindowProtoReader.init(&[_]u8{});
    }
    pub inline fn getViewsCreated(self: *const InputMethodServiceProtoReader) bool {
        return self._views_created;
    }
    pub inline fn getDecorViewVisible(self: *const InputMethodServiceProtoReader) bool {
        return self._decor_view_visible;
    }
    pub inline fn getDecorViewWasVisible(self: *const InputMethodServiceProtoReader) bool {
        return self._decor_view_was_visible;
    }
    pub inline fn getWindowVisible(self: *const InputMethodServiceProtoReader) bool {
        return self._window_visible;
    }
    pub inline fn getInShowWindow(self: *const InputMethodServiceProtoReader) bool {
        return self._in_show_window;
    }
    pub inline fn getConfiguration(self: *const InputMethodServiceProtoReader) []const u8 {
        return self._configuration orelse &[_]u8{};
    }
    pub inline fn getToken(self: *const InputMethodServiceProtoReader) []const u8 {
        return self._token orelse &[_]u8{};
    }
    pub inline fn getInputBinding(self: *const InputMethodServiceProtoReader) []const u8 {
        return self._input_binding orelse &[_]u8{};
    }
    pub inline fn getInputStarted(self: *const InputMethodServiceProtoReader) bool {
        return self._input_started;
    }
    pub inline fn getInputViewStarted(self: *const InputMethodServiceProtoReader) bool {
        return self._input_view_started;
    }
    pub inline fn getCandidatesViewStarted(self: *const InputMethodServiceProtoReader) bool {
        return self._candidates_view_started;
    }
    pub fn getInputEditorInfo(self: *const InputMethodServiceProtoReader) gremlin.Error!editorinfo.EditorInfoProtoReader {
        if (self._input_editor_info_buf) |buf| {
            return try editorinfo.EditorInfoProtoReader.init(buf);
        }
        return try editorinfo.EditorInfoProtoReader.init(&[_]u8{});
    }
    pub inline fn getShowInputRequested(self: *const InputMethodServiceProtoReader) bool {
        return self._show_input_requested;
    }
    pub inline fn getLastShowInputRequested(self: *const InputMethodServiceProtoReader) bool {
        return self._last_show_input_requested;
    }
    pub inline fn getShowInputFlags(self: *const InputMethodServiceProtoReader) i32 {
        return self._show_input_flags;
    }
    pub inline fn getCandidatesVisibility(self: *const InputMethodServiceProtoReader) i32 {
        return self._candidates_visibility;
    }
    pub inline fn getFullscreenApplied(self: *const InputMethodServiceProtoReader) bool {
        return self._fullscreen_applied;
    }
    pub inline fn getIsFullscreen(self: *const InputMethodServiceProtoReader) bool {
        return self._is_fullscreen;
    }
    pub inline fn getExtractViewHidden(self: *const InputMethodServiceProtoReader) bool {
        return self._extract_view_hidden;
    }
    pub inline fn getExtractedToken(self: *const InputMethodServiceProtoReader) i32 {
        return self._extracted_token;
    }
    pub inline fn getIsInputViewShown(self: *const InputMethodServiceProtoReader) bool {
        return self._is_input_view_shown;
    }
    pub inline fn getStatusIcon(self: *const InputMethodServiceProtoReader) i32 {
        return self._status_icon;
    }
    pub fn getLastComputedInsets(self: *const InputMethodServiceProtoReader) gremlin.Error!InputMethodServiceProto.InsetsProtoReader {
        if (self._last_computed_insets_buf) |buf| {
            return try InputMethodServiceProto.InsetsProtoReader.init(buf);
        }
        return try InputMethodServiceProto.InsetsProtoReader.init(&[_]u8{});
    }
    pub inline fn getSettingsObserver(self: *const InputMethodServiceProtoReader) []const u8 {
        return self._settings_observer orelse &[_]u8{};
    }
    pub fn getInputConnectionCall(self: *const InputMethodServiceProtoReader) gremlin.Error!inputconnection.InputConnectionCallProtoReader {
        if (self._input_connection_call_buf) |buf| {
            return try inputconnection.InputConnectionCallProtoReader.init(buf);
        }
        return try inputconnection.InputConnectionCallProtoReader.init(&[_]u8{});
    }
};
