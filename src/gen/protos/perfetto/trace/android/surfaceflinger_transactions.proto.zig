// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
const surfaceflinger_common = @import("surfaceflinger_common.proto.zig");
const rect = @import("src/gen/protos/perfetto/trace/android/graphics/rect.proto.zig");
// structs
const TransactionTraceFileWire = struct {
    const MAGIC_NUMBER_WIRE: gremlin.ProtoWireNumber = 1;
    const ENTRY_WIRE: gremlin.ProtoWireNumber = 2;
    const REAL_TO_ELAPSED_TIME_OFFSET_NANOS_WIRE: gremlin.ProtoWireNumber = 3;
    const VERSION_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const TransactionTraceFile = struct {
    // nested enums
    pub const MagicNumber = enum(i32) {
        INVALID = 0,
        MAGIC_NUMBER_L = 1415073364,
        MAGIC_NUMBER_H = 1162035538,
    };
    // fields
    magic_number: u64 = 0,
    entry: ?[]const ?TransactionTraceEntry = null,
    real_to_elapsed_time_offset_nanos: u64 = 0,
    version: u32 = 0,
    pub fn calcProtobufSize(self: *const TransactionTraceFile) usize {
        var res: usize = 0;
        if (self.magic_number != 0) {
            res += gremlin.sizes.sizeWireNumber(TransactionTraceFileWire.MAGIC_NUMBER_WIRE) + gremlin.sizes.sizeFixed64(self.magic_number);
        }
        if (self.entry) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TransactionTraceFileWire.ENTRY_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.real_to_elapsed_time_offset_nanos != 0) {
            res += gremlin.sizes.sizeWireNumber(TransactionTraceFileWire.REAL_TO_ELAPSED_TIME_OFFSET_NANOS_WIRE) + gremlin.sizes.sizeFixed64(self.real_to_elapsed_time_offset_nanos);
        }
        if (self.version != 0) {
            res += gremlin.sizes.sizeWireNumber(TransactionTraceFileWire.VERSION_WIRE) + gremlin.sizes.sizeU32(self.version);
        }
        return res;
    }
    pub fn encode(self: *const TransactionTraceFile, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TransactionTraceFile, target: *gremlin.Writer) void {
        if (self.magic_number != 0) {
            target.appendFixed64(TransactionTraceFileWire.MAGIC_NUMBER_WIRE, self.magic_number);
        }
        if (self.entry) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(TransactionTraceFileWire.ENTRY_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(TransactionTraceFileWire.ENTRY_WIRE, 0);
                }
            }
        }
        if (self.real_to_elapsed_time_offset_nanos != 0) {
            target.appendFixed64(TransactionTraceFileWire.REAL_TO_ELAPSED_TIME_OFFSET_NANOS_WIRE, self.real_to_elapsed_time_offset_nanos);
        }
        if (self.version != 0) {
            target.appendUint32(TransactionTraceFileWire.VERSION_WIRE, self.version);
        }
    }
};
pub const TransactionTraceFileReader = struct {
    buf: gremlin.Reader,
    _magic_number: u64 = 0,
    _entry_offset: ?usize = null,
    _entry_last_offset: ?usize = null,
    _entry_cnt: usize = 0,
    _real_to_elapsed_time_offset_nanos: u64 = 0,
    _version: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!TransactionTraceFileReader {
        const buf = gremlin.Reader.init(src);
        var res = TransactionTraceFileReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TransactionTraceFileWire.MAGIC_NUMBER_WIRE => {
                    const result = try buf.readFixed64(offset);
                    offset += result.size;
                    res._magic_number = result.value;
                },
                TransactionTraceFileWire.ENTRY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._entry_offset == null) {
                        res._entry_offset = offset - result.size;
                    }
                    res._entry_last_offset = offset;
                    res._entry_cnt += 1;
                },
                TransactionTraceFileWire.REAL_TO_ELAPSED_TIME_OFFSET_NANOS_WIRE => {
                    const result = try buf.readFixed64(offset);
                    offset += result.size;
                    res._real_to_elapsed_time_offset_nanos = result.value;
                },
                TransactionTraceFileWire.VERSION_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._version = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getMagicNumber(self: *const TransactionTraceFileReader) u64 {
        return self._magic_number;
    }
    pub fn entryCount(self: *const TransactionTraceFileReader) usize {
        return self._entry_cnt;
    }
    pub fn entryNext(self: *TransactionTraceFileReader) ?TransactionTraceEntryReader {
        if (self._entry_offset == null) return null;
        const current_offset = self._entry_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = TransactionTraceEntryReader.init(result.value) catch return null;
        if (self._entry_last_offset != null and current_offset >= self._entry_last_offset.?) {
            self._entry_offset = null;
            return msg;
        }
        if (self._entry_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._entry_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TransactionTraceFileWire.ENTRY_WIRE) {
                self._entry_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._entry_offset = null;
        return msg;
    }
    pub inline fn getRealToElapsedTimeOffsetNanos(self: *const TransactionTraceFileReader) u64 {
        return self._real_to_elapsed_time_offset_nanos;
    }
    pub inline fn getVersion(self: *const TransactionTraceFileReader) u32 {
        return self._version;
    }
};
const TransactionTraceEntryWire = struct {
    const ELAPSED_REALTIME_NANOS_WIRE: gremlin.ProtoWireNumber = 1;
    const VSYNC_ID_WIRE: gremlin.ProtoWireNumber = 2;
    const TRANSACTIONS_WIRE: gremlin.ProtoWireNumber = 3;
    const ADDED_LAYERS_WIRE: gremlin.ProtoWireNumber = 4;
    const DESTROYED_LAYERS_WIRE: gremlin.ProtoWireNumber = 5;
    const ADDED_DISPLAYS_WIRE: gremlin.ProtoWireNumber = 6;
    const REMOVED_DISPLAYS_WIRE: gremlin.ProtoWireNumber = 7;
    const DESTROYED_LAYER_HANDLES_WIRE: gremlin.ProtoWireNumber = 8;
    const DISPLAYS_CHANGED_WIRE: gremlin.ProtoWireNumber = 9;
    const DISPLAYS_WIRE: gremlin.ProtoWireNumber = 10;
};
pub const TransactionTraceEntry = struct {
    // fields
    elapsed_realtime_nanos: i64 = 0,
    vsync_id: i64 = 0,
    transactions: ?[]const ?TransactionState = null,
    added_layers: ?[]const ?LayerCreationArgs = null,
    destroyed_layers: ?[]const u32 = null,
    added_displays: ?[]const ?DisplayState = null,
    removed_displays: ?[]const i32 = null,
    destroyed_layer_handles: ?[]const u32 = null,
    displays_changed: bool = false,
    displays: ?[]const ?DisplayInfo = null,
    pub fn calcProtobufSize(self: *const TransactionTraceEntry) usize {
        var res: usize = 0;
        if (self.elapsed_realtime_nanos != 0) {
            res += gremlin.sizes.sizeWireNumber(TransactionTraceEntryWire.ELAPSED_REALTIME_NANOS_WIRE) + gremlin.sizes.sizeI64(self.elapsed_realtime_nanos);
        }
        if (self.vsync_id != 0) {
            res += gremlin.sizes.sizeWireNumber(TransactionTraceEntryWire.VSYNC_ID_WIRE) + gremlin.sizes.sizeI64(self.vsync_id);
        }
        if (self.transactions) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TransactionTraceEntryWire.TRANSACTIONS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.added_layers) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TransactionTraceEntryWire.ADDED_LAYERS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.destroyed_layers) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(TransactionTraceEntryWire.DESTROYED_LAYERS_WIRE) + gremlin.sizes.sizeU32(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU32(v);
                }
                res += gremlin.sizes.sizeWireNumber(TransactionTraceEntryWire.DESTROYED_LAYERS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.added_displays) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TransactionTraceEntryWire.ADDED_DISPLAYS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.removed_displays) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(TransactionTraceEntryWire.REMOVED_DISPLAYS_WIRE) + gremlin.sizes.sizeI32(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(v);
                }
                res += gremlin.sizes.sizeWireNumber(TransactionTraceEntryWire.REMOVED_DISPLAYS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.destroyed_layer_handles) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(TransactionTraceEntryWire.DESTROYED_LAYER_HANDLES_WIRE) + gremlin.sizes.sizeU32(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU32(v);
                }
                res += gremlin.sizes.sizeWireNumber(TransactionTraceEntryWire.DESTROYED_LAYER_HANDLES_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.displays_changed != false) {
            res += gremlin.sizes.sizeWireNumber(TransactionTraceEntryWire.DISPLAYS_CHANGED_WIRE) + gremlin.sizes.sizeBool(self.displays_changed);
        }
        if (self.displays) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TransactionTraceEntryWire.DISPLAYS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const TransactionTraceEntry, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TransactionTraceEntry, target: *gremlin.Writer) void {
        if (self.elapsed_realtime_nanos != 0) {
            target.appendInt64(TransactionTraceEntryWire.ELAPSED_REALTIME_NANOS_WIRE, self.elapsed_realtime_nanos);
        }
        if (self.vsync_id != 0) {
            target.appendInt64(TransactionTraceEntryWire.VSYNC_ID_WIRE, self.vsync_id);
        }
        if (self.transactions) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(TransactionTraceEntryWire.TRANSACTIONS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(TransactionTraceEntryWire.TRANSACTIONS_WIRE, 0);
                }
            }
        }
        if (self.added_layers) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(TransactionTraceEntryWire.ADDED_LAYERS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(TransactionTraceEntryWire.ADDED_LAYERS_WIRE, 0);
                }
            }
        }
        if (self.destroyed_layers) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint32(TransactionTraceEntryWire.DESTROYED_LAYERS_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU32(v);
                }
                target.appendBytesTag(TransactionTraceEntryWire.DESTROYED_LAYERS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint32WithoutTag(v);
                }
            }
        }
        if (self.added_displays) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(TransactionTraceEntryWire.ADDED_DISPLAYS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(TransactionTraceEntryWire.ADDED_DISPLAYS_WIRE, 0);
                }
            }
        }
        if (self.removed_displays) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt32(TransactionTraceEntryWire.REMOVED_DISPLAYS_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(v);
                }
                target.appendBytesTag(TransactionTraceEntryWire.REMOVED_DISPLAYS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt32WithoutTag(v);
                }
            }
        }
        if (self.destroyed_layer_handles) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint32(TransactionTraceEntryWire.DESTROYED_LAYER_HANDLES_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU32(v);
                }
                target.appendBytesTag(TransactionTraceEntryWire.DESTROYED_LAYER_HANDLES_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint32WithoutTag(v);
                }
            }
        }
        if (self.displays_changed != false) {
            target.appendBool(TransactionTraceEntryWire.DISPLAYS_CHANGED_WIRE, self.displays_changed);
        }
        if (self.displays) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(TransactionTraceEntryWire.DISPLAYS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(TransactionTraceEntryWire.DISPLAYS_WIRE, 0);
                }
            }
        }
    }
};
pub const TransactionTraceEntryReader = struct {
    buf: gremlin.Reader,
    _elapsed_realtime_nanos: i64 = 0,
    _vsync_id: i64 = 0,
    _transactions_offset: ?usize = null,
    _transactions_last_offset: ?usize = null,
    _transactions_cnt: usize = 0,
    _added_layers_offset: ?usize = null,
    _added_layers_last_offset: ?usize = null,
    _added_layers_cnt: usize = 0,
    _destroyed_layers_offset: ?usize = null,
    _destroyed_layers_last_offset: ?usize = null,
    _destroyed_layers_packed: bool = false,
    _added_displays_offset: ?usize = null,
    _added_displays_last_offset: ?usize = null,
    _added_displays_cnt: usize = 0,
    _removed_displays_offset: ?usize = null,
    _removed_displays_last_offset: ?usize = null,
    _removed_displays_packed: bool = false,
    _destroyed_layer_handles_offset: ?usize = null,
    _destroyed_layer_handles_last_offset: ?usize = null,
    _destroyed_layer_handles_packed: bool = false,
    _displays_changed: bool = false,
    _displays_offset: ?usize = null,
    _displays_last_offset: ?usize = null,
    _displays_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!TransactionTraceEntryReader {
        const buf = gremlin.Reader.init(src);
        var res = TransactionTraceEntryReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TransactionTraceEntryWire.ELAPSED_REALTIME_NANOS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._elapsed_realtime_nanos = result.value;
                },
                TransactionTraceEntryWire.VSYNC_ID_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._vsync_id = result.value;
                },
                TransactionTraceEntryWire.TRANSACTIONS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._transactions_offset == null) {
                        res._transactions_offset = offset - result.size;
                    }
                    res._transactions_last_offset = offset;
                    res._transactions_cnt += 1;
                },
                TransactionTraceEntryWire.ADDED_LAYERS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._added_layers_offset == null) {
                        res._added_layers_offset = offset - result.size;
                    }
                    res._added_layers_last_offset = offset;
                    res._added_layers_cnt += 1;
                },
                TransactionTraceEntryWire.DESTROYED_LAYERS_WIRE => {
                    if (res._destroyed_layers_offset == null) {
                        res._destroyed_layers_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._destroyed_layers_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._destroyed_layers_offset = offset + length_result.size;
                        res._destroyed_layers_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._destroyed_layers_last_offset.?;
                    } else {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._destroyed_layers_last_offset = offset;
                    }
                },
                TransactionTraceEntryWire.ADDED_DISPLAYS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._added_displays_offset == null) {
                        res._added_displays_offset = offset - result.size;
                    }
                    res._added_displays_last_offset = offset;
                    res._added_displays_cnt += 1;
                },
                TransactionTraceEntryWire.REMOVED_DISPLAYS_WIRE => {
                    if (res._removed_displays_offset == null) {
                        res._removed_displays_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._removed_displays_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._removed_displays_offset = offset + length_result.size;
                        res._removed_displays_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._removed_displays_last_offset.?;
                    } else {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._removed_displays_last_offset = offset;
                    }
                },
                TransactionTraceEntryWire.DESTROYED_LAYER_HANDLES_WIRE => {
                    if (res._destroyed_layer_handles_offset == null) {
                        res._destroyed_layer_handles_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._destroyed_layer_handles_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._destroyed_layer_handles_offset = offset + length_result.size;
                        res._destroyed_layer_handles_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._destroyed_layer_handles_last_offset.?;
                    } else {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._destroyed_layer_handles_last_offset = offset;
                    }
                },
                TransactionTraceEntryWire.DISPLAYS_CHANGED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._displays_changed = result.value;
                },
                TransactionTraceEntryWire.DISPLAYS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._displays_offset == null) {
                        res._displays_offset = offset - result.size;
                    }
                    res._displays_last_offset = offset;
                    res._displays_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getElapsedRealtimeNanos(self: *const TransactionTraceEntryReader) i64 {
        return self._elapsed_realtime_nanos;
    }
    pub inline fn getVsyncId(self: *const TransactionTraceEntryReader) i64 {
        return self._vsync_id;
    }
    pub fn transactionsCount(self: *const TransactionTraceEntryReader) usize {
        return self._transactions_cnt;
    }
    pub fn transactionsNext(self: *TransactionTraceEntryReader) ?TransactionStateReader {
        if (self._transactions_offset == null) return null;
        const current_offset = self._transactions_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = TransactionStateReader.init(result.value) catch return null;
        if (self._transactions_last_offset != null and current_offset >= self._transactions_last_offset.?) {
            self._transactions_offset = null;
            return msg;
        }
        if (self._transactions_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._transactions_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TransactionTraceEntryWire.TRANSACTIONS_WIRE) {
                self._transactions_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._transactions_offset = null;
        return msg;
    }
    pub fn addedLayersCount(self: *const TransactionTraceEntryReader) usize {
        return self._added_layers_cnt;
    }
    pub fn addedLayersNext(self: *TransactionTraceEntryReader) ?LayerCreationArgsReader {
        if (self._added_layers_offset == null) return null;
        const current_offset = self._added_layers_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = LayerCreationArgsReader.init(result.value) catch return null;
        if (self._added_layers_last_offset != null and current_offset >= self._added_layers_last_offset.?) {
            self._added_layers_offset = null;
            return msg;
        }
        if (self._added_layers_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._added_layers_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TransactionTraceEntryWire.ADDED_LAYERS_WIRE) {
                self._added_layers_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._added_layers_offset = null;
        return msg;
    }
    pub fn destroyedLayersNext(self: *TransactionTraceEntryReader) gremlin.Error!?u32 {
        if (self._destroyed_layers_offset == null) return null;
        const current_offset = self._destroyed_layers_offset.?;
        if (current_offset >= self._destroyed_layers_last_offset.?) {
            self._destroyed_layers_offset = null;
            return null;
        }
        if (self._destroyed_layers_packed) {
            const value_result = try self.buf.readUInt32(current_offset);
            self._destroyed_layers_offset = current_offset + value_result.size;
            if (self._destroyed_layers_offset.? >= self._destroyed_layers_last_offset.?) {
                self._destroyed_layers_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._destroyed_layers_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == TransactionTraceEntryWire.DESTROYED_LAYERS_WIRE) {
                    self._destroyed_layers_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._destroyed_layers_offset = null;
            return value_result.value;
        }
    }
    pub fn addedDisplaysCount(self: *const TransactionTraceEntryReader) usize {
        return self._added_displays_cnt;
    }
    pub fn addedDisplaysNext(self: *TransactionTraceEntryReader) ?DisplayStateReader {
        if (self._added_displays_offset == null) return null;
        const current_offset = self._added_displays_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = DisplayStateReader.init(result.value) catch return null;
        if (self._added_displays_last_offset != null and current_offset >= self._added_displays_last_offset.?) {
            self._added_displays_offset = null;
            return msg;
        }
        if (self._added_displays_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._added_displays_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TransactionTraceEntryWire.ADDED_DISPLAYS_WIRE) {
                self._added_displays_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._added_displays_offset = null;
        return msg;
    }
    pub fn removedDisplaysNext(self: *TransactionTraceEntryReader) gremlin.Error!?i32 {
        if (self._removed_displays_offset == null) return null;
        const current_offset = self._removed_displays_offset.?;
        if (current_offset >= self._removed_displays_last_offset.?) {
            self._removed_displays_offset = null;
            return null;
        }
        if (self._removed_displays_packed) {
            const value_result = try self.buf.readInt32(current_offset);
            self._removed_displays_offset = current_offset + value_result.size;
            if (self._removed_displays_offset.? >= self._removed_displays_last_offset.?) {
                self._removed_displays_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._removed_displays_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == TransactionTraceEntryWire.REMOVED_DISPLAYS_WIRE) {
                    self._removed_displays_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._removed_displays_offset = null;
            return value_result.value;
        }
    }
    pub fn destroyedLayerHandlesNext(self: *TransactionTraceEntryReader) gremlin.Error!?u32 {
        if (self._destroyed_layer_handles_offset == null) return null;
        const current_offset = self._destroyed_layer_handles_offset.?;
        if (current_offset >= self._destroyed_layer_handles_last_offset.?) {
            self._destroyed_layer_handles_offset = null;
            return null;
        }
        if (self._destroyed_layer_handles_packed) {
            const value_result = try self.buf.readUInt32(current_offset);
            self._destroyed_layer_handles_offset = current_offset + value_result.size;
            if (self._destroyed_layer_handles_offset.? >= self._destroyed_layer_handles_last_offset.?) {
                self._destroyed_layer_handles_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._destroyed_layer_handles_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == TransactionTraceEntryWire.DESTROYED_LAYER_HANDLES_WIRE) {
                    self._destroyed_layer_handles_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._destroyed_layer_handles_offset = null;
            return value_result.value;
        }
    }
    pub inline fn getDisplaysChanged(self: *const TransactionTraceEntryReader) bool {
        return self._displays_changed;
    }
    pub fn displaysCount(self: *const TransactionTraceEntryReader) usize {
        return self._displays_cnt;
    }
    pub fn displaysNext(self: *TransactionTraceEntryReader) ?DisplayInfoReader {
        if (self._displays_offset == null) return null;
        const current_offset = self._displays_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = DisplayInfoReader.init(result.value) catch return null;
        if (self._displays_last_offset != null and current_offset >= self._displays_last_offset.?) {
            self._displays_offset = null;
            return msg;
        }
        if (self._displays_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._displays_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TransactionTraceEntryWire.DISPLAYS_WIRE) {
                self._displays_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._displays_offset = null;
        return msg;
    }
};
const DisplayInfoWire = struct {
    const LAYER_STACK_WIRE: gremlin.ProtoWireNumber = 1;
    const DISPLAY_ID_WIRE: gremlin.ProtoWireNumber = 2;
    const LOGICAL_WIDTH_WIRE: gremlin.ProtoWireNumber = 3;
    const LOGICAL_HEIGHT_WIRE: gremlin.ProtoWireNumber = 4;
    const TRANSFORM_INVERSE_WIRE: gremlin.ProtoWireNumber = 5;
    const TRANSFORM_WIRE: gremlin.ProtoWireNumber = 6;
    const RECEIVES_INPUT_WIRE: gremlin.ProtoWireNumber = 7;
    const IS_SECURE_WIRE: gremlin.ProtoWireNumber = 8;
    const IS_PRIMARY_WIRE: gremlin.ProtoWireNumber = 9;
    const IS_VIRTUAL_WIRE: gremlin.ProtoWireNumber = 10;
    const ROTATION_FLAGS_WIRE: gremlin.ProtoWireNumber = 11;
    const TRANSFORM_HINT_WIRE: gremlin.ProtoWireNumber = 12;
};
pub const DisplayInfo = struct {
    // fields
    layer_stack: u32 = 0,
    display_id: i32 = 0,
    logical_width: i32 = 0,
    logical_height: i32 = 0,
    transform_inverse: ?Transform = null,
    transform: ?Transform = null,
    receives_input: bool = false,
    is_secure: bool = false,
    is_primary: bool = false,
    is_virtual: bool = false,
    rotation_flags: i32 = 0,
    transform_hint: i32 = 0,
    pub fn calcProtobufSize(self: *const DisplayInfo) usize {
        var res: usize = 0;
        if (self.layer_stack != 0) {
            res += gremlin.sizes.sizeWireNumber(DisplayInfoWire.LAYER_STACK_WIRE) + gremlin.sizes.sizeU32(self.layer_stack);
        }
        if (self.display_id != 0) {
            res += gremlin.sizes.sizeWireNumber(DisplayInfoWire.DISPLAY_ID_WIRE) + gremlin.sizes.sizeI32(self.display_id);
        }
        if (self.logical_width != 0) {
            res += gremlin.sizes.sizeWireNumber(DisplayInfoWire.LOGICAL_WIDTH_WIRE) + gremlin.sizes.sizeI32(self.logical_width);
        }
        if (self.logical_height != 0) {
            res += gremlin.sizes.sizeWireNumber(DisplayInfoWire.LOGICAL_HEIGHT_WIRE) + gremlin.sizes.sizeI32(self.logical_height);
        }
        if (self.transform_inverse) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DisplayInfoWire.TRANSFORM_INVERSE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.transform) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DisplayInfoWire.TRANSFORM_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.receives_input != false) {
            res += gremlin.sizes.sizeWireNumber(DisplayInfoWire.RECEIVES_INPUT_WIRE) + gremlin.sizes.sizeBool(self.receives_input);
        }
        if (self.is_secure != false) {
            res += gremlin.sizes.sizeWireNumber(DisplayInfoWire.IS_SECURE_WIRE) + gremlin.sizes.sizeBool(self.is_secure);
        }
        if (self.is_primary != false) {
            res += gremlin.sizes.sizeWireNumber(DisplayInfoWire.IS_PRIMARY_WIRE) + gremlin.sizes.sizeBool(self.is_primary);
        }
        if (self.is_virtual != false) {
            res += gremlin.sizes.sizeWireNumber(DisplayInfoWire.IS_VIRTUAL_WIRE) + gremlin.sizes.sizeBool(self.is_virtual);
        }
        if (self.rotation_flags != 0) {
            res += gremlin.sizes.sizeWireNumber(DisplayInfoWire.ROTATION_FLAGS_WIRE) + gremlin.sizes.sizeI32(self.rotation_flags);
        }
        if (self.transform_hint != 0) {
            res += gremlin.sizes.sizeWireNumber(DisplayInfoWire.TRANSFORM_HINT_WIRE) + gremlin.sizes.sizeI32(self.transform_hint);
        }
        return res;
    }
    pub fn encode(self: *const DisplayInfo, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const DisplayInfo, target: *gremlin.Writer) void {
        if (self.layer_stack != 0) {
            target.appendUint32(DisplayInfoWire.LAYER_STACK_WIRE, self.layer_stack);
        }
        if (self.display_id != 0) {
            target.appendInt32(DisplayInfoWire.DISPLAY_ID_WIRE, self.display_id);
        }
        if (self.logical_width != 0) {
            target.appendInt32(DisplayInfoWire.LOGICAL_WIDTH_WIRE, self.logical_width);
        }
        if (self.logical_height != 0) {
            target.appendInt32(DisplayInfoWire.LOGICAL_HEIGHT_WIRE, self.logical_height);
        }
        if (self.transform_inverse) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DisplayInfoWire.TRANSFORM_INVERSE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.transform) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DisplayInfoWire.TRANSFORM_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.receives_input != false) {
            target.appendBool(DisplayInfoWire.RECEIVES_INPUT_WIRE, self.receives_input);
        }
        if (self.is_secure != false) {
            target.appendBool(DisplayInfoWire.IS_SECURE_WIRE, self.is_secure);
        }
        if (self.is_primary != false) {
            target.appendBool(DisplayInfoWire.IS_PRIMARY_WIRE, self.is_primary);
        }
        if (self.is_virtual != false) {
            target.appendBool(DisplayInfoWire.IS_VIRTUAL_WIRE, self.is_virtual);
        }
        if (self.rotation_flags != 0) {
            target.appendInt32(DisplayInfoWire.ROTATION_FLAGS_WIRE, self.rotation_flags);
        }
        if (self.transform_hint != 0) {
            target.appendInt32(DisplayInfoWire.TRANSFORM_HINT_WIRE, self.transform_hint);
        }
    }
};
pub const DisplayInfoReader = struct {
    buf: gremlin.Reader,
    _layer_stack: u32 = 0,
    _display_id: i32 = 0,
    _logical_width: i32 = 0,
    _logical_height: i32 = 0,
    _transform_inverse_buf: ?[]const u8 = null,
    _transform_buf: ?[]const u8 = null,
    _receives_input: bool = false,
    _is_secure: bool = false,
    _is_primary: bool = false,
    _is_virtual: bool = false,
    _rotation_flags: i32 = 0,
    _transform_hint: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!DisplayInfoReader {
        const buf = gremlin.Reader.init(src);
        var res = DisplayInfoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                DisplayInfoWire.LAYER_STACK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._layer_stack = result.value;
                },
                DisplayInfoWire.DISPLAY_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._display_id = result.value;
                },
                DisplayInfoWire.LOGICAL_WIDTH_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._logical_width = result.value;
                },
                DisplayInfoWire.LOGICAL_HEIGHT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._logical_height = result.value;
                },
                DisplayInfoWire.TRANSFORM_INVERSE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._transform_inverse_buf = result.value;
                },
                DisplayInfoWire.TRANSFORM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._transform_buf = result.value;
                },
                DisplayInfoWire.RECEIVES_INPUT_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._receives_input = result.value;
                },
                DisplayInfoWire.IS_SECURE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_secure = result.value;
                },
                DisplayInfoWire.IS_PRIMARY_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_primary = result.value;
                },
                DisplayInfoWire.IS_VIRTUAL_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_virtual = result.value;
                },
                DisplayInfoWire.ROTATION_FLAGS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._rotation_flags = result.value;
                },
                DisplayInfoWire.TRANSFORM_HINT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._transform_hint = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getLayerStack(self: *const DisplayInfoReader) u32 {
        return self._layer_stack;
    }
    pub inline fn getDisplayId(self: *const DisplayInfoReader) i32 {
        return self._display_id;
    }
    pub inline fn getLogicalWidth(self: *const DisplayInfoReader) i32 {
        return self._logical_width;
    }
    pub inline fn getLogicalHeight(self: *const DisplayInfoReader) i32 {
        return self._logical_height;
    }
    pub fn getTransformInverse(self: *const DisplayInfoReader) gremlin.Error!TransformReader {
        if (self._transform_inverse_buf) |buf| {
            return try TransformReader.init(buf);
        }
        return try TransformReader.init(&[_]u8{});
    }
    pub fn getTransform(self: *const DisplayInfoReader) gremlin.Error!TransformReader {
        if (self._transform_buf) |buf| {
            return try TransformReader.init(buf);
        }
        return try TransformReader.init(&[_]u8{});
    }
    pub inline fn getReceivesInput(self: *const DisplayInfoReader) bool {
        return self._receives_input;
    }
    pub inline fn getIsSecure(self: *const DisplayInfoReader) bool {
        return self._is_secure;
    }
    pub inline fn getIsPrimary(self: *const DisplayInfoReader) bool {
        return self._is_primary;
    }
    pub inline fn getIsVirtual(self: *const DisplayInfoReader) bool {
        return self._is_virtual;
    }
    pub inline fn getRotationFlags(self: *const DisplayInfoReader) i32 {
        return self._rotation_flags;
    }
    pub inline fn getTransformHint(self: *const DisplayInfoReader) i32 {
        return self._transform_hint;
    }
};
const LayerCreationArgsWire = struct {
    const LAYER_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const NAME_WIRE: gremlin.ProtoWireNumber = 2;
    const FLAGS_WIRE: gremlin.ProtoWireNumber = 3;
    const PARENT_ID_WIRE: gremlin.ProtoWireNumber = 4;
    const MIRROR_FROM_ID_WIRE: gremlin.ProtoWireNumber = 5;
    const ADD_TO_ROOT_WIRE: gremlin.ProtoWireNumber = 6;
    const LAYER_STACK_TO_MIRROR_WIRE: gremlin.ProtoWireNumber = 7;
};
pub const LayerCreationArgs = struct {
    // fields
    layer_id: u32 = 0,
    name: ?[]const u8 = null,
    flags: u32 = 0,
    parent_id: u32 = 0,
    mirror_from_id: u32 = 0,
    add_to_root: bool = false,
    layer_stack_to_mirror: u32 = 0,
    pub fn calcProtobufSize(self: *const LayerCreationArgs) usize {
        var res: usize = 0;
        if (self.layer_id != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerCreationArgsWire.LAYER_ID_WIRE) + gremlin.sizes.sizeU32(self.layer_id);
        }
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerCreationArgsWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.flags != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerCreationArgsWire.FLAGS_WIRE) + gremlin.sizes.sizeU32(self.flags);
        }
        if (self.parent_id != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerCreationArgsWire.PARENT_ID_WIRE) + gremlin.sizes.sizeU32(self.parent_id);
        }
        if (self.mirror_from_id != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerCreationArgsWire.MIRROR_FROM_ID_WIRE) + gremlin.sizes.sizeU32(self.mirror_from_id);
        }
        if (self.add_to_root != false) {
            res += gremlin.sizes.sizeWireNumber(LayerCreationArgsWire.ADD_TO_ROOT_WIRE) + gremlin.sizes.sizeBool(self.add_to_root);
        }
        if (self.layer_stack_to_mirror != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerCreationArgsWire.LAYER_STACK_TO_MIRROR_WIRE) + gremlin.sizes.sizeU32(self.layer_stack_to_mirror);
        }
        return res;
    }
    pub fn encode(self: *const LayerCreationArgs, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const LayerCreationArgs, target: *gremlin.Writer) void {
        if (self.layer_id != 0) {
            target.appendUint32(LayerCreationArgsWire.LAYER_ID_WIRE, self.layer_id);
        }
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(LayerCreationArgsWire.NAME_WIRE, v);
            }
        }
        if (self.flags != 0) {
            target.appendUint32(LayerCreationArgsWire.FLAGS_WIRE, self.flags);
        }
        if (self.parent_id != 0) {
            target.appendUint32(LayerCreationArgsWire.PARENT_ID_WIRE, self.parent_id);
        }
        if (self.mirror_from_id != 0) {
            target.appendUint32(LayerCreationArgsWire.MIRROR_FROM_ID_WIRE, self.mirror_from_id);
        }
        if (self.add_to_root != false) {
            target.appendBool(LayerCreationArgsWire.ADD_TO_ROOT_WIRE, self.add_to_root);
        }
        if (self.layer_stack_to_mirror != 0) {
            target.appendUint32(LayerCreationArgsWire.LAYER_STACK_TO_MIRROR_WIRE, self.layer_stack_to_mirror);
        }
    }
};
pub const LayerCreationArgsReader = struct {
    buf: gremlin.Reader,
    _layer_id: u32 = 0,
    _name: ?[]const u8 = null,
    _flags: u32 = 0,
    _parent_id: u32 = 0,
    _mirror_from_id: u32 = 0,
    _add_to_root: bool = false,
    _layer_stack_to_mirror: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!LayerCreationArgsReader {
        const buf = gremlin.Reader.init(src);
        var res = LayerCreationArgsReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                LayerCreationArgsWire.LAYER_ID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._layer_id = result.value;
                },
                LayerCreationArgsWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                LayerCreationArgsWire.FLAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._flags = result.value;
                },
                LayerCreationArgsWire.PARENT_ID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._parent_id = result.value;
                },
                LayerCreationArgsWire.MIRROR_FROM_ID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._mirror_from_id = result.value;
                },
                LayerCreationArgsWire.ADD_TO_ROOT_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._add_to_root = result.value;
                },
                LayerCreationArgsWire.LAYER_STACK_TO_MIRROR_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._layer_stack_to_mirror = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getLayerId(self: *const LayerCreationArgsReader) u32 {
        return self._layer_id;
    }
    pub inline fn getName(self: *const LayerCreationArgsReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub inline fn getFlags(self: *const LayerCreationArgsReader) u32 {
        return self._flags;
    }
    pub inline fn getParentId(self: *const LayerCreationArgsReader) u32 {
        return self._parent_id;
    }
    pub inline fn getMirrorFromId(self: *const LayerCreationArgsReader) u32 {
        return self._mirror_from_id;
    }
    pub inline fn getAddToRoot(self: *const LayerCreationArgsReader) bool {
        return self._add_to_root;
    }
    pub inline fn getLayerStackToMirror(self: *const LayerCreationArgsReader) u32 {
        return self._layer_stack_to_mirror;
    }
};
const TransformWire = struct {
    const DSDX_WIRE: gremlin.ProtoWireNumber = 1;
    const DTDX_WIRE: gremlin.ProtoWireNumber = 2;
    const DTDY_WIRE: gremlin.ProtoWireNumber = 3;
    const DSDY_WIRE: gremlin.ProtoWireNumber = 4;
    const TX_WIRE: gremlin.ProtoWireNumber = 5;
    const TY_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const Transform = struct {
    // fields
    dsdx: f32 = 0.0,
    dtdx: f32 = 0.0,
    dtdy: f32 = 0.0,
    dsdy: f32 = 0.0,
    tx: f32 = 0.0,
    ty: f32 = 0.0,
    pub fn calcProtobufSize(self: *const Transform) usize {
        var res: usize = 0;
        if (self.dsdx != 0.0) {
            res += gremlin.sizes.sizeWireNumber(TransformWire.DSDX_WIRE) + gremlin.sizes.sizeFloat(self.dsdx);
        }
        if (self.dtdx != 0.0) {
            res += gremlin.sizes.sizeWireNumber(TransformWire.DTDX_WIRE) + gremlin.sizes.sizeFloat(self.dtdx);
        }
        if (self.dtdy != 0.0) {
            res += gremlin.sizes.sizeWireNumber(TransformWire.DTDY_WIRE) + gremlin.sizes.sizeFloat(self.dtdy);
        }
        if (self.dsdy != 0.0) {
            res += gremlin.sizes.sizeWireNumber(TransformWire.DSDY_WIRE) + gremlin.sizes.sizeFloat(self.dsdy);
        }
        if (self.tx != 0.0) {
            res += gremlin.sizes.sizeWireNumber(TransformWire.TX_WIRE) + gremlin.sizes.sizeFloat(self.tx);
        }
        if (self.ty != 0.0) {
            res += gremlin.sizes.sizeWireNumber(TransformWire.TY_WIRE) + gremlin.sizes.sizeFloat(self.ty);
        }
        return res;
    }
    pub fn encode(self: *const Transform, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const Transform, target: *gremlin.Writer) void {
        if (self.dsdx != 0.0) {
            target.appendFloat32(TransformWire.DSDX_WIRE, self.dsdx);
        }
        if (self.dtdx != 0.0) {
            target.appendFloat32(TransformWire.DTDX_WIRE, self.dtdx);
        }
        if (self.dtdy != 0.0) {
            target.appendFloat32(TransformWire.DTDY_WIRE, self.dtdy);
        }
        if (self.dsdy != 0.0) {
            target.appendFloat32(TransformWire.DSDY_WIRE, self.dsdy);
        }
        if (self.tx != 0.0) {
            target.appendFloat32(TransformWire.TX_WIRE, self.tx);
        }
        if (self.ty != 0.0) {
            target.appendFloat32(TransformWire.TY_WIRE, self.ty);
        }
    }
};
pub const TransformReader = struct {
    buf: gremlin.Reader,
    _dsdx: f32 = 0.0,
    _dtdx: f32 = 0.0,
    _dtdy: f32 = 0.0,
    _dsdy: f32 = 0.0,
    _tx: f32 = 0.0,
    _ty: f32 = 0.0,
    pub fn init(src: []const u8) gremlin.Error!TransformReader {
        const buf = gremlin.Reader.init(src);
        var res = TransformReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TransformWire.DSDX_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._dsdx = result.value;
                },
                TransformWire.DTDX_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._dtdx = result.value;
                },
                TransformWire.DTDY_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._dtdy = result.value;
                },
                TransformWire.DSDY_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._dsdy = result.value;
                },
                TransformWire.TX_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._tx = result.value;
                },
                TransformWire.TY_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._ty = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDsdx(self: *const TransformReader) f32 {
        return self._dsdx;
    }
    pub inline fn getDtdx(self: *const TransformReader) f32 {
        return self._dtdx;
    }
    pub inline fn getDtdy(self: *const TransformReader) f32 {
        return self._dtdy;
    }
    pub inline fn getDsdy(self: *const TransformReader) f32 {
        return self._dsdy;
    }
    pub inline fn getTx(self: *const TransformReader) f32 {
        return self._tx;
    }
    pub inline fn getTy(self: *const TransformReader) f32 {
        return self._ty;
    }
};
const TransactionBarrierWire = struct {
    const BARRIER_TOKEN_WIRE: gremlin.ProtoWireNumber = 1;
    const KIND_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const TransactionBarrier = struct {
    // fields
    barrier_token: ?[]const u8 = null,
    kind: u32 = 0,
    pub fn calcProtobufSize(self: *const TransactionBarrier) usize {
        var res: usize = 0;
        if (self.barrier_token) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TransactionBarrierWire.BARRIER_TOKEN_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.kind != 0) {
            res += gremlin.sizes.sizeWireNumber(TransactionBarrierWire.KIND_WIRE) + gremlin.sizes.sizeU32(self.kind);
        }
        return res;
    }
    pub fn encode(self: *const TransactionBarrier, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TransactionBarrier, target: *gremlin.Writer) void {
        if (self.barrier_token) |v| {
            if (v.len > 0) {
                target.appendBytes(TransactionBarrierWire.BARRIER_TOKEN_WIRE, v);
            }
        }
        if (self.kind != 0) {
            target.appendUint32(TransactionBarrierWire.KIND_WIRE, self.kind);
        }
    }
};
pub const TransactionBarrierReader = struct {
    buf: gremlin.Reader,
    _barrier_token: ?[]const u8 = null,
    _kind: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!TransactionBarrierReader {
        const buf = gremlin.Reader.init(src);
        var res = TransactionBarrierReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TransactionBarrierWire.BARRIER_TOKEN_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._barrier_token = result.value;
                },
                TransactionBarrierWire.KIND_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._kind = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getBarrierToken(self: *const TransactionBarrierReader) []const u8 {
        return self._barrier_token orelse &[_]u8{};
    }
    pub inline fn getKind(self: *const TransactionBarrierReader) u32 {
        return self._kind;
    }
};
const TransactionStateWire = struct {
    const PID_WIRE: gremlin.ProtoWireNumber = 1;
    const UID_WIRE: gremlin.ProtoWireNumber = 2;
    const VSYNC_ID_WIRE: gremlin.ProtoWireNumber = 3;
    const INPUT_EVENT_ID_WIRE: gremlin.ProtoWireNumber = 4;
    const POST_TIME_WIRE: gremlin.ProtoWireNumber = 5;
    const TRANSACTION_ID_WIRE: gremlin.ProtoWireNumber = 6;
    const LAYER_CHANGES_WIRE: gremlin.ProtoWireNumber = 7;
    const DISPLAY_CHANGES_WIRE: gremlin.ProtoWireNumber = 8;
    const MERGED_TRANSACTION_IDS_WIRE: gremlin.ProtoWireNumber = 9;
    const APPLY_TOKEN_WIRE: gremlin.ProtoWireNumber = 10;
    const TRANSACTION_BARRIERS_WIRE: gremlin.ProtoWireNumber = 11;
};
pub const TransactionState = struct {
    // fields
    pid: i32 = 0,
    uid: i32 = 0,
    vsync_id: i64 = 0,
    input_event_id: i32 = 0,
    post_time: i64 = 0,
    transaction_id: u64 = 0,
    layer_changes: ?[]const ?LayerState = null,
    display_changes: ?[]const ?DisplayState = null,
    merged_transaction_ids: ?[]const u64 = null,
    apply_token: u64 = 0,
    transaction_barriers: ?[]const ?TransactionBarrier = null,
    pub fn calcProtobufSize(self: *const TransactionState) usize {
        var res: usize = 0;
        if (self.pid != 0) {
            res += gremlin.sizes.sizeWireNumber(TransactionStateWire.PID_WIRE) + gremlin.sizes.sizeI32(self.pid);
        }
        if (self.uid != 0) {
            res += gremlin.sizes.sizeWireNumber(TransactionStateWire.UID_WIRE) + gremlin.sizes.sizeI32(self.uid);
        }
        if (self.vsync_id != 0) {
            res += gremlin.sizes.sizeWireNumber(TransactionStateWire.VSYNC_ID_WIRE) + gremlin.sizes.sizeI64(self.vsync_id);
        }
        if (self.input_event_id != 0) {
            res += gremlin.sizes.sizeWireNumber(TransactionStateWire.INPUT_EVENT_ID_WIRE) + gremlin.sizes.sizeI32(self.input_event_id);
        }
        if (self.post_time != 0) {
            res += gremlin.sizes.sizeWireNumber(TransactionStateWire.POST_TIME_WIRE) + gremlin.sizes.sizeI64(self.post_time);
        }
        if (self.transaction_id != 0) {
            res += gremlin.sizes.sizeWireNumber(TransactionStateWire.TRANSACTION_ID_WIRE) + gremlin.sizes.sizeU64(self.transaction_id);
        }
        if (self.layer_changes) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TransactionStateWire.LAYER_CHANGES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.display_changes) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TransactionStateWire.DISPLAY_CHANGES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.merged_transaction_ids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(TransactionStateWire.MERGED_TRANSACTION_IDS_WIRE) + gremlin.sizes.sizeU64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                res += gremlin.sizes.sizeWireNumber(TransactionStateWire.MERGED_TRANSACTION_IDS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.apply_token != 0) {
            res += gremlin.sizes.sizeWireNumber(TransactionStateWire.APPLY_TOKEN_WIRE) + gremlin.sizes.sizeU64(self.apply_token);
        }
        if (self.transaction_barriers) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TransactionStateWire.TRANSACTION_BARRIERS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const TransactionState, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TransactionState, target: *gremlin.Writer) void {
        if (self.pid != 0) {
            target.appendInt32(TransactionStateWire.PID_WIRE, self.pid);
        }
        if (self.uid != 0) {
            target.appendInt32(TransactionStateWire.UID_WIRE, self.uid);
        }
        if (self.vsync_id != 0) {
            target.appendInt64(TransactionStateWire.VSYNC_ID_WIRE, self.vsync_id);
        }
        if (self.input_event_id != 0) {
            target.appendInt32(TransactionStateWire.INPUT_EVENT_ID_WIRE, self.input_event_id);
        }
        if (self.post_time != 0) {
            target.appendInt64(TransactionStateWire.POST_TIME_WIRE, self.post_time);
        }
        if (self.transaction_id != 0) {
            target.appendUint64(TransactionStateWire.TRANSACTION_ID_WIRE, self.transaction_id);
        }
        if (self.layer_changes) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(TransactionStateWire.LAYER_CHANGES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(TransactionStateWire.LAYER_CHANGES_WIRE, 0);
                }
            }
        }
        if (self.display_changes) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(TransactionStateWire.DISPLAY_CHANGES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(TransactionStateWire.DISPLAY_CHANGES_WIRE, 0);
                }
            }
        }
        if (self.merged_transaction_ids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint64(TransactionStateWire.MERGED_TRANSACTION_IDS_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                target.appendBytesTag(TransactionStateWire.MERGED_TRANSACTION_IDS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint64WithoutTag(v);
                }
            }
        }
        if (self.apply_token != 0) {
            target.appendUint64(TransactionStateWire.APPLY_TOKEN_WIRE, self.apply_token);
        }
        if (self.transaction_barriers) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(TransactionStateWire.TRANSACTION_BARRIERS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(TransactionStateWire.TRANSACTION_BARRIERS_WIRE, 0);
                }
            }
        }
    }
};
pub const TransactionStateReader = struct {
    buf: gremlin.Reader,
    _pid: i32 = 0,
    _uid: i32 = 0,
    _vsync_id: i64 = 0,
    _input_event_id: i32 = 0,
    _post_time: i64 = 0,
    _transaction_id: u64 = 0,
    _layer_changes_offset: ?usize = null,
    _layer_changes_last_offset: ?usize = null,
    _layer_changes_cnt: usize = 0,
    _display_changes_offset: ?usize = null,
    _display_changes_last_offset: ?usize = null,
    _display_changes_cnt: usize = 0,
    _merged_transaction_ids_offset: ?usize = null,
    _merged_transaction_ids_last_offset: ?usize = null,
    _merged_transaction_ids_packed: bool = false,
    _apply_token: u64 = 0,
    _transaction_barriers_offset: ?usize = null,
    _transaction_barriers_last_offset: ?usize = null,
    _transaction_barriers_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!TransactionStateReader {
        const buf = gremlin.Reader.init(src);
        var res = TransactionStateReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TransactionStateWire.PID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._pid = result.value;
                },
                TransactionStateWire.UID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._uid = result.value;
                },
                TransactionStateWire.VSYNC_ID_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._vsync_id = result.value;
                },
                TransactionStateWire.INPUT_EVENT_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._input_event_id = result.value;
                },
                TransactionStateWire.POST_TIME_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._post_time = result.value;
                },
                TransactionStateWire.TRANSACTION_ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._transaction_id = result.value;
                },
                TransactionStateWire.LAYER_CHANGES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._layer_changes_offset == null) {
                        res._layer_changes_offset = offset - result.size;
                    }
                    res._layer_changes_last_offset = offset;
                    res._layer_changes_cnt += 1;
                },
                TransactionStateWire.DISPLAY_CHANGES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._display_changes_offset == null) {
                        res._display_changes_offset = offset - result.size;
                    }
                    res._display_changes_last_offset = offset;
                    res._display_changes_cnt += 1;
                },
                TransactionStateWire.MERGED_TRANSACTION_IDS_WIRE => {
                    if (res._merged_transaction_ids_offset == null) {
                        res._merged_transaction_ids_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._merged_transaction_ids_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._merged_transaction_ids_offset = offset + length_result.size;
                        res._merged_transaction_ids_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._merged_transaction_ids_last_offset.?;
                    } else {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._merged_transaction_ids_last_offset = offset;
                    }
                },
                TransactionStateWire.APPLY_TOKEN_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._apply_token = result.value;
                },
                TransactionStateWire.TRANSACTION_BARRIERS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._transaction_barriers_offset == null) {
                        res._transaction_barriers_offset = offset - result.size;
                    }
                    res._transaction_barriers_last_offset = offset;
                    res._transaction_barriers_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getPid(self: *const TransactionStateReader) i32 {
        return self._pid;
    }
    pub inline fn getUid(self: *const TransactionStateReader) i32 {
        return self._uid;
    }
    pub inline fn getVsyncId(self: *const TransactionStateReader) i64 {
        return self._vsync_id;
    }
    pub inline fn getInputEventId(self: *const TransactionStateReader) i32 {
        return self._input_event_id;
    }
    pub inline fn getPostTime(self: *const TransactionStateReader) i64 {
        return self._post_time;
    }
    pub inline fn getTransactionId(self: *const TransactionStateReader) u64 {
        return self._transaction_id;
    }
    pub fn layerChangesCount(self: *const TransactionStateReader) usize {
        return self._layer_changes_cnt;
    }
    pub fn layerChangesNext(self: *TransactionStateReader) ?LayerStateReader {
        if (self._layer_changes_offset == null) return null;
        const current_offset = self._layer_changes_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = LayerStateReader.init(result.value) catch return null;
        if (self._layer_changes_last_offset != null and current_offset >= self._layer_changes_last_offset.?) {
            self._layer_changes_offset = null;
            return msg;
        }
        if (self._layer_changes_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._layer_changes_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TransactionStateWire.LAYER_CHANGES_WIRE) {
                self._layer_changes_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._layer_changes_offset = null;
        return msg;
    }
    pub fn displayChangesCount(self: *const TransactionStateReader) usize {
        return self._display_changes_cnt;
    }
    pub fn displayChangesNext(self: *TransactionStateReader) ?DisplayStateReader {
        if (self._display_changes_offset == null) return null;
        const current_offset = self._display_changes_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = DisplayStateReader.init(result.value) catch return null;
        if (self._display_changes_last_offset != null and current_offset >= self._display_changes_last_offset.?) {
            self._display_changes_offset = null;
            return msg;
        }
        if (self._display_changes_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._display_changes_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TransactionStateWire.DISPLAY_CHANGES_WIRE) {
                self._display_changes_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._display_changes_offset = null;
        return msg;
    }
    pub fn mergedTransactionIdsNext(self: *TransactionStateReader) gremlin.Error!?u64 {
        if (self._merged_transaction_ids_offset == null) return null;
        const current_offset = self._merged_transaction_ids_offset.?;
        if (current_offset >= self._merged_transaction_ids_last_offset.?) {
            self._merged_transaction_ids_offset = null;
            return null;
        }
        if (self._merged_transaction_ids_packed) {
            const value_result = try self.buf.readUInt64(current_offset);
            self._merged_transaction_ids_offset = current_offset + value_result.size;
            if (self._merged_transaction_ids_offset.? >= self._merged_transaction_ids_last_offset.?) {
                self._merged_transaction_ids_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._merged_transaction_ids_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == TransactionStateWire.MERGED_TRANSACTION_IDS_WIRE) {
                    self._merged_transaction_ids_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._merged_transaction_ids_offset = null;
            return value_result.value;
        }
    }
    pub inline fn getApplyToken(self: *const TransactionStateReader) u64 {
        return self._apply_token;
    }
    pub fn transactionBarriersCount(self: *const TransactionStateReader) usize {
        return self._transaction_barriers_cnt;
    }
    pub fn transactionBarriersNext(self: *TransactionStateReader) ?TransactionBarrierReader {
        if (self._transaction_barriers_offset == null) return null;
        const current_offset = self._transaction_barriers_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = TransactionBarrierReader.init(result.value) catch return null;
        if (self._transaction_barriers_last_offset != null and current_offset >= self._transaction_barriers_last_offset.?) {
            self._transaction_barriers_offset = null;
            return msg;
        }
        if (self._transaction_barriers_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._transaction_barriers_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TransactionStateWire.TRANSACTION_BARRIERS_WIRE) {
                self._transaction_barriers_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._transaction_barriers_offset = null;
        return msg;
    }
};
const LayerStateWire = struct {
    const LAYER_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const WHAT_WIRE: gremlin.ProtoWireNumber = 2;
    const X_WIRE: gremlin.ProtoWireNumber = 3;
    const Y_WIRE: gremlin.ProtoWireNumber = 4;
    const Z_WIRE: gremlin.ProtoWireNumber = 5;
    const W_WIRE: gremlin.ProtoWireNumber = 6;
    const H_WIRE: gremlin.ProtoWireNumber = 7;
    const LAYER_STACK_WIRE: gremlin.ProtoWireNumber = 8;
    const FLAGS_WIRE: gremlin.ProtoWireNumber = 9;
    const MASK_WIRE: gremlin.ProtoWireNumber = 10;
    const MATRIX_WIRE: gremlin.ProtoWireNumber = 11;
    const CORNER_RADIUS_WIRE: gremlin.ProtoWireNumber = 12;
    const BACKGROUND_BLUR_RADIUS_WIRE: gremlin.ProtoWireNumber = 13;
    const PARENT_ID_WIRE: gremlin.ProtoWireNumber = 14;
    const RELATIVE_PARENT_ID_WIRE: gremlin.ProtoWireNumber = 15;
    const ALPHA_WIRE: gremlin.ProtoWireNumber = 16;
    const COLOR_WIRE: gremlin.ProtoWireNumber = 17;
    const TRANSPARENT_REGION_WIRE: gremlin.ProtoWireNumber = 18;
    const TRANSFORM_WIRE: gremlin.ProtoWireNumber = 19;
    const TRANSFORM_TO_DISPLAY_INVERSE_WIRE: gremlin.ProtoWireNumber = 20;
    const CROP_WIRE: gremlin.ProtoWireNumber = 21;
    const BUFFER_DATA_WIRE: gremlin.ProtoWireNumber = 22;
    const API_WIRE: gremlin.ProtoWireNumber = 23;
    const HAS_SIDEBAND_STREAM_WIRE: gremlin.ProtoWireNumber = 24;
    const COLOR_TRANSFORM_WIRE: gremlin.ProtoWireNumber = 25;
    const BLUR_REGIONS_WIRE: gremlin.ProtoWireNumber = 26;
    const WINDOW_INFO_HANDLE_WIRE: gremlin.ProtoWireNumber = 27;
    const BG_COLOR_ALPHA_WIRE: gremlin.ProtoWireNumber = 28;
    const BG_COLOR_DATASPACE_WIRE: gremlin.ProtoWireNumber = 29;
    const COLOR_SPACE_AGNOSTIC_WIRE: gremlin.ProtoWireNumber = 30;
    const SHADOW_RADIUS_WIRE: gremlin.ProtoWireNumber = 31;
    const FRAME_RATE_SELECTION_PRIORITY_WIRE: gremlin.ProtoWireNumber = 32;
    const FRAME_RATE_WIRE: gremlin.ProtoWireNumber = 33;
    const FRAME_RATE_COMPATIBILITY_WIRE: gremlin.ProtoWireNumber = 34;
    const CHANGE_FRAME_RATE_STRATEGY_WIRE: gremlin.ProtoWireNumber = 35;
    const FIXED_TRANSFORM_HINT_WIRE: gremlin.ProtoWireNumber = 36;
    const FRAME_NUMBER_WIRE: gremlin.ProtoWireNumber = 37;
    const AUTO_REFRESH_WIRE: gremlin.ProtoWireNumber = 38;
    const IS_TRUSTED_OVERLAY_WIRE: gremlin.ProtoWireNumber = 39;
    const BUFFER_CROP_WIRE: gremlin.ProtoWireNumber = 40;
    const DESTINATION_FRAME_WIRE: gremlin.ProtoWireNumber = 41;
    const DROP_INPUT_MODE_WIRE: gremlin.ProtoWireNumber = 42;
    const TRUSTED_OVERLAY_WIRE: gremlin.ProtoWireNumber = 43;
    const BACKGROUND_BLUR_SCALE_WIRE: gremlin.ProtoWireNumber = 44;
    const CORNER_RADII_WIRE: gremlin.ProtoWireNumber = 45;
    const CLIENT_DRAWN_CORNER_RADII_WIRE: gremlin.ProtoWireNumber = 46;
    const SYSTEM_CONTENT_PRIORITY_WIRE: gremlin.ProtoWireNumber = 47;
    const BOX_SHADOW_SETTINGS_WIRE: gremlin.ProtoWireNumber = 48;
    const BORDER_SETTINGS_WIRE: gremlin.ProtoWireNumber = 49;
};
pub const LayerState = struct {
    // nested enums
    pub const ChangesLsb = enum(i32) {
        E_CHANGES_LSB_NONE = 0,
        E_POSITION_CHANGED = 1,
        E_LAYER_CHANGED = 2,
        E_ALPHA_CHANGED = 8,
        E_MATRIX_CHANGED = 16,
        E_TRANSPARENT_REGION_CHANGED = 32,
        E_FLAGS_CHANGED = 64,
        E_LAYER_STACK_CHANGED = 128,
        E_RELEASE_BUFFER_LISTENER_CHANGED = 1024,
        E_SHADOW_RADIUS_CHANGED = 2048,
        E_BUFFER_CROP_CHANGED = 8192,
        E_RELATIVE_LAYER_CHANGED = 16384,
        E_REPARENT = 32768,
        E_COLOR_CHANGED = 65536,
        E_BUFFER_TRANSFORM_CHANGED = 262144,
        E_TRANSFORM_TO_DISPLAY_INVERSE_CHANGED = 524288,
        E_CROP_CHANGED = 1048576,
        E_BUFFER_CHANGED = 2097152,
        E_ACQUIRE_FENCE_CHANGED = 4194304,
        E_DATASPACE_CHANGED = 8388608,
        E_HDR_METADATA_CHANGED = 16777216,
        E_SURFACE_DAMAGE_REGION_CHANGED = 33554432,
        E_API_CHANGED = 67108864,
        E_SIDEBAND_STREAM_CHANGED = 134217728,
        E_COLOR_TRANSFORM_CHANGED = 268435456,
        E_HAS_LISTENER_CALLBACKS_CHANGED = 536870912,
        E_INPUT_INFO_CHANGED = 1073741824,
        E_CORNER_RADIUS_CHANGED = -2147483648,
    };
    pub const ChangesMsb = enum(i32) {
        E_CHANGES_MSB_NONE = 0,
        E_DESTINATION_FRAME_CHANGED = 1,
        E_CACHED_BUFFER_CHANGED = 2,
        E_BACKGROUND_COLOR_CHANGED = 4,
        E_METADATA_CHANGED = 8,
        E_COLOR_SPACE_AGNOSTIC_CHANGED = 16,
        E_FRAME_RATE_SELECTION_PRIORITY = 32,
        E_FRAME_RATE_CHANGED = 64,
        E_BACKGROUND_BLUR_RADIUS_CHANGED = 128,
        E_PRODUCER_DISCONNECT = 256,
        E_FIXED_TRANSFORM_HINT_CHANGED = 512,
        E_FRAME_NUMBER_CHANGED = 1024,
        E_BLUR_REGIONS_CHANGED = 2048,
        E_AUTO_REFRESH_CHANGED = 4096,
        E_STRETCH_CHANGED = 8192,
        E_TRUSTED_OVERLAY_CHANGED = 16384,
        E_DROP_INPUT_MODE_CHANGED = 32768,
        E_CLIENT_DRAWN_CORNER_RADIUS_CHANGED = 65536,
        E_SYSTEM_CONTENT_PRIORITY_CHANGED = 131072,
        E_BOX_SHADOW_SETTINGS_CHANGED = 262144,
        E_BORDER_SETTINGS_CHANGED = 524288,
    };
    pub const Flags = enum(i32) {
        E_FLAGS_NONE = 0,
        E_LAYER_HIDDEN = 1,
        E_LAYER_OPAQUE = 2,
        E_LAYER_SKIP_SCREENSHOT = 64,
        E_LAYER_SECURE = 128,
        E_ENABLE_BACKPRESSURE = 256,
        E_LAYER_IS_DISPLAY_DECORATION = 512,
    };
    pub const DropInputMode = enum(i32) {
        NONE = 0,
        ALL = 1,
        OBSCURED = 2,
    };
    // nested structs
    const Matrix22Wire = struct {
        const DSDX_WIRE: gremlin.ProtoWireNumber = 1;
        const DTDX_WIRE: gremlin.ProtoWireNumber = 2;
        const DTDY_WIRE: gremlin.ProtoWireNumber = 3;
        const DSDY_WIRE: gremlin.ProtoWireNumber = 4;
    };
    pub const Matrix22 = struct {
        // fields
        dsdx: f32 = 0.0,
        dtdx: f32 = 0.0,
        dtdy: f32 = 0.0,
        dsdy: f32 = 0.0,
        pub fn calcProtobufSize(self: *const LayerState.Matrix22) usize {
            var res: usize = 0;
            if (self.dsdx != 0.0) {
                res += gremlin.sizes.sizeWireNumber(LayerState.Matrix22Wire.DSDX_WIRE) + gremlin.sizes.sizeFloat(self.dsdx);
            }
            if (self.dtdx != 0.0) {
                res += gremlin.sizes.sizeWireNumber(LayerState.Matrix22Wire.DTDX_WIRE) + gremlin.sizes.sizeFloat(self.dtdx);
            }
            if (self.dtdy != 0.0) {
                res += gremlin.sizes.sizeWireNumber(LayerState.Matrix22Wire.DTDY_WIRE) + gremlin.sizes.sizeFloat(self.dtdy);
            }
            if (self.dsdy != 0.0) {
                res += gremlin.sizes.sizeWireNumber(LayerState.Matrix22Wire.DSDY_WIRE) + gremlin.sizes.sizeFloat(self.dsdy);
            }
            return res;
        }
        pub fn encode(self: *const LayerState.Matrix22, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const LayerState.Matrix22, target: *gremlin.Writer) void {
            if (self.dsdx != 0.0) {
                target.appendFloat32(LayerState.Matrix22Wire.DSDX_WIRE, self.dsdx);
            }
            if (self.dtdx != 0.0) {
                target.appendFloat32(LayerState.Matrix22Wire.DTDX_WIRE, self.dtdx);
            }
            if (self.dtdy != 0.0) {
                target.appendFloat32(LayerState.Matrix22Wire.DTDY_WIRE, self.dtdy);
            }
            if (self.dsdy != 0.0) {
                target.appendFloat32(LayerState.Matrix22Wire.DSDY_WIRE, self.dsdy);
            }
        }
    };
    pub const Matrix22Reader = struct {
        buf: gremlin.Reader,
        _dsdx: f32 = 0.0,
        _dtdx: f32 = 0.0,
        _dtdy: f32 = 0.0,
        _dsdy: f32 = 0.0,
        pub fn init(src: []const u8) gremlin.Error!LayerState.Matrix22Reader {
            const buf = gremlin.Reader.init(src);
            var res = LayerState.Matrix22Reader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    LayerState.Matrix22Wire.DSDX_WIRE => {
                        const result = try buf.readFloat32(offset);
                        offset += result.size;
                        res._dsdx = result.value;
                    },
                    LayerState.Matrix22Wire.DTDX_WIRE => {
                        const result = try buf.readFloat32(offset);
                        offset += result.size;
                        res._dtdx = result.value;
                    },
                    LayerState.Matrix22Wire.DTDY_WIRE => {
                        const result = try buf.readFloat32(offset);
                        offset += result.size;
                        res._dtdy = result.value;
                    },
                    LayerState.Matrix22Wire.DSDY_WIRE => {
                        const result = try buf.readFloat32(offset);
                        offset += result.size;
                        res._dsdy = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getDsdx(self: *const LayerState.Matrix22Reader) f32 {
            return self._dsdx;
        }
        pub inline fn getDtdx(self: *const LayerState.Matrix22Reader) f32 {
            return self._dtdx;
        }
        pub inline fn getDtdy(self: *const LayerState.Matrix22Reader) f32 {
            return self._dtdy;
        }
        pub inline fn getDsdy(self: *const LayerState.Matrix22Reader) f32 {
            return self._dsdy;
        }
    };
    const CornerRadiiWire = struct {
        const TL_WIRE: gremlin.ProtoWireNumber = 1;
        const TR_WIRE: gremlin.ProtoWireNumber = 2;
        const BL_WIRE: gremlin.ProtoWireNumber = 3;
        const BR_WIRE: gremlin.ProtoWireNumber = 4;
    };
    pub const CornerRadii = struct {
        // fields
        tl: f32 = 0.0,
        tr: f32 = 0.0,
        bl: f32 = 0.0,
        br: f32 = 0.0,
        pub fn calcProtobufSize(self: *const LayerState.CornerRadii) usize {
            var res: usize = 0;
            if (self.tl != 0.0) {
                res += gremlin.sizes.sizeWireNumber(LayerState.CornerRadiiWire.TL_WIRE) + gremlin.sizes.sizeFloat(self.tl);
            }
            if (self.tr != 0.0) {
                res += gremlin.sizes.sizeWireNumber(LayerState.CornerRadiiWire.TR_WIRE) + gremlin.sizes.sizeFloat(self.tr);
            }
            if (self.bl != 0.0) {
                res += gremlin.sizes.sizeWireNumber(LayerState.CornerRadiiWire.BL_WIRE) + gremlin.sizes.sizeFloat(self.bl);
            }
            if (self.br != 0.0) {
                res += gremlin.sizes.sizeWireNumber(LayerState.CornerRadiiWire.BR_WIRE) + gremlin.sizes.sizeFloat(self.br);
            }
            return res;
        }
        pub fn encode(self: *const LayerState.CornerRadii, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const LayerState.CornerRadii, target: *gremlin.Writer) void {
            if (self.tl != 0.0) {
                target.appendFloat32(LayerState.CornerRadiiWire.TL_WIRE, self.tl);
            }
            if (self.tr != 0.0) {
                target.appendFloat32(LayerState.CornerRadiiWire.TR_WIRE, self.tr);
            }
            if (self.bl != 0.0) {
                target.appendFloat32(LayerState.CornerRadiiWire.BL_WIRE, self.bl);
            }
            if (self.br != 0.0) {
                target.appendFloat32(LayerState.CornerRadiiWire.BR_WIRE, self.br);
            }
        }
    };
    pub const CornerRadiiReader = struct {
        buf: gremlin.Reader,
        _tl: f32 = 0.0,
        _tr: f32 = 0.0,
        _bl: f32 = 0.0,
        _br: f32 = 0.0,
        pub fn init(src: []const u8) gremlin.Error!LayerState.CornerRadiiReader {
            const buf = gremlin.Reader.init(src);
            var res = LayerState.CornerRadiiReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    LayerState.CornerRadiiWire.TL_WIRE => {
                        const result = try buf.readFloat32(offset);
                        offset += result.size;
                        res._tl = result.value;
                    },
                    LayerState.CornerRadiiWire.TR_WIRE => {
                        const result = try buf.readFloat32(offset);
                        offset += result.size;
                        res._tr = result.value;
                    },
                    LayerState.CornerRadiiWire.BL_WIRE => {
                        const result = try buf.readFloat32(offset);
                        offset += result.size;
                        res._bl = result.value;
                    },
                    LayerState.CornerRadiiWire.BR_WIRE => {
                        const result = try buf.readFloat32(offset);
                        offset += result.size;
                        res._br = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getTl(self: *const LayerState.CornerRadiiReader) f32 {
            return self._tl;
        }
        pub inline fn getTr(self: *const LayerState.CornerRadiiReader) f32 {
            return self._tr;
        }
        pub inline fn getBl(self: *const LayerState.CornerRadiiReader) f32 {
            return self._bl;
        }
        pub inline fn getBr(self: *const LayerState.CornerRadiiReader) f32 {
            return self._br;
        }
    };
    const Color3Wire = struct {
        const R_WIRE: gremlin.ProtoWireNumber = 1;
        const G_WIRE: gremlin.ProtoWireNumber = 2;
        const B_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const Color3 = struct {
        // fields
        r: f32 = 0.0,
        g: f32 = 0.0,
        b: f32 = 0.0,
        pub fn calcProtobufSize(self: *const LayerState.Color3) usize {
            var res: usize = 0;
            if (self.r != 0.0) {
                res += gremlin.sizes.sizeWireNumber(LayerState.Color3Wire.R_WIRE) + gremlin.sizes.sizeFloat(self.r);
            }
            if (self.g != 0.0) {
                res += gremlin.sizes.sizeWireNumber(LayerState.Color3Wire.G_WIRE) + gremlin.sizes.sizeFloat(self.g);
            }
            if (self.b != 0.0) {
                res += gremlin.sizes.sizeWireNumber(LayerState.Color3Wire.B_WIRE) + gremlin.sizes.sizeFloat(self.b);
            }
            return res;
        }
        pub fn encode(self: *const LayerState.Color3, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const LayerState.Color3, target: *gremlin.Writer) void {
            if (self.r != 0.0) {
                target.appendFloat32(LayerState.Color3Wire.R_WIRE, self.r);
            }
            if (self.g != 0.0) {
                target.appendFloat32(LayerState.Color3Wire.G_WIRE, self.g);
            }
            if (self.b != 0.0) {
                target.appendFloat32(LayerState.Color3Wire.B_WIRE, self.b);
            }
        }
    };
    pub const Color3Reader = struct {
        buf: gremlin.Reader,
        _r: f32 = 0.0,
        _g: f32 = 0.0,
        _b: f32 = 0.0,
        pub fn init(src: []const u8) gremlin.Error!LayerState.Color3Reader {
            const buf = gremlin.Reader.init(src);
            var res = LayerState.Color3Reader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    LayerState.Color3Wire.R_WIRE => {
                        const result = try buf.readFloat32(offset);
                        offset += result.size;
                        res._r = result.value;
                    },
                    LayerState.Color3Wire.G_WIRE => {
                        const result = try buf.readFloat32(offset);
                        offset += result.size;
                        res._g = result.value;
                    },
                    LayerState.Color3Wire.B_WIRE => {
                        const result = try buf.readFloat32(offset);
                        offset += result.size;
                        res._b = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getR(self: *const LayerState.Color3Reader) f32 {
            return self._r;
        }
        pub inline fn getG(self: *const LayerState.Color3Reader) f32 {
            return self._g;
        }
        pub inline fn getB(self: *const LayerState.Color3Reader) f32 {
            return self._b;
        }
    };
    const BufferDataWire = struct {
        const BUFFER_ID_WIRE: gremlin.ProtoWireNumber = 1;
        const WIDTH_WIRE: gremlin.ProtoWireNumber = 2;
        const HEIGHT_WIRE: gremlin.ProtoWireNumber = 3;
        const FRAME_NUMBER_WIRE: gremlin.ProtoWireNumber = 4;
        const FLAGS_WIRE: gremlin.ProtoWireNumber = 5;
        const CACHED_BUFFER_ID_WIRE: gremlin.ProtoWireNumber = 6;
        const PIXEL_FORMAT_WIRE: gremlin.ProtoWireNumber = 7;
        const USAGE_WIRE: gremlin.ProtoWireNumber = 8;
    };
    pub const BufferData = struct {
        // nested enums
        pub const BufferDataChange = enum(i32) {
            BUFFER_DATA_CHANGE_NONE = 0,
            FENCE_CHANGED = 1,
            FRAME_NUMBER_CHANGED = 2,
            CACHED_BUFFER_CHANGED = 4,
        };
        pub const PixelFormat = enum(i32) {
            PIXEL_FORMAT_UNKNOWN = 0,
            PIXEL_FORMAT_CUSTOM = -4,
            PIXEL_FORMAT_TRANSLUCENT = -3,
            PIXEL_FORMAT_TRANSPARENT = -2,
            PIXEL_FORMAT_OPAQUE = -1,
            PIXEL_FORMAT_RGBA_8888 = 1,
            PIXEL_FORMAT_RGBX_8888 = 2,
            PIXEL_FORMAT_RGB_888 = 3,
            PIXEL_FORMAT_RGB_565 = 4,
            PIXEL_FORMAT_BGRA_8888 = 5,
            PIXEL_FORMAT_RGBA_5551 = 6,
            PIXEL_FORMAT_RGBA_4444 = 7,
            PIXEL_FORMAT_RGBA_FP16 = 22,
            PIXEL_FORMAT_RGBA_1010102 = 43,
            PIXEL_FORMAT_R_8 = 56,
        };
        // fields
        buffer_id: u64 = 0,
        width: u32 = 0,
        height: u32 = 0,
        frame_number: u64 = 0,
        flags: u32 = 0,
        cached_buffer_id: u64 = 0,
        pixel_format: LayerState.BufferData.PixelFormat = @enumFromInt(0),
        usage: u64 = 0,
        pub fn calcProtobufSize(self: *const LayerState.BufferData) usize {
            var res: usize = 0;
            if (self.buffer_id != 0) {
                res += gremlin.sizes.sizeWireNumber(LayerState.BufferDataWire.BUFFER_ID_WIRE) + gremlin.sizes.sizeU64(self.buffer_id);
            }
            if (self.width != 0) {
                res += gremlin.sizes.sizeWireNumber(LayerState.BufferDataWire.WIDTH_WIRE) + gremlin.sizes.sizeU32(self.width);
            }
            if (self.height != 0) {
                res += gremlin.sizes.sizeWireNumber(LayerState.BufferDataWire.HEIGHT_WIRE) + gremlin.sizes.sizeU32(self.height);
            }
            if (self.frame_number != 0) {
                res += gremlin.sizes.sizeWireNumber(LayerState.BufferDataWire.FRAME_NUMBER_WIRE) + gremlin.sizes.sizeU64(self.frame_number);
            }
            if (self.flags != 0) {
                res += gremlin.sizes.sizeWireNumber(LayerState.BufferDataWire.FLAGS_WIRE) + gremlin.sizes.sizeU32(self.flags);
            }
            if (self.cached_buffer_id != 0) {
                res += gremlin.sizes.sizeWireNumber(LayerState.BufferDataWire.CACHED_BUFFER_ID_WIRE) + gremlin.sizes.sizeU64(self.cached_buffer_id);
            }
            if (@intFromEnum(self.pixel_format) != 0) {
                res += gremlin.sizes.sizeWireNumber(LayerState.BufferDataWire.PIXEL_FORMAT_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.pixel_format));
            }
            if (self.usage != 0) {
                res += gremlin.sizes.sizeWireNumber(LayerState.BufferDataWire.USAGE_WIRE) + gremlin.sizes.sizeU64(self.usage);
            }
            return res;
        }
        pub fn encode(self: *const LayerState.BufferData, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const LayerState.BufferData, target: *gremlin.Writer) void {
            if (self.buffer_id != 0) {
                target.appendUint64(LayerState.BufferDataWire.BUFFER_ID_WIRE, self.buffer_id);
            }
            if (self.width != 0) {
                target.appendUint32(LayerState.BufferDataWire.WIDTH_WIRE, self.width);
            }
            if (self.height != 0) {
                target.appendUint32(LayerState.BufferDataWire.HEIGHT_WIRE, self.height);
            }
            if (self.frame_number != 0) {
                target.appendUint64(LayerState.BufferDataWire.FRAME_NUMBER_WIRE, self.frame_number);
            }
            if (self.flags != 0) {
                target.appendUint32(LayerState.BufferDataWire.FLAGS_WIRE, self.flags);
            }
            if (self.cached_buffer_id != 0) {
                target.appendUint64(LayerState.BufferDataWire.CACHED_BUFFER_ID_WIRE, self.cached_buffer_id);
            }
            if (@intFromEnum(self.pixel_format) != 0) {
                target.appendInt32(LayerState.BufferDataWire.PIXEL_FORMAT_WIRE, @intFromEnum(self.pixel_format));
            }
            if (self.usage != 0) {
                target.appendUint64(LayerState.BufferDataWire.USAGE_WIRE, self.usage);
            }
        }
    };
    pub const BufferDataReader = struct {
        buf: gremlin.Reader,
        _buffer_id: u64 = 0,
        _width: u32 = 0,
        _height: u32 = 0,
        _frame_number: u64 = 0,
        _flags: u32 = 0,
        _cached_buffer_id: u64 = 0,
        _pixel_format: LayerState.BufferData.PixelFormat = @enumFromInt(0),
        _usage: u64 = 0,
        pub fn init(src: []const u8) gremlin.Error!LayerState.BufferDataReader {
            const buf = gremlin.Reader.init(src);
            var res = LayerState.BufferDataReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    LayerState.BufferDataWire.BUFFER_ID_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._buffer_id = result.value;
                    },
                    LayerState.BufferDataWire.WIDTH_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._width = result.value;
                    },
                    LayerState.BufferDataWire.HEIGHT_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._height = result.value;
                    },
                    LayerState.BufferDataWire.FRAME_NUMBER_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._frame_number = result.value;
                    },
                    LayerState.BufferDataWire.FLAGS_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._flags = result.value;
                    },
                    LayerState.BufferDataWire.CACHED_BUFFER_ID_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._cached_buffer_id = result.value;
                    },
                    LayerState.BufferDataWire.PIXEL_FORMAT_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._pixel_format = @enumFromInt(result.value);
                    },
                    LayerState.BufferDataWire.USAGE_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._usage = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getBufferId(self: *const LayerState.BufferDataReader) u64 {
            return self._buffer_id;
        }
        pub inline fn getWidth(self: *const LayerState.BufferDataReader) u32 {
            return self._width;
        }
        pub inline fn getHeight(self: *const LayerState.BufferDataReader) u32 {
            return self._height;
        }
        pub inline fn getFrameNumber(self: *const LayerState.BufferDataReader) u64 {
            return self._frame_number;
        }
        pub inline fn getFlags(self: *const LayerState.BufferDataReader) u32 {
            return self._flags;
        }
        pub inline fn getCachedBufferId(self: *const LayerState.BufferDataReader) u64 {
            return self._cached_buffer_id;
        }
        pub inline fn getPixelFormat(self: *const LayerState.BufferDataReader) LayerState.BufferData.PixelFormat {
            return self._pixel_format;
        }
        pub inline fn getUsage(self: *const LayerState.BufferDataReader) u64 {
            return self._usage;
        }
    };
    const WindowInfoWire = struct {
        const LAYOUT_PARAMS_FLAGS_WIRE: gremlin.ProtoWireNumber = 1;
        const LAYOUT_PARAMS_TYPE_WIRE: gremlin.ProtoWireNumber = 2;
        const TOUCHABLE_REGION_WIRE: gremlin.ProtoWireNumber = 3;
        const SURFACE_INSET_WIRE: gremlin.ProtoWireNumber = 4;
        const FOCUSABLE_WIRE: gremlin.ProtoWireNumber = 5;
        const HAS_WALLPAPER_WIRE: gremlin.ProtoWireNumber = 6;
        const GLOBAL_SCALE_FACTOR_WIRE: gremlin.ProtoWireNumber = 7;
        const CROP_LAYER_ID_WIRE: gremlin.ProtoWireNumber = 8;
        const REPLACE_TOUCHABLE_REGION_WITH_CROP_WIRE: gremlin.ProtoWireNumber = 9;
        const TOUCHABLE_REGION_CROP_WIRE: gremlin.ProtoWireNumber = 10;
        const TRANSFORM_WIRE: gremlin.ProtoWireNumber = 11;
        const INPUT_CONFIG_WIRE: gremlin.ProtoWireNumber = 12;
    };
    pub const WindowInfo = struct {
        // fields
        layout_params_flags: u32 = 0,
        layout_params_type: i32 = 0,
        touchable_region: ?surfaceflinger_common.RegionProto = null,
        surface_inset: i32 = 0,
        focusable: bool = false,
        has_wallpaper: bool = false,
        global_scale_factor: f32 = 0.0,
        crop_layer_id: u32 = 0,
        replace_touchable_region_with_crop: bool = false,
        touchable_region_crop: ?rect.RectProto = null,
        transform: ?Transform = null,
        input_config: u32 = 0,
        pub fn calcProtobufSize(self: *const LayerState.WindowInfo) usize {
            var res: usize = 0;
            if (self.layout_params_flags != 0) {
                res += gremlin.sizes.sizeWireNumber(LayerState.WindowInfoWire.LAYOUT_PARAMS_FLAGS_WIRE) + gremlin.sizes.sizeU32(self.layout_params_flags);
            }
            if (self.layout_params_type != 0) {
                res += gremlin.sizes.sizeWireNumber(LayerState.WindowInfoWire.LAYOUT_PARAMS_TYPE_WIRE) + gremlin.sizes.sizeI32(self.layout_params_type);
            }
            if (self.touchable_region) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(LayerState.WindowInfoWire.TOUCHABLE_REGION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.surface_inset != 0) {
                res += gremlin.sizes.sizeWireNumber(LayerState.WindowInfoWire.SURFACE_INSET_WIRE) + gremlin.sizes.sizeI32(self.surface_inset);
            }
            if (self.focusable != false) {
                res += gremlin.sizes.sizeWireNumber(LayerState.WindowInfoWire.FOCUSABLE_WIRE) + gremlin.sizes.sizeBool(self.focusable);
            }
            if (self.has_wallpaper != false) {
                res += gremlin.sizes.sizeWireNumber(LayerState.WindowInfoWire.HAS_WALLPAPER_WIRE) + gremlin.sizes.sizeBool(self.has_wallpaper);
            }
            if (self.global_scale_factor != 0.0) {
                res += gremlin.sizes.sizeWireNumber(LayerState.WindowInfoWire.GLOBAL_SCALE_FACTOR_WIRE) + gremlin.sizes.sizeFloat(self.global_scale_factor);
            }
            if (self.crop_layer_id != 0) {
                res += gremlin.sizes.sizeWireNumber(LayerState.WindowInfoWire.CROP_LAYER_ID_WIRE) + gremlin.sizes.sizeU32(self.crop_layer_id);
            }
            if (self.replace_touchable_region_with_crop != false) {
                res += gremlin.sizes.sizeWireNumber(LayerState.WindowInfoWire.REPLACE_TOUCHABLE_REGION_WITH_CROP_WIRE) + gremlin.sizes.sizeBool(self.replace_touchable_region_with_crop);
            }
            if (self.touchable_region_crop) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(LayerState.WindowInfoWire.TOUCHABLE_REGION_CROP_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.transform) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(LayerState.WindowInfoWire.TRANSFORM_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.input_config != 0) {
                res += gremlin.sizes.sizeWireNumber(LayerState.WindowInfoWire.INPUT_CONFIG_WIRE) + gremlin.sizes.sizeU32(self.input_config);
            }
            return res;
        }
        pub fn encode(self: *const LayerState.WindowInfo, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const LayerState.WindowInfo, target: *gremlin.Writer) void {
            if (self.layout_params_flags != 0) {
                target.appendUint32(LayerState.WindowInfoWire.LAYOUT_PARAMS_FLAGS_WIRE, self.layout_params_flags);
            }
            if (self.layout_params_type != 0) {
                target.appendInt32(LayerState.WindowInfoWire.LAYOUT_PARAMS_TYPE_WIRE, self.layout_params_type);
            }
            if (self.touchable_region) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(LayerState.WindowInfoWire.TOUCHABLE_REGION_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.surface_inset != 0) {
                target.appendInt32(LayerState.WindowInfoWire.SURFACE_INSET_WIRE, self.surface_inset);
            }
            if (self.focusable != false) {
                target.appendBool(LayerState.WindowInfoWire.FOCUSABLE_WIRE, self.focusable);
            }
            if (self.has_wallpaper != false) {
                target.appendBool(LayerState.WindowInfoWire.HAS_WALLPAPER_WIRE, self.has_wallpaper);
            }
            if (self.global_scale_factor != 0.0) {
                target.appendFloat32(LayerState.WindowInfoWire.GLOBAL_SCALE_FACTOR_WIRE, self.global_scale_factor);
            }
            if (self.crop_layer_id != 0) {
                target.appendUint32(LayerState.WindowInfoWire.CROP_LAYER_ID_WIRE, self.crop_layer_id);
            }
            if (self.replace_touchable_region_with_crop != false) {
                target.appendBool(LayerState.WindowInfoWire.REPLACE_TOUCHABLE_REGION_WITH_CROP_WIRE, self.replace_touchable_region_with_crop);
            }
            if (self.touchable_region_crop) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(LayerState.WindowInfoWire.TOUCHABLE_REGION_CROP_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.transform) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(LayerState.WindowInfoWire.TRANSFORM_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.input_config != 0) {
                target.appendUint32(LayerState.WindowInfoWire.INPUT_CONFIG_WIRE, self.input_config);
            }
        }
    };
    pub const WindowInfoReader = struct {
        buf: gremlin.Reader,
        _layout_params_flags: u32 = 0,
        _layout_params_type: i32 = 0,
        _touchable_region_buf: ?[]const u8 = null,
        _surface_inset: i32 = 0,
        _focusable: bool = false,
        _has_wallpaper: bool = false,
        _global_scale_factor: f32 = 0.0,
        _crop_layer_id: u32 = 0,
        _replace_touchable_region_with_crop: bool = false,
        _touchable_region_crop_buf: ?[]const u8 = null,
        _transform_buf: ?[]const u8 = null,
        _input_config: u32 = 0,
        pub fn init(src: []const u8) gremlin.Error!LayerState.WindowInfoReader {
            const buf = gremlin.Reader.init(src);
            var res = LayerState.WindowInfoReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    LayerState.WindowInfoWire.LAYOUT_PARAMS_FLAGS_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._layout_params_flags = result.value;
                    },
                    LayerState.WindowInfoWire.LAYOUT_PARAMS_TYPE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._layout_params_type = result.value;
                    },
                    LayerState.WindowInfoWire.TOUCHABLE_REGION_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._touchable_region_buf = result.value;
                    },
                    LayerState.WindowInfoWire.SURFACE_INSET_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._surface_inset = result.value;
                    },
                    LayerState.WindowInfoWire.FOCUSABLE_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._focusable = result.value;
                    },
                    LayerState.WindowInfoWire.HAS_WALLPAPER_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._has_wallpaper = result.value;
                    },
                    LayerState.WindowInfoWire.GLOBAL_SCALE_FACTOR_WIRE => {
                        const result = try buf.readFloat32(offset);
                        offset += result.size;
                        res._global_scale_factor = result.value;
                    },
                    LayerState.WindowInfoWire.CROP_LAYER_ID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._crop_layer_id = result.value;
                    },
                    LayerState.WindowInfoWire.REPLACE_TOUCHABLE_REGION_WITH_CROP_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._replace_touchable_region_with_crop = result.value;
                    },
                    LayerState.WindowInfoWire.TOUCHABLE_REGION_CROP_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._touchable_region_crop_buf = result.value;
                    },
                    LayerState.WindowInfoWire.TRANSFORM_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._transform_buf = result.value;
                    },
                    LayerState.WindowInfoWire.INPUT_CONFIG_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._input_config = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getLayoutParamsFlags(self: *const LayerState.WindowInfoReader) u32 {
            return self._layout_params_flags;
        }
        pub inline fn getLayoutParamsType(self: *const LayerState.WindowInfoReader) i32 {
            return self._layout_params_type;
        }
        pub fn getTouchableRegion(self: *const LayerState.WindowInfoReader) gremlin.Error!surfaceflinger_common.RegionProtoReader {
            if (self._touchable_region_buf) |buf| {
                return try surfaceflinger_common.RegionProtoReader.init(buf);
            }
            return try surfaceflinger_common.RegionProtoReader.init(&[_]u8{});
        }
        pub inline fn getSurfaceInset(self: *const LayerState.WindowInfoReader) i32 {
            return self._surface_inset;
        }
        pub inline fn getFocusable(self: *const LayerState.WindowInfoReader) bool {
            return self._focusable;
        }
        pub inline fn getHasWallpaper(self: *const LayerState.WindowInfoReader) bool {
            return self._has_wallpaper;
        }
        pub inline fn getGlobalScaleFactor(self: *const LayerState.WindowInfoReader) f32 {
            return self._global_scale_factor;
        }
        pub inline fn getCropLayerId(self: *const LayerState.WindowInfoReader) u32 {
            return self._crop_layer_id;
        }
        pub inline fn getReplaceTouchableRegionWithCrop(self: *const LayerState.WindowInfoReader) bool {
            return self._replace_touchable_region_with_crop;
        }
        pub fn getTouchableRegionCrop(self: *const LayerState.WindowInfoReader) gremlin.Error!rect.RectProtoReader {
            if (self._touchable_region_crop_buf) |buf| {
                return try rect.RectProtoReader.init(buf);
            }
            return try rect.RectProtoReader.init(&[_]u8{});
        }
        pub fn getTransform(self: *const LayerState.WindowInfoReader) gremlin.Error!TransformReader {
            if (self._transform_buf) |buf| {
                return try TransformReader.init(buf);
            }
            return try TransformReader.init(&[_]u8{});
        }
        pub inline fn getInputConfig(self: *const LayerState.WindowInfoReader) u32 {
            return self._input_config;
        }
    };
    // fields
    layer_id: u32 = 0,
    what: u64 = 0,
    x: f32 = 0.0,
    y: f32 = 0.0,
    z: i32 = 0,
    w: u32 = 0,
    h: u32 = 0,
    layer_stack: u32 = 0,
    flags: u32 = 0,
    mask: u32 = 0,
    matrix: ?LayerState.Matrix22 = null,
    corner_radius: f32 = 0.0,
    background_blur_radius: u32 = 0,
    parent_id: u32 = 0,
    relative_parent_id: u32 = 0,
    alpha: f32 = 0.0,
    color: ?LayerState.Color3 = null,
    transparent_region: ?surfaceflinger_common.RegionProto = null,
    transform: u32 = 0,
    transform_to_display_inverse: bool = false,
    crop: ?rect.RectProto = null,
    buffer_data: ?LayerState.BufferData = null,
    api: i32 = 0,
    has_sideband_stream: bool = false,
    color_transform: ?surfaceflinger_common.ColorTransformProto = null,
    blur_regions: ?[]const ?surfaceflinger_common.BlurRegion = null,
    window_info_handle: ?LayerState.WindowInfo = null,
    bg_color_alpha: f32 = 0.0,
    bg_color_dataspace: i32 = 0,
    color_space_agnostic: bool = false,
    shadow_radius: f32 = 0.0,
    frame_rate_selection_priority: i32 = 0,
    frame_rate: f32 = 0.0,
    frame_rate_compatibility: i32 = 0,
    change_frame_rate_strategy: i32 = 0,
    fixed_transform_hint: u32 = 0,
    frame_number: u64 = 0,
    auto_refresh: bool = false,
    is_trusted_overlay: bool = false,
    buffer_crop: ?rect.RectProto = null,
    destination_frame: ?rect.RectProto = null,
    drop_input_mode: LayerState.DropInputMode = @enumFromInt(0),
    trusted_overlay: surfaceflinger_common.TrustedOverlay = @enumFromInt(0),
    background_blur_scale: f32 = 0.0,
    corner_radii: ?LayerState.CornerRadii = null,
    client_drawn_corner_radii: ?LayerState.CornerRadii = null,
    system_content_priority: i32 = 0,
    box_shadow_settings: ?surfaceflinger_common.BoxShadowSettings = null,
    border_settings: ?surfaceflinger_common.BorderSettings = null,
    pub fn calcProtobufSize(self: *const LayerState) usize {
        var res: usize = 0;
        if (self.layer_id != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerStateWire.LAYER_ID_WIRE) + gremlin.sizes.sizeU32(self.layer_id);
        }
        if (self.what != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerStateWire.WHAT_WIRE) + gremlin.sizes.sizeU64(self.what);
        }
        if (self.x != 0.0) {
            res += gremlin.sizes.sizeWireNumber(LayerStateWire.X_WIRE) + gremlin.sizes.sizeFloat(self.x);
        }
        if (self.y != 0.0) {
            res += gremlin.sizes.sizeWireNumber(LayerStateWire.Y_WIRE) + gremlin.sizes.sizeFloat(self.y);
        }
        if (self.z != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerStateWire.Z_WIRE) + gremlin.sizes.sizeI32(self.z);
        }
        if (self.w != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerStateWire.W_WIRE) + gremlin.sizes.sizeU32(self.w);
        }
        if (self.h != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerStateWire.H_WIRE) + gremlin.sizes.sizeU32(self.h);
        }
        if (self.layer_stack != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerStateWire.LAYER_STACK_WIRE) + gremlin.sizes.sizeU32(self.layer_stack);
        }
        if (self.flags != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerStateWire.FLAGS_WIRE) + gremlin.sizes.sizeU32(self.flags);
        }
        if (self.mask != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerStateWire.MASK_WIRE) + gremlin.sizes.sizeU32(self.mask);
        }
        if (self.matrix) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerStateWire.MATRIX_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.corner_radius != 0.0) {
            res += gremlin.sizes.sizeWireNumber(LayerStateWire.CORNER_RADIUS_WIRE) + gremlin.sizes.sizeFloat(self.corner_radius);
        }
        if (self.background_blur_radius != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerStateWire.BACKGROUND_BLUR_RADIUS_WIRE) + gremlin.sizes.sizeU32(self.background_blur_radius);
        }
        if (self.parent_id != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerStateWire.PARENT_ID_WIRE) + gremlin.sizes.sizeU32(self.parent_id);
        }
        if (self.relative_parent_id != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerStateWire.RELATIVE_PARENT_ID_WIRE) + gremlin.sizes.sizeU32(self.relative_parent_id);
        }
        if (self.alpha != 0.0) {
            res += gremlin.sizes.sizeWireNumber(LayerStateWire.ALPHA_WIRE) + gremlin.sizes.sizeFloat(self.alpha);
        }
        if (self.color) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerStateWire.COLOR_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.transparent_region) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerStateWire.TRANSPARENT_REGION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.transform != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerStateWire.TRANSFORM_WIRE) + gremlin.sizes.sizeU32(self.transform);
        }
        if (self.transform_to_display_inverse != false) {
            res += gremlin.sizes.sizeWireNumber(LayerStateWire.TRANSFORM_TO_DISPLAY_INVERSE_WIRE) + gremlin.sizes.sizeBool(self.transform_to_display_inverse);
        }
        if (self.crop) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerStateWire.CROP_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.buffer_data) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerStateWire.BUFFER_DATA_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.api != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerStateWire.API_WIRE) + gremlin.sizes.sizeI32(self.api);
        }
        if (self.has_sideband_stream != false) {
            res += gremlin.sizes.sizeWireNumber(LayerStateWire.HAS_SIDEBAND_STREAM_WIRE) + gremlin.sizes.sizeBool(self.has_sideband_stream);
        }
        if (self.color_transform) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerStateWire.COLOR_TRANSFORM_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.blur_regions) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(LayerStateWire.BLUR_REGIONS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.window_info_handle) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerStateWire.WINDOW_INFO_HANDLE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.bg_color_alpha != 0.0) {
            res += gremlin.sizes.sizeWireNumber(LayerStateWire.BG_COLOR_ALPHA_WIRE) + gremlin.sizes.sizeFloat(self.bg_color_alpha);
        }
        if (self.bg_color_dataspace != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerStateWire.BG_COLOR_DATASPACE_WIRE) + gremlin.sizes.sizeI32(self.bg_color_dataspace);
        }
        if (self.color_space_agnostic != false) {
            res += gremlin.sizes.sizeWireNumber(LayerStateWire.COLOR_SPACE_AGNOSTIC_WIRE) + gremlin.sizes.sizeBool(self.color_space_agnostic);
        }
        if (self.shadow_radius != 0.0) {
            res += gremlin.sizes.sizeWireNumber(LayerStateWire.SHADOW_RADIUS_WIRE) + gremlin.sizes.sizeFloat(self.shadow_radius);
        }
        if (self.frame_rate_selection_priority != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerStateWire.FRAME_RATE_SELECTION_PRIORITY_WIRE) + gremlin.sizes.sizeI32(self.frame_rate_selection_priority);
        }
        if (self.frame_rate != 0.0) {
            res += gremlin.sizes.sizeWireNumber(LayerStateWire.FRAME_RATE_WIRE) + gremlin.sizes.sizeFloat(self.frame_rate);
        }
        if (self.frame_rate_compatibility != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerStateWire.FRAME_RATE_COMPATIBILITY_WIRE) + gremlin.sizes.sizeI32(self.frame_rate_compatibility);
        }
        if (self.change_frame_rate_strategy != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerStateWire.CHANGE_FRAME_RATE_STRATEGY_WIRE) + gremlin.sizes.sizeI32(self.change_frame_rate_strategy);
        }
        if (self.fixed_transform_hint != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerStateWire.FIXED_TRANSFORM_HINT_WIRE) + gremlin.sizes.sizeU32(self.fixed_transform_hint);
        }
        if (self.frame_number != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerStateWire.FRAME_NUMBER_WIRE) + gremlin.sizes.sizeU64(self.frame_number);
        }
        if (self.auto_refresh != false) {
            res += gremlin.sizes.sizeWireNumber(LayerStateWire.AUTO_REFRESH_WIRE) + gremlin.sizes.sizeBool(self.auto_refresh);
        }
        if (self.is_trusted_overlay != false) {
            res += gremlin.sizes.sizeWireNumber(LayerStateWire.IS_TRUSTED_OVERLAY_WIRE) + gremlin.sizes.sizeBool(self.is_trusted_overlay);
        }
        if (self.buffer_crop) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerStateWire.BUFFER_CROP_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.destination_frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerStateWire.DESTINATION_FRAME_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (@intFromEnum(self.drop_input_mode) != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerStateWire.DROP_INPUT_MODE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.drop_input_mode));
        }
        if (@intFromEnum(self.trusted_overlay) != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerStateWire.TRUSTED_OVERLAY_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.trusted_overlay));
        }
        if (self.background_blur_scale != 0.0) {
            res += gremlin.sizes.sizeWireNumber(LayerStateWire.BACKGROUND_BLUR_SCALE_WIRE) + gremlin.sizes.sizeFloat(self.background_blur_scale);
        }
        if (self.corner_radii) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerStateWire.CORNER_RADII_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.client_drawn_corner_radii) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerStateWire.CLIENT_DRAWN_CORNER_RADII_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.system_content_priority != 0) {
            res += gremlin.sizes.sizeWireNumber(LayerStateWire.SYSTEM_CONTENT_PRIORITY_WIRE) + gremlin.sizes.sizeI32(self.system_content_priority);
        }
        if (self.box_shadow_settings) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerStateWire.BOX_SHADOW_SETTINGS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.border_settings) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(LayerStateWire.BORDER_SETTINGS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const LayerState, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const LayerState, target: *gremlin.Writer) void {
        if (self.layer_id != 0) {
            target.appendUint32(LayerStateWire.LAYER_ID_WIRE, self.layer_id);
        }
        if (self.what != 0) {
            target.appendUint64(LayerStateWire.WHAT_WIRE, self.what);
        }
        if (self.x != 0.0) {
            target.appendFloat32(LayerStateWire.X_WIRE, self.x);
        }
        if (self.y != 0.0) {
            target.appendFloat32(LayerStateWire.Y_WIRE, self.y);
        }
        if (self.z != 0) {
            target.appendInt32(LayerStateWire.Z_WIRE, self.z);
        }
        if (self.w != 0) {
            target.appendUint32(LayerStateWire.W_WIRE, self.w);
        }
        if (self.h != 0) {
            target.appendUint32(LayerStateWire.H_WIRE, self.h);
        }
        if (self.layer_stack != 0) {
            target.appendUint32(LayerStateWire.LAYER_STACK_WIRE, self.layer_stack);
        }
        if (self.flags != 0) {
            target.appendUint32(LayerStateWire.FLAGS_WIRE, self.flags);
        }
        if (self.mask != 0) {
            target.appendUint32(LayerStateWire.MASK_WIRE, self.mask);
        }
        if (self.matrix) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LayerStateWire.MATRIX_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.corner_radius != 0.0) {
            target.appendFloat32(LayerStateWire.CORNER_RADIUS_WIRE, self.corner_radius);
        }
        if (self.background_blur_radius != 0) {
            target.appendUint32(LayerStateWire.BACKGROUND_BLUR_RADIUS_WIRE, self.background_blur_radius);
        }
        if (self.parent_id != 0) {
            target.appendUint32(LayerStateWire.PARENT_ID_WIRE, self.parent_id);
        }
        if (self.relative_parent_id != 0) {
            target.appendUint32(LayerStateWire.RELATIVE_PARENT_ID_WIRE, self.relative_parent_id);
        }
        if (self.alpha != 0.0) {
            target.appendFloat32(LayerStateWire.ALPHA_WIRE, self.alpha);
        }
        if (self.color) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LayerStateWire.COLOR_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.transparent_region) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LayerStateWire.TRANSPARENT_REGION_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.transform != 0) {
            target.appendUint32(LayerStateWire.TRANSFORM_WIRE, self.transform);
        }
        if (self.transform_to_display_inverse != false) {
            target.appendBool(LayerStateWire.TRANSFORM_TO_DISPLAY_INVERSE_WIRE, self.transform_to_display_inverse);
        }
        if (self.crop) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LayerStateWire.CROP_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.buffer_data) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LayerStateWire.BUFFER_DATA_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.api != 0) {
            target.appendInt32(LayerStateWire.API_WIRE, self.api);
        }
        if (self.has_sideband_stream != false) {
            target.appendBool(LayerStateWire.HAS_SIDEBAND_STREAM_WIRE, self.has_sideband_stream);
        }
        if (self.color_transform) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LayerStateWire.COLOR_TRANSFORM_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.blur_regions) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(LayerStateWire.BLUR_REGIONS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(LayerStateWire.BLUR_REGIONS_WIRE, 0);
                }
            }
        }
        if (self.window_info_handle) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LayerStateWire.WINDOW_INFO_HANDLE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.bg_color_alpha != 0.0) {
            target.appendFloat32(LayerStateWire.BG_COLOR_ALPHA_WIRE, self.bg_color_alpha);
        }
        if (self.bg_color_dataspace != 0) {
            target.appendInt32(LayerStateWire.BG_COLOR_DATASPACE_WIRE, self.bg_color_dataspace);
        }
        if (self.color_space_agnostic != false) {
            target.appendBool(LayerStateWire.COLOR_SPACE_AGNOSTIC_WIRE, self.color_space_agnostic);
        }
        if (self.shadow_radius != 0.0) {
            target.appendFloat32(LayerStateWire.SHADOW_RADIUS_WIRE, self.shadow_radius);
        }
        if (self.frame_rate_selection_priority != 0) {
            target.appendInt32(LayerStateWire.FRAME_RATE_SELECTION_PRIORITY_WIRE, self.frame_rate_selection_priority);
        }
        if (self.frame_rate != 0.0) {
            target.appendFloat32(LayerStateWire.FRAME_RATE_WIRE, self.frame_rate);
        }
        if (self.frame_rate_compatibility != 0) {
            target.appendInt32(LayerStateWire.FRAME_RATE_COMPATIBILITY_WIRE, self.frame_rate_compatibility);
        }
        if (self.change_frame_rate_strategy != 0) {
            target.appendInt32(LayerStateWire.CHANGE_FRAME_RATE_STRATEGY_WIRE, self.change_frame_rate_strategy);
        }
        if (self.fixed_transform_hint != 0) {
            target.appendUint32(LayerStateWire.FIXED_TRANSFORM_HINT_WIRE, self.fixed_transform_hint);
        }
        if (self.frame_number != 0) {
            target.appendUint64(LayerStateWire.FRAME_NUMBER_WIRE, self.frame_number);
        }
        if (self.auto_refresh != false) {
            target.appendBool(LayerStateWire.AUTO_REFRESH_WIRE, self.auto_refresh);
        }
        if (self.is_trusted_overlay != false) {
            target.appendBool(LayerStateWire.IS_TRUSTED_OVERLAY_WIRE, self.is_trusted_overlay);
        }
        if (self.buffer_crop) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LayerStateWire.BUFFER_CROP_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.destination_frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LayerStateWire.DESTINATION_FRAME_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (@intFromEnum(self.drop_input_mode) != 0) {
            target.appendInt32(LayerStateWire.DROP_INPUT_MODE_WIRE, @intFromEnum(self.drop_input_mode));
        }
        if (@intFromEnum(self.trusted_overlay) != 0) {
            target.appendInt32(LayerStateWire.TRUSTED_OVERLAY_WIRE, @intFromEnum(self.trusted_overlay));
        }
        if (self.background_blur_scale != 0.0) {
            target.appendFloat32(LayerStateWire.BACKGROUND_BLUR_SCALE_WIRE, self.background_blur_scale);
        }
        if (self.corner_radii) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LayerStateWire.CORNER_RADII_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.client_drawn_corner_radii) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LayerStateWire.CLIENT_DRAWN_CORNER_RADII_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.system_content_priority != 0) {
            target.appendInt32(LayerStateWire.SYSTEM_CONTENT_PRIORITY_WIRE, self.system_content_priority);
        }
        if (self.box_shadow_settings) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LayerStateWire.BOX_SHADOW_SETTINGS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.border_settings) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(LayerStateWire.BORDER_SETTINGS_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const LayerStateReader = struct {
    buf: gremlin.Reader,
    _layer_id: u32 = 0,
    _what: u64 = 0,
    _x: f32 = 0.0,
    _y: f32 = 0.0,
    _z: i32 = 0,
    _w: u32 = 0,
    _h: u32 = 0,
    _layer_stack: u32 = 0,
    _flags: u32 = 0,
    _mask: u32 = 0,
    _matrix_buf: ?[]const u8 = null,
    _corner_radius: f32 = 0.0,
    _background_blur_radius: u32 = 0,
    _parent_id: u32 = 0,
    _relative_parent_id: u32 = 0,
    _alpha: f32 = 0.0,
    _color_buf: ?[]const u8 = null,
    _transparent_region_buf: ?[]const u8 = null,
    _transform: u32 = 0,
    _transform_to_display_inverse: bool = false,
    _crop_buf: ?[]const u8 = null,
    _buffer_data_buf: ?[]const u8 = null,
    _api: i32 = 0,
    _has_sideband_stream: bool = false,
    _color_transform_buf: ?[]const u8 = null,
    _blur_regions_offset: ?usize = null,
    _blur_regions_last_offset: ?usize = null,
    _blur_regions_cnt: usize = 0,
    _window_info_handle_buf: ?[]const u8 = null,
    _bg_color_alpha: f32 = 0.0,
    _bg_color_dataspace: i32 = 0,
    _color_space_agnostic: bool = false,
    _shadow_radius: f32 = 0.0,
    _frame_rate_selection_priority: i32 = 0,
    _frame_rate: f32 = 0.0,
    _frame_rate_compatibility: i32 = 0,
    _change_frame_rate_strategy: i32 = 0,
    _fixed_transform_hint: u32 = 0,
    _frame_number: u64 = 0,
    _auto_refresh: bool = false,
    _is_trusted_overlay: bool = false,
    _buffer_crop_buf: ?[]const u8 = null,
    _destination_frame_buf: ?[]const u8 = null,
    _drop_input_mode: LayerState.DropInputMode = @enumFromInt(0),
    _trusted_overlay: surfaceflinger_common.TrustedOverlay = @enumFromInt(0),
    _background_blur_scale: f32 = 0.0,
    _corner_radii_buf: ?[]const u8 = null,
    _client_drawn_corner_radii_buf: ?[]const u8 = null,
    _system_content_priority: i32 = 0,
    _box_shadow_settings_buf: ?[]const u8 = null,
    _border_settings_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!LayerStateReader {
        const buf = gremlin.Reader.init(src);
        var res = LayerStateReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                LayerStateWire.LAYER_ID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._layer_id = result.value;
                },
                LayerStateWire.WHAT_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._what = result.value;
                },
                LayerStateWire.X_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._x = result.value;
                },
                LayerStateWire.Y_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._y = result.value;
                },
                LayerStateWire.Z_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._z = result.value;
                },
                LayerStateWire.W_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._w = result.value;
                },
                LayerStateWire.H_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._h = result.value;
                },
                LayerStateWire.LAYER_STACK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._layer_stack = result.value;
                },
                LayerStateWire.FLAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._flags = result.value;
                },
                LayerStateWire.MASK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._mask = result.value;
                },
                LayerStateWire.MATRIX_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._matrix_buf = result.value;
                },
                LayerStateWire.CORNER_RADIUS_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._corner_radius = result.value;
                },
                LayerStateWire.BACKGROUND_BLUR_RADIUS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._background_blur_radius = result.value;
                },
                LayerStateWire.PARENT_ID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._parent_id = result.value;
                },
                LayerStateWire.RELATIVE_PARENT_ID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._relative_parent_id = result.value;
                },
                LayerStateWire.ALPHA_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._alpha = result.value;
                },
                LayerStateWire.COLOR_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._color_buf = result.value;
                },
                LayerStateWire.TRANSPARENT_REGION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._transparent_region_buf = result.value;
                },
                LayerStateWire.TRANSFORM_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._transform = result.value;
                },
                LayerStateWire.TRANSFORM_TO_DISPLAY_INVERSE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._transform_to_display_inverse = result.value;
                },
                LayerStateWire.CROP_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._crop_buf = result.value;
                },
                LayerStateWire.BUFFER_DATA_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._buffer_data_buf = result.value;
                },
                LayerStateWire.API_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._api = result.value;
                },
                LayerStateWire.HAS_SIDEBAND_STREAM_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._has_sideband_stream = result.value;
                },
                LayerStateWire.COLOR_TRANSFORM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._color_transform_buf = result.value;
                },
                LayerStateWire.BLUR_REGIONS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._blur_regions_offset == null) {
                        res._blur_regions_offset = offset - result.size;
                    }
                    res._blur_regions_last_offset = offset;
                    res._blur_regions_cnt += 1;
                },
                LayerStateWire.WINDOW_INFO_HANDLE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._window_info_handle_buf = result.value;
                },
                LayerStateWire.BG_COLOR_ALPHA_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._bg_color_alpha = result.value;
                },
                LayerStateWire.BG_COLOR_DATASPACE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._bg_color_dataspace = result.value;
                },
                LayerStateWire.COLOR_SPACE_AGNOSTIC_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._color_space_agnostic = result.value;
                },
                LayerStateWire.SHADOW_RADIUS_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._shadow_radius = result.value;
                },
                LayerStateWire.FRAME_RATE_SELECTION_PRIORITY_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._frame_rate_selection_priority = result.value;
                },
                LayerStateWire.FRAME_RATE_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._frame_rate = result.value;
                },
                LayerStateWire.FRAME_RATE_COMPATIBILITY_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._frame_rate_compatibility = result.value;
                },
                LayerStateWire.CHANGE_FRAME_RATE_STRATEGY_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._change_frame_rate_strategy = result.value;
                },
                LayerStateWire.FIXED_TRANSFORM_HINT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._fixed_transform_hint = result.value;
                },
                LayerStateWire.FRAME_NUMBER_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._frame_number = result.value;
                },
                LayerStateWire.AUTO_REFRESH_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._auto_refresh = result.value;
                },
                LayerStateWire.IS_TRUSTED_OVERLAY_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_trusted_overlay = result.value;
                },
                LayerStateWire.BUFFER_CROP_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._buffer_crop_buf = result.value;
                },
                LayerStateWire.DESTINATION_FRAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._destination_frame_buf = result.value;
                },
                LayerStateWire.DROP_INPUT_MODE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._drop_input_mode = @enumFromInt(result.value);
                },
                LayerStateWire.TRUSTED_OVERLAY_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._trusted_overlay = @enumFromInt(result.value);
                },
                LayerStateWire.BACKGROUND_BLUR_SCALE_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._background_blur_scale = result.value;
                },
                LayerStateWire.CORNER_RADII_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._corner_radii_buf = result.value;
                },
                LayerStateWire.CLIENT_DRAWN_CORNER_RADII_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._client_drawn_corner_radii_buf = result.value;
                },
                LayerStateWire.SYSTEM_CONTENT_PRIORITY_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._system_content_priority = result.value;
                },
                LayerStateWire.BOX_SHADOW_SETTINGS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._box_shadow_settings_buf = result.value;
                },
                LayerStateWire.BORDER_SETTINGS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._border_settings_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getLayerId(self: *const LayerStateReader) u32 {
        return self._layer_id;
    }
    pub inline fn getWhat(self: *const LayerStateReader) u64 {
        return self._what;
    }
    pub inline fn getX(self: *const LayerStateReader) f32 {
        return self._x;
    }
    pub inline fn getY(self: *const LayerStateReader) f32 {
        return self._y;
    }
    pub inline fn getZ(self: *const LayerStateReader) i32 {
        return self._z;
    }
    pub inline fn getW(self: *const LayerStateReader) u32 {
        return self._w;
    }
    pub inline fn getH(self: *const LayerStateReader) u32 {
        return self._h;
    }
    pub inline fn getLayerStack(self: *const LayerStateReader) u32 {
        return self._layer_stack;
    }
    pub inline fn getFlags(self: *const LayerStateReader) u32 {
        return self._flags;
    }
    pub inline fn getMask(self: *const LayerStateReader) u32 {
        return self._mask;
    }
    pub fn getMatrix(self: *const LayerStateReader) gremlin.Error!LayerState.Matrix22Reader {
        if (self._matrix_buf) |buf| {
            return try LayerState.Matrix22Reader.init(buf);
        }
        return try LayerState.Matrix22Reader.init(&[_]u8{});
    }
    pub inline fn getCornerRadius(self: *const LayerStateReader) f32 {
        return self._corner_radius;
    }
    pub inline fn getBackgroundBlurRadius(self: *const LayerStateReader) u32 {
        return self._background_blur_radius;
    }
    pub inline fn getParentId(self: *const LayerStateReader) u32 {
        return self._parent_id;
    }
    pub inline fn getRelativeParentId(self: *const LayerStateReader) u32 {
        return self._relative_parent_id;
    }
    pub inline fn getAlpha(self: *const LayerStateReader) f32 {
        return self._alpha;
    }
    pub fn getColor(self: *const LayerStateReader) gremlin.Error!LayerState.Color3Reader {
        if (self._color_buf) |buf| {
            return try LayerState.Color3Reader.init(buf);
        }
        return try LayerState.Color3Reader.init(&[_]u8{});
    }
    pub fn getTransparentRegion(self: *const LayerStateReader) gremlin.Error!surfaceflinger_common.RegionProtoReader {
        if (self._transparent_region_buf) |buf| {
            return try surfaceflinger_common.RegionProtoReader.init(buf);
        }
        return try surfaceflinger_common.RegionProtoReader.init(&[_]u8{});
    }
    pub inline fn getTransform(self: *const LayerStateReader) u32 {
        return self._transform;
    }
    pub inline fn getTransformToDisplayInverse(self: *const LayerStateReader) bool {
        return self._transform_to_display_inverse;
    }
    pub fn getCrop(self: *const LayerStateReader) gremlin.Error!rect.RectProtoReader {
        if (self._crop_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getBufferData(self: *const LayerStateReader) gremlin.Error!LayerState.BufferDataReader {
        if (self._buffer_data_buf) |buf| {
            return try LayerState.BufferDataReader.init(buf);
        }
        return try LayerState.BufferDataReader.init(&[_]u8{});
    }
    pub inline fn getApi(self: *const LayerStateReader) i32 {
        return self._api;
    }
    pub inline fn getHasSidebandStream(self: *const LayerStateReader) bool {
        return self._has_sideband_stream;
    }
    pub fn getColorTransform(self: *const LayerStateReader) gremlin.Error!surfaceflinger_common.ColorTransformProtoReader {
        if (self._color_transform_buf) |buf| {
            return try surfaceflinger_common.ColorTransformProtoReader.init(buf);
        }
        return try surfaceflinger_common.ColorTransformProtoReader.init(&[_]u8{});
    }
    pub fn blurRegionsCount(self: *const LayerStateReader) usize {
        return self._blur_regions_cnt;
    }
    pub fn blurRegionsNext(self: *LayerStateReader) ?surfaceflinger_common.BlurRegionReader {
        if (self._blur_regions_offset == null) return null;
        const current_offset = self._blur_regions_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = surfaceflinger_common.BlurRegionReader.init(result.value) catch return null;
        if (self._blur_regions_last_offset != null and current_offset >= self._blur_regions_last_offset.?) {
            self._blur_regions_offset = null;
            return msg;
        }
        if (self._blur_regions_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._blur_regions_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == LayerStateWire.BLUR_REGIONS_WIRE) {
                self._blur_regions_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._blur_regions_offset = null;
        return msg;
    }
    pub fn getWindowInfoHandle(self: *const LayerStateReader) gremlin.Error!LayerState.WindowInfoReader {
        if (self._window_info_handle_buf) |buf| {
            return try LayerState.WindowInfoReader.init(buf);
        }
        return try LayerState.WindowInfoReader.init(&[_]u8{});
    }
    pub inline fn getBgColorAlpha(self: *const LayerStateReader) f32 {
        return self._bg_color_alpha;
    }
    pub inline fn getBgColorDataspace(self: *const LayerStateReader) i32 {
        return self._bg_color_dataspace;
    }
    pub inline fn getColorSpaceAgnostic(self: *const LayerStateReader) bool {
        return self._color_space_agnostic;
    }
    pub inline fn getShadowRadius(self: *const LayerStateReader) f32 {
        return self._shadow_radius;
    }
    pub inline fn getFrameRateSelectionPriority(self: *const LayerStateReader) i32 {
        return self._frame_rate_selection_priority;
    }
    pub inline fn getFrameRate(self: *const LayerStateReader) f32 {
        return self._frame_rate;
    }
    pub inline fn getFrameRateCompatibility(self: *const LayerStateReader) i32 {
        return self._frame_rate_compatibility;
    }
    pub inline fn getChangeFrameRateStrategy(self: *const LayerStateReader) i32 {
        return self._change_frame_rate_strategy;
    }
    pub inline fn getFixedTransformHint(self: *const LayerStateReader) u32 {
        return self._fixed_transform_hint;
    }
    pub inline fn getFrameNumber(self: *const LayerStateReader) u64 {
        return self._frame_number;
    }
    pub inline fn getAutoRefresh(self: *const LayerStateReader) bool {
        return self._auto_refresh;
    }
    pub inline fn getIsTrustedOverlay(self: *const LayerStateReader) bool {
        return self._is_trusted_overlay;
    }
    pub fn getBufferCrop(self: *const LayerStateReader) gremlin.Error!rect.RectProtoReader {
        if (self._buffer_crop_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getDestinationFrame(self: *const LayerStateReader) gremlin.Error!rect.RectProtoReader {
        if (self._destination_frame_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub inline fn getDropInputMode(self: *const LayerStateReader) LayerState.DropInputMode {
        return self._drop_input_mode;
    }
    pub inline fn getTrustedOverlay(self: *const LayerStateReader) surfaceflinger_common.TrustedOverlay {
        return self._trusted_overlay;
    }
    pub inline fn getBackgroundBlurScale(self: *const LayerStateReader) f32 {
        return self._background_blur_scale;
    }
    pub fn getCornerRadii(self: *const LayerStateReader) gremlin.Error!LayerState.CornerRadiiReader {
        if (self._corner_radii_buf) |buf| {
            return try LayerState.CornerRadiiReader.init(buf);
        }
        return try LayerState.CornerRadiiReader.init(&[_]u8{});
    }
    pub fn getClientDrawnCornerRadii(self: *const LayerStateReader) gremlin.Error!LayerState.CornerRadiiReader {
        if (self._client_drawn_corner_radii_buf) |buf| {
            return try LayerState.CornerRadiiReader.init(buf);
        }
        return try LayerState.CornerRadiiReader.init(&[_]u8{});
    }
    pub inline fn getSystemContentPriority(self: *const LayerStateReader) i32 {
        return self._system_content_priority;
    }
    pub fn getBoxShadowSettings(self: *const LayerStateReader) gremlin.Error!surfaceflinger_common.BoxShadowSettingsReader {
        if (self._box_shadow_settings_buf) |buf| {
            return try surfaceflinger_common.BoxShadowSettingsReader.init(buf);
        }
        return try surfaceflinger_common.BoxShadowSettingsReader.init(&[_]u8{});
    }
    pub fn getBorderSettings(self: *const LayerStateReader) gremlin.Error!surfaceflinger_common.BorderSettingsReader {
        if (self._border_settings_buf) |buf| {
            return try surfaceflinger_common.BorderSettingsReader.init(buf);
        }
        return try surfaceflinger_common.BorderSettingsReader.init(&[_]u8{});
    }
};
const DisplayStateWire = struct {
    const ID_WIRE: gremlin.ProtoWireNumber = 1;
    const WHAT_WIRE: gremlin.ProtoWireNumber = 2;
    const FLAGS_WIRE: gremlin.ProtoWireNumber = 3;
    const LAYER_STACK_WIRE: gremlin.ProtoWireNumber = 4;
    const ORIENTATION_WIRE: gremlin.ProtoWireNumber = 5;
    const LAYER_STACK_SPACE_RECT_WIRE: gremlin.ProtoWireNumber = 6;
    const ORIENTED_DISPLAY_SPACE_RECT_WIRE: gremlin.ProtoWireNumber = 7;
    const WIDTH_WIRE: gremlin.ProtoWireNumber = 8;
    const HEIGHT_WIRE: gremlin.ProtoWireNumber = 9;
};
pub const DisplayState = struct {
    // nested enums
    pub const Changes = enum(i32) {
        E_CHANGES_NONE = 0,
        E_SURFACE_CHANGED = 1,
        E_LAYER_STACK_CHANGED = 2,
        E_DISPLAY_PROJECTION_CHANGED = 4,
        E_DISPLAY_SIZE_CHANGED = 8,
        E_FLAGS_CHANGED = 16,
    };
    // fields
    id: i32 = 0,
    what: u32 = 0,
    flags: u32 = 0,
    layer_stack: u32 = 0,
    orientation: u32 = 0,
    layer_stack_space_rect: ?rect.RectProto = null,
    oriented_display_space_rect: ?rect.RectProto = null,
    width: u32 = 0,
    height: u32 = 0,
    pub fn calcProtobufSize(self: *const DisplayState) usize {
        var res: usize = 0;
        if (self.id != 0) {
            res += gremlin.sizes.sizeWireNumber(DisplayStateWire.ID_WIRE) + gremlin.sizes.sizeI32(self.id);
        }
        if (self.what != 0) {
            res += gremlin.sizes.sizeWireNumber(DisplayStateWire.WHAT_WIRE) + gremlin.sizes.sizeU32(self.what);
        }
        if (self.flags != 0) {
            res += gremlin.sizes.sizeWireNumber(DisplayStateWire.FLAGS_WIRE) + gremlin.sizes.sizeU32(self.flags);
        }
        if (self.layer_stack != 0) {
            res += gremlin.sizes.sizeWireNumber(DisplayStateWire.LAYER_STACK_WIRE) + gremlin.sizes.sizeU32(self.layer_stack);
        }
        if (self.orientation != 0) {
            res += gremlin.sizes.sizeWireNumber(DisplayStateWire.ORIENTATION_WIRE) + gremlin.sizes.sizeU32(self.orientation);
        }
        if (self.layer_stack_space_rect) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DisplayStateWire.LAYER_STACK_SPACE_RECT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.oriented_display_space_rect) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DisplayStateWire.ORIENTED_DISPLAY_SPACE_RECT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.width != 0) {
            res += gremlin.sizes.sizeWireNumber(DisplayStateWire.WIDTH_WIRE) + gremlin.sizes.sizeU32(self.width);
        }
        if (self.height != 0) {
            res += gremlin.sizes.sizeWireNumber(DisplayStateWire.HEIGHT_WIRE) + gremlin.sizes.sizeU32(self.height);
        }
        return res;
    }
    pub fn encode(self: *const DisplayState, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const DisplayState, target: *gremlin.Writer) void {
        if (self.id != 0) {
            target.appendInt32(DisplayStateWire.ID_WIRE, self.id);
        }
        if (self.what != 0) {
            target.appendUint32(DisplayStateWire.WHAT_WIRE, self.what);
        }
        if (self.flags != 0) {
            target.appendUint32(DisplayStateWire.FLAGS_WIRE, self.flags);
        }
        if (self.layer_stack != 0) {
            target.appendUint32(DisplayStateWire.LAYER_STACK_WIRE, self.layer_stack);
        }
        if (self.orientation != 0) {
            target.appendUint32(DisplayStateWire.ORIENTATION_WIRE, self.orientation);
        }
        if (self.layer_stack_space_rect) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DisplayStateWire.LAYER_STACK_SPACE_RECT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.oriented_display_space_rect) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DisplayStateWire.ORIENTED_DISPLAY_SPACE_RECT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.width != 0) {
            target.appendUint32(DisplayStateWire.WIDTH_WIRE, self.width);
        }
        if (self.height != 0) {
            target.appendUint32(DisplayStateWire.HEIGHT_WIRE, self.height);
        }
    }
};
pub const DisplayStateReader = struct {
    buf: gremlin.Reader,
    _id: i32 = 0,
    _what: u32 = 0,
    _flags: u32 = 0,
    _layer_stack: u32 = 0,
    _orientation: u32 = 0,
    _layer_stack_space_rect_buf: ?[]const u8 = null,
    _oriented_display_space_rect_buf: ?[]const u8 = null,
    _width: u32 = 0,
    _height: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!DisplayStateReader {
        const buf = gremlin.Reader.init(src);
        var res = DisplayStateReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                DisplayStateWire.ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._id = result.value;
                },
                DisplayStateWire.WHAT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._what = result.value;
                },
                DisplayStateWire.FLAGS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._flags = result.value;
                },
                DisplayStateWire.LAYER_STACK_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._layer_stack = result.value;
                },
                DisplayStateWire.ORIENTATION_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._orientation = result.value;
                },
                DisplayStateWire.LAYER_STACK_SPACE_RECT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._layer_stack_space_rect_buf = result.value;
                },
                DisplayStateWire.ORIENTED_DISPLAY_SPACE_RECT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._oriented_display_space_rect_buf = result.value;
                },
                DisplayStateWire.WIDTH_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._width = result.value;
                },
                DisplayStateWire.HEIGHT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._height = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getId(self: *const DisplayStateReader) i32 {
        return self._id;
    }
    pub inline fn getWhat(self: *const DisplayStateReader) u32 {
        return self._what;
    }
    pub inline fn getFlags(self: *const DisplayStateReader) u32 {
        return self._flags;
    }
    pub inline fn getLayerStack(self: *const DisplayStateReader) u32 {
        return self._layer_stack;
    }
    pub inline fn getOrientation(self: *const DisplayStateReader) u32 {
        return self._orientation;
    }
    pub fn getLayerStackSpaceRect(self: *const DisplayStateReader) gremlin.Error!rect.RectProtoReader {
        if (self._layer_stack_space_rect_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getOrientedDisplaySpaceRect(self: *const DisplayStateReader) gremlin.Error!rect.RectProtoReader {
        if (self._oriented_display_space_rect_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub inline fn getWidth(self: *const DisplayStateReader) u32 {
        return self._width;
    }
    pub inline fn getHeight(self: *const DisplayStateReader) u32 {
        return self._height;
    }
};
