// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
const surfacecontrol = @import("surfacecontrol.proto.zig");
const rect = @import("src/gen/protos/perfetto/trace/android/graphics/rect.proto.zig");
const point = @import("src/gen/protos/perfetto/trace/android/graphics/point.proto.zig");
const window_configuration = @import("src/gen/protos/perfetto/trace/android/app/window_configuration.proto.zig");
// structs
const RemoteAnimationTargetProtoWire = struct {
    const TASK_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const MODE_WIRE: gremlin.ProtoWireNumber = 2;
    const LEASH_WIRE: gremlin.ProtoWireNumber = 3;
    const IS_TRANSLUCENT_WIRE: gremlin.ProtoWireNumber = 4;
    const CLIP_RECT_WIRE: gremlin.ProtoWireNumber = 5;
    const CONTENT_INSETS_WIRE: gremlin.ProtoWireNumber = 6;
    const PREFIX_ORDER_INDEX_WIRE: gremlin.ProtoWireNumber = 7;
    const POSITION_WIRE: gremlin.ProtoWireNumber = 8;
    const SOURCE_CONTAINER_BOUNDS_WIRE: gremlin.ProtoWireNumber = 9;
    const WINDOW_CONFIGURATION_WIRE: gremlin.ProtoWireNumber = 10;
    const START_LEASH_WIRE: gremlin.ProtoWireNumber = 11;
    const START_BOUNDS_WIRE: gremlin.ProtoWireNumber = 12;
    const LOCAL_BOUNDS_WIRE: gremlin.ProtoWireNumber = 13;
    const SCREEN_SPACE_BOUNDS_WIRE: gremlin.ProtoWireNumber = 14;
};
pub const RemoteAnimationTargetProto = struct {
    // fields
    task_id: i32 = 0,
    mode: i32 = 0,
    leash: ?surfacecontrol.SurfaceControlProto = null,
    is_translucent: bool = false,
    clip_rect: ?rect.RectProto = null,
    content_insets: ?rect.RectProto = null,
    prefix_order_index: i32 = 0,
    position: ?point.PointProto = null,
    source_container_bounds: ?rect.RectProto = null,
    window_configuration: ?window_configuration.WindowConfigurationProto = null,
    start_leash: ?surfacecontrol.SurfaceControlProto = null,
    start_bounds: ?rect.RectProto = null,
    local_bounds: ?rect.RectProto = null,
    screen_space_bounds: ?rect.RectProto = null,
    pub fn calcProtobufSize(self: *const RemoteAnimationTargetProto) usize {
        var res: usize = 0;
        if (self.task_id != 0) {
            res += gremlin.sizes.sizeWireNumber(RemoteAnimationTargetProtoWire.TASK_ID_WIRE) + gremlin.sizes.sizeI32(self.task_id);
        }
        if (self.mode != 0) {
            res += gremlin.sizes.sizeWireNumber(RemoteAnimationTargetProtoWire.MODE_WIRE) + gremlin.sizes.sizeI32(self.mode);
        }
        if (self.leash) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(RemoteAnimationTargetProtoWire.LEASH_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.is_translucent != false) {
            res += gremlin.sizes.sizeWireNumber(RemoteAnimationTargetProtoWire.IS_TRANSLUCENT_WIRE) + gremlin.sizes.sizeBool(self.is_translucent);
        }
        if (self.clip_rect) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(RemoteAnimationTargetProtoWire.CLIP_RECT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.content_insets) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(RemoteAnimationTargetProtoWire.CONTENT_INSETS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.prefix_order_index != 0) {
            res += gremlin.sizes.sizeWireNumber(RemoteAnimationTargetProtoWire.PREFIX_ORDER_INDEX_WIRE) + gremlin.sizes.sizeI32(self.prefix_order_index);
        }
        if (self.position) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(RemoteAnimationTargetProtoWire.POSITION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.source_container_bounds) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(RemoteAnimationTargetProtoWire.SOURCE_CONTAINER_BOUNDS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.window_configuration) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(RemoteAnimationTargetProtoWire.WINDOW_CONFIGURATION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.start_leash) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(RemoteAnimationTargetProtoWire.START_LEASH_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.start_bounds) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(RemoteAnimationTargetProtoWire.START_BOUNDS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.local_bounds) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(RemoteAnimationTargetProtoWire.LOCAL_BOUNDS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.screen_space_bounds) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(RemoteAnimationTargetProtoWire.SCREEN_SPACE_BOUNDS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const RemoteAnimationTargetProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const RemoteAnimationTargetProto, target: *gremlin.Writer) void {
        if (self.task_id != 0) {
            target.appendInt32(RemoteAnimationTargetProtoWire.TASK_ID_WIRE, self.task_id);
        }
        if (self.mode != 0) {
            target.appendInt32(RemoteAnimationTargetProtoWire.MODE_WIRE, self.mode);
        }
        if (self.leash) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(RemoteAnimationTargetProtoWire.LEASH_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.is_translucent != false) {
            target.appendBool(RemoteAnimationTargetProtoWire.IS_TRANSLUCENT_WIRE, self.is_translucent);
        }
        if (self.clip_rect) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(RemoteAnimationTargetProtoWire.CLIP_RECT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.content_insets) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(RemoteAnimationTargetProtoWire.CONTENT_INSETS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.prefix_order_index != 0) {
            target.appendInt32(RemoteAnimationTargetProtoWire.PREFIX_ORDER_INDEX_WIRE, self.prefix_order_index);
        }
        if (self.position) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(RemoteAnimationTargetProtoWire.POSITION_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.source_container_bounds) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(RemoteAnimationTargetProtoWire.SOURCE_CONTAINER_BOUNDS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.window_configuration) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(RemoteAnimationTargetProtoWire.WINDOW_CONFIGURATION_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.start_leash) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(RemoteAnimationTargetProtoWire.START_LEASH_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.start_bounds) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(RemoteAnimationTargetProtoWire.START_BOUNDS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.local_bounds) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(RemoteAnimationTargetProtoWire.LOCAL_BOUNDS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.screen_space_bounds) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(RemoteAnimationTargetProtoWire.SCREEN_SPACE_BOUNDS_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const RemoteAnimationTargetProtoReader = struct {
    buf: gremlin.Reader,
    _task_id: i32 = 0,
    _mode: i32 = 0,
    _leash_buf: ?[]const u8 = null,
    _is_translucent: bool = false,
    _clip_rect_buf: ?[]const u8 = null,
    _content_insets_buf: ?[]const u8 = null,
    _prefix_order_index: i32 = 0,
    _position_buf: ?[]const u8 = null,
    _source_container_bounds_buf: ?[]const u8 = null,
    _window_configuration_buf: ?[]const u8 = null,
    _start_leash_buf: ?[]const u8 = null,
    _start_bounds_buf: ?[]const u8 = null,
    _local_bounds_buf: ?[]const u8 = null,
    _screen_space_bounds_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!RemoteAnimationTargetProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = RemoteAnimationTargetProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                RemoteAnimationTargetProtoWire.TASK_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._task_id = result.value;
                },
                RemoteAnimationTargetProtoWire.MODE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._mode = result.value;
                },
                RemoteAnimationTargetProtoWire.LEASH_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._leash_buf = result.value;
                },
                RemoteAnimationTargetProtoWire.IS_TRANSLUCENT_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_translucent = result.value;
                },
                RemoteAnimationTargetProtoWire.CLIP_RECT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._clip_rect_buf = result.value;
                },
                RemoteAnimationTargetProtoWire.CONTENT_INSETS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._content_insets_buf = result.value;
                },
                RemoteAnimationTargetProtoWire.PREFIX_ORDER_INDEX_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._prefix_order_index = result.value;
                },
                RemoteAnimationTargetProtoWire.POSITION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._position_buf = result.value;
                },
                RemoteAnimationTargetProtoWire.SOURCE_CONTAINER_BOUNDS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._source_container_bounds_buf = result.value;
                },
                RemoteAnimationTargetProtoWire.WINDOW_CONFIGURATION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._window_configuration_buf = result.value;
                },
                RemoteAnimationTargetProtoWire.START_LEASH_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._start_leash_buf = result.value;
                },
                RemoteAnimationTargetProtoWire.START_BOUNDS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._start_bounds_buf = result.value;
                },
                RemoteAnimationTargetProtoWire.LOCAL_BOUNDS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._local_bounds_buf = result.value;
                },
                RemoteAnimationTargetProtoWire.SCREEN_SPACE_BOUNDS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._screen_space_bounds_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getTaskId(self: *const RemoteAnimationTargetProtoReader) i32 {
        return self._task_id;
    }
    pub inline fn getMode(self: *const RemoteAnimationTargetProtoReader) i32 {
        return self._mode;
    }
    pub fn getLeash(self: *const RemoteAnimationTargetProtoReader) gremlin.Error!surfacecontrol.SurfaceControlProtoReader {
        if (self._leash_buf) |buf| {
            return try surfacecontrol.SurfaceControlProtoReader.init(buf);
        }
        return try surfacecontrol.SurfaceControlProtoReader.init(&[_]u8{});
    }
    pub inline fn getIsTranslucent(self: *const RemoteAnimationTargetProtoReader) bool {
        return self._is_translucent;
    }
    pub fn getClipRect(self: *const RemoteAnimationTargetProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._clip_rect_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getContentInsets(self: *const RemoteAnimationTargetProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._content_insets_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub inline fn getPrefixOrderIndex(self: *const RemoteAnimationTargetProtoReader) i32 {
        return self._prefix_order_index;
    }
    pub fn getPosition(self: *const RemoteAnimationTargetProtoReader) gremlin.Error!point.PointProtoReader {
        if (self._position_buf) |buf| {
            return try point.PointProtoReader.init(buf);
        }
        return try point.PointProtoReader.init(&[_]u8{});
    }
    pub fn getSourceContainerBounds(self: *const RemoteAnimationTargetProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._source_container_bounds_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getWindowConfiguration(self: *const RemoteAnimationTargetProtoReader) gremlin.Error!window_configuration.WindowConfigurationProtoReader {
        if (self._window_configuration_buf) |buf| {
            return try window_configuration.WindowConfigurationProtoReader.init(buf);
        }
        return try window_configuration.WindowConfigurationProtoReader.init(&[_]u8{});
    }
    pub fn getStartLeash(self: *const RemoteAnimationTargetProtoReader) gremlin.Error!surfacecontrol.SurfaceControlProtoReader {
        if (self._start_leash_buf) |buf| {
            return try surfacecontrol.SurfaceControlProtoReader.init(buf);
        }
        return try surfacecontrol.SurfaceControlProtoReader.init(&[_]u8{});
    }
    pub fn getStartBounds(self: *const RemoteAnimationTargetProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._start_bounds_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getLocalBounds(self: *const RemoteAnimationTargetProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._local_bounds_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getScreenSpaceBounds(self: *const RemoteAnimationTargetProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._screen_space_bounds_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
};
