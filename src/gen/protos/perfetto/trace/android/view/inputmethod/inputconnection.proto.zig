// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const InputConnectionProtoWire = struct {
    const SELECTED_TEXT_START_WIRE: gremlin.ProtoWireNumber = 3;
    const SELECTED_TEXT_END_WIRE: gremlin.ProtoWireNumber = 4;
    const CURSOR_CAPS_MODE_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const InputConnectionProto = struct {
    // fields
    selected_text_start: i32 = 0,
    selected_text_end: i32 = 0,
    cursor_caps_mode: i32 = 0,
    pub fn calcProtobufSize(self: *const InputConnectionProto) usize {
        var res: usize = 0;
        if (self.selected_text_start != 0) {
            res += gremlin.sizes.sizeWireNumber(InputConnectionProtoWire.SELECTED_TEXT_START_WIRE) + gremlin.sizes.sizeI32(self.selected_text_start);
        }
        if (self.selected_text_end != 0) {
            res += gremlin.sizes.sizeWireNumber(InputConnectionProtoWire.SELECTED_TEXT_END_WIRE) + gremlin.sizes.sizeI32(self.selected_text_end);
        }
        if (self.cursor_caps_mode != 0) {
            res += gremlin.sizes.sizeWireNumber(InputConnectionProtoWire.CURSOR_CAPS_MODE_WIRE) + gremlin.sizes.sizeI32(self.cursor_caps_mode);
        }
        return res;
    }
    pub fn encode(self: *const InputConnectionProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const InputConnectionProto, target: *gremlin.Writer) void {
        if (self.selected_text_start != 0) {
            target.appendInt32(InputConnectionProtoWire.SELECTED_TEXT_START_WIRE, self.selected_text_start);
        }
        if (self.selected_text_end != 0) {
            target.appendInt32(InputConnectionProtoWire.SELECTED_TEXT_END_WIRE, self.selected_text_end);
        }
        if (self.cursor_caps_mode != 0) {
            target.appendInt32(InputConnectionProtoWire.CURSOR_CAPS_MODE_WIRE, self.cursor_caps_mode);
        }
    }
};
pub const InputConnectionProtoReader = struct {
    buf: gremlin.Reader,
    _selected_text_start: i32 = 0,
    _selected_text_end: i32 = 0,
    _cursor_caps_mode: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!InputConnectionProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = InputConnectionProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                InputConnectionProtoWire.SELECTED_TEXT_START_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._selected_text_start = result.value;
                },
                InputConnectionProtoWire.SELECTED_TEXT_END_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._selected_text_end = result.value;
                },
                InputConnectionProtoWire.CURSOR_CAPS_MODE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._cursor_caps_mode = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getSelectedTextStart(self: *const InputConnectionProtoReader) i32 {
        return self._selected_text_start;
    }
    pub inline fn getSelectedTextEnd(self: *const InputConnectionProtoReader) i32 {
        return self._selected_text_end;
    }
    pub inline fn getCursorCapsMode(self: *const InputConnectionProtoReader) i32 {
        return self._cursor_caps_mode;
    }
};
const InputConnectionCallProtoWire = struct {
    const GET_TEXT_BEFORE_CURSOR_WIRE: gremlin.ProtoWireNumber = 1;
    const GET_TEXT_AFTER_CURSOR_WIRE: gremlin.ProtoWireNumber = 2;
    const GET_SELECTED_TEXT_WIRE: gremlin.ProtoWireNumber = 3;
    const GET_SURROUNDING_TEXT_WIRE: gremlin.ProtoWireNumber = 4;
    const GET_CURSOR_CAPS_MODE_WIRE: gremlin.ProtoWireNumber = 5;
    const GET_EXTRACTED_TEXT_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const InputConnectionCallProto = struct {
    // nested structs
    const GetTextBeforeCursorWire = struct {
        const LENGTH_WIRE: gremlin.ProtoWireNumber = 1;
        const FLAGS_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const GetTextBeforeCursor = struct {
        // fields
        length: i32 = 0,
        flags: i32 = 0,
        pub fn calcProtobufSize(self: *const InputConnectionCallProto.GetTextBeforeCursor) usize {
            var res: usize = 0;
            if (self.length != 0) {
                res += gremlin.sizes.sizeWireNumber(InputConnectionCallProto.GetTextBeforeCursorWire.LENGTH_WIRE) + gremlin.sizes.sizeI32(self.length);
            }
            if (self.flags != 0) {
                res += gremlin.sizes.sizeWireNumber(InputConnectionCallProto.GetTextBeforeCursorWire.FLAGS_WIRE) + gremlin.sizes.sizeI32(self.flags);
            }
            return res;
        }
        pub fn encode(self: *const InputConnectionCallProto.GetTextBeforeCursor, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const InputConnectionCallProto.GetTextBeforeCursor, target: *gremlin.Writer) void {
            if (self.length != 0) {
                target.appendInt32(InputConnectionCallProto.GetTextBeforeCursorWire.LENGTH_WIRE, self.length);
            }
            if (self.flags != 0) {
                target.appendInt32(InputConnectionCallProto.GetTextBeforeCursorWire.FLAGS_WIRE, self.flags);
            }
        }
    };
    pub const GetTextBeforeCursorReader = struct {
        buf: gremlin.Reader,
        _length: i32 = 0,
        _flags: i32 = 0,
        pub fn init(src: []const u8) gremlin.Error!InputConnectionCallProto.GetTextBeforeCursorReader {
            const buf = gremlin.Reader.init(src);
            var res = InputConnectionCallProto.GetTextBeforeCursorReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    InputConnectionCallProto.GetTextBeforeCursorWire.LENGTH_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._length = result.value;
                    },
                    InputConnectionCallProto.GetTextBeforeCursorWire.FLAGS_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._flags = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getLength(self: *const InputConnectionCallProto.GetTextBeforeCursorReader) i32 {
            return self._length;
        }
        pub inline fn getFlags(self: *const InputConnectionCallProto.GetTextBeforeCursorReader) i32 {
            return self._flags;
        }
    };
    const GetTextAfterCursorWire = struct {
        const LENGTH_WIRE: gremlin.ProtoWireNumber = 1;
        const FLAGS_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const GetTextAfterCursor = struct {
        // fields
        length: i32 = 0,
        flags: i32 = 0,
        pub fn calcProtobufSize(self: *const InputConnectionCallProto.GetTextAfterCursor) usize {
            var res: usize = 0;
            if (self.length != 0) {
                res += gremlin.sizes.sizeWireNumber(InputConnectionCallProto.GetTextAfterCursorWire.LENGTH_WIRE) + gremlin.sizes.sizeI32(self.length);
            }
            if (self.flags != 0) {
                res += gremlin.sizes.sizeWireNumber(InputConnectionCallProto.GetTextAfterCursorWire.FLAGS_WIRE) + gremlin.sizes.sizeI32(self.flags);
            }
            return res;
        }
        pub fn encode(self: *const InputConnectionCallProto.GetTextAfterCursor, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const InputConnectionCallProto.GetTextAfterCursor, target: *gremlin.Writer) void {
            if (self.length != 0) {
                target.appendInt32(InputConnectionCallProto.GetTextAfterCursorWire.LENGTH_WIRE, self.length);
            }
            if (self.flags != 0) {
                target.appendInt32(InputConnectionCallProto.GetTextAfterCursorWire.FLAGS_WIRE, self.flags);
            }
        }
    };
    pub const GetTextAfterCursorReader = struct {
        buf: gremlin.Reader,
        _length: i32 = 0,
        _flags: i32 = 0,
        pub fn init(src: []const u8) gremlin.Error!InputConnectionCallProto.GetTextAfterCursorReader {
            const buf = gremlin.Reader.init(src);
            var res = InputConnectionCallProto.GetTextAfterCursorReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    InputConnectionCallProto.GetTextAfterCursorWire.LENGTH_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._length = result.value;
                    },
                    InputConnectionCallProto.GetTextAfterCursorWire.FLAGS_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._flags = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getLength(self: *const InputConnectionCallProto.GetTextAfterCursorReader) i32 {
            return self._length;
        }
        pub inline fn getFlags(self: *const InputConnectionCallProto.GetTextAfterCursorReader) i32 {
            return self._flags;
        }
    };
    const GetSelectedTextWire = struct {
        const FLAGS_WIRE: gremlin.ProtoWireNumber = 1;
    };
    pub const GetSelectedText = struct {
        // fields
        flags: i32 = 0,
        pub fn calcProtobufSize(self: *const InputConnectionCallProto.GetSelectedText) usize {
            var res: usize = 0;
            if (self.flags != 0) {
                res += gremlin.sizes.sizeWireNumber(InputConnectionCallProto.GetSelectedTextWire.FLAGS_WIRE) + gremlin.sizes.sizeI32(self.flags);
            }
            return res;
        }
        pub fn encode(self: *const InputConnectionCallProto.GetSelectedText, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const InputConnectionCallProto.GetSelectedText, target: *gremlin.Writer) void {
            if (self.flags != 0) {
                target.appendInt32(InputConnectionCallProto.GetSelectedTextWire.FLAGS_WIRE, self.flags);
            }
        }
    };
    pub const GetSelectedTextReader = struct {
        buf: gremlin.Reader,
        _flags: i32 = 0,
        pub fn init(src: []const u8) gremlin.Error!InputConnectionCallProto.GetSelectedTextReader {
            const buf = gremlin.Reader.init(src);
            var res = InputConnectionCallProto.GetSelectedTextReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    InputConnectionCallProto.GetSelectedTextWire.FLAGS_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._flags = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getFlags(self: *const InputConnectionCallProto.GetSelectedTextReader) i32 {
            return self._flags;
        }
    };
    const GetSurroundingTextWire = struct {
        const BEFORE_LENGTH_WIRE: gremlin.ProtoWireNumber = 1;
        const AFTER_LENGTH_WIRE: gremlin.ProtoWireNumber = 2;
        const FLAGS_WIRE: gremlin.ProtoWireNumber = 3;
        const RESULT_WIRE: gremlin.ProtoWireNumber = 4;
    };
    pub const GetSurroundingText = struct {
        // nested structs
        const SurroundingTextWire = struct {
            const SELECTION_START_WIRE: gremlin.ProtoWireNumber = 2;
            const SELECTION_END_WIRE: gremlin.ProtoWireNumber = 3;
            const OFFSET_WIRE: gremlin.ProtoWireNumber = 4;
        };
        pub const SurroundingText = struct {
            // fields
            selection_start: i32 = 0,
            selection_end: i32 = 0,
            offset: i32 = 0,
            pub fn calcProtobufSize(self: *const InputConnectionCallProto.GetSurroundingText.SurroundingText) usize {
                var res: usize = 0;
                if (self.selection_start != 0) {
                    res += gremlin.sizes.sizeWireNumber(InputConnectionCallProto.GetSurroundingText.SurroundingTextWire.SELECTION_START_WIRE) + gremlin.sizes.sizeI32(self.selection_start);
                }
                if (self.selection_end != 0) {
                    res += gremlin.sizes.sizeWireNumber(InputConnectionCallProto.GetSurroundingText.SurroundingTextWire.SELECTION_END_WIRE) + gremlin.sizes.sizeI32(self.selection_end);
                }
                if (self.offset != 0) {
                    res += gremlin.sizes.sizeWireNumber(InputConnectionCallProto.GetSurroundingText.SurroundingTextWire.OFFSET_WIRE) + gremlin.sizes.sizeI32(self.offset);
                }
                return res;
            }
            pub fn encode(self: *const InputConnectionCallProto.GetSurroundingText.SurroundingText, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const InputConnectionCallProto.GetSurroundingText.SurroundingText, target: *gremlin.Writer) void {
                if (self.selection_start != 0) {
                    target.appendInt32(InputConnectionCallProto.GetSurroundingText.SurroundingTextWire.SELECTION_START_WIRE, self.selection_start);
                }
                if (self.selection_end != 0) {
                    target.appendInt32(InputConnectionCallProto.GetSurroundingText.SurroundingTextWire.SELECTION_END_WIRE, self.selection_end);
                }
                if (self.offset != 0) {
                    target.appendInt32(InputConnectionCallProto.GetSurroundingText.SurroundingTextWire.OFFSET_WIRE, self.offset);
                }
            }
        };
        pub const SurroundingTextReader = struct {
            buf: gremlin.Reader,
            _selection_start: i32 = 0,
            _selection_end: i32 = 0,
            _offset: i32 = 0,
            pub fn init(src: []const u8) gremlin.Error!InputConnectionCallProto.GetSurroundingText.SurroundingTextReader {
                const buf = gremlin.Reader.init(src);
                var res = InputConnectionCallProto.GetSurroundingText.SurroundingTextReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        InputConnectionCallProto.GetSurroundingText.SurroundingTextWire.SELECTION_START_WIRE => {
                            const result = try buf.readInt32(offset);
                            offset += result.size;
                            res._selection_start = result.value;
                        },
                        InputConnectionCallProto.GetSurroundingText.SurroundingTextWire.SELECTION_END_WIRE => {
                            const result = try buf.readInt32(offset);
                            offset += result.size;
                            res._selection_end = result.value;
                        },
                        InputConnectionCallProto.GetSurroundingText.SurroundingTextWire.OFFSET_WIRE => {
                            const result = try buf.readInt32(offset);
                            offset += result.size;
                            res._offset = result.value;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub inline fn getSelectionStart(self: *const InputConnectionCallProto.GetSurroundingText.SurroundingTextReader) i32 {
                return self._selection_start;
            }
            pub inline fn getSelectionEnd(self: *const InputConnectionCallProto.GetSurroundingText.SurroundingTextReader) i32 {
                return self._selection_end;
            }
            pub inline fn getOffset(self: *const InputConnectionCallProto.GetSurroundingText.SurroundingTextReader) i32 {
                return self._offset;
            }
        };
        // fields
        before_length: i32 = 0,
        after_length: i32 = 0,
        flags: i32 = 0,
        result: ?InputConnectionCallProto.GetSurroundingText.SurroundingText = null,
        pub fn calcProtobufSize(self: *const InputConnectionCallProto.GetSurroundingText) usize {
            var res: usize = 0;
            if (self.before_length != 0) {
                res += gremlin.sizes.sizeWireNumber(InputConnectionCallProto.GetSurroundingTextWire.BEFORE_LENGTH_WIRE) + gremlin.sizes.sizeI32(self.before_length);
            }
            if (self.after_length != 0) {
                res += gremlin.sizes.sizeWireNumber(InputConnectionCallProto.GetSurroundingTextWire.AFTER_LENGTH_WIRE) + gremlin.sizes.sizeI32(self.after_length);
            }
            if (self.flags != 0) {
                res += gremlin.sizes.sizeWireNumber(InputConnectionCallProto.GetSurroundingTextWire.FLAGS_WIRE) + gremlin.sizes.sizeI32(self.flags);
            }
            if (self.result) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(InputConnectionCallProto.GetSurroundingTextWire.RESULT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            return res;
        }
        pub fn encode(self: *const InputConnectionCallProto.GetSurroundingText, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const InputConnectionCallProto.GetSurroundingText, target: *gremlin.Writer) void {
            if (self.before_length != 0) {
                target.appendInt32(InputConnectionCallProto.GetSurroundingTextWire.BEFORE_LENGTH_WIRE, self.before_length);
            }
            if (self.after_length != 0) {
                target.appendInt32(InputConnectionCallProto.GetSurroundingTextWire.AFTER_LENGTH_WIRE, self.after_length);
            }
            if (self.flags != 0) {
                target.appendInt32(InputConnectionCallProto.GetSurroundingTextWire.FLAGS_WIRE, self.flags);
            }
            if (self.result) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(InputConnectionCallProto.GetSurroundingTextWire.RESULT_WIRE, size);
                    v.encodeTo(target);
                }
            }
        }
    };
    pub const GetSurroundingTextReader = struct {
        buf: gremlin.Reader,
        _before_length: i32 = 0,
        _after_length: i32 = 0,
        _flags: i32 = 0,
        _result_buf: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!InputConnectionCallProto.GetSurroundingTextReader {
            const buf = gremlin.Reader.init(src);
            var res = InputConnectionCallProto.GetSurroundingTextReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    InputConnectionCallProto.GetSurroundingTextWire.BEFORE_LENGTH_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._before_length = result.value;
                    },
                    InputConnectionCallProto.GetSurroundingTextWire.AFTER_LENGTH_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._after_length = result.value;
                    },
                    InputConnectionCallProto.GetSurroundingTextWire.FLAGS_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._flags = result.value;
                    },
                    InputConnectionCallProto.GetSurroundingTextWire.RESULT_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._result_buf = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getBeforeLength(self: *const InputConnectionCallProto.GetSurroundingTextReader) i32 {
            return self._before_length;
        }
        pub inline fn getAfterLength(self: *const InputConnectionCallProto.GetSurroundingTextReader) i32 {
            return self._after_length;
        }
        pub inline fn getFlags(self: *const InputConnectionCallProto.GetSurroundingTextReader) i32 {
            return self._flags;
        }
        pub fn getResult(self: *const InputConnectionCallProto.GetSurroundingTextReader) gremlin.Error!InputConnectionCallProto.GetSurroundingText.SurroundingTextReader {
            if (self._result_buf) |buf| {
                return try InputConnectionCallProto.GetSurroundingText.SurroundingTextReader.init(buf);
            }
            return try InputConnectionCallProto.GetSurroundingText.SurroundingTextReader.init(&[_]u8{});
        }
    };
    const GetCursorCapsModeWire = struct {
        const REQ_MODES_WIRE: gremlin.ProtoWireNumber = 1;
        const RESULT_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const GetCursorCapsMode = struct {
        // fields
        req_modes: i32 = 0,
        result: i32 = 0,
        pub fn calcProtobufSize(self: *const InputConnectionCallProto.GetCursorCapsMode) usize {
            var res: usize = 0;
            if (self.req_modes != 0) {
                res += gremlin.sizes.sizeWireNumber(InputConnectionCallProto.GetCursorCapsModeWire.REQ_MODES_WIRE) + gremlin.sizes.sizeI32(self.req_modes);
            }
            if (self.result != 0) {
                res += gremlin.sizes.sizeWireNumber(InputConnectionCallProto.GetCursorCapsModeWire.RESULT_WIRE) + gremlin.sizes.sizeI32(self.result);
            }
            return res;
        }
        pub fn encode(self: *const InputConnectionCallProto.GetCursorCapsMode, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const InputConnectionCallProto.GetCursorCapsMode, target: *gremlin.Writer) void {
            if (self.req_modes != 0) {
                target.appendInt32(InputConnectionCallProto.GetCursorCapsModeWire.REQ_MODES_WIRE, self.req_modes);
            }
            if (self.result != 0) {
                target.appendInt32(InputConnectionCallProto.GetCursorCapsModeWire.RESULT_WIRE, self.result);
            }
        }
    };
    pub const GetCursorCapsModeReader = struct {
        buf: gremlin.Reader,
        _req_modes: i32 = 0,
        _result: i32 = 0,
        pub fn init(src: []const u8) gremlin.Error!InputConnectionCallProto.GetCursorCapsModeReader {
            const buf = gremlin.Reader.init(src);
            var res = InputConnectionCallProto.GetCursorCapsModeReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    InputConnectionCallProto.GetCursorCapsModeWire.REQ_MODES_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._req_modes = result.value;
                    },
                    InputConnectionCallProto.GetCursorCapsModeWire.RESULT_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._result = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getReqModes(self: *const InputConnectionCallProto.GetCursorCapsModeReader) i32 {
            return self._req_modes;
        }
        pub inline fn getResult(self: *const InputConnectionCallProto.GetCursorCapsModeReader) i32 {
            return self._result;
        }
    };
    const GetExtractedTextWire = struct {
        const REQUEST_WIRE: gremlin.ProtoWireNumber = 1;
        const FLAGS_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const GetExtractedText = struct {
        // nested structs
        const ExtractedTextRequestWire = struct {
            const TOKEN_WIRE: gremlin.ProtoWireNumber = 1;
            const FLAGS_WIRE: gremlin.ProtoWireNumber = 2;
            const HINT_MAX_LINES_WIRE: gremlin.ProtoWireNumber = 3;
            const HINT_MAX_CHARS_WIRE: gremlin.ProtoWireNumber = 4;
        };
        pub const ExtractedTextRequest = struct {
            // fields
            token: i32 = 0,
            flags: i32 = 0,
            hint_max_lines: i32 = 0,
            hint_max_chars: i32 = 0,
            pub fn calcProtobufSize(self: *const InputConnectionCallProto.GetExtractedText.ExtractedTextRequest) usize {
                var res: usize = 0;
                if (self.token != 0) {
                    res += gremlin.sizes.sizeWireNumber(InputConnectionCallProto.GetExtractedText.ExtractedTextRequestWire.TOKEN_WIRE) + gremlin.sizes.sizeI32(self.token);
                }
                if (self.flags != 0) {
                    res += gremlin.sizes.sizeWireNumber(InputConnectionCallProto.GetExtractedText.ExtractedTextRequestWire.FLAGS_WIRE) + gremlin.sizes.sizeI32(self.flags);
                }
                if (self.hint_max_lines != 0) {
                    res += gremlin.sizes.sizeWireNumber(InputConnectionCallProto.GetExtractedText.ExtractedTextRequestWire.HINT_MAX_LINES_WIRE) + gremlin.sizes.sizeI32(self.hint_max_lines);
                }
                if (self.hint_max_chars != 0) {
                    res += gremlin.sizes.sizeWireNumber(InputConnectionCallProto.GetExtractedText.ExtractedTextRequestWire.HINT_MAX_CHARS_WIRE) + gremlin.sizes.sizeI32(self.hint_max_chars);
                }
                return res;
            }
            pub fn encode(self: *const InputConnectionCallProto.GetExtractedText.ExtractedTextRequest, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const InputConnectionCallProto.GetExtractedText.ExtractedTextRequest, target: *gremlin.Writer) void {
                if (self.token != 0) {
                    target.appendInt32(InputConnectionCallProto.GetExtractedText.ExtractedTextRequestWire.TOKEN_WIRE, self.token);
                }
                if (self.flags != 0) {
                    target.appendInt32(InputConnectionCallProto.GetExtractedText.ExtractedTextRequestWire.FLAGS_WIRE, self.flags);
                }
                if (self.hint_max_lines != 0) {
                    target.appendInt32(InputConnectionCallProto.GetExtractedText.ExtractedTextRequestWire.HINT_MAX_LINES_WIRE, self.hint_max_lines);
                }
                if (self.hint_max_chars != 0) {
                    target.appendInt32(InputConnectionCallProto.GetExtractedText.ExtractedTextRequestWire.HINT_MAX_CHARS_WIRE, self.hint_max_chars);
                }
            }
        };
        pub const ExtractedTextRequestReader = struct {
            buf: gremlin.Reader,
            _token: i32 = 0,
            _flags: i32 = 0,
            _hint_max_lines: i32 = 0,
            _hint_max_chars: i32 = 0,
            pub fn init(src: []const u8) gremlin.Error!InputConnectionCallProto.GetExtractedText.ExtractedTextRequestReader {
                const buf = gremlin.Reader.init(src);
                var res = InputConnectionCallProto.GetExtractedText.ExtractedTextRequestReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        InputConnectionCallProto.GetExtractedText.ExtractedTextRequestWire.TOKEN_WIRE => {
                            const result = try buf.readInt32(offset);
                            offset += result.size;
                            res._token = result.value;
                        },
                        InputConnectionCallProto.GetExtractedText.ExtractedTextRequestWire.FLAGS_WIRE => {
                            const result = try buf.readInt32(offset);
                            offset += result.size;
                            res._flags = result.value;
                        },
                        InputConnectionCallProto.GetExtractedText.ExtractedTextRequestWire.HINT_MAX_LINES_WIRE => {
                            const result = try buf.readInt32(offset);
                            offset += result.size;
                            res._hint_max_lines = result.value;
                        },
                        InputConnectionCallProto.GetExtractedText.ExtractedTextRequestWire.HINT_MAX_CHARS_WIRE => {
                            const result = try buf.readInt32(offset);
                            offset += result.size;
                            res._hint_max_chars = result.value;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub inline fn getToken(self: *const InputConnectionCallProto.GetExtractedText.ExtractedTextRequestReader) i32 {
                return self._token;
            }
            pub inline fn getFlags(self: *const InputConnectionCallProto.GetExtractedText.ExtractedTextRequestReader) i32 {
                return self._flags;
            }
            pub inline fn getHintMaxLines(self: *const InputConnectionCallProto.GetExtractedText.ExtractedTextRequestReader) i32 {
                return self._hint_max_lines;
            }
            pub inline fn getHintMaxChars(self: *const InputConnectionCallProto.GetExtractedText.ExtractedTextRequestReader) i32 {
                return self._hint_max_chars;
            }
        };
        // fields
        request: ?InputConnectionCallProto.GetExtractedText.ExtractedTextRequest = null,
        flags: i32 = 0,
        pub fn calcProtobufSize(self: *const InputConnectionCallProto.GetExtractedText) usize {
            var res: usize = 0;
            if (self.request) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(InputConnectionCallProto.GetExtractedTextWire.REQUEST_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.flags != 0) {
                res += gremlin.sizes.sizeWireNumber(InputConnectionCallProto.GetExtractedTextWire.FLAGS_WIRE) + gremlin.sizes.sizeI32(self.flags);
            }
            return res;
        }
        pub fn encode(self: *const InputConnectionCallProto.GetExtractedText, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const InputConnectionCallProto.GetExtractedText, target: *gremlin.Writer) void {
            if (self.request) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(InputConnectionCallProto.GetExtractedTextWire.REQUEST_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.flags != 0) {
                target.appendInt32(InputConnectionCallProto.GetExtractedTextWire.FLAGS_WIRE, self.flags);
            }
        }
    };
    pub const GetExtractedTextReader = struct {
        buf: gremlin.Reader,
        _request_buf: ?[]const u8 = null,
        _flags: i32 = 0,
        pub fn init(src: []const u8) gremlin.Error!InputConnectionCallProto.GetExtractedTextReader {
            const buf = gremlin.Reader.init(src);
            var res = InputConnectionCallProto.GetExtractedTextReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    InputConnectionCallProto.GetExtractedTextWire.REQUEST_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._request_buf = result.value;
                    },
                    InputConnectionCallProto.GetExtractedTextWire.FLAGS_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._flags = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn getRequest(self: *const InputConnectionCallProto.GetExtractedTextReader) gremlin.Error!InputConnectionCallProto.GetExtractedText.ExtractedTextRequestReader {
            if (self._request_buf) |buf| {
                return try InputConnectionCallProto.GetExtractedText.ExtractedTextRequestReader.init(buf);
            }
            return try InputConnectionCallProto.GetExtractedText.ExtractedTextRequestReader.init(&[_]u8{});
        }
        pub inline fn getFlags(self: *const InputConnectionCallProto.GetExtractedTextReader) i32 {
            return self._flags;
        }
    };
    // fields
    get_text_before_cursor: ?InputConnectionCallProto.GetTextBeforeCursor = null,
    get_text_after_cursor: ?InputConnectionCallProto.GetTextAfterCursor = null,
    get_selected_text: ?InputConnectionCallProto.GetSelectedText = null,
    get_surrounding_text: ?InputConnectionCallProto.GetSurroundingText = null,
    get_cursor_caps_mode: ?InputConnectionCallProto.GetCursorCapsMode = null,
    get_extracted_text: ?InputConnectionCallProto.GetExtractedText = null,
    pub fn calcProtobufSize(self: *const InputConnectionCallProto) usize {
        var res: usize = 0;
        if (self.get_text_before_cursor) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(InputConnectionCallProtoWire.GET_TEXT_BEFORE_CURSOR_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.get_text_after_cursor) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(InputConnectionCallProtoWire.GET_TEXT_AFTER_CURSOR_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.get_selected_text) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(InputConnectionCallProtoWire.GET_SELECTED_TEXT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.get_surrounding_text) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(InputConnectionCallProtoWire.GET_SURROUNDING_TEXT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.get_cursor_caps_mode) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(InputConnectionCallProtoWire.GET_CURSOR_CAPS_MODE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.get_extracted_text) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(InputConnectionCallProtoWire.GET_EXTRACTED_TEXT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const InputConnectionCallProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const InputConnectionCallProto, target: *gremlin.Writer) void {
        if (self.get_text_before_cursor) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(InputConnectionCallProtoWire.GET_TEXT_BEFORE_CURSOR_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.get_text_after_cursor) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(InputConnectionCallProtoWire.GET_TEXT_AFTER_CURSOR_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.get_selected_text) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(InputConnectionCallProtoWire.GET_SELECTED_TEXT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.get_surrounding_text) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(InputConnectionCallProtoWire.GET_SURROUNDING_TEXT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.get_cursor_caps_mode) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(InputConnectionCallProtoWire.GET_CURSOR_CAPS_MODE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.get_extracted_text) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(InputConnectionCallProtoWire.GET_EXTRACTED_TEXT_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const InputConnectionCallProtoReader = struct {
    buf: gremlin.Reader,
    _get_text_before_cursor_buf: ?[]const u8 = null,
    _get_text_after_cursor_buf: ?[]const u8 = null,
    _get_selected_text_buf: ?[]const u8 = null,
    _get_surrounding_text_buf: ?[]const u8 = null,
    _get_cursor_caps_mode_buf: ?[]const u8 = null,
    _get_extracted_text_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!InputConnectionCallProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = InputConnectionCallProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                InputConnectionCallProtoWire.GET_TEXT_BEFORE_CURSOR_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._get_text_before_cursor_buf = result.value;
                },
                InputConnectionCallProtoWire.GET_TEXT_AFTER_CURSOR_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._get_text_after_cursor_buf = result.value;
                },
                InputConnectionCallProtoWire.GET_SELECTED_TEXT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._get_selected_text_buf = result.value;
                },
                InputConnectionCallProtoWire.GET_SURROUNDING_TEXT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._get_surrounding_text_buf = result.value;
                },
                InputConnectionCallProtoWire.GET_CURSOR_CAPS_MODE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._get_cursor_caps_mode_buf = result.value;
                },
                InputConnectionCallProtoWire.GET_EXTRACTED_TEXT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._get_extracted_text_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getGetTextBeforeCursor(self: *const InputConnectionCallProtoReader) gremlin.Error!InputConnectionCallProto.GetTextBeforeCursorReader {
        if (self._get_text_before_cursor_buf) |buf| {
            return try InputConnectionCallProto.GetTextBeforeCursorReader.init(buf);
        }
        return try InputConnectionCallProto.GetTextBeforeCursorReader.init(&[_]u8{});
    }
    pub fn getGetTextAfterCursor(self: *const InputConnectionCallProtoReader) gremlin.Error!InputConnectionCallProto.GetTextAfterCursorReader {
        if (self._get_text_after_cursor_buf) |buf| {
            return try InputConnectionCallProto.GetTextAfterCursorReader.init(buf);
        }
        return try InputConnectionCallProto.GetTextAfterCursorReader.init(&[_]u8{});
    }
    pub fn getGetSelectedText(self: *const InputConnectionCallProtoReader) gremlin.Error!InputConnectionCallProto.GetSelectedTextReader {
        if (self._get_selected_text_buf) |buf| {
            return try InputConnectionCallProto.GetSelectedTextReader.init(buf);
        }
        return try InputConnectionCallProto.GetSelectedTextReader.init(&[_]u8{});
    }
    pub fn getGetSurroundingText(self: *const InputConnectionCallProtoReader) gremlin.Error!InputConnectionCallProto.GetSurroundingTextReader {
        if (self._get_surrounding_text_buf) |buf| {
            return try InputConnectionCallProto.GetSurroundingTextReader.init(buf);
        }
        return try InputConnectionCallProto.GetSurroundingTextReader.init(&[_]u8{});
    }
    pub fn getGetCursorCapsMode(self: *const InputConnectionCallProtoReader) gremlin.Error!InputConnectionCallProto.GetCursorCapsModeReader {
        if (self._get_cursor_caps_mode_buf) |buf| {
            return try InputConnectionCallProto.GetCursorCapsModeReader.init(buf);
        }
        return try InputConnectionCallProto.GetCursorCapsModeReader.init(&[_]u8{});
    }
    pub fn getGetExtractedText(self: *const InputConnectionCallProtoReader) gremlin.Error!InputConnectionCallProto.GetExtractedTextReader {
        if (self._get_extracted_text_buf) |buf| {
            return try InputConnectionCallProto.GetExtractedTextReader.init(buf);
        }
        return try InputConnectionCallProto.GetExtractedTextReader.init(&[_]u8{});
    }
};
