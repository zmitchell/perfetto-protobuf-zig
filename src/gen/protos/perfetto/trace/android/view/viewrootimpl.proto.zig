// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
const rect = @import("src/gen/protos/perfetto/trace/android/graphics/rect.proto.zig");
const displaycutout = @import("displaycutout.proto.zig");
const windowlayoutparams = @import("windowlayoutparams.proto.zig");
// structs
const ViewRootImplProtoWire = struct {
    const VIEW_WIRE: gremlin.ProtoWireNumber = 1;
    const DISPLAY_ID_WIRE: gremlin.ProtoWireNumber = 2;
    const APP_VISIBLE_WIRE: gremlin.ProtoWireNumber = 3;
    const WIDTH_WIRE: gremlin.ProtoWireNumber = 4;
    const HEIGHT_WIRE: gremlin.ProtoWireNumber = 5;
    const IS_ANIMATING_WIRE: gremlin.ProtoWireNumber = 6;
    const VISIBLE_RECT_WIRE: gremlin.ProtoWireNumber = 7;
    const IS_DRAWING_WIRE: gremlin.ProtoWireNumber = 8;
    const ADDED_WIRE: gremlin.ProtoWireNumber = 9;
    const WIN_FRAME_WIRE: gremlin.ProtoWireNumber = 10;
    const PENDING_DISPLAY_CUTOUT_WIRE: gremlin.ProtoWireNumber = 11;
    const LAST_WINDOW_INSETS_WIRE: gremlin.ProtoWireNumber = 12;
    const SOFT_INPUT_MODE_WIRE: gremlin.ProtoWireNumber = 13;
    const SCROLL_Y_WIRE: gremlin.ProtoWireNumber = 14;
    const CUR_SCROLL_Y_WIRE: gremlin.ProtoWireNumber = 15;
    const REMOVED_WIRE: gremlin.ProtoWireNumber = 16;
    const WINDOW_ATTRIBUTES_WIRE: gremlin.ProtoWireNumber = 17;
};
pub const ViewRootImplProto = struct {
    // fields
    view: ?[]const u8 = null,
    display_id: i32 = 0,
    app_visible: bool = false,
    width: i32 = 0,
    height: i32 = 0,
    is_animating: bool = false,
    visible_rect: ?rect.RectProto = null,
    is_drawing: bool = false,
    added: bool = false,
    win_frame: ?rect.RectProto = null,
    pending_display_cutout: ?displaycutout.DisplayCutoutProto = null,
    last_window_insets: ?[]const u8 = null,
    soft_input_mode: ?[]const u8 = null,
    scroll_y: i32 = 0,
    cur_scroll_y: i32 = 0,
    removed: bool = false,
    window_attributes: ?windowlayoutparams.WindowLayoutParamsProto = null,
    pub fn calcProtobufSize(self: *const ViewRootImplProto) usize {
        var res: usize = 0;
        if (self.view) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(ViewRootImplProtoWire.VIEW_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.display_id != 0) {
            res += gremlin.sizes.sizeWireNumber(ViewRootImplProtoWire.DISPLAY_ID_WIRE) + gremlin.sizes.sizeI32(self.display_id);
        }
        if (self.app_visible != false) {
            res += gremlin.sizes.sizeWireNumber(ViewRootImplProtoWire.APP_VISIBLE_WIRE) + gremlin.sizes.sizeBool(self.app_visible);
        }
        if (self.width != 0) {
            res += gremlin.sizes.sizeWireNumber(ViewRootImplProtoWire.WIDTH_WIRE) + gremlin.sizes.sizeI32(self.width);
        }
        if (self.height != 0) {
            res += gremlin.sizes.sizeWireNumber(ViewRootImplProtoWire.HEIGHT_WIRE) + gremlin.sizes.sizeI32(self.height);
        }
        if (self.is_animating != false) {
            res += gremlin.sizes.sizeWireNumber(ViewRootImplProtoWire.IS_ANIMATING_WIRE) + gremlin.sizes.sizeBool(self.is_animating);
        }
        if (self.visible_rect) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ViewRootImplProtoWire.VISIBLE_RECT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.is_drawing != false) {
            res += gremlin.sizes.sizeWireNumber(ViewRootImplProtoWire.IS_DRAWING_WIRE) + gremlin.sizes.sizeBool(self.is_drawing);
        }
        if (self.added != false) {
            res += gremlin.sizes.sizeWireNumber(ViewRootImplProtoWire.ADDED_WIRE) + gremlin.sizes.sizeBool(self.added);
        }
        if (self.win_frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ViewRootImplProtoWire.WIN_FRAME_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.pending_display_cutout) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ViewRootImplProtoWire.PENDING_DISPLAY_CUTOUT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.last_window_insets) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(ViewRootImplProtoWire.LAST_WINDOW_INSETS_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.soft_input_mode) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(ViewRootImplProtoWire.SOFT_INPUT_MODE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.scroll_y != 0) {
            res += gremlin.sizes.sizeWireNumber(ViewRootImplProtoWire.SCROLL_Y_WIRE) + gremlin.sizes.sizeI32(self.scroll_y);
        }
        if (self.cur_scroll_y != 0) {
            res += gremlin.sizes.sizeWireNumber(ViewRootImplProtoWire.CUR_SCROLL_Y_WIRE) + gremlin.sizes.sizeI32(self.cur_scroll_y);
        }
        if (self.removed != false) {
            res += gremlin.sizes.sizeWireNumber(ViewRootImplProtoWire.REMOVED_WIRE) + gremlin.sizes.sizeBool(self.removed);
        }
        if (self.window_attributes) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ViewRootImplProtoWire.WINDOW_ATTRIBUTES_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const ViewRootImplProto, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ViewRootImplProto, target: *gremlin.Writer) void {
        if (self.view) |v| {
            if (v.len > 0) {
                target.appendBytes(ViewRootImplProtoWire.VIEW_WIRE, v);
            }
        }
        if (self.display_id != 0) {
            target.appendInt32(ViewRootImplProtoWire.DISPLAY_ID_WIRE, self.display_id);
        }
        if (self.app_visible != false) {
            target.appendBool(ViewRootImplProtoWire.APP_VISIBLE_WIRE, self.app_visible);
        }
        if (self.width != 0) {
            target.appendInt32(ViewRootImplProtoWire.WIDTH_WIRE, self.width);
        }
        if (self.height != 0) {
            target.appendInt32(ViewRootImplProtoWire.HEIGHT_WIRE, self.height);
        }
        if (self.is_animating != false) {
            target.appendBool(ViewRootImplProtoWire.IS_ANIMATING_WIRE, self.is_animating);
        }
        if (self.visible_rect) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ViewRootImplProtoWire.VISIBLE_RECT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.is_drawing != false) {
            target.appendBool(ViewRootImplProtoWire.IS_DRAWING_WIRE, self.is_drawing);
        }
        if (self.added != false) {
            target.appendBool(ViewRootImplProtoWire.ADDED_WIRE, self.added);
        }
        if (self.win_frame) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ViewRootImplProtoWire.WIN_FRAME_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.pending_display_cutout) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ViewRootImplProtoWire.PENDING_DISPLAY_CUTOUT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.last_window_insets) |v| {
            if (v.len > 0) {
                target.appendBytes(ViewRootImplProtoWire.LAST_WINDOW_INSETS_WIRE, v);
            }
        }
        if (self.soft_input_mode) |v| {
            if (v.len > 0) {
                target.appendBytes(ViewRootImplProtoWire.SOFT_INPUT_MODE_WIRE, v);
            }
        }
        if (self.scroll_y != 0) {
            target.appendInt32(ViewRootImplProtoWire.SCROLL_Y_WIRE, self.scroll_y);
        }
        if (self.cur_scroll_y != 0) {
            target.appendInt32(ViewRootImplProtoWire.CUR_SCROLL_Y_WIRE, self.cur_scroll_y);
        }
        if (self.removed != false) {
            target.appendBool(ViewRootImplProtoWire.REMOVED_WIRE, self.removed);
        }
        if (self.window_attributes) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ViewRootImplProtoWire.WINDOW_ATTRIBUTES_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const ViewRootImplProtoReader = struct {
    buf: gremlin.Reader,
    _view: ?[]const u8 = null,
    _display_id: i32 = 0,
    _app_visible: bool = false,
    _width: i32 = 0,
    _height: i32 = 0,
    _is_animating: bool = false,
    _visible_rect_buf: ?[]const u8 = null,
    _is_drawing: bool = false,
    _added: bool = false,
    _win_frame_buf: ?[]const u8 = null,
    _pending_display_cutout_buf: ?[]const u8 = null,
    _last_window_insets: ?[]const u8 = null,
    _soft_input_mode: ?[]const u8 = null,
    _scroll_y: i32 = 0,
    _cur_scroll_y: i32 = 0,
    _removed: bool = false,
    _window_attributes_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!ViewRootImplProtoReader {
        const buf = gremlin.Reader.init(src);
        var res = ViewRootImplProtoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ViewRootImplProtoWire.VIEW_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._view = result.value;
                },
                ViewRootImplProtoWire.DISPLAY_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._display_id = result.value;
                },
                ViewRootImplProtoWire.APP_VISIBLE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._app_visible = result.value;
                },
                ViewRootImplProtoWire.WIDTH_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._width = result.value;
                },
                ViewRootImplProtoWire.HEIGHT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._height = result.value;
                },
                ViewRootImplProtoWire.IS_ANIMATING_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_animating = result.value;
                },
                ViewRootImplProtoWire.VISIBLE_RECT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._visible_rect_buf = result.value;
                },
                ViewRootImplProtoWire.IS_DRAWING_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_drawing = result.value;
                },
                ViewRootImplProtoWire.ADDED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._added = result.value;
                },
                ViewRootImplProtoWire.WIN_FRAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._win_frame_buf = result.value;
                },
                ViewRootImplProtoWire.PENDING_DISPLAY_CUTOUT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._pending_display_cutout_buf = result.value;
                },
                ViewRootImplProtoWire.LAST_WINDOW_INSETS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._last_window_insets = result.value;
                },
                ViewRootImplProtoWire.SOFT_INPUT_MODE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._soft_input_mode = result.value;
                },
                ViewRootImplProtoWire.SCROLL_Y_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._scroll_y = result.value;
                },
                ViewRootImplProtoWire.CUR_SCROLL_Y_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._cur_scroll_y = result.value;
                },
                ViewRootImplProtoWire.REMOVED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._removed = result.value;
                },
                ViewRootImplProtoWire.WINDOW_ATTRIBUTES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._window_attributes_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getView(self: *const ViewRootImplProtoReader) []const u8 {
        return self._view orelse &[_]u8{};
    }
    pub inline fn getDisplayId(self: *const ViewRootImplProtoReader) i32 {
        return self._display_id;
    }
    pub inline fn getAppVisible(self: *const ViewRootImplProtoReader) bool {
        return self._app_visible;
    }
    pub inline fn getWidth(self: *const ViewRootImplProtoReader) i32 {
        return self._width;
    }
    pub inline fn getHeight(self: *const ViewRootImplProtoReader) i32 {
        return self._height;
    }
    pub inline fn getIsAnimating(self: *const ViewRootImplProtoReader) bool {
        return self._is_animating;
    }
    pub fn getVisibleRect(self: *const ViewRootImplProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._visible_rect_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub inline fn getIsDrawing(self: *const ViewRootImplProtoReader) bool {
        return self._is_drawing;
    }
    pub inline fn getAdded(self: *const ViewRootImplProtoReader) bool {
        return self._added;
    }
    pub fn getWinFrame(self: *const ViewRootImplProtoReader) gremlin.Error!rect.RectProtoReader {
        if (self._win_frame_buf) |buf| {
            return try rect.RectProtoReader.init(buf);
        }
        return try rect.RectProtoReader.init(&[_]u8{});
    }
    pub fn getPendingDisplayCutout(self: *const ViewRootImplProtoReader) gremlin.Error!displaycutout.DisplayCutoutProtoReader {
        if (self._pending_display_cutout_buf) |buf| {
            return try displaycutout.DisplayCutoutProtoReader.init(buf);
        }
        return try displaycutout.DisplayCutoutProtoReader.init(&[_]u8{});
    }
    pub inline fn getLastWindowInsets(self: *const ViewRootImplProtoReader) []const u8 {
        return self._last_window_insets orelse &[_]u8{};
    }
    pub inline fn getSoftInputMode(self: *const ViewRootImplProtoReader) []const u8 {
        return self._soft_input_mode orelse &[_]u8{};
    }
    pub inline fn getScrollY(self: *const ViewRootImplProtoReader) i32 {
        return self._scroll_y;
    }
    pub inline fn getCurScrollY(self: *const ViewRootImplProtoReader) i32 {
        return self._cur_scroll_y;
    }
    pub inline fn getRemoved(self: *const ViewRootImplProtoReader) bool {
        return self._removed;
    }
    pub fn getWindowAttributes(self: *const ViewRootImplProtoReader) gremlin.Error!windowlayoutparams.WindowLayoutParamsProtoReader {
        if (self._window_attributes_buf) |buf| {
            return try windowlayoutparams.WindowLayoutParamsProtoReader.init(buf);
        }
        return try windowlayoutparams.WindowLayoutParamsProtoReader.init(&[_]u8{});
    }
};
