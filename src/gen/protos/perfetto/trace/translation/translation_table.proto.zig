// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const TranslationTableWire = struct {
    const CHROME_HISTOGRAM_WIRE: gremlin.ProtoWireNumber = 1;
    const CHROME_USER_EVENT_WIRE: gremlin.ProtoWireNumber = 2;
    const CHROME_PERFORMANCE_MARK_WIRE: gremlin.ProtoWireNumber = 3;
    const SLICE_NAME_WIRE: gremlin.ProtoWireNumber = 4;
    const PROCESS_TRACK_NAME_WIRE: gremlin.ProtoWireNumber = 5;
    const CHROME_STUDY_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const TranslationTable = struct {
    // fields
    chrome_histogram: ?ChromeHistorgramTranslationTable = null,
    chrome_user_event: ?ChromeUserEventTranslationTable = null,
    chrome_performance_mark: ?ChromePerformanceMarkTranslationTable = null,
    slice_name: ?SliceNameTranslationTable = null,
    process_track_name: ?ProcessTrackNameTranslationTable = null,
    chrome_study: ?ChromeStudyTranslationTable = null,
    pub fn calcProtobufSize(self: *const TranslationTable) usize {
        var res: usize = 0;
        if (self.chrome_histogram) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TranslationTableWire.CHROME_HISTOGRAM_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_user_event) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TranslationTableWire.CHROME_USER_EVENT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_performance_mark) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TranslationTableWire.CHROME_PERFORMANCE_MARK_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.slice_name) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TranslationTableWire.SLICE_NAME_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.process_track_name) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TranslationTableWire.PROCESS_TRACK_NAME_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_study) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TranslationTableWire.CHROME_STUDY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const TranslationTable, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TranslationTable, target: *gremlin.Writer) void {
        if (self.chrome_histogram) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TranslationTableWire.CHROME_HISTOGRAM_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_user_event) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TranslationTableWire.CHROME_USER_EVENT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_performance_mark) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TranslationTableWire.CHROME_PERFORMANCE_MARK_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.slice_name) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TranslationTableWire.SLICE_NAME_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.process_track_name) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TranslationTableWire.PROCESS_TRACK_NAME_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_study) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TranslationTableWire.CHROME_STUDY_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const TranslationTableReader = struct {
    buf: gremlin.Reader,
    _chrome_histogram_buf: ?[]const u8 = null,
    _chrome_user_event_buf: ?[]const u8 = null,
    _chrome_performance_mark_buf: ?[]const u8 = null,
    _slice_name_buf: ?[]const u8 = null,
    _process_track_name_buf: ?[]const u8 = null,
    _chrome_study_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!TranslationTableReader {
        const buf = gremlin.Reader.init(src);
        var res = TranslationTableReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TranslationTableWire.CHROME_HISTOGRAM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_histogram_buf = result.value;
                },
                TranslationTableWire.CHROME_USER_EVENT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_user_event_buf = result.value;
                },
                TranslationTableWire.CHROME_PERFORMANCE_MARK_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_performance_mark_buf = result.value;
                },
                TranslationTableWire.SLICE_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._slice_name_buf = result.value;
                },
                TranslationTableWire.PROCESS_TRACK_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._process_track_name_buf = result.value;
                },
                TranslationTableWire.CHROME_STUDY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_study_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getChromeHistogram(self: *const TranslationTableReader) gremlin.Error!ChromeHistorgramTranslationTableReader {
        if (self._chrome_histogram_buf) |buf| {
            return try ChromeHistorgramTranslationTableReader.init(buf);
        }
        return try ChromeHistorgramTranslationTableReader.init(&[_]u8{});
    }
    pub fn getChromeUserEvent(self: *const TranslationTableReader) gremlin.Error!ChromeUserEventTranslationTableReader {
        if (self._chrome_user_event_buf) |buf| {
            return try ChromeUserEventTranslationTableReader.init(buf);
        }
        return try ChromeUserEventTranslationTableReader.init(&[_]u8{});
    }
    pub fn getChromePerformanceMark(self: *const TranslationTableReader) gremlin.Error!ChromePerformanceMarkTranslationTableReader {
        if (self._chrome_performance_mark_buf) |buf| {
            return try ChromePerformanceMarkTranslationTableReader.init(buf);
        }
        return try ChromePerformanceMarkTranslationTableReader.init(&[_]u8{});
    }
    pub fn getSliceName(self: *const TranslationTableReader) gremlin.Error!SliceNameTranslationTableReader {
        if (self._slice_name_buf) |buf| {
            return try SliceNameTranslationTableReader.init(buf);
        }
        return try SliceNameTranslationTableReader.init(&[_]u8{});
    }
    pub fn getProcessTrackName(self: *const TranslationTableReader) gremlin.Error!ProcessTrackNameTranslationTableReader {
        if (self._process_track_name_buf) |buf| {
            return try ProcessTrackNameTranslationTableReader.init(buf);
        }
        return try ProcessTrackNameTranslationTableReader.init(&[_]u8{});
    }
    pub fn getChromeStudy(self: *const TranslationTableReader) gremlin.Error!ChromeStudyTranslationTableReader {
        if (self._chrome_study_buf) |buf| {
            return try ChromeStudyTranslationTableReader.init(buf);
        }
        return try ChromeStudyTranslationTableReader.init(&[_]u8{});
    }
};
const ChromeHistorgramTranslationTableWire = struct {
    const HASH_TO_NAME_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const ChromeHistorgramTranslationTable = struct {
    // fields
    hash_to_name: ?*std.AutoHashMap(u64, []const u8) = null,
    pub fn calcProtobufSize(self: *const ChromeHistorgramTranslationTable) usize {
        var res: usize = 0;
        if (self.hash_to_name) |v| {
            var it = v.iterator();
            const entry_wire = gremlin.sizes.sizeWireNumber(ChromeHistorgramTranslationTableWire.HASH_TO_NAME_WIRE);
            while (it.next()) |entry| {
                const key = entry.key_ptr.*;
                const key_size = gremlin.sizes.sizeU64(key);
                const value = entry.value_ptr.*;
                const value_size = gremlin.sizes.sizeUsize(value.len) + value.len;
                const entry_size = key_size + value_size + gremlin.sizes.sizeWireNumber(1) + gremlin.sizes.sizeWireNumber(2);
                res += entry_wire + gremlin.sizes.sizeUsize(entry_size) + entry_size;
            }
        }
        return res;
    }
    pub fn encode(self: *const ChromeHistorgramTranslationTable, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ChromeHistorgramTranslationTable, target: *gremlin.Writer) void {
        if (self.hash_to_name) |v| {
            var it = v.iterator();
            while (it.next()) |entry| {
                const key = entry.key_ptr.*;
                const key_size = gremlin.sizes.sizeU64(key);
                const value = entry.value_ptr.*;
                const value_size = gremlin.sizes.sizeUsize(value.len) + value.len;
                const entry_size = key_size + value_size + gremlin.sizes.sizeWireNumber(1) + gremlin.sizes.sizeWireNumber(2);
                target.appendBytesTag(ChromeHistorgramTranslationTableWire.HASH_TO_NAME_WIRE, entry_size);
                target.appendUint64(1, key);
                target.appendBytes(2, value);
            }
        }
    }
};
pub const ChromeHistorgramTranslationTableReader = struct {
    pub const HashToNameEntry = struct {
        key: u64,
        value: []const u8,
    };
    buf: gremlin.Reader,
    _hash_to_name_offset: ?usize = null,
    _hash_to_name_last_offset: ?usize = null,
    _hash_to_name_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!ChromeHistorgramTranslationTableReader {
        const buf = gremlin.Reader.init(src);
        var res = ChromeHistorgramTranslationTableReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ChromeHistorgramTranslationTableWire.HASH_TO_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._hash_to_name_offset == null) {
                        res._hash_to_name_offset = offset - result.size;
                    }
                    res._hash_to_name_last_offset = offset;
                    res._hash_to_name_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn countHashToName(self: *const ChromeHistorgramTranslationTableReader) usize {
        return self._hash_to_name_cnt;
    }
    pub fn nextHashToName(self: *ChromeHistorgramTranslationTableReader) gremlin.Error!?HashToNameEntry {
        if (self._hash_to_name_offset) |current_offset| {
            if (self._hash_to_name_last_offset) |last_offset| {
                if (current_offset >= last_offset) {
                    self._hash_to_name_offset = null;
                    return null;
                }
            }
            var offset = current_offset;
            const result = try self.buf.readBytes(offset);
            offset += result.size;
            const entry_buf = gremlin.Reader.init(result.value);
            var entry_offset: usize = 0;
            var key: u64 = undefined;
            var has_key = false;
            var value: []const u8 = undefined;
            var has_value = false;
            while (entry_buf.hasNext(entry_offset, 0)) {
                const entry_tag = try entry_buf.readTagAt(entry_offset);
                entry_offset += entry_tag.size;
                switch (entry_tag.number) {
                    1 => {
                        const sized_key = try entry_buf.readUInt64(entry_offset);
                        key = sized_key.value;
                        entry_offset += sized_key.size;
                        has_key = true;
                    },
                    2 => {
                        const sized_value = try entry_buf.readBytes(entry_offset);
                        value = sized_value.value;
                        entry_offset += sized_value.size;
                        has_value = true;
                    },
                    else => {
                        entry_offset = try entry_buf.skipData(entry_offset, entry_tag.wire);
                    },
                }
            }
            // Find next map entry in the main buffer
            var next_offset = offset;
            const max_offset = self._hash_to_name_last_offset.?;
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = try self.buf.readTagAt(next_offset);
                next_offset += tag.size;
                if (tag.number == ChromeHistorgramTranslationTableWire.HASH_TO_NAME_WIRE) {
                    self._hash_to_name_offset = next_offset;
                    break;
                } else {
                    next_offset = try self.buf.skipData(next_offset, tag.wire);
                }
            } else {
                self._hash_to_name_offset = null;
            }
            if (has_key and has_value) {
                return HashToNameEntry{ .key = key, .value = value };
            }
            return null;
        }
        return null;
    }
};
const ChromeUserEventTranslationTableWire = struct {
    const ACTION_HASH_TO_NAME_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const ChromeUserEventTranslationTable = struct {
    // fields
    action_hash_to_name: ?*std.AutoHashMap(u64, []const u8) = null,
    pub fn calcProtobufSize(self: *const ChromeUserEventTranslationTable) usize {
        var res: usize = 0;
        if (self.action_hash_to_name) |v| {
            var it = v.iterator();
            const entry_wire = gremlin.sizes.sizeWireNumber(ChromeUserEventTranslationTableWire.ACTION_HASH_TO_NAME_WIRE);
            while (it.next()) |entry| {
                const key = entry.key_ptr.*;
                const key_size = gremlin.sizes.sizeU64(key);
                const value = entry.value_ptr.*;
                const value_size = gremlin.sizes.sizeUsize(value.len) + value.len;
                const entry_size = key_size + value_size + gremlin.sizes.sizeWireNumber(1) + gremlin.sizes.sizeWireNumber(2);
                res += entry_wire + gremlin.sizes.sizeUsize(entry_size) + entry_size;
            }
        }
        return res;
    }
    pub fn encode(self: *const ChromeUserEventTranslationTable, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ChromeUserEventTranslationTable, target: *gremlin.Writer) void {
        if (self.action_hash_to_name) |v| {
            var it = v.iterator();
            while (it.next()) |entry| {
                const key = entry.key_ptr.*;
                const key_size = gremlin.sizes.sizeU64(key);
                const value = entry.value_ptr.*;
                const value_size = gremlin.sizes.sizeUsize(value.len) + value.len;
                const entry_size = key_size + value_size + gremlin.sizes.sizeWireNumber(1) + gremlin.sizes.sizeWireNumber(2);
                target.appendBytesTag(ChromeUserEventTranslationTableWire.ACTION_HASH_TO_NAME_WIRE, entry_size);
                target.appendUint64(1, key);
                target.appendBytes(2, value);
            }
        }
    }
};
pub const ChromeUserEventTranslationTableReader = struct {
    pub const ActionHashToNameEntry = struct {
        key: u64,
        value: []const u8,
    };
    buf: gremlin.Reader,
    _action_hash_to_name_offset: ?usize = null,
    _action_hash_to_name_last_offset: ?usize = null,
    _action_hash_to_name_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!ChromeUserEventTranslationTableReader {
        const buf = gremlin.Reader.init(src);
        var res = ChromeUserEventTranslationTableReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ChromeUserEventTranslationTableWire.ACTION_HASH_TO_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._action_hash_to_name_offset == null) {
                        res._action_hash_to_name_offset = offset - result.size;
                    }
                    res._action_hash_to_name_last_offset = offset;
                    res._action_hash_to_name_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn countActionHashToName(self: *const ChromeUserEventTranslationTableReader) usize {
        return self._action_hash_to_name_cnt;
    }
    pub fn nextActionHashToName(self: *ChromeUserEventTranslationTableReader) gremlin.Error!?ActionHashToNameEntry {
        if (self._action_hash_to_name_offset) |current_offset| {
            if (self._action_hash_to_name_last_offset) |last_offset| {
                if (current_offset >= last_offset) {
                    self._action_hash_to_name_offset = null;
                    return null;
                }
            }
            var offset = current_offset;
            const result = try self.buf.readBytes(offset);
            offset += result.size;
            const entry_buf = gremlin.Reader.init(result.value);
            var entry_offset: usize = 0;
            var key: u64 = undefined;
            var has_key = false;
            var value: []const u8 = undefined;
            var has_value = false;
            while (entry_buf.hasNext(entry_offset, 0)) {
                const entry_tag = try entry_buf.readTagAt(entry_offset);
                entry_offset += entry_tag.size;
                switch (entry_tag.number) {
                    1 => {
                        const sized_key = try entry_buf.readUInt64(entry_offset);
                        key = sized_key.value;
                        entry_offset += sized_key.size;
                        has_key = true;
                    },
                    2 => {
                        const sized_value = try entry_buf.readBytes(entry_offset);
                        value = sized_value.value;
                        entry_offset += sized_value.size;
                        has_value = true;
                    },
                    else => {
                        entry_offset = try entry_buf.skipData(entry_offset, entry_tag.wire);
                    },
                }
            }
            // Find next map entry in the main buffer
            var next_offset = offset;
            const max_offset = self._action_hash_to_name_last_offset.?;
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = try self.buf.readTagAt(next_offset);
                next_offset += tag.size;
                if (tag.number == ChromeUserEventTranslationTableWire.ACTION_HASH_TO_NAME_WIRE) {
                    self._action_hash_to_name_offset = next_offset;
                    break;
                } else {
                    next_offset = try self.buf.skipData(next_offset, tag.wire);
                }
            } else {
                self._action_hash_to_name_offset = null;
            }
            if (has_key and has_value) {
                return ActionHashToNameEntry{ .key = key, .value = value };
            }
            return null;
        }
        return null;
    }
};
const ChromePerformanceMarkTranslationTableWire = struct {
    const SITE_HASH_TO_NAME_WIRE: gremlin.ProtoWireNumber = 1;
    const MARK_HASH_TO_NAME_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const ChromePerformanceMarkTranslationTable = struct {
    // fields
    site_hash_to_name: ?*std.AutoHashMap(u32, []const u8) = null,
    mark_hash_to_name: ?*std.AutoHashMap(u32, []const u8) = null,
    pub fn calcProtobufSize(self: *const ChromePerformanceMarkTranslationTable) usize {
        var res: usize = 0;
        if (self.site_hash_to_name) |v| {
            var it = v.iterator();
            const entry_wire = gremlin.sizes.sizeWireNumber(ChromePerformanceMarkTranslationTableWire.SITE_HASH_TO_NAME_WIRE);
            while (it.next()) |entry| {
                const key = entry.key_ptr.*;
                const key_size = gremlin.sizes.sizeU32(key);
                const value = entry.value_ptr.*;
                const value_size = gremlin.sizes.sizeUsize(value.len) + value.len;
                const entry_size = key_size + value_size + gremlin.sizes.sizeWireNumber(1) + gremlin.sizes.sizeWireNumber(2);
                res += entry_wire + gremlin.sizes.sizeUsize(entry_size) + entry_size;
            }
        }
        if (self.mark_hash_to_name) |v| {
            var it = v.iterator();
            const entry_wire = gremlin.sizes.sizeWireNumber(ChromePerformanceMarkTranslationTableWire.MARK_HASH_TO_NAME_WIRE);
            while (it.next()) |entry| {
                const key = entry.key_ptr.*;
                const key_size = gremlin.sizes.sizeU32(key);
                const value = entry.value_ptr.*;
                const value_size = gremlin.sizes.sizeUsize(value.len) + value.len;
                const entry_size = key_size + value_size + gremlin.sizes.sizeWireNumber(1) + gremlin.sizes.sizeWireNumber(2);
                res += entry_wire + gremlin.sizes.sizeUsize(entry_size) + entry_size;
            }
        }
        return res;
    }
    pub fn encode(self: *const ChromePerformanceMarkTranslationTable, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ChromePerformanceMarkTranslationTable, target: *gremlin.Writer) void {
        if (self.site_hash_to_name) |v| {
            var it = v.iterator();
            while (it.next()) |entry| {
                const key = entry.key_ptr.*;
                const key_size = gremlin.sizes.sizeU32(key);
                const value = entry.value_ptr.*;
                const value_size = gremlin.sizes.sizeUsize(value.len) + value.len;
                const entry_size = key_size + value_size + gremlin.sizes.sizeWireNumber(1) + gremlin.sizes.sizeWireNumber(2);
                target.appendBytesTag(ChromePerformanceMarkTranslationTableWire.SITE_HASH_TO_NAME_WIRE, entry_size);
                target.appendUint32(1, key);
                target.appendBytes(2, value);
            }
        }
        if (self.mark_hash_to_name) |v| {
            var it = v.iterator();
            while (it.next()) |entry| {
                const key = entry.key_ptr.*;
                const key_size = gremlin.sizes.sizeU32(key);
                const value = entry.value_ptr.*;
                const value_size = gremlin.sizes.sizeUsize(value.len) + value.len;
                const entry_size = key_size + value_size + gremlin.sizes.sizeWireNumber(1) + gremlin.sizes.sizeWireNumber(2);
                target.appendBytesTag(ChromePerformanceMarkTranslationTableWire.MARK_HASH_TO_NAME_WIRE, entry_size);
                target.appendUint32(1, key);
                target.appendBytes(2, value);
            }
        }
    }
};
pub const ChromePerformanceMarkTranslationTableReader = struct {
    pub const SiteHashToNameEntry = struct {
        key: u32,
        value: []const u8,
    };
    pub const MarkHashToNameEntry = struct {
        key: u32,
        value: []const u8,
    };
    buf: gremlin.Reader,
    _site_hash_to_name_offset: ?usize = null,
    _site_hash_to_name_last_offset: ?usize = null,
    _site_hash_to_name_cnt: usize = 0,
    _mark_hash_to_name_offset: ?usize = null,
    _mark_hash_to_name_last_offset: ?usize = null,
    _mark_hash_to_name_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!ChromePerformanceMarkTranslationTableReader {
        const buf = gremlin.Reader.init(src);
        var res = ChromePerformanceMarkTranslationTableReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ChromePerformanceMarkTranslationTableWire.SITE_HASH_TO_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._site_hash_to_name_offset == null) {
                        res._site_hash_to_name_offset = offset - result.size;
                    }
                    res._site_hash_to_name_last_offset = offset;
                    res._site_hash_to_name_cnt += 1;
                },
                ChromePerformanceMarkTranslationTableWire.MARK_HASH_TO_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._mark_hash_to_name_offset == null) {
                        res._mark_hash_to_name_offset = offset - result.size;
                    }
                    res._mark_hash_to_name_last_offset = offset;
                    res._mark_hash_to_name_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn countSiteHashToName(self: *const ChromePerformanceMarkTranslationTableReader) usize {
        return self._site_hash_to_name_cnt;
    }
    pub fn nextSiteHashToName(self: *ChromePerformanceMarkTranslationTableReader) gremlin.Error!?SiteHashToNameEntry {
        if (self._site_hash_to_name_offset) |current_offset| {
            if (self._site_hash_to_name_last_offset) |last_offset| {
                if (current_offset >= last_offset) {
                    self._site_hash_to_name_offset = null;
                    return null;
                }
            }
            var offset = current_offset;
            const result = try self.buf.readBytes(offset);
            offset += result.size;
            const entry_buf = gremlin.Reader.init(result.value);
            var entry_offset: usize = 0;
            var key: u32 = undefined;
            var has_key = false;
            var value: []const u8 = undefined;
            var has_value = false;
            while (entry_buf.hasNext(entry_offset, 0)) {
                const entry_tag = try entry_buf.readTagAt(entry_offset);
                entry_offset += entry_tag.size;
                switch (entry_tag.number) {
                    1 => {
                        const sized_key = try entry_buf.readUInt32(entry_offset);
                        key = sized_key.value;
                        entry_offset += sized_key.size;
                        has_key = true;
                    },
                    2 => {
                        const sized_value = try entry_buf.readBytes(entry_offset);
                        value = sized_value.value;
                        entry_offset += sized_value.size;
                        has_value = true;
                    },
                    else => {
                        entry_offset = try entry_buf.skipData(entry_offset, entry_tag.wire);
                    },
                }
            }
            // Find next map entry in the main buffer
            var next_offset = offset;
            const max_offset = self._site_hash_to_name_last_offset.?;
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = try self.buf.readTagAt(next_offset);
                next_offset += tag.size;
                if (tag.number == ChromePerformanceMarkTranslationTableWire.SITE_HASH_TO_NAME_WIRE) {
                    self._site_hash_to_name_offset = next_offset;
                    break;
                } else {
                    next_offset = try self.buf.skipData(next_offset, tag.wire);
                }
            } else {
                self._site_hash_to_name_offset = null;
            }
            if (has_key and has_value) {
                return SiteHashToNameEntry{ .key = key, .value = value };
            }
            return null;
        }
        return null;
    }
    pub fn countMarkHashToName(self: *const ChromePerformanceMarkTranslationTableReader) usize {
        return self._mark_hash_to_name_cnt;
    }
    pub fn nextMarkHashToName(self: *ChromePerformanceMarkTranslationTableReader) gremlin.Error!?MarkHashToNameEntry {
        if (self._mark_hash_to_name_offset) |current_offset| {
            if (self._mark_hash_to_name_last_offset) |last_offset| {
                if (current_offset >= last_offset) {
                    self._mark_hash_to_name_offset = null;
                    return null;
                }
            }
            var offset = current_offset;
            const result = try self.buf.readBytes(offset);
            offset += result.size;
            const entry_buf = gremlin.Reader.init(result.value);
            var entry_offset: usize = 0;
            var key: u32 = undefined;
            var has_key = false;
            var value: []const u8 = undefined;
            var has_value = false;
            while (entry_buf.hasNext(entry_offset, 0)) {
                const entry_tag = try entry_buf.readTagAt(entry_offset);
                entry_offset += entry_tag.size;
                switch (entry_tag.number) {
                    1 => {
                        const sized_key = try entry_buf.readUInt32(entry_offset);
                        key = sized_key.value;
                        entry_offset += sized_key.size;
                        has_key = true;
                    },
                    2 => {
                        const sized_value = try entry_buf.readBytes(entry_offset);
                        value = sized_value.value;
                        entry_offset += sized_value.size;
                        has_value = true;
                    },
                    else => {
                        entry_offset = try entry_buf.skipData(entry_offset, entry_tag.wire);
                    },
                }
            }
            // Find next map entry in the main buffer
            var next_offset = offset;
            const max_offset = self._mark_hash_to_name_last_offset.?;
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = try self.buf.readTagAt(next_offset);
                next_offset += tag.size;
                if (tag.number == ChromePerformanceMarkTranslationTableWire.MARK_HASH_TO_NAME_WIRE) {
                    self._mark_hash_to_name_offset = next_offset;
                    break;
                } else {
                    next_offset = try self.buf.skipData(next_offset, tag.wire);
                }
            } else {
                self._mark_hash_to_name_offset = null;
            }
            if (has_key and has_value) {
                return MarkHashToNameEntry{ .key = key, .value = value };
            }
            return null;
        }
        return null;
    }
};
const SliceNameTranslationTableWire = struct {
    const RAW_TO_DEOBFUSCATED_NAME_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const SliceNameTranslationTable = struct {
    // fields
    raw_to_deobfuscated_name: ?*std.StringHashMap([]const u8) = null,
    pub fn calcProtobufSize(self: *const SliceNameTranslationTable) usize {
        var res: usize = 0;
        if (self.raw_to_deobfuscated_name) |v| {
            var it = v.iterator();
            const entry_wire = gremlin.sizes.sizeWireNumber(SliceNameTranslationTableWire.RAW_TO_DEOBFUSCATED_NAME_WIRE);
            while (it.next()) |entry| {
                const key = entry.key_ptr.*;
                const key_size = gremlin.sizes.sizeUsize(key.len) + key.len;
                const value = entry.value_ptr.*;
                const value_size = gremlin.sizes.sizeUsize(value.len) + value.len;
                const entry_size = key_size + value_size + gremlin.sizes.sizeWireNumber(1) + gremlin.sizes.sizeWireNumber(2);
                res += entry_wire + gremlin.sizes.sizeUsize(entry_size) + entry_size;
            }
        }
        return res;
    }
    pub fn encode(self: *const SliceNameTranslationTable, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SliceNameTranslationTable, target: *gremlin.Writer) void {
        if (self.raw_to_deobfuscated_name) |v| {
            var it = v.iterator();
            while (it.next()) |entry| {
                const key = entry.key_ptr.*;
                const key_size = gremlin.sizes.sizeUsize(key.len) + key.len;
                const value = entry.value_ptr.*;
                const value_size = gremlin.sizes.sizeUsize(value.len) + value.len;
                const entry_size = key_size + value_size + gremlin.sizes.sizeWireNumber(1) + gremlin.sizes.sizeWireNumber(2);
                target.appendBytesTag(SliceNameTranslationTableWire.RAW_TO_DEOBFUSCATED_NAME_WIRE, entry_size);
                target.appendBytes(1, key);
                target.appendBytes(2, value);
            }
        }
    }
};
pub const SliceNameTranslationTableReader = struct {
    pub const RawToDeobfuscatedNameEntry = struct {
        key: []const u8,
        value: []const u8,
    };
    buf: gremlin.Reader,
    _raw_to_deobfuscated_name_offset: ?usize = null,
    _raw_to_deobfuscated_name_last_offset: ?usize = null,
    _raw_to_deobfuscated_name_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!SliceNameTranslationTableReader {
        const buf = gremlin.Reader.init(src);
        var res = SliceNameTranslationTableReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SliceNameTranslationTableWire.RAW_TO_DEOBFUSCATED_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._raw_to_deobfuscated_name_offset == null) {
                        res._raw_to_deobfuscated_name_offset = offset - result.size;
                    }
                    res._raw_to_deobfuscated_name_last_offset = offset;
                    res._raw_to_deobfuscated_name_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn countRawToDeobfuscatedName(self: *const SliceNameTranslationTableReader) usize {
        return self._raw_to_deobfuscated_name_cnt;
    }
    pub fn nextRawToDeobfuscatedName(self: *SliceNameTranslationTableReader) gremlin.Error!?RawToDeobfuscatedNameEntry {
        if (self._raw_to_deobfuscated_name_offset) |current_offset| {
            if (self._raw_to_deobfuscated_name_last_offset) |last_offset| {
                if (current_offset >= last_offset) {
                    self._raw_to_deobfuscated_name_offset = null;
                    return null;
                }
            }
            var offset = current_offset;
            const result = try self.buf.readBytes(offset);
            offset += result.size;
            const entry_buf = gremlin.Reader.init(result.value);
            var entry_offset: usize = 0;
            var key: []const u8 = undefined;
            var has_key = false;
            var value: []const u8 = undefined;
            var has_value = false;
            while (entry_buf.hasNext(entry_offset, 0)) {
                const entry_tag = try entry_buf.readTagAt(entry_offset);
                entry_offset += entry_tag.size;
                switch (entry_tag.number) {
                    1 => {
                        const sized_key = try entry_buf.readBytes(entry_offset);
                        key = sized_key.value;
                        entry_offset += sized_key.size;
                        has_key = true;
                    },
                    2 => {
                        const sized_value = try entry_buf.readBytes(entry_offset);
                        value = sized_value.value;
                        entry_offset += sized_value.size;
                        has_value = true;
                    },
                    else => {
                        entry_offset = try entry_buf.skipData(entry_offset, entry_tag.wire);
                    },
                }
            }
            // Find next map entry in the main buffer
            var next_offset = offset;
            const max_offset = self._raw_to_deobfuscated_name_last_offset.?;
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = try self.buf.readTagAt(next_offset);
                next_offset += tag.size;
                if (tag.number == SliceNameTranslationTableWire.RAW_TO_DEOBFUSCATED_NAME_WIRE) {
                    self._raw_to_deobfuscated_name_offset = next_offset;
                    break;
                } else {
                    next_offset = try self.buf.skipData(next_offset, tag.wire);
                }
            } else {
                self._raw_to_deobfuscated_name_offset = null;
            }
            if (has_key and has_value) {
                return RawToDeobfuscatedNameEntry{ .key = key, .value = value };
            }
            return null;
        }
        return null;
    }
};
const ProcessTrackNameTranslationTableWire = struct {
    const RAW_TO_DEOBFUSCATED_NAME_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const ProcessTrackNameTranslationTable = struct {
    // fields
    raw_to_deobfuscated_name: ?*std.StringHashMap([]const u8) = null,
    pub fn calcProtobufSize(self: *const ProcessTrackNameTranslationTable) usize {
        var res: usize = 0;
        if (self.raw_to_deobfuscated_name) |v| {
            var it = v.iterator();
            const entry_wire = gremlin.sizes.sizeWireNumber(ProcessTrackNameTranslationTableWire.RAW_TO_DEOBFUSCATED_NAME_WIRE);
            while (it.next()) |entry| {
                const key = entry.key_ptr.*;
                const key_size = gremlin.sizes.sizeUsize(key.len) + key.len;
                const value = entry.value_ptr.*;
                const value_size = gremlin.sizes.sizeUsize(value.len) + value.len;
                const entry_size = key_size + value_size + gremlin.sizes.sizeWireNumber(1) + gremlin.sizes.sizeWireNumber(2);
                res += entry_wire + gremlin.sizes.sizeUsize(entry_size) + entry_size;
            }
        }
        return res;
    }
    pub fn encode(self: *const ProcessTrackNameTranslationTable, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ProcessTrackNameTranslationTable, target: *gremlin.Writer) void {
        if (self.raw_to_deobfuscated_name) |v| {
            var it = v.iterator();
            while (it.next()) |entry| {
                const key = entry.key_ptr.*;
                const key_size = gremlin.sizes.sizeUsize(key.len) + key.len;
                const value = entry.value_ptr.*;
                const value_size = gremlin.sizes.sizeUsize(value.len) + value.len;
                const entry_size = key_size + value_size + gremlin.sizes.sizeWireNumber(1) + gremlin.sizes.sizeWireNumber(2);
                target.appendBytesTag(ProcessTrackNameTranslationTableWire.RAW_TO_DEOBFUSCATED_NAME_WIRE, entry_size);
                target.appendBytes(1, key);
                target.appendBytes(2, value);
            }
        }
    }
};
pub const ProcessTrackNameTranslationTableReader = struct {
    pub const RawToDeobfuscatedNameEntry = struct {
        key: []const u8,
        value: []const u8,
    };
    buf: gremlin.Reader,
    _raw_to_deobfuscated_name_offset: ?usize = null,
    _raw_to_deobfuscated_name_last_offset: ?usize = null,
    _raw_to_deobfuscated_name_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!ProcessTrackNameTranslationTableReader {
        const buf = gremlin.Reader.init(src);
        var res = ProcessTrackNameTranslationTableReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ProcessTrackNameTranslationTableWire.RAW_TO_DEOBFUSCATED_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._raw_to_deobfuscated_name_offset == null) {
                        res._raw_to_deobfuscated_name_offset = offset - result.size;
                    }
                    res._raw_to_deobfuscated_name_last_offset = offset;
                    res._raw_to_deobfuscated_name_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn countRawToDeobfuscatedName(self: *const ProcessTrackNameTranslationTableReader) usize {
        return self._raw_to_deobfuscated_name_cnt;
    }
    pub fn nextRawToDeobfuscatedName(self: *ProcessTrackNameTranslationTableReader) gremlin.Error!?RawToDeobfuscatedNameEntry {
        if (self._raw_to_deobfuscated_name_offset) |current_offset| {
            if (self._raw_to_deobfuscated_name_last_offset) |last_offset| {
                if (current_offset >= last_offset) {
                    self._raw_to_deobfuscated_name_offset = null;
                    return null;
                }
            }
            var offset = current_offset;
            const result = try self.buf.readBytes(offset);
            offset += result.size;
            const entry_buf = gremlin.Reader.init(result.value);
            var entry_offset: usize = 0;
            var key: []const u8 = undefined;
            var has_key = false;
            var value: []const u8 = undefined;
            var has_value = false;
            while (entry_buf.hasNext(entry_offset, 0)) {
                const entry_tag = try entry_buf.readTagAt(entry_offset);
                entry_offset += entry_tag.size;
                switch (entry_tag.number) {
                    1 => {
                        const sized_key = try entry_buf.readBytes(entry_offset);
                        key = sized_key.value;
                        entry_offset += sized_key.size;
                        has_key = true;
                    },
                    2 => {
                        const sized_value = try entry_buf.readBytes(entry_offset);
                        value = sized_value.value;
                        entry_offset += sized_value.size;
                        has_value = true;
                    },
                    else => {
                        entry_offset = try entry_buf.skipData(entry_offset, entry_tag.wire);
                    },
                }
            }
            // Find next map entry in the main buffer
            var next_offset = offset;
            const max_offset = self._raw_to_deobfuscated_name_last_offset.?;
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = try self.buf.readTagAt(next_offset);
                next_offset += tag.size;
                if (tag.number == ProcessTrackNameTranslationTableWire.RAW_TO_DEOBFUSCATED_NAME_WIRE) {
                    self._raw_to_deobfuscated_name_offset = next_offset;
                    break;
                } else {
                    next_offset = try self.buf.skipData(next_offset, tag.wire);
                }
            } else {
                self._raw_to_deobfuscated_name_offset = null;
            }
            if (has_key and has_value) {
                return RawToDeobfuscatedNameEntry{ .key = key, .value = value };
            }
            return null;
        }
        return null;
    }
};
const ChromeStudyTranslationTableWire = struct {
    const HASH_TO_NAME_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const ChromeStudyTranslationTable = struct {
    // fields
    hash_to_name: ?*std.AutoHashMap(u64, []const u8) = null,
    pub fn calcProtobufSize(self: *const ChromeStudyTranslationTable) usize {
        var res: usize = 0;
        if (self.hash_to_name) |v| {
            var it = v.iterator();
            const entry_wire = gremlin.sizes.sizeWireNumber(ChromeStudyTranslationTableWire.HASH_TO_NAME_WIRE);
            while (it.next()) |entry| {
                const key = entry.key_ptr.*;
                const key_size = gremlin.sizes.sizeU64(key);
                const value = entry.value_ptr.*;
                const value_size = gremlin.sizes.sizeUsize(value.len) + value.len;
                const entry_size = key_size + value_size + gremlin.sizes.sizeWireNumber(1) + gremlin.sizes.sizeWireNumber(2);
                res += entry_wire + gremlin.sizes.sizeUsize(entry_size) + entry_size;
            }
        }
        return res;
    }
    pub fn encode(self: *const ChromeStudyTranslationTable, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ChromeStudyTranslationTable, target: *gremlin.Writer) void {
        if (self.hash_to_name) |v| {
            var it = v.iterator();
            while (it.next()) |entry| {
                const key = entry.key_ptr.*;
                const key_size = gremlin.sizes.sizeU64(key);
                const value = entry.value_ptr.*;
                const value_size = gremlin.sizes.sizeUsize(value.len) + value.len;
                const entry_size = key_size + value_size + gremlin.sizes.sizeWireNumber(1) + gremlin.sizes.sizeWireNumber(2);
                target.appendBytesTag(ChromeStudyTranslationTableWire.HASH_TO_NAME_WIRE, entry_size);
                target.appendUint64(1, key);
                target.appendBytes(2, value);
            }
        }
    }
};
pub const ChromeStudyTranslationTableReader = struct {
    pub const HashToNameEntry = struct {
        key: u64,
        value: []const u8,
    };
    buf: gremlin.Reader,
    _hash_to_name_offset: ?usize = null,
    _hash_to_name_last_offset: ?usize = null,
    _hash_to_name_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!ChromeStudyTranslationTableReader {
        const buf = gremlin.Reader.init(src);
        var res = ChromeStudyTranslationTableReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ChromeStudyTranslationTableWire.HASH_TO_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._hash_to_name_offset == null) {
                        res._hash_to_name_offset = offset - result.size;
                    }
                    res._hash_to_name_last_offset = offset;
                    res._hash_to_name_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn countHashToName(self: *const ChromeStudyTranslationTableReader) usize {
        return self._hash_to_name_cnt;
    }
    pub fn nextHashToName(self: *ChromeStudyTranslationTableReader) gremlin.Error!?HashToNameEntry {
        if (self._hash_to_name_offset) |current_offset| {
            if (self._hash_to_name_last_offset) |last_offset| {
                if (current_offset >= last_offset) {
                    self._hash_to_name_offset = null;
                    return null;
                }
            }
            var offset = current_offset;
            const result = try self.buf.readBytes(offset);
            offset += result.size;
            const entry_buf = gremlin.Reader.init(result.value);
            var entry_offset: usize = 0;
            var key: u64 = undefined;
            var has_key = false;
            var value: []const u8 = undefined;
            var has_value = false;
            while (entry_buf.hasNext(entry_offset, 0)) {
                const entry_tag = try entry_buf.readTagAt(entry_offset);
                entry_offset += entry_tag.size;
                switch (entry_tag.number) {
                    1 => {
                        const sized_key = try entry_buf.readUInt64(entry_offset);
                        key = sized_key.value;
                        entry_offset += sized_key.size;
                        has_key = true;
                    },
                    2 => {
                        const sized_value = try entry_buf.readBytes(entry_offset);
                        value = sized_value.value;
                        entry_offset += sized_value.size;
                        has_value = true;
                    },
                    else => {
                        entry_offset = try entry_buf.skipData(entry_offset, entry_tag.wire);
                    },
                }
            }
            // Find next map entry in the main buffer
            var next_offset = offset;
            const max_offset = self._hash_to_name_last_offset.?;
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = try self.buf.readTagAt(next_offset);
                next_offset += tag.size;
                if (tag.number == ChromeStudyTranslationTableWire.HASH_TO_NAME_WIRE) {
                    self._hash_to_name_offset = next_offset;
                    break;
                } else {
                    next_offset = try self.buf.skipData(next_offset, tag.wire);
                }
            } else {
                self._hash_to_name_offset = null;
            }
            if (has_key and has_value) {
                return HashToNameEntry{ .key = key, .value = value };
            }
            return null;
        }
        return null;
    }
};
