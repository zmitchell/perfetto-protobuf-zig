// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const GpuRenderStageEventWire = struct {
    const EVENT_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const DURATION_WIRE: gremlin.ProtoWireNumber = 2;
    const HW_QUEUE_IID_WIRE: gremlin.ProtoWireNumber = 13;
    const STAGE_IID_WIRE: gremlin.ProtoWireNumber = 14;
    const GPU_ID_WIRE: gremlin.ProtoWireNumber = 11;
    const CONTEXT_WIRE: gremlin.ProtoWireNumber = 5;
    const RENDER_TARGET_HANDLE_WIRE: gremlin.ProtoWireNumber = 8;
    const SUBMISSION_ID_WIRE: gremlin.ProtoWireNumber = 10;
    const EXTRA_DATA_WIRE: gremlin.ProtoWireNumber = 6;
    const RENDER_PASS_HANDLE_WIRE: gremlin.ProtoWireNumber = 9;
    const RENDER_PASS_INSTANCE_ID_WIRE: gremlin.ProtoWireNumber = 16;
    const RENDER_SUBPASS_INDEX_MASK_WIRE: gremlin.ProtoWireNumber = 15;
    const COMMAND_BUFFER_HANDLE_WIRE: gremlin.ProtoWireNumber = 12;
    const SPECIFICATIONS_WIRE: gremlin.ProtoWireNumber = 7;
    const HW_QUEUE_ID_WIRE: gremlin.ProtoWireNumber = 3;
    const STAGE_ID_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const GpuRenderStageEvent = struct {
    // nested structs
    const ExtraDataWire = struct {
        const NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const VALUE_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const ExtraData = struct {
        // fields
        name: ?[]const u8 = null,
        value: ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const GpuRenderStageEvent.ExtraData) usize {
            var res: usize = 0;
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(GpuRenderStageEvent.ExtraDataWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.value) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(GpuRenderStageEvent.ExtraDataWire.VALUE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            return res;
        }
        pub fn encode(self: *const GpuRenderStageEvent.ExtraData, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const GpuRenderStageEvent.ExtraData, target: *gremlin.Writer) void {
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(GpuRenderStageEvent.ExtraDataWire.NAME_WIRE, v);
                }
            }
            if (self.value) |v| {
                if (v.len > 0) {
                    target.appendBytes(GpuRenderStageEvent.ExtraDataWire.VALUE_WIRE, v);
                }
            }
        }
    };
    pub const ExtraDataReader = struct {
        buf: gremlin.Reader,
        _name: ?[]const u8 = null,
        _value: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!GpuRenderStageEvent.ExtraDataReader {
            const buf = gremlin.Reader.init(src);
            var res = GpuRenderStageEvent.ExtraDataReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    GpuRenderStageEvent.ExtraDataWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    GpuRenderStageEvent.ExtraDataWire.VALUE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._value = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getName(self: *const GpuRenderStageEvent.ExtraDataReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub inline fn getValue(self: *const GpuRenderStageEvent.ExtraDataReader) []const u8 {
            return self._value orelse &[_]u8{};
        }
    };
    const SpecificationsWire = struct {
        const CONTEXT_SPEC_WIRE: gremlin.ProtoWireNumber = 1;
        const HW_QUEUE_WIRE: gremlin.ProtoWireNumber = 2;
        const STAGE_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const Specifications = struct {
        // nested structs
        const ContextSpecWire = struct {
            const CONTEXT_WIRE: gremlin.ProtoWireNumber = 1;
            const PID_WIRE: gremlin.ProtoWireNumber = 2;
        };
        pub const ContextSpec = struct {
            // fields
            context: u64 = 0,
            pid: i32 = 0,
            pub fn calcProtobufSize(self: *const GpuRenderStageEvent.Specifications.ContextSpec) usize {
                var res: usize = 0;
                if (self.context != 0) {
                    res += gremlin.sizes.sizeWireNumber(GpuRenderStageEvent.Specifications.ContextSpecWire.CONTEXT_WIRE) + gremlin.sizes.sizeU64(self.context);
                }
                if (self.pid != 0) {
                    res += gremlin.sizes.sizeWireNumber(GpuRenderStageEvent.Specifications.ContextSpecWire.PID_WIRE) + gremlin.sizes.sizeI32(self.pid);
                }
                return res;
            }
            pub fn encode(self: *const GpuRenderStageEvent.Specifications.ContextSpec, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const GpuRenderStageEvent.Specifications.ContextSpec, target: *gremlin.Writer) void {
                if (self.context != 0) {
                    target.appendUint64(GpuRenderStageEvent.Specifications.ContextSpecWire.CONTEXT_WIRE, self.context);
                }
                if (self.pid != 0) {
                    target.appendInt32(GpuRenderStageEvent.Specifications.ContextSpecWire.PID_WIRE, self.pid);
                }
            }
        };
        pub const ContextSpecReader = struct {
            buf: gremlin.Reader,
            _context: u64 = 0,
            _pid: i32 = 0,
            pub fn init(src: []const u8) gremlin.Error!GpuRenderStageEvent.Specifications.ContextSpecReader {
                const buf = gremlin.Reader.init(src);
                var res = GpuRenderStageEvent.Specifications.ContextSpecReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        GpuRenderStageEvent.Specifications.ContextSpecWire.CONTEXT_WIRE => {
                            const result = try buf.readUInt64(offset);
                            offset += result.size;
                            res._context = result.value;
                        },
                        GpuRenderStageEvent.Specifications.ContextSpecWire.PID_WIRE => {
                            const result = try buf.readInt32(offset);
                            offset += result.size;
                            res._pid = result.value;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub inline fn getContext(self: *const GpuRenderStageEvent.Specifications.ContextSpecReader) u64 {
                return self._context;
            }
            pub inline fn getPid(self: *const GpuRenderStageEvent.Specifications.ContextSpecReader) i32 {
                return self._pid;
            }
        };
        const DescriptionWire = struct {
            const NAME_WIRE: gremlin.ProtoWireNumber = 1;
            const DESCRIPTION_WIRE: gremlin.ProtoWireNumber = 2;
        };
        pub const Description = struct {
            // fields
            name: ?[]const u8 = null,
            description: ?[]const u8 = null,
            pub fn calcProtobufSize(self: *const GpuRenderStageEvent.Specifications.Description) usize {
                var res: usize = 0;
                if (self.name) |v| {
                    if (v.len > 0) {
                        res += gremlin.sizes.sizeWireNumber(GpuRenderStageEvent.Specifications.DescriptionWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                    }
                }
                if (self.description) |v| {
                    if (v.len > 0) {
                        res += gremlin.sizes.sizeWireNumber(GpuRenderStageEvent.Specifications.DescriptionWire.DESCRIPTION_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                    }
                }
                return res;
            }
            pub fn encode(self: *const GpuRenderStageEvent.Specifications.Description, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const GpuRenderStageEvent.Specifications.Description, target: *gremlin.Writer) void {
                if (self.name) |v| {
                    if (v.len > 0) {
                        target.appendBytes(GpuRenderStageEvent.Specifications.DescriptionWire.NAME_WIRE, v);
                    }
                }
                if (self.description) |v| {
                    if (v.len > 0) {
                        target.appendBytes(GpuRenderStageEvent.Specifications.DescriptionWire.DESCRIPTION_WIRE, v);
                    }
                }
            }
        };
        pub const DescriptionReader = struct {
            buf: gremlin.Reader,
            _name: ?[]const u8 = null,
            _description: ?[]const u8 = null,
            pub fn init(src: []const u8) gremlin.Error!GpuRenderStageEvent.Specifications.DescriptionReader {
                const buf = gremlin.Reader.init(src);
                var res = GpuRenderStageEvent.Specifications.DescriptionReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        GpuRenderStageEvent.Specifications.DescriptionWire.NAME_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._name = result.value;
                        },
                        GpuRenderStageEvent.Specifications.DescriptionWire.DESCRIPTION_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._description = result.value;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub inline fn getName(self: *const GpuRenderStageEvent.Specifications.DescriptionReader) []const u8 {
                return self._name orelse &[_]u8{};
            }
            pub inline fn getDescription(self: *const GpuRenderStageEvent.Specifications.DescriptionReader) []const u8 {
                return self._description orelse &[_]u8{};
            }
        };
        // fields
        context_spec: ?GpuRenderStageEvent.Specifications.ContextSpec = null,
        hw_queue: ?[]const ?GpuRenderStageEvent.Specifications.Description = null,
        stage: ?[]const ?GpuRenderStageEvent.Specifications.Description = null,
        pub fn calcProtobufSize(self: *const GpuRenderStageEvent.Specifications) usize {
            var res: usize = 0;
            if (self.context_spec) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(GpuRenderStageEvent.SpecificationsWire.CONTEXT_SPEC_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.hw_queue) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(GpuRenderStageEvent.SpecificationsWire.HW_QUEUE_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.stage) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(GpuRenderStageEvent.SpecificationsWire.STAGE_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const GpuRenderStageEvent.Specifications, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const GpuRenderStageEvent.Specifications, target: *gremlin.Writer) void {
            if (self.context_spec) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(GpuRenderStageEvent.SpecificationsWire.CONTEXT_SPEC_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.hw_queue) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(GpuRenderStageEvent.SpecificationsWire.HW_QUEUE_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(GpuRenderStageEvent.SpecificationsWire.HW_QUEUE_WIRE, 0);
                    }
                }
            }
            if (self.stage) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(GpuRenderStageEvent.SpecificationsWire.STAGE_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(GpuRenderStageEvent.SpecificationsWire.STAGE_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const SpecificationsReader = struct {
        buf: gremlin.Reader,
        _context_spec_buf: ?[]const u8 = null,
        _hw_queue_offset: ?usize = null,
        _hw_queue_last_offset: ?usize = null,
        _hw_queue_cnt: usize = 0,
        _stage_offset: ?usize = null,
        _stage_last_offset: ?usize = null,
        _stage_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!GpuRenderStageEvent.SpecificationsReader {
            const buf = gremlin.Reader.init(src);
            var res = GpuRenderStageEvent.SpecificationsReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    GpuRenderStageEvent.SpecificationsWire.CONTEXT_SPEC_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._context_spec_buf = result.value;
                    },
                    GpuRenderStageEvent.SpecificationsWire.HW_QUEUE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._hw_queue_offset == null) {
                            res._hw_queue_offset = offset - result.size;
                        }
                        res._hw_queue_last_offset = offset;
                        res._hw_queue_cnt += 1;
                    },
                    GpuRenderStageEvent.SpecificationsWire.STAGE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._stage_offset == null) {
                            res._stage_offset = offset - result.size;
                        }
                        res._stage_last_offset = offset;
                        res._stage_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn getContextSpec(self: *const GpuRenderStageEvent.SpecificationsReader) gremlin.Error!GpuRenderStageEvent.Specifications.ContextSpecReader {
            if (self._context_spec_buf) |buf| {
                return try GpuRenderStageEvent.Specifications.ContextSpecReader.init(buf);
            }
            return try GpuRenderStageEvent.Specifications.ContextSpecReader.init(&[_]u8{});
        }
        pub fn hwQueueCount(self: *const GpuRenderStageEvent.SpecificationsReader) usize {
            return self._hw_queue_cnt;
        }
        pub fn hwQueueNext(self: *GpuRenderStageEvent.SpecificationsReader) ?GpuRenderStageEvent.Specifications.DescriptionReader {
            if (self._hw_queue_offset == null) return null;
            const current_offset = self._hw_queue_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = GpuRenderStageEvent.Specifications.DescriptionReader.init(result.value) catch return null;
            if (self._hw_queue_last_offset != null and current_offset >= self._hw_queue_last_offset.?) {
                self._hw_queue_offset = null;
                return msg;
            }
            if (self._hw_queue_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._hw_queue_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == GpuRenderStageEvent.SpecificationsWire.HW_QUEUE_WIRE) {
                    self._hw_queue_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._hw_queue_offset = null;
            return msg;
        }
        pub fn stageCount(self: *const GpuRenderStageEvent.SpecificationsReader) usize {
            return self._stage_cnt;
        }
        pub fn stageNext(self: *GpuRenderStageEvent.SpecificationsReader) ?GpuRenderStageEvent.Specifications.DescriptionReader {
            if (self._stage_offset == null) return null;
            const current_offset = self._stage_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = GpuRenderStageEvent.Specifications.DescriptionReader.init(result.value) catch return null;
            if (self._stage_last_offset != null and current_offset >= self._stage_last_offset.?) {
                self._stage_offset = null;
                return msg;
            }
            if (self._stage_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._stage_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == GpuRenderStageEvent.SpecificationsWire.STAGE_WIRE) {
                    self._stage_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._stage_offset = null;
            return msg;
        }
    };
    // fields
    event_id: u64 = 0,
    duration: u64 = 0,
    hw_queue_iid: u64 = 0,
    stage_iid: u64 = 0,
    gpu_id: i32 = 0,
    context: u64 = 0,
    render_target_handle: u64 = 0,
    submission_id: u32 = 0,
    extra_data: ?[]const ?GpuRenderStageEvent.ExtraData = null,
    render_pass_handle: u64 = 0,
    render_pass_instance_id: u64 = 0,
    render_subpass_index_mask: ?[]const u64 = null,
    command_buffer_handle: u64 = 0,
    specifications: ?GpuRenderStageEvent.Specifications = null,
    hw_queue_id: i32 = 0,
    stage_id: i32 = 0,
    pub fn calcProtobufSize(self: *const GpuRenderStageEvent) usize {
        var res: usize = 0;
        if (self.event_id != 0) {
            res += gremlin.sizes.sizeWireNumber(GpuRenderStageEventWire.EVENT_ID_WIRE) + gremlin.sizes.sizeU64(self.event_id);
        }
        if (self.duration != 0) {
            res += gremlin.sizes.sizeWireNumber(GpuRenderStageEventWire.DURATION_WIRE) + gremlin.sizes.sizeU64(self.duration);
        }
        if (self.hw_queue_iid != 0) {
            res += gremlin.sizes.sizeWireNumber(GpuRenderStageEventWire.HW_QUEUE_IID_WIRE) + gremlin.sizes.sizeU64(self.hw_queue_iid);
        }
        if (self.stage_iid != 0) {
            res += gremlin.sizes.sizeWireNumber(GpuRenderStageEventWire.STAGE_IID_WIRE) + gremlin.sizes.sizeU64(self.stage_iid);
        }
        if (self.gpu_id != 0) {
            res += gremlin.sizes.sizeWireNumber(GpuRenderStageEventWire.GPU_ID_WIRE) + gremlin.sizes.sizeI32(self.gpu_id);
        }
        if (self.context != 0) {
            res += gremlin.sizes.sizeWireNumber(GpuRenderStageEventWire.CONTEXT_WIRE) + gremlin.sizes.sizeU64(self.context);
        }
        if (self.render_target_handle != 0) {
            res += gremlin.sizes.sizeWireNumber(GpuRenderStageEventWire.RENDER_TARGET_HANDLE_WIRE) + gremlin.sizes.sizeU64(self.render_target_handle);
        }
        if (self.submission_id != 0) {
            res += gremlin.sizes.sizeWireNumber(GpuRenderStageEventWire.SUBMISSION_ID_WIRE) + gremlin.sizes.sizeU32(self.submission_id);
        }
        if (self.extra_data) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(GpuRenderStageEventWire.EXTRA_DATA_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.render_pass_handle != 0) {
            res += gremlin.sizes.sizeWireNumber(GpuRenderStageEventWire.RENDER_PASS_HANDLE_WIRE) + gremlin.sizes.sizeU64(self.render_pass_handle);
        }
        if (self.render_pass_instance_id != 0) {
            res += gremlin.sizes.sizeWireNumber(GpuRenderStageEventWire.RENDER_PASS_INSTANCE_ID_WIRE) + gremlin.sizes.sizeU64(self.render_pass_instance_id);
        }
        if (self.render_subpass_index_mask) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(GpuRenderStageEventWire.RENDER_SUBPASS_INDEX_MASK_WIRE) + gremlin.sizes.sizeU64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                res += gremlin.sizes.sizeWireNumber(GpuRenderStageEventWire.RENDER_SUBPASS_INDEX_MASK_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.command_buffer_handle != 0) {
            res += gremlin.sizes.sizeWireNumber(GpuRenderStageEventWire.COMMAND_BUFFER_HANDLE_WIRE) + gremlin.sizes.sizeU64(self.command_buffer_handle);
        }
        if (self.specifications) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(GpuRenderStageEventWire.SPECIFICATIONS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.hw_queue_id != 0) {
            res += gremlin.sizes.sizeWireNumber(GpuRenderStageEventWire.HW_QUEUE_ID_WIRE) + gremlin.sizes.sizeI32(self.hw_queue_id);
        }
        if (self.stage_id != 0) {
            res += gremlin.sizes.sizeWireNumber(GpuRenderStageEventWire.STAGE_ID_WIRE) + gremlin.sizes.sizeI32(self.stage_id);
        }
        return res;
    }
    pub fn encode(self: *const GpuRenderStageEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const GpuRenderStageEvent, target: *gremlin.Writer) void {
        if (self.event_id != 0) {
            target.appendUint64(GpuRenderStageEventWire.EVENT_ID_WIRE, self.event_id);
        }
        if (self.duration != 0) {
            target.appendUint64(GpuRenderStageEventWire.DURATION_WIRE, self.duration);
        }
        if (self.hw_queue_iid != 0) {
            target.appendUint64(GpuRenderStageEventWire.HW_QUEUE_IID_WIRE, self.hw_queue_iid);
        }
        if (self.stage_iid != 0) {
            target.appendUint64(GpuRenderStageEventWire.STAGE_IID_WIRE, self.stage_iid);
        }
        if (self.gpu_id != 0) {
            target.appendInt32(GpuRenderStageEventWire.GPU_ID_WIRE, self.gpu_id);
        }
        if (self.context != 0) {
            target.appendUint64(GpuRenderStageEventWire.CONTEXT_WIRE, self.context);
        }
        if (self.render_target_handle != 0) {
            target.appendUint64(GpuRenderStageEventWire.RENDER_TARGET_HANDLE_WIRE, self.render_target_handle);
        }
        if (self.submission_id != 0) {
            target.appendUint32(GpuRenderStageEventWire.SUBMISSION_ID_WIRE, self.submission_id);
        }
        if (self.extra_data) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(GpuRenderStageEventWire.EXTRA_DATA_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(GpuRenderStageEventWire.EXTRA_DATA_WIRE, 0);
                }
            }
        }
        if (self.render_pass_handle != 0) {
            target.appendUint64(GpuRenderStageEventWire.RENDER_PASS_HANDLE_WIRE, self.render_pass_handle);
        }
        if (self.render_pass_instance_id != 0) {
            target.appendUint64(GpuRenderStageEventWire.RENDER_PASS_INSTANCE_ID_WIRE, self.render_pass_instance_id);
        }
        if (self.render_subpass_index_mask) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint64(GpuRenderStageEventWire.RENDER_SUBPASS_INDEX_MASK_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                target.appendBytesTag(GpuRenderStageEventWire.RENDER_SUBPASS_INDEX_MASK_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint64WithoutTag(v);
                }
            }
        }
        if (self.command_buffer_handle != 0) {
            target.appendUint64(GpuRenderStageEventWire.COMMAND_BUFFER_HANDLE_WIRE, self.command_buffer_handle);
        }
        if (self.specifications) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(GpuRenderStageEventWire.SPECIFICATIONS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.hw_queue_id != 0) {
            target.appendInt32(GpuRenderStageEventWire.HW_QUEUE_ID_WIRE, self.hw_queue_id);
        }
        if (self.stage_id != 0) {
            target.appendInt32(GpuRenderStageEventWire.STAGE_ID_WIRE, self.stage_id);
        }
    }
};
pub const GpuRenderStageEventReader = struct {
    buf: gremlin.Reader,
    _event_id: u64 = 0,
    _duration: u64 = 0,
    _hw_queue_iid: u64 = 0,
    _stage_iid: u64 = 0,
    _gpu_id: i32 = 0,
    _context: u64 = 0,
    _render_target_handle: u64 = 0,
    _submission_id: u32 = 0,
    _extra_data_offset: ?usize = null,
    _extra_data_last_offset: ?usize = null,
    _extra_data_cnt: usize = 0,
    _render_pass_handle: u64 = 0,
    _render_pass_instance_id: u64 = 0,
    _render_subpass_index_mask_offset: ?usize = null,
    _render_subpass_index_mask_last_offset: ?usize = null,
    _render_subpass_index_mask_packed: bool = false,
    _command_buffer_handle: u64 = 0,
    _specifications_buf: ?[]const u8 = null,
    _hw_queue_id: i32 = 0,
    _stage_id: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!GpuRenderStageEventReader {
        const buf = gremlin.Reader.init(src);
        var res = GpuRenderStageEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                GpuRenderStageEventWire.EVENT_ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._event_id = result.value;
                },
                GpuRenderStageEventWire.DURATION_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._duration = result.value;
                },
                GpuRenderStageEventWire.HW_QUEUE_IID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._hw_queue_iid = result.value;
                },
                GpuRenderStageEventWire.STAGE_IID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._stage_iid = result.value;
                },
                GpuRenderStageEventWire.GPU_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._gpu_id = result.value;
                },
                GpuRenderStageEventWire.CONTEXT_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._context = result.value;
                },
                GpuRenderStageEventWire.RENDER_TARGET_HANDLE_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._render_target_handle = result.value;
                },
                GpuRenderStageEventWire.SUBMISSION_ID_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._submission_id = result.value;
                },
                GpuRenderStageEventWire.EXTRA_DATA_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._extra_data_offset == null) {
                        res._extra_data_offset = offset - result.size;
                    }
                    res._extra_data_last_offset = offset;
                    res._extra_data_cnt += 1;
                },
                GpuRenderStageEventWire.RENDER_PASS_HANDLE_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._render_pass_handle = result.value;
                },
                GpuRenderStageEventWire.RENDER_PASS_INSTANCE_ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._render_pass_instance_id = result.value;
                },
                GpuRenderStageEventWire.RENDER_SUBPASS_INDEX_MASK_WIRE => {
                    if (res._render_subpass_index_mask_offset == null) {
                        res._render_subpass_index_mask_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._render_subpass_index_mask_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._render_subpass_index_mask_offset = offset + length_result.size;
                        res._render_subpass_index_mask_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._render_subpass_index_mask_last_offset.?;
                    } else {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._render_subpass_index_mask_last_offset = offset;
                    }
                },
                GpuRenderStageEventWire.COMMAND_BUFFER_HANDLE_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._command_buffer_handle = result.value;
                },
                GpuRenderStageEventWire.SPECIFICATIONS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._specifications_buf = result.value;
                },
                GpuRenderStageEventWire.HW_QUEUE_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._hw_queue_id = result.value;
                },
                GpuRenderStageEventWire.STAGE_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._stage_id = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getEventId(self: *const GpuRenderStageEventReader) u64 {
        return self._event_id;
    }
    pub inline fn getDuration(self: *const GpuRenderStageEventReader) u64 {
        return self._duration;
    }
    pub inline fn getHwQueueIid(self: *const GpuRenderStageEventReader) u64 {
        return self._hw_queue_iid;
    }
    pub inline fn getStageIid(self: *const GpuRenderStageEventReader) u64 {
        return self._stage_iid;
    }
    pub inline fn getGpuId(self: *const GpuRenderStageEventReader) i32 {
        return self._gpu_id;
    }
    pub inline fn getContext(self: *const GpuRenderStageEventReader) u64 {
        return self._context;
    }
    pub inline fn getRenderTargetHandle(self: *const GpuRenderStageEventReader) u64 {
        return self._render_target_handle;
    }
    pub inline fn getSubmissionId(self: *const GpuRenderStageEventReader) u32 {
        return self._submission_id;
    }
    pub fn extraDataCount(self: *const GpuRenderStageEventReader) usize {
        return self._extra_data_cnt;
    }
    pub fn extraDataNext(self: *GpuRenderStageEventReader) ?GpuRenderStageEvent.ExtraDataReader {
        if (self._extra_data_offset == null) return null;
        const current_offset = self._extra_data_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = GpuRenderStageEvent.ExtraDataReader.init(result.value) catch return null;
        if (self._extra_data_last_offset != null and current_offset >= self._extra_data_last_offset.?) {
            self._extra_data_offset = null;
            return msg;
        }
        if (self._extra_data_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._extra_data_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == GpuRenderStageEventWire.EXTRA_DATA_WIRE) {
                self._extra_data_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._extra_data_offset = null;
        return msg;
    }
    pub inline fn getRenderPassHandle(self: *const GpuRenderStageEventReader) u64 {
        return self._render_pass_handle;
    }
    pub inline fn getRenderPassInstanceId(self: *const GpuRenderStageEventReader) u64 {
        return self._render_pass_instance_id;
    }
    pub fn renderSubpassIndexMaskNext(self: *GpuRenderStageEventReader) gremlin.Error!?u64 {
        if (self._render_subpass_index_mask_offset == null) return null;
        const current_offset = self._render_subpass_index_mask_offset.?;
        if (current_offset >= self._render_subpass_index_mask_last_offset.?) {
            self._render_subpass_index_mask_offset = null;
            return null;
        }
        if (self._render_subpass_index_mask_packed) {
            const value_result = try self.buf.readUInt64(current_offset);
            self._render_subpass_index_mask_offset = current_offset + value_result.size;
            if (self._render_subpass_index_mask_offset.? >= self._render_subpass_index_mask_last_offset.?) {
                self._render_subpass_index_mask_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._render_subpass_index_mask_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == GpuRenderStageEventWire.RENDER_SUBPASS_INDEX_MASK_WIRE) {
                    self._render_subpass_index_mask_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._render_subpass_index_mask_offset = null;
            return value_result.value;
        }
    }
    pub inline fn getCommandBufferHandle(self: *const GpuRenderStageEventReader) u64 {
        return self._command_buffer_handle;
    }
    pub fn getSpecifications(self: *const GpuRenderStageEventReader) gremlin.Error!GpuRenderStageEvent.SpecificationsReader {
        if (self._specifications_buf) |buf| {
            return try GpuRenderStageEvent.SpecificationsReader.init(buf);
        }
        return try GpuRenderStageEvent.SpecificationsReader.init(&[_]u8{});
    }
    pub inline fn getHwQueueId(self: *const GpuRenderStageEventReader) i32 {
        return self._hw_queue_id;
    }
    pub inline fn getStageId(self: *const GpuRenderStageEventReader) i32 {
        return self._stage_id;
    }
};
const InternedGraphicsContextWire = struct {
    const IID_WIRE: gremlin.ProtoWireNumber = 1;
    const PID_WIRE: gremlin.ProtoWireNumber = 2;
    const API_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const InternedGraphicsContext = struct {
    // nested enums
    pub const Api = enum(i32) {
        UNDEFINED = 0,
        OPEN_GL = 1,
        VULKAN = 2,
        OPEN_CL = 3,
    };
    // fields
    iid: u64 = 0,
    pid: i32 = 0,
    api: InternedGraphicsContext.Api = @enumFromInt(0),
    pub fn calcProtobufSize(self: *const InternedGraphicsContext) usize {
        var res: usize = 0;
        if (self.iid != 0) {
            res += gremlin.sizes.sizeWireNumber(InternedGraphicsContextWire.IID_WIRE) + gremlin.sizes.sizeU64(self.iid);
        }
        if (self.pid != 0) {
            res += gremlin.sizes.sizeWireNumber(InternedGraphicsContextWire.PID_WIRE) + gremlin.sizes.sizeI32(self.pid);
        }
        if (@intFromEnum(self.api) != 0) {
            res += gremlin.sizes.sizeWireNumber(InternedGraphicsContextWire.API_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.api));
        }
        return res;
    }
    pub fn encode(self: *const InternedGraphicsContext, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const InternedGraphicsContext, target: *gremlin.Writer) void {
        if (self.iid != 0) {
            target.appendUint64(InternedGraphicsContextWire.IID_WIRE, self.iid);
        }
        if (self.pid != 0) {
            target.appendInt32(InternedGraphicsContextWire.PID_WIRE, self.pid);
        }
        if (@intFromEnum(self.api) != 0) {
            target.appendInt32(InternedGraphicsContextWire.API_WIRE, @intFromEnum(self.api));
        }
    }
};
pub const InternedGraphicsContextReader = struct {
    buf: gremlin.Reader,
    _iid: u64 = 0,
    _pid: i32 = 0,
    _api: InternedGraphicsContext.Api = @enumFromInt(0),
    pub fn init(src: []const u8) gremlin.Error!InternedGraphicsContextReader {
        const buf = gremlin.Reader.init(src);
        var res = InternedGraphicsContextReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                InternedGraphicsContextWire.IID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._iid = result.value;
                },
                InternedGraphicsContextWire.PID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._pid = result.value;
                },
                InternedGraphicsContextWire.API_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._api = @enumFromInt(result.value);
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getIid(self: *const InternedGraphicsContextReader) u64 {
        return self._iid;
    }
    pub inline fn getPid(self: *const InternedGraphicsContextReader) i32 {
        return self._pid;
    }
    pub inline fn getApi(self: *const InternedGraphicsContextReader) InternedGraphicsContext.Api {
        return self._api;
    }
};
const InternedGpuRenderStageSpecificationWire = struct {
    const IID_WIRE: gremlin.ProtoWireNumber = 1;
    const NAME_WIRE: gremlin.ProtoWireNumber = 2;
    const DESCRIPTION_WIRE: gremlin.ProtoWireNumber = 3;
    const CATEGORY_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const InternedGpuRenderStageSpecification = struct {
    // nested enums
    pub const RenderStageCategory = enum(i32) {
        OTHER = 0,
        GRAPHICS = 1,
        COMPUTE = 2,
    };
    // fields
    iid: u64 = 0,
    name: ?[]const u8 = null,
    description: ?[]const u8 = null,
    category: InternedGpuRenderStageSpecification.RenderStageCategory = @enumFromInt(0),
    pub fn calcProtobufSize(self: *const InternedGpuRenderStageSpecification) usize {
        var res: usize = 0;
        if (self.iid != 0) {
            res += gremlin.sizes.sizeWireNumber(InternedGpuRenderStageSpecificationWire.IID_WIRE) + gremlin.sizes.sizeU64(self.iid);
        }
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(InternedGpuRenderStageSpecificationWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.description) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(InternedGpuRenderStageSpecificationWire.DESCRIPTION_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (@intFromEnum(self.category) != 0) {
            res += gremlin.sizes.sizeWireNumber(InternedGpuRenderStageSpecificationWire.CATEGORY_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.category));
        }
        return res;
    }
    pub fn encode(self: *const InternedGpuRenderStageSpecification, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const InternedGpuRenderStageSpecification, target: *gremlin.Writer) void {
        if (self.iid != 0) {
            target.appendUint64(InternedGpuRenderStageSpecificationWire.IID_WIRE, self.iid);
        }
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(InternedGpuRenderStageSpecificationWire.NAME_WIRE, v);
            }
        }
        if (self.description) |v| {
            if (v.len > 0) {
                target.appendBytes(InternedGpuRenderStageSpecificationWire.DESCRIPTION_WIRE, v);
            }
        }
        if (@intFromEnum(self.category) != 0) {
            target.appendInt32(InternedGpuRenderStageSpecificationWire.CATEGORY_WIRE, @intFromEnum(self.category));
        }
    }
};
pub const InternedGpuRenderStageSpecificationReader = struct {
    buf: gremlin.Reader,
    _iid: u64 = 0,
    _name: ?[]const u8 = null,
    _description: ?[]const u8 = null,
    _category: InternedGpuRenderStageSpecification.RenderStageCategory = @enumFromInt(0),
    pub fn init(src: []const u8) gremlin.Error!InternedGpuRenderStageSpecificationReader {
        const buf = gremlin.Reader.init(src);
        var res = InternedGpuRenderStageSpecificationReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                InternedGpuRenderStageSpecificationWire.IID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._iid = result.value;
                },
                InternedGpuRenderStageSpecificationWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                InternedGpuRenderStageSpecificationWire.DESCRIPTION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._description = result.value;
                },
                InternedGpuRenderStageSpecificationWire.CATEGORY_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._category = @enumFromInt(result.value);
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getIid(self: *const InternedGpuRenderStageSpecificationReader) u64 {
        return self._iid;
    }
    pub inline fn getName(self: *const InternedGpuRenderStageSpecificationReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub inline fn getDescription(self: *const InternedGpuRenderStageSpecificationReader) []const u8 {
        return self._description orelse &[_]u8{};
    }
    pub inline fn getCategory(self: *const InternedGpuRenderStageSpecificationReader) InternedGpuRenderStageSpecification.RenderStageCategory {
        return self._category;
    }
};
