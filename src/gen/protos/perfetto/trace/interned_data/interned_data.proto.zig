// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
const track_event = @import("src/gen/protos/perfetto/trace/track_event/track_event.proto.zig");
const debug_annotation = @import("src/gen/protos/perfetto/trace/track_event/debug_annotation.proto.zig");
const source_location = @import("src/gen/protos/perfetto/trace/track_event/source_location.proto.zig");
const log_message = @import("src/gen/protos/perfetto/trace/track_event/log_message.proto.zig");
const chrome_histogram_sample = @import("src/gen/protos/perfetto/trace/track_event/chrome_histogram_sample.proto.zig");
const profile_common = @import("src/gen/protos/perfetto/trace/profiling/profile_common.proto.zig");
const gpu_render_stage_event = @import("src/gen/protos/perfetto/trace/gpu/gpu_render_stage_event.proto.zig");
const network_trace = @import("src/gen/protos/perfetto/trace/android/network_trace.proto.zig");
const v8 = @import("src/gen/protos/perfetto/trace/chrome/v8.proto.zig");
const app_wakelock_data = @import("src/gen/protos/perfetto/trace/android/app_wakelock_data.proto.zig");
// structs
const InternedDataWire = struct {
    const EVENT_CATEGORIES_WIRE: gremlin.ProtoWireNumber = 1;
    const EVENT_NAMES_WIRE: gremlin.ProtoWireNumber = 2;
    const DEBUG_ANNOTATION_NAMES_WIRE: gremlin.ProtoWireNumber = 3;
    const DEBUG_ANNOTATION_VALUE_TYPE_NAMES_WIRE: gremlin.ProtoWireNumber = 27;
    const SOURCE_LOCATIONS_WIRE: gremlin.ProtoWireNumber = 4;
    const UNSYMBOLIZED_SOURCE_LOCATIONS_WIRE: gremlin.ProtoWireNumber = 28;
    const LOG_MESSAGE_BODY_WIRE: gremlin.ProtoWireNumber = 20;
    const HISTOGRAM_NAMES_WIRE: gremlin.ProtoWireNumber = 25;
    const BUILD_IDS_WIRE: gremlin.ProtoWireNumber = 16;
    const MAPPING_PATHS_WIRE: gremlin.ProtoWireNumber = 17;
    const SOURCE_PATHS_WIRE: gremlin.ProtoWireNumber = 18;
    const FUNCTION_NAMES_WIRE: gremlin.ProtoWireNumber = 5;
    const MAPPINGS_WIRE: gremlin.ProtoWireNumber = 19;
    const FRAMES_WIRE: gremlin.ProtoWireNumber = 6;
    const CALLSTACKS_WIRE: gremlin.ProtoWireNumber = 7;
    const VULKAN_MEMORY_KEYS_WIRE: gremlin.ProtoWireNumber = 22;
    const GRAPHICS_CONTEXTS_WIRE: gremlin.ProtoWireNumber = 23;
    const GPU_SPECIFICATIONS_WIRE: gremlin.ProtoWireNumber = 24;
    const KERNEL_SYMBOLS_WIRE: gremlin.ProtoWireNumber = 26;
    const DEBUG_ANNOTATION_STRING_VALUES_WIRE: gremlin.ProtoWireNumber = 29;
    const PACKET_CONTEXT_WIRE: gremlin.ProtoWireNumber = 30;
    const V8_JS_FUNCTION_NAME_WIRE: gremlin.ProtoWireNumber = 31;
    const V8_JS_FUNCTION_WIRE: gremlin.ProtoWireNumber = 32;
    const V8_JS_SCRIPT_WIRE: gremlin.ProtoWireNumber = 33;
    const V8_WASM_SCRIPT_WIRE: gremlin.ProtoWireNumber = 34;
    const V8_ISOLATE_WIRE: gremlin.ProtoWireNumber = 35;
    const PROTOLOG_STRING_ARGS_WIRE: gremlin.ProtoWireNumber = 36;
    const PROTOLOG_STACKTRACE_WIRE: gremlin.ProtoWireNumber = 37;
    const VIEWCAPTURE_PACKAGE_NAME_WIRE: gremlin.ProtoWireNumber = 38;
    const VIEWCAPTURE_WINDOW_NAME_WIRE: gremlin.ProtoWireNumber = 39;
    const VIEWCAPTURE_VIEW_ID_WIRE: gremlin.ProtoWireNumber = 40;
    const VIEWCAPTURE_CLASS_NAME_WIRE: gremlin.ProtoWireNumber = 41;
    const APP_WAKELOCK_INFO_WIRE: gremlin.ProtoWireNumber = 42;
    const CORRELATION_ID_STR_WIRE: gremlin.ProtoWireNumber = 43;
};
pub const InternedData = struct {
    // fields
    event_categories: ?[]const ?track_event.EventCategory = null,
    event_names: ?[]const ?track_event.EventName = null,
    debug_annotation_names: ?[]const ?debug_annotation.DebugAnnotationName = null,
    debug_annotation_value_type_names: ?[]const ?debug_annotation.DebugAnnotationValueTypeName = null,
    source_locations: ?[]const ?source_location.SourceLocation = null,
    unsymbolized_source_locations: ?[]const ?source_location.UnsymbolizedSourceLocation = null,
    log_message_body: ?[]const ?log_message.LogMessageBody = null,
    histogram_names: ?[]const ?chrome_histogram_sample.HistogramName = null,
    build_ids: ?[]const ?profile_common.InternedString = null,
    mapping_paths: ?[]const ?profile_common.InternedString = null,
    source_paths: ?[]const ?profile_common.InternedString = null,
    function_names: ?[]const ?profile_common.InternedString = null,
    mappings: ?[]const ?profile_common.Mapping = null,
    frames: ?[]const ?track_event.TrackEvent.Callstack.Frame = null,
    callstacks: ?[]const ?track_event.TrackEvent.Callstack = null,
    vulkan_memory_keys: ?[]const ?profile_common.InternedString = null,
    graphics_contexts: ?[]const ?gpu_render_stage_event.InternedGraphicsContext = null,
    gpu_specifications: ?[]const ?gpu_render_stage_event.InternedGpuRenderStageSpecification = null,
    kernel_symbols: ?[]const ?profile_common.InternedString = null,
    debug_annotation_string_values: ?[]const ?profile_common.InternedString = null,
    packet_context: ?[]const ?network_trace.NetworkPacketContext = null,
    v8_js_function_name: ?[]const ?v8.InternedV8String = null,
    v8_js_function: ?[]const ?v8.InternedV8JsFunction = null,
    v8_js_script: ?[]const ?v8.InternedV8JsScript = null,
    v8_wasm_script: ?[]const ?v8.InternedV8WasmScript = null,
    v8_isolate: ?[]const ?v8.InternedV8Isolate = null,
    protolog_string_args: ?[]const ?profile_common.InternedString = null,
    protolog_stacktrace: ?[]const ?profile_common.InternedString = null,
    viewcapture_package_name: ?[]const ?profile_common.InternedString = null,
    viewcapture_window_name: ?[]const ?profile_common.InternedString = null,
    viewcapture_view_id: ?[]const ?profile_common.InternedString = null,
    viewcapture_class_name: ?[]const ?profile_common.InternedString = null,
    app_wakelock_info: ?[]const ?app_wakelock_data.AppWakelockInfo = null,
    correlation_id_str: ?[]const ?profile_common.InternedString = null,
    pub fn calcProtobufSize(self: *const InternedData) usize {
        var res: usize = 0;
        if (self.event_categories) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(InternedDataWire.EVENT_CATEGORIES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.event_names) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(InternedDataWire.EVENT_NAMES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.debug_annotation_names) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(InternedDataWire.DEBUG_ANNOTATION_NAMES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.debug_annotation_value_type_names) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(InternedDataWire.DEBUG_ANNOTATION_VALUE_TYPE_NAMES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.source_locations) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(InternedDataWire.SOURCE_LOCATIONS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.unsymbolized_source_locations) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(InternedDataWire.UNSYMBOLIZED_SOURCE_LOCATIONS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.log_message_body) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(InternedDataWire.LOG_MESSAGE_BODY_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.histogram_names) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(InternedDataWire.HISTOGRAM_NAMES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.build_ids) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(InternedDataWire.BUILD_IDS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.mapping_paths) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(InternedDataWire.MAPPING_PATHS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.source_paths) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(InternedDataWire.SOURCE_PATHS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.function_names) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(InternedDataWire.FUNCTION_NAMES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.mappings) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(InternedDataWire.MAPPINGS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.frames) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(InternedDataWire.FRAMES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.callstacks) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(InternedDataWire.CALLSTACKS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.vulkan_memory_keys) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(InternedDataWire.VULKAN_MEMORY_KEYS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.graphics_contexts) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(InternedDataWire.GRAPHICS_CONTEXTS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.gpu_specifications) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(InternedDataWire.GPU_SPECIFICATIONS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.kernel_symbols) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(InternedDataWire.KERNEL_SYMBOLS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.debug_annotation_string_values) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(InternedDataWire.DEBUG_ANNOTATION_STRING_VALUES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.packet_context) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(InternedDataWire.PACKET_CONTEXT_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.v8_js_function_name) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(InternedDataWire.V8_JS_FUNCTION_NAME_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.v8_js_function) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(InternedDataWire.V8_JS_FUNCTION_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.v8_js_script) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(InternedDataWire.V8_JS_SCRIPT_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.v8_wasm_script) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(InternedDataWire.V8_WASM_SCRIPT_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.v8_isolate) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(InternedDataWire.V8_ISOLATE_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.protolog_string_args) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(InternedDataWire.PROTOLOG_STRING_ARGS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.protolog_stacktrace) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(InternedDataWire.PROTOLOG_STACKTRACE_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.viewcapture_package_name) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(InternedDataWire.VIEWCAPTURE_PACKAGE_NAME_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.viewcapture_window_name) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(InternedDataWire.VIEWCAPTURE_WINDOW_NAME_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.viewcapture_view_id) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(InternedDataWire.VIEWCAPTURE_VIEW_ID_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.viewcapture_class_name) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(InternedDataWire.VIEWCAPTURE_CLASS_NAME_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.app_wakelock_info) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(InternedDataWire.APP_WAKELOCK_INFO_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.correlation_id_str) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(InternedDataWire.CORRELATION_ID_STR_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const InternedData, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const InternedData, target: *gremlin.Writer) void {
        if (self.event_categories) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(InternedDataWire.EVENT_CATEGORIES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(InternedDataWire.EVENT_CATEGORIES_WIRE, 0);
                }
            }
        }
        if (self.event_names) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(InternedDataWire.EVENT_NAMES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(InternedDataWire.EVENT_NAMES_WIRE, 0);
                }
            }
        }
        if (self.debug_annotation_names) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(InternedDataWire.DEBUG_ANNOTATION_NAMES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(InternedDataWire.DEBUG_ANNOTATION_NAMES_WIRE, 0);
                }
            }
        }
        if (self.debug_annotation_value_type_names) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(InternedDataWire.DEBUG_ANNOTATION_VALUE_TYPE_NAMES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(InternedDataWire.DEBUG_ANNOTATION_VALUE_TYPE_NAMES_WIRE, 0);
                }
            }
        }
        if (self.source_locations) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(InternedDataWire.SOURCE_LOCATIONS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(InternedDataWire.SOURCE_LOCATIONS_WIRE, 0);
                }
            }
        }
        if (self.unsymbolized_source_locations) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(InternedDataWire.UNSYMBOLIZED_SOURCE_LOCATIONS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(InternedDataWire.UNSYMBOLIZED_SOURCE_LOCATIONS_WIRE, 0);
                }
            }
        }
        if (self.log_message_body) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(InternedDataWire.LOG_MESSAGE_BODY_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(InternedDataWire.LOG_MESSAGE_BODY_WIRE, 0);
                }
            }
        }
        if (self.histogram_names) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(InternedDataWire.HISTOGRAM_NAMES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(InternedDataWire.HISTOGRAM_NAMES_WIRE, 0);
                }
            }
        }
        if (self.build_ids) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(InternedDataWire.BUILD_IDS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(InternedDataWire.BUILD_IDS_WIRE, 0);
                }
            }
        }
        if (self.mapping_paths) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(InternedDataWire.MAPPING_PATHS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(InternedDataWire.MAPPING_PATHS_WIRE, 0);
                }
            }
        }
        if (self.source_paths) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(InternedDataWire.SOURCE_PATHS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(InternedDataWire.SOURCE_PATHS_WIRE, 0);
                }
            }
        }
        if (self.function_names) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(InternedDataWire.FUNCTION_NAMES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(InternedDataWire.FUNCTION_NAMES_WIRE, 0);
                }
            }
        }
        if (self.mappings) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(InternedDataWire.MAPPINGS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(InternedDataWire.MAPPINGS_WIRE, 0);
                }
            }
        }
        if (self.frames) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(InternedDataWire.FRAMES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(InternedDataWire.FRAMES_WIRE, 0);
                }
            }
        }
        if (self.callstacks) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(InternedDataWire.CALLSTACKS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(InternedDataWire.CALLSTACKS_WIRE, 0);
                }
            }
        }
        if (self.vulkan_memory_keys) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(InternedDataWire.VULKAN_MEMORY_KEYS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(InternedDataWire.VULKAN_MEMORY_KEYS_WIRE, 0);
                }
            }
        }
        if (self.graphics_contexts) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(InternedDataWire.GRAPHICS_CONTEXTS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(InternedDataWire.GRAPHICS_CONTEXTS_WIRE, 0);
                }
            }
        }
        if (self.gpu_specifications) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(InternedDataWire.GPU_SPECIFICATIONS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(InternedDataWire.GPU_SPECIFICATIONS_WIRE, 0);
                }
            }
        }
        if (self.kernel_symbols) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(InternedDataWire.KERNEL_SYMBOLS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(InternedDataWire.KERNEL_SYMBOLS_WIRE, 0);
                }
            }
        }
        if (self.debug_annotation_string_values) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(InternedDataWire.DEBUG_ANNOTATION_STRING_VALUES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(InternedDataWire.DEBUG_ANNOTATION_STRING_VALUES_WIRE, 0);
                }
            }
        }
        if (self.packet_context) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(InternedDataWire.PACKET_CONTEXT_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(InternedDataWire.PACKET_CONTEXT_WIRE, 0);
                }
            }
        }
        if (self.v8_js_function_name) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(InternedDataWire.V8_JS_FUNCTION_NAME_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(InternedDataWire.V8_JS_FUNCTION_NAME_WIRE, 0);
                }
            }
        }
        if (self.v8_js_function) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(InternedDataWire.V8_JS_FUNCTION_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(InternedDataWire.V8_JS_FUNCTION_WIRE, 0);
                }
            }
        }
        if (self.v8_js_script) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(InternedDataWire.V8_JS_SCRIPT_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(InternedDataWire.V8_JS_SCRIPT_WIRE, 0);
                }
            }
        }
        if (self.v8_wasm_script) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(InternedDataWire.V8_WASM_SCRIPT_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(InternedDataWire.V8_WASM_SCRIPT_WIRE, 0);
                }
            }
        }
        if (self.v8_isolate) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(InternedDataWire.V8_ISOLATE_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(InternedDataWire.V8_ISOLATE_WIRE, 0);
                }
            }
        }
        if (self.protolog_string_args) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(InternedDataWire.PROTOLOG_STRING_ARGS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(InternedDataWire.PROTOLOG_STRING_ARGS_WIRE, 0);
                }
            }
        }
        if (self.protolog_stacktrace) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(InternedDataWire.PROTOLOG_STACKTRACE_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(InternedDataWire.PROTOLOG_STACKTRACE_WIRE, 0);
                }
            }
        }
        if (self.viewcapture_package_name) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(InternedDataWire.VIEWCAPTURE_PACKAGE_NAME_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(InternedDataWire.VIEWCAPTURE_PACKAGE_NAME_WIRE, 0);
                }
            }
        }
        if (self.viewcapture_window_name) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(InternedDataWire.VIEWCAPTURE_WINDOW_NAME_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(InternedDataWire.VIEWCAPTURE_WINDOW_NAME_WIRE, 0);
                }
            }
        }
        if (self.viewcapture_view_id) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(InternedDataWire.VIEWCAPTURE_VIEW_ID_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(InternedDataWire.VIEWCAPTURE_VIEW_ID_WIRE, 0);
                }
            }
        }
        if (self.viewcapture_class_name) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(InternedDataWire.VIEWCAPTURE_CLASS_NAME_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(InternedDataWire.VIEWCAPTURE_CLASS_NAME_WIRE, 0);
                }
            }
        }
        if (self.app_wakelock_info) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(InternedDataWire.APP_WAKELOCK_INFO_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(InternedDataWire.APP_WAKELOCK_INFO_WIRE, 0);
                }
            }
        }
        if (self.correlation_id_str) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(InternedDataWire.CORRELATION_ID_STR_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(InternedDataWire.CORRELATION_ID_STR_WIRE, 0);
                }
            }
        }
    }
};
pub const InternedDataReader = struct {
    buf: gremlin.Reader,
    _event_categories_offset: ?usize = null,
    _event_categories_last_offset: ?usize = null,
    _event_categories_cnt: usize = 0,
    _event_names_offset: ?usize = null,
    _event_names_last_offset: ?usize = null,
    _event_names_cnt: usize = 0,
    _debug_annotation_names_offset: ?usize = null,
    _debug_annotation_names_last_offset: ?usize = null,
    _debug_annotation_names_cnt: usize = 0,
    _debug_annotation_value_type_names_offset: ?usize = null,
    _debug_annotation_value_type_names_last_offset: ?usize = null,
    _debug_annotation_value_type_names_cnt: usize = 0,
    _source_locations_offset: ?usize = null,
    _source_locations_last_offset: ?usize = null,
    _source_locations_cnt: usize = 0,
    _unsymbolized_source_locations_offset: ?usize = null,
    _unsymbolized_source_locations_last_offset: ?usize = null,
    _unsymbolized_source_locations_cnt: usize = 0,
    _log_message_body_offset: ?usize = null,
    _log_message_body_last_offset: ?usize = null,
    _log_message_body_cnt: usize = 0,
    _histogram_names_offset: ?usize = null,
    _histogram_names_last_offset: ?usize = null,
    _histogram_names_cnt: usize = 0,
    _build_ids_offset: ?usize = null,
    _build_ids_last_offset: ?usize = null,
    _build_ids_cnt: usize = 0,
    _mapping_paths_offset: ?usize = null,
    _mapping_paths_last_offset: ?usize = null,
    _mapping_paths_cnt: usize = 0,
    _source_paths_offset: ?usize = null,
    _source_paths_last_offset: ?usize = null,
    _source_paths_cnt: usize = 0,
    _function_names_offset: ?usize = null,
    _function_names_last_offset: ?usize = null,
    _function_names_cnt: usize = 0,
    _mappings_offset: ?usize = null,
    _mappings_last_offset: ?usize = null,
    _mappings_cnt: usize = 0,
    _frames_offset: ?usize = null,
    _frames_last_offset: ?usize = null,
    _frames_cnt: usize = 0,
    _callstacks_offset: ?usize = null,
    _callstacks_last_offset: ?usize = null,
    _callstacks_cnt: usize = 0,
    _vulkan_memory_keys_offset: ?usize = null,
    _vulkan_memory_keys_last_offset: ?usize = null,
    _vulkan_memory_keys_cnt: usize = 0,
    _graphics_contexts_offset: ?usize = null,
    _graphics_contexts_last_offset: ?usize = null,
    _graphics_contexts_cnt: usize = 0,
    _gpu_specifications_offset: ?usize = null,
    _gpu_specifications_last_offset: ?usize = null,
    _gpu_specifications_cnt: usize = 0,
    _kernel_symbols_offset: ?usize = null,
    _kernel_symbols_last_offset: ?usize = null,
    _kernel_symbols_cnt: usize = 0,
    _debug_annotation_string_values_offset: ?usize = null,
    _debug_annotation_string_values_last_offset: ?usize = null,
    _debug_annotation_string_values_cnt: usize = 0,
    _packet_context_offset: ?usize = null,
    _packet_context_last_offset: ?usize = null,
    _packet_context_cnt: usize = 0,
    _v8_js_function_name_offset: ?usize = null,
    _v8_js_function_name_last_offset: ?usize = null,
    _v8_js_function_name_cnt: usize = 0,
    _v8_js_function_offset: ?usize = null,
    _v8_js_function_last_offset: ?usize = null,
    _v8_js_function_cnt: usize = 0,
    _v8_js_script_offset: ?usize = null,
    _v8_js_script_last_offset: ?usize = null,
    _v8_js_script_cnt: usize = 0,
    _v8_wasm_script_offset: ?usize = null,
    _v8_wasm_script_last_offset: ?usize = null,
    _v8_wasm_script_cnt: usize = 0,
    _v8_isolate_offset: ?usize = null,
    _v8_isolate_last_offset: ?usize = null,
    _v8_isolate_cnt: usize = 0,
    _protolog_string_args_offset: ?usize = null,
    _protolog_string_args_last_offset: ?usize = null,
    _protolog_string_args_cnt: usize = 0,
    _protolog_stacktrace_offset: ?usize = null,
    _protolog_stacktrace_last_offset: ?usize = null,
    _protolog_stacktrace_cnt: usize = 0,
    _viewcapture_package_name_offset: ?usize = null,
    _viewcapture_package_name_last_offset: ?usize = null,
    _viewcapture_package_name_cnt: usize = 0,
    _viewcapture_window_name_offset: ?usize = null,
    _viewcapture_window_name_last_offset: ?usize = null,
    _viewcapture_window_name_cnt: usize = 0,
    _viewcapture_view_id_offset: ?usize = null,
    _viewcapture_view_id_last_offset: ?usize = null,
    _viewcapture_view_id_cnt: usize = 0,
    _viewcapture_class_name_offset: ?usize = null,
    _viewcapture_class_name_last_offset: ?usize = null,
    _viewcapture_class_name_cnt: usize = 0,
    _app_wakelock_info_offset: ?usize = null,
    _app_wakelock_info_last_offset: ?usize = null,
    _app_wakelock_info_cnt: usize = 0,
    _correlation_id_str_offset: ?usize = null,
    _correlation_id_str_last_offset: ?usize = null,
    _correlation_id_str_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!InternedDataReader {
        const buf = gremlin.Reader.init(src);
        var res = InternedDataReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                InternedDataWire.EVENT_CATEGORIES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._event_categories_offset == null) {
                        res._event_categories_offset = offset - result.size;
                    }
                    res._event_categories_last_offset = offset;
                    res._event_categories_cnt += 1;
                },
                InternedDataWire.EVENT_NAMES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._event_names_offset == null) {
                        res._event_names_offset = offset - result.size;
                    }
                    res._event_names_last_offset = offset;
                    res._event_names_cnt += 1;
                },
                InternedDataWire.DEBUG_ANNOTATION_NAMES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._debug_annotation_names_offset == null) {
                        res._debug_annotation_names_offset = offset - result.size;
                    }
                    res._debug_annotation_names_last_offset = offset;
                    res._debug_annotation_names_cnt += 1;
                },
                InternedDataWire.DEBUG_ANNOTATION_VALUE_TYPE_NAMES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._debug_annotation_value_type_names_offset == null) {
                        res._debug_annotation_value_type_names_offset = offset - result.size;
                    }
                    res._debug_annotation_value_type_names_last_offset = offset;
                    res._debug_annotation_value_type_names_cnt += 1;
                },
                InternedDataWire.SOURCE_LOCATIONS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._source_locations_offset == null) {
                        res._source_locations_offset = offset - result.size;
                    }
                    res._source_locations_last_offset = offset;
                    res._source_locations_cnt += 1;
                },
                InternedDataWire.UNSYMBOLIZED_SOURCE_LOCATIONS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._unsymbolized_source_locations_offset == null) {
                        res._unsymbolized_source_locations_offset = offset - result.size;
                    }
                    res._unsymbolized_source_locations_last_offset = offset;
                    res._unsymbolized_source_locations_cnt += 1;
                },
                InternedDataWire.LOG_MESSAGE_BODY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._log_message_body_offset == null) {
                        res._log_message_body_offset = offset - result.size;
                    }
                    res._log_message_body_last_offset = offset;
                    res._log_message_body_cnt += 1;
                },
                InternedDataWire.HISTOGRAM_NAMES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._histogram_names_offset == null) {
                        res._histogram_names_offset = offset - result.size;
                    }
                    res._histogram_names_last_offset = offset;
                    res._histogram_names_cnt += 1;
                },
                InternedDataWire.BUILD_IDS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._build_ids_offset == null) {
                        res._build_ids_offset = offset - result.size;
                    }
                    res._build_ids_last_offset = offset;
                    res._build_ids_cnt += 1;
                },
                InternedDataWire.MAPPING_PATHS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._mapping_paths_offset == null) {
                        res._mapping_paths_offset = offset - result.size;
                    }
                    res._mapping_paths_last_offset = offset;
                    res._mapping_paths_cnt += 1;
                },
                InternedDataWire.SOURCE_PATHS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._source_paths_offset == null) {
                        res._source_paths_offset = offset - result.size;
                    }
                    res._source_paths_last_offset = offset;
                    res._source_paths_cnt += 1;
                },
                InternedDataWire.FUNCTION_NAMES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._function_names_offset == null) {
                        res._function_names_offset = offset - result.size;
                    }
                    res._function_names_last_offset = offset;
                    res._function_names_cnt += 1;
                },
                InternedDataWire.MAPPINGS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._mappings_offset == null) {
                        res._mappings_offset = offset - result.size;
                    }
                    res._mappings_last_offset = offset;
                    res._mappings_cnt += 1;
                },
                InternedDataWire.FRAMES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._frames_offset == null) {
                        res._frames_offset = offset - result.size;
                    }
                    res._frames_last_offset = offset;
                    res._frames_cnt += 1;
                },
                InternedDataWire.CALLSTACKS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._callstacks_offset == null) {
                        res._callstacks_offset = offset - result.size;
                    }
                    res._callstacks_last_offset = offset;
                    res._callstacks_cnt += 1;
                },
                InternedDataWire.VULKAN_MEMORY_KEYS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._vulkan_memory_keys_offset == null) {
                        res._vulkan_memory_keys_offset = offset - result.size;
                    }
                    res._vulkan_memory_keys_last_offset = offset;
                    res._vulkan_memory_keys_cnt += 1;
                },
                InternedDataWire.GRAPHICS_CONTEXTS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._graphics_contexts_offset == null) {
                        res._graphics_contexts_offset = offset - result.size;
                    }
                    res._graphics_contexts_last_offset = offset;
                    res._graphics_contexts_cnt += 1;
                },
                InternedDataWire.GPU_SPECIFICATIONS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._gpu_specifications_offset == null) {
                        res._gpu_specifications_offset = offset - result.size;
                    }
                    res._gpu_specifications_last_offset = offset;
                    res._gpu_specifications_cnt += 1;
                },
                InternedDataWire.KERNEL_SYMBOLS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._kernel_symbols_offset == null) {
                        res._kernel_symbols_offset = offset - result.size;
                    }
                    res._kernel_symbols_last_offset = offset;
                    res._kernel_symbols_cnt += 1;
                },
                InternedDataWire.DEBUG_ANNOTATION_STRING_VALUES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._debug_annotation_string_values_offset == null) {
                        res._debug_annotation_string_values_offset = offset - result.size;
                    }
                    res._debug_annotation_string_values_last_offset = offset;
                    res._debug_annotation_string_values_cnt += 1;
                },
                InternedDataWire.PACKET_CONTEXT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._packet_context_offset == null) {
                        res._packet_context_offset = offset - result.size;
                    }
                    res._packet_context_last_offset = offset;
                    res._packet_context_cnt += 1;
                },
                InternedDataWire.V8_JS_FUNCTION_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._v8_js_function_name_offset == null) {
                        res._v8_js_function_name_offset = offset - result.size;
                    }
                    res._v8_js_function_name_last_offset = offset;
                    res._v8_js_function_name_cnt += 1;
                },
                InternedDataWire.V8_JS_FUNCTION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._v8_js_function_offset == null) {
                        res._v8_js_function_offset = offset - result.size;
                    }
                    res._v8_js_function_last_offset = offset;
                    res._v8_js_function_cnt += 1;
                },
                InternedDataWire.V8_JS_SCRIPT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._v8_js_script_offset == null) {
                        res._v8_js_script_offset = offset - result.size;
                    }
                    res._v8_js_script_last_offset = offset;
                    res._v8_js_script_cnt += 1;
                },
                InternedDataWire.V8_WASM_SCRIPT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._v8_wasm_script_offset == null) {
                        res._v8_wasm_script_offset = offset - result.size;
                    }
                    res._v8_wasm_script_last_offset = offset;
                    res._v8_wasm_script_cnt += 1;
                },
                InternedDataWire.V8_ISOLATE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._v8_isolate_offset == null) {
                        res._v8_isolate_offset = offset - result.size;
                    }
                    res._v8_isolate_last_offset = offset;
                    res._v8_isolate_cnt += 1;
                },
                InternedDataWire.PROTOLOG_STRING_ARGS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._protolog_string_args_offset == null) {
                        res._protolog_string_args_offset = offset - result.size;
                    }
                    res._protolog_string_args_last_offset = offset;
                    res._protolog_string_args_cnt += 1;
                },
                InternedDataWire.PROTOLOG_STACKTRACE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._protolog_stacktrace_offset == null) {
                        res._protolog_stacktrace_offset = offset - result.size;
                    }
                    res._protolog_stacktrace_last_offset = offset;
                    res._protolog_stacktrace_cnt += 1;
                },
                InternedDataWire.VIEWCAPTURE_PACKAGE_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._viewcapture_package_name_offset == null) {
                        res._viewcapture_package_name_offset = offset - result.size;
                    }
                    res._viewcapture_package_name_last_offset = offset;
                    res._viewcapture_package_name_cnt += 1;
                },
                InternedDataWire.VIEWCAPTURE_WINDOW_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._viewcapture_window_name_offset == null) {
                        res._viewcapture_window_name_offset = offset - result.size;
                    }
                    res._viewcapture_window_name_last_offset = offset;
                    res._viewcapture_window_name_cnt += 1;
                },
                InternedDataWire.VIEWCAPTURE_VIEW_ID_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._viewcapture_view_id_offset == null) {
                        res._viewcapture_view_id_offset = offset - result.size;
                    }
                    res._viewcapture_view_id_last_offset = offset;
                    res._viewcapture_view_id_cnt += 1;
                },
                InternedDataWire.VIEWCAPTURE_CLASS_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._viewcapture_class_name_offset == null) {
                        res._viewcapture_class_name_offset = offset - result.size;
                    }
                    res._viewcapture_class_name_last_offset = offset;
                    res._viewcapture_class_name_cnt += 1;
                },
                InternedDataWire.APP_WAKELOCK_INFO_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._app_wakelock_info_offset == null) {
                        res._app_wakelock_info_offset = offset - result.size;
                    }
                    res._app_wakelock_info_last_offset = offset;
                    res._app_wakelock_info_cnt += 1;
                },
                InternedDataWire.CORRELATION_ID_STR_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._correlation_id_str_offset == null) {
                        res._correlation_id_str_offset = offset - result.size;
                    }
                    res._correlation_id_str_last_offset = offset;
                    res._correlation_id_str_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn eventCategoriesCount(self: *const InternedDataReader) usize {
        return self._event_categories_cnt;
    }
    pub fn eventCategoriesNext(self: *InternedDataReader) ?track_event.EventCategoryReader {
        if (self._event_categories_offset == null) return null;
        const current_offset = self._event_categories_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = track_event.EventCategoryReader.init(result.value) catch return null;
        if (self._event_categories_last_offset != null and current_offset >= self._event_categories_last_offset.?) {
            self._event_categories_offset = null;
            return msg;
        }
        if (self._event_categories_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._event_categories_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == InternedDataWire.EVENT_CATEGORIES_WIRE) {
                self._event_categories_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._event_categories_offset = null;
        return msg;
    }
    pub fn eventNamesCount(self: *const InternedDataReader) usize {
        return self._event_names_cnt;
    }
    pub fn eventNamesNext(self: *InternedDataReader) ?track_event.EventNameReader {
        if (self._event_names_offset == null) return null;
        const current_offset = self._event_names_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = track_event.EventNameReader.init(result.value) catch return null;
        if (self._event_names_last_offset != null and current_offset >= self._event_names_last_offset.?) {
            self._event_names_offset = null;
            return msg;
        }
        if (self._event_names_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._event_names_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == InternedDataWire.EVENT_NAMES_WIRE) {
                self._event_names_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._event_names_offset = null;
        return msg;
    }
    pub fn debugAnnotationNamesCount(self: *const InternedDataReader) usize {
        return self._debug_annotation_names_cnt;
    }
    pub fn debugAnnotationNamesNext(self: *InternedDataReader) ?debug_annotation.DebugAnnotationNameReader {
        if (self._debug_annotation_names_offset == null) return null;
        const current_offset = self._debug_annotation_names_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = debug_annotation.DebugAnnotationNameReader.init(result.value) catch return null;
        if (self._debug_annotation_names_last_offset != null and current_offset >= self._debug_annotation_names_last_offset.?) {
            self._debug_annotation_names_offset = null;
            return msg;
        }
        if (self._debug_annotation_names_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._debug_annotation_names_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == InternedDataWire.DEBUG_ANNOTATION_NAMES_WIRE) {
                self._debug_annotation_names_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._debug_annotation_names_offset = null;
        return msg;
    }
    pub fn debugAnnotationValueTypeNamesCount(self: *const InternedDataReader) usize {
        return self._debug_annotation_value_type_names_cnt;
    }
    pub fn debugAnnotationValueTypeNamesNext(self: *InternedDataReader) ?debug_annotation.DebugAnnotationValueTypeNameReader {
        if (self._debug_annotation_value_type_names_offset == null) return null;
        const current_offset = self._debug_annotation_value_type_names_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = debug_annotation.DebugAnnotationValueTypeNameReader.init(result.value) catch return null;
        if (self._debug_annotation_value_type_names_last_offset != null and current_offset >= self._debug_annotation_value_type_names_last_offset.?) {
            self._debug_annotation_value_type_names_offset = null;
            return msg;
        }
        if (self._debug_annotation_value_type_names_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._debug_annotation_value_type_names_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == InternedDataWire.DEBUG_ANNOTATION_VALUE_TYPE_NAMES_WIRE) {
                self._debug_annotation_value_type_names_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._debug_annotation_value_type_names_offset = null;
        return msg;
    }
    pub fn sourceLocationsCount(self: *const InternedDataReader) usize {
        return self._source_locations_cnt;
    }
    pub fn sourceLocationsNext(self: *InternedDataReader) ?source_location.SourceLocationReader {
        if (self._source_locations_offset == null) return null;
        const current_offset = self._source_locations_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = source_location.SourceLocationReader.init(result.value) catch return null;
        if (self._source_locations_last_offset != null and current_offset >= self._source_locations_last_offset.?) {
            self._source_locations_offset = null;
            return msg;
        }
        if (self._source_locations_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._source_locations_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == InternedDataWire.SOURCE_LOCATIONS_WIRE) {
                self._source_locations_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._source_locations_offset = null;
        return msg;
    }
    pub fn unsymbolizedSourceLocationsCount(self: *const InternedDataReader) usize {
        return self._unsymbolized_source_locations_cnt;
    }
    pub fn unsymbolizedSourceLocationsNext(self: *InternedDataReader) ?source_location.UnsymbolizedSourceLocationReader {
        if (self._unsymbolized_source_locations_offset == null) return null;
        const current_offset = self._unsymbolized_source_locations_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = source_location.UnsymbolizedSourceLocationReader.init(result.value) catch return null;
        if (self._unsymbolized_source_locations_last_offset != null and current_offset >= self._unsymbolized_source_locations_last_offset.?) {
            self._unsymbolized_source_locations_offset = null;
            return msg;
        }
        if (self._unsymbolized_source_locations_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._unsymbolized_source_locations_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == InternedDataWire.UNSYMBOLIZED_SOURCE_LOCATIONS_WIRE) {
                self._unsymbolized_source_locations_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._unsymbolized_source_locations_offset = null;
        return msg;
    }
    pub fn logMessageBodyCount(self: *const InternedDataReader) usize {
        return self._log_message_body_cnt;
    }
    pub fn logMessageBodyNext(self: *InternedDataReader) ?log_message.LogMessageBodyReader {
        if (self._log_message_body_offset == null) return null;
        const current_offset = self._log_message_body_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = log_message.LogMessageBodyReader.init(result.value) catch return null;
        if (self._log_message_body_last_offset != null and current_offset >= self._log_message_body_last_offset.?) {
            self._log_message_body_offset = null;
            return msg;
        }
        if (self._log_message_body_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._log_message_body_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == InternedDataWire.LOG_MESSAGE_BODY_WIRE) {
                self._log_message_body_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._log_message_body_offset = null;
        return msg;
    }
    pub fn histogramNamesCount(self: *const InternedDataReader) usize {
        return self._histogram_names_cnt;
    }
    pub fn histogramNamesNext(self: *InternedDataReader) ?chrome_histogram_sample.HistogramNameReader {
        if (self._histogram_names_offset == null) return null;
        const current_offset = self._histogram_names_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = chrome_histogram_sample.HistogramNameReader.init(result.value) catch return null;
        if (self._histogram_names_last_offset != null and current_offset >= self._histogram_names_last_offset.?) {
            self._histogram_names_offset = null;
            return msg;
        }
        if (self._histogram_names_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._histogram_names_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == InternedDataWire.HISTOGRAM_NAMES_WIRE) {
                self._histogram_names_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._histogram_names_offset = null;
        return msg;
    }
    pub fn buildIdsCount(self: *const InternedDataReader) usize {
        return self._build_ids_cnt;
    }
    pub fn buildIdsNext(self: *InternedDataReader) ?profile_common.InternedStringReader {
        if (self._build_ids_offset == null) return null;
        const current_offset = self._build_ids_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = profile_common.InternedStringReader.init(result.value) catch return null;
        if (self._build_ids_last_offset != null and current_offset >= self._build_ids_last_offset.?) {
            self._build_ids_offset = null;
            return msg;
        }
        if (self._build_ids_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._build_ids_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == InternedDataWire.BUILD_IDS_WIRE) {
                self._build_ids_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._build_ids_offset = null;
        return msg;
    }
    pub fn mappingPathsCount(self: *const InternedDataReader) usize {
        return self._mapping_paths_cnt;
    }
    pub fn mappingPathsNext(self: *InternedDataReader) ?profile_common.InternedStringReader {
        if (self._mapping_paths_offset == null) return null;
        const current_offset = self._mapping_paths_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = profile_common.InternedStringReader.init(result.value) catch return null;
        if (self._mapping_paths_last_offset != null and current_offset >= self._mapping_paths_last_offset.?) {
            self._mapping_paths_offset = null;
            return msg;
        }
        if (self._mapping_paths_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._mapping_paths_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == InternedDataWire.MAPPING_PATHS_WIRE) {
                self._mapping_paths_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._mapping_paths_offset = null;
        return msg;
    }
    pub fn sourcePathsCount(self: *const InternedDataReader) usize {
        return self._source_paths_cnt;
    }
    pub fn sourcePathsNext(self: *InternedDataReader) ?profile_common.InternedStringReader {
        if (self._source_paths_offset == null) return null;
        const current_offset = self._source_paths_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = profile_common.InternedStringReader.init(result.value) catch return null;
        if (self._source_paths_last_offset != null and current_offset >= self._source_paths_last_offset.?) {
            self._source_paths_offset = null;
            return msg;
        }
        if (self._source_paths_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._source_paths_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == InternedDataWire.SOURCE_PATHS_WIRE) {
                self._source_paths_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._source_paths_offset = null;
        return msg;
    }
    pub fn functionNamesCount(self: *const InternedDataReader) usize {
        return self._function_names_cnt;
    }
    pub fn functionNamesNext(self: *InternedDataReader) ?profile_common.InternedStringReader {
        if (self._function_names_offset == null) return null;
        const current_offset = self._function_names_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = profile_common.InternedStringReader.init(result.value) catch return null;
        if (self._function_names_last_offset != null and current_offset >= self._function_names_last_offset.?) {
            self._function_names_offset = null;
            return msg;
        }
        if (self._function_names_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._function_names_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == InternedDataWire.FUNCTION_NAMES_WIRE) {
                self._function_names_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._function_names_offset = null;
        return msg;
    }
    pub fn mappingsCount(self: *const InternedDataReader) usize {
        return self._mappings_cnt;
    }
    pub fn mappingsNext(self: *InternedDataReader) ?profile_common.MappingReader {
        if (self._mappings_offset == null) return null;
        const current_offset = self._mappings_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = profile_common.MappingReader.init(result.value) catch return null;
        if (self._mappings_last_offset != null and current_offset >= self._mappings_last_offset.?) {
            self._mappings_offset = null;
            return msg;
        }
        if (self._mappings_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._mappings_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == InternedDataWire.MAPPINGS_WIRE) {
                self._mappings_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._mappings_offset = null;
        return msg;
    }
    pub fn framesCount(self: *const InternedDataReader) usize {
        return self._frames_cnt;
    }
    pub fn framesNext(self: *InternedDataReader) ?track_event.TrackEvent.Callstack.FrameReader {
        if (self._frames_offset == null) return null;
        const current_offset = self._frames_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = track_event.TrackEvent.Callstack.FrameReader.init(result.value) catch return null;
        if (self._frames_last_offset != null and current_offset >= self._frames_last_offset.?) {
            self._frames_offset = null;
            return msg;
        }
        if (self._frames_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._frames_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == InternedDataWire.FRAMES_WIRE) {
                self._frames_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._frames_offset = null;
        return msg;
    }
    pub fn callstacksCount(self: *const InternedDataReader) usize {
        return self._callstacks_cnt;
    }
    pub fn callstacksNext(self: *InternedDataReader) ?track_event.TrackEvent.CallstackReader {
        if (self._callstacks_offset == null) return null;
        const current_offset = self._callstacks_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = track_event.TrackEvent.CallstackReader.init(result.value) catch return null;
        if (self._callstacks_last_offset != null and current_offset >= self._callstacks_last_offset.?) {
            self._callstacks_offset = null;
            return msg;
        }
        if (self._callstacks_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._callstacks_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == InternedDataWire.CALLSTACKS_WIRE) {
                self._callstacks_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._callstacks_offset = null;
        return msg;
    }
    pub fn vulkanMemoryKeysCount(self: *const InternedDataReader) usize {
        return self._vulkan_memory_keys_cnt;
    }
    pub fn vulkanMemoryKeysNext(self: *InternedDataReader) ?profile_common.InternedStringReader {
        if (self._vulkan_memory_keys_offset == null) return null;
        const current_offset = self._vulkan_memory_keys_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = profile_common.InternedStringReader.init(result.value) catch return null;
        if (self._vulkan_memory_keys_last_offset != null and current_offset >= self._vulkan_memory_keys_last_offset.?) {
            self._vulkan_memory_keys_offset = null;
            return msg;
        }
        if (self._vulkan_memory_keys_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._vulkan_memory_keys_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == InternedDataWire.VULKAN_MEMORY_KEYS_WIRE) {
                self._vulkan_memory_keys_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._vulkan_memory_keys_offset = null;
        return msg;
    }
    pub fn graphicsContextsCount(self: *const InternedDataReader) usize {
        return self._graphics_contexts_cnt;
    }
    pub fn graphicsContextsNext(self: *InternedDataReader) ?gpu_render_stage_event.InternedGraphicsContextReader {
        if (self._graphics_contexts_offset == null) return null;
        const current_offset = self._graphics_contexts_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = gpu_render_stage_event.InternedGraphicsContextReader.init(result.value) catch return null;
        if (self._graphics_contexts_last_offset != null and current_offset >= self._graphics_contexts_last_offset.?) {
            self._graphics_contexts_offset = null;
            return msg;
        }
        if (self._graphics_contexts_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._graphics_contexts_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == InternedDataWire.GRAPHICS_CONTEXTS_WIRE) {
                self._graphics_contexts_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._graphics_contexts_offset = null;
        return msg;
    }
    pub fn gpuSpecificationsCount(self: *const InternedDataReader) usize {
        return self._gpu_specifications_cnt;
    }
    pub fn gpuSpecificationsNext(self: *InternedDataReader) ?gpu_render_stage_event.InternedGpuRenderStageSpecificationReader {
        if (self._gpu_specifications_offset == null) return null;
        const current_offset = self._gpu_specifications_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = gpu_render_stage_event.InternedGpuRenderStageSpecificationReader.init(result.value) catch return null;
        if (self._gpu_specifications_last_offset != null and current_offset >= self._gpu_specifications_last_offset.?) {
            self._gpu_specifications_offset = null;
            return msg;
        }
        if (self._gpu_specifications_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._gpu_specifications_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == InternedDataWire.GPU_SPECIFICATIONS_WIRE) {
                self._gpu_specifications_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._gpu_specifications_offset = null;
        return msg;
    }
    pub fn kernelSymbolsCount(self: *const InternedDataReader) usize {
        return self._kernel_symbols_cnt;
    }
    pub fn kernelSymbolsNext(self: *InternedDataReader) ?profile_common.InternedStringReader {
        if (self._kernel_symbols_offset == null) return null;
        const current_offset = self._kernel_symbols_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = profile_common.InternedStringReader.init(result.value) catch return null;
        if (self._kernel_symbols_last_offset != null and current_offset >= self._kernel_symbols_last_offset.?) {
            self._kernel_symbols_offset = null;
            return msg;
        }
        if (self._kernel_symbols_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._kernel_symbols_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == InternedDataWire.KERNEL_SYMBOLS_WIRE) {
                self._kernel_symbols_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._kernel_symbols_offset = null;
        return msg;
    }
    pub fn debugAnnotationStringValuesCount(self: *const InternedDataReader) usize {
        return self._debug_annotation_string_values_cnt;
    }
    pub fn debugAnnotationStringValuesNext(self: *InternedDataReader) ?profile_common.InternedStringReader {
        if (self._debug_annotation_string_values_offset == null) return null;
        const current_offset = self._debug_annotation_string_values_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = profile_common.InternedStringReader.init(result.value) catch return null;
        if (self._debug_annotation_string_values_last_offset != null and current_offset >= self._debug_annotation_string_values_last_offset.?) {
            self._debug_annotation_string_values_offset = null;
            return msg;
        }
        if (self._debug_annotation_string_values_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._debug_annotation_string_values_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == InternedDataWire.DEBUG_ANNOTATION_STRING_VALUES_WIRE) {
                self._debug_annotation_string_values_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._debug_annotation_string_values_offset = null;
        return msg;
    }
    pub fn packetContextCount(self: *const InternedDataReader) usize {
        return self._packet_context_cnt;
    }
    pub fn packetContextNext(self: *InternedDataReader) ?network_trace.NetworkPacketContextReader {
        if (self._packet_context_offset == null) return null;
        const current_offset = self._packet_context_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = network_trace.NetworkPacketContextReader.init(result.value) catch return null;
        if (self._packet_context_last_offset != null and current_offset >= self._packet_context_last_offset.?) {
            self._packet_context_offset = null;
            return msg;
        }
        if (self._packet_context_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._packet_context_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == InternedDataWire.PACKET_CONTEXT_WIRE) {
                self._packet_context_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._packet_context_offset = null;
        return msg;
    }
    pub fn v8JsFunctionNameCount(self: *const InternedDataReader) usize {
        return self._v8_js_function_name_cnt;
    }
    pub fn v8JsFunctionNameNext(self: *InternedDataReader) ?v8.InternedV8StringReader {
        if (self._v8_js_function_name_offset == null) return null;
        const current_offset = self._v8_js_function_name_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = v8.InternedV8StringReader.init(result.value) catch return null;
        if (self._v8_js_function_name_last_offset != null and current_offset >= self._v8_js_function_name_last_offset.?) {
            self._v8_js_function_name_offset = null;
            return msg;
        }
        if (self._v8_js_function_name_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._v8_js_function_name_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == InternedDataWire.V8_JS_FUNCTION_NAME_WIRE) {
                self._v8_js_function_name_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._v8_js_function_name_offset = null;
        return msg;
    }
    pub fn v8JsFunctionCount(self: *const InternedDataReader) usize {
        return self._v8_js_function_cnt;
    }
    pub fn v8JsFunctionNext(self: *InternedDataReader) ?v8.InternedV8JsFunctionReader {
        if (self._v8_js_function_offset == null) return null;
        const current_offset = self._v8_js_function_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = v8.InternedV8JsFunctionReader.init(result.value) catch return null;
        if (self._v8_js_function_last_offset != null and current_offset >= self._v8_js_function_last_offset.?) {
            self._v8_js_function_offset = null;
            return msg;
        }
        if (self._v8_js_function_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._v8_js_function_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == InternedDataWire.V8_JS_FUNCTION_WIRE) {
                self._v8_js_function_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._v8_js_function_offset = null;
        return msg;
    }
    pub fn v8JsScriptCount(self: *const InternedDataReader) usize {
        return self._v8_js_script_cnt;
    }
    pub fn v8JsScriptNext(self: *InternedDataReader) ?v8.InternedV8JsScriptReader {
        if (self._v8_js_script_offset == null) return null;
        const current_offset = self._v8_js_script_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = v8.InternedV8JsScriptReader.init(result.value) catch return null;
        if (self._v8_js_script_last_offset != null and current_offset >= self._v8_js_script_last_offset.?) {
            self._v8_js_script_offset = null;
            return msg;
        }
        if (self._v8_js_script_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._v8_js_script_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == InternedDataWire.V8_JS_SCRIPT_WIRE) {
                self._v8_js_script_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._v8_js_script_offset = null;
        return msg;
    }
    pub fn v8WasmScriptCount(self: *const InternedDataReader) usize {
        return self._v8_wasm_script_cnt;
    }
    pub fn v8WasmScriptNext(self: *InternedDataReader) ?v8.InternedV8WasmScriptReader {
        if (self._v8_wasm_script_offset == null) return null;
        const current_offset = self._v8_wasm_script_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = v8.InternedV8WasmScriptReader.init(result.value) catch return null;
        if (self._v8_wasm_script_last_offset != null and current_offset >= self._v8_wasm_script_last_offset.?) {
            self._v8_wasm_script_offset = null;
            return msg;
        }
        if (self._v8_wasm_script_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._v8_wasm_script_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == InternedDataWire.V8_WASM_SCRIPT_WIRE) {
                self._v8_wasm_script_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._v8_wasm_script_offset = null;
        return msg;
    }
    pub fn v8IsolateCount(self: *const InternedDataReader) usize {
        return self._v8_isolate_cnt;
    }
    pub fn v8IsolateNext(self: *InternedDataReader) ?v8.InternedV8IsolateReader {
        if (self._v8_isolate_offset == null) return null;
        const current_offset = self._v8_isolate_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = v8.InternedV8IsolateReader.init(result.value) catch return null;
        if (self._v8_isolate_last_offset != null and current_offset >= self._v8_isolate_last_offset.?) {
            self._v8_isolate_offset = null;
            return msg;
        }
        if (self._v8_isolate_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._v8_isolate_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == InternedDataWire.V8_ISOLATE_WIRE) {
                self._v8_isolate_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._v8_isolate_offset = null;
        return msg;
    }
    pub fn protologStringArgsCount(self: *const InternedDataReader) usize {
        return self._protolog_string_args_cnt;
    }
    pub fn protologStringArgsNext(self: *InternedDataReader) ?profile_common.InternedStringReader {
        if (self._protolog_string_args_offset == null) return null;
        const current_offset = self._protolog_string_args_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = profile_common.InternedStringReader.init(result.value) catch return null;
        if (self._protolog_string_args_last_offset != null and current_offset >= self._protolog_string_args_last_offset.?) {
            self._protolog_string_args_offset = null;
            return msg;
        }
        if (self._protolog_string_args_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._protolog_string_args_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == InternedDataWire.PROTOLOG_STRING_ARGS_WIRE) {
                self._protolog_string_args_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._protolog_string_args_offset = null;
        return msg;
    }
    pub fn protologStacktraceCount(self: *const InternedDataReader) usize {
        return self._protolog_stacktrace_cnt;
    }
    pub fn protologStacktraceNext(self: *InternedDataReader) ?profile_common.InternedStringReader {
        if (self._protolog_stacktrace_offset == null) return null;
        const current_offset = self._protolog_stacktrace_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = profile_common.InternedStringReader.init(result.value) catch return null;
        if (self._protolog_stacktrace_last_offset != null and current_offset >= self._protolog_stacktrace_last_offset.?) {
            self._protolog_stacktrace_offset = null;
            return msg;
        }
        if (self._protolog_stacktrace_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._protolog_stacktrace_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == InternedDataWire.PROTOLOG_STACKTRACE_WIRE) {
                self._protolog_stacktrace_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._protolog_stacktrace_offset = null;
        return msg;
    }
    pub fn viewcapturePackageNameCount(self: *const InternedDataReader) usize {
        return self._viewcapture_package_name_cnt;
    }
    pub fn viewcapturePackageNameNext(self: *InternedDataReader) ?profile_common.InternedStringReader {
        if (self._viewcapture_package_name_offset == null) return null;
        const current_offset = self._viewcapture_package_name_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = profile_common.InternedStringReader.init(result.value) catch return null;
        if (self._viewcapture_package_name_last_offset != null and current_offset >= self._viewcapture_package_name_last_offset.?) {
            self._viewcapture_package_name_offset = null;
            return msg;
        }
        if (self._viewcapture_package_name_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._viewcapture_package_name_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == InternedDataWire.VIEWCAPTURE_PACKAGE_NAME_WIRE) {
                self._viewcapture_package_name_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._viewcapture_package_name_offset = null;
        return msg;
    }
    pub fn viewcaptureWindowNameCount(self: *const InternedDataReader) usize {
        return self._viewcapture_window_name_cnt;
    }
    pub fn viewcaptureWindowNameNext(self: *InternedDataReader) ?profile_common.InternedStringReader {
        if (self._viewcapture_window_name_offset == null) return null;
        const current_offset = self._viewcapture_window_name_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = profile_common.InternedStringReader.init(result.value) catch return null;
        if (self._viewcapture_window_name_last_offset != null and current_offset >= self._viewcapture_window_name_last_offset.?) {
            self._viewcapture_window_name_offset = null;
            return msg;
        }
        if (self._viewcapture_window_name_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._viewcapture_window_name_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == InternedDataWire.VIEWCAPTURE_WINDOW_NAME_WIRE) {
                self._viewcapture_window_name_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._viewcapture_window_name_offset = null;
        return msg;
    }
    pub fn viewcaptureViewIdCount(self: *const InternedDataReader) usize {
        return self._viewcapture_view_id_cnt;
    }
    pub fn viewcaptureViewIdNext(self: *InternedDataReader) ?profile_common.InternedStringReader {
        if (self._viewcapture_view_id_offset == null) return null;
        const current_offset = self._viewcapture_view_id_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = profile_common.InternedStringReader.init(result.value) catch return null;
        if (self._viewcapture_view_id_last_offset != null and current_offset >= self._viewcapture_view_id_last_offset.?) {
            self._viewcapture_view_id_offset = null;
            return msg;
        }
        if (self._viewcapture_view_id_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._viewcapture_view_id_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == InternedDataWire.VIEWCAPTURE_VIEW_ID_WIRE) {
                self._viewcapture_view_id_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._viewcapture_view_id_offset = null;
        return msg;
    }
    pub fn viewcaptureClassNameCount(self: *const InternedDataReader) usize {
        return self._viewcapture_class_name_cnt;
    }
    pub fn viewcaptureClassNameNext(self: *InternedDataReader) ?profile_common.InternedStringReader {
        if (self._viewcapture_class_name_offset == null) return null;
        const current_offset = self._viewcapture_class_name_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = profile_common.InternedStringReader.init(result.value) catch return null;
        if (self._viewcapture_class_name_last_offset != null and current_offset >= self._viewcapture_class_name_last_offset.?) {
            self._viewcapture_class_name_offset = null;
            return msg;
        }
        if (self._viewcapture_class_name_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._viewcapture_class_name_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == InternedDataWire.VIEWCAPTURE_CLASS_NAME_WIRE) {
                self._viewcapture_class_name_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._viewcapture_class_name_offset = null;
        return msg;
    }
    pub fn appWakelockInfoCount(self: *const InternedDataReader) usize {
        return self._app_wakelock_info_cnt;
    }
    pub fn appWakelockInfoNext(self: *InternedDataReader) ?app_wakelock_data.AppWakelockInfoReader {
        if (self._app_wakelock_info_offset == null) return null;
        const current_offset = self._app_wakelock_info_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = app_wakelock_data.AppWakelockInfoReader.init(result.value) catch return null;
        if (self._app_wakelock_info_last_offset != null and current_offset >= self._app_wakelock_info_last_offset.?) {
            self._app_wakelock_info_offset = null;
            return msg;
        }
        if (self._app_wakelock_info_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._app_wakelock_info_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == InternedDataWire.APP_WAKELOCK_INFO_WIRE) {
                self._app_wakelock_info_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._app_wakelock_info_offset = null;
        return msg;
    }
    pub fn correlationIdStrCount(self: *const InternedDataReader) usize {
        return self._correlation_id_str_cnt;
    }
    pub fn correlationIdStrNext(self: *InternedDataReader) ?profile_common.InternedStringReader {
        if (self._correlation_id_str_offset == null) return null;
        const current_offset = self._correlation_id_str_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = profile_common.InternedStringReader.init(result.value) catch return null;
        if (self._correlation_id_str_last_offset != null and current_offset >= self._correlation_id_str_last_offset.?) {
            self._correlation_id_str_offset = null;
            return msg;
        }
        if (self._correlation_id_str_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._correlation_id_str_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == InternedDataWire.CORRELATION_ID_STR_WIRE) {
                self._correlation_id_str_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._correlation_id_str_offset = null;
        return msg;
    }
};
