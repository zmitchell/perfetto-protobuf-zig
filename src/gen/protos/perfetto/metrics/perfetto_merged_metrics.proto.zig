// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const AdServicesUiMetricWire = struct {
    const COMMON_SERVICE_INITIALIZATION_LATENCY_WIRE: gremlin.ProtoWireNumber = 1;
    const COMMON_SERVICE_PERMISSION_CHECK_LATENCY_WIRE: gremlin.ProtoWireNumber = 2;
    const COMMON_SERVICE_UX_ENGINE_FLOW_LATENCY_WIRE: gremlin.ProtoWireNumber = 3;
    const MAIN_ACTIVITY_CREATION_LATENCY_WIRE: gremlin.ProtoWireNumber = 4;
    const CONSENT_MANAGER_INITIALIZATION_LATENCY_WIRE: gremlin.ProtoWireNumber = 5;
    const CONSENT_MANAGER_READ_LATENCY_WIRE: gremlin.ProtoWireNumber = 6;
    const CONSENT_MANAGER_WRITE_LATENCY_WIRE: gremlin.ProtoWireNumber = 7;
};
pub const AdServicesUiMetric = struct {
    // fields
    common_service_initialization_latency: f64 = 0.0,
    common_service_permission_check_latency: f64 = 0.0,
    common_service_ux_engine_flow_latency: f64 = 0.0,
    main_activity_creation_latency: f64 = 0.0,
    consent_manager_initialization_latency: f64 = 0.0,
    consent_manager_read_latency: f64 = 0.0,
    consent_manager_write_latency: f64 = 0.0,
    pub fn calcProtobufSize(self: *const AdServicesUiMetric) usize {
        var res: usize = 0;
        if (self.common_service_initialization_latency != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AdServicesUiMetricWire.COMMON_SERVICE_INITIALIZATION_LATENCY_WIRE) + gremlin.sizes.sizeDouble(self.common_service_initialization_latency);
        }
        if (self.common_service_permission_check_latency != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AdServicesUiMetricWire.COMMON_SERVICE_PERMISSION_CHECK_LATENCY_WIRE) + gremlin.sizes.sizeDouble(self.common_service_permission_check_latency);
        }
        if (self.common_service_ux_engine_flow_latency != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AdServicesUiMetricWire.COMMON_SERVICE_UX_ENGINE_FLOW_LATENCY_WIRE) + gremlin.sizes.sizeDouble(self.common_service_ux_engine_flow_latency);
        }
        if (self.main_activity_creation_latency != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AdServicesUiMetricWire.MAIN_ACTIVITY_CREATION_LATENCY_WIRE) + gremlin.sizes.sizeDouble(self.main_activity_creation_latency);
        }
        if (self.consent_manager_initialization_latency != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AdServicesUiMetricWire.CONSENT_MANAGER_INITIALIZATION_LATENCY_WIRE) + gremlin.sizes.sizeDouble(self.consent_manager_initialization_latency);
        }
        if (self.consent_manager_read_latency != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AdServicesUiMetricWire.CONSENT_MANAGER_READ_LATENCY_WIRE) + gremlin.sizes.sizeDouble(self.consent_manager_read_latency);
        }
        if (self.consent_manager_write_latency != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AdServicesUiMetricWire.CONSENT_MANAGER_WRITE_LATENCY_WIRE) + gremlin.sizes.sizeDouble(self.consent_manager_write_latency);
        }
        return res;
    }
    pub fn encode(self: *const AdServicesUiMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AdServicesUiMetric, target: *gremlin.Writer) void {
        if (self.common_service_initialization_latency != 0.0) {
            target.appendFloat64(AdServicesUiMetricWire.COMMON_SERVICE_INITIALIZATION_LATENCY_WIRE, self.common_service_initialization_latency);
        }
        if (self.common_service_permission_check_latency != 0.0) {
            target.appendFloat64(AdServicesUiMetricWire.COMMON_SERVICE_PERMISSION_CHECK_LATENCY_WIRE, self.common_service_permission_check_latency);
        }
        if (self.common_service_ux_engine_flow_latency != 0.0) {
            target.appendFloat64(AdServicesUiMetricWire.COMMON_SERVICE_UX_ENGINE_FLOW_LATENCY_WIRE, self.common_service_ux_engine_flow_latency);
        }
        if (self.main_activity_creation_latency != 0.0) {
            target.appendFloat64(AdServicesUiMetricWire.MAIN_ACTIVITY_CREATION_LATENCY_WIRE, self.main_activity_creation_latency);
        }
        if (self.consent_manager_initialization_latency != 0.0) {
            target.appendFloat64(AdServicesUiMetricWire.CONSENT_MANAGER_INITIALIZATION_LATENCY_WIRE, self.consent_manager_initialization_latency);
        }
        if (self.consent_manager_read_latency != 0.0) {
            target.appendFloat64(AdServicesUiMetricWire.CONSENT_MANAGER_READ_LATENCY_WIRE, self.consent_manager_read_latency);
        }
        if (self.consent_manager_write_latency != 0.0) {
            target.appendFloat64(AdServicesUiMetricWire.CONSENT_MANAGER_WRITE_LATENCY_WIRE, self.consent_manager_write_latency);
        }
    }
};
pub const AdServicesUiMetricReader = struct {
    buf: gremlin.Reader,
    _common_service_initialization_latency: f64 = 0.0,
    _common_service_permission_check_latency: f64 = 0.0,
    _common_service_ux_engine_flow_latency: f64 = 0.0,
    _main_activity_creation_latency: f64 = 0.0,
    _consent_manager_initialization_latency: f64 = 0.0,
    _consent_manager_read_latency: f64 = 0.0,
    _consent_manager_write_latency: f64 = 0.0,
    pub fn init(src: []const u8) gremlin.Error!AdServicesUiMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AdServicesUiMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AdServicesUiMetricWire.COMMON_SERVICE_INITIALIZATION_LATENCY_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._common_service_initialization_latency = result.value;
                },
                AdServicesUiMetricWire.COMMON_SERVICE_PERMISSION_CHECK_LATENCY_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._common_service_permission_check_latency = result.value;
                },
                AdServicesUiMetricWire.COMMON_SERVICE_UX_ENGINE_FLOW_LATENCY_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._common_service_ux_engine_flow_latency = result.value;
                },
                AdServicesUiMetricWire.MAIN_ACTIVITY_CREATION_LATENCY_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._main_activity_creation_latency = result.value;
                },
                AdServicesUiMetricWire.CONSENT_MANAGER_INITIALIZATION_LATENCY_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._consent_manager_initialization_latency = result.value;
                },
                AdServicesUiMetricWire.CONSENT_MANAGER_READ_LATENCY_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._consent_manager_read_latency = result.value;
                },
                AdServicesUiMetricWire.CONSENT_MANAGER_WRITE_LATENCY_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._consent_manager_write_latency = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getCommonServiceInitializationLatency(self: *const AdServicesUiMetricReader) f64 {
        return self._common_service_initialization_latency;
    }
    pub inline fn getCommonServicePermissionCheckLatency(self: *const AdServicesUiMetricReader) f64 {
        return self._common_service_permission_check_latency;
    }
    pub inline fn getCommonServiceUxEngineFlowLatency(self: *const AdServicesUiMetricReader) f64 {
        return self._common_service_ux_engine_flow_latency;
    }
    pub inline fn getMainActivityCreationLatency(self: *const AdServicesUiMetricReader) f64 {
        return self._main_activity_creation_latency;
    }
    pub inline fn getConsentManagerInitializationLatency(self: *const AdServicesUiMetricReader) f64 {
        return self._consent_manager_initialization_latency;
    }
    pub inline fn getConsentManagerReadLatency(self: *const AdServicesUiMetricReader) f64 {
        return self._consent_manager_read_latency;
    }
    pub inline fn getConsentManagerWriteLatency(self: *const AdServicesUiMetricReader) f64 {
        return self._consent_manager_write_latency;
    }
};
const AdServicesAdIdMetricWire = struct {
    const LATENCY_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const AdServicesAdIdMetric = struct {
    // fields
    latency: f64 = 0.0,
    pub fn calcProtobufSize(self: *const AdServicesAdIdMetric) usize {
        var res: usize = 0;
        if (self.latency != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AdServicesAdIdMetricWire.LATENCY_WIRE) + gremlin.sizes.sizeDouble(self.latency);
        }
        return res;
    }
    pub fn encode(self: *const AdServicesAdIdMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AdServicesAdIdMetric, target: *gremlin.Writer) void {
        if (self.latency != 0.0) {
            target.appendFloat64(AdServicesAdIdMetricWire.LATENCY_WIRE, self.latency);
        }
    }
};
pub const AdServicesAdIdMetricReader = struct {
    buf: gremlin.Reader,
    _latency: f64 = 0.0,
    pub fn init(src: []const u8) gremlin.Error!AdServicesAdIdMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AdServicesAdIdMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AdServicesAdIdMetricWire.LATENCY_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._latency = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getLatency(self: *const AdServicesAdIdMetricReader) f64 {
        return self._latency;
    }
};
const AdServicesAppSetIdMetricWire = struct {
    const LATENCY_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const AdServicesAppSetIdMetric = struct {
    // fields
    latency: f64 = 0.0,
    pub fn calcProtobufSize(self: *const AdServicesAppSetIdMetric) usize {
        var res: usize = 0;
        if (self.latency != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AdServicesAppSetIdMetricWire.LATENCY_WIRE) + gremlin.sizes.sizeDouble(self.latency);
        }
        return res;
    }
    pub fn encode(self: *const AdServicesAppSetIdMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AdServicesAppSetIdMetric, target: *gremlin.Writer) void {
        if (self.latency != 0.0) {
            target.appendFloat64(AdServicesAppSetIdMetricWire.LATENCY_WIRE, self.latency);
        }
    }
};
pub const AdServicesAppSetIdMetricReader = struct {
    buf: gremlin.Reader,
    _latency: f64 = 0.0,
    pub fn init(src: []const u8) gremlin.Error!AdServicesAppSetIdMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AdServicesAppSetIdMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AdServicesAppSetIdMetricWire.LATENCY_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._latency = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getLatency(self: *const AdServicesAppSetIdMetricReader) f64 {
        return self._latency;
    }
};
const OnDevicePersonalizationMetricWire = struct {
    const MANAGING_SERVICE_INITIALIZATION_LATENCY_WIRE: gremlin.ProtoWireNumber = 1;
    const SERVICE_DELEGATE_EXECUTE_FLOW_LATENCY_WIRE: gremlin.ProtoWireNumber = 2;
    const SERVICE_DELEGATE_REQUEST_SURFACE_PACKAGE_LATENCY_WIRE: gremlin.ProtoWireNumber = 3;
    const SERVICE_DELEGATE_REGISTER_WEB_TRIGGER_LATENCY_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const OnDevicePersonalizationMetric = struct {
    // fields
    managing_service_initialization_latency: f64 = 0.0,
    service_delegate_execute_flow_latency: f64 = 0.0,
    service_delegate_request_surface_package_latency: f64 = 0.0,
    service_delegate_register_web_trigger_latency: f64 = 0.0,
    pub fn calcProtobufSize(self: *const OnDevicePersonalizationMetric) usize {
        var res: usize = 0;
        if (self.managing_service_initialization_latency != 0.0) {
            res += gremlin.sizes.sizeWireNumber(OnDevicePersonalizationMetricWire.MANAGING_SERVICE_INITIALIZATION_LATENCY_WIRE) + gremlin.sizes.sizeDouble(self.managing_service_initialization_latency);
        }
        if (self.service_delegate_execute_flow_latency != 0.0) {
            res += gremlin.sizes.sizeWireNumber(OnDevicePersonalizationMetricWire.SERVICE_DELEGATE_EXECUTE_FLOW_LATENCY_WIRE) + gremlin.sizes.sizeDouble(self.service_delegate_execute_flow_latency);
        }
        if (self.service_delegate_request_surface_package_latency != 0.0) {
            res += gremlin.sizes.sizeWireNumber(OnDevicePersonalizationMetricWire.SERVICE_DELEGATE_REQUEST_SURFACE_PACKAGE_LATENCY_WIRE) + gremlin.sizes.sizeDouble(self.service_delegate_request_surface_package_latency);
        }
        if (self.service_delegate_register_web_trigger_latency != 0.0) {
            res += gremlin.sizes.sizeWireNumber(OnDevicePersonalizationMetricWire.SERVICE_DELEGATE_REGISTER_WEB_TRIGGER_LATENCY_WIRE) + gremlin.sizes.sizeDouble(self.service_delegate_register_web_trigger_latency);
        }
        return res;
    }
    pub fn encode(self: *const OnDevicePersonalizationMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const OnDevicePersonalizationMetric, target: *gremlin.Writer) void {
        if (self.managing_service_initialization_latency != 0.0) {
            target.appendFloat64(OnDevicePersonalizationMetricWire.MANAGING_SERVICE_INITIALIZATION_LATENCY_WIRE, self.managing_service_initialization_latency);
        }
        if (self.service_delegate_execute_flow_latency != 0.0) {
            target.appendFloat64(OnDevicePersonalizationMetricWire.SERVICE_DELEGATE_EXECUTE_FLOW_LATENCY_WIRE, self.service_delegate_execute_flow_latency);
        }
        if (self.service_delegate_request_surface_package_latency != 0.0) {
            target.appendFloat64(OnDevicePersonalizationMetricWire.SERVICE_DELEGATE_REQUEST_SURFACE_PACKAGE_LATENCY_WIRE, self.service_delegate_request_surface_package_latency);
        }
        if (self.service_delegate_register_web_trigger_latency != 0.0) {
            target.appendFloat64(OnDevicePersonalizationMetricWire.SERVICE_DELEGATE_REGISTER_WEB_TRIGGER_LATENCY_WIRE, self.service_delegate_register_web_trigger_latency);
        }
    }
};
pub const OnDevicePersonalizationMetricReader = struct {
    buf: gremlin.Reader,
    _managing_service_initialization_latency: f64 = 0.0,
    _service_delegate_execute_flow_latency: f64 = 0.0,
    _service_delegate_request_surface_package_latency: f64 = 0.0,
    _service_delegate_register_web_trigger_latency: f64 = 0.0,
    pub fn init(src: []const u8) gremlin.Error!OnDevicePersonalizationMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = OnDevicePersonalizationMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                OnDevicePersonalizationMetricWire.MANAGING_SERVICE_INITIALIZATION_LATENCY_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._managing_service_initialization_latency = result.value;
                },
                OnDevicePersonalizationMetricWire.SERVICE_DELEGATE_EXECUTE_FLOW_LATENCY_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._service_delegate_execute_flow_latency = result.value;
                },
                OnDevicePersonalizationMetricWire.SERVICE_DELEGATE_REQUEST_SURFACE_PACKAGE_LATENCY_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._service_delegate_request_surface_package_latency = result.value;
                },
                OnDevicePersonalizationMetricWire.SERVICE_DELEGATE_REGISTER_WEB_TRIGGER_LATENCY_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._service_delegate_register_web_trigger_latency = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getManagingServiceInitializationLatency(self: *const OnDevicePersonalizationMetricReader) f64 {
        return self._managing_service_initialization_latency;
    }
    pub inline fn getServiceDelegateExecuteFlowLatency(self: *const OnDevicePersonalizationMetricReader) f64 {
        return self._service_delegate_execute_flow_latency;
    }
    pub inline fn getServiceDelegateRequestSurfacePackageLatency(self: *const OnDevicePersonalizationMetricReader) f64 {
        return self._service_delegate_request_surface_package_latency;
    }
    pub inline fn getServiceDelegateRegisterWebTriggerLatency(self: *const OnDevicePersonalizationMetricReader) f64 {
        return self._service_delegate_register_web_trigger_latency;
    }
};
const AdServicesMetricWire = struct {
    const UI_METRIC_WIRE: gremlin.ProtoWireNumber = 1;
    const AD_ID_METRIC_WIRE: gremlin.ProtoWireNumber = 2;
    const APP_SET_ID_METRIC_WIRE: gremlin.ProtoWireNumber = 3;
    const ODP_METRIC_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const AdServicesMetric = struct {
    // fields
    ui_metric: ?[]const ?AdServicesUiMetric = null,
    ad_id_metric: ?[]const ?AdServicesAdIdMetric = null,
    app_set_id_metric: ?[]const ?AdServicesAppSetIdMetric = null,
    odp_metric: ?[]const ?OnDevicePersonalizationMetric = null,
    pub fn calcProtobufSize(self: *const AdServicesMetric) usize {
        var res: usize = 0;
        if (self.ui_metric) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AdServicesMetricWire.UI_METRIC_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.ad_id_metric) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AdServicesMetricWire.AD_ID_METRIC_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.app_set_id_metric) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AdServicesMetricWire.APP_SET_ID_METRIC_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.odp_metric) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AdServicesMetricWire.ODP_METRIC_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AdServicesMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AdServicesMetric, target: *gremlin.Writer) void {
        if (self.ui_metric) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AdServicesMetricWire.UI_METRIC_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AdServicesMetricWire.UI_METRIC_WIRE, 0);
                }
            }
        }
        if (self.ad_id_metric) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AdServicesMetricWire.AD_ID_METRIC_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AdServicesMetricWire.AD_ID_METRIC_WIRE, 0);
                }
            }
        }
        if (self.app_set_id_metric) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AdServicesMetricWire.APP_SET_ID_METRIC_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AdServicesMetricWire.APP_SET_ID_METRIC_WIRE, 0);
                }
            }
        }
        if (self.odp_metric) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AdServicesMetricWire.ODP_METRIC_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AdServicesMetricWire.ODP_METRIC_WIRE, 0);
                }
            }
        }
    }
};
pub const AdServicesMetricReader = struct {
    buf: gremlin.Reader,
    _ui_metric_offset: ?usize = null,
    _ui_metric_last_offset: ?usize = null,
    _ui_metric_cnt: usize = 0,
    _ad_id_metric_offset: ?usize = null,
    _ad_id_metric_last_offset: ?usize = null,
    _ad_id_metric_cnt: usize = 0,
    _app_set_id_metric_offset: ?usize = null,
    _app_set_id_metric_last_offset: ?usize = null,
    _app_set_id_metric_cnt: usize = 0,
    _odp_metric_offset: ?usize = null,
    _odp_metric_last_offset: ?usize = null,
    _odp_metric_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AdServicesMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AdServicesMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AdServicesMetricWire.UI_METRIC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._ui_metric_offset == null) {
                        res._ui_metric_offset = offset - result.size;
                    }
                    res._ui_metric_last_offset = offset;
                    res._ui_metric_cnt += 1;
                },
                AdServicesMetricWire.AD_ID_METRIC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._ad_id_metric_offset == null) {
                        res._ad_id_metric_offset = offset - result.size;
                    }
                    res._ad_id_metric_last_offset = offset;
                    res._ad_id_metric_cnt += 1;
                },
                AdServicesMetricWire.APP_SET_ID_METRIC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._app_set_id_metric_offset == null) {
                        res._app_set_id_metric_offset = offset - result.size;
                    }
                    res._app_set_id_metric_last_offset = offset;
                    res._app_set_id_metric_cnt += 1;
                },
                AdServicesMetricWire.ODP_METRIC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._odp_metric_offset == null) {
                        res._odp_metric_offset = offset - result.size;
                    }
                    res._odp_metric_last_offset = offset;
                    res._odp_metric_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn uiMetricCount(self: *const AdServicesMetricReader) usize {
        return self._ui_metric_cnt;
    }
    pub fn uiMetricNext(self: *AdServicesMetricReader) ?AdServicesUiMetricReader {
        if (self._ui_metric_offset == null) return null;
        const current_offset = self._ui_metric_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AdServicesUiMetricReader.init(result.value) catch return null;
        if (self._ui_metric_last_offset != null and current_offset >= self._ui_metric_last_offset.?) {
            self._ui_metric_offset = null;
            return msg;
        }
        if (self._ui_metric_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._ui_metric_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AdServicesMetricWire.UI_METRIC_WIRE) {
                self._ui_metric_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._ui_metric_offset = null;
        return msg;
    }
    pub fn adIdMetricCount(self: *const AdServicesMetricReader) usize {
        return self._ad_id_metric_cnt;
    }
    pub fn adIdMetricNext(self: *AdServicesMetricReader) ?AdServicesAdIdMetricReader {
        if (self._ad_id_metric_offset == null) return null;
        const current_offset = self._ad_id_metric_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AdServicesAdIdMetricReader.init(result.value) catch return null;
        if (self._ad_id_metric_last_offset != null and current_offset >= self._ad_id_metric_last_offset.?) {
            self._ad_id_metric_offset = null;
            return msg;
        }
        if (self._ad_id_metric_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._ad_id_metric_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AdServicesMetricWire.AD_ID_METRIC_WIRE) {
                self._ad_id_metric_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._ad_id_metric_offset = null;
        return msg;
    }
    pub fn appSetIdMetricCount(self: *const AdServicesMetricReader) usize {
        return self._app_set_id_metric_cnt;
    }
    pub fn appSetIdMetricNext(self: *AdServicesMetricReader) ?AdServicesAppSetIdMetricReader {
        if (self._app_set_id_metric_offset == null) return null;
        const current_offset = self._app_set_id_metric_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AdServicesAppSetIdMetricReader.init(result.value) catch return null;
        if (self._app_set_id_metric_last_offset != null and current_offset >= self._app_set_id_metric_last_offset.?) {
            self._app_set_id_metric_offset = null;
            return msg;
        }
        if (self._app_set_id_metric_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._app_set_id_metric_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AdServicesMetricWire.APP_SET_ID_METRIC_WIRE) {
                self._app_set_id_metric_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._app_set_id_metric_offset = null;
        return msg;
    }
    pub fn odpMetricCount(self: *const AdServicesMetricReader) usize {
        return self._odp_metric_cnt;
    }
    pub fn odpMetricNext(self: *AdServicesMetricReader) ?OnDevicePersonalizationMetricReader {
        if (self._odp_metric_offset == null) return null;
        const current_offset = self._odp_metric_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = OnDevicePersonalizationMetricReader.init(result.value) catch return null;
        if (self._odp_metric_last_offset != null and current_offset >= self._odp_metric_last_offset.?) {
            self._odp_metric_offset = null;
            return msg;
        }
        if (self._odp_metric_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._odp_metric_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AdServicesMetricWire.ODP_METRIC_WIRE) {
                self._odp_metric_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._odp_metric_offset = null;
        return msg;
    }
};
const AndroidAnomalyMetricWire = struct {
    const BINDER_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const AndroidAnomalyMetric = struct {
    // nested enums
    pub const Unit = enum(i32) {
        UNIT_UNSPECIFIED = 0,
        COUNT_PER_SECOND = 1,
    };
    // nested structs
    const ProcessAnomalyWire = struct {
        const PROCESS_NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const PID_WIRE: gremlin.ProtoWireNumber = 2;
        const UNIT_WIRE: gremlin.ProtoWireNumber = 3;
        const VALUE_WIRE: gremlin.ProtoWireNumber = 4;
    };
    pub const ProcessAnomaly = struct {
        // fields
        process_name: ?[]const u8 = null,
        pid: u32 = 0,
        unit: AndroidAnomalyMetric.Unit = @enumFromInt(0),
        value: u32 = 0,
        pub fn calcProtobufSize(self: *const AndroidAnomalyMetric.ProcessAnomaly) usize {
            var res: usize = 0;
            if (self.process_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidAnomalyMetric.ProcessAnomalyWire.PROCESS_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.pid != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidAnomalyMetric.ProcessAnomalyWire.PID_WIRE) + gremlin.sizes.sizeU32(self.pid);
            }
            if (@intFromEnum(self.unit) != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidAnomalyMetric.ProcessAnomalyWire.UNIT_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.unit));
            }
            if (self.value != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidAnomalyMetric.ProcessAnomalyWire.VALUE_WIRE) + gremlin.sizes.sizeU32(self.value);
            }
            return res;
        }
        pub fn encode(self: *const AndroidAnomalyMetric.ProcessAnomaly, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidAnomalyMetric.ProcessAnomaly, target: *gremlin.Writer) void {
            if (self.process_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidAnomalyMetric.ProcessAnomalyWire.PROCESS_NAME_WIRE, v);
                }
            }
            if (self.pid != 0) {
                target.appendUint32(AndroidAnomalyMetric.ProcessAnomalyWire.PID_WIRE, self.pid);
            }
            if (@intFromEnum(self.unit) != 0) {
                target.appendInt32(AndroidAnomalyMetric.ProcessAnomalyWire.UNIT_WIRE, @intFromEnum(self.unit));
            }
            if (self.value != 0) {
                target.appendUint32(AndroidAnomalyMetric.ProcessAnomalyWire.VALUE_WIRE, self.value);
            }
        }
    };
    pub const ProcessAnomalyReader = struct {
        buf: gremlin.Reader,
        _process_name: ?[]const u8 = null,
        _pid: u32 = 0,
        _unit: AndroidAnomalyMetric.Unit = @enumFromInt(0),
        _value: u32 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidAnomalyMetric.ProcessAnomalyReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidAnomalyMetric.ProcessAnomalyReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidAnomalyMetric.ProcessAnomalyWire.PROCESS_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._process_name = result.value;
                    },
                    AndroidAnomalyMetric.ProcessAnomalyWire.PID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._pid = result.value;
                    },
                    AndroidAnomalyMetric.ProcessAnomalyWire.UNIT_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._unit = @enumFromInt(result.value);
                    },
                    AndroidAnomalyMetric.ProcessAnomalyWire.VALUE_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._value = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getProcessName(self: *const AndroidAnomalyMetric.ProcessAnomalyReader) []const u8 {
            return self._process_name orelse &[_]u8{};
        }
        pub inline fn getPid(self: *const AndroidAnomalyMetric.ProcessAnomalyReader) u32 {
            return self._pid;
        }
        pub inline fn getUnit(self: *const AndroidAnomalyMetric.ProcessAnomalyReader) AndroidAnomalyMetric.Unit {
            return self._unit;
        }
        pub inline fn getValue(self: *const AndroidAnomalyMetric.ProcessAnomalyReader) u32 {
            return self._value;
        }
    };
    const BinderWire = struct {
        const MAX_INCOMING_PROCESS_COUNT_PER_SECOND_WIRE: gremlin.ProtoWireNumber = 1;
        const MAX_OUTGOING_PROCESS_COUNT_PER_SECOND_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const Binder = struct {
        // fields
        max_incoming_process_count_per_second: ?[]const ?AndroidAnomalyMetric.ProcessAnomaly = null,
        max_outgoing_process_count_per_second: ?[]const ?AndroidAnomalyMetric.ProcessAnomaly = null,
        pub fn calcProtobufSize(self: *const AndroidAnomalyMetric.Binder) usize {
            var res: usize = 0;
            if (self.max_incoming_process_count_per_second) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidAnomalyMetric.BinderWire.MAX_INCOMING_PROCESS_COUNT_PER_SECOND_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.max_outgoing_process_count_per_second) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidAnomalyMetric.BinderWire.MAX_OUTGOING_PROCESS_COUNT_PER_SECOND_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidAnomalyMetric.Binder, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidAnomalyMetric.Binder, target: *gremlin.Writer) void {
            if (self.max_incoming_process_count_per_second) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidAnomalyMetric.BinderWire.MAX_INCOMING_PROCESS_COUNT_PER_SECOND_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidAnomalyMetric.BinderWire.MAX_INCOMING_PROCESS_COUNT_PER_SECOND_WIRE, 0);
                    }
                }
            }
            if (self.max_outgoing_process_count_per_second) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidAnomalyMetric.BinderWire.MAX_OUTGOING_PROCESS_COUNT_PER_SECOND_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidAnomalyMetric.BinderWire.MAX_OUTGOING_PROCESS_COUNT_PER_SECOND_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const BinderReader = struct {
        buf: gremlin.Reader,
        _max_incoming_process_count_per_second_offset: ?usize = null,
        _max_incoming_process_count_per_second_last_offset: ?usize = null,
        _max_incoming_process_count_per_second_cnt: usize = 0,
        _max_outgoing_process_count_per_second_offset: ?usize = null,
        _max_outgoing_process_count_per_second_last_offset: ?usize = null,
        _max_outgoing_process_count_per_second_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidAnomalyMetric.BinderReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidAnomalyMetric.BinderReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidAnomalyMetric.BinderWire.MAX_INCOMING_PROCESS_COUNT_PER_SECOND_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._max_incoming_process_count_per_second_offset == null) {
                            res._max_incoming_process_count_per_second_offset = offset - result.size;
                        }
                        res._max_incoming_process_count_per_second_last_offset = offset;
                        res._max_incoming_process_count_per_second_cnt += 1;
                    },
                    AndroidAnomalyMetric.BinderWire.MAX_OUTGOING_PROCESS_COUNT_PER_SECOND_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._max_outgoing_process_count_per_second_offset == null) {
                            res._max_outgoing_process_count_per_second_offset = offset - result.size;
                        }
                        res._max_outgoing_process_count_per_second_last_offset = offset;
                        res._max_outgoing_process_count_per_second_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn maxIncomingProcessCountPerSecondCount(self: *const AndroidAnomalyMetric.BinderReader) usize {
            return self._max_incoming_process_count_per_second_cnt;
        }
        pub fn maxIncomingProcessCountPerSecondNext(self: *AndroidAnomalyMetric.BinderReader) ?AndroidAnomalyMetric.ProcessAnomalyReader {
            if (self._max_incoming_process_count_per_second_offset == null) return null;
            const current_offset = self._max_incoming_process_count_per_second_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidAnomalyMetric.ProcessAnomalyReader.init(result.value) catch return null;
            if (self._max_incoming_process_count_per_second_last_offset != null and current_offset >= self._max_incoming_process_count_per_second_last_offset.?) {
                self._max_incoming_process_count_per_second_offset = null;
                return msg;
            }
            if (self._max_incoming_process_count_per_second_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._max_incoming_process_count_per_second_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidAnomalyMetric.BinderWire.MAX_INCOMING_PROCESS_COUNT_PER_SECOND_WIRE) {
                    self._max_incoming_process_count_per_second_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._max_incoming_process_count_per_second_offset = null;
            return msg;
        }
        pub fn maxOutgoingProcessCountPerSecondCount(self: *const AndroidAnomalyMetric.BinderReader) usize {
            return self._max_outgoing_process_count_per_second_cnt;
        }
        pub fn maxOutgoingProcessCountPerSecondNext(self: *AndroidAnomalyMetric.BinderReader) ?AndroidAnomalyMetric.ProcessAnomalyReader {
            if (self._max_outgoing_process_count_per_second_offset == null) return null;
            const current_offset = self._max_outgoing_process_count_per_second_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidAnomalyMetric.ProcessAnomalyReader.init(result.value) catch return null;
            if (self._max_outgoing_process_count_per_second_last_offset != null and current_offset >= self._max_outgoing_process_count_per_second_last_offset.?) {
                self._max_outgoing_process_count_per_second_offset = null;
                return msg;
            }
            if (self._max_outgoing_process_count_per_second_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._max_outgoing_process_count_per_second_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidAnomalyMetric.BinderWire.MAX_OUTGOING_PROCESS_COUNT_PER_SECOND_WIRE) {
                    self._max_outgoing_process_count_per_second_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._max_outgoing_process_count_per_second_offset = null;
            return msg;
        }
    };
    // fields
    binder: ?AndroidAnomalyMetric.Binder = null,
    pub fn calcProtobufSize(self: *const AndroidAnomalyMetric) usize {
        var res: usize = 0;
        if (self.binder) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidAnomalyMetricWire.BINDER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidAnomalyMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidAnomalyMetric, target: *gremlin.Writer) void {
        if (self.binder) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidAnomalyMetricWire.BINDER_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const AndroidAnomalyMetricReader = struct {
    buf: gremlin.Reader,
    _binder_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!AndroidAnomalyMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidAnomalyMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidAnomalyMetricWire.BINDER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._binder_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getBinder(self: *const AndroidAnomalyMetricReader) gremlin.Error!AndroidAnomalyMetric.BinderReader {
        if (self._binder_buf) |buf| {
            return try AndroidAnomalyMetric.BinderReader.init(buf);
        }
        return try AndroidAnomalyMetric.BinderReader.init(&[_]u8{});
    }
};
const AndroidBlockingCallWire = struct {
    const NAME_WIRE: gremlin.ProtoWireNumber = 1;
    const CNT_WIRE: gremlin.ProtoWireNumber = 2;
    const TOTAL_DUR_MS_WIRE: gremlin.ProtoWireNumber = 3;
    const MAX_DUR_MS_WIRE: gremlin.ProtoWireNumber = 4;
    const MIN_DUR_MS_WIRE: gremlin.ProtoWireNumber = 5;
    const TOTAL_DUR_NS_WIRE: gremlin.ProtoWireNumber = 6;
    const MAX_DUR_NS_WIRE: gremlin.ProtoWireNumber = 7;
    const MIN_DUR_NS_WIRE: gremlin.ProtoWireNumber = 8;
    const AVG_DUR_MS_WIRE: gremlin.ProtoWireNumber = 9;
    const AVG_DUR_NS_WIRE: gremlin.ProtoWireNumber = 10;
};
pub const AndroidBlockingCall = struct {
    // fields
    name: ?[]const u8 = null,
    cnt: i64 = 0,
    total_dur_ms: i64 = 0,
    max_dur_ms: i64 = 0,
    min_dur_ms: i64 = 0,
    total_dur_ns: i64 = 0,
    max_dur_ns: i64 = 0,
    min_dur_ns: i64 = 0,
    avg_dur_ms: i64 = 0,
    avg_dur_ns: i64 = 0,
    pub fn calcProtobufSize(self: *const AndroidBlockingCall) usize {
        var res: usize = 0;
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBlockingCallWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.cnt != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidBlockingCallWire.CNT_WIRE) + gremlin.sizes.sizeI64(self.cnt);
        }
        if (self.total_dur_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidBlockingCallWire.TOTAL_DUR_MS_WIRE) + gremlin.sizes.sizeI64(self.total_dur_ms);
        }
        if (self.max_dur_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidBlockingCallWire.MAX_DUR_MS_WIRE) + gremlin.sizes.sizeI64(self.max_dur_ms);
        }
        if (self.min_dur_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidBlockingCallWire.MIN_DUR_MS_WIRE) + gremlin.sizes.sizeI64(self.min_dur_ms);
        }
        if (self.total_dur_ns != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidBlockingCallWire.TOTAL_DUR_NS_WIRE) + gremlin.sizes.sizeI64(self.total_dur_ns);
        }
        if (self.max_dur_ns != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidBlockingCallWire.MAX_DUR_NS_WIRE) + gremlin.sizes.sizeI64(self.max_dur_ns);
        }
        if (self.min_dur_ns != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidBlockingCallWire.MIN_DUR_NS_WIRE) + gremlin.sizes.sizeI64(self.min_dur_ns);
        }
        if (self.avg_dur_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidBlockingCallWire.AVG_DUR_MS_WIRE) + gremlin.sizes.sizeI64(self.avg_dur_ms);
        }
        if (self.avg_dur_ns != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidBlockingCallWire.AVG_DUR_NS_WIRE) + gremlin.sizes.sizeI64(self.avg_dur_ns);
        }
        return res;
    }
    pub fn encode(self: *const AndroidBlockingCall, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidBlockingCall, target: *gremlin.Writer) void {
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(AndroidBlockingCallWire.NAME_WIRE, v);
            }
        }
        if (self.cnt != 0) {
            target.appendInt64(AndroidBlockingCallWire.CNT_WIRE, self.cnt);
        }
        if (self.total_dur_ms != 0) {
            target.appendInt64(AndroidBlockingCallWire.TOTAL_DUR_MS_WIRE, self.total_dur_ms);
        }
        if (self.max_dur_ms != 0) {
            target.appendInt64(AndroidBlockingCallWire.MAX_DUR_MS_WIRE, self.max_dur_ms);
        }
        if (self.min_dur_ms != 0) {
            target.appendInt64(AndroidBlockingCallWire.MIN_DUR_MS_WIRE, self.min_dur_ms);
        }
        if (self.total_dur_ns != 0) {
            target.appendInt64(AndroidBlockingCallWire.TOTAL_DUR_NS_WIRE, self.total_dur_ns);
        }
        if (self.max_dur_ns != 0) {
            target.appendInt64(AndroidBlockingCallWire.MAX_DUR_NS_WIRE, self.max_dur_ns);
        }
        if (self.min_dur_ns != 0) {
            target.appendInt64(AndroidBlockingCallWire.MIN_DUR_NS_WIRE, self.min_dur_ns);
        }
        if (self.avg_dur_ms != 0) {
            target.appendInt64(AndroidBlockingCallWire.AVG_DUR_MS_WIRE, self.avg_dur_ms);
        }
        if (self.avg_dur_ns != 0) {
            target.appendInt64(AndroidBlockingCallWire.AVG_DUR_NS_WIRE, self.avg_dur_ns);
        }
    }
};
pub const AndroidBlockingCallReader = struct {
    buf: gremlin.Reader,
    _name: ?[]const u8 = null,
    _cnt: i64 = 0,
    _total_dur_ms: i64 = 0,
    _max_dur_ms: i64 = 0,
    _min_dur_ms: i64 = 0,
    _total_dur_ns: i64 = 0,
    _max_dur_ns: i64 = 0,
    _min_dur_ns: i64 = 0,
    _avg_dur_ms: i64 = 0,
    _avg_dur_ns: i64 = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidBlockingCallReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidBlockingCallReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidBlockingCallWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                AndroidBlockingCallWire.CNT_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._cnt = result.value;
                },
                AndroidBlockingCallWire.TOTAL_DUR_MS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._total_dur_ms = result.value;
                },
                AndroidBlockingCallWire.MAX_DUR_MS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._max_dur_ms = result.value;
                },
                AndroidBlockingCallWire.MIN_DUR_MS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._min_dur_ms = result.value;
                },
                AndroidBlockingCallWire.TOTAL_DUR_NS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._total_dur_ns = result.value;
                },
                AndroidBlockingCallWire.MAX_DUR_NS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._max_dur_ns = result.value;
                },
                AndroidBlockingCallWire.MIN_DUR_NS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._min_dur_ns = result.value;
                },
                AndroidBlockingCallWire.AVG_DUR_MS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._avg_dur_ms = result.value;
                },
                AndroidBlockingCallWire.AVG_DUR_NS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._avg_dur_ns = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getName(self: *const AndroidBlockingCallReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub inline fn getCnt(self: *const AndroidBlockingCallReader) i64 {
        return self._cnt;
    }
    pub inline fn getTotalDurMs(self: *const AndroidBlockingCallReader) i64 {
        return self._total_dur_ms;
    }
    pub inline fn getMaxDurMs(self: *const AndroidBlockingCallReader) i64 {
        return self._max_dur_ms;
    }
    pub inline fn getMinDurMs(self: *const AndroidBlockingCallReader) i64 {
        return self._min_dur_ms;
    }
    pub inline fn getTotalDurNs(self: *const AndroidBlockingCallReader) i64 {
        return self._total_dur_ns;
    }
    pub inline fn getMaxDurNs(self: *const AndroidBlockingCallReader) i64 {
        return self._max_dur_ns;
    }
    pub inline fn getMinDurNs(self: *const AndroidBlockingCallReader) i64 {
        return self._min_dur_ns;
    }
    pub inline fn getAvgDurMs(self: *const AndroidBlockingCallReader) i64 {
        return self._avg_dur_ms;
    }
    pub inline fn getAvgDurNs(self: *const AndroidBlockingCallReader) i64 {
        return self._avg_dur_ns;
    }
};
const AndroidProcessMetadataWire = struct {
    const NAME_WIRE: gremlin.ProtoWireNumber = 1;
    const UID_WIRE: gremlin.ProtoWireNumber = 2;
    const ANDROID_USER_ID_WIRE: gremlin.ProtoWireNumber = 10;
    const PACKAGE_WIRE: gremlin.ProtoWireNumber = 7;
    const PID_WIRE: gremlin.ProtoWireNumber = 9;
    const IS_KERNEL_TASK_WIRE: gremlin.ProtoWireNumber = 11;
};
pub const AndroidProcessMetadata = struct {
    // nested structs
    const PackageWire = struct {
        const PACKAGE_NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const APK_VERSION_CODE_WIRE: gremlin.ProtoWireNumber = 2;
        const DEBUGGABLE_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const Package = struct {
        // fields
        package_name: ?[]const u8 = null,
        apk_version_code: i64 = 0,
        debuggable: bool = false,
        pub fn calcProtobufSize(self: *const AndroidProcessMetadata.Package) usize {
            var res: usize = 0;
            if (self.package_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidProcessMetadata.PackageWire.PACKAGE_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.apk_version_code != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidProcessMetadata.PackageWire.APK_VERSION_CODE_WIRE) + gremlin.sizes.sizeI64(self.apk_version_code);
            }
            if (self.debuggable != false) {
                res += gremlin.sizes.sizeWireNumber(AndroidProcessMetadata.PackageWire.DEBUGGABLE_WIRE) + gremlin.sizes.sizeBool(self.debuggable);
            }
            return res;
        }
        pub fn encode(self: *const AndroidProcessMetadata.Package, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidProcessMetadata.Package, target: *gremlin.Writer) void {
            if (self.package_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidProcessMetadata.PackageWire.PACKAGE_NAME_WIRE, v);
                }
            }
            if (self.apk_version_code != 0) {
                target.appendInt64(AndroidProcessMetadata.PackageWire.APK_VERSION_CODE_WIRE, self.apk_version_code);
            }
            if (self.debuggable != false) {
                target.appendBool(AndroidProcessMetadata.PackageWire.DEBUGGABLE_WIRE, self.debuggable);
            }
        }
    };
    pub const PackageReader = struct {
        buf: gremlin.Reader,
        _package_name: ?[]const u8 = null,
        _apk_version_code: i64 = 0,
        _debuggable: bool = false,
        pub fn init(src: []const u8) gremlin.Error!AndroidProcessMetadata.PackageReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidProcessMetadata.PackageReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidProcessMetadata.PackageWire.PACKAGE_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._package_name = result.value;
                    },
                    AndroidProcessMetadata.PackageWire.APK_VERSION_CODE_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._apk_version_code = result.value;
                    },
                    AndroidProcessMetadata.PackageWire.DEBUGGABLE_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._debuggable = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getPackageName(self: *const AndroidProcessMetadata.PackageReader) []const u8 {
            return self._package_name orelse &[_]u8{};
        }
        pub inline fn getApkVersionCode(self: *const AndroidProcessMetadata.PackageReader) i64 {
            return self._apk_version_code;
        }
        pub inline fn getDebuggable(self: *const AndroidProcessMetadata.PackageReader) bool {
            return self._debuggable;
        }
    };
    // fields
    name: ?[]const u8 = null,
    uid: i64 = 0,
    android_user_id: i64 = 0,
    package: ?AndroidProcessMetadata.Package = null,
    pid: i64 = 0,
    is_kernel_task: bool = false,
    pub fn calcProtobufSize(self: *const AndroidProcessMetadata) usize {
        var res: usize = 0;
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidProcessMetadataWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.uid != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidProcessMetadataWire.UID_WIRE) + gremlin.sizes.sizeI64(self.uid);
        }
        if (self.android_user_id != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidProcessMetadataWire.ANDROID_USER_ID_WIRE) + gremlin.sizes.sizeI64(self.android_user_id);
        }
        if (self.package) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidProcessMetadataWire.PACKAGE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.pid != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidProcessMetadataWire.PID_WIRE) + gremlin.sizes.sizeI64(self.pid);
        }
        if (self.is_kernel_task != false) {
            res += gremlin.sizes.sizeWireNumber(AndroidProcessMetadataWire.IS_KERNEL_TASK_WIRE) + gremlin.sizes.sizeBool(self.is_kernel_task);
        }
        return res;
    }
    pub fn encode(self: *const AndroidProcessMetadata, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidProcessMetadata, target: *gremlin.Writer) void {
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(AndroidProcessMetadataWire.NAME_WIRE, v);
            }
        }
        if (self.uid != 0) {
            target.appendInt64(AndroidProcessMetadataWire.UID_WIRE, self.uid);
        }
        if (self.android_user_id != 0) {
            target.appendInt64(AndroidProcessMetadataWire.ANDROID_USER_ID_WIRE, self.android_user_id);
        }
        if (self.package) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidProcessMetadataWire.PACKAGE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.pid != 0) {
            target.appendInt64(AndroidProcessMetadataWire.PID_WIRE, self.pid);
        }
        if (self.is_kernel_task != false) {
            target.appendBool(AndroidProcessMetadataWire.IS_KERNEL_TASK_WIRE, self.is_kernel_task);
        }
    }
};
pub const AndroidProcessMetadataReader = struct {
    buf: gremlin.Reader,
    _name: ?[]const u8 = null,
    _uid: i64 = 0,
    _android_user_id: i64 = 0,
    _package_buf: ?[]const u8 = null,
    _pid: i64 = 0,
    _is_kernel_task: bool = false,
    pub fn init(src: []const u8) gremlin.Error!AndroidProcessMetadataReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidProcessMetadataReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidProcessMetadataWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                AndroidProcessMetadataWire.UID_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._uid = result.value;
                },
                AndroidProcessMetadataWire.ANDROID_USER_ID_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._android_user_id = result.value;
                },
                AndroidProcessMetadataWire.PACKAGE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._package_buf = result.value;
                },
                AndroidProcessMetadataWire.PID_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._pid = result.value;
                },
                AndroidProcessMetadataWire.IS_KERNEL_TASK_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_kernel_task = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getName(self: *const AndroidProcessMetadataReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub inline fn getUid(self: *const AndroidProcessMetadataReader) i64 {
        return self._uid;
    }
    pub inline fn getAndroidUserId(self: *const AndroidProcessMetadataReader) i64 {
        return self._android_user_id;
    }
    pub fn getPackage(self: *const AndroidProcessMetadataReader) gremlin.Error!AndroidProcessMetadata.PackageReader {
        if (self._package_buf) |buf| {
            return try AndroidProcessMetadata.PackageReader.init(buf);
        }
        return try AndroidProcessMetadata.PackageReader.init(&[_]u8{});
    }
    pub inline fn getPid(self: *const AndroidProcessMetadataReader) i64 {
        return self._pid;
    }
    pub inline fn getIsKernelTask(self: *const AndroidProcessMetadataReader) bool {
        return self._is_kernel_task;
    }
};
const AndroidBlockingCallsCujMetricWire = struct {
    const CUJ_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const AndroidBlockingCallsCujMetric = struct {
    // nested structs
    const CujWire = struct {
        const ID_WIRE: gremlin.ProtoWireNumber = 1;
        const NAME_WIRE: gremlin.ProtoWireNumber = 2;
        const PROCESS_WIRE: gremlin.ProtoWireNumber = 3;
        const TS_WIRE: gremlin.ProtoWireNumber = 4;
        const DUR_WIRE: gremlin.ProtoWireNumber = 5;
        const BLOCKING_CALLS_WIRE: gremlin.ProtoWireNumber = 6;
    };
    pub const Cuj = struct {
        // fields
        id: i32 = 0,
        name: ?[]const u8 = null,
        process: ?AndroidProcessMetadata = null,
        ts: i64 = 0,
        dur: i64 = 0,
        blocking_calls: ?[]const ?AndroidBlockingCall = null,
        pub fn calcProtobufSize(self: *const AndroidBlockingCallsCujMetric.Cuj) usize {
            var res: usize = 0;
            if (self.id != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBlockingCallsCujMetric.CujWire.ID_WIRE) + gremlin.sizes.sizeI32(self.id);
            }
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidBlockingCallsCujMetric.CujWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.process) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidBlockingCallsCujMetric.CujWire.PROCESS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.ts != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBlockingCallsCujMetric.CujWire.TS_WIRE) + gremlin.sizes.sizeI64(self.ts);
            }
            if (self.dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBlockingCallsCujMetric.CujWire.DUR_WIRE) + gremlin.sizes.sizeI64(self.dur);
            }
            if (self.blocking_calls) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidBlockingCallsCujMetric.CujWire.BLOCKING_CALLS_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidBlockingCallsCujMetric.Cuj, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidBlockingCallsCujMetric.Cuj, target: *gremlin.Writer) void {
            if (self.id != 0) {
                target.appendInt32(AndroidBlockingCallsCujMetric.CujWire.ID_WIRE, self.id);
            }
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidBlockingCallsCujMetric.CujWire.NAME_WIRE, v);
                }
            }
            if (self.process) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidBlockingCallsCujMetric.CujWire.PROCESS_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.ts != 0) {
                target.appendInt64(AndroidBlockingCallsCujMetric.CujWire.TS_WIRE, self.ts);
            }
            if (self.dur != 0) {
                target.appendInt64(AndroidBlockingCallsCujMetric.CujWire.DUR_WIRE, self.dur);
            }
            if (self.blocking_calls) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidBlockingCallsCujMetric.CujWire.BLOCKING_CALLS_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidBlockingCallsCujMetric.CujWire.BLOCKING_CALLS_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const CujReader = struct {
        buf: gremlin.Reader,
        _id: i32 = 0,
        _name: ?[]const u8 = null,
        _process_buf: ?[]const u8 = null,
        _ts: i64 = 0,
        _dur: i64 = 0,
        _blocking_calls_offset: ?usize = null,
        _blocking_calls_last_offset: ?usize = null,
        _blocking_calls_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidBlockingCallsCujMetric.CujReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidBlockingCallsCujMetric.CujReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidBlockingCallsCujMetric.CujWire.ID_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._id = result.value;
                    },
                    AndroidBlockingCallsCujMetric.CujWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    AndroidBlockingCallsCujMetric.CujWire.PROCESS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._process_buf = result.value;
                    },
                    AndroidBlockingCallsCujMetric.CujWire.TS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._ts = result.value;
                    },
                    AndroidBlockingCallsCujMetric.CujWire.DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._dur = result.value;
                    },
                    AndroidBlockingCallsCujMetric.CujWire.BLOCKING_CALLS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._blocking_calls_offset == null) {
                            res._blocking_calls_offset = offset - result.size;
                        }
                        res._blocking_calls_last_offset = offset;
                        res._blocking_calls_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getId(self: *const AndroidBlockingCallsCujMetric.CujReader) i32 {
            return self._id;
        }
        pub inline fn getName(self: *const AndroidBlockingCallsCujMetric.CujReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub fn getProcess(self: *const AndroidBlockingCallsCujMetric.CujReader) gremlin.Error!AndroidProcessMetadataReader {
            if (self._process_buf) |buf| {
                return try AndroidProcessMetadataReader.init(buf);
            }
            return try AndroidProcessMetadataReader.init(&[_]u8{});
        }
        pub inline fn getTs(self: *const AndroidBlockingCallsCujMetric.CujReader) i64 {
            return self._ts;
        }
        pub inline fn getDur(self: *const AndroidBlockingCallsCujMetric.CujReader) i64 {
            return self._dur;
        }
        pub fn blockingCallsCount(self: *const AndroidBlockingCallsCujMetric.CujReader) usize {
            return self._blocking_calls_cnt;
        }
        pub fn blockingCallsNext(self: *AndroidBlockingCallsCujMetric.CujReader) ?AndroidBlockingCallReader {
            if (self._blocking_calls_offset == null) return null;
            const current_offset = self._blocking_calls_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidBlockingCallReader.init(result.value) catch return null;
            if (self._blocking_calls_last_offset != null and current_offset >= self._blocking_calls_last_offset.?) {
                self._blocking_calls_offset = null;
                return msg;
            }
            if (self._blocking_calls_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._blocking_calls_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidBlockingCallsCujMetric.CujWire.BLOCKING_CALLS_WIRE) {
                    self._blocking_calls_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._blocking_calls_offset = null;
            return msg;
        }
    };
    // fields
    cuj: ?[]const ?AndroidBlockingCallsCujMetric.Cuj = null,
    pub fn calcProtobufSize(self: *const AndroidBlockingCallsCujMetric) usize {
        var res: usize = 0;
        if (self.cuj) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidBlockingCallsCujMetricWire.CUJ_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidBlockingCallsCujMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidBlockingCallsCujMetric, target: *gremlin.Writer) void {
        if (self.cuj) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidBlockingCallsCujMetricWire.CUJ_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidBlockingCallsCujMetricWire.CUJ_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidBlockingCallsCujMetricReader = struct {
    buf: gremlin.Reader,
    _cuj_offset: ?usize = null,
    _cuj_last_offset: ?usize = null,
    _cuj_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidBlockingCallsCujMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidBlockingCallsCujMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidBlockingCallsCujMetricWire.CUJ_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._cuj_offset == null) {
                        res._cuj_offset = offset - result.size;
                    }
                    res._cuj_last_offset = offset;
                    res._cuj_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn cujCount(self: *const AndroidBlockingCallsCujMetricReader) usize {
        return self._cuj_cnt;
    }
    pub fn cujNext(self: *AndroidBlockingCallsCujMetricReader) ?AndroidBlockingCallsCujMetric.CujReader {
        if (self._cuj_offset == null) return null;
        const current_offset = self._cuj_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidBlockingCallsCujMetric.CujReader.init(result.value) catch return null;
        if (self._cuj_last_offset != null and current_offset >= self._cuj_last_offset.?) {
            self._cuj_offset = null;
            return msg;
        }
        if (self._cuj_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._cuj_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidBlockingCallsCujMetricWire.CUJ_WIRE) {
                self._cuj_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._cuj_offset = null;
        return msg;
    }
};
const AndroidBlockingCallPerFrameWire = struct {
    const NAME_WIRE: gremlin.ProtoWireNumber = 1;
    const MAX_DUR_PER_FRAME_MS_WIRE: gremlin.ProtoWireNumber = 2;
    const MAX_DUR_PER_FRAME_NS_WIRE: gremlin.ProtoWireNumber = 3;
    const MEAN_DUR_PER_FRAME_MS_WIRE: gremlin.ProtoWireNumber = 4;
    const MEAN_DUR_PER_FRAME_NS_WIRE: gremlin.ProtoWireNumber = 5;
    const MAX_CNT_PER_FRAME_WIRE: gremlin.ProtoWireNumber = 6;
    const MEAN_CNT_PER_FRAME_WIRE: gremlin.ProtoWireNumber = 7;
};
pub const AndroidBlockingCallPerFrame = struct {
    // fields
    name: ?[]const u8 = null,
    max_dur_per_frame_ms: i64 = 0,
    max_dur_per_frame_ns: i64 = 0,
    mean_dur_per_frame_ms: i64 = 0,
    mean_dur_per_frame_ns: i64 = 0,
    max_cnt_per_frame: i64 = 0,
    mean_cnt_per_frame: f64 = 0.0,
    pub fn calcProtobufSize(self: *const AndroidBlockingCallPerFrame) usize {
        var res: usize = 0;
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBlockingCallPerFrameWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.max_dur_per_frame_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidBlockingCallPerFrameWire.MAX_DUR_PER_FRAME_MS_WIRE) + gremlin.sizes.sizeI64(self.max_dur_per_frame_ms);
        }
        if (self.max_dur_per_frame_ns != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidBlockingCallPerFrameWire.MAX_DUR_PER_FRAME_NS_WIRE) + gremlin.sizes.sizeI64(self.max_dur_per_frame_ns);
        }
        if (self.mean_dur_per_frame_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidBlockingCallPerFrameWire.MEAN_DUR_PER_FRAME_MS_WIRE) + gremlin.sizes.sizeI64(self.mean_dur_per_frame_ms);
        }
        if (self.mean_dur_per_frame_ns != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidBlockingCallPerFrameWire.MEAN_DUR_PER_FRAME_NS_WIRE) + gremlin.sizes.sizeI64(self.mean_dur_per_frame_ns);
        }
        if (self.max_cnt_per_frame != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidBlockingCallPerFrameWire.MAX_CNT_PER_FRAME_WIRE) + gremlin.sizes.sizeI64(self.max_cnt_per_frame);
        }
        if (self.mean_cnt_per_frame != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidBlockingCallPerFrameWire.MEAN_CNT_PER_FRAME_WIRE) + gremlin.sizes.sizeDouble(self.mean_cnt_per_frame);
        }
        return res;
    }
    pub fn encode(self: *const AndroidBlockingCallPerFrame, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidBlockingCallPerFrame, target: *gremlin.Writer) void {
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(AndroidBlockingCallPerFrameWire.NAME_WIRE, v);
            }
        }
        if (self.max_dur_per_frame_ms != 0) {
            target.appendInt64(AndroidBlockingCallPerFrameWire.MAX_DUR_PER_FRAME_MS_WIRE, self.max_dur_per_frame_ms);
        }
        if (self.max_dur_per_frame_ns != 0) {
            target.appendInt64(AndroidBlockingCallPerFrameWire.MAX_DUR_PER_FRAME_NS_WIRE, self.max_dur_per_frame_ns);
        }
        if (self.mean_dur_per_frame_ms != 0) {
            target.appendInt64(AndroidBlockingCallPerFrameWire.MEAN_DUR_PER_FRAME_MS_WIRE, self.mean_dur_per_frame_ms);
        }
        if (self.mean_dur_per_frame_ns != 0) {
            target.appendInt64(AndroidBlockingCallPerFrameWire.MEAN_DUR_PER_FRAME_NS_WIRE, self.mean_dur_per_frame_ns);
        }
        if (self.max_cnt_per_frame != 0) {
            target.appendInt64(AndroidBlockingCallPerFrameWire.MAX_CNT_PER_FRAME_WIRE, self.max_cnt_per_frame);
        }
        if (self.mean_cnt_per_frame != 0.0) {
            target.appendFloat64(AndroidBlockingCallPerFrameWire.MEAN_CNT_PER_FRAME_WIRE, self.mean_cnt_per_frame);
        }
    }
};
pub const AndroidBlockingCallPerFrameReader = struct {
    buf: gremlin.Reader,
    _name: ?[]const u8 = null,
    _max_dur_per_frame_ms: i64 = 0,
    _max_dur_per_frame_ns: i64 = 0,
    _mean_dur_per_frame_ms: i64 = 0,
    _mean_dur_per_frame_ns: i64 = 0,
    _max_cnt_per_frame: i64 = 0,
    _mean_cnt_per_frame: f64 = 0.0,
    pub fn init(src: []const u8) gremlin.Error!AndroidBlockingCallPerFrameReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidBlockingCallPerFrameReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidBlockingCallPerFrameWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                AndroidBlockingCallPerFrameWire.MAX_DUR_PER_FRAME_MS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._max_dur_per_frame_ms = result.value;
                },
                AndroidBlockingCallPerFrameWire.MAX_DUR_PER_FRAME_NS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._max_dur_per_frame_ns = result.value;
                },
                AndroidBlockingCallPerFrameWire.MEAN_DUR_PER_FRAME_MS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._mean_dur_per_frame_ms = result.value;
                },
                AndroidBlockingCallPerFrameWire.MEAN_DUR_PER_FRAME_NS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._mean_dur_per_frame_ns = result.value;
                },
                AndroidBlockingCallPerFrameWire.MAX_CNT_PER_FRAME_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._max_cnt_per_frame = result.value;
                },
                AndroidBlockingCallPerFrameWire.MEAN_CNT_PER_FRAME_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._mean_cnt_per_frame = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getName(self: *const AndroidBlockingCallPerFrameReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub inline fn getMaxDurPerFrameMs(self: *const AndroidBlockingCallPerFrameReader) i64 {
        return self._max_dur_per_frame_ms;
    }
    pub inline fn getMaxDurPerFrameNs(self: *const AndroidBlockingCallPerFrameReader) i64 {
        return self._max_dur_per_frame_ns;
    }
    pub inline fn getMeanDurPerFrameMs(self: *const AndroidBlockingCallPerFrameReader) i64 {
        return self._mean_dur_per_frame_ms;
    }
    pub inline fn getMeanDurPerFrameNs(self: *const AndroidBlockingCallPerFrameReader) i64 {
        return self._mean_dur_per_frame_ns;
    }
    pub inline fn getMaxCntPerFrame(self: *const AndroidBlockingCallPerFrameReader) i64 {
        return self._max_cnt_per_frame;
    }
    pub inline fn getMeanCntPerFrame(self: *const AndroidBlockingCallPerFrameReader) f64 {
        return self._mean_cnt_per_frame;
    }
};
const AndroidCujBlockingCallsPerFrameMetricWire = struct {
    const CUJ_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const AndroidCujBlockingCallsPerFrameMetric = struct {
    // nested structs
    const CujWire = struct {
        const NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const PROCESS_WIRE: gremlin.ProtoWireNumber = 2;
        const BLOCKING_CALLS_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const Cuj = struct {
        // fields
        name: ?[]const u8 = null,
        process: ?AndroidProcessMetadata = null,
        blocking_calls: ?[]const ?AndroidBlockingCallPerFrame = null,
        pub fn calcProtobufSize(self: *const AndroidCujBlockingCallsPerFrameMetric.Cuj) usize {
            var res: usize = 0;
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidCujBlockingCallsPerFrameMetric.CujWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.process) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidCujBlockingCallsPerFrameMetric.CujWire.PROCESS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.blocking_calls) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidCujBlockingCallsPerFrameMetric.CujWire.BLOCKING_CALLS_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidCujBlockingCallsPerFrameMetric.Cuj, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidCujBlockingCallsPerFrameMetric.Cuj, target: *gremlin.Writer) void {
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidCujBlockingCallsPerFrameMetric.CujWire.NAME_WIRE, v);
                }
            }
            if (self.process) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidCujBlockingCallsPerFrameMetric.CujWire.PROCESS_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.blocking_calls) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidCujBlockingCallsPerFrameMetric.CujWire.BLOCKING_CALLS_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidCujBlockingCallsPerFrameMetric.CujWire.BLOCKING_CALLS_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const CujReader = struct {
        buf: gremlin.Reader,
        _name: ?[]const u8 = null,
        _process_buf: ?[]const u8 = null,
        _blocking_calls_offset: ?usize = null,
        _blocking_calls_last_offset: ?usize = null,
        _blocking_calls_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidCujBlockingCallsPerFrameMetric.CujReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidCujBlockingCallsPerFrameMetric.CujReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidCujBlockingCallsPerFrameMetric.CujWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    AndroidCujBlockingCallsPerFrameMetric.CujWire.PROCESS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._process_buf = result.value;
                    },
                    AndroidCujBlockingCallsPerFrameMetric.CujWire.BLOCKING_CALLS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._blocking_calls_offset == null) {
                            res._blocking_calls_offset = offset - result.size;
                        }
                        res._blocking_calls_last_offset = offset;
                        res._blocking_calls_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getName(self: *const AndroidCujBlockingCallsPerFrameMetric.CujReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub fn getProcess(self: *const AndroidCujBlockingCallsPerFrameMetric.CujReader) gremlin.Error!AndroidProcessMetadataReader {
            if (self._process_buf) |buf| {
                return try AndroidProcessMetadataReader.init(buf);
            }
            return try AndroidProcessMetadataReader.init(&[_]u8{});
        }
        pub fn blockingCallsCount(self: *const AndroidCujBlockingCallsPerFrameMetric.CujReader) usize {
            return self._blocking_calls_cnt;
        }
        pub fn blockingCallsNext(self: *AndroidCujBlockingCallsPerFrameMetric.CujReader) ?AndroidBlockingCallPerFrameReader {
            if (self._blocking_calls_offset == null) return null;
            const current_offset = self._blocking_calls_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidBlockingCallPerFrameReader.init(result.value) catch return null;
            if (self._blocking_calls_last_offset != null and current_offset >= self._blocking_calls_last_offset.?) {
                self._blocking_calls_offset = null;
                return msg;
            }
            if (self._blocking_calls_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._blocking_calls_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidCujBlockingCallsPerFrameMetric.CujWire.BLOCKING_CALLS_WIRE) {
                    self._blocking_calls_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._blocking_calls_offset = null;
            return msg;
        }
    };
    // fields
    cuj: ?[]const ?AndroidCujBlockingCallsPerFrameMetric.Cuj = null,
    pub fn calcProtobufSize(self: *const AndroidCujBlockingCallsPerFrameMetric) usize {
        var res: usize = 0;
        if (self.cuj) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidCujBlockingCallsPerFrameMetricWire.CUJ_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidCujBlockingCallsPerFrameMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidCujBlockingCallsPerFrameMetric, target: *gremlin.Writer) void {
        if (self.cuj) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidCujBlockingCallsPerFrameMetricWire.CUJ_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidCujBlockingCallsPerFrameMetricWire.CUJ_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidCujBlockingCallsPerFrameMetricReader = struct {
    buf: gremlin.Reader,
    _cuj_offset: ?usize = null,
    _cuj_last_offset: ?usize = null,
    _cuj_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidCujBlockingCallsPerFrameMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidCujBlockingCallsPerFrameMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidCujBlockingCallsPerFrameMetricWire.CUJ_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._cuj_offset == null) {
                        res._cuj_offset = offset - result.size;
                    }
                    res._cuj_last_offset = offset;
                    res._cuj_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn cujCount(self: *const AndroidCujBlockingCallsPerFrameMetricReader) usize {
        return self._cuj_cnt;
    }
    pub fn cujNext(self: *AndroidCujBlockingCallsPerFrameMetricReader) ?AndroidCujBlockingCallsPerFrameMetric.CujReader {
        if (self._cuj_offset == null) return null;
        const current_offset = self._cuj_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidCujBlockingCallsPerFrameMetric.CujReader.init(result.value) catch return null;
        if (self._cuj_last_offset != null and current_offset >= self._cuj_last_offset.?) {
            self._cuj_offset = null;
            return msg;
        }
        if (self._cuj_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._cuj_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidCujBlockingCallsPerFrameMetricWire.CUJ_WIRE) {
                self._cuj_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._cuj_offset = null;
        return msg;
    }
};
const AndroidBlockingCallsUnaggWire = struct {
    const PROCESS_WITH_BLOCKING_CALLS_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const AndroidBlockingCallsUnagg = struct {
    // nested structs
    const ProcessWithBlockingCallsWire = struct {
        const PROCESS_WIRE: gremlin.ProtoWireNumber = 1;
        const BLOCKING_CALLS_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const ProcessWithBlockingCalls = struct {
        // fields
        process: ?AndroidProcessMetadata = null,
        blocking_calls: ?[]const ?AndroidBlockingCall = null,
        pub fn calcProtobufSize(self: *const AndroidBlockingCallsUnagg.ProcessWithBlockingCalls) usize {
            var res: usize = 0;
            if (self.process) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidBlockingCallsUnagg.ProcessWithBlockingCallsWire.PROCESS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.blocking_calls) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidBlockingCallsUnagg.ProcessWithBlockingCallsWire.BLOCKING_CALLS_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidBlockingCallsUnagg.ProcessWithBlockingCalls, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidBlockingCallsUnagg.ProcessWithBlockingCalls, target: *gremlin.Writer) void {
            if (self.process) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidBlockingCallsUnagg.ProcessWithBlockingCallsWire.PROCESS_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.blocking_calls) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidBlockingCallsUnagg.ProcessWithBlockingCallsWire.BLOCKING_CALLS_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidBlockingCallsUnagg.ProcessWithBlockingCallsWire.BLOCKING_CALLS_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const ProcessWithBlockingCallsReader = struct {
        buf: gremlin.Reader,
        _process_buf: ?[]const u8 = null,
        _blocking_calls_offset: ?usize = null,
        _blocking_calls_last_offset: ?usize = null,
        _blocking_calls_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidBlockingCallsUnagg.ProcessWithBlockingCallsReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidBlockingCallsUnagg.ProcessWithBlockingCallsReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidBlockingCallsUnagg.ProcessWithBlockingCallsWire.PROCESS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._process_buf = result.value;
                    },
                    AndroidBlockingCallsUnagg.ProcessWithBlockingCallsWire.BLOCKING_CALLS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._blocking_calls_offset == null) {
                            res._blocking_calls_offset = offset - result.size;
                        }
                        res._blocking_calls_last_offset = offset;
                        res._blocking_calls_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn getProcess(self: *const AndroidBlockingCallsUnagg.ProcessWithBlockingCallsReader) gremlin.Error!AndroidProcessMetadataReader {
            if (self._process_buf) |buf| {
                return try AndroidProcessMetadataReader.init(buf);
            }
            return try AndroidProcessMetadataReader.init(&[_]u8{});
        }
        pub fn blockingCallsCount(self: *const AndroidBlockingCallsUnagg.ProcessWithBlockingCallsReader) usize {
            return self._blocking_calls_cnt;
        }
        pub fn blockingCallsNext(self: *AndroidBlockingCallsUnagg.ProcessWithBlockingCallsReader) ?AndroidBlockingCallReader {
            if (self._blocking_calls_offset == null) return null;
            const current_offset = self._blocking_calls_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidBlockingCallReader.init(result.value) catch return null;
            if (self._blocking_calls_last_offset != null and current_offset >= self._blocking_calls_last_offset.?) {
                self._blocking_calls_offset = null;
                return msg;
            }
            if (self._blocking_calls_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._blocking_calls_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidBlockingCallsUnagg.ProcessWithBlockingCallsWire.BLOCKING_CALLS_WIRE) {
                    self._blocking_calls_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._blocking_calls_offset = null;
            return msg;
        }
    };
    // fields
    process_with_blocking_calls: ?[]const ?AndroidBlockingCallsUnagg.ProcessWithBlockingCalls = null,
    pub fn calcProtobufSize(self: *const AndroidBlockingCallsUnagg) usize {
        var res: usize = 0;
        if (self.process_with_blocking_calls) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidBlockingCallsUnaggWire.PROCESS_WITH_BLOCKING_CALLS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidBlockingCallsUnagg, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidBlockingCallsUnagg, target: *gremlin.Writer) void {
        if (self.process_with_blocking_calls) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidBlockingCallsUnaggWire.PROCESS_WITH_BLOCKING_CALLS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidBlockingCallsUnaggWire.PROCESS_WITH_BLOCKING_CALLS_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidBlockingCallsUnaggReader = struct {
    buf: gremlin.Reader,
    _process_with_blocking_calls_offset: ?usize = null,
    _process_with_blocking_calls_last_offset: ?usize = null,
    _process_with_blocking_calls_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidBlockingCallsUnaggReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidBlockingCallsUnaggReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidBlockingCallsUnaggWire.PROCESS_WITH_BLOCKING_CALLS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._process_with_blocking_calls_offset == null) {
                        res._process_with_blocking_calls_offset = offset - result.size;
                    }
                    res._process_with_blocking_calls_last_offset = offset;
                    res._process_with_blocking_calls_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn processWithBlockingCallsCount(self: *const AndroidBlockingCallsUnaggReader) usize {
        return self._process_with_blocking_calls_cnt;
    }
    pub fn processWithBlockingCallsNext(self: *AndroidBlockingCallsUnaggReader) ?AndroidBlockingCallsUnagg.ProcessWithBlockingCallsReader {
        if (self._process_with_blocking_calls_offset == null) return null;
        const current_offset = self._process_with_blocking_calls_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidBlockingCallsUnagg.ProcessWithBlockingCallsReader.init(result.value) catch return null;
        if (self._process_with_blocking_calls_last_offset != null and current_offset >= self._process_with_blocking_calls_last_offset.?) {
            self._process_with_blocking_calls_offset = null;
            return msg;
        }
        if (self._process_with_blocking_calls_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._process_with_blocking_calls_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidBlockingCallsUnaggWire.PROCESS_WITH_BLOCKING_CALLS_WIRE) {
                self._process_with_blocking_calls_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._process_with_blocking_calls_offset = null;
        return msg;
    }
};
const ProcessStateDurationsWire = struct {
    const TOTAL_DUR_WIRE: gremlin.ProtoWireNumber = 2;
    const UNINTERRUPTIBLE_SLEEP_DUR_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const ProcessStateDurations = struct {
    // fields
    total_dur: i64 = 0,
    uninterruptible_sleep_dur: i64 = 0,
    pub fn calcProtobufSize(self: *const ProcessStateDurations) usize {
        var res: usize = 0;
        if (self.total_dur != 0) {
            res += gremlin.sizes.sizeWireNumber(ProcessStateDurationsWire.TOTAL_DUR_WIRE) + gremlin.sizes.sizeI64(self.total_dur);
        }
        if (self.uninterruptible_sleep_dur != 0) {
            res += gremlin.sizes.sizeWireNumber(ProcessStateDurationsWire.UNINTERRUPTIBLE_SLEEP_DUR_WIRE) + gremlin.sizes.sizeI64(self.uninterruptible_sleep_dur);
        }
        return res;
    }
    pub fn encode(self: *const ProcessStateDurations, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ProcessStateDurations, target: *gremlin.Writer) void {
        if (self.total_dur != 0) {
            target.appendInt64(ProcessStateDurationsWire.TOTAL_DUR_WIRE, self.total_dur);
        }
        if (self.uninterruptible_sleep_dur != 0) {
            target.appendInt64(ProcessStateDurationsWire.UNINTERRUPTIBLE_SLEEP_DUR_WIRE, self.uninterruptible_sleep_dur);
        }
    }
};
pub const ProcessStateDurationsReader = struct {
    buf: gremlin.Reader,
    _total_dur: i64 = 0,
    _uninterruptible_sleep_dur: i64 = 0,
    pub fn init(src: []const u8) gremlin.Error!ProcessStateDurationsReader {
        const buf = gremlin.Reader.init(src);
        var res = ProcessStateDurationsReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ProcessStateDurationsWire.TOTAL_DUR_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._total_dur = result.value;
                },
                ProcessStateDurationsWire.UNINTERRUPTIBLE_SLEEP_DUR_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._uninterruptible_sleep_dur = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getTotalDur(self: *const ProcessStateDurationsReader) i64 {
        return self._total_dur;
    }
    pub inline fn getUninterruptibleSleepDur(self: *const ProcessStateDurationsReader) i64 {
        return self._uninterruptible_sleep_dur;
    }
};
const AndroidBootMetricWire = struct {
    const SYSTEM_SERVER_DURATIONS_WIRE: gremlin.ProtoWireNumber = 1;
    const SYSTEMUI_DURATIONS_WIRE: gremlin.ProtoWireNumber = 2;
    const LAUNCHER_DURATIONS_WIRE: gremlin.ProtoWireNumber = 3;
    const GMS_DURATIONS_WIRE: gremlin.ProtoWireNumber = 4;
    const LAUNCHER_BREAKDOWN_WIRE: gremlin.ProtoWireNumber = 5;
    const FULL_TRACE_PROCESS_START_AGGREGATION_WIRE: gremlin.ProtoWireNumber = 6;
    const POST_BOOT_PROCESS_START_AGGREGATION_WIRE: gremlin.ProtoWireNumber = 7;
    const FULL_TRACE_GC_AGGREGATION_WIRE: gremlin.ProtoWireNumber = 8;
    const POST_BOOT_GC_AGGREGATION_WIRE: gremlin.ProtoWireNumber = 9;
    const POST_BOOT_OOM_ADJUSTER_TRANSITION_COUNTS_GLOBAL_WIRE: gremlin.ProtoWireNumber = 10;
    const POST_BOOT_OOM_ADJUSTER_TRANSITION_COUNTS_BY_PROCESS_WIRE: gremlin.ProtoWireNumber = 11;
    const POST_BOOT_OOM_ADJUSTER_TRANSITION_COUNTS_BY_OOM_ADJ_REASON_WIRE: gremlin.ProtoWireNumber = 12;
    const POST_BOOT_OOM_ADJ_BUCKET_DURATION_AGG_GLOBAL_WIRE: gremlin.ProtoWireNumber = 13;
    const POST_BOOT_OOM_ADJ_BUCKET_DURATION_AGG_BY_PROCESS_WIRE: gremlin.ProtoWireNumber = 14;
    const POST_BOOT_OOM_ADJ_DURATION_AGG_WIRE: gremlin.ProtoWireNumber = 15;
    const POST_BOOT_BROADCAST_PROCESS_COUNT_BY_INTENT_WIRE: gremlin.ProtoWireNumber = 16;
    const POST_BOOT_BROADCAST_COUNT_BY_PROCESS_WIRE: gremlin.ProtoWireNumber = 17;
    const POST_BOOT_BRODCAST_DURATION_AGG_BY_INTENT_WIRE: gremlin.ProtoWireNumber = 18;
    const POST_BOOT_BRODCAST_DURATION_AGG_BY_PROCESS_WIRE: gremlin.ProtoWireNumber = 19;
};
pub const AndroidBootMetric = struct {
    // nested structs
    const LauncherBreakdownWire = struct {
        const COLD_START_DUR_WIRE: gremlin.ProtoWireNumber = 1;
    };
    pub const LauncherBreakdown = struct {
        // fields
        cold_start_dur: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidBootMetric.LauncherBreakdown) usize {
            var res: usize = 0;
            if (self.cold_start_dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetric.LauncherBreakdownWire.COLD_START_DUR_WIRE) + gremlin.sizes.sizeI64(self.cold_start_dur);
            }
            return res;
        }
        pub fn encode(self: *const AndroidBootMetric.LauncherBreakdown, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidBootMetric.LauncherBreakdown, target: *gremlin.Writer) void {
            if (self.cold_start_dur != 0) {
                target.appendInt64(AndroidBootMetric.LauncherBreakdownWire.COLD_START_DUR_WIRE, self.cold_start_dur);
            }
        }
    };
    pub const LauncherBreakdownReader = struct {
        buf: gremlin.Reader,
        _cold_start_dur: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidBootMetric.LauncherBreakdownReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidBootMetric.LauncherBreakdownReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidBootMetric.LauncherBreakdownWire.COLD_START_DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._cold_start_dur = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getColdStartDur(self: *const AndroidBootMetric.LauncherBreakdownReader) i64 {
            return self._cold_start_dur;
        }
    };
    const ProcessStartAggregationWire = struct {
        const TOTAL_START_SUM_WIRE: gremlin.ProtoWireNumber = 1;
        const NUM_OF_PROCESSES_WIRE: gremlin.ProtoWireNumber = 2;
        const AVERAGE_START_TIME_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const ProcessStartAggregation = struct {
        // fields
        total_start_sum: i64 = 0,
        num_of_processes: i64 = 0,
        average_start_time: f64 = 0.0,
        pub fn calcProtobufSize(self: *const AndroidBootMetric.ProcessStartAggregation) usize {
            var res: usize = 0;
            if (self.total_start_sum != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetric.ProcessStartAggregationWire.TOTAL_START_SUM_WIRE) + gremlin.sizes.sizeI64(self.total_start_sum);
            }
            if (self.num_of_processes != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetric.ProcessStartAggregationWire.NUM_OF_PROCESSES_WIRE) + gremlin.sizes.sizeI64(self.num_of_processes);
            }
            if (self.average_start_time != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetric.ProcessStartAggregationWire.AVERAGE_START_TIME_WIRE) + gremlin.sizes.sizeDouble(self.average_start_time);
            }
            return res;
        }
        pub fn encode(self: *const AndroidBootMetric.ProcessStartAggregation, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidBootMetric.ProcessStartAggregation, target: *gremlin.Writer) void {
            if (self.total_start_sum != 0) {
                target.appendInt64(AndroidBootMetric.ProcessStartAggregationWire.TOTAL_START_SUM_WIRE, self.total_start_sum);
            }
            if (self.num_of_processes != 0) {
                target.appendInt64(AndroidBootMetric.ProcessStartAggregationWire.NUM_OF_PROCESSES_WIRE, self.num_of_processes);
            }
            if (self.average_start_time != 0.0) {
                target.appendFloat64(AndroidBootMetric.ProcessStartAggregationWire.AVERAGE_START_TIME_WIRE, self.average_start_time);
            }
        }
    };
    pub const ProcessStartAggregationReader = struct {
        buf: gremlin.Reader,
        _total_start_sum: i64 = 0,
        _num_of_processes: i64 = 0,
        _average_start_time: f64 = 0.0,
        pub fn init(src: []const u8) gremlin.Error!AndroidBootMetric.ProcessStartAggregationReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidBootMetric.ProcessStartAggregationReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidBootMetric.ProcessStartAggregationWire.TOTAL_START_SUM_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._total_start_sum = result.value;
                    },
                    AndroidBootMetric.ProcessStartAggregationWire.NUM_OF_PROCESSES_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._num_of_processes = result.value;
                    },
                    AndroidBootMetric.ProcessStartAggregationWire.AVERAGE_START_TIME_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._average_start_time = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getTotalStartSum(self: *const AndroidBootMetric.ProcessStartAggregationReader) i64 {
            return self._total_start_sum;
        }
        pub inline fn getNumOfProcesses(self: *const AndroidBootMetric.ProcessStartAggregationReader) i64 {
            return self._num_of_processes;
        }
        pub inline fn getAverageStartTime(self: *const AndroidBootMetric.ProcessStartAggregationReader) f64 {
            return self._average_start_time;
        }
    };
    const GarbageCollectionAggregationWire = struct {
        const TOTAL_GC_COUNT_WIRE: gremlin.ProtoWireNumber = 1;
        const NUM_OF_PROCESSES_WITH_GC_WIRE: gremlin.ProtoWireNumber = 2;
        const NUM_OF_THREADS_WITH_GC_WIRE: gremlin.ProtoWireNumber = 3;
        const AVG_GC_DURATION_WIRE: gremlin.ProtoWireNumber = 4;
        const AVG_RUNNING_GC_DURATION_WIRE: gremlin.ProtoWireNumber = 5;
        const FULL_GC_COUNT_WIRE: gremlin.ProtoWireNumber = 6;
        const COLLECTOR_TRANSITION_GC_COUNT_WIRE: gremlin.ProtoWireNumber = 7;
        const YOUNG_GC_COUNT_WIRE: gremlin.ProtoWireNumber = 8;
        const NATIVE_ALLOC_GC_COUNT_WIRE: gremlin.ProtoWireNumber = 9;
        const EXPLICIT_GC_COUNT_WIRE: gremlin.ProtoWireNumber = 10;
        const ALLOC_GC_COUNT_WIRE: gremlin.ProtoWireNumber = 11;
        const MB_PER_MS_OF_GC_WIRE: gremlin.ProtoWireNumber = 12;
    };
    pub const GarbageCollectionAggregation = struct {
        // fields
        total_gc_count: i64 = 0,
        num_of_processes_with_gc: i64 = 0,
        num_of_threads_with_gc: i64 = 0,
        avg_gc_duration: f64 = 0.0,
        avg_running_gc_duration: f64 = 0.0,
        full_gc_count: i64 = 0,
        collector_transition_gc_count: i64 = 0,
        young_gc_count: i64 = 0,
        native_alloc_gc_count: i64 = 0,
        explicit_gc_count: i64 = 0,
        alloc_gc_count: i64 = 0,
        mb_per_ms_of_gc: f64 = 0.0,
        pub fn calcProtobufSize(self: *const AndroidBootMetric.GarbageCollectionAggregation) usize {
            var res: usize = 0;
            if (self.total_gc_count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetric.GarbageCollectionAggregationWire.TOTAL_GC_COUNT_WIRE) + gremlin.sizes.sizeI64(self.total_gc_count);
            }
            if (self.num_of_processes_with_gc != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetric.GarbageCollectionAggregationWire.NUM_OF_PROCESSES_WITH_GC_WIRE) + gremlin.sizes.sizeI64(self.num_of_processes_with_gc);
            }
            if (self.num_of_threads_with_gc != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetric.GarbageCollectionAggregationWire.NUM_OF_THREADS_WITH_GC_WIRE) + gremlin.sizes.sizeI64(self.num_of_threads_with_gc);
            }
            if (self.avg_gc_duration != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetric.GarbageCollectionAggregationWire.AVG_GC_DURATION_WIRE) + gremlin.sizes.sizeDouble(self.avg_gc_duration);
            }
            if (self.avg_running_gc_duration != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetric.GarbageCollectionAggregationWire.AVG_RUNNING_GC_DURATION_WIRE) + gremlin.sizes.sizeDouble(self.avg_running_gc_duration);
            }
            if (self.full_gc_count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetric.GarbageCollectionAggregationWire.FULL_GC_COUNT_WIRE) + gremlin.sizes.sizeI64(self.full_gc_count);
            }
            if (self.collector_transition_gc_count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetric.GarbageCollectionAggregationWire.COLLECTOR_TRANSITION_GC_COUNT_WIRE) + gremlin.sizes.sizeI64(self.collector_transition_gc_count);
            }
            if (self.young_gc_count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetric.GarbageCollectionAggregationWire.YOUNG_GC_COUNT_WIRE) + gremlin.sizes.sizeI64(self.young_gc_count);
            }
            if (self.native_alloc_gc_count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetric.GarbageCollectionAggregationWire.NATIVE_ALLOC_GC_COUNT_WIRE) + gremlin.sizes.sizeI64(self.native_alloc_gc_count);
            }
            if (self.explicit_gc_count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetric.GarbageCollectionAggregationWire.EXPLICIT_GC_COUNT_WIRE) + gremlin.sizes.sizeI64(self.explicit_gc_count);
            }
            if (self.alloc_gc_count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetric.GarbageCollectionAggregationWire.ALLOC_GC_COUNT_WIRE) + gremlin.sizes.sizeI64(self.alloc_gc_count);
            }
            if (self.mb_per_ms_of_gc != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetric.GarbageCollectionAggregationWire.MB_PER_MS_OF_GC_WIRE) + gremlin.sizes.sizeDouble(self.mb_per_ms_of_gc);
            }
            return res;
        }
        pub fn encode(self: *const AndroidBootMetric.GarbageCollectionAggregation, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidBootMetric.GarbageCollectionAggregation, target: *gremlin.Writer) void {
            if (self.total_gc_count != 0) {
                target.appendInt64(AndroidBootMetric.GarbageCollectionAggregationWire.TOTAL_GC_COUNT_WIRE, self.total_gc_count);
            }
            if (self.num_of_processes_with_gc != 0) {
                target.appendInt64(AndroidBootMetric.GarbageCollectionAggregationWire.NUM_OF_PROCESSES_WITH_GC_WIRE, self.num_of_processes_with_gc);
            }
            if (self.num_of_threads_with_gc != 0) {
                target.appendInt64(AndroidBootMetric.GarbageCollectionAggregationWire.NUM_OF_THREADS_WITH_GC_WIRE, self.num_of_threads_with_gc);
            }
            if (self.avg_gc_duration != 0.0) {
                target.appendFloat64(AndroidBootMetric.GarbageCollectionAggregationWire.AVG_GC_DURATION_WIRE, self.avg_gc_duration);
            }
            if (self.avg_running_gc_duration != 0.0) {
                target.appendFloat64(AndroidBootMetric.GarbageCollectionAggregationWire.AVG_RUNNING_GC_DURATION_WIRE, self.avg_running_gc_duration);
            }
            if (self.full_gc_count != 0) {
                target.appendInt64(AndroidBootMetric.GarbageCollectionAggregationWire.FULL_GC_COUNT_WIRE, self.full_gc_count);
            }
            if (self.collector_transition_gc_count != 0) {
                target.appendInt64(AndroidBootMetric.GarbageCollectionAggregationWire.COLLECTOR_TRANSITION_GC_COUNT_WIRE, self.collector_transition_gc_count);
            }
            if (self.young_gc_count != 0) {
                target.appendInt64(AndroidBootMetric.GarbageCollectionAggregationWire.YOUNG_GC_COUNT_WIRE, self.young_gc_count);
            }
            if (self.native_alloc_gc_count != 0) {
                target.appendInt64(AndroidBootMetric.GarbageCollectionAggregationWire.NATIVE_ALLOC_GC_COUNT_WIRE, self.native_alloc_gc_count);
            }
            if (self.explicit_gc_count != 0) {
                target.appendInt64(AndroidBootMetric.GarbageCollectionAggregationWire.EXPLICIT_GC_COUNT_WIRE, self.explicit_gc_count);
            }
            if (self.alloc_gc_count != 0) {
                target.appendInt64(AndroidBootMetric.GarbageCollectionAggregationWire.ALLOC_GC_COUNT_WIRE, self.alloc_gc_count);
            }
            if (self.mb_per_ms_of_gc != 0.0) {
                target.appendFloat64(AndroidBootMetric.GarbageCollectionAggregationWire.MB_PER_MS_OF_GC_WIRE, self.mb_per_ms_of_gc);
            }
        }
    };
    pub const GarbageCollectionAggregationReader = struct {
        buf: gremlin.Reader,
        _total_gc_count: i64 = 0,
        _num_of_processes_with_gc: i64 = 0,
        _num_of_threads_with_gc: i64 = 0,
        _avg_gc_duration: f64 = 0.0,
        _avg_running_gc_duration: f64 = 0.0,
        _full_gc_count: i64 = 0,
        _collector_transition_gc_count: i64 = 0,
        _young_gc_count: i64 = 0,
        _native_alloc_gc_count: i64 = 0,
        _explicit_gc_count: i64 = 0,
        _alloc_gc_count: i64 = 0,
        _mb_per_ms_of_gc: f64 = 0.0,
        pub fn init(src: []const u8) gremlin.Error!AndroidBootMetric.GarbageCollectionAggregationReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidBootMetric.GarbageCollectionAggregationReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidBootMetric.GarbageCollectionAggregationWire.TOTAL_GC_COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._total_gc_count = result.value;
                    },
                    AndroidBootMetric.GarbageCollectionAggregationWire.NUM_OF_PROCESSES_WITH_GC_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._num_of_processes_with_gc = result.value;
                    },
                    AndroidBootMetric.GarbageCollectionAggregationWire.NUM_OF_THREADS_WITH_GC_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._num_of_threads_with_gc = result.value;
                    },
                    AndroidBootMetric.GarbageCollectionAggregationWire.AVG_GC_DURATION_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._avg_gc_duration = result.value;
                    },
                    AndroidBootMetric.GarbageCollectionAggregationWire.AVG_RUNNING_GC_DURATION_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._avg_running_gc_duration = result.value;
                    },
                    AndroidBootMetric.GarbageCollectionAggregationWire.FULL_GC_COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._full_gc_count = result.value;
                    },
                    AndroidBootMetric.GarbageCollectionAggregationWire.COLLECTOR_TRANSITION_GC_COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._collector_transition_gc_count = result.value;
                    },
                    AndroidBootMetric.GarbageCollectionAggregationWire.YOUNG_GC_COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._young_gc_count = result.value;
                    },
                    AndroidBootMetric.GarbageCollectionAggregationWire.NATIVE_ALLOC_GC_COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._native_alloc_gc_count = result.value;
                    },
                    AndroidBootMetric.GarbageCollectionAggregationWire.EXPLICIT_GC_COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._explicit_gc_count = result.value;
                    },
                    AndroidBootMetric.GarbageCollectionAggregationWire.ALLOC_GC_COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._alloc_gc_count = result.value;
                    },
                    AndroidBootMetric.GarbageCollectionAggregationWire.MB_PER_MS_OF_GC_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._mb_per_ms_of_gc = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getTotalGcCount(self: *const AndroidBootMetric.GarbageCollectionAggregationReader) i64 {
            return self._total_gc_count;
        }
        pub inline fn getNumOfProcessesWithGc(self: *const AndroidBootMetric.GarbageCollectionAggregationReader) i64 {
            return self._num_of_processes_with_gc;
        }
        pub inline fn getNumOfThreadsWithGc(self: *const AndroidBootMetric.GarbageCollectionAggregationReader) i64 {
            return self._num_of_threads_with_gc;
        }
        pub inline fn getAvgGcDuration(self: *const AndroidBootMetric.GarbageCollectionAggregationReader) f64 {
            return self._avg_gc_duration;
        }
        pub inline fn getAvgRunningGcDuration(self: *const AndroidBootMetric.GarbageCollectionAggregationReader) f64 {
            return self._avg_running_gc_duration;
        }
        pub inline fn getFullGcCount(self: *const AndroidBootMetric.GarbageCollectionAggregationReader) i64 {
            return self._full_gc_count;
        }
        pub inline fn getCollectorTransitionGcCount(self: *const AndroidBootMetric.GarbageCollectionAggregationReader) i64 {
            return self._collector_transition_gc_count;
        }
        pub inline fn getYoungGcCount(self: *const AndroidBootMetric.GarbageCollectionAggregationReader) i64 {
            return self._young_gc_count;
        }
        pub inline fn getNativeAllocGcCount(self: *const AndroidBootMetric.GarbageCollectionAggregationReader) i64 {
            return self._native_alloc_gc_count;
        }
        pub inline fn getExplicitGcCount(self: *const AndroidBootMetric.GarbageCollectionAggregationReader) i64 {
            return self._explicit_gc_count;
        }
        pub inline fn getAllocGcCount(self: *const AndroidBootMetric.GarbageCollectionAggregationReader) i64 {
            return self._alloc_gc_count;
        }
        pub inline fn getMbPerMsOfGc(self: *const AndroidBootMetric.GarbageCollectionAggregationReader) f64 {
            return self._mb_per_ms_of_gc;
        }
    };
    const OomAdjusterTransitionCountsWire = struct {
        const NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const SRC_BUCKET_WIRE: gremlin.ProtoWireNumber = 2;
        const DEST_BUCKET_WIRE: gremlin.ProtoWireNumber = 3;
        const COUNT_WIRE: gremlin.ProtoWireNumber = 4;
    };
    pub const OomAdjusterTransitionCounts = struct {
        // fields
        name: ?[]const u8 = null,
        src_bucket: ?[]const u8 = null,
        dest_bucket: ?[]const u8 = null,
        count: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidBootMetric.OomAdjusterTransitionCounts) usize {
            var res: usize = 0;
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidBootMetric.OomAdjusterTransitionCountsWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.src_bucket) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidBootMetric.OomAdjusterTransitionCountsWire.SRC_BUCKET_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.dest_bucket) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidBootMetric.OomAdjusterTransitionCountsWire.DEST_BUCKET_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetric.OomAdjusterTransitionCountsWire.COUNT_WIRE) + gremlin.sizes.sizeI64(self.count);
            }
            return res;
        }
        pub fn encode(self: *const AndroidBootMetric.OomAdjusterTransitionCounts, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidBootMetric.OomAdjusterTransitionCounts, target: *gremlin.Writer) void {
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidBootMetric.OomAdjusterTransitionCountsWire.NAME_WIRE, v);
                }
            }
            if (self.src_bucket) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidBootMetric.OomAdjusterTransitionCountsWire.SRC_BUCKET_WIRE, v);
                }
            }
            if (self.dest_bucket) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidBootMetric.OomAdjusterTransitionCountsWire.DEST_BUCKET_WIRE, v);
                }
            }
            if (self.count != 0) {
                target.appendInt64(AndroidBootMetric.OomAdjusterTransitionCountsWire.COUNT_WIRE, self.count);
            }
        }
    };
    pub const OomAdjusterTransitionCountsReader = struct {
        buf: gremlin.Reader,
        _name: ?[]const u8 = null,
        _src_bucket: ?[]const u8 = null,
        _dest_bucket: ?[]const u8 = null,
        _count: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidBootMetric.OomAdjusterTransitionCountsReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidBootMetric.OomAdjusterTransitionCountsReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidBootMetric.OomAdjusterTransitionCountsWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    AndroidBootMetric.OomAdjusterTransitionCountsWire.SRC_BUCKET_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._src_bucket = result.value;
                    },
                    AndroidBootMetric.OomAdjusterTransitionCountsWire.DEST_BUCKET_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._dest_bucket = result.value;
                    },
                    AndroidBootMetric.OomAdjusterTransitionCountsWire.COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._count = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getName(self: *const AndroidBootMetric.OomAdjusterTransitionCountsReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub inline fn getSrcBucket(self: *const AndroidBootMetric.OomAdjusterTransitionCountsReader) []const u8 {
            return self._src_bucket orelse &[_]u8{};
        }
        pub inline fn getDestBucket(self: *const AndroidBootMetric.OomAdjusterTransitionCountsReader) []const u8 {
            return self._dest_bucket orelse &[_]u8{};
        }
        pub inline fn getCount(self: *const AndroidBootMetric.OomAdjusterTransitionCountsReader) i64 {
            return self._count;
        }
    };
    const OomAdjBucketDurationAggregationWire = struct {
        const NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const BUCKET_WIRE: gremlin.ProtoWireNumber = 2;
        const TOTAL_DUR_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const OomAdjBucketDurationAggregation = struct {
        // fields
        name: ?[]const u8 = null,
        bucket: ?[]const u8 = null,
        total_dur: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidBootMetric.OomAdjBucketDurationAggregation) usize {
            var res: usize = 0;
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidBootMetric.OomAdjBucketDurationAggregationWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.bucket) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidBootMetric.OomAdjBucketDurationAggregationWire.BUCKET_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.total_dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetric.OomAdjBucketDurationAggregationWire.TOTAL_DUR_WIRE) + gremlin.sizes.sizeI64(self.total_dur);
            }
            return res;
        }
        pub fn encode(self: *const AndroidBootMetric.OomAdjBucketDurationAggregation, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidBootMetric.OomAdjBucketDurationAggregation, target: *gremlin.Writer) void {
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidBootMetric.OomAdjBucketDurationAggregationWire.NAME_WIRE, v);
                }
            }
            if (self.bucket) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidBootMetric.OomAdjBucketDurationAggregationWire.BUCKET_WIRE, v);
                }
            }
            if (self.total_dur != 0) {
                target.appendInt64(AndroidBootMetric.OomAdjBucketDurationAggregationWire.TOTAL_DUR_WIRE, self.total_dur);
            }
        }
    };
    pub const OomAdjBucketDurationAggregationReader = struct {
        buf: gremlin.Reader,
        _name: ?[]const u8 = null,
        _bucket: ?[]const u8 = null,
        _total_dur: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidBootMetric.OomAdjBucketDurationAggregationReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidBootMetric.OomAdjBucketDurationAggregationReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidBootMetric.OomAdjBucketDurationAggregationWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    AndroidBootMetric.OomAdjBucketDurationAggregationWire.BUCKET_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._bucket = result.value;
                    },
                    AndroidBootMetric.OomAdjBucketDurationAggregationWire.TOTAL_DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._total_dur = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getName(self: *const AndroidBootMetric.OomAdjBucketDurationAggregationReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub inline fn getBucket(self: *const AndroidBootMetric.OomAdjBucketDurationAggregationReader) []const u8 {
            return self._bucket orelse &[_]u8{};
        }
        pub inline fn getTotalDur(self: *const AndroidBootMetric.OomAdjBucketDurationAggregationReader) i64 {
            return self._total_dur;
        }
    };
    const OomAdjDurationAggregationWire = struct {
        const MIN_OOM_ADJ_DUR_WIRE: gremlin.ProtoWireNumber = 1;
        const MAX_OOM_ADJ_DUR_WIRE: gremlin.ProtoWireNumber = 2;
        const AVG_OOM_ADJ_DUR_WIRE: gremlin.ProtoWireNumber = 3;
        const OOM_ADJ_EVENT_COUNT_WIRE: gremlin.ProtoWireNumber = 4;
        const OOM_ADJ_REASON_WIRE: gremlin.ProtoWireNumber = 5;
    };
    pub const OomAdjDurationAggregation = struct {
        // fields
        min_oom_adj_dur: i64 = 0,
        max_oom_adj_dur: i64 = 0,
        avg_oom_adj_dur: f64 = 0.0,
        oom_adj_event_count: i64 = 0,
        oom_adj_reason: ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const AndroidBootMetric.OomAdjDurationAggregation) usize {
            var res: usize = 0;
            if (self.min_oom_adj_dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetric.OomAdjDurationAggregationWire.MIN_OOM_ADJ_DUR_WIRE) + gremlin.sizes.sizeI64(self.min_oom_adj_dur);
            }
            if (self.max_oom_adj_dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetric.OomAdjDurationAggregationWire.MAX_OOM_ADJ_DUR_WIRE) + gremlin.sizes.sizeI64(self.max_oom_adj_dur);
            }
            if (self.avg_oom_adj_dur != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetric.OomAdjDurationAggregationWire.AVG_OOM_ADJ_DUR_WIRE) + gremlin.sizes.sizeDouble(self.avg_oom_adj_dur);
            }
            if (self.oom_adj_event_count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetric.OomAdjDurationAggregationWire.OOM_ADJ_EVENT_COUNT_WIRE) + gremlin.sizes.sizeI64(self.oom_adj_event_count);
            }
            if (self.oom_adj_reason) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidBootMetric.OomAdjDurationAggregationWire.OOM_ADJ_REASON_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidBootMetric.OomAdjDurationAggregation, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidBootMetric.OomAdjDurationAggregation, target: *gremlin.Writer) void {
            if (self.min_oom_adj_dur != 0) {
                target.appendInt64(AndroidBootMetric.OomAdjDurationAggregationWire.MIN_OOM_ADJ_DUR_WIRE, self.min_oom_adj_dur);
            }
            if (self.max_oom_adj_dur != 0) {
                target.appendInt64(AndroidBootMetric.OomAdjDurationAggregationWire.MAX_OOM_ADJ_DUR_WIRE, self.max_oom_adj_dur);
            }
            if (self.avg_oom_adj_dur != 0.0) {
                target.appendFloat64(AndroidBootMetric.OomAdjDurationAggregationWire.AVG_OOM_ADJ_DUR_WIRE, self.avg_oom_adj_dur);
            }
            if (self.oom_adj_event_count != 0) {
                target.appendInt64(AndroidBootMetric.OomAdjDurationAggregationWire.OOM_ADJ_EVENT_COUNT_WIRE, self.oom_adj_event_count);
            }
            if (self.oom_adj_reason) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidBootMetric.OomAdjDurationAggregationWire.OOM_ADJ_REASON_WIRE, v);
                }
            }
        }
    };
    pub const OomAdjDurationAggregationReader = struct {
        buf: gremlin.Reader,
        _min_oom_adj_dur: i64 = 0,
        _max_oom_adj_dur: i64 = 0,
        _avg_oom_adj_dur: f64 = 0.0,
        _oom_adj_event_count: i64 = 0,
        _oom_adj_reason: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!AndroidBootMetric.OomAdjDurationAggregationReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidBootMetric.OomAdjDurationAggregationReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidBootMetric.OomAdjDurationAggregationWire.MIN_OOM_ADJ_DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._min_oom_adj_dur = result.value;
                    },
                    AndroidBootMetric.OomAdjDurationAggregationWire.MAX_OOM_ADJ_DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._max_oom_adj_dur = result.value;
                    },
                    AndroidBootMetric.OomAdjDurationAggregationWire.AVG_OOM_ADJ_DUR_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._avg_oom_adj_dur = result.value;
                    },
                    AndroidBootMetric.OomAdjDurationAggregationWire.OOM_ADJ_EVENT_COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._oom_adj_event_count = result.value;
                    },
                    AndroidBootMetric.OomAdjDurationAggregationWire.OOM_ADJ_REASON_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._oom_adj_reason = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getMinOomAdjDur(self: *const AndroidBootMetric.OomAdjDurationAggregationReader) i64 {
            return self._min_oom_adj_dur;
        }
        pub inline fn getMaxOomAdjDur(self: *const AndroidBootMetric.OomAdjDurationAggregationReader) i64 {
            return self._max_oom_adj_dur;
        }
        pub inline fn getAvgOomAdjDur(self: *const AndroidBootMetric.OomAdjDurationAggregationReader) f64 {
            return self._avg_oom_adj_dur;
        }
        pub inline fn getOomAdjEventCount(self: *const AndroidBootMetric.OomAdjDurationAggregationReader) i64 {
            return self._oom_adj_event_count;
        }
        pub inline fn getOomAdjReason(self: *const AndroidBootMetric.OomAdjDurationAggregationReader) []const u8 {
            return self._oom_adj_reason orelse &[_]u8{};
        }
    };
    const BroadcastCountAggregationWire = struct {
        const NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const COUNT_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const BroadcastCountAggregation = struct {
        // fields
        name: ?[]const u8 = null,
        count: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidBootMetric.BroadcastCountAggregation) usize {
            var res: usize = 0;
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidBootMetric.BroadcastCountAggregationWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetric.BroadcastCountAggregationWire.COUNT_WIRE) + gremlin.sizes.sizeI64(self.count);
            }
            return res;
        }
        pub fn encode(self: *const AndroidBootMetric.BroadcastCountAggregation, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidBootMetric.BroadcastCountAggregation, target: *gremlin.Writer) void {
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidBootMetric.BroadcastCountAggregationWire.NAME_WIRE, v);
                }
            }
            if (self.count != 0) {
                target.appendInt64(AndroidBootMetric.BroadcastCountAggregationWire.COUNT_WIRE, self.count);
            }
        }
    };
    pub const BroadcastCountAggregationReader = struct {
        buf: gremlin.Reader,
        _name: ?[]const u8 = null,
        _count: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidBootMetric.BroadcastCountAggregationReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidBootMetric.BroadcastCountAggregationReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidBootMetric.BroadcastCountAggregationWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    AndroidBootMetric.BroadcastCountAggregationWire.COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._count = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getName(self: *const AndroidBootMetric.BroadcastCountAggregationReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub inline fn getCount(self: *const AndroidBootMetric.BroadcastCountAggregationReader) i64 {
            return self._count;
        }
    };
    const BroadcastDurationAggregationWire = struct {
        const NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const AVG_DURATION_WIRE: gremlin.ProtoWireNumber = 2;
        const MAX_DURATION_WIRE: gremlin.ProtoWireNumber = 3;
        const SUM_DURATION_WIRE: gremlin.ProtoWireNumber = 4;
    };
    pub const BroadcastDurationAggregation = struct {
        // fields
        name: ?[]const u8 = null,
        avg_duration: f64 = 0.0,
        max_duration: i64 = 0,
        sum_duration: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidBootMetric.BroadcastDurationAggregation) usize {
            var res: usize = 0;
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidBootMetric.BroadcastDurationAggregationWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.avg_duration != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetric.BroadcastDurationAggregationWire.AVG_DURATION_WIRE) + gremlin.sizes.sizeDouble(self.avg_duration);
            }
            if (self.max_duration != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetric.BroadcastDurationAggregationWire.MAX_DURATION_WIRE) + gremlin.sizes.sizeI64(self.max_duration);
            }
            if (self.sum_duration != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetric.BroadcastDurationAggregationWire.SUM_DURATION_WIRE) + gremlin.sizes.sizeI64(self.sum_duration);
            }
            return res;
        }
        pub fn encode(self: *const AndroidBootMetric.BroadcastDurationAggregation, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidBootMetric.BroadcastDurationAggregation, target: *gremlin.Writer) void {
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidBootMetric.BroadcastDurationAggregationWire.NAME_WIRE, v);
                }
            }
            if (self.avg_duration != 0.0) {
                target.appendFloat64(AndroidBootMetric.BroadcastDurationAggregationWire.AVG_DURATION_WIRE, self.avg_duration);
            }
            if (self.max_duration != 0) {
                target.appendInt64(AndroidBootMetric.BroadcastDurationAggregationWire.MAX_DURATION_WIRE, self.max_duration);
            }
            if (self.sum_duration != 0) {
                target.appendInt64(AndroidBootMetric.BroadcastDurationAggregationWire.SUM_DURATION_WIRE, self.sum_duration);
            }
        }
    };
    pub const BroadcastDurationAggregationReader = struct {
        buf: gremlin.Reader,
        _name: ?[]const u8 = null,
        _avg_duration: f64 = 0.0,
        _max_duration: i64 = 0,
        _sum_duration: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidBootMetric.BroadcastDurationAggregationReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidBootMetric.BroadcastDurationAggregationReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidBootMetric.BroadcastDurationAggregationWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    AndroidBootMetric.BroadcastDurationAggregationWire.AVG_DURATION_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._avg_duration = result.value;
                    },
                    AndroidBootMetric.BroadcastDurationAggregationWire.MAX_DURATION_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._max_duration = result.value;
                    },
                    AndroidBootMetric.BroadcastDurationAggregationWire.SUM_DURATION_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._sum_duration = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getName(self: *const AndroidBootMetric.BroadcastDurationAggregationReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub inline fn getAvgDuration(self: *const AndroidBootMetric.BroadcastDurationAggregationReader) f64 {
            return self._avg_duration;
        }
        pub inline fn getMaxDuration(self: *const AndroidBootMetric.BroadcastDurationAggregationReader) i64 {
            return self._max_duration;
        }
        pub inline fn getSumDuration(self: *const AndroidBootMetric.BroadcastDurationAggregationReader) i64 {
            return self._sum_duration;
        }
    };
    // fields
    system_server_durations: ?ProcessStateDurations = null,
    systemui_durations: ?ProcessStateDurations = null,
    launcher_durations: ?ProcessStateDurations = null,
    gms_durations: ?ProcessStateDurations = null,
    launcher_breakdown: ?AndroidBootMetric.LauncherBreakdown = null,
    full_trace_process_start_aggregation: ?AndroidBootMetric.ProcessStartAggregation = null,
    post_boot_process_start_aggregation: ?AndroidBootMetric.ProcessStartAggregation = null,
    full_trace_gc_aggregation: ?AndroidBootMetric.GarbageCollectionAggregation = null,
    post_boot_gc_aggregation: ?AndroidBootMetric.GarbageCollectionAggregation = null,
    post_boot_oom_adjuster_transition_counts_global: ?[]const ?AndroidBootMetric.OomAdjusterTransitionCounts = null,
    post_boot_oom_adjuster_transition_counts_by_process: ?[]const ?AndroidBootMetric.OomAdjusterTransitionCounts = null,
    post_boot_oom_adjuster_transition_counts_by_oom_adj_reason: ?[]const ?AndroidBootMetric.OomAdjusterTransitionCounts = null,
    post_boot_oom_adj_bucket_duration_agg_global: ?[]const ?AndroidBootMetric.OomAdjBucketDurationAggregation = null,
    post_boot_oom_adj_bucket_duration_agg_by_process: ?[]const ?AndroidBootMetric.OomAdjBucketDurationAggregation = null,
    post_boot_oom_adj_duration_agg: ?[]const ?AndroidBootMetric.OomAdjDurationAggregation = null,
    post_boot_broadcast_process_count_by_intent: ?[]const ?AndroidBootMetric.BroadcastCountAggregation = null,
    post_boot_broadcast_count_by_process: ?[]const ?AndroidBootMetric.BroadcastCountAggregation = null,
    post_boot_brodcast_duration_agg_by_intent: ?[]const ?AndroidBootMetric.BroadcastDurationAggregation = null,
    post_boot_brodcast_duration_agg_by_process: ?[]const ?AndroidBootMetric.BroadcastDurationAggregation = null,
    pub fn calcProtobufSize(self: *const AndroidBootMetric) usize {
        var res: usize = 0;
        if (self.system_server_durations) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetricWire.SYSTEM_SERVER_DURATIONS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.systemui_durations) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetricWire.SYSTEMUI_DURATIONS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.launcher_durations) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetricWire.LAUNCHER_DURATIONS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.gms_durations) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetricWire.GMS_DURATIONS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.launcher_breakdown) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetricWire.LAUNCHER_BREAKDOWN_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.full_trace_process_start_aggregation) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetricWire.FULL_TRACE_PROCESS_START_AGGREGATION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.post_boot_process_start_aggregation) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetricWire.POST_BOOT_PROCESS_START_AGGREGATION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.full_trace_gc_aggregation) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetricWire.FULL_TRACE_GC_AGGREGATION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.post_boot_gc_aggregation) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetricWire.POST_BOOT_GC_AGGREGATION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.post_boot_oom_adjuster_transition_counts_global) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetricWire.POST_BOOT_OOM_ADJUSTER_TRANSITION_COUNTS_GLOBAL_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.post_boot_oom_adjuster_transition_counts_by_process) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetricWire.POST_BOOT_OOM_ADJUSTER_TRANSITION_COUNTS_BY_PROCESS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.post_boot_oom_adjuster_transition_counts_by_oom_adj_reason) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetricWire.POST_BOOT_OOM_ADJUSTER_TRANSITION_COUNTS_BY_OOM_ADJ_REASON_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.post_boot_oom_adj_bucket_duration_agg_global) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetricWire.POST_BOOT_OOM_ADJ_BUCKET_DURATION_AGG_GLOBAL_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.post_boot_oom_adj_bucket_duration_agg_by_process) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetricWire.POST_BOOT_OOM_ADJ_BUCKET_DURATION_AGG_BY_PROCESS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.post_boot_oom_adj_duration_agg) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetricWire.POST_BOOT_OOM_ADJ_DURATION_AGG_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.post_boot_broadcast_process_count_by_intent) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetricWire.POST_BOOT_BROADCAST_PROCESS_COUNT_BY_INTENT_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.post_boot_broadcast_count_by_process) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetricWire.POST_BOOT_BROADCAST_COUNT_BY_PROCESS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.post_boot_brodcast_duration_agg_by_intent) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetricWire.POST_BOOT_BRODCAST_DURATION_AGG_BY_INTENT_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.post_boot_brodcast_duration_agg_by_process) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidBootMetricWire.POST_BOOT_BRODCAST_DURATION_AGG_BY_PROCESS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidBootMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidBootMetric, target: *gremlin.Writer) void {
        if (self.system_server_durations) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidBootMetricWire.SYSTEM_SERVER_DURATIONS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.systemui_durations) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidBootMetricWire.SYSTEMUI_DURATIONS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.launcher_durations) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidBootMetricWire.LAUNCHER_DURATIONS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.gms_durations) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidBootMetricWire.GMS_DURATIONS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.launcher_breakdown) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidBootMetricWire.LAUNCHER_BREAKDOWN_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.full_trace_process_start_aggregation) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidBootMetricWire.FULL_TRACE_PROCESS_START_AGGREGATION_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.post_boot_process_start_aggregation) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidBootMetricWire.POST_BOOT_PROCESS_START_AGGREGATION_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.full_trace_gc_aggregation) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidBootMetricWire.FULL_TRACE_GC_AGGREGATION_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.post_boot_gc_aggregation) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidBootMetricWire.POST_BOOT_GC_AGGREGATION_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.post_boot_oom_adjuster_transition_counts_global) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidBootMetricWire.POST_BOOT_OOM_ADJUSTER_TRANSITION_COUNTS_GLOBAL_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidBootMetricWire.POST_BOOT_OOM_ADJUSTER_TRANSITION_COUNTS_GLOBAL_WIRE, 0);
                }
            }
        }
        if (self.post_boot_oom_adjuster_transition_counts_by_process) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidBootMetricWire.POST_BOOT_OOM_ADJUSTER_TRANSITION_COUNTS_BY_PROCESS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidBootMetricWire.POST_BOOT_OOM_ADJUSTER_TRANSITION_COUNTS_BY_PROCESS_WIRE, 0);
                }
            }
        }
        if (self.post_boot_oom_adjuster_transition_counts_by_oom_adj_reason) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidBootMetricWire.POST_BOOT_OOM_ADJUSTER_TRANSITION_COUNTS_BY_OOM_ADJ_REASON_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidBootMetricWire.POST_BOOT_OOM_ADJUSTER_TRANSITION_COUNTS_BY_OOM_ADJ_REASON_WIRE, 0);
                }
            }
        }
        if (self.post_boot_oom_adj_bucket_duration_agg_global) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidBootMetricWire.POST_BOOT_OOM_ADJ_BUCKET_DURATION_AGG_GLOBAL_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidBootMetricWire.POST_BOOT_OOM_ADJ_BUCKET_DURATION_AGG_GLOBAL_WIRE, 0);
                }
            }
        }
        if (self.post_boot_oom_adj_bucket_duration_agg_by_process) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidBootMetricWire.POST_BOOT_OOM_ADJ_BUCKET_DURATION_AGG_BY_PROCESS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidBootMetricWire.POST_BOOT_OOM_ADJ_BUCKET_DURATION_AGG_BY_PROCESS_WIRE, 0);
                }
            }
        }
        if (self.post_boot_oom_adj_duration_agg) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidBootMetricWire.POST_BOOT_OOM_ADJ_DURATION_AGG_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidBootMetricWire.POST_BOOT_OOM_ADJ_DURATION_AGG_WIRE, 0);
                }
            }
        }
        if (self.post_boot_broadcast_process_count_by_intent) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidBootMetricWire.POST_BOOT_BROADCAST_PROCESS_COUNT_BY_INTENT_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidBootMetricWire.POST_BOOT_BROADCAST_PROCESS_COUNT_BY_INTENT_WIRE, 0);
                }
            }
        }
        if (self.post_boot_broadcast_count_by_process) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidBootMetricWire.POST_BOOT_BROADCAST_COUNT_BY_PROCESS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidBootMetricWire.POST_BOOT_BROADCAST_COUNT_BY_PROCESS_WIRE, 0);
                }
            }
        }
        if (self.post_boot_brodcast_duration_agg_by_intent) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidBootMetricWire.POST_BOOT_BRODCAST_DURATION_AGG_BY_INTENT_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidBootMetricWire.POST_BOOT_BRODCAST_DURATION_AGG_BY_INTENT_WIRE, 0);
                }
            }
        }
        if (self.post_boot_brodcast_duration_agg_by_process) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidBootMetricWire.POST_BOOT_BRODCAST_DURATION_AGG_BY_PROCESS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidBootMetricWire.POST_BOOT_BRODCAST_DURATION_AGG_BY_PROCESS_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidBootMetricReader = struct {
    buf: gremlin.Reader,
    _system_server_durations_buf: ?[]const u8 = null,
    _systemui_durations_buf: ?[]const u8 = null,
    _launcher_durations_buf: ?[]const u8 = null,
    _gms_durations_buf: ?[]const u8 = null,
    _launcher_breakdown_buf: ?[]const u8 = null,
    _full_trace_process_start_aggregation_buf: ?[]const u8 = null,
    _post_boot_process_start_aggregation_buf: ?[]const u8 = null,
    _full_trace_gc_aggregation_buf: ?[]const u8 = null,
    _post_boot_gc_aggregation_buf: ?[]const u8 = null,
    _post_boot_oom_adjuster_transition_counts_global_offset: ?usize = null,
    _post_boot_oom_adjuster_transition_counts_global_last_offset: ?usize = null,
    _post_boot_oom_adjuster_transition_counts_global_cnt: usize = 0,
    _post_boot_oom_adjuster_transition_counts_by_process_offset: ?usize = null,
    _post_boot_oom_adjuster_transition_counts_by_process_last_offset: ?usize = null,
    _post_boot_oom_adjuster_transition_counts_by_process_cnt: usize = 0,
    _post_boot_oom_adjuster_transition_counts_by_oom_adj_reason_offset: ?usize = null,
    _post_boot_oom_adjuster_transition_counts_by_oom_adj_reason_last_offset: ?usize = null,
    _post_boot_oom_adjuster_transition_counts_by_oom_adj_reason_cnt: usize = 0,
    _post_boot_oom_adj_bucket_duration_agg_global_offset: ?usize = null,
    _post_boot_oom_adj_bucket_duration_agg_global_last_offset: ?usize = null,
    _post_boot_oom_adj_bucket_duration_agg_global_cnt: usize = 0,
    _post_boot_oom_adj_bucket_duration_agg_by_process_offset: ?usize = null,
    _post_boot_oom_adj_bucket_duration_agg_by_process_last_offset: ?usize = null,
    _post_boot_oom_adj_bucket_duration_agg_by_process_cnt: usize = 0,
    _post_boot_oom_adj_duration_agg_offset: ?usize = null,
    _post_boot_oom_adj_duration_agg_last_offset: ?usize = null,
    _post_boot_oom_adj_duration_agg_cnt: usize = 0,
    _post_boot_broadcast_process_count_by_intent_offset: ?usize = null,
    _post_boot_broadcast_process_count_by_intent_last_offset: ?usize = null,
    _post_boot_broadcast_process_count_by_intent_cnt: usize = 0,
    _post_boot_broadcast_count_by_process_offset: ?usize = null,
    _post_boot_broadcast_count_by_process_last_offset: ?usize = null,
    _post_boot_broadcast_count_by_process_cnt: usize = 0,
    _post_boot_brodcast_duration_agg_by_intent_offset: ?usize = null,
    _post_boot_brodcast_duration_agg_by_intent_last_offset: ?usize = null,
    _post_boot_brodcast_duration_agg_by_intent_cnt: usize = 0,
    _post_boot_brodcast_duration_agg_by_process_offset: ?usize = null,
    _post_boot_brodcast_duration_agg_by_process_last_offset: ?usize = null,
    _post_boot_brodcast_duration_agg_by_process_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidBootMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidBootMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidBootMetricWire.SYSTEM_SERVER_DURATIONS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._system_server_durations_buf = result.value;
                },
                AndroidBootMetricWire.SYSTEMUI_DURATIONS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._systemui_durations_buf = result.value;
                },
                AndroidBootMetricWire.LAUNCHER_DURATIONS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._launcher_durations_buf = result.value;
                },
                AndroidBootMetricWire.GMS_DURATIONS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._gms_durations_buf = result.value;
                },
                AndroidBootMetricWire.LAUNCHER_BREAKDOWN_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._launcher_breakdown_buf = result.value;
                },
                AndroidBootMetricWire.FULL_TRACE_PROCESS_START_AGGREGATION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._full_trace_process_start_aggregation_buf = result.value;
                },
                AndroidBootMetricWire.POST_BOOT_PROCESS_START_AGGREGATION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._post_boot_process_start_aggregation_buf = result.value;
                },
                AndroidBootMetricWire.FULL_TRACE_GC_AGGREGATION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._full_trace_gc_aggregation_buf = result.value;
                },
                AndroidBootMetricWire.POST_BOOT_GC_AGGREGATION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._post_boot_gc_aggregation_buf = result.value;
                },
                AndroidBootMetricWire.POST_BOOT_OOM_ADJUSTER_TRANSITION_COUNTS_GLOBAL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._post_boot_oom_adjuster_transition_counts_global_offset == null) {
                        res._post_boot_oom_adjuster_transition_counts_global_offset = offset - result.size;
                    }
                    res._post_boot_oom_adjuster_transition_counts_global_last_offset = offset;
                    res._post_boot_oom_adjuster_transition_counts_global_cnt += 1;
                },
                AndroidBootMetricWire.POST_BOOT_OOM_ADJUSTER_TRANSITION_COUNTS_BY_PROCESS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._post_boot_oom_adjuster_transition_counts_by_process_offset == null) {
                        res._post_boot_oom_adjuster_transition_counts_by_process_offset = offset - result.size;
                    }
                    res._post_boot_oom_adjuster_transition_counts_by_process_last_offset = offset;
                    res._post_boot_oom_adjuster_transition_counts_by_process_cnt += 1;
                },
                AndroidBootMetricWire.POST_BOOT_OOM_ADJUSTER_TRANSITION_COUNTS_BY_OOM_ADJ_REASON_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._post_boot_oom_adjuster_transition_counts_by_oom_adj_reason_offset == null) {
                        res._post_boot_oom_adjuster_transition_counts_by_oom_adj_reason_offset = offset - result.size;
                    }
                    res._post_boot_oom_adjuster_transition_counts_by_oom_adj_reason_last_offset = offset;
                    res._post_boot_oom_adjuster_transition_counts_by_oom_adj_reason_cnt += 1;
                },
                AndroidBootMetricWire.POST_BOOT_OOM_ADJ_BUCKET_DURATION_AGG_GLOBAL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._post_boot_oom_adj_bucket_duration_agg_global_offset == null) {
                        res._post_boot_oom_adj_bucket_duration_agg_global_offset = offset - result.size;
                    }
                    res._post_boot_oom_adj_bucket_duration_agg_global_last_offset = offset;
                    res._post_boot_oom_adj_bucket_duration_agg_global_cnt += 1;
                },
                AndroidBootMetricWire.POST_BOOT_OOM_ADJ_BUCKET_DURATION_AGG_BY_PROCESS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._post_boot_oom_adj_bucket_duration_agg_by_process_offset == null) {
                        res._post_boot_oom_adj_bucket_duration_agg_by_process_offset = offset - result.size;
                    }
                    res._post_boot_oom_adj_bucket_duration_agg_by_process_last_offset = offset;
                    res._post_boot_oom_adj_bucket_duration_agg_by_process_cnt += 1;
                },
                AndroidBootMetricWire.POST_BOOT_OOM_ADJ_DURATION_AGG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._post_boot_oom_adj_duration_agg_offset == null) {
                        res._post_boot_oom_adj_duration_agg_offset = offset - result.size;
                    }
                    res._post_boot_oom_adj_duration_agg_last_offset = offset;
                    res._post_boot_oom_adj_duration_agg_cnt += 1;
                },
                AndroidBootMetricWire.POST_BOOT_BROADCAST_PROCESS_COUNT_BY_INTENT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._post_boot_broadcast_process_count_by_intent_offset == null) {
                        res._post_boot_broadcast_process_count_by_intent_offset = offset - result.size;
                    }
                    res._post_boot_broadcast_process_count_by_intent_last_offset = offset;
                    res._post_boot_broadcast_process_count_by_intent_cnt += 1;
                },
                AndroidBootMetricWire.POST_BOOT_BROADCAST_COUNT_BY_PROCESS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._post_boot_broadcast_count_by_process_offset == null) {
                        res._post_boot_broadcast_count_by_process_offset = offset - result.size;
                    }
                    res._post_boot_broadcast_count_by_process_last_offset = offset;
                    res._post_boot_broadcast_count_by_process_cnt += 1;
                },
                AndroidBootMetricWire.POST_BOOT_BRODCAST_DURATION_AGG_BY_INTENT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._post_boot_brodcast_duration_agg_by_intent_offset == null) {
                        res._post_boot_brodcast_duration_agg_by_intent_offset = offset - result.size;
                    }
                    res._post_boot_brodcast_duration_agg_by_intent_last_offset = offset;
                    res._post_boot_brodcast_duration_agg_by_intent_cnt += 1;
                },
                AndroidBootMetricWire.POST_BOOT_BRODCAST_DURATION_AGG_BY_PROCESS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._post_boot_brodcast_duration_agg_by_process_offset == null) {
                        res._post_boot_brodcast_duration_agg_by_process_offset = offset - result.size;
                    }
                    res._post_boot_brodcast_duration_agg_by_process_last_offset = offset;
                    res._post_boot_brodcast_duration_agg_by_process_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getSystemServerDurations(self: *const AndroidBootMetricReader) gremlin.Error!ProcessStateDurationsReader {
        if (self._system_server_durations_buf) |buf| {
            return try ProcessStateDurationsReader.init(buf);
        }
        return try ProcessStateDurationsReader.init(&[_]u8{});
    }
    pub fn getSystemuiDurations(self: *const AndroidBootMetricReader) gremlin.Error!ProcessStateDurationsReader {
        if (self._systemui_durations_buf) |buf| {
            return try ProcessStateDurationsReader.init(buf);
        }
        return try ProcessStateDurationsReader.init(&[_]u8{});
    }
    pub fn getLauncherDurations(self: *const AndroidBootMetricReader) gremlin.Error!ProcessStateDurationsReader {
        if (self._launcher_durations_buf) |buf| {
            return try ProcessStateDurationsReader.init(buf);
        }
        return try ProcessStateDurationsReader.init(&[_]u8{});
    }
    pub fn getGmsDurations(self: *const AndroidBootMetricReader) gremlin.Error!ProcessStateDurationsReader {
        if (self._gms_durations_buf) |buf| {
            return try ProcessStateDurationsReader.init(buf);
        }
        return try ProcessStateDurationsReader.init(&[_]u8{});
    }
    pub fn getLauncherBreakdown(self: *const AndroidBootMetricReader) gremlin.Error!AndroidBootMetric.LauncherBreakdownReader {
        if (self._launcher_breakdown_buf) |buf| {
            return try AndroidBootMetric.LauncherBreakdownReader.init(buf);
        }
        return try AndroidBootMetric.LauncherBreakdownReader.init(&[_]u8{});
    }
    pub fn getFullTraceProcessStartAggregation(self: *const AndroidBootMetricReader) gremlin.Error!AndroidBootMetric.ProcessStartAggregationReader {
        if (self._full_trace_process_start_aggregation_buf) |buf| {
            return try AndroidBootMetric.ProcessStartAggregationReader.init(buf);
        }
        return try AndroidBootMetric.ProcessStartAggregationReader.init(&[_]u8{});
    }
    pub fn getPostBootProcessStartAggregation(self: *const AndroidBootMetricReader) gremlin.Error!AndroidBootMetric.ProcessStartAggregationReader {
        if (self._post_boot_process_start_aggregation_buf) |buf| {
            return try AndroidBootMetric.ProcessStartAggregationReader.init(buf);
        }
        return try AndroidBootMetric.ProcessStartAggregationReader.init(&[_]u8{});
    }
    pub fn getFullTraceGcAggregation(self: *const AndroidBootMetricReader) gremlin.Error!AndroidBootMetric.GarbageCollectionAggregationReader {
        if (self._full_trace_gc_aggregation_buf) |buf| {
            return try AndroidBootMetric.GarbageCollectionAggregationReader.init(buf);
        }
        return try AndroidBootMetric.GarbageCollectionAggregationReader.init(&[_]u8{});
    }
    pub fn getPostBootGcAggregation(self: *const AndroidBootMetricReader) gremlin.Error!AndroidBootMetric.GarbageCollectionAggregationReader {
        if (self._post_boot_gc_aggregation_buf) |buf| {
            return try AndroidBootMetric.GarbageCollectionAggregationReader.init(buf);
        }
        return try AndroidBootMetric.GarbageCollectionAggregationReader.init(&[_]u8{});
    }
    pub fn postBootOomAdjusterTransitionCountsGlobalCount(self: *const AndroidBootMetricReader) usize {
        return self._post_boot_oom_adjuster_transition_counts_global_cnt;
    }
    pub fn postBootOomAdjusterTransitionCountsGlobalNext(self: *AndroidBootMetricReader) ?AndroidBootMetric.OomAdjusterTransitionCountsReader {
        if (self._post_boot_oom_adjuster_transition_counts_global_offset == null) return null;
        const current_offset = self._post_boot_oom_adjuster_transition_counts_global_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidBootMetric.OomAdjusterTransitionCountsReader.init(result.value) catch return null;
        if (self._post_boot_oom_adjuster_transition_counts_global_last_offset != null and current_offset >= self._post_boot_oom_adjuster_transition_counts_global_last_offset.?) {
            self._post_boot_oom_adjuster_transition_counts_global_offset = null;
            return msg;
        }
        if (self._post_boot_oom_adjuster_transition_counts_global_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._post_boot_oom_adjuster_transition_counts_global_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidBootMetricWire.POST_BOOT_OOM_ADJUSTER_TRANSITION_COUNTS_GLOBAL_WIRE) {
                self._post_boot_oom_adjuster_transition_counts_global_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._post_boot_oom_adjuster_transition_counts_global_offset = null;
        return msg;
    }
    pub fn postBootOomAdjusterTransitionCountsByProcessCount(self: *const AndroidBootMetricReader) usize {
        return self._post_boot_oom_adjuster_transition_counts_by_process_cnt;
    }
    pub fn postBootOomAdjusterTransitionCountsByProcessNext(self: *AndroidBootMetricReader) ?AndroidBootMetric.OomAdjusterTransitionCountsReader {
        if (self._post_boot_oom_adjuster_transition_counts_by_process_offset == null) return null;
        const current_offset = self._post_boot_oom_adjuster_transition_counts_by_process_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidBootMetric.OomAdjusterTransitionCountsReader.init(result.value) catch return null;
        if (self._post_boot_oom_adjuster_transition_counts_by_process_last_offset != null and current_offset >= self._post_boot_oom_adjuster_transition_counts_by_process_last_offset.?) {
            self._post_boot_oom_adjuster_transition_counts_by_process_offset = null;
            return msg;
        }
        if (self._post_boot_oom_adjuster_transition_counts_by_process_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._post_boot_oom_adjuster_transition_counts_by_process_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidBootMetricWire.POST_BOOT_OOM_ADJUSTER_TRANSITION_COUNTS_BY_PROCESS_WIRE) {
                self._post_boot_oom_adjuster_transition_counts_by_process_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._post_boot_oom_adjuster_transition_counts_by_process_offset = null;
        return msg;
    }
    pub fn postBootOomAdjusterTransitionCountsByOomAdjReasonCount(self: *const AndroidBootMetricReader) usize {
        return self._post_boot_oom_adjuster_transition_counts_by_oom_adj_reason_cnt;
    }
    pub fn postBootOomAdjusterTransitionCountsByOomAdjReasonNext(self: *AndroidBootMetricReader) ?AndroidBootMetric.OomAdjusterTransitionCountsReader {
        if (self._post_boot_oom_adjuster_transition_counts_by_oom_adj_reason_offset == null) return null;
        const current_offset = self._post_boot_oom_adjuster_transition_counts_by_oom_adj_reason_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidBootMetric.OomAdjusterTransitionCountsReader.init(result.value) catch return null;
        if (self._post_boot_oom_adjuster_transition_counts_by_oom_adj_reason_last_offset != null and current_offset >= self._post_boot_oom_adjuster_transition_counts_by_oom_adj_reason_last_offset.?) {
            self._post_boot_oom_adjuster_transition_counts_by_oom_adj_reason_offset = null;
            return msg;
        }
        if (self._post_boot_oom_adjuster_transition_counts_by_oom_adj_reason_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._post_boot_oom_adjuster_transition_counts_by_oom_adj_reason_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidBootMetricWire.POST_BOOT_OOM_ADJUSTER_TRANSITION_COUNTS_BY_OOM_ADJ_REASON_WIRE) {
                self._post_boot_oom_adjuster_transition_counts_by_oom_adj_reason_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._post_boot_oom_adjuster_transition_counts_by_oom_adj_reason_offset = null;
        return msg;
    }
    pub fn postBootOomAdjBucketDurationAggGlobalCount(self: *const AndroidBootMetricReader) usize {
        return self._post_boot_oom_adj_bucket_duration_agg_global_cnt;
    }
    pub fn postBootOomAdjBucketDurationAggGlobalNext(self: *AndroidBootMetricReader) ?AndroidBootMetric.OomAdjBucketDurationAggregationReader {
        if (self._post_boot_oom_adj_bucket_duration_agg_global_offset == null) return null;
        const current_offset = self._post_boot_oom_adj_bucket_duration_agg_global_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidBootMetric.OomAdjBucketDurationAggregationReader.init(result.value) catch return null;
        if (self._post_boot_oom_adj_bucket_duration_agg_global_last_offset != null and current_offset >= self._post_boot_oom_adj_bucket_duration_agg_global_last_offset.?) {
            self._post_boot_oom_adj_bucket_duration_agg_global_offset = null;
            return msg;
        }
        if (self._post_boot_oom_adj_bucket_duration_agg_global_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._post_boot_oom_adj_bucket_duration_agg_global_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidBootMetricWire.POST_BOOT_OOM_ADJ_BUCKET_DURATION_AGG_GLOBAL_WIRE) {
                self._post_boot_oom_adj_bucket_duration_agg_global_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._post_boot_oom_adj_bucket_duration_agg_global_offset = null;
        return msg;
    }
    pub fn postBootOomAdjBucketDurationAggByProcessCount(self: *const AndroidBootMetricReader) usize {
        return self._post_boot_oom_adj_bucket_duration_agg_by_process_cnt;
    }
    pub fn postBootOomAdjBucketDurationAggByProcessNext(self: *AndroidBootMetricReader) ?AndroidBootMetric.OomAdjBucketDurationAggregationReader {
        if (self._post_boot_oom_adj_bucket_duration_agg_by_process_offset == null) return null;
        const current_offset = self._post_boot_oom_adj_bucket_duration_agg_by_process_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidBootMetric.OomAdjBucketDurationAggregationReader.init(result.value) catch return null;
        if (self._post_boot_oom_adj_bucket_duration_agg_by_process_last_offset != null and current_offset >= self._post_boot_oom_adj_bucket_duration_agg_by_process_last_offset.?) {
            self._post_boot_oom_adj_bucket_duration_agg_by_process_offset = null;
            return msg;
        }
        if (self._post_boot_oom_adj_bucket_duration_agg_by_process_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._post_boot_oom_adj_bucket_duration_agg_by_process_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidBootMetricWire.POST_BOOT_OOM_ADJ_BUCKET_DURATION_AGG_BY_PROCESS_WIRE) {
                self._post_boot_oom_adj_bucket_duration_agg_by_process_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._post_boot_oom_adj_bucket_duration_agg_by_process_offset = null;
        return msg;
    }
    pub fn postBootOomAdjDurationAggCount(self: *const AndroidBootMetricReader) usize {
        return self._post_boot_oom_adj_duration_agg_cnt;
    }
    pub fn postBootOomAdjDurationAggNext(self: *AndroidBootMetricReader) ?AndroidBootMetric.OomAdjDurationAggregationReader {
        if (self._post_boot_oom_adj_duration_agg_offset == null) return null;
        const current_offset = self._post_boot_oom_adj_duration_agg_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidBootMetric.OomAdjDurationAggregationReader.init(result.value) catch return null;
        if (self._post_boot_oom_adj_duration_agg_last_offset != null and current_offset >= self._post_boot_oom_adj_duration_agg_last_offset.?) {
            self._post_boot_oom_adj_duration_agg_offset = null;
            return msg;
        }
        if (self._post_boot_oom_adj_duration_agg_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._post_boot_oom_adj_duration_agg_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidBootMetricWire.POST_BOOT_OOM_ADJ_DURATION_AGG_WIRE) {
                self._post_boot_oom_adj_duration_agg_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._post_boot_oom_adj_duration_agg_offset = null;
        return msg;
    }
    pub fn postBootBroadcastProcessCountByIntentCount(self: *const AndroidBootMetricReader) usize {
        return self._post_boot_broadcast_process_count_by_intent_cnt;
    }
    pub fn postBootBroadcastProcessCountByIntentNext(self: *AndroidBootMetricReader) ?AndroidBootMetric.BroadcastCountAggregationReader {
        if (self._post_boot_broadcast_process_count_by_intent_offset == null) return null;
        const current_offset = self._post_boot_broadcast_process_count_by_intent_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidBootMetric.BroadcastCountAggregationReader.init(result.value) catch return null;
        if (self._post_boot_broadcast_process_count_by_intent_last_offset != null and current_offset >= self._post_boot_broadcast_process_count_by_intent_last_offset.?) {
            self._post_boot_broadcast_process_count_by_intent_offset = null;
            return msg;
        }
        if (self._post_boot_broadcast_process_count_by_intent_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._post_boot_broadcast_process_count_by_intent_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidBootMetricWire.POST_BOOT_BROADCAST_PROCESS_COUNT_BY_INTENT_WIRE) {
                self._post_boot_broadcast_process_count_by_intent_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._post_boot_broadcast_process_count_by_intent_offset = null;
        return msg;
    }
    pub fn postBootBroadcastCountByProcessCount(self: *const AndroidBootMetricReader) usize {
        return self._post_boot_broadcast_count_by_process_cnt;
    }
    pub fn postBootBroadcastCountByProcessNext(self: *AndroidBootMetricReader) ?AndroidBootMetric.BroadcastCountAggregationReader {
        if (self._post_boot_broadcast_count_by_process_offset == null) return null;
        const current_offset = self._post_boot_broadcast_count_by_process_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidBootMetric.BroadcastCountAggregationReader.init(result.value) catch return null;
        if (self._post_boot_broadcast_count_by_process_last_offset != null and current_offset >= self._post_boot_broadcast_count_by_process_last_offset.?) {
            self._post_boot_broadcast_count_by_process_offset = null;
            return msg;
        }
        if (self._post_boot_broadcast_count_by_process_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._post_boot_broadcast_count_by_process_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidBootMetricWire.POST_BOOT_BROADCAST_COUNT_BY_PROCESS_WIRE) {
                self._post_boot_broadcast_count_by_process_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._post_boot_broadcast_count_by_process_offset = null;
        return msg;
    }
    pub fn postBootBrodcastDurationAggByIntentCount(self: *const AndroidBootMetricReader) usize {
        return self._post_boot_brodcast_duration_agg_by_intent_cnt;
    }
    pub fn postBootBrodcastDurationAggByIntentNext(self: *AndroidBootMetricReader) ?AndroidBootMetric.BroadcastDurationAggregationReader {
        if (self._post_boot_brodcast_duration_agg_by_intent_offset == null) return null;
        const current_offset = self._post_boot_brodcast_duration_agg_by_intent_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidBootMetric.BroadcastDurationAggregationReader.init(result.value) catch return null;
        if (self._post_boot_brodcast_duration_agg_by_intent_last_offset != null and current_offset >= self._post_boot_brodcast_duration_agg_by_intent_last_offset.?) {
            self._post_boot_brodcast_duration_agg_by_intent_offset = null;
            return msg;
        }
        if (self._post_boot_brodcast_duration_agg_by_intent_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._post_boot_brodcast_duration_agg_by_intent_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidBootMetricWire.POST_BOOT_BRODCAST_DURATION_AGG_BY_INTENT_WIRE) {
                self._post_boot_brodcast_duration_agg_by_intent_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._post_boot_brodcast_duration_agg_by_intent_offset = null;
        return msg;
    }
    pub fn postBootBrodcastDurationAggByProcessCount(self: *const AndroidBootMetricReader) usize {
        return self._post_boot_brodcast_duration_agg_by_process_cnt;
    }
    pub fn postBootBrodcastDurationAggByProcessNext(self: *AndroidBootMetricReader) ?AndroidBootMetric.BroadcastDurationAggregationReader {
        if (self._post_boot_brodcast_duration_agg_by_process_offset == null) return null;
        const current_offset = self._post_boot_brodcast_duration_agg_by_process_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidBootMetric.BroadcastDurationAggregationReader.init(result.value) catch return null;
        if (self._post_boot_brodcast_duration_agg_by_process_last_offset != null and current_offset >= self._post_boot_brodcast_duration_agg_by_process_last_offset.?) {
            self._post_boot_brodcast_duration_agg_by_process_offset = null;
            return msg;
        }
        if (self._post_boot_brodcast_duration_agg_by_process_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._post_boot_brodcast_duration_agg_by_process_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidBootMetricWire.POST_BOOT_BRODCAST_DURATION_AGG_BY_PROCESS_WIRE) {
                self._post_boot_brodcast_duration_agg_by_process_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._post_boot_brodcast_duration_agg_by_process_offset = null;
        return msg;
    }
};
const AndroidGarbageCollectionUnaggMetricWire = struct {
    const GC_EVENTS_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const AndroidGarbageCollectionUnaggMetric = struct {
    // nested structs
    const GarbageCollectionEventWire = struct {
        const THREAD_NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const PROCESS_NAME_WIRE: gremlin.ProtoWireNumber = 2;
        const GC_TYPE_WIRE: gremlin.ProtoWireNumber = 3;
        const IS_MARK_COMPACT_WIRE: gremlin.ProtoWireNumber = 4;
        const RECLAIMED_MB_WIRE: gremlin.ProtoWireNumber = 5;
        const MIN_HEAP_MB_WIRE: gremlin.ProtoWireNumber = 6;
        const MAX_HEAP_MB_WIRE: gremlin.ProtoWireNumber = 7;
        const MB_PER_MS_OF_RUNNING_GC_WIRE: gremlin.ProtoWireNumber = 8;
        const MB_PER_MS_OF_WALL_GC_WIRE: gremlin.ProtoWireNumber = 9;
        const GC_DUR_WIRE: gremlin.ProtoWireNumber = 10;
        const GC_RUNNING_DUR_WIRE: gremlin.ProtoWireNumber = 11;
        const GC_RUNNABLE_DUR_WIRE: gremlin.ProtoWireNumber = 12;
        const GC_UNINT_IO_DUR_WIRE: gremlin.ProtoWireNumber = 13;
        const GC_UNINT_NON_IO_DUR_WIRE: gremlin.ProtoWireNumber = 14;
        const GC_INT_DUR_WIRE: gremlin.ProtoWireNumber = 15;
        const GC_TS_WIRE: gremlin.ProtoWireNumber = 16;
        const PID_WIRE: gremlin.ProtoWireNumber = 17;
        const TID_WIRE: gremlin.ProtoWireNumber = 18;
        const GC_MONOTONIC_DUR_WIRE: gremlin.ProtoWireNumber = 19;
        const PROCESS_WIRE: gremlin.ProtoWireNumber = 20;
        const GC_COUNT_WIRE: gremlin.ProtoWireNumber = 21;
    };
    pub const GarbageCollectionEvent = struct {
        // fields
        thread_name: ?[]const u8 = null,
        process_name: ?[]const u8 = null,
        gc_type: ?[]const u8 = null,
        is_mark_compact: i64 = 0,
        reclaimed_mb: f64 = 0.0,
        min_heap_mb: f64 = 0.0,
        max_heap_mb: f64 = 0.0,
        mb_per_ms_of_running_gc: f64 = 0.0,
        mb_per_ms_of_wall_gc: f64 = 0.0,
        gc_dur: i64 = 0,
        gc_running_dur: i64 = 0,
        gc_runnable_dur: i64 = 0,
        gc_unint_io_dur: i64 = 0,
        gc_unint_non_io_dur: i64 = 0,
        gc_int_dur: i64 = 0,
        gc_ts: i64 = 0,
        pid: i64 = 0,
        tid: i64 = 0,
        gc_monotonic_dur: i64 = 0,
        process: ?AndroidProcessMetadata = null,
        gc_count: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidGarbageCollectionUnaggMetric.GarbageCollectionEvent) usize {
            var res: usize = 0;
            if (self.thread_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.THREAD_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.process_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.PROCESS_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.gc_type) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.GC_TYPE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.is_mark_compact != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.IS_MARK_COMPACT_WIRE) + gremlin.sizes.sizeI64(self.is_mark_compact);
            }
            if (self.reclaimed_mb != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.RECLAIMED_MB_WIRE) + gremlin.sizes.sizeDouble(self.reclaimed_mb);
            }
            if (self.min_heap_mb != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.MIN_HEAP_MB_WIRE) + gremlin.sizes.sizeDouble(self.min_heap_mb);
            }
            if (self.max_heap_mb != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.MAX_HEAP_MB_WIRE) + gremlin.sizes.sizeDouble(self.max_heap_mb);
            }
            if (self.mb_per_ms_of_running_gc != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.MB_PER_MS_OF_RUNNING_GC_WIRE) + gremlin.sizes.sizeDouble(self.mb_per_ms_of_running_gc);
            }
            if (self.mb_per_ms_of_wall_gc != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.MB_PER_MS_OF_WALL_GC_WIRE) + gremlin.sizes.sizeDouble(self.mb_per_ms_of_wall_gc);
            }
            if (self.gc_dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.GC_DUR_WIRE) + gremlin.sizes.sizeI64(self.gc_dur);
            }
            if (self.gc_running_dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.GC_RUNNING_DUR_WIRE) + gremlin.sizes.sizeI64(self.gc_running_dur);
            }
            if (self.gc_runnable_dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.GC_RUNNABLE_DUR_WIRE) + gremlin.sizes.sizeI64(self.gc_runnable_dur);
            }
            if (self.gc_unint_io_dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.GC_UNINT_IO_DUR_WIRE) + gremlin.sizes.sizeI64(self.gc_unint_io_dur);
            }
            if (self.gc_unint_non_io_dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.GC_UNINT_NON_IO_DUR_WIRE) + gremlin.sizes.sizeI64(self.gc_unint_non_io_dur);
            }
            if (self.gc_int_dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.GC_INT_DUR_WIRE) + gremlin.sizes.sizeI64(self.gc_int_dur);
            }
            if (self.gc_ts != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.GC_TS_WIRE) + gremlin.sizes.sizeI64(self.gc_ts);
            }
            if (self.pid != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.PID_WIRE) + gremlin.sizes.sizeI64(self.pid);
            }
            if (self.tid != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.TID_WIRE) + gremlin.sizes.sizeI64(self.tid);
            }
            if (self.gc_monotonic_dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.GC_MONOTONIC_DUR_WIRE) + gremlin.sizes.sizeI64(self.gc_monotonic_dur);
            }
            if (self.process) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.PROCESS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.gc_count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.GC_COUNT_WIRE) + gremlin.sizes.sizeI64(self.gc_count);
            }
            return res;
        }
        pub fn encode(self: *const AndroidGarbageCollectionUnaggMetric.GarbageCollectionEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidGarbageCollectionUnaggMetric.GarbageCollectionEvent, target: *gremlin.Writer) void {
            if (self.thread_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.THREAD_NAME_WIRE, v);
                }
            }
            if (self.process_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.PROCESS_NAME_WIRE, v);
                }
            }
            if (self.gc_type) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.GC_TYPE_WIRE, v);
                }
            }
            if (self.is_mark_compact != 0) {
                target.appendInt64(AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.IS_MARK_COMPACT_WIRE, self.is_mark_compact);
            }
            if (self.reclaimed_mb != 0.0) {
                target.appendFloat64(AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.RECLAIMED_MB_WIRE, self.reclaimed_mb);
            }
            if (self.min_heap_mb != 0.0) {
                target.appendFloat64(AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.MIN_HEAP_MB_WIRE, self.min_heap_mb);
            }
            if (self.max_heap_mb != 0.0) {
                target.appendFloat64(AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.MAX_HEAP_MB_WIRE, self.max_heap_mb);
            }
            if (self.mb_per_ms_of_running_gc != 0.0) {
                target.appendFloat64(AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.MB_PER_MS_OF_RUNNING_GC_WIRE, self.mb_per_ms_of_running_gc);
            }
            if (self.mb_per_ms_of_wall_gc != 0.0) {
                target.appendFloat64(AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.MB_PER_MS_OF_WALL_GC_WIRE, self.mb_per_ms_of_wall_gc);
            }
            if (self.gc_dur != 0) {
                target.appendInt64(AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.GC_DUR_WIRE, self.gc_dur);
            }
            if (self.gc_running_dur != 0) {
                target.appendInt64(AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.GC_RUNNING_DUR_WIRE, self.gc_running_dur);
            }
            if (self.gc_runnable_dur != 0) {
                target.appendInt64(AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.GC_RUNNABLE_DUR_WIRE, self.gc_runnable_dur);
            }
            if (self.gc_unint_io_dur != 0) {
                target.appendInt64(AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.GC_UNINT_IO_DUR_WIRE, self.gc_unint_io_dur);
            }
            if (self.gc_unint_non_io_dur != 0) {
                target.appendInt64(AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.GC_UNINT_NON_IO_DUR_WIRE, self.gc_unint_non_io_dur);
            }
            if (self.gc_int_dur != 0) {
                target.appendInt64(AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.GC_INT_DUR_WIRE, self.gc_int_dur);
            }
            if (self.gc_ts != 0) {
                target.appendInt64(AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.GC_TS_WIRE, self.gc_ts);
            }
            if (self.pid != 0) {
                target.appendInt64(AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.PID_WIRE, self.pid);
            }
            if (self.tid != 0) {
                target.appendInt64(AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.TID_WIRE, self.tid);
            }
            if (self.gc_monotonic_dur != 0) {
                target.appendInt64(AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.GC_MONOTONIC_DUR_WIRE, self.gc_monotonic_dur);
            }
            if (self.process) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.PROCESS_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.gc_count != 0) {
                target.appendInt64(AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.GC_COUNT_WIRE, self.gc_count);
            }
        }
    };
    pub const GarbageCollectionEventReader = struct {
        buf: gremlin.Reader,
        _thread_name: ?[]const u8 = null,
        _process_name: ?[]const u8 = null,
        _gc_type: ?[]const u8 = null,
        _is_mark_compact: i64 = 0,
        _reclaimed_mb: f64 = 0.0,
        _min_heap_mb: f64 = 0.0,
        _max_heap_mb: f64 = 0.0,
        _mb_per_ms_of_running_gc: f64 = 0.0,
        _mb_per_ms_of_wall_gc: f64 = 0.0,
        _gc_dur: i64 = 0,
        _gc_running_dur: i64 = 0,
        _gc_runnable_dur: i64 = 0,
        _gc_unint_io_dur: i64 = 0,
        _gc_unint_non_io_dur: i64 = 0,
        _gc_int_dur: i64 = 0,
        _gc_ts: i64 = 0,
        _pid: i64 = 0,
        _tid: i64 = 0,
        _gc_monotonic_dur: i64 = 0,
        _process_buf: ?[]const u8 = null,
        _gc_count: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.THREAD_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._thread_name = result.value;
                    },
                    AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.PROCESS_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._process_name = result.value;
                    },
                    AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.GC_TYPE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._gc_type = result.value;
                    },
                    AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.IS_MARK_COMPACT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._is_mark_compact = result.value;
                    },
                    AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.RECLAIMED_MB_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._reclaimed_mb = result.value;
                    },
                    AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.MIN_HEAP_MB_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._min_heap_mb = result.value;
                    },
                    AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.MAX_HEAP_MB_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._max_heap_mb = result.value;
                    },
                    AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.MB_PER_MS_OF_RUNNING_GC_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._mb_per_ms_of_running_gc = result.value;
                    },
                    AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.MB_PER_MS_OF_WALL_GC_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._mb_per_ms_of_wall_gc = result.value;
                    },
                    AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.GC_DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._gc_dur = result.value;
                    },
                    AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.GC_RUNNING_DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._gc_running_dur = result.value;
                    },
                    AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.GC_RUNNABLE_DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._gc_runnable_dur = result.value;
                    },
                    AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.GC_UNINT_IO_DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._gc_unint_io_dur = result.value;
                    },
                    AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.GC_UNINT_NON_IO_DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._gc_unint_non_io_dur = result.value;
                    },
                    AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.GC_INT_DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._gc_int_dur = result.value;
                    },
                    AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.GC_TS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._gc_ts = result.value;
                    },
                    AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.PID_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._pid = result.value;
                    },
                    AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.TID_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._tid = result.value;
                    },
                    AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.GC_MONOTONIC_DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._gc_monotonic_dur = result.value;
                    },
                    AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.PROCESS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._process_buf = result.value;
                    },
                    AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventWire.GC_COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._gc_count = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getThreadName(self: *const AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventReader) []const u8 {
            return self._thread_name orelse &[_]u8{};
        }
        pub inline fn getProcessName(self: *const AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventReader) []const u8 {
            return self._process_name orelse &[_]u8{};
        }
        pub inline fn getGcType(self: *const AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventReader) []const u8 {
            return self._gc_type orelse &[_]u8{};
        }
        pub inline fn getIsMarkCompact(self: *const AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventReader) i64 {
            return self._is_mark_compact;
        }
        pub inline fn getReclaimedMb(self: *const AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventReader) f64 {
            return self._reclaimed_mb;
        }
        pub inline fn getMinHeapMb(self: *const AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventReader) f64 {
            return self._min_heap_mb;
        }
        pub inline fn getMaxHeapMb(self: *const AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventReader) f64 {
            return self._max_heap_mb;
        }
        pub inline fn getMbPerMsOfRunningGc(self: *const AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventReader) f64 {
            return self._mb_per_ms_of_running_gc;
        }
        pub inline fn getMbPerMsOfWallGc(self: *const AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventReader) f64 {
            return self._mb_per_ms_of_wall_gc;
        }
        pub inline fn getGcDur(self: *const AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventReader) i64 {
            return self._gc_dur;
        }
        pub inline fn getGcRunningDur(self: *const AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventReader) i64 {
            return self._gc_running_dur;
        }
        pub inline fn getGcRunnableDur(self: *const AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventReader) i64 {
            return self._gc_runnable_dur;
        }
        pub inline fn getGcUnintIoDur(self: *const AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventReader) i64 {
            return self._gc_unint_io_dur;
        }
        pub inline fn getGcUnintNonIoDur(self: *const AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventReader) i64 {
            return self._gc_unint_non_io_dur;
        }
        pub inline fn getGcIntDur(self: *const AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventReader) i64 {
            return self._gc_int_dur;
        }
        pub inline fn getGcTs(self: *const AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventReader) i64 {
            return self._gc_ts;
        }
        pub inline fn getPid(self: *const AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventReader) i64 {
            return self._pid;
        }
        pub inline fn getTid(self: *const AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventReader) i64 {
            return self._tid;
        }
        pub inline fn getGcMonotonicDur(self: *const AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventReader) i64 {
            return self._gc_monotonic_dur;
        }
        pub fn getProcess(self: *const AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventReader) gremlin.Error!AndroidProcessMetadataReader {
            if (self._process_buf) |buf| {
                return try AndroidProcessMetadataReader.init(buf);
            }
            return try AndroidProcessMetadataReader.init(&[_]u8{});
        }
        pub inline fn getGcCount(self: *const AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventReader) i64 {
            return self._gc_count;
        }
    };
    // fields
    gc_events: ?[]const ?AndroidGarbageCollectionUnaggMetric.GarbageCollectionEvent = null,
    pub fn calcProtobufSize(self: *const AndroidGarbageCollectionUnaggMetric) usize {
        var res: usize = 0;
        if (self.gc_events) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionUnaggMetricWire.GC_EVENTS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidGarbageCollectionUnaggMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidGarbageCollectionUnaggMetric, target: *gremlin.Writer) void {
        if (self.gc_events) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidGarbageCollectionUnaggMetricWire.GC_EVENTS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidGarbageCollectionUnaggMetricWire.GC_EVENTS_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidGarbageCollectionUnaggMetricReader = struct {
    buf: gremlin.Reader,
    _gc_events_offset: ?usize = null,
    _gc_events_last_offset: ?usize = null,
    _gc_events_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidGarbageCollectionUnaggMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidGarbageCollectionUnaggMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidGarbageCollectionUnaggMetricWire.GC_EVENTS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._gc_events_offset == null) {
                        res._gc_events_offset = offset - result.size;
                    }
                    res._gc_events_last_offset = offset;
                    res._gc_events_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn gcEventsCount(self: *const AndroidGarbageCollectionUnaggMetricReader) usize {
        return self._gc_events_cnt;
    }
    pub fn gcEventsNext(self: *AndroidGarbageCollectionUnaggMetricReader) ?AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventReader {
        if (self._gc_events_offset == null) return null;
        const current_offset = self._gc_events_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidGarbageCollectionUnaggMetric.GarbageCollectionEventReader.init(result.value) catch return null;
        if (self._gc_events_last_offset != null and current_offset >= self._gc_events_last_offset.?) {
            self._gc_events_offset = null;
            return msg;
        }
        if (self._gc_events_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._gc_events_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidGarbageCollectionUnaggMetricWire.GC_EVENTS_WIRE) {
                self._gc_events_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._gc_events_offset = null;
        return msg;
    }
};
const AndroidAppProcessStartsMetricWire = struct {
    const ALL_APPS_WIRE: gremlin.ProtoWireNumber = 1;
    const STARTED_BY_BROADCAST_WIRE: gremlin.ProtoWireNumber = 2;
    const STARTED_BY_SERVICE_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const AndroidAppProcessStartsMetric = struct {
    // nested structs
    const ProcessStartWire = struct {
        const PROCESS_NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const INTENT_WIRE: gremlin.ProtoWireNumber = 2;
        const REASON_WIRE: gremlin.ProtoWireNumber = 3;
        const PROC_START_DUR_WIRE: gremlin.ProtoWireNumber = 4;
        const BIND_APP_DUR_WIRE: gremlin.ProtoWireNumber = 5;
        const INTENT_DUR_WIRE: gremlin.ProtoWireNumber = 6;
        const TOTAL_DUR_WIRE: gremlin.ProtoWireNumber = 7;
    };
    pub const ProcessStart = struct {
        // fields
        process_name: ?[]const u8 = null,
        intent: ?[]const u8 = null,
        reason: ?[]const u8 = null,
        proc_start_dur: i64 = 0,
        bind_app_dur: i64 = 0,
        intent_dur: i64 = 0,
        total_dur: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidAppProcessStartsMetric.ProcessStart) usize {
            var res: usize = 0;
            if (self.process_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidAppProcessStartsMetric.ProcessStartWire.PROCESS_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.intent) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidAppProcessStartsMetric.ProcessStartWire.INTENT_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.reason) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidAppProcessStartsMetric.ProcessStartWire.REASON_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.proc_start_dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidAppProcessStartsMetric.ProcessStartWire.PROC_START_DUR_WIRE) + gremlin.sizes.sizeI64(self.proc_start_dur);
            }
            if (self.bind_app_dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidAppProcessStartsMetric.ProcessStartWire.BIND_APP_DUR_WIRE) + gremlin.sizes.sizeI64(self.bind_app_dur);
            }
            if (self.intent_dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidAppProcessStartsMetric.ProcessStartWire.INTENT_DUR_WIRE) + gremlin.sizes.sizeI64(self.intent_dur);
            }
            if (self.total_dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidAppProcessStartsMetric.ProcessStartWire.TOTAL_DUR_WIRE) + gremlin.sizes.sizeI64(self.total_dur);
            }
            return res;
        }
        pub fn encode(self: *const AndroidAppProcessStartsMetric.ProcessStart, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidAppProcessStartsMetric.ProcessStart, target: *gremlin.Writer) void {
            if (self.process_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidAppProcessStartsMetric.ProcessStartWire.PROCESS_NAME_WIRE, v);
                }
            }
            if (self.intent) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidAppProcessStartsMetric.ProcessStartWire.INTENT_WIRE, v);
                }
            }
            if (self.reason) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidAppProcessStartsMetric.ProcessStartWire.REASON_WIRE, v);
                }
            }
            if (self.proc_start_dur != 0) {
                target.appendInt64(AndroidAppProcessStartsMetric.ProcessStartWire.PROC_START_DUR_WIRE, self.proc_start_dur);
            }
            if (self.bind_app_dur != 0) {
                target.appendInt64(AndroidAppProcessStartsMetric.ProcessStartWire.BIND_APP_DUR_WIRE, self.bind_app_dur);
            }
            if (self.intent_dur != 0) {
                target.appendInt64(AndroidAppProcessStartsMetric.ProcessStartWire.INTENT_DUR_WIRE, self.intent_dur);
            }
            if (self.total_dur != 0) {
                target.appendInt64(AndroidAppProcessStartsMetric.ProcessStartWire.TOTAL_DUR_WIRE, self.total_dur);
            }
        }
    };
    pub const ProcessStartReader = struct {
        buf: gremlin.Reader,
        _process_name: ?[]const u8 = null,
        _intent: ?[]const u8 = null,
        _reason: ?[]const u8 = null,
        _proc_start_dur: i64 = 0,
        _bind_app_dur: i64 = 0,
        _intent_dur: i64 = 0,
        _total_dur: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidAppProcessStartsMetric.ProcessStartReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidAppProcessStartsMetric.ProcessStartReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidAppProcessStartsMetric.ProcessStartWire.PROCESS_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._process_name = result.value;
                    },
                    AndroidAppProcessStartsMetric.ProcessStartWire.INTENT_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._intent = result.value;
                    },
                    AndroidAppProcessStartsMetric.ProcessStartWire.REASON_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._reason = result.value;
                    },
                    AndroidAppProcessStartsMetric.ProcessStartWire.PROC_START_DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._proc_start_dur = result.value;
                    },
                    AndroidAppProcessStartsMetric.ProcessStartWire.BIND_APP_DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._bind_app_dur = result.value;
                    },
                    AndroidAppProcessStartsMetric.ProcessStartWire.INTENT_DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._intent_dur = result.value;
                    },
                    AndroidAppProcessStartsMetric.ProcessStartWire.TOTAL_DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._total_dur = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getProcessName(self: *const AndroidAppProcessStartsMetric.ProcessStartReader) []const u8 {
            return self._process_name orelse &[_]u8{};
        }
        pub inline fn getIntent(self: *const AndroidAppProcessStartsMetric.ProcessStartReader) []const u8 {
            return self._intent orelse &[_]u8{};
        }
        pub inline fn getReason(self: *const AndroidAppProcessStartsMetric.ProcessStartReader) []const u8 {
            return self._reason orelse &[_]u8{};
        }
        pub inline fn getProcStartDur(self: *const AndroidAppProcessStartsMetric.ProcessStartReader) i64 {
            return self._proc_start_dur;
        }
        pub inline fn getBindAppDur(self: *const AndroidAppProcessStartsMetric.ProcessStartReader) i64 {
            return self._bind_app_dur;
        }
        pub inline fn getIntentDur(self: *const AndroidAppProcessStartsMetric.ProcessStartReader) i64 {
            return self._intent_dur;
        }
        pub inline fn getTotalDur(self: *const AndroidAppProcessStartsMetric.ProcessStartReader) i64 {
            return self._total_dur;
        }
    };
    // fields
    all_apps: ?[]const ?AndroidAppProcessStartsMetric.ProcessStart = null,
    started_by_broadcast: ?[]const ?AndroidAppProcessStartsMetric.ProcessStart = null,
    started_by_service: ?[]const ?AndroidAppProcessStartsMetric.ProcessStart = null,
    pub fn calcProtobufSize(self: *const AndroidAppProcessStartsMetric) usize {
        var res: usize = 0;
        if (self.all_apps) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidAppProcessStartsMetricWire.ALL_APPS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.started_by_broadcast) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidAppProcessStartsMetricWire.STARTED_BY_BROADCAST_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.started_by_service) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidAppProcessStartsMetricWire.STARTED_BY_SERVICE_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidAppProcessStartsMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidAppProcessStartsMetric, target: *gremlin.Writer) void {
        if (self.all_apps) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidAppProcessStartsMetricWire.ALL_APPS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidAppProcessStartsMetricWire.ALL_APPS_WIRE, 0);
                }
            }
        }
        if (self.started_by_broadcast) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidAppProcessStartsMetricWire.STARTED_BY_BROADCAST_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidAppProcessStartsMetricWire.STARTED_BY_BROADCAST_WIRE, 0);
                }
            }
        }
        if (self.started_by_service) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidAppProcessStartsMetricWire.STARTED_BY_SERVICE_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidAppProcessStartsMetricWire.STARTED_BY_SERVICE_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidAppProcessStartsMetricReader = struct {
    buf: gremlin.Reader,
    _all_apps_offset: ?usize = null,
    _all_apps_last_offset: ?usize = null,
    _all_apps_cnt: usize = 0,
    _started_by_broadcast_offset: ?usize = null,
    _started_by_broadcast_last_offset: ?usize = null,
    _started_by_broadcast_cnt: usize = 0,
    _started_by_service_offset: ?usize = null,
    _started_by_service_last_offset: ?usize = null,
    _started_by_service_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidAppProcessStartsMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidAppProcessStartsMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidAppProcessStartsMetricWire.ALL_APPS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._all_apps_offset == null) {
                        res._all_apps_offset = offset - result.size;
                    }
                    res._all_apps_last_offset = offset;
                    res._all_apps_cnt += 1;
                },
                AndroidAppProcessStartsMetricWire.STARTED_BY_BROADCAST_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._started_by_broadcast_offset == null) {
                        res._started_by_broadcast_offset = offset - result.size;
                    }
                    res._started_by_broadcast_last_offset = offset;
                    res._started_by_broadcast_cnt += 1;
                },
                AndroidAppProcessStartsMetricWire.STARTED_BY_SERVICE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._started_by_service_offset == null) {
                        res._started_by_service_offset = offset - result.size;
                    }
                    res._started_by_service_last_offset = offset;
                    res._started_by_service_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn allAppsCount(self: *const AndroidAppProcessStartsMetricReader) usize {
        return self._all_apps_cnt;
    }
    pub fn allAppsNext(self: *AndroidAppProcessStartsMetricReader) ?AndroidAppProcessStartsMetric.ProcessStartReader {
        if (self._all_apps_offset == null) return null;
        const current_offset = self._all_apps_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidAppProcessStartsMetric.ProcessStartReader.init(result.value) catch return null;
        if (self._all_apps_last_offset != null and current_offset >= self._all_apps_last_offset.?) {
            self._all_apps_offset = null;
            return msg;
        }
        if (self._all_apps_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._all_apps_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidAppProcessStartsMetricWire.ALL_APPS_WIRE) {
                self._all_apps_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._all_apps_offset = null;
        return msg;
    }
    pub fn startedByBroadcastCount(self: *const AndroidAppProcessStartsMetricReader) usize {
        return self._started_by_broadcast_cnt;
    }
    pub fn startedByBroadcastNext(self: *AndroidAppProcessStartsMetricReader) ?AndroidAppProcessStartsMetric.ProcessStartReader {
        if (self._started_by_broadcast_offset == null) return null;
        const current_offset = self._started_by_broadcast_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidAppProcessStartsMetric.ProcessStartReader.init(result.value) catch return null;
        if (self._started_by_broadcast_last_offset != null and current_offset >= self._started_by_broadcast_last_offset.?) {
            self._started_by_broadcast_offset = null;
            return msg;
        }
        if (self._started_by_broadcast_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._started_by_broadcast_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidAppProcessStartsMetricWire.STARTED_BY_BROADCAST_WIRE) {
                self._started_by_broadcast_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._started_by_broadcast_offset = null;
        return msg;
    }
    pub fn startedByServiceCount(self: *const AndroidAppProcessStartsMetricReader) usize {
        return self._started_by_service_cnt;
    }
    pub fn startedByServiceNext(self: *AndroidAppProcessStartsMetricReader) ?AndroidAppProcessStartsMetric.ProcessStartReader {
        if (self._started_by_service_offset == null) return null;
        const current_offset = self._started_by_service_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidAppProcessStartsMetric.ProcessStartReader.init(result.value) catch return null;
        if (self._started_by_service_last_offset != null and current_offset >= self._started_by_service_last_offset.?) {
            self._started_by_service_offset = null;
            return msg;
        }
        if (self._started_by_service_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._started_by_service_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidAppProcessStartsMetricWire.STARTED_BY_SERVICE_WIRE) {
                self._started_by_service_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._started_by_service_offset = null;
        return msg;
    }
};
const AndroidBootUnaggWire = struct {
    const ANDROID_APP_PROCESS_START_METRIC_WIRE: gremlin.ProtoWireNumber = 1;
    const ANDROID_POST_BOOT_GC_METRIC_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const AndroidBootUnagg = struct {
    // fields
    android_app_process_start_metric: ?AndroidAppProcessStartsMetric = null,
    android_post_boot_gc_metric: ?AndroidGarbageCollectionUnaggMetric = null,
    pub fn calcProtobufSize(self: *const AndroidBootUnagg) usize {
        var res: usize = 0;
        if (self.android_app_process_start_metric) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBootUnaggWire.ANDROID_APP_PROCESS_START_METRIC_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_post_boot_gc_metric) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBootUnaggWire.ANDROID_POST_BOOT_GC_METRIC_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidBootUnagg, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidBootUnagg, target: *gremlin.Writer) void {
        if (self.android_app_process_start_metric) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidBootUnaggWire.ANDROID_APP_PROCESS_START_METRIC_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_post_boot_gc_metric) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidBootUnaggWire.ANDROID_POST_BOOT_GC_METRIC_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const AndroidBootUnaggReader = struct {
    buf: gremlin.Reader,
    _android_app_process_start_metric_buf: ?[]const u8 = null,
    _android_post_boot_gc_metric_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!AndroidBootUnaggReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidBootUnaggReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidBootUnaggWire.ANDROID_APP_PROCESS_START_METRIC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_app_process_start_metric_buf = result.value;
                },
                AndroidBootUnaggWire.ANDROID_POST_BOOT_GC_METRIC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_post_boot_gc_metric_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getAndroidAppProcessStartMetric(self: *const AndroidBootUnaggReader) gremlin.Error!AndroidAppProcessStartsMetricReader {
        if (self._android_app_process_start_metric_buf) |buf| {
            return try AndroidAppProcessStartsMetricReader.init(buf);
        }
        return try AndroidAppProcessStartsMetricReader.init(&[_]u8{});
    }
    pub fn getAndroidPostBootGcMetric(self: *const AndroidBootUnaggReader) gremlin.Error!AndroidGarbageCollectionUnaggMetricReader {
        if (self._android_post_boot_gc_metric_buf) |buf| {
            return try AndroidGarbageCollectionUnaggMetricReader.init(buf);
        }
        return try AndroidGarbageCollectionUnaggMetricReader.init(&[_]u8{});
    }
};
const AndroidBroadcastsMetricWire = struct {
    const PROCESS_COUNT_BY_INTENT_WIRE: gremlin.ProtoWireNumber = 1;
    const BROADCAST_COUNT_BY_PROCESS_WIRE: gremlin.ProtoWireNumber = 2;
    const BRODCAST_DURATION_AGG_BY_INTENT_WIRE: gremlin.ProtoWireNumber = 3;
    const BRODCAST_DURATION_AGG_BY_PROCESS_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const AndroidBroadcastsMetric = struct {
    // nested structs
    const BroadcastCountAggregationWire = struct {
        const NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const COUNT_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const BroadcastCountAggregation = struct {
        // fields
        name: ?[]const u8 = null,
        count: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidBroadcastsMetric.BroadcastCountAggregation) usize {
            var res: usize = 0;
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidBroadcastsMetric.BroadcastCountAggregationWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBroadcastsMetric.BroadcastCountAggregationWire.COUNT_WIRE) + gremlin.sizes.sizeI64(self.count);
            }
            return res;
        }
        pub fn encode(self: *const AndroidBroadcastsMetric.BroadcastCountAggregation, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidBroadcastsMetric.BroadcastCountAggregation, target: *gremlin.Writer) void {
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidBroadcastsMetric.BroadcastCountAggregationWire.NAME_WIRE, v);
                }
            }
            if (self.count != 0) {
                target.appendInt64(AndroidBroadcastsMetric.BroadcastCountAggregationWire.COUNT_WIRE, self.count);
            }
        }
    };
    pub const BroadcastCountAggregationReader = struct {
        buf: gremlin.Reader,
        _name: ?[]const u8 = null,
        _count: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidBroadcastsMetric.BroadcastCountAggregationReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidBroadcastsMetric.BroadcastCountAggregationReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidBroadcastsMetric.BroadcastCountAggregationWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    AndroidBroadcastsMetric.BroadcastCountAggregationWire.COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._count = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getName(self: *const AndroidBroadcastsMetric.BroadcastCountAggregationReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub inline fn getCount(self: *const AndroidBroadcastsMetric.BroadcastCountAggregationReader) i64 {
            return self._count;
        }
    };
    const BroadcastDurationAggregationWire = struct {
        const NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const AVG_DURATION_WIRE: gremlin.ProtoWireNumber = 2;
        const MAX_DURATION_WIRE: gremlin.ProtoWireNumber = 3;
        const SUM_DURATION_WIRE: gremlin.ProtoWireNumber = 4;
    };
    pub const BroadcastDurationAggregation = struct {
        // fields
        name: ?[]const u8 = null,
        avg_duration: f64 = 0.0,
        max_duration: i64 = 0,
        sum_duration: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidBroadcastsMetric.BroadcastDurationAggregation) usize {
            var res: usize = 0;
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidBroadcastsMetric.BroadcastDurationAggregationWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.avg_duration != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBroadcastsMetric.BroadcastDurationAggregationWire.AVG_DURATION_WIRE) + gremlin.sizes.sizeDouble(self.avg_duration);
            }
            if (self.max_duration != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBroadcastsMetric.BroadcastDurationAggregationWire.MAX_DURATION_WIRE) + gremlin.sizes.sizeI64(self.max_duration);
            }
            if (self.sum_duration != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBroadcastsMetric.BroadcastDurationAggregationWire.SUM_DURATION_WIRE) + gremlin.sizes.sizeI64(self.sum_duration);
            }
            return res;
        }
        pub fn encode(self: *const AndroidBroadcastsMetric.BroadcastDurationAggregation, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidBroadcastsMetric.BroadcastDurationAggregation, target: *gremlin.Writer) void {
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidBroadcastsMetric.BroadcastDurationAggregationWire.NAME_WIRE, v);
                }
            }
            if (self.avg_duration != 0.0) {
                target.appendFloat64(AndroidBroadcastsMetric.BroadcastDurationAggregationWire.AVG_DURATION_WIRE, self.avg_duration);
            }
            if (self.max_duration != 0) {
                target.appendInt64(AndroidBroadcastsMetric.BroadcastDurationAggregationWire.MAX_DURATION_WIRE, self.max_duration);
            }
            if (self.sum_duration != 0) {
                target.appendInt64(AndroidBroadcastsMetric.BroadcastDurationAggregationWire.SUM_DURATION_WIRE, self.sum_duration);
            }
        }
    };
    pub const BroadcastDurationAggregationReader = struct {
        buf: gremlin.Reader,
        _name: ?[]const u8 = null,
        _avg_duration: f64 = 0.0,
        _max_duration: i64 = 0,
        _sum_duration: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidBroadcastsMetric.BroadcastDurationAggregationReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidBroadcastsMetric.BroadcastDurationAggregationReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidBroadcastsMetric.BroadcastDurationAggregationWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    AndroidBroadcastsMetric.BroadcastDurationAggregationWire.AVG_DURATION_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._avg_duration = result.value;
                    },
                    AndroidBroadcastsMetric.BroadcastDurationAggregationWire.MAX_DURATION_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._max_duration = result.value;
                    },
                    AndroidBroadcastsMetric.BroadcastDurationAggregationWire.SUM_DURATION_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._sum_duration = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getName(self: *const AndroidBroadcastsMetric.BroadcastDurationAggregationReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub inline fn getAvgDuration(self: *const AndroidBroadcastsMetric.BroadcastDurationAggregationReader) f64 {
            return self._avg_duration;
        }
        pub inline fn getMaxDuration(self: *const AndroidBroadcastsMetric.BroadcastDurationAggregationReader) i64 {
            return self._max_duration;
        }
        pub inline fn getSumDuration(self: *const AndroidBroadcastsMetric.BroadcastDurationAggregationReader) i64 {
            return self._sum_duration;
        }
    };
    // fields
    process_count_by_intent: ?[]const ?AndroidBroadcastsMetric.BroadcastCountAggregation = null,
    broadcast_count_by_process: ?[]const ?AndroidBroadcastsMetric.BroadcastCountAggregation = null,
    brodcast_duration_agg_by_intent: ?[]const ?AndroidBroadcastsMetric.BroadcastDurationAggregation = null,
    brodcast_duration_agg_by_process: ?[]const ?AndroidBroadcastsMetric.BroadcastDurationAggregation = null,
    pub fn calcProtobufSize(self: *const AndroidBroadcastsMetric) usize {
        var res: usize = 0;
        if (self.process_count_by_intent) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidBroadcastsMetricWire.PROCESS_COUNT_BY_INTENT_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.broadcast_count_by_process) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidBroadcastsMetricWire.BROADCAST_COUNT_BY_PROCESS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.brodcast_duration_agg_by_intent) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidBroadcastsMetricWire.BRODCAST_DURATION_AGG_BY_INTENT_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.brodcast_duration_agg_by_process) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidBroadcastsMetricWire.BRODCAST_DURATION_AGG_BY_PROCESS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidBroadcastsMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidBroadcastsMetric, target: *gremlin.Writer) void {
        if (self.process_count_by_intent) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidBroadcastsMetricWire.PROCESS_COUNT_BY_INTENT_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidBroadcastsMetricWire.PROCESS_COUNT_BY_INTENT_WIRE, 0);
                }
            }
        }
        if (self.broadcast_count_by_process) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidBroadcastsMetricWire.BROADCAST_COUNT_BY_PROCESS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidBroadcastsMetricWire.BROADCAST_COUNT_BY_PROCESS_WIRE, 0);
                }
            }
        }
        if (self.brodcast_duration_agg_by_intent) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidBroadcastsMetricWire.BRODCAST_DURATION_AGG_BY_INTENT_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidBroadcastsMetricWire.BRODCAST_DURATION_AGG_BY_INTENT_WIRE, 0);
                }
            }
        }
        if (self.brodcast_duration_agg_by_process) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidBroadcastsMetricWire.BRODCAST_DURATION_AGG_BY_PROCESS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidBroadcastsMetricWire.BRODCAST_DURATION_AGG_BY_PROCESS_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidBroadcastsMetricReader = struct {
    buf: gremlin.Reader,
    _process_count_by_intent_offset: ?usize = null,
    _process_count_by_intent_last_offset: ?usize = null,
    _process_count_by_intent_cnt: usize = 0,
    _broadcast_count_by_process_offset: ?usize = null,
    _broadcast_count_by_process_last_offset: ?usize = null,
    _broadcast_count_by_process_cnt: usize = 0,
    _brodcast_duration_agg_by_intent_offset: ?usize = null,
    _brodcast_duration_agg_by_intent_last_offset: ?usize = null,
    _brodcast_duration_agg_by_intent_cnt: usize = 0,
    _brodcast_duration_agg_by_process_offset: ?usize = null,
    _brodcast_duration_agg_by_process_last_offset: ?usize = null,
    _brodcast_duration_agg_by_process_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidBroadcastsMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidBroadcastsMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidBroadcastsMetricWire.PROCESS_COUNT_BY_INTENT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._process_count_by_intent_offset == null) {
                        res._process_count_by_intent_offset = offset - result.size;
                    }
                    res._process_count_by_intent_last_offset = offset;
                    res._process_count_by_intent_cnt += 1;
                },
                AndroidBroadcastsMetricWire.BROADCAST_COUNT_BY_PROCESS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._broadcast_count_by_process_offset == null) {
                        res._broadcast_count_by_process_offset = offset - result.size;
                    }
                    res._broadcast_count_by_process_last_offset = offset;
                    res._broadcast_count_by_process_cnt += 1;
                },
                AndroidBroadcastsMetricWire.BRODCAST_DURATION_AGG_BY_INTENT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._brodcast_duration_agg_by_intent_offset == null) {
                        res._brodcast_duration_agg_by_intent_offset = offset - result.size;
                    }
                    res._brodcast_duration_agg_by_intent_last_offset = offset;
                    res._brodcast_duration_agg_by_intent_cnt += 1;
                },
                AndroidBroadcastsMetricWire.BRODCAST_DURATION_AGG_BY_PROCESS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._brodcast_duration_agg_by_process_offset == null) {
                        res._brodcast_duration_agg_by_process_offset = offset - result.size;
                    }
                    res._brodcast_duration_agg_by_process_last_offset = offset;
                    res._brodcast_duration_agg_by_process_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn processCountByIntentCount(self: *const AndroidBroadcastsMetricReader) usize {
        return self._process_count_by_intent_cnt;
    }
    pub fn processCountByIntentNext(self: *AndroidBroadcastsMetricReader) ?AndroidBroadcastsMetric.BroadcastCountAggregationReader {
        if (self._process_count_by_intent_offset == null) return null;
        const current_offset = self._process_count_by_intent_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidBroadcastsMetric.BroadcastCountAggregationReader.init(result.value) catch return null;
        if (self._process_count_by_intent_last_offset != null and current_offset >= self._process_count_by_intent_last_offset.?) {
            self._process_count_by_intent_offset = null;
            return msg;
        }
        if (self._process_count_by_intent_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._process_count_by_intent_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidBroadcastsMetricWire.PROCESS_COUNT_BY_INTENT_WIRE) {
                self._process_count_by_intent_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._process_count_by_intent_offset = null;
        return msg;
    }
    pub fn broadcastCountByProcessCount(self: *const AndroidBroadcastsMetricReader) usize {
        return self._broadcast_count_by_process_cnt;
    }
    pub fn broadcastCountByProcessNext(self: *AndroidBroadcastsMetricReader) ?AndroidBroadcastsMetric.BroadcastCountAggregationReader {
        if (self._broadcast_count_by_process_offset == null) return null;
        const current_offset = self._broadcast_count_by_process_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidBroadcastsMetric.BroadcastCountAggregationReader.init(result.value) catch return null;
        if (self._broadcast_count_by_process_last_offset != null and current_offset >= self._broadcast_count_by_process_last_offset.?) {
            self._broadcast_count_by_process_offset = null;
            return msg;
        }
        if (self._broadcast_count_by_process_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._broadcast_count_by_process_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidBroadcastsMetricWire.BROADCAST_COUNT_BY_PROCESS_WIRE) {
                self._broadcast_count_by_process_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._broadcast_count_by_process_offset = null;
        return msg;
    }
    pub fn brodcastDurationAggByIntentCount(self: *const AndroidBroadcastsMetricReader) usize {
        return self._brodcast_duration_agg_by_intent_cnt;
    }
    pub fn brodcastDurationAggByIntentNext(self: *AndroidBroadcastsMetricReader) ?AndroidBroadcastsMetric.BroadcastDurationAggregationReader {
        if (self._brodcast_duration_agg_by_intent_offset == null) return null;
        const current_offset = self._brodcast_duration_agg_by_intent_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidBroadcastsMetric.BroadcastDurationAggregationReader.init(result.value) catch return null;
        if (self._brodcast_duration_agg_by_intent_last_offset != null and current_offset >= self._brodcast_duration_agg_by_intent_last_offset.?) {
            self._brodcast_duration_agg_by_intent_offset = null;
            return msg;
        }
        if (self._brodcast_duration_agg_by_intent_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._brodcast_duration_agg_by_intent_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidBroadcastsMetricWire.BRODCAST_DURATION_AGG_BY_INTENT_WIRE) {
                self._brodcast_duration_agg_by_intent_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._brodcast_duration_agg_by_intent_offset = null;
        return msg;
    }
    pub fn brodcastDurationAggByProcessCount(self: *const AndroidBroadcastsMetricReader) usize {
        return self._brodcast_duration_agg_by_process_cnt;
    }
    pub fn brodcastDurationAggByProcessNext(self: *AndroidBroadcastsMetricReader) ?AndroidBroadcastsMetric.BroadcastDurationAggregationReader {
        if (self._brodcast_duration_agg_by_process_offset == null) return null;
        const current_offset = self._brodcast_duration_agg_by_process_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidBroadcastsMetric.BroadcastDurationAggregationReader.init(result.value) catch return null;
        if (self._brodcast_duration_agg_by_process_last_offset != null and current_offset >= self._brodcast_duration_agg_by_process_last_offset.?) {
            self._brodcast_duration_agg_by_process_offset = null;
            return msg;
        }
        if (self._brodcast_duration_agg_by_process_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._brodcast_duration_agg_by_process_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidBroadcastsMetricWire.BRODCAST_DURATION_AGG_BY_PROCESS_WIRE) {
                self._brodcast_duration_agg_by_process_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._brodcast_duration_agg_by_process_offset = null;
        return msg;
    }
};
const AndroidFrameTimelineMetricWire = struct {
    const TOTAL_FRAMES_WIRE: gremlin.ProtoWireNumber = 4;
    const MISSED_APP_FRAMES_WIRE: gremlin.ProtoWireNumber = 5;
    const DROPPED_FRAMES_WIRE: gremlin.ProtoWireNumber = 6;
    const PROCESS_WIRE: gremlin.ProtoWireNumber = 2;
    const JANK_TYPES_WIRE: gremlin.ProtoWireNumber = 7;
};
pub const AndroidFrameTimelineMetric = struct {
    // nested structs
    const JankTypeMetricWire = struct {
        const TYPE_WIRE: gremlin.ProtoWireNumber = 1;
        const TOTAL_COUNT_WIRE: gremlin.ProtoWireNumber = 2;
        const PRESENT_UNSPECIFIED_COUNT_WIRE: gremlin.ProtoWireNumber = 3;
        const PRESENT_ON_TIME_COUNT_WIRE: gremlin.ProtoWireNumber = 4;
        const PRESENT_LATE_COUNT_WIRE: gremlin.ProtoWireNumber = 5;
        const PRESENT_EARLY_COUNT_WIRE: gremlin.ProtoWireNumber = 6;
        const PRESENT_DROPPED_COUNT_WIRE: gremlin.ProtoWireNumber = 7;
        const PRESENT_UNKNOWN_COUNT_WIRE: gremlin.ProtoWireNumber = 8;
    };
    pub const JankTypeMetric = struct {
        // fields
        type: ?[]const u8 = null,
        total_count: i64 = 0,
        present_unspecified_count: i64 = 0,
        present_on_time_count: i64 = 0,
        present_late_count: i64 = 0,
        present_early_count: i64 = 0,
        present_dropped_count: i64 = 0,
        present_unknown_count: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidFrameTimelineMetric.JankTypeMetric) usize {
            var res: usize = 0;
            if (self.type) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidFrameTimelineMetric.JankTypeMetricWire.TYPE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.total_count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidFrameTimelineMetric.JankTypeMetricWire.TOTAL_COUNT_WIRE) + gremlin.sizes.sizeI64(self.total_count);
            }
            if (self.present_unspecified_count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidFrameTimelineMetric.JankTypeMetricWire.PRESENT_UNSPECIFIED_COUNT_WIRE) + gremlin.sizes.sizeI64(self.present_unspecified_count);
            }
            if (self.present_on_time_count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidFrameTimelineMetric.JankTypeMetricWire.PRESENT_ON_TIME_COUNT_WIRE) + gremlin.sizes.sizeI64(self.present_on_time_count);
            }
            if (self.present_late_count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidFrameTimelineMetric.JankTypeMetricWire.PRESENT_LATE_COUNT_WIRE) + gremlin.sizes.sizeI64(self.present_late_count);
            }
            if (self.present_early_count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidFrameTimelineMetric.JankTypeMetricWire.PRESENT_EARLY_COUNT_WIRE) + gremlin.sizes.sizeI64(self.present_early_count);
            }
            if (self.present_dropped_count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidFrameTimelineMetric.JankTypeMetricWire.PRESENT_DROPPED_COUNT_WIRE) + gremlin.sizes.sizeI64(self.present_dropped_count);
            }
            if (self.present_unknown_count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidFrameTimelineMetric.JankTypeMetricWire.PRESENT_UNKNOWN_COUNT_WIRE) + gremlin.sizes.sizeI64(self.present_unknown_count);
            }
            return res;
        }
        pub fn encode(self: *const AndroidFrameTimelineMetric.JankTypeMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidFrameTimelineMetric.JankTypeMetric, target: *gremlin.Writer) void {
            if (self.type) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidFrameTimelineMetric.JankTypeMetricWire.TYPE_WIRE, v);
                }
            }
            if (self.total_count != 0) {
                target.appendInt64(AndroidFrameTimelineMetric.JankTypeMetricWire.TOTAL_COUNT_WIRE, self.total_count);
            }
            if (self.present_unspecified_count != 0) {
                target.appendInt64(AndroidFrameTimelineMetric.JankTypeMetricWire.PRESENT_UNSPECIFIED_COUNT_WIRE, self.present_unspecified_count);
            }
            if (self.present_on_time_count != 0) {
                target.appendInt64(AndroidFrameTimelineMetric.JankTypeMetricWire.PRESENT_ON_TIME_COUNT_WIRE, self.present_on_time_count);
            }
            if (self.present_late_count != 0) {
                target.appendInt64(AndroidFrameTimelineMetric.JankTypeMetricWire.PRESENT_LATE_COUNT_WIRE, self.present_late_count);
            }
            if (self.present_early_count != 0) {
                target.appendInt64(AndroidFrameTimelineMetric.JankTypeMetricWire.PRESENT_EARLY_COUNT_WIRE, self.present_early_count);
            }
            if (self.present_dropped_count != 0) {
                target.appendInt64(AndroidFrameTimelineMetric.JankTypeMetricWire.PRESENT_DROPPED_COUNT_WIRE, self.present_dropped_count);
            }
            if (self.present_unknown_count != 0) {
                target.appendInt64(AndroidFrameTimelineMetric.JankTypeMetricWire.PRESENT_UNKNOWN_COUNT_WIRE, self.present_unknown_count);
            }
        }
    };
    pub const JankTypeMetricReader = struct {
        buf: gremlin.Reader,
        _type: ?[]const u8 = null,
        _total_count: i64 = 0,
        _present_unspecified_count: i64 = 0,
        _present_on_time_count: i64 = 0,
        _present_late_count: i64 = 0,
        _present_early_count: i64 = 0,
        _present_dropped_count: i64 = 0,
        _present_unknown_count: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidFrameTimelineMetric.JankTypeMetricReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidFrameTimelineMetric.JankTypeMetricReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidFrameTimelineMetric.JankTypeMetricWire.TYPE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._type = result.value;
                    },
                    AndroidFrameTimelineMetric.JankTypeMetricWire.TOTAL_COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._total_count = result.value;
                    },
                    AndroidFrameTimelineMetric.JankTypeMetricWire.PRESENT_UNSPECIFIED_COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._present_unspecified_count = result.value;
                    },
                    AndroidFrameTimelineMetric.JankTypeMetricWire.PRESENT_ON_TIME_COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._present_on_time_count = result.value;
                    },
                    AndroidFrameTimelineMetric.JankTypeMetricWire.PRESENT_LATE_COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._present_late_count = result.value;
                    },
                    AndroidFrameTimelineMetric.JankTypeMetricWire.PRESENT_EARLY_COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._present_early_count = result.value;
                    },
                    AndroidFrameTimelineMetric.JankTypeMetricWire.PRESENT_DROPPED_COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._present_dropped_count = result.value;
                    },
                    AndroidFrameTimelineMetric.JankTypeMetricWire.PRESENT_UNKNOWN_COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._present_unknown_count = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getType(self: *const AndroidFrameTimelineMetric.JankTypeMetricReader) []const u8 {
            return self._type orelse &[_]u8{};
        }
        pub inline fn getTotalCount(self: *const AndroidFrameTimelineMetric.JankTypeMetricReader) i64 {
            return self._total_count;
        }
        pub inline fn getPresentUnspecifiedCount(self: *const AndroidFrameTimelineMetric.JankTypeMetricReader) i64 {
            return self._present_unspecified_count;
        }
        pub inline fn getPresentOnTimeCount(self: *const AndroidFrameTimelineMetric.JankTypeMetricReader) i64 {
            return self._present_on_time_count;
        }
        pub inline fn getPresentLateCount(self: *const AndroidFrameTimelineMetric.JankTypeMetricReader) i64 {
            return self._present_late_count;
        }
        pub inline fn getPresentEarlyCount(self: *const AndroidFrameTimelineMetric.JankTypeMetricReader) i64 {
            return self._present_early_count;
        }
        pub inline fn getPresentDroppedCount(self: *const AndroidFrameTimelineMetric.JankTypeMetricReader) i64 {
            return self._present_dropped_count;
        }
        pub inline fn getPresentUnknownCount(self: *const AndroidFrameTimelineMetric.JankTypeMetricReader) i64 {
            return self._present_unknown_count;
        }
    };
    const ProcessBreakdownWire = struct {
        const PROCESS_WIRE: gremlin.ProtoWireNumber = 3;
        const TOTAL_FRAMES_WIRE: gremlin.ProtoWireNumber = 4;
        const MISSED_FRAMES_WIRE: gremlin.ProtoWireNumber = 5;
        const MISSED_APP_FRAMES_WIRE: gremlin.ProtoWireNumber = 6;
        const MISSED_SF_FRAMES_WIRE: gremlin.ProtoWireNumber = 7;
        const FRAME_DUR_MAX_WIRE: gremlin.ProtoWireNumber = 8;
        const FRAME_DUR_AVG_WIRE: gremlin.ProtoWireNumber = 9;
        const FRAME_DUR_P50_WIRE: gremlin.ProtoWireNumber = 10;
        const FRAME_DUR_P90_WIRE: gremlin.ProtoWireNumber = 11;
        const FRAME_DUR_P95_WIRE: gremlin.ProtoWireNumber = 12;
        const FRAME_DUR_P99_WIRE: gremlin.ProtoWireNumber = 13;
        const FRAME_DUR_MS_P50_WIRE: gremlin.ProtoWireNumber = 14;
        const FRAME_DUR_MS_P90_WIRE: gremlin.ProtoWireNumber = 15;
        const FRAME_DUR_MS_P95_WIRE: gremlin.ProtoWireNumber = 16;
        const FRAME_DUR_MS_P99_WIRE: gremlin.ProtoWireNumber = 17;
        const DROPPED_FRAMES_WIRE: gremlin.ProtoWireNumber = 18;
        const JANK_TYPES_WIRE: gremlin.ProtoWireNumber = 19;
    };
    pub const ProcessBreakdown = struct {
        // fields
        process: ?AndroidProcessMetadata = null,
        total_frames: i64 = 0,
        missed_frames: i64 = 0,
        missed_app_frames: i64 = 0,
        missed_sf_frames: i64 = 0,
        frame_dur_max: i64 = 0,
        frame_dur_avg: i64 = 0,
        frame_dur_p50: i64 = 0,
        frame_dur_p90: i64 = 0,
        frame_dur_p95: i64 = 0,
        frame_dur_p99: i64 = 0,
        frame_dur_ms_p50: f64 = 0.0,
        frame_dur_ms_p90: f64 = 0.0,
        frame_dur_ms_p95: f64 = 0.0,
        frame_dur_ms_p99: f64 = 0.0,
        dropped_frames: i64 = 0,
        jank_types: ?[]const ?AndroidFrameTimelineMetric.JankTypeMetric = null,
        pub fn calcProtobufSize(self: *const AndroidFrameTimelineMetric.ProcessBreakdown) usize {
            var res: usize = 0;
            if (self.process) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidFrameTimelineMetric.ProcessBreakdownWire.PROCESS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.total_frames != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidFrameTimelineMetric.ProcessBreakdownWire.TOTAL_FRAMES_WIRE) + gremlin.sizes.sizeI64(self.total_frames);
            }
            if (self.missed_frames != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidFrameTimelineMetric.ProcessBreakdownWire.MISSED_FRAMES_WIRE) + gremlin.sizes.sizeI64(self.missed_frames);
            }
            if (self.missed_app_frames != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidFrameTimelineMetric.ProcessBreakdownWire.MISSED_APP_FRAMES_WIRE) + gremlin.sizes.sizeI64(self.missed_app_frames);
            }
            if (self.missed_sf_frames != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidFrameTimelineMetric.ProcessBreakdownWire.MISSED_SF_FRAMES_WIRE) + gremlin.sizes.sizeI64(self.missed_sf_frames);
            }
            if (self.frame_dur_max != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidFrameTimelineMetric.ProcessBreakdownWire.FRAME_DUR_MAX_WIRE) + gremlin.sizes.sizeI64(self.frame_dur_max);
            }
            if (self.frame_dur_avg != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidFrameTimelineMetric.ProcessBreakdownWire.FRAME_DUR_AVG_WIRE) + gremlin.sizes.sizeI64(self.frame_dur_avg);
            }
            if (self.frame_dur_p50 != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidFrameTimelineMetric.ProcessBreakdownWire.FRAME_DUR_P50_WIRE) + gremlin.sizes.sizeI64(self.frame_dur_p50);
            }
            if (self.frame_dur_p90 != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidFrameTimelineMetric.ProcessBreakdownWire.FRAME_DUR_P90_WIRE) + gremlin.sizes.sizeI64(self.frame_dur_p90);
            }
            if (self.frame_dur_p95 != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidFrameTimelineMetric.ProcessBreakdownWire.FRAME_DUR_P95_WIRE) + gremlin.sizes.sizeI64(self.frame_dur_p95);
            }
            if (self.frame_dur_p99 != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidFrameTimelineMetric.ProcessBreakdownWire.FRAME_DUR_P99_WIRE) + gremlin.sizes.sizeI64(self.frame_dur_p99);
            }
            if (self.frame_dur_ms_p50 != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidFrameTimelineMetric.ProcessBreakdownWire.FRAME_DUR_MS_P50_WIRE) + gremlin.sizes.sizeDouble(self.frame_dur_ms_p50);
            }
            if (self.frame_dur_ms_p90 != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidFrameTimelineMetric.ProcessBreakdownWire.FRAME_DUR_MS_P90_WIRE) + gremlin.sizes.sizeDouble(self.frame_dur_ms_p90);
            }
            if (self.frame_dur_ms_p95 != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidFrameTimelineMetric.ProcessBreakdownWire.FRAME_DUR_MS_P95_WIRE) + gremlin.sizes.sizeDouble(self.frame_dur_ms_p95);
            }
            if (self.frame_dur_ms_p99 != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidFrameTimelineMetric.ProcessBreakdownWire.FRAME_DUR_MS_P99_WIRE) + gremlin.sizes.sizeDouble(self.frame_dur_ms_p99);
            }
            if (self.dropped_frames != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidFrameTimelineMetric.ProcessBreakdownWire.DROPPED_FRAMES_WIRE) + gremlin.sizes.sizeI64(self.dropped_frames);
            }
            if (self.jank_types) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidFrameTimelineMetric.ProcessBreakdownWire.JANK_TYPES_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidFrameTimelineMetric.ProcessBreakdown, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidFrameTimelineMetric.ProcessBreakdown, target: *gremlin.Writer) void {
            if (self.process) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidFrameTimelineMetric.ProcessBreakdownWire.PROCESS_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.total_frames != 0) {
                target.appendInt64(AndroidFrameTimelineMetric.ProcessBreakdownWire.TOTAL_FRAMES_WIRE, self.total_frames);
            }
            if (self.missed_frames != 0) {
                target.appendInt64(AndroidFrameTimelineMetric.ProcessBreakdownWire.MISSED_FRAMES_WIRE, self.missed_frames);
            }
            if (self.missed_app_frames != 0) {
                target.appendInt64(AndroidFrameTimelineMetric.ProcessBreakdownWire.MISSED_APP_FRAMES_WIRE, self.missed_app_frames);
            }
            if (self.missed_sf_frames != 0) {
                target.appendInt64(AndroidFrameTimelineMetric.ProcessBreakdownWire.MISSED_SF_FRAMES_WIRE, self.missed_sf_frames);
            }
            if (self.frame_dur_max != 0) {
                target.appendInt64(AndroidFrameTimelineMetric.ProcessBreakdownWire.FRAME_DUR_MAX_WIRE, self.frame_dur_max);
            }
            if (self.frame_dur_avg != 0) {
                target.appendInt64(AndroidFrameTimelineMetric.ProcessBreakdownWire.FRAME_DUR_AVG_WIRE, self.frame_dur_avg);
            }
            if (self.frame_dur_p50 != 0) {
                target.appendInt64(AndroidFrameTimelineMetric.ProcessBreakdownWire.FRAME_DUR_P50_WIRE, self.frame_dur_p50);
            }
            if (self.frame_dur_p90 != 0) {
                target.appendInt64(AndroidFrameTimelineMetric.ProcessBreakdownWire.FRAME_DUR_P90_WIRE, self.frame_dur_p90);
            }
            if (self.frame_dur_p95 != 0) {
                target.appendInt64(AndroidFrameTimelineMetric.ProcessBreakdownWire.FRAME_DUR_P95_WIRE, self.frame_dur_p95);
            }
            if (self.frame_dur_p99 != 0) {
                target.appendInt64(AndroidFrameTimelineMetric.ProcessBreakdownWire.FRAME_DUR_P99_WIRE, self.frame_dur_p99);
            }
            if (self.frame_dur_ms_p50 != 0.0) {
                target.appendFloat64(AndroidFrameTimelineMetric.ProcessBreakdownWire.FRAME_DUR_MS_P50_WIRE, self.frame_dur_ms_p50);
            }
            if (self.frame_dur_ms_p90 != 0.0) {
                target.appendFloat64(AndroidFrameTimelineMetric.ProcessBreakdownWire.FRAME_DUR_MS_P90_WIRE, self.frame_dur_ms_p90);
            }
            if (self.frame_dur_ms_p95 != 0.0) {
                target.appendFloat64(AndroidFrameTimelineMetric.ProcessBreakdownWire.FRAME_DUR_MS_P95_WIRE, self.frame_dur_ms_p95);
            }
            if (self.frame_dur_ms_p99 != 0.0) {
                target.appendFloat64(AndroidFrameTimelineMetric.ProcessBreakdownWire.FRAME_DUR_MS_P99_WIRE, self.frame_dur_ms_p99);
            }
            if (self.dropped_frames != 0) {
                target.appendInt64(AndroidFrameTimelineMetric.ProcessBreakdownWire.DROPPED_FRAMES_WIRE, self.dropped_frames);
            }
            if (self.jank_types) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidFrameTimelineMetric.ProcessBreakdownWire.JANK_TYPES_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidFrameTimelineMetric.ProcessBreakdownWire.JANK_TYPES_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const ProcessBreakdownReader = struct {
        buf: gremlin.Reader,
        _process_buf: ?[]const u8 = null,
        _total_frames: i64 = 0,
        _missed_frames: i64 = 0,
        _missed_app_frames: i64 = 0,
        _missed_sf_frames: i64 = 0,
        _frame_dur_max: i64 = 0,
        _frame_dur_avg: i64 = 0,
        _frame_dur_p50: i64 = 0,
        _frame_dur_p90: i64 = 0,
        _frame_dur_p95: i64 = 0,
        _frame_dur_p99: i64 = 0,
        _frame_dur_ms_p50: f64 = 0.0,
        _frame_dur_ms_p90: f64 = 0.0,
        _frame_dur_ms_p95: f64 = 0.0,
        _frame_dur_ms_p99: f64 = 0.0,
        _dropped_frames: i64 = 0,
        _jank_types_offset: ?usize = null,
        _jank_types_last_offset: ?usize = null,
        _jank_types_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidFrameTimelineMetric.ProcessBreakdownReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidFrameTimelineMetric.ProcessBreakdownReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidFrameTimelineMetric.ProcessBreakdownWire.PROCESS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._process_buf = result.value;
                    },
                    AndroidFrameTimelineMetric.ProcessBreakdownWire.TOTAL_FRAMES_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._total_frames = result.value;
                    },
                    AndroidFrameTimelineMetric.ProcessBreakdownWire.MISSED_FRAMES_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._missed_frames = result.value;
                    },
                    AndroidFrameTimelineMetric.ProcessBreakdownWire.MISSED_APP_FRAMES_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._missed_app_frames = result.value;
                    },
                    AndroidFrameTimelineMetric.ProcessBreakdownWire.MISSED_SF_FRAMES_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._missed_sf_frames = result.value;
                    },
                    AndroidFrameTimelineMetric.ProcessBreakdownWire.FRAME_DUR_MAX_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._frame_dur_max = result.value;
                    },
                    AndroidFrameTimelineMetric.ProcessBreakdownWire.FRAME_DUR_AVG_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._frame_dur_avg = result.value;
                    },
                    AndroidFrameTimelineMetric.ProcessBreakdownWire.FRAME_DUR_P50_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._frame_dur_p50 = result.value;
                    },
                    AndroidFrameTimelineMetric.ProcessBreakdownWire.FRAME_DUR_P90_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._frame_dur_p90 = result.value;
                    },
                    AndroidFrameTimelineMetric.ProcessBreakdownWire.FRAME_DUR_P95_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._frame_dur_p95 = result.value;
                    },
                    AndroidFrameTimelineMetric.ProcessBreakdownWire.FRAME_DUR_P99_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._frame_dur_p99 = result.value;
                    },
                    AndroidFrameTimelineMetric.ProcessBreakdownWire.FRAME_DUR_MS_P50_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._frame_dur_ms_p50 = result.value;
                    },
                    AndroidFrameTimelineMetric.ProcessBreakdownWire.FRAME_DUR_MS_P90_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._frame_dur_ms_p90 = result.value;
                    },
                    AndroidFrameTimelineMetric.ProcessBreakdownWire.FRAME_DUR_MS_P95_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._frame_dur_ms_p95 = result.value;
                    },
                    AndroidFrameTimelineMetric.ProcessBreakdownWire.FRAME_DUR_MS_P99_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._frame_dur_ms_p99 = result.value;
                    },
                    AndroidFrameTimelineMetric.ProcessBreakdownWire.DROPPED_FRAMES_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._dropped_frames = result.value;
                    },
                    AndroidFrameTimelineMetric.ProcessBreakdownWire.JANK_TYPES_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._jank_types_offset == null) {
                            res._jank_types_offset = offset - result.size;
                        }
                        res._jank_types_last_offset = offset;
                        res._jank_types_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn getProcess(self: *const AndroidFrameTimelineMetric.ProcessBreakdownReader) gremlin.Error!AndroidProcessMetadataReader {
            if (self._process_buf) |buf| {
                return try AndroidProcessMetadataReader.init(buf);
            }
            return try AndroidProcessMetadataReader.init(&[_]u8{});
        }
        pub inline fn getTotalFrames(self: *const AndroidFrameTimelineMetric.ProcessBreakdownReader) i64 {
            return self._total_frames;
        }
        pub inline fn getMissedFrames(self: *const AndroidFrameTimelineMetric.ProcessBreakdownReader) i64 {
            return self._missed_frames;
        }
        pub inline fn getMissedAppFrames(self: *const AndroidFrameTimelineMetric.ProcessBreakdownReader) i64 {
            return self._missed_app_frames;
        }
        pub inline fn getMissedSfFrames(self: *const AndroidFrameTimelineMetric.ProcessBreakdownReader) i64 {
            return self._missed_sf_frames;
        }
        pub inline fn getFrameDurMax(self: *const AndroidFrameTimelineMetric.ProcessBreakdownReader) i64 {
            return self._frame_dur_max;
        }
        pub inline fn getFrameDurAvg(self: *const AndroidFrameTimelineMetric.ProcessBreakdownReader) i64 {
            return self._frame_dur_avg;
        }
        pub inline fn getFrameDurP50(self: *const AndroidFrameTimelineMetric.ProcessBreakdownReader) i64 {
            return self._frame_dur_p50;
        }
        pub inline fn getFrameDurP90(self: *const AndroidFrameTimelineMetric.ProcessBreakdownReader) i64 {
            return self._frame_dur_p90;
        }
        pub inline fn getFrameDurP95(self: *const AndroidFrameTimelineMetric.ProcessBreakdownReader) i64 {
            return self._frame_dur_p95;
        }
        pub inline fn getFrameDurP99(self: *const AndroidFrameTimelineMetric.ProcessBreakdownReader) i64 {
            return self._frame_dur_p99;
        }
        pub inline fn getFrameDurMsP50(self: *const AndroidFrameTimelineMetric.ProcessBreakdownReader) f64 {
            return self._frame_dur_ms_p50;
        }
        pub inline fn getFrameDurMsP90(self: *const AndroidFrameTimelineMetric.ProcessBreakdownReader) f64 {
            return self._frame_dur_ms_p90;
        }
        pub inline fn getFrameDurMsP95(self: *const AndroidFrameTimelineMetric.ProcessBreakdownReader) f64 {
            return self._frame_dur_ms_p95;
        }
        pub inline fn getFrameDurMsP99(self: *const AndroidFrameTimelineMetric.ProcessBreakdownReader) f64 {
            return self._frame_dur_ms_p99;
        }
        pub inline fn getDroppedFrames(self: *const AndroidFrameTimelineMetric.ProcessBreakdownReader) i64 {
            return self._dropped_frames;
        }
        pub fn jankTypesCount(self: *const AndroidFrameTimelineMetric.ProcessBreakdownReader) usize {
            return self._jank_types_cnt;
        }
        pub fn jankTypesNext(self: *AndroidFrameTimelineMetric.ProcessBreakdownReader) ?AndroidFrameTimelineMetric.JankTypeMetricReader {
            if (self._jank_types_offset == null) return null;
            const current_offset = self._jank_types_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidFrameTimelineMetric.JankTypeMetricReader.init(result.value) catch return null;
            if (self._jank_types_last_offset != null and current_offset >= self._jank_types_last_offset.?) {
                self._jank_types_offset = null;
                return msg;
            }
            if (self._jank_types_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._jank_types_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidFrameTimelineMetric.ProcessBreakdownWire.JANK_TYPES_WIRE) {
                    self._jank_types_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._jank_types_offset = null;
            return msg;
        }
    };
    // fields
    total_frames: i64 = 0,
    missed_app_frames: i64 = 0,
    dropped_frames: i64 = 0,
    process: ?[]const ?AndroidFrameTimelineMetric.ProcessBreakdown = null,
    jank_types: ?[]const ?AndroidFrameTimelineMetric.JankTypeMetric = null,
    pub fn calcProtobufSize(self: *const AndroidFrameTimelineMetric) usize {
        var res: usize = 0;
        if (self.total_frames != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidFrameTimelineMetricWire.TOTAL_FRAMES_WIRE) + gremlin.sizes.sizeI64(self.total_frames);
        }
        if (self.missed_app_frames != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidFrameTimelineMetricWire.MISSED_APP_FRAMES_WIRE) + gremlin.sizes.sizeI64(self.missed_app_frames);
        }
        if (self.dropped_frames != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidFrameTimelineMetricWire.DROPPED_FRAMES_WIRE) + gremlin.sizes.sizeI64(self.dropped_frames);
        }
        if (self.process) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidFrameTimelineMetricWire.PROCESS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.jank_types) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidFrameTimelineMetricWire.JANK_TYPES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidFrameTimelineMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidFrameTimelineMetric, target: *gremlin.Writer) void {
        if (self.total_frames != 0) {
            target.appendInt64(AndroidFrameTimelineMetricWire.TOTAL_FRAMES_WIRE, self.total_frames);
        }
        if (self.missed_app_frames != 0) {
            target.appendInt64(AndroidFrameTimelineMetricWire.MISSED_APP_FRAMES_WIRE, self.missed_app_frames);
        }
        if (self.dropped_frames != 0) {
            target.appendInt64(AndroidFrameTimelineMetricWire.DROPPED_FRAMES_WIRE, self.dropped_frames);
        }
        if (self.process) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidFrameTimelineMetricWire.PROCESS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidFrameTimelineMetricWire.PROCESS_WIRE, 0);
                }
            }
        }
        if (self.jank_types) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidFrameTimelineMetricWire.JANK_TYPES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidFrameTimelineMetricWire.JANK_TYPES_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidFrameTimelineMetricReader = struct {
    buf: gremlin.Reader,
    _total_frames: i64 = 0,
    _missed_app_frames: i64 = 0,
    _dropped_frames: i64 = 0,
    _process_offset: ?usize = null,
    _process_last_offset: ?usize = null,
    _process_cnt: usize = 0,
    _jank_types_offset: ?usize = null,
    _jank_types_last_offset: ?usize = null,
    _jank_types_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidFrameTimelineMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidFrameTimelineMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidFrameTimelineMetricWire.TOTAL_FRAMES_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._total_frames = result.value;
                },
                AndroidFrameTimelineMetricWire.MISSED_APP_FRAMES_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._missed_app_frames = result.value;
                },
                AndroidFrameTimelineMetricWire.DROPPED_FRAMES_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._dropped_frames = result.value;
                },
                AndroidFrameTimelineMetricWire.PROCESS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._process_offset == null) {
                        res._process_offset = offset - result.size;
                    }
                    res._process_last_offset = offset;
                    res._process_cnt += 1;
                },
                AndroidFrameTimelineMetricWire.JANK_TYPES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._jank_types_offset == null) {
                        res._jank_types_offset = offset - result.size;
                    }
                    res._jank_types_last_offset = offset;
                    res._jank_types_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getTotalFrames(self: *const AndroidFrameTimelineMetricReader) i64 {
        return self._total_frames;
    }
    pub inline fn getMissedAppFrames(self: *const AndroidFrameTimelineMetricReader) i64 {
        return self._missed_app_frames;
    }
    pub inline fn getDroppedFrames(self: *const AndroidFrameTimelineMetricReader) i64 {
        return self._dropped_frames;
    }
    pub fn processCount(self: *const AndroidFrameTimelineMetricReader) usize {
        return self._process_cnt;
    }
    pub fn processNext(self: *AndroidFrameTimelineMetricReader) ?AndroidFrameTimelineMetric.ProcessBreakdownReader {
        if (self._process_offset == null) return null;
        const current_offset = self._process_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidFrameTimelineMetric.ProcessBreakdownReader.init(result.value) catch return null;
        if (self._process_last_offset != null and current_offset >= self._process_last_offset.?) {
            self._process_offset = null;
            return msg;
        }
        if (self._process_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._process_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidFrameTimelineMetricWire.PROCESS_WIRE) {
                self._process_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._process_offset = null;
        return msg;
    }
    pub fn jankTypesCount(self: *const AndroidFrameTimelineMetricReader) usize {
        return self._jank_types_cnt;
    }
    pub fn jankTypesNext(self: *AndroidFrameTimelineMetricReader) ?AndroidFrameTimelineMetric.JankTypeMetricReader {
        if (self._jank_types_offset == null) return null;
        const current_offset = self._jank_types_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidFrameTimelineMetric.JankTypeMetricReader.init(result.value) catch return null;
        if (self._jank_types_last_offset != null and current_offset >= self._jank_types_last_offset.?) {
            self._jank_types_offset = null;
            return msg;
        }
        if (self._jank_types_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._jank_types_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidFrameTimelineMetricWire.JANK_TYPES_WIRE) {
                self._jank_types_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._jank_types_offset = null;
        return msg;
    }
};
const AndroidGarbageCollectionStatsWire = struct {
    const TS_WIRE: gremlin.ProtoWireNumber = 1;
    const DUR_WIRE: gremlin.ProtoWireNumber = 2;
    const HEAP_SIZE_MBS_WIRE: gremlin.ProtoWireNumber = 3;
    const HEAP_SIZE_MB_WIRE: gremlin.ProtoWireNumber = 4;
    const HEAP_ALLOCATED_MB_WIRE: gremlin.ProtoWireNumber = 5;
    const HEAP_ALLOCATION_RATE_WIRE: gremlin.ProtoWireNumber = 6;
    const HEAP_LIVE_MBS_WIRE: gremlin.ProtoWireNumber = 7;
    const HEAP_TOTAL_MBS_WIRE: gremlin.ProtoWireNumber = 8;
    const HEAP_UTILIZATION_WIRE: gremlin.ProtoWireNumber = 9;
    const GC_RUNNING_DUR_WIRE: gremlin.ProtoWireNumber = 10;
    const GC_RUNNING_RATE_WIRE: gremlin.ProtoWireNumber = 11;
    const GC_RUNNING_EFFICIENCY_WIRE: gremlin.ProtoWireNumber = 12;
    const GC_DURING_ANDROID_STARTUP_DUR_WIRE: gremlin.ProtoWireNumber = 13;
    const TOTAL_ANDROID_STARTUP_DUR_WIRE: gremlin.ProtoWireNumber = 14;
    const GC_DURING_ANDROID_STARTUP_RATE_WIRE: gremlin.ProtoWireNumber = 15;
    const GC_DURING_ANDROID_STARTUP_EFFICIENCY_WIRE: gremlin.ProtoWireNumber = 16;
    const PROCESSES_WIRE: gremlin.ProtoWireNumber = 17;
};
pub const AndroidGarbageCollectionStats = struct {
    // nested structs
    const ProcessStatsWire = struct {
        const PROCESS_WIRE: gremlin.ProtoWireNumber = 1;
        const HEAP_SIZE_MBS_WIRE: gremlin.ProtoWireNumber = 2;
        const HEAP_SIZE_MB_WIRE: gremlin.ProtoWireNumber = 3;
        const HEAP_ALLOCATED_MB_WIRE: gremlin.ProtoWireNumber = 4;
        const HEAP_ALLOCATION_RATE_WIRE: gremlin.ProtoWireNumber = 5;
        const HEAP_LIVE_MBS_WIRE: gremlin.ProtoWireNumber = 6;
        const HEAP_TOTAL_MBS_WIRE: gremlin.ProtoWireNumber = 7;
        const HEAP_UTILIZATION_WIRE: gremlin.ProtoWireNumber = 8;
        const GC_RUNNING_DUR_WIRE: gremlin.ProtoWireNumber = 9;
        const GC_RUNNING_RATE_WIRE: gremlin.ProtoWireNumber = 10;
        const GC_RUNNING_EFFICIENCY_WIRE: gremlin.ProtoWireNumber = 11;
        const GC_DURING_ANDROID_STARTUP_DUR_WIRE: gremlin.ProtoWireNumber = 12;
        const GC_DURING_ANDROID_STARTUP_RATE_WIRE: gremlin.ProtoWireNumber = 13;
        const GC_DURING_ANDROID_STARTUP_EFFICIENCY_WIRE: gremlin.ProtoWireNumber = 14;
    };
    pub const ProcessStats = struct {
        // fields
        process: ?AndroidProcessMetadata = null,
        heap_size_mbs: f64 = 0.0,
        heap_size_mb: f64 = 0.0,
        heap_allocated_mb: f64 = 0.0,
        heap_allocation_rate: f64 = 0.0,
        heap_live_mbs: f64 = 0.0,
        heap_total_mbs: f64 = 0.0,
        heap_utilization: f64 = 0.0,
        gc_running_dur: i64 = 0,
        gc_running_rate: f64 = 0.0,
        gc_running_efficiency: f64 = 0.0,
        gc_during_android_startup_dur: i64 = 0,
        gc_during_android_startup_rate: f64 = 0.0,
        gc_during_android_startup_efficiency: f64 = 0.0,
        pub fn calcProtobufSize(self: *const AndroidGarbageCollectionStats.ProcessStats) usize {
            var res: usize = 0;
            if (self.process) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionStats.ProcessStatsWire.PROCESS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.heap_size_mbs != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionStats.ProcessStatsWire.HEAP_SIZE_MBS_WIRE) + gremlin.sizes.sizeDouble(self.heap_size_mbs);
            }
            if (self.heap_size_mb != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionStats.ProcessStatsWire.HEAP_SIZE_MB_WIRE) + gremlin.sizes.sizeDouble(self.heap_size_mb);
            }
            if (self.heap_allocated_mb != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionStats.ProcessStatsWire.HEAP_ALLOCATED_MB_WIRE) + gremlin.sizes.sizeDouble(self.heap_allocated_mb);
            }
            if (self.heap_allocation_rate != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionStats.ProcessStatsWire.HEAP_ALLOCATION_RATE_WIRE) + gremlin.sizes.sizeDouble(self.heap_allocation_rate);
            }
            if (self.heap_live_mbs != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionStats.ProcessStatsWire.HEAP_LIVE_MBS_WIRE) + gremlin.sizes.sizeDouble(self.heap_live_mbs);
            }
            if (self.heap_total_mbs != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionStats.ProcessStatsWire.HEAP_TOTAL_MBS_WIRE) + gremlin.sizes.sizeDouble(self.heap_total_mbs);
            }
            if (self.heap_utilization != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionStats.ProcessStatsWire.HEAP_UTILIZATION_WIRE) + gremlin.sizes.sizeDouble(self.heap_utilization);
            }
            if (self.gc_running_dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionStats.ProcessStatsWire.GC_RUNNING_DUR_WIRE) + gremlin.sizes.sizeI64(self.gc_running_dur);
            }
            if (self.gc_running_rate != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionStats.ProcessStatsWire.GC_RUNNING_RATE_WIRE) + gremlin.sizes.sizeDouble(self.gc_running_rate);
            }
            if (self.gc_running_efficiency != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionStats.ProcessStatsWire.GC_RUNNING_EFFICIENCY_WIRE) + gremlin.sizes.sizeDouble(self.gc_running_efficiency);
            }
            if (self.gc_during_android_startup_dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionStats.ProcessStatsWire.GC_DURING_ANDROID_STARTUP_DUR_WIRE) + gremlin.sizes.sizeI64(self.gc_during_android_startup_dur);
            }
            if (self.gc_during_android_startup_rate != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionStats.ProcessStatsWire.GC_DURING_ANDROID_STARTUP_RATE_WIRE) + gremlin.sizes.sizeDouble(self.gc_during_android_startup_rate);
            }
            if (self.gc_during_android_startup_efficiency != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionStats.ProcessStatsWire.GC_DURING_ANDROID_STARTUP_EFFICIENCY_WIRE) + gremlin.sizes.sizeDouble(self.gc_during_android_startup_efficiency);
            }
            return res;
        }
        pub fn encode(self: *const AndroidGarbageCollectionStats.ProcessStats, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidGarbageCollectionStats.ProcessStats, target: *gremlin.Writer) void {
            if (self.process) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidGarbageCollectionStats.ProcessStatsWire.PROCESS_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.heap_size_mbs != 0.0) {
                target.appendFloat64(AndroidGarbageCollectionStats.ProcessStatsWire.HEAP_SIZE_MBS_WIRE, self.heap_size_mbs);
            }
            if (self.heap_size_mb != 0.0) {
                target.appendFloat64(AndroidGarbageCollectionStats.ProcessStatsWire.HEAP_SIZE_MB_WIRE, self.heap_size_mb);
            }
            if (self.heap_allocated_mb != 0.0) {
                target.appendFloat64(AndroidGarbageCollectionStats.ProcessStatsWire.HEAP_ALLOCATED_MB_WIRE, self.heap_allocated_mb);
            }
            if (self.heap_allocation_rate != 0.0) {
                target.appendFloat64(AndroidGarbageCollectionStats.ProcessStatsWire.HEAP_ALLOCATION_RATE_WIRE, self.heap_allocation_rate);
            }
            if (self.heap_live_mbs != 0.0) {
                target.appendFloat64(AndroidGarbageCollectionStats.ProcessStatsWire.HEAP_LIVE_MBS_WIRE, self.heap_live_mbs);
            }
            if (self.heap_total_mbs != 0.0) {
                target.appendFloat64(AndroidGarbageCollectionStats.ProcessStatsWire.HEAP_TOTAL_MBS_WIRE, self.heap_total_mbs);
            }
            if (self.heap_utilization != 0.0) {
                target.appendFloat64(AndroidGarbageCollectionStats.ProcessStatsWire.HEAP_UTILIZATION_WIRE, self.heap_utilization);
            }
            if (self.gc_running_dur != 0) {
                target.appendInt64(AndroidGarbageCollectionStats.ProcessStatsWire.GC_RUNNING_DUR_WIRE, self.gc_running_dur);
            }
            if (self.gc_running_rate != 0.0) {
                target.appendFloat64(AndroidGarbageCollectionStats.ProcessStatsWire.GC_RUNNING_RATE_WIRE, self.gc_running_rate);
            }
            if (self.gc_running_efficiency != 0.0) {
                target.appendFloat64(AndroidGarbageCollectionStats.ProcessStatsWire.GC_RUNNING_EFFICIENCY_WIRE, self.gc_running_efficiency);
            }
            if (self.gc_during_android_startup_dur != 0) {
                target.appendInt64(AndroidGarbageCollectionStats.ProcessStatsWire.GC_DURING_ANDROID_STARTUP_DUR_WIRE, self.gc_during_android_startup_dur);
            }
            if (self.gc_during_android_startup_rate != 0.0) {
                target.appendFloat64(AndroidGarbageCollectionStats.ProcessStatsWire.GC_DURING_ANDROID_STARTUP_RATE_WIRE, self.gc_during_android_startup_rate);
            }
            if (self.gc_during_android_startup_efficiency != 0.0) {
                target.appendFloat64(AndroidGarbageCollectionStats.ProcessStatsWire.GC_DURING_ANDROID_STARTUP_EFFICIENCY_WIRE, self.gc_during_android_startup_efficiency);
            }
        }
    };
    pub const ProcessStatsReader = struct {
        buf: gremlin.Reader,
        _process_buf: ?[]const u8 = null,
        _heap_size_mbs: f64 = 0.0,
        _heap_size_mb: f64 = 0.0,
        _heap_allocated_mb: f64 = 0.0,
        _heap_allocation_rate: f64 = 0.0,
        _heap_live_mbs: f64 = 0.0,
        _heap_total_mbs: f64 = 0.0,
        _heap_utilization: f64 = 0.0,
        _gc_running_dur: i64 = 0,
        _gc_running_rate: f64 = 0.0,
        _gc_running_efficiency: f64 = 0.0,
        _gc_during_android_startup_dur: i64 = 0,
        _gc_during_android_startup_rate: f64 = 0.0,
        _gc_during_android_startup_efficiency: f64 = 0.0,
        pub fn init(src: []const u8) gremlin.Error!AndroidGarbageCollectionStats.ProcessStatsReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidGarbageCollectionStats.ProcessStatsReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidGarbageCollectionStats.ProcessStatsWire.PROCESS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._process_buf = result.value;
                    },
                    AndroidGarbageCollectionStats.ProcessStatsWire.HEAP_SIZE_MBS_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._heap_size_mbs = result.value;
                    },
                    AndroidGarbageCollectionStats.ProcessStatsWire.HEAP_SIZE_MB_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._heap_size_mb = result.value;
                    },
                    AndroidGarbageCollectionStats.ProcessStatsWire.HEAP_ALLOCATED_MB_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._heap_allocated_mb = result.value;
                    },
                    AndroidGarbageCollectionStats.ProcessStatsWire.HEAP_ALLOCATION_RATE_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._heap_allocation_rate = result.value;
                    },
                    AndroidGarbageCollectionStats.ProcessStatsWire.HEAP_LIVE_MBS_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._heap_live_mbs = result.value;
                    },
                    AndroidGarbageCollectionStats.ProcessStatsWire.HEAP_TOTAL_MBS_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._heap_total_mbs = result.value;
                    },
                    AndroidGarbageCollectionStats.ProcessStatsWire.HEAP_UTILIZATION_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._heap_utilization = result.value;
                    },
                    AndroidGarbageCollectionStats.ProcessStatsWire.GC_RUNNING_DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._gc_running_dur = result.value;
                    },
                    AndroidGarbageCollectionStats.ProcessStatsWire.GC_RUNNING_RATE_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._gc_running_rate = result.value;
                    },
                    AndroidGarbageCollectionStats.ProcessStatsWire.GC_RUNNING_EFFICIENCY_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._gc_running_efficiency = result.value;
                    },
                    AndroidGarbageCollectionStats.ProcessStatsWire.GC_DURING_ANDROID_STARTUP_DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._gc_during_android_startup_dur = result.value;
                    },
                    AndroidGarbageCollectionStats.ProcessStatsWire.GC_DURING_ANDROID_STARTUP_RATE_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._gc_during_android_startup_rate = result.value;
                    },
                    AndroidGarbageCollectionStats.ProcessStatsWire.GC_DURING_ANDROID_STARTUP_EFFICIENCY_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._gc_during_android_startup_efficiency = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn getProcess(self: *const AndroidGarbageCollectionStats.ProcessStatsReader) gremlin.Error!AndroidProcessMetadataReader {
            if (self._process_buf) |buf| {
                return try AndroidProcessMetadataReader.init(buf);
            }
            return try AndroidProcessMetadataReader.init(&[_]u8{});
        }
        pub inline fn getHeapSizeMbs(self: *const AndroidGarbageCollectionStats.ProcessStatsReader) f64 {
            return self._heap_size_mbs;
        }
        pub inline fn getHeapSizeMb(self: *const AndroidGarbageCollectionStats.ProcessStatsReader) f64 {
            return self._heap_size_mb;
        }
        pub inline fn getHeapAllocatedMb(self: *const AndroidGarbageCollectionStats.ProcessStatsReader) f64 {
            return self._heap_allocated_mb;
        }
        pub inline fn getHeapAllocationRate(self: *const AndroidGarbageCollectionStats.ProcessStatsReader) f64 {
            return self._heap_allocation_rate;
        }
        pub inline fn getHeapLiveMbs(self: *const AndroidGarbageCollectionStats.ProcessStatsReader) f64 {
            return self._heap_live_mbs;
        }
        pub inline fn getHeapTotalMbs(self: *const AndroidGarbageCollectionStats.ProcessStatsReader) f64 {
            return self._heap_total_mbs;
        }
        pub inline fn getHeapUtilization(self: *const AndroidGarbageCollectionStats.ProcessStatsReader) f64 {
            return self._heap_utilization;
        }
        pub inline fn getGcRunningDur(self: *const AndroidGarbageCollectionStats.ProcessStatsReader) i64 {
            return self._gc_running_dur;
        }
        pub inline fn getGcRunningRate(self: *const AndroidGarbageCollectionStats.ProcessStatsReader) f64 {
            return self._gc_running_rate;
        }
        pub inline fn getGcRunningEfficiency(self: *const AndroidGarbageCollectionStats.ProcessStatsReader) f64 {
            return self._gc_running_efficiency;
        }
        pub inline fn getGcDuringAndroidStartupDur(self: *const AndroidGarbageCollectionStats.ProcessStatsReader) i64 {
            return self._gc_during_android_startup_dur;
        }
        pub inline fn getGcDuringAndroidStartupRate(self: *const AndroidGarbageCollectionStats.ProcessStatsReader) f64 {
            return self._gc_during_android_startup_rate;
        }
        pub inline fn getGcDuringAndroidStartupEfficiency(self: *const AndroidGarbageCollectionStats.ProcessStatsReader) f64 {
            return self._gc_during_android_startup_efficiency;
        }
    };
    // fields
    ts: i64 = 0,
    dur: i64 = 0,
    heap_size_mbs: f64 = 0.0,
    heap_size_mb: f64 = 0.0,
    heap_allocated_mb: f64 = 0.0,
    heap_allocation_rate: f64 = 0.0,
    heap_live_mbs: f64 = 0.0,
    heap_total_mbs: f64 = 0.0,
    heap_utilization: f64 = 0.0,
    gc_running_dur: i64 = 0,
    gc_running_rate: f64 = 0.0,
    gc_running_efficiency: f64 = 0.0,
    gc_during_android_startup_dur: i64 = 0,
    total_android_startup_dur: i64 = 0,
    gc_during_android_startup_rate: f64 = 0.0,
    gc_during_android_startup_efficiency: f64 = 0.0,
    processes: ?[]const ?AndroidGarbageCollectionStats.ProcessStats = null,
    pub fn calcProtobufSize(self: *const AndroidGarbageCollectionStats) usize {
        var res: usize = 0;
        if (self.ts != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionStatsWire.TS_WIRE) + gremlin.sizes.sizeI64(self.ts);
        }
        if (self.dur != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionStatsWire.DUR_WIRE) + gremlin.sizes.sizeI64(self.dur);
        }
        if (self.heap_size_mbs != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionStatsWire.HEAP_SIZE_MBS_WIRE) + gremlin.sizes.sizeDouble(self.heap_size_mbs);
        }
        if (self.heap_size_mb != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionStatsWire.HEAP_SIZE_MB_WIRE) + gremlin.sizes.sizeDouble(self.heap_size_mb);
        }
        if (self.heap_allocated_mb != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionStatsWire.HEAP_ALLOCATED_MB_WIRE) + gremlin.sizes.sizeDouble(self.heap_allocated_mb);
        }
        if (self.heap_allocation_rate != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionStatsWire.HEAP_ALLOCATION_RATE_WIRE) + gremlin.sizes.sizeDouble(self.heap_allocation_rate);
        }
        if (self.heap_live_mbs != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionStatsWire.HEAP_LIVE_MBS_WIRE) + gremlin.sizes.sizeDouble(self.heap_live_mbs);
        }
        if (self.heap_total_mbs != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionStatsWire.HEAP_TOTAL_MBS_WIRE) + gremlin.sizes.sizeDouble(self.heap_total_mbs);
        }
        if (self.heap_utilization != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionStatsWire.HEAP_UTILIZATION_WIRE) + gremlin.sizes.sizeDouble(self.heap_utilization);
        }
        if (self.gc_running_dur != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionStatsWire.GC_RUNNING_DUR_WIRE) + gremlin.sizes.sizeI64(self.gc_running_dur);
        }
        if (self.gc_running_rate != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionStatsWire.GC_RUNNING_RATE_WIRE) + gremlin.sizes.sizeDouble(self.gc_running_rate);
        }
        if (self.gc_running_efficiency != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionStatsWire.GC_RUNNING_EFFICIENCY_WIRE) + gremlin.sizes.sizeDouble(self.gc_running_efficiency);
        }
        if (self.gc_during_android_startup_dur != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionStatsWire.GC_DURING_ANDROID_STARTUP_DUR_WIRE) + gremlin.sizes.sizeI64(self.gc_during_android_startup_dur);
        }
        if (self.total_android_startup_dur != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionStatsWire.TOTAL_ANDROID_STARTUP_DUR_WIRE) + gremlin.sizes.sizeI64(self.total_android_startup_dur);
        }
        if (self.gc_during_android_startup_rate != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionStatsWire.GC_DURING_ANDROID_STARTUP_RATE_WIRE) + gremlin.sizes.sizeDouble(self.gc_during_android_startup_rate);
        }
        if (self.gc_during_android_startup_efficiency != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionStatsWire.GC_DURING_ANDROID_STARTUP_EFFICIENCY_WIRE) + gremlin.sizes.sizeDouble(self.gc_during_android_startup_efficiency);
        }
        if (self.processes) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidGarbageCollectionStatsWire.PROCESSES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidGarbageCollectionStats, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidGarbageCollectionStats, target: *gremlin.Writer) void {
        if (self.ts != 0) {
            target.appendInt64(AndroidGarbageCollectionStatsWire.TS_WIRE, self.ts);
        }
        if (self.dur != 0) {
            target.appendInt64(AndroidGarbageCollectionStatsWire.DUR_WIRE, self.dur);
        }
        if (self.heap_size_mbs != 0.0) {
            target.appendFloat64(AndroidGarbageCollectionStatsWire.HEAP_SIZE_MBS_WIRE, self.heap_size_mbs);
        }
        if (self.heap_size_mb != 0.0) {
            target.appendFloat64(AndroidGarbageCollectionStatsWire.HEAP_SIZE_MB_WIRE, self.heap_size_mb);
        }
        if (self.heap_allocated_mb != 0.0) {
            target.appendFloat64(AndroidGarbageCollectionStatsWire.HEAP_ALLOCATED_MB_WIRE, self.heap_allocated_mb);
        }
        if (self.heap_allocation_rate != 0.0) {
            target.appendFloat64(AndroidGarbageCollectionStatsWire.HEAP_ALLOCATION_RATE_WIRE, self.heap_allocation_rate);
        }
        if (self.heap_live_mbs != 0.0) {
            target.appendFloat64(AndroidGarbageCollectionStatsWire.HEAP_LIVE_MBS_WIRE, self.heap_live_mbs);
        }
        if (self.heap_total_mbs != 0.0) {
            target.appendFloat64(AndroidGarbageCollectionStatsWire.HEAP_TOTAL_MBS_WIRE, self.heap_total_mbs);
        }
        if (self.heap_utilization != 0.0) {
            target.appendFloat64(AndroidGarbageCollectionStatsWire.HEAP_UTILIZATION_WIRE, self.heap_utilization);
        }
        if (self.gc_running_dur != 0) {
            target.appendInt64(AndroidGarbageCollectionStatsWire.GC_RUNNING_DUR_WIRE, self.gc_running_dur);
        }
        if (self.gc_running_rate != 0.0) {
            target.appendFloat64(AndroidGarbageCollectionStatsWire.GC_RUNNING_RATE_WIRE, self.gc_running_rate);
        }
        if (self.gc_running_efficiency != 0.0) {
            target.appendFloat64(AndroidGarbageCollectionStatsWire.GC_RUNNING_EFFICIENCY_WIRE, self.gc_running_efficiency);
        }
        if (self.gc_during_android_startup_dur != 0) {
            target.appendInt64(AndroidGarbageCollectionStatsWire.GC_DURING_ANDROID_STARTUP_DUR_WIRE, self.gc_during_android_startup_dur);
        }
        if (self.total_android_startup_dur != 0) {
            target.appendInt64(AndroidGarbageCollectionStatsWire.TOTAL_ANDROID_STARTUP_DUR_WIRE, self.total_android_startup_dur);
        }
        if (self.gc_during_android_startup_rate != 0.0) {
            target.appendFloat64(AndroidGarbageCollectionStatsWire.GC_DURING_ANDROID_STARTUP_RATE_WIRE, self.gc_during_android_startup_rate);
        }
        if (self.gc_during_android_startup_efficiency != 0.0) {
            target.appendFloat64(AndroidGarbageCollectionStatsWire.GC_DURING_ANDROID_STARTUP_EFFICIENCY_WIRE, self.gc_during_android_startup_efficiency);
        }
        if (self.processes) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidGarbageCollectionStatsWire.PROCESSES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidGarbageCollectionStatsWire.PROCESSES_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidGarbageCollectionStatsReader = struct {
    buf: gremlin.Reader,
    _ts: i64 = 0,
    _dur: i64 = 0,
    _heap_size_mbs: f64 = 0.0,
    _heap_size_mb: f64 = 0.0,
    _heap_allocated_mb: f64 = 0.0,
    _heap_allocation_rate: f64 = 0.0,
    _heap_live_mbs: f64 = 0.0,
    _heap_total_mbs: f64 = 0.0,
    _heap_utilization: f64 = 0.0,
    _gc_running_dur: i64 = 0,
    _gc_running_rate: f64 = 0.0,
    _gc_running_efficiency: f64 = 0.0,
    _gc_during_android_startup_dur: i64 = 0,
    _total_android_startup_dur: i64 = 0,
    _gc_during_android_startup_rate: f64 = 0.0,
    _gc_during_android_startup_efficiency: f64 = 0.0,
    _processes_offset: ?usize = null,
    _processes_last_offset: ?usize = null,
    _processes_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidGarbageCollectionStatsReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidGarbageCollectionStatsReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidGarbageCollectionStatsWire.TS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._ts = result.value;
                },
                AndroidGarbageCollectionStatsWire.DUR_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._dur = result.value;
                },
                AndroidGarbageCollectionStatsWire.HEAP_SIZE_MBS_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._heap_size_mbs = result.value;
                },
                AndroidGarbageCollectionStatsWire.HEAP_SIZE_MB_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._heap_size_mb = result.value;
                },
                AndroidGarbageCollectionStatsWire.HEAP_ALLOCATED_MB_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._heap_allocated_mb = result.value;
                },
                AndroidGarbageCollectionStatsWire.HEAP_ALLOCATION_RATE_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._heap_allocation_rate = result.value;
                },
                AndroidGarbageCollectionStatsWire.HEAP_LIVE_MBS_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._heap_live_mbs = result.value;
                },
                AndroidGarbageCollectionStatsWire.HEAP_TOTAL_MBS_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._heap_total_mbs = result.value;
                },
                AndroidGarbageCollectionStatsWire.HEAP_UTILIZATION_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._heap_utilization = result.value;
                },
                AndroidGarbageCollectionStatsWire.GC_RUNNING_DUR_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._gc_running_dur = result.value;
                },
                AndroidGarbageCollectionStatsWire.GC_RUNNING_RATE_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._gc_running_rate = result.value;
                },
                AndroidGarbageCollectionStatsWire.GC_RUNNING_EFFICIENCY_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._gc_running_efficiency = result.value;
                },
                AndroidGarbageCollectionStatsWire.GC_DURING_ANDROID_STARTUP_DUR_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._gc_during_android_startup_dur = result.value;
                },
                AndroidGarbageCollectionStatsWire.TOTAL_ANDROID_STARTUP_DUR_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._total_android_startup_dur = result.value;
                },
                AndroidGarbageCollectionStatsWire.GC_DURING_ANDROID_STARTUP_RATE_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._gc_during_android_startup_rate = result.value;
                },
                AndroidGarbageCollectionStatsWire.GC_DURING_ANDROID_STARTUP_EFFICIENCY_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._gc_during_android_startup_efficiency = result.value;
                },
                AndroidGarbageCollectionStatsWire.PROCESSES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._processes_offset == null) {
                        res._processes_offset = offset - result.size;
                    }
                    res._processes_last_offset = offset;
                    res._processes_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getTs(self: *const AndroidGarbageCollectionStatsReader) i64 {
        return self._ts;
    }
    pub inline fn getDur(self: *const AndroidGarbageCollectionStatsReader) i64 {
        return self._dur;
    }
    pub inline fn getHeapSizeMbs(self: *const AndroidGarbageCollectionStatsReader) f64 {
        return self._heap_size_mbs;
    }
    pub inline fn getHeapSizeMb(self: *const AndroidGarbageCollectionStatsReader) f64 {
        return self._heap_size_mb;
    }
    pub inline fn getHeapAllocatedMb(self: *const AndroidGarbageCollectionStatsReader) f64 {
        return self._heap_allocated_mb;
    }
    pub inline fn getHeapAllocationRate(self: *const AndroidGarbageCollectionStatsReader) f64 {
        return self._heap_allocation_rate;
    }
    pub inline fn getHeapLiveMbs(self: *const AndroidGarbageCollectionStatsReader) f64 {
        return self._heap_live_mbs;
    }
    pub inline fn getHeapTotalMbs(self: *const AndroidGarbageCollectionStatsReader) f64 {
        return self._heap_total_mbs;
    }
    pub inline fn getHeapUtilization(self: *const AndroidGarbageCollectionStatsReader) f64 {
        return self._heap_utilization;
    }
    pub inline fn getGcRunningDur(self: *const AndroidGarbageCollectionStatsReader) i64 {
        return self._gc_running_dur;
    }
    pub inline fn getGcRunningRate(self: *const AndroidGarbageCollectionStatsReader) f64 {
        return self._gc_running_rate;
    }
    pub inline fn getGcRunningEfficiency(self: *const AndroidGarbageCollectionStatsReader) f64 {
        return self._gc_running_efficiency;
    }
    pub inline fn getGcDuringAndroidStartupDur(self: *const AndroidGarbageCollectionStatsReader) i64 {
        return self._gc_during_android_startup_dur;
    }
    pub inline fn getTotalAndroidStartupDur(self: *const AndroidGarbageCollectionStatsReader) i64 {
        return self._total_android_startup_dur;
    }
    pub inline fn getGcDuringAndroidStartupRate(self: *const AndroidGarbageCollectionStatsReader) f64 {
        return self._gc_during_android_startup_rate;
    }
    pub inline fn getGcDuringAndroidStartupEfficiency(self: *const AndroidGarbageCollectionStatsReader) f64 {
        return self._gc_during_android_startup_efficiency;
    }
    pub fn processesCount(self: *const AndroidGarbageCollectionStatsReader) usize {
        return self._processes_cnt;
    }
    pub fn processesNext(self: *AndroidGarbageCollectionStatsReader) ?AndroidGarbageCollectionStats.ProcessStatsReader {
        if (self._processes_offset == null) return null;
        const current_offset = self._processes_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidGarbageCollectionStats.ProcessStatsReader.init(result.value) catch return null;
        if (self._processes_last_offset != null and current_offset >= self._processes_last_offset.?) {
            self._processes_offset = null;
            return msg;
        }
        if (self._processes_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._processes_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidGarbageCollectionStatsWire.PROCESSES_WIRE) {
                self._processes_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._processes_offset = null;
        return msg;
    }
};
const AndroidOomAdjusterMetricWire = struct {
    const OOM_ADJUSTER_TRANSITION_COUNTS_GLOBAL_WIRE: gremlin.ProtoWireNumber = 1;
    const OOM_ADJUSTER_TRANSITION_COUNTS_BY_PROCESS_WIRE: gremlin.ProtoWireNumber = 2;
    const OOM_ADJUSTER_TRANSITION_COUNTS_BY_OOM_ADJ_REASON_WIRE: gremlin.ProtoWireNumber = 3;
    const OOM_ADJ_BUCKET_DURATION_AGG_GLOBAL_WIRE: gremlin.ProtoWireNumber = 4;
    const OOM_ADJ_BUCKET_DURATION_AGG_BY_PROCESS_WIRE: gremlin.ProtoWireNumber = 5;
    const OOM_ADJ_DURATION_AGG_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const AndroidOomAdjusterMetric = struct {
    // nested structs
    const OomAdjusterTransitionCountsWire = struct {
        const NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const SRC_BUCKET_WIRE: gremlin.ProtoWireNumber = 2;
        const DEST_BUCKET_WIRE: gremlin.ProtoWireNumber = 3;
        const COUNT_WIRE: gremlin.ProtoWireNumber = 4;
    };
    pub const OomAdjusterTransitionCounts = struct {
        // fields
        name: ?[]const u8 = null,
        src_bucket: ?[]const u8 = null,
        dest_bucket: ?[]const u8 = null,
        count: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidOomAdjusterMetric.OomAdjusterTransitionCounts) usize {
            var res: usize = 0;
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidOomAdjusterMetric.OomAdjusterTransitionCountsWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.src_bucket) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidOomAdjusterMetric.OomAdjusterTransitionCountsWire.SRC_BUCKET_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.dest_bucket) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidOomAdjusterMetric.OomAdjusterTransitionCountsWire.DEST_BUCKET_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidOomAdjusterMetric.OomAdjusterTransitionCountsWire.COUNT_WIRE) + gremlin.sizes.sizeI64(self.count);
            }
            return res;
        }
        pub fn encode(self: *const AndroidOomAdjusterMetric.OomAdjusterTransitionCounts, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidOomAdjusterMetric.OomAdjusterTransitionCounts, target: *gremlin.Writer) void {
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidOomAdjusterMetric.OomAdjusterTransitionCountsWire.NAME_WIRE, v);
                }
            }
            if (self.src_bucket) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidOomAdjusterMetric.OomAdjusterTransitionCountsWire.SRC_BUCKET_WIRE, v);
                }
            }
            if (self.dest_bucket) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidOomAdjusterMetric.OomAdjusterTransitionCountsWire.DEST_BUCKET_WIRE, v);
                }
            }
            if (self.count != 0) {
                target.appendInt64(AndroidOomAdjusterMetric.OomAdjusterTransitionCountsWire.COUNT_WIRE, self.count);
            }
        }
    };
    pub const OomAdjusterTransitionCountsReader = struct {
        buf: gremlin.Reader,
        _name: ?[]const u8 = null,
        _src_bucket: ?[]const u8 = null,
        _dest_bucket: ?[]const u8 = null,
        _count: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidOomAdjusterMetric.OomAdjusterTransitionCountsReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidOomAdjusterMetric.OomAdjusterTransitionCountsReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidOomAdjusterMetric.OomAdjusterTransitionCountsWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    AndroidOomAdjusterMetric.OomAdjusterTransitionCountsWire.SRC_BUCKET_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._src_bucket = result.value;
                    },
                    AndroidOomAdjusterMetric.OomAdjusterTransitionCountsWire.DEST_BUCKET_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._dest_bucket = result.value;
                    },
                    AndroidOomAdjusterMetric.OomAdjusterTransitionCountsWire.COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._count = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getName(self: *const AndroidOomAdjusterMetric.OomAdjusterTransitionCountsReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub inline fn getSrcBucket(self: *const AndroidOomAdjusterMetric.OomAdjusterTransitionCountsReader) []const u8 {
            return self._src_bucket orelse &[_]u8{};
        }
        pub inline fn getDestBucket(self: *const AndroidOomAdjusterMetric.OomAdjusterTransitionCountsReader) []const u8 {
            return self._dest_bucket orelse &[_]u8{};
        }
        pub inline fn getCount(self: *const AndroidOomAdjusterMetric.OomAdjusterTransitionCountsReader) i64 {
            return self._count;
        }
    };
    const OomAdjBucketDurationAggregationWire = struct {
        const NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const BUCKET_WIRE: gremlin.ProtoWireNumber = 2;
        const TOTAL_DUR_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const OomAdjBucketDurationAggregation = struct {
        // fields
        name: ?[]const u8 = null,
        bucket: ?[]const u8 = null,
        total_dur: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidOomAdjusterMetric.OomAdjBucketDurationAggregation) usize {
            var res: usize = 0;
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidOomAdjusterMetric.OomAdjBucketDurationAggregationWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.bucket) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidOomAdjusterMetric.OomAdjBucketDurationAggregationWire.BUCKET_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.total_dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidOomAdjusterMetric.OomAdjBucketDurationAggregationWire.TOTAL_DUR_WIRE) + gremlin.sizes.sizeI64(self.total_dur);
            }
            return res;
        }
        pub fn encode(self: *const AndroidOomAdjusterMetric.OomAdjBucketDurationAggregation, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidOomAdjusterMetric.OomAdjBucketDurationAggregation, target: *gremlin.Writer) void {
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidOomAdjusterMetric.OomAdjBucketDurationAggregationWire.NAME_WIRE, v);
                }
            }
            if (self.bucket) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidOomAdjusterMetric.OomAdjBucketDurationAggregationWire.BUCKET_WIRE, v);
                }
            }
            if (self.total_dur != 0) {
                target.appendInt64(AndroidOomAdjusterMetric.OomAdjBucketDurationAggregationWire.TOTAL_DUR_WIRE, self.total_dur);
            }
        }
    };
    pub const OomAdjBucketDurationAggregationReader = struct {
        buf: gremlin.Reader,
        _name: ?[]const u8 = null,
        _bucket: ?[]const u8 = null,
        _total_dur: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidOomAdjusterMetric.OomAdjBucketDurationAggregationReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidOomAdjusterMetric.OomAdjBucketDurationAggregationReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidOomAdjusterMetric.OomAdjBucketDurationAggregationWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    AndroidOomAdjusterMetric.OomAdjBucketDurationAggregationWire.BUCKET_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._bucket = result.value;
                    },
                    AndroidOomAdjusterMetric.OomAdjBucketDurationAggregationWire.TOTAL_DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._total_dur = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getName(self: *const AndroidOomAdjusterMetric.OomAdjBucketDurationAggregationReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub inline fn getBucket(self: *const AndroidOomAdjusterMetric.OomAdjBucketDurationAggregationReader) []const u8 {
            return self._bucket orelse &[_]u8{};
        }
        pub inline fn getTotalDur(self: *const AndroidOomAdjusterMetric.OomAdjBucketDurationAggregationReader) i64 {
            return self._total_dur;
        }
    };
    const OomAdjDurationAggregationWire = struct {
        const MIN_OOM_ADJ_DUR_WIRE: gremlin.ProtoWireNumber = 1;
        const MAX_OOM_ADJ_DUR_WIRE: gremlin.ProtoWireNumber = 2;
        const AVG_OOM_ADJ_DUR_WIRE: gremlin.ProtoWireNumber = 3;
        const OOM_ADJ_EVENT_COUNT_WIRE: gremlin.ProtoWireNumber = 4;
        const OOM_ADJ_REASON_WIRE: gremlin.ProtoWireNumber = 5;
    };
    pub const OomAdjDurationAggregation = struct {
        // fields
        min_oom_adj_dur: i64 = 0,
        max_oom_adj_dur: i64 = 0,
        avg_oom_adj_dur: f64 = 0.0,
        oom_adj_event_count: i64 = 0,
        oom_adj_reason: ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const AndroidOomAdjusterMetric.OomAdjDurationAggregation) usize {
            var res: usize = 0;
            if (self.min_oom_adj_dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidOomAdjusterMetric.OomAdjDurationAggregationWire.MIN_OOM_ADJ_DUR_WIRE) + gremlin.sizes.sizeI64(self.min_oom_adj_dur);
            }
            if (self.max_oom_adj_dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidOomAdjusterMetric.OomAdjDurationAggregationWire.MAX_OOM_ADJ_DUR_WIRE) + gremlin.sizes.sizeI64(self.max_oom_adj_dur);
            }
            if (self.avg_oom_adj_dur != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidOomAdjusterMetric.OomAdjDurationAggregationWire.AVG_OOM_ADJ_DUR_WIRE) + gremlin.sizes.sizeDouble(self.avg_oom_adj_dur);
            }
            if (self.oom_adj_event_count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidOomAdjusterMetric.OomAdjDurationAggregationWire.OOM_ADJ_EVENT_COUNT_WIRE) + gremlin.sizes.sizeI64(self.oom_adj_event_count);
            }
            if (self.oom_adj_reason) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidOomAdjusterMetric.OomAdjDurationAggregationWire.OOM_ADJ_REASON_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidOomAdjusterMetric.OomAdjDurationAggregation, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidOomAdjusterMetric.OomAdjDurationAggregation, target: *gremlin.Writer) void {
            if (self.min_oom_adj_dur != 0) {
                target.appendInt64(AndroidOomAdjusterMetric.OomAdjDurationAggregationWire.MIN_OOM_ADJ_DUR_WIRE, self.min_oom_adj_dur);
            }
            if (self.max_oom_adj_dur != 0) {
                target.appendInt64(AndroidOomAdjusterMetric.OomAdjDurationAggregationWire.MAX_OOM_ADJ_DUR_WIRE, self.max_oom_adj_dur);
            }
            if (self.avg_oom_adj_dur != 0.0) {
                target.appendFloat64(AndroidOomAdjusterMetric.OomAdjDurationAggregationWire.AVG_OOM_ADJ_DUR_WIRE, self.avg_oom_adj_dur);
            }
            if (self.oom_adj_event_count != 0) {
                target.appendInt64(AndroidOomAdjusterMetric.OomAdjDurationAggregationWire.OOM_ADJ_EVENT_COUNT_WIRE, self.oom_adj_event_count);
            }
            if (self.oom_adj_reason) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidOomAdjusterMetric.OomAdjDurationAggregationWire.OOM_ADJ_REASON_WIRE, v);
                }
            }
        }
    };
    pub const OomAdjDurationAggregationReader = struct {
        buf: gremlin.Reader,
        _min_oom_adj_dur: i64 = 0,
        _max_oom_adj_dur: i64 = 0,
        _avg_oom_adj_dur: f64 = 0.0,
        _oom_adj_event_count: i64 = 0,
        _oom_adj_reason: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!AndroidOomAdjusterMetric.OomAdjDurationAggregationReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidOomAdjusterMetric.OomAdjDurationAggregationReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidOomAdjusterMetric.OomAdjDurationAggregationWire.MIN_OOM_ADJ_DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._min_oom_adj_dur = result.value;
                    },
                    AndroidOomAdjusterMetric.OomAdjDurationAggregationWire.MAX_OOM_ADJ_DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._max_oom_adj_dur = result.value;
                    },
                    AndroidOomAdjusterMetric.OomAdjDurationAggregationWire.AVG_OOM_ADJ_DUR_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._avg_oom_adj_dur = result.value;
                    },
                    AndroidOomAdjusterMetric.OomAdjDurationAggregationWire.OOM_ADJ_EVENT_COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._oom_adj_event_count = result.value;
                    },
                    AndroidOomAdjusterMetric.OomAdjDurationAggregationWire.OOM_ADJ_REASON_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._oom_adj_reason = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getMinOomAdjDur(self: *const AndroidOomAdjusterMetric.OomAdjDurationAggregationReader) i64 {
            return self._min_oom_adj_dur;
        }
        pub inline fn getMaxOomAdjDur(self: *const AndroidOomAdjusterMetric.OomAdjDurationAggregationReader) i64 {
            return self._max_oom_adj_dur;
        }
        pub inline fn getAvgOomAdjDur(self: *const AndroidOomAdjusterMetric.OomAdjDurationAggregationReader) f64 {
            return self._avg_oom_adj_dur;
        }
        pub inline fn getOomAdjEventCount(self: *const AndroidOomAdjusterMetric.OomAdjDurationAggregationReader) i64 {
            return self._oom_adj_event_count;
        }
        pub inline fn getOomAdjReason(self: *const AndroidOomAdjusterMetric.OomAdjDurationAggregationReader) []const u8 {
            return self._oom_adj_reason orelse &[_]u8{};
        }
    };
    // fields
    oom_adjuster_transition_counts_global: ?[]const ?AndroidOomAdjusterMetric.OomAdjusterTransitionCounts = null,
    oom_adjuster_transition_counts_by_process: ?[]const ?AndroidOomAdjusterMetric.OomAdjusterTransitionCounts = null,
    oom_adjuster_transition_counts_by_oom_adj_reason: ?[]const ?AndroidOomAdjusterMetric.OomAdjusterTransitionCounts = null,
    oom_adj_bucket_duration_agg_global: ?[]const ?AndroidOomAdjusterMetric.OomAdjBucketDurationAggregation = null,
    oom_adj_bucket_duration_agg_by_process: ?[]const ?AndroidOomAdjusterMetric.OomAdjBucketDurationAggregation = null,
    oom_adj_duration_agg: ?[]const ?AndroidOomAdjusterMetric.OomAdjDurationAggregation = null,
    pub fn calcProtobufSize(self: *const AndroidOomAdjusterMetric) usize {
        var res: usize = 0;
        if (self.oom_adjuster_transition_counts_global) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidOomAdjusterMetricWire.OOM_ADJUSTER_TRANSITION_COUNTS_GLOBAL_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.oom_adjuster_transition_counts_by_process) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidOomAdjusterMetricWire.OOM_ADJUSTER_TRANSITION_COUNTS_BY_PROCESS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.oom_adjuster_transition_counts_by_oom_adj_reason) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidOomAdjusterMetricWire.OOM_ADJUSTER_TRANSITION_COUNTS_BY_OOM_ADJ_REASON_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.oom_adj_bucket_duration_agg_global) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidOomAdjusterMetricWire.OOM_ADJ_BUCKET_DURATION_AGG_GLOBAL_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.oom_adj_bucket_duration_agg_by_process) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidOomAdjusterMetricWire.OOM_ADJ_BUCKET_DURATION_AGG_BY_PROCESS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.oom_adj_duration_agg) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidOomAdjusterMetricWire.OOM_ADJ_DURATION_AGG_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidOomAdjusterMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidOomAdjusterMetric, target: *gremlin.Writer) void {
        if (self.oom_adjuster_transition_counts_global) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidOomAdjusterMetricWire.OOM_ADJUSTER_TRANSITION_COUNTS_GLOBAL_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidOomAdjusterMetricWire.OOM_ADJUSTER_TRANSITION_COUNTS_GLOBAL_WIRE, 0);
                }
            }
        }
        if (self.oom_adjuster_transition_counts_by_process) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidOomAdjusterMetricWire.OOM_ADJUSTER_TRANSITION_COUNTS_BY_PROCESS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidOomAdjusterMetricWire.OOM_ADJUSTER_TRANSITION_COUNTS_BY_PROCESS_WIRE, 0);
                }
            }
        }
        if (self.oom_adjuster_transition_counts_by_oom_adj_reason) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidOomAdjusterMetricWire.OOM_ADJUSTER_TRANSITION_COUNTS_BY_OOM_ADJ_REASON_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidOomAdjusterMetricWire.OOM_ADJUSTER_TRANSITION_COUNTS_BY_OOM_ADJ_REASON_WIRE, 0);
                }
            }
        }
        if (self.oom_adj_bucket_duration_agg_global) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidOomAdjusterMetricWire.OOM_ADJ_BUCKET_DURATION_AGG_GLOBAL_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidOomAdjusterMetricWire.OOM_ADJ_BUCKET_DURATION_AGG_GLOBAL_WIRE, 0);
                }
            }
        }
        if (self.oom_adj_bucket_duration_agg_by_process) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidOomAdjusterMetricWire.OOM_ADJ_BUCKET_DURATION_AGG_BY_PROCESS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidOomAdjusterMetricWire.OOM_ADJ_BUCKET_DURATION_AGG_BY_PROCESS_WIRE, 0);
                }
            }
        }
        if (self.oom_adj_duration_agg) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidOomAdjusterMetricWire.OOM_ADJ_DURATION_AGG_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidOomAdjusterMetricWire.OOM_ADJ_DURATION_AGG_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidOomAdjusterMetricReader = struct {
    buf: gremlin.Reader,
    _oom_adjuster_transition_counts_global_offset: ?usize = null,
    _oom_adjuster_transition_counts_global_last_offset: ?usize = null,
    _oom_adjuster_transition_counts_global_cnt: usize = 0,
    _oom_adjuster_transition_counts_by_process_offset: ?usize = null,
    _oom_adjuster_transition_counts_by_process_last_offset: ?usize = null,
    _oom_adjuster_transition_counts_by_process_cnt: usize = 0,
    _oom_adjuster_transition_counts_by_oom_adj_reason_offset: ?usize = null,
    _oom_adjuster_transition_counts_by_oom_adj_reason_last_offset: ?usize = null,
    _oom_adjuster_transition_counts_by_oom_adj_reason_cnt: usize = 0,
    _oom_adj_bucket_duration_agg_global_offset: ?usize = null,
    _oom_adj_bucket_duration_agg_global_last_offset: ?usize = null,
    _oom_adj_bucket_duration_agg_global_cnt: usize = 0,
    _oom_adj_bucket_duration_agg_by_process_offset: ?usize = null,
    _oom_adj_bucket_duration_agg_by_process_last_offset: ?usize = null,
    _oom_adj_bucket_duration_agg_by_process_cnt: usize = 0,
    _oom_adj_duration_agg_offset: ?usize = null,
    _oom_adj_duration_agg_last_offset: ?usize = null,
    _oom_adj_duration_agg_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidOomAdjusterMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidOomAdjusterMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidOomAdjusterMetricWire.OOM_ADJUSTER_TRANSITION_COUNTS_GLOBAL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._oom_adjuster_transition_counts_global_offset == null) {
                        res._oom_adjuster_transition_counts_global_offset = offset - result.size;
                    }
                    res._oom_adjuster_transition_counts_global_last_offset = offset;
                    res._oom_adjuster_transition_counts_global_cnt += 1;
                },
                AndroidOomAdjusterMetricWire.OOM_ADJUSTER_TRANSITION_COUNTS_BY_PROCESS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._oom_adjuster_transition_counts_by_process_offset == null) {
                        res._oom_adjuster_transition_counts_by_process_offset = offset - result.size;
                    }
                    res._oom_adjuster_transition_counts_by_process_last_offset = offset;
                    res._oom_adjuster_transition_counts_by_process_cnt += 1;
                },
                AndroidOomAdjusterMetricWire.OOM_ADJUSTER_TRANSITION_COUNTS_BY_OOM_ADJ_REASON_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._oom_adjuster_transition_counts_by_oom_adj_reason_offset == null) {
                        res._oom_adjuster_transition_counts_by_oom_adj_reason_offset = offset - result.size;
                    }
                    res._oom_adjuster_transition_counts_by_oom_adj_reason_last_offset = offset;
                    res._oom_adjuster_transition_counts_by_oom_adj_reason_cnt += 1;
                },
                AndroidOomAdjusterMetricWire.OOM_ADJ_BUCKET_DURATION_AGG_GLOBAL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._oom_adj_bucket_duration_agg_global_offset == null) {
                        res._oom_adj_bucket_duration_agg_global_offset = offset - result.size;
                    }
                    res._oom_adj_bucket_duration_agg_global_last_offset = offset;
                    res._oom_adj_bucket_duration_agg_global_cnt += 1;
                },
                AndroidOomAdjusterMetricWire.OOM_ADJ_BUCKET_DURATION_AGG_BY_PROCESS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._oom_adj_bucket_duration_agg_by_process_offset == null) {
                        res._oom_adj_bucket_duration_agg_by_process_offset = offset - result.size;
                    }
                    res._oom_adj_bucket_duration_agg_by_process_last_offset = offset;
                    res._oom_adj_bucket_duration_agg_by_process_cnt += 1;
                },
                AndroidOomAdjusterMetricWire.OOM_ADJ_DURATION_AGG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._oom_adj_duration_agg_offset == null) {
                        res._oom_adj_duration_agg_offset = offset - result.size;
                    }
                    res._oom_adj_duration_agg_last_offset = offset;
                    res._oom_adj_duration_agg_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn oomAdjusterTransitionCountsGlobalCount(self: *const AndroidOomAdjusterMetricReader) usize {
        return self._oom_adjuster_transition_counts_global_cnt;
    }
    pub fn oomAdjusterTransitionCountsGlobalNext(self: *AndroidOomAdjusterMetricReader) ?AndroidOomAdjusterMetric.OomAdjusterTransitionCountsReader {
        if (self._oom_adjuster_transition_counts_global_offset == null) return null;
        const current_offset = self._oom_adjuster_transition_counts_global_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidOomAdjusterMetric.OomAdjusterTransitionCountsReader.init(result.value) catch return null;
        if (self._oom_adjuster_transition_counts_global_last_offset != null and current_offset >= self._oom_adjuster_transition_counts_global_last_offset.?) {
            self._oom_adjuster_transition_counts_global_offset = null;
            return msg;
        }
        if (self._oom_adjuster_transition_counts_global_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._oom_adjuster_transition_counts_global_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidOomAdjusterMetricWire.OOM_ADJUSTER_TRANSITION_COUNTS_GLOBAL_WIRE) {
                self._oom_adjuster_transition_counts_global_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._oom_adjuster_transition_counts_global_offset = null;
        return msg;
    }
    pub fn oomAdjusterTransitionCountsByProcessCount(self: *const AndroidOomAdjusterMetricReader) usize {
        return self._oom_adjuster_transition_counts_by_process_cnt;
    }
    pub fn oomAdjusterTransitionCountsByProcessNext(self: *AndroidOomAdjusterMetricReader) ?AndroidOomAdjusterMetric.OomAdjusterTransitionCountsReader {
        if (self._oom_adjuster_transition_counts_by_process_offset == null) return null;
        const current_offset = self._oom_adjuster_transition_counts_by_process_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidOomAdjusterMetric.OomAdjusterTransitionCountsReader.init(result.value) catch return null;
        if (self._oom_adjuster_transition_counts_by_process_last_offset != null and current_offset >= self._oom_adjuster_transition_counts_by_process_last_offset.?) {
            self._oom_adjuster_transition_counts_by_process_offset = null;
            return msg;
        }
        if (self._oom_adjuster_transition_counts_by_process_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._oom_adjuster_transition_counts_by_process_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidOomAdjusterMetricWire.OOM_ADJUSTER_TRANSITION_COUNTS_BY_PROCESS_WIRE) {
                self._oom_adjuster_transition_counts_by_process_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._oom_adjuster_transition_counts_by_process_offset = null;
        return msg;
    }
    pub fn oomAdjusterTransitionCountsByOomAdjReasonCount(self: *const AndroidOomAdjusterMetricReader) usize {
        return self._oom_adjuster_transition_counts_by_oom_adj_reason_cnt;
    }
    pub fn oomAdjusterTransitionCountsByOomAdjReasonNext(self: *AndroidOomAdjusterMetricReader) ?AndroidOomAdjusterMetric.OomAdjusterTransitionCountsReader {
        if (self._oom_adjuster_transition_counts_by_oom_adj_reason_offset == null) return null;
        const current_offset = self._oom_adjuster_transition_counts_by_oom_adj_reason_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidOomAdjusterMetric.OomAdjusterTransitionCountsReader.init(result.value) catch return null;
        if (self._oom_adjuster_transition_counts_by_oom_adj_reason_last_offset != null and current_offset >= self._oom_adjuster_transition_counts_by_oom_adj_reason_last_offset.?) {
            self._oom_adjuster_transition_counts_by_oom_adj_reason_offset = null;
            return msg;
        }
        if (self._oom_adjuster_transition_counts_by_oom_adj_reason_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._oom_adjuster_transition_counts_by_oom_adj_reason_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidOomAdjusterMetricWire.OOM_ADJUSTER_TRANSITION_COUNTS_BY_OOM_ADJ_REASON_WIRE) {
                self._oom_adjuster_transition_counts_by_oom_adj_reason_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._oom_adjuster_transition_counts_by_oom_adj_reason_offset = null;
        return msg;
    }
    pub fn oomAdjBucketDurationAggGlobalCount(self: *const AndroidOomAdjusterMetricReader) usize {
        return self._oom_adj_bucket_duration_agg_global_cnt;
    }
    pub fn oomAdjBucketDurationAggGlobalNext(self: *AndroidOomAdjusterMetricReader) ?AndroidOomAdjusterMetric.OomAdjBucketDurationAggregationReader {
        if (self._oom_adj_bucket_duration_agg_global_offset == null) return null;
        const current_offset = self._oom_adj_bucket_duration_agg_global_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidOomAdjusterMetric.OomAdjBucketDurationAggregationReader.init(result.value) catch return null;
        if (self._oom_adj_bucket_duration_agg_global_last_offset != null and current_offset >= self._oom_adj_bucket_duration_agg_global_last_offset.?) {
            self._oom_adj_bucket_duration_agg_global_offset = null;
            return msg;
        }
        if (self._oom_adj_bucket_duration_agg_global_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._oom_adj_bucket_duration_agg_global_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidOomAdjusterMetricWire.OOM_ADJ_BUCKET_DURATION_AGG_GLOBAL_WIRE) {
                self._oom_adj_bucket_duration_agg_global_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._oom_adj_bucket_duration_agg_global_offset = null;
        return msg;
    }
    pub fn oomAdjBucketDurationAggByProcessCount(self: *const AndroidOomAdjusterMetricReader) usize {
        return self._oom_adj_bucket_duration_agg_by_process_cnt;
    }
    pub fn oomAdjBucketDurationAggByProcessNext(self: *AndroidOomAdjusterMetricReader) ?AndroidOomAdjusterMetric.OomAdjBucketDurationAggregationReader {
        if (self._oom_adj_bucket_duration_agg_by_process_offset == null) return null;
        const current_offset = self._oom_adj_bucket_duration_agg_by_process_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidOomAdjusterMetric.OomAdjBucketDurationAggregationReader.init(result.value) catch return null;
        if (self._oom_adj_bucket_duration_agg_by_process_last_offset != null and current_offset >= self._oom_adj_bucket_duration_agg_by_process_last_offset.?) {
            self._oom_adj_bucket_duration_agg_by_process_offset = null;
            return msg;
        }
        if (self._oom_adj_bucket_duration_agg_by_process_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._oom_adj_bucket_duration_agg_by_process_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidOomAdjusterMetricWire.OOM_ADJ_BUCKET_DURATION_AGG_BY_PROCESS_WIRE) {
                self._oom_adj_bucket_duration_agg_by_process_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._oom_adj_bucket_duration_agg_by_process_offset = null;
        return msg;
    }
    pub fn oomAdjDurationAggCount(self: *const AndroidOomAdjusterMetricReader) usize {
        return self._oom_adj_duration_agg_cnt;
    }
    pub fn oomAdjDurationAggNext(self: *AndroidOomAdjusterMetricReader) ?AndroidOomAdjusterMetric.OomAdjDurationAggregationReader {
        if (self._oom_adj_duration_agg_offset == null) return null;
        const current_offset = self._oom_adj_duration_agg_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidOomAdjusterMetric.OomAdjDurationAggregationReader.init(result.value) catch return null;
        if (self._oom_adj_duration_agg_last_offset != null and current_offset >= self._oom_adj_duration_agg_last_offset.?) {
            self._oom_adj_duration_agg_offset = null;
            return msg;
        }
        if (self._oom_adj_duration_agg_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._oom_adj_duration_agg_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidOomAdjusterMetricWire.OOM_ADJ_DURATION_AGG_WIRE) {
                self._oom_adj_duration_agg_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._oom_adj_duration_agg_offset = null;
        return msg;
    }
};
const AndroidSysUINotificationsBlockingCallsMetricWire = struct {
    const BLOCKING_CALLS_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const AndroidSysUINotificationsBlockingCallsMetric = struct {
    // fields
    blocking_calls: ?[]const ?AndroidBlockingCall = null,
    pub fn calcProtobufSize(self: *const AndroidSysUINotificationsBlockingCallsMetric) usize {
        var res: usize = 0;
        if (self.blocking_calls) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidSysUINotificationsBlockingCallsMetricWire.BLOCKING_CALLS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidSysUINotificationsBlockingCallsMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidSysUINotificationsBlockingCallsMetric, target: *gremlin.Writer) void {
        if (self.blocking_calls) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidSysUINotificationsBlockingCallsMetricWire.BLOCKING_CALLS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidSysUINotificationsBlockingCallsMetricWire.BLOCKING_CALLS_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidSysUINotificationsBlockingCallsMetricReader = struct {
    buf: gremlin.Reader,
    _blocking_calls_offset: ?usize = null,
    _blocking_calls_last_offset: ?usize = null,
    _blocking_calls_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidSysUINotificationsBlockingCallsMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidSysUINotificationsBlockingCallsMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidSysUINotificationsBlockingCallsMetricWire.BLOCKING_CALLS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._blocking_calls_offset == null) {
                        res._blocking_calls_offset = offset - result.size;
                    }
                    res._blocking_calls_last_offset = offset;
                    res._blocking_calls_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn blockingCallsCount(self: *const AndroidSysUINotificationsBlockingCallsMetricReader) usize {
        return self._blocking_calls_cnt;
    }
    pub fn blockingCallsNext(self: *AndroidSysUINotificationsBlockingCallsMetricReader) ?AndroidBlockingCallReader {
        if (self._blocking_calls_offset == null) return null;
        const current_offset = self._blocking_calls_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidBlockingCallReader.init(result.value) catch return null;
        if (self._blocking_calls_last_offset != null and current_offset >= self._blocking_calls_last_offset.?) {
            self._blocking_calls_offset = null;
            return msg;
        }
        if (self._blocking_calls_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._blocking_calls_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidSysUINotificationsBlockingCallsMetricWire.BLOCKING_CALLS_WIRE) {
                self._blocking_calls_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._blocking_calls_offset = null;
        return msg;
    }
};
const AndroidAnrMetricWire = struct {
    const ANR_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const AndroidAnrMetric = struct {
    // nested structs
    const AnrWire = struct {
        const ERROR_ID_WIRE: gremlin.ProtoWireNumber = 1;
        const PROCESS_NAME_WIRE: gremlin.ProtoWireNumber = 2;
        const PID_WIRE: gremlin.ProtoWireNumber = 3;
        const SUBJECT_WIRE: gremlin.ProtoWireNumber = 4;
        const TS_WIRE: gremlin.ProtoWireNumber = 5;
    };
    pub const Anr = struct {
        // fields
        error_id: ?[]const u8 = null,
        process_name: ?[]const u8 = null,
        pid: i32 = 0,
        subject: ?[]const u8 = null,
        ts: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidAnrMetric.Anr) usize {
            var res: usize = 0;
            if (self.error_id) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidAnrMetric.AnrWire.ERROR_ID_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.process_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidAnrMetric.AnrWire.PROCESS_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.pid != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidAnrMetric.AnrWire.PID_WIRE) + gremlin.sizes.sizeI32(self.pid);
            }
            if (self.subject) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidAnrMetric.AnrWire.SUBJECT_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.ts != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidAnrMetric.AnrWire.TS_WIRE) + gremlin.sizes.sizeI64(self.ts);
            }
            return res;
        }
        pub fn encode(self: *const AndroidAnrMetric.Anr, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidAnrMetric.Anr, target: *gremlin.Writer) void {
            if (self.error_id) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidAnrMetric.AnrWire.ERROR_ID_WIRE, v);
                }
            }
            if (self.process_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidAnrMetric.AnrWire.PROCESS_NAME_WIRE, v);
                }
            }
            if (self.pid != 0) {
                target.appendInt32(AndroidAnrMetric.AnrWire.PID_WIRE, self.pid);
            }
            if (self.subject) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidAnrMetric.AnrWire.SUBJECT_WIRE, v);
                }
            }
            if (self.ts != 0) {
                target.appendInt64(AndroidAnrMetric.AnrWire.TS_WIRE, self.ts);
            }
        }
    };
    pub const AnrReader = struct {
        buf: gremlin.Reader,
        _error_id: ?[]const u8 = null,
        _process_name: ?[]const u8 = null,
        _pid: i32 = 0,
        _subject: ?[]const u8 = null,
        _ts: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidAnrMetric.AnrReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidAnrMetric.AnrReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidAnrMetric.AnrWire.ERROR_ID_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._error_id = result.value;
                    },
                    AndroidAnrMetric.AnrWire.PROCESS_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._process_name = result.value;
                    },
                    AndroidAnrMetric.AnrWire.PID_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._pid = result.value;
                    },
                    AndroidAnrMetric.AnrWire.SUBJECT_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._subject = result.value;
                    },
                    AndroidAnrMetric.AnrWire.TS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._ts = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getErrorId(self: *const AndroidAnrMetric.AnrReader) []const u8 {
            return self._error_id orelse &[_]u8{};
        }
        pub inline fn getProcessName(self: *const AndroidAnrMetric.AnrReader) []const u8 {
            return self._process_name orelse &[_]u8{};
        }
        pub inline fn getPid(self: *const AndroidAnrMetric.AnrReader) i32 {
            return self._pid;
        }
        pub inline fn getSubject(self: *const AndroidAnrMetric.AnrReader) []const u8 {
            return self._subject orelse &[_]u8{};
        }
        pub inline fn getTs(self: *const AndroidAnrMetric.AnrReader) i64 {
            return self._ts;
        }
    };
    // fields
    anr: ?[]const ?AndroidAnrMetric.Anr = null,
    pub fn calcProtobufSize(self: *const AndroidAnrMetric) usize {
        var res: usize = 0;
        if (self.anr) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidAnrMetricWire.ANR_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidAnrMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidAnrMetric, target: *gremlin.Writer) void {
        if (self.anr) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidAnrMetricWire.ANR_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidAnrMetricWire.ANR_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidAnrMetricReader = struct {
    buf: gremlin.Reader,
    _anr_offset: ?usize = null,
    _anr_last_offset: ?usize = null,
    _anr_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidAnrMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidAnrMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidAnrMetricWire.ANR_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._anr_offset == null) {
                        res._anr_offset = offset - result.size;
                    }
                    res._anr_last_offset = offset;
                    res._anr_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn anrCount(self: *const AndroidAnrMetricReader) usize {
        return self._anr_cnt;
    }
    pub fn anrNext(self: *AndroidAnrMetricReader) ?AndroidAnrMetric.AnrReader {
        if (self._anr_offset == null) return null;
        const current_offset = self._anr_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidAnrMetric.AnrReader.init(result.value) catch return null;
        if (self._anr_last_offset != null and current_offset >= self._anr_last_offset.?) {
            self._anr_offset = null;
            return msg;
        }
        if (self._anr_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._anr_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidAnrMetricWire.ANR_WIRE) {
                self._anr_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._anr_offset = null;
        return msg;
    }
};
const AndroidAutoMultiuserMetricWire = struct {
    const USER_SWITCH_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const AndroidAutoMultiuserMetric = struct {
    // nested structs
    const EventDataWire = struct {
        const USER_ID_WIRE: gremlin.ProtoWireNumber = 1;
        const START_EVENT_WIRE: gremlin.ProtoWireNumber = 2;
        const END_EVENT_WIRE: gremlin.ProtoWireNumber = 3;
        const DURATION_MS_WIRE: gremlin.ProtoWireNumber = 4;
        const PREVIOUS_USER_INFO_WIRE: gremlin.ProtoWireNumber = 5;
    };
    pub const EventData = struct {
        // nested structs
        const UserDataWire = struct {
            const USER_ID_WIRE: gremlin.ProtoWireNumber = 1;
            const TOTAL_CPU_TIME_MS_WIRE: gremlin.ProtoWireNumber = 2;
            const TOTAL_MEMORY_USAGE_KB_WIRE: gremlin.ProtoWireNumber = 3;
        };
        pub const UserData = struct {
            // fields
            user_id: i32 = 0,
            total_cpu_time_ms: i64 = 0,
            total_memory_usage_kb: i64 = 0,
            pub fn calcProtobufSize(self: *const AndroidAutoMultiuserMetric.EventData.UserData) usize {
                var res: usize = 0;
                if (self.user_id != 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidAutoMultiuserMetric.EventData.UserDataWire.USER_ID_WIRE) + gremlin.sizes.sizeI32(self.user_id);
                }
                if (self.total_cpu_time_ms != 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidAutoMultiuserMetric.EventData.UserDataWire.TOTAL_CPU_TIME_MS_WIRE) + gremlin.sizes.sizeI64(self.total_cpu_time_ms);
                }
                if (self.total_memory_usage_kb != 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidAutoMultiuserMetric.EventData.UserDataWire.TOTAL_MEMORY_USAGE_KB_WIRE) + gremlin.sizes.sizeI64(self.total_memory_usage_kb);
                }
                return res;
            }
            pub fn encode(self: *const AndroidAutoMultiuserMetric.EventData.UserData, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const AndroidAutoMultiuserMetric.EventData.UserData, target: *gremlin.Writer) void {
                if (self.user_id != 0) {
                    target.appendInt32(AndroidAutoMultiuserMetric.EventData.UserDataWire.USER_ID_WIRE, self.user_id);
                }
                if (self.total_cpu_time_ms != 0) {
                    target.appendInt64(AndroidAutoMultiuserMetric.EventData.UserDataWire.TOTAL_CPU_TIME_MS_WIRE, self.total_cpu_time_ms);
                }
                if (self.total_memory_usage_kb != 0) {
                    target.appendInt64(AndroidAutoMultiuserMetric.EventData.UserDataWire.TOTAL_MEMORY_USAGE_KB_WIRE, self.total_memory_usage_kb);
                }
            }
        };
        pub const UserDataReader = struct {
            buf: gremlin.Reader,
            _user_id: i32 = 0,
            _total_cpu_time_ms: i64 = 0,
            _total_memory_usage_kb: i64 = 0,
            pub fn init(src: []const u8) gremlin.Error!AndroidAutoMultiuserMetric.EventData.UserDataReader {
                const buf = gremlin.Reader.init(src);
                var res = AndroidAutoMultiuserMetric.EventData.UserDataReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        AndroidAutoMultiuserMetric.EventData.UserDataWire.USER_ID_WIRE => {
                            const result = try buf.readInt32(offset);
                            offset += result.size;
                            res._user_id = result.value;
                        },
                        AndroidAutoMultiuserMetric.EventData.UserDataWire.TOTAL_CPU_TIME_MS_WIRE => {
                            const result = try buf.readInt64(offset);
                            offset += result.size;
                            res._total_cpu_time_ms = result.value;
                        },
                        AndroidAutoMultiuserMetric.EventData.UserDataWire.TOTAL_MEMORY_USAGE_KB_WIRE => {
                            const result = try buf.readInt64(offset);
                            offset += result.size;
                            res._total_memory_usage_kb = result.value;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub inline fn getUserId(self: *const AndroidAutoMultiuserMetric.EventData.UserDataReader) i32 {
                return self._user_id;
            }
            pub inline fn getTotalCpuTimeMs(self: *const AndroidAutoMultiuserMetric.EventData.UserDataReader) i64 {
                return self._total_cpu_time_ms;
            }
            pub inline fn getTotalMemoryUsageKb(self: *const AndroidAutoMultiuserMetric.EventData.UserDataReader) i64 {
                return self._total_memory_usage_kb;
            }
        };
        // fields
        user_id: i32 = 0,
        start_event: ?[]const u8 = null,
        end_event: ?[]const u8 = null,
        duration_ms: i64 = 0,
        previous_user_info: ?AndroidAutoMultiuserMetric.EventData.UserData = null,
        pub fn calcProtobufSize(self: *const AndroidAutoMultiuserMetric.EventData) usize {
            var res: usize = 0;
            if (self.user_id != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidAutoMultiuserMetric.EventDataWire.USER_ID_WIRE) + gremlin.sizes.sizeI32(self.user_id);
            }
            if (self.start_event) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidAutoMultiuserMetric.EventDataWire.START_EVENT_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.end_event) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidAutoMultiuserMetric.EventDataWire.END_EVENT_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.duration_ms != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidAutoMultiuserMetric.EventDataWire.DURATION_MS_WIRE) + gremlin.sizes.sizeI64(self.duration_ms);
            }
            if (self.previous_user_info) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidAutoMultiuserMetric.EventDataWire.PREVIOUS_USER_INFO_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidAutoMultiuserMetric.EventData, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidAutoMultiuserMetric.EventData, target: *gremlin.Writer) void {
            if (self.user_id != 0) {
                target.appendInt32(AndroidAutoMultiuserMetric.EventDataWire.USER_ID_WIRE, self.user_id);
            }
            if (self.start_event) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidAutoMultiuserMetric.EventDataWire.START_EVENT_WIRE, v);
                }
            }
            if (self.end_event) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidAutoMultiuserMetric.EventDataWire.END_EVENT_WIRE, v);
                }
            }
            if (self.duration_ms != 0) {
                target.appendInt64(AndroidAutoMultiuserMetric.EventDataWire.DURATION_MS_WIRE, self.duration_ms);
            }
            if (self.previous_user_info) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidAutoMultiuserMetric.EventDataWire.PREVIOUS_USER_INFO_WIRE, size);
                    v.encodeTo(target);
                }
            }
        }
    };
    pub const EventDataReader = struct {
        buf: gremlin.Reader,
        _user_id: i32 = 0,
        _start_event: ?[]const u8 = null,
        _end_event: ?[]const u8 = null,
        _duration_ms: i64 = 0,
        _previous_user_info_buf: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!AndroidAutoMultiuserMetric.EventDataReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidAutoMultiuserMetric.EventDataReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidAutoMultiuserMetric.EventDataWire.USER_ID_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._user_id = result.value;
                    },
                    AndroidAutoMultiuserMetric.EventDataWire.START_EVENT_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._start_event = result.value;
                    },
                    AndroidAutoMultiuserMetric.EventDataWire.END_EVENT_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._end_event = result.value;
                    },
                    AndroidAutoMultiuserMetric.EventDataWire.DURATION_MS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._duration_ms = result.value;
                    },
                    AndroidAutoMultiuserMetric.EventDataWire.PREVIOUS_USER_INFO_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._previous_user_info_buf = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getUserId(self: *const AndroidAutoMultiuserMetric.EventDataReader) i32 {
            return self._user_id;
        }
        pub inline fn getStartEvent(self: *const AndroidAutoMultiuserMetric.EventDataReader) []const u8 {
            return self._start_event orelse &[_]u8{};
        }
        pub inline fn getEndEvent(self: *const AndroidAutoMultiuserMetric.EventDataReader) []const u8 {
            return self._end_event orelse &[_]u8{};
        }
        pub inline fn getDurationMs(self: *const AndroidAutoMultiuserMetric.EventDataReader) i64 {
            return self._duration_ms;
        }
        pub fn getPreviousUserInfo(self: *const AndroidAutoMultiuserMetric.EventDataReader) gremlin.Error!AndroidAutoMultiuserMetric.EventData.UserDataReader {
            if (self._previous_user_info_buf) |buf| {
                return try AndroidAutoMultiuserMetric.EventData.UserDataReader.init(buf);
            }
            return try AndroidAutoMultiuserMetric.EventData.UserDataReader.init(&[_]u8{});
        }
    };
    // fields
    user_switch: ?[]const ?AndroidAutoMultiuserMetric.EventData = null,
    pub fn calcProtobufSize(self: *const AndroidAutoMultiuserMetric) usize {
        var res: usize = 0;
        if (self.user_switch) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidAutoMultiuserMetricWire.USER_SWITCH_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidAutoMultiuserMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidAutoMultiuserMetric, target: *gremlin.Writer) void {
        if (self.user_switch) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidAutoMultiuserMetricWire.USER_SWITCH_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidAutoMultiuserMetricWire.USER_SWITCH_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidAutoMultiuserMetricReader = struct {
    buf: gremlin.Reader,
    _user_switch_offset: ?usize = null,
    _user_switch_last_offset: ?usize = null,
    _user_switch_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidAutoMultiuserMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidAutoMultiuserMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidAutoMultiuserMetricWire.USER_SWITCH_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._user_switch_offset == null) {
                        res._user_switch_offset = offset - result.size;
                    }
                    res._user_switch_last_offset = offset;
                    res._user_switch_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn userSwitchCount(self: *const AndroidAutoMultiuserMetricReader) usize {
        return self._user_switch_cnt;
    }
    pub fn userSwitchNext(self: *AndroidAutoMultiuserMetricReader) ?AndroidAutoMultiuserMetric.EventDataReader {
        if (self._user_switch_offset == null) return null;
        const current_offset = self._user_switch_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidAutoMultiuserMetric.EventDataReader.init(result.value) catch return null;
        if (self._user_switch_last_offset != null and current_offset >= self._user_switch_last_offset.?) {
            self._user_switch_offset = null;
            return msg;
        }
        if (self._user_switch_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._user_switch_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidAutoMultiuserMetricWire.USER_SWITCH_WIRE) {
                self._user_switch_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._user_switch_offset = null;
        return msg;
    }
};
const AndroidBatteryMetricWire = struct {
    const BATTERY_COUNTERS_WIRE: gremlin.ProtoWireNumber = 1;
    const BATTERY_AGGREGATES_WIRE: gremlin.ProtoWireNumber = 2;
    const SUSPEND_PERIOD_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const AndroidBatteryMetric = struct {
    // nested structs
    const BatteryCountersWire = struct {
        const TIMESTAMP_NS_WIRE: gremlin.ProtoWireNumber = 1;
        const CHARGE_COUNTER_UAH_WIRE: gremlin.ProtoWireNumber = 2;
        const CAPACITY_PERCENT_WIRE: gremlin.ProtoWireNumber = 3;
        const CURRENT_UA_WIRE: gremlin.ProtoWireNumber = 4;
        const CURRENT_AVG_UA_WIRE: gremlin.ProtoWireNumber = 5;
        const VOLTAGE_UV_WIRE: gremlin.ProtoWireNumber = 6;
    };
    pub const BatteryCounters = struct {
        // fields
        timestamp_ns: i64 = 0,
        charge_counter_uah: f64 = 0.0,
        capacity_percent: f32 = 0.0,
        current_ua: f64 = 0.0,
        current_avg_ua: f64 = 0.0,
        voltage_uv: f64 = 0.0,
        pub fn calcProtobufSize(self: *const AndroidBatteryMetric.BatteryCounters) usize {
            var res: usize = 0;
            if (self.timestamp_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBatteryMetric.BatteryCountersWire.TIMESTAMP_NS_WIRE) + gremlin.sizes.sizeI64(self.timestamp_ns);
            }
            if (self.charge_counter_uah != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBatteryMetric.BatteryCountersWire.CHARGE_COUNTER_UAH_WIRE) + gremlin.sizes.sizeDouble(self.charge_counter_uah);
            }
            if (self.capacity_percent != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBatteryMetric.BatteryCountersWire.CAPACITY_PERCENT_WIRE) + gremlin.sizes.sizeFloat(self.capacity_percent);
            }
            if (self.current_ua != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBatteryMetric.BatteryCountersWire.CURRENT_UA_WIRE) + gremlin.sizes.sizeDouble(self.current_ua);
            }
            if (self.current_avg_ua != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBatteryMetric.BatteryCountersWire.CURRENT_AVG_UA_WIRE) + gremlin.sizes.sizeDouble(self.current_avg_ua);
            }
            if (self.voltage_uv != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBatteryMetric.BatteryCountersWire.VOLTAGE_UV_WIRE) + gremlin.sizes.sizeDouble(self.voltage_uv);
            }
            return res;
        }
        pub fn encode(self: *const AndroidBatteryMetric.BatteryCounters, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidBatteryMetric.BatteryCounters, target: *gremlin.Writer) void {
            if (self.timestamp_ns != 0) {
                target.appendInt64(AndroidBatteryMetric.BatteryCountersWire.TIMESTAMP_NS_WIRE, self.timestamp_ns);
            }
            if (self.charge_counter_uah != 0.0) {
                target.appendFloat64(AndroidBatteryMetric.BatteryCountersWire.CHARGE_COUNTER_UAH_WIRE, self.charge_counter_uah);
            }
            if (self.capacity_percent != 0.0) {
                target.appendFloat32(AndroidBatteryMetric.BatteryCountersWire.CAPACITY_PERCENT_WIRE, self.capacity_percent);
            }
            if (self.current_ua != 0.0) {
                target.appendFloat64(AndroidBatteryMetric.BatteryCountersWire.CURRENT_UA_WIRE, self.current_ua);
            }
            if (self.current_avg_ua != 0.0) {
                target.appendFloat64(AndroidBatteryMetric.BatteryCountersWire.CURRENT_AVG_UA_WIRE, self.current_avg_ua);
            }
            if (self.voltage_uv != 0.0) {
                target.appendFloat64(AndroidBatteryMetric.BatteryCountersWire.VOLTAGE_UV_WIRE, self.voltage_uv);
            }
        }
    };
    pub const BatteryCountersReader = struct {
        buf: gremlin.Reader,
        _timestamp_ns: i64 = 0,
        _charge_counter_uah: f64 = 0.0,
        _capacity_percent: f32 = 0.0,
        _current_ua: f64 = 0.0,
        _current_avg_ua: f64 = 0.0,
        _voltage_uv: f64 = 0.0,
        pub fn init(src: []const u8) gremlin.Error!AndroidBatteryMetric.BatteryCountersReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidBatteryMetric.BatteryCountersReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidBatteryMetric.BatteryCountersWire.TIMESTAMP_NS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._timestamp_ns = result.value;
                    },
                    AndroidBatteryMetric.BatteryCountersWire.CHARGE_COUNTER_UAH_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._charge_counter_uah = result.value;
                    },
                    AndroidBatteryMetric.BatteryCountersWire.CAPACITY_PERCENT_WIRE => {
                        const result = try buf.readFloat32(offset);
                        offset += result.size;
                        res._capacity_percent = result.value;
                    },
                    AndroidBatteryMetric.BatteryCountersWire.CURRENT_UA_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._current_ua = result.value;
                    },
                    AndroidBatteryMetric.BatteryCountersWire.CURRENT_AVG_UA_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._current_avg_ua = result.value;
                    },
                    AndroidBatteryMetric.BatteryCountersWire.VOLTAGE_UV_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._voltage_uv = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getTimestampNs(self: *const AndroidBatteryMetric.BatteryCountersReader) i64 {
            return self._timestamp_ns;
        }
        pub inline fn getChargeCounterUah(self: *const AndroidBatteryMetric.BatteryCountersReader) f64 {
            return self._charge_counter_uah;
        }
        pub inline fn getCapacityPercent(self: *const AndroidBatteryMetric.BatteryCountersReader) f32 {
            return self._capacity_percent;
        }
        pub inline fn getCurrentUa(self: *const AndroidBatteryMetric.BatteryCountersReader) f64 {
            return self._current_ua;
        }
        pub inline fn getCurrentAvgUa(self: *const AndroidBatteryMetric.BatteryCountersReader) f64 {
            return self._current_avg_ua;
        }
        pub inline fn getVoltageUv(self: *const AndroidBatteryMetric.BatteryCountersReader) f64 {
            return self._voltage_uv;
        }
    };
    const BatteryAggregatesWire = struct {
        const TOTAL_SCREEN_OFF_NS_WIRE: gremlin.ProtoWireNumber = 1;
        const TOTAL_SCREEN_ON_NS_WIRE: gremlin.ProtoWireNumber = 2;
        const TOTAL_SCREEN_DOZE_NS_WIRE: gremlin.ProtoWireNumber = 3;
        const TOTAL_WAKELOCK_NS_WIRE: gremlin.ProtoWireNumber = 4;
        const SLEEP_NS_WIRE: gremlin.ProtoWireNumber = 5;
        const SLEEP_SCREEN_OFF_NS_WIRE: gremlin.ProtoWireNumber = 6;
        const SLEEP_SCREEN_ON_NS_WIRE: gremlin.ProtoWireNumber = 7;
        const SLEEP_SCREEN_DOZE_NS_WIRE: gremlin.ProtoWireNumber = 8;
        const AVG_POWER_MW_WIRE: gremlin.ProtoWireNumber = 9;
        const AVG_POWER_FROM_CHARGE_DIFF_MW_WIRE: gremlin.ProtoWireNumber = 10;
    };
    pub const BatteryAggregates = struct {
        // fields
        total_screen_off_ns: i64 = 0,
        total_screen_on_ns: i64 = 0,
        total_screen_doze_ns: i64 = 0,
        total_wakelock_ns: i64 = 0,
        sleep_ns: i64 = 0,
        sleep_screen_off_ns: i64 = 0,
        sleep_screen_on_ns: i64 = 0,
        sleep_screen_doze_ns: i64 = 0,
        avg_power_mw: f64 = 0.0,
        avg_power_from_charge_diff_mw: f64 = 0.0,
        pub fn calcProtobufSize(self: *const AndroidBatteryMetric.BatteryAggregates) usize {
            var res: usize = 0;
            if (self.total_screen_off_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBatteryMetric.BatteryAggregatesWire.TOTAL_SCREEN_OFF_NS_WIRE) + gremlin.sizes.sizeI64(self.total_screen_off_ns);
            }
            if (self.total_screen_on_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBatteryMetric.BatteryAggregatesWire.TOTAL_SCREEN_ON_NS_WIRE) + gremlin.sizes.sizeI64(self.total_screen_on_ns);
            }
            if (self.total_screen_doze_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBatteryMetric.BatteryAggregatesWire.TOTAL_SCREEN_DOZE_NS_WIRE) + gremlin.sizes.sizeI64(self.total_screen_doze_ns);
            }
            if (self.total_wakelock_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBatteryMetric.BatteryAggregatesWire.TOTAL_WAKELOCK_NS_WIRE) + gremlin.sizes.sizeI64(self.total_wakelock_ns);
            }
            if (self.sleep_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBatteryMetric.BatteryAggregatesWire.SLEEP_NS_WIRE) + gremlin.sizes.sizeI64(self.sleep_ns);
            }
            if (self.sleep_screen_off_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBatteryMetric.BatteryAggregatesWire.SLEEP_SCREEN_OFF_NS_WIRE) + gremlin.sizes.sizeI64(self.sleep_screen_off_ns);
            }
            if (self.sleep_screen_on_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBatteryMetric.BatteryAggregatesWire.SLEEP_SCREEN_ON_NS_WIRE) + gremlin.sizes.sizeI64(self.sleep_screen_on_ns);
            }
            if (self.sleep_screen_doze_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBatteryMetric.BatteryAggregatesWire.SLEEP_SCREEN_DOZE_NS_WIRE) + gremlin.sizes.sizeI64(self.sleep_screen_doze_ns);
            }
            if (self.avg_power_mw != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBatteryMetric.BatteryAggregatesWire.AVG_POWER_MW_WIRE) + gremlin.sizes.sizeDouble(self.avg_power_mw);
            }
            if (self.avg_power_from_charge_diff_mw != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBatteryMetric.BatteryAggregatesWire.AVG_POWER_FROM_CHARGE_DIFF_MW_WIRE) + gremlin.sizes.sizeDouble(self.avg_power_from_charge_diff_mw);
            }
            return res;
        }
        pub fn encode(self: *const AndroidBatteryMetric.BatteryAggregates, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidBatteryMetric.BatteryAggregates, target: *gremlin.Writer) void {
            if (self.total_screen_off_ns != 0) {
                target.appendInt64(AndroidBatteryMetric.BatteryAggregatesWire.TOTAL_SCREEN_OFF_NS_WIRE, self.total_screen_off_ns);
            }
            if (self.total_screen_on_ns != 0) {
                target.appendInt64(AndroidBatteryMetric.BatteryAggregatesWire.TOTAL_SCREEN_ON_NS_WIRE, self.total_screen_on_ns);
            }
            if (self.total_screen_doze_ns != 0) {
                target.appendInt64(AndroidBatteryMetric.BatteryAggregatesWire.TOTAL_SCREEN_DOZE_NS_WIRE, self.total_screen_doze_ns);
            }
            if (self.total_wakelock_ns != 0) {
                target.appendInt64(AndroidBatteryMetric.BatteryAggregatesWire.TOTAL_WAKELOCK_NS_WIRE, self.total_wakelock_ns);
            }
            if (self.sleep_ns != 0) {
                target.appendInt64(AndroidBatteryMetric.BatteryAggregatesWire.SLEEP_NS_WIRE, self.sleep_ns);
            }
            if (self.sleep_screen_off_ns != 0) {
                target.appendInt64(AndroidBatteryMetric.BatteryAggregatesWire.SLEEP_SCREEN_OFF_NS_WIRE, self.sleep_screen_off_ns);
            }
            if (self.sleep_screen_on_ns != 0) {
                target.appendInt64(AndroidBatteryMetric.BatteryAggregatesWire.SLEEP_SCREEN_ON_NS_WIRE, self.sleep_screen_on_ns);
            }
            if (self.sleep_screen_doze_ns != 0) {
                target.appendInt64(AndroidBatteryMetric.BatteryAggregatesWire.SLEEP_SCREEN_DOZE_NS_WIRE, self.sleep_screen_doze_ns);
            }
            if (self.avg_power_mw != 0.0) {
                target.appendFloat64(AndroidBatteryMetric.BatteryAggregatesWire.AVG_POWER_MW_WIRE, self.avg_power_mw);
            }
            if (self.avg_power_from_charge_diff_mw != 0.0) {
                target.appendFloat64(AndroidBatteryMetric.BatteryAggregatesWire.AVG_POWER_FROM_CHARGE_DIFF_MW_WIRE, self.avg_power_from_charge_diff_mw);
            }
        }
    };
    pub const BatteryAggregatesReader = struct {
        buf: gremlin.Reader,
        _total_screen_off_ns: i64 = 0,
        _total_screen_on_ns: i64 = 0,
        _total_screen_doze_ns: i64 = 0,
        _total_wakelock_ns: i64 = 0,
        _sleep_ns: i64 = 0,
        _sleep_screen_off_ns: i64 = 0,
        _sleep_screen_on_ns: i64 = 0,
        _sleep_screen_doze_ns: i64 = 0,
        _avg_power_mw: f64 = 0.0,
        _avg_power_from_charge_diff_mw: f64 = 0.0,
        pub fn init(src: []const u8) gremlin.Error!AndroidBatteryMetric.BatteryAggregatesReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidBatteryMetric.BatteryAggregatesReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidBatteryMetric.BatteryAggregatesWire.TOTAL_SCREEN_OFF_NS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._total_screen_off_ns = result.value;
                    },
                    AndroidBatteryMetric.BatteryAggregatesWire.TOTAL_SCREEN_ON_NS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._total_screen_on_ns = result.value;
                    },
                    AndroidBatteryMetric.BatteryAggregatesWire.TOTAL_SCREEN_DOZE_NS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._total_screen_doze_ns = result.value;
                    },
                    AndroidBatteryMetric.BatteryAggregatesWire.TOTAL_WAKELOCK_NS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._total_wakelock_ns = result.value;
                    },
                    AndroidBatteryMetric.BatteryAggregatesWire.SLEEP_NS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._sleep_ns = result.value;
                    },
                    AndroidBatteryMetric.BatteryAggregatesWire.SLEEP_SCREEN_OFF_NS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._sleep_screen_off_ns = result.value;
                    },
                    AndroidBatteryMetric.BatteryAggregatesWire.SLEEP_SCREEN_ON_NS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._sleep_screen_on_ns = result.value;
                    },
                    AndroidBatteryMetric.BatteryAggregatesWire.SLEEP_SCREEN_DOZE_NS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._sleep_screen_doze_ns = result.value;
                    },
                    AndroidBatteryMetric.BatteryAggregatesWire.AVG_POWER_MW_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._avg_power_mw = result.value;
                    },
                    AndroidBatteryMetric.BatteryAggregatesWire.AVG_POWER_FROM_CHARGE_DIFF_MW_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._avg_power_from_charge_diff_mw = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getTotalScreenOffNs(self: *const AndroidBatteryMetric.BatteryAggregatesReader) i64 {
            return self._total_screen_off_ns;
        }
        pub inline fn getTotalScreenOnNs(self: *const AndroidBatteryMetric.BatteryAggregatesReader) i64 {
            return self._total_screen_on_ns;
        }
        pub inline fn getTotalScreenDozeNs(self: *const AndroidBatteryMetric.BatteryAggregatesReader) i64 {
            return self._total_screen_doze_ns;
        }
        pub inline fn getTotalWakelockNs(self: *const AndroidBatteryMetric.BatteryAggregatesReader) i64 {
            return self._total_wakelock_ns;
        }
        pub inline fn getSleepNs(self: *const AndroidBatteryMetric.BatteryAggregatesReader) i64 {
            return self._sleep_ns;
        }
        pub inline fn getSleepScreenOffNs(self: *const AndroidBatteryMetric.BatteryAggregatesReader) i64 {
            return self._sleep_screen_off_ns;
        }
        pub inline fn getSleepScreenOnNs(self: *const AndroidBatteryMetric.BatteryAggregatesReader) i64 {
            return self._sleep_screen_on_ns;
        }
        pub inline fn getSleepScreenDozeNs(self: *const AndroidBatteryMetric.BatteryAggregatesReader) i64 {
            return self._sleep_screen_doze_ns;
        }
        pub inline fn getAvgPowerMw(self: *const AndroidBatteryMetric.BatteryAggregatesReader) f64 {
            return self._avg_power_mw;
        }
        pub inline fn getAvgPowerFromChargeDiffMw(self: *const AndroidBatteryMetric.BatteryAggregatesReader) f64 {
            return self._avg_power_from_charge_diff_mw;
        }
    };
    const SuspendPeriodWire = struct {
        const TIMESTAMP_NS_WIRE: gremlin.ProtoWireNumber = 1;
        const DURATION_NS_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const SuspendPeriod = struct {
        // fields
        timestamp_ns: i64 = 0,
        duration_ns: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidBatteryMetric.SuspendPeriod) usize {
            var res: usize = 0;
            if (self.timestamp_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBatteryMetric.SuspendPeriodWire.TIMESTAMP_NS_WIRE) + gremlin.sizes.sizeI64(self.timestamp_ns);
            }
            if (self.duration_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBatteryMetric.SuspendPeriodWire.DURATION_NS_WIRE) + gremlin.sizes.sizeI64(self.duration_ns);
            }
            return res;
        }
        pub fn encode(self: *const AndroidBatteryMetric.SuspendPeriod, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidBatteryMetric.SuspendPeriod, target: *gremlin.Writer) void {
            if (self.timestamp_ns != 0) {
                target.appendInt64(AndroidBatteryMetric.SuspendPeriodWire.TIMESTAMP_NS_WIRE, self.timestamp_ns);
            }
            if (self.duration_ns != 0) {
                target.appendInt64(AndroidBatteryMetric.SuspendPeriodWire.DURATION_NS_WIRE, self.duration_ns);
            }
        }
    };
    pub const SuspendPeriodReader = struct {
        buf: gremlin.Reader,
        _timestamp_ns: i64 = 0,
        _duration_ns: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidBatteryMetric.SuspendPeriodReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidBatteryMetric.SuspendPeriodReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidBatteryMetric.SuspendPeriodWire.TIMESTAMP_NS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._timestamp_ns = result.value;
                    },
                    AndroidBatteryMetric.SuspendPeriodWire.DURATION_NS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._duration_ns = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getTimestampNs(self: *const AndroidBatteryMetric.SuspendPeriodReader) i64 {
            return self._timestamp_ns;
        }
        pub inline fn getDurationNs(self: *const AndroidBatteryMetric.SuspendPeriodReader) i64 {
            return self._duration_ns;
        }
    };
    // fields
    battery_counters: ?[]const ?AndroidBatteryMetric.BatteryCounters = null,
    battery_aggregates: ?AndroidBatteryMetric.BatteryAggregates = null,
    suspend_period: ?[]const ?AndroidBatteryMetric.SuspendPeriod = null,
    pub fn calcProtobufSize(self: *const AndroidBatteryMetric) usize {
        var res: usize = 0;
        if (self.battery_counters) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidBatteryMetricWire.BATTERY_COUNTERS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.battery_aggregates) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBatteryMetricWire.BATTERY_AGGREGATES_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.suspend_period) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidBatteryMetricWire.SUSPEND_PERIOD_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidBatteryMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidBatteryMetric, target: *gremlin.Writer) void {
        if (self.battery_counters) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidBatteryMetricWire.BATTERY_COUNTERS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidBatteryMetricWire.BATTERY_COUNTERS_WIRE, 0);
                }
            }
        }
        if (self.battery_aggregates) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidBatteryMetricWire.BATTERY_AGGREGATES_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.suspend_period) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidBatteryMetricWire.SUSPEND_PERIOD_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidBatteryMetricWire.SUSPEND_PERIOD_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidBatteryMetricReader = struct {
    buf: gremlin.Reader,
    _battery_counters_offset: ?usize = null,
    _battery_counters_last_offset: ?usize = null,
    _battery_counters_cnt: usize = 0,
    _battery_aggregates_buf: ?[]const u8 = null,
    _suspend_period_offset: ?usize = null,
    _suspend_period_last_offset: ?usize = null,
    _suspend_period_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidBatteryMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidBatteryMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidBatteryMetricWire.BATTERY_COUNTERS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._battery_counters_offset == null) {
                        res._battery_counters_offset = offset - result.size;
                    }
                    res._battery_counters_last_offset = offset;
                    res._battery_counters_cnt += 1;
                },
                AndroidBatteryMetricWire.BATTERY_AGGREGATES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._battery_aggregates_buf = result.value;
                },
                AndroidBatteryMetricWire.SUSPEND_PERIOD_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._suspend_period_offset == null) {
                        res._suspend_period_offset = offset - result.size;
                    }
                    res._suspend_period_last_offset = offset;
                    res._suspend_period_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn batteryCountersCount(self: *const AndroidBatteryMetricReader) usize {
        return self._battery_counters_cnt;
    }
    pub fn batteryCountersNext(self: *AndroidBatteryMetricReader) ?AndroidBatteryMetric.BatteryCountersReader {
        if (self._battery_counters_offset == null) return null;
        const current_offset = self._battery_counters_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidBatteryMetric.BatteryCountersReader.init(result.value) catch return null;
        if (self._battery_counters_last_offset != null and current_offset >= self._battery_counters_last_offset.?) {
            self._battery_counters_offset = null;
            return msg;
        }
        if (self._battery_counters_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._battery_counters_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidBatteryMetricWire.BATTERY_COUNTERS_WIRE) {
                self._battery_counters_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._battery_counters_offset = null;
        return msg;
    }
    pub fn getBatteryAggregates(self: *const AndroidBatteryMetricReader) gremlin.Error!AndroidBatteryMetric.BatteryAggregatesReader {
        if (self._battery_aggregates_buf) |buf| {
            return try AndroidBatteryMetric.BatteryAggregatesReader.init(buf);
        }
        return try AndroidBatteryMetric.BatteryAggregatesReader.init(&[_]u8{});
    }
    pub fn suspendPeriodCount(self: *const AndroidBatteryMetricReader) usize {
        return self._suspend_period_cnt;
    }
    pub fn suspendPeriodNext(self: *AndroidBatteryMetricReader) ?AndroidBatteryMetric.SuspendPeriodReader {
        if (self._suspend_period_offset == null) return null;
        const current_offset = self._suspend_period_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidBatteryMetric.SuspendPeriodReader.init(result.value) catch return null;
        if (self._suspend_period_last_offset != null and current_offset >= self._suspend_period_last_offset.?) {
            self._suspend_period_offset = null;
            return msg;
        }
        if (self._suspend_period_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._suspend_period_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidBatteryMetricWire.SUSPEND_PERIOD_WIRE) {
                self._suspend_period_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._suspend_period_offset = null;
        return msg;
    }
};
const AndroidBinderMetricWire = struct {
    const PROCESS_BREAKDOWN_WIRE: gremlin.ProtoWireNumber = 1;
    const UNAGGREGATED_TXN_BREAKDOWN_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const AndroidBinderMetric = struct {
    // nested structs
    const PerProcessBreakdownWire = struct {
        const PROCESS_NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const PID_WIRE: gremlin.ProtoWireNumber = 2;
        const SLICE_NAME_WIRE: gremlin.ProtoWireNumber = 3;
        const COUNT_WIRE: gremlin.ProtoWireNumber = 4;
    };
    pub const PerProcessBreakdown = struct {
        // fields
        process_name: ?[]const u8 = null,
        pid: u32 = 0,
        slice_name: ?[]const u8 = null,
        count: u32 = 0,
        pub fn calcProtobufSize(self: *const AndroidBinderMetric.PerProcessBreakdown) usize {
            var res: usize = 0;
            if (self.process_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.PerProcessBreakdownWire.PROCESS_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.pid != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.PerProcessBreakdownWire.PID_WIRE) + gremlin.sizes.sizeU32(self.pid);
            }
            if (self.slice_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.PerProcessBreakdownWire.SLICE_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.PerProcessBreakdownWire.COUNT_WIRE) + gremlin.sizes.sizeU32(self.count);
            }
            return res;
        }
        pub fn encode(self: *const AndroidBinderMetric.PerProcessBreakdown, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidBinderMetric.PerProcessBreakdown, target: *gremlin.Writer) void {
            if (self.process_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidBinderMetric.PerProcessBreakdownWire.PROCESS_NAME_WIRE, v);
                }
            }
            if (self.pid != 0) {
                target.appendUint32(AndroidBinderMetric.PerProcessBreakdownWire.PID_WIRE, self.pid);
            }
            if (self.slice_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidBinderMetric.PerProcessBreakdownWire.SLICE_NAME_WIRE, v);
                }
            }
            if (self.count != 0) {
                target.appendUint32(AndroidBinderMetric.PerProcessBreakdownWire.COUNT_WIRE, self.count);
            }
        }
    };
    pub const PerProcessBreakdownReader = struct {
        buf: gremlin.Reader,
        _process_name: ?[]const u8 = null,
        _pid: u32 = 0,
        _slice_name: ?[]const u8 = null,
        _count: u32 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidBinderMetric.PerProcessBreakdownReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidBinderMetric.PerProcessBreakdownReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidBinderMetric.PerProcessBreakdownWire.PROCESS_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._process_name = result.value;
                    },
                    AndroidBinderMetric.PerProcessBreakdownWire.PID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._pid = result.value;
                    },
                    AndroidBinderMetric.PerProcessBreakdownWire.SLICE_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._slice_name = result.value;
                    },
                    AndroidBinderMetric.PerProcessBreakdownWire.COUNT_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._count = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getProcessName(self: *const AndroidBinderMetric.PerProcessBreakdownReader) []const u8 {
            return self._process_name orelse &[_]u8{};
        }
        pub inline fn getPid(self: *const AndroidBinderMetric.PerProcessBreakdownReader) u32 {
            return self._pid;
        }
        pub inline fn getSliceName(self: *const AndroidBinderMetric.PerProcessBreakdownReader) []const u8 {
            return self._slice_name orelse &[_]u8{};
        }
        pub inline fn getCount(self: *const AndroidBinderMetric.PerProcessBreakdownReader) u32 {
            return self._count;
        }
    };
    const UnaggregatedTxnBreakdownWire = struct {
        const AIDL_NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const AIDL_TS_WIRE: gremlin.ProtoWireNumber = 22;
        const AIDL_DUR_WIRE: gremlin.ProtoWireNumber = 23;
        const IS_SYNC_WIRE: gremlin.ProtoWireNumber = 21;
        const CLIENT_PROCESS_WIRE: gremlin.ProtoWireNumber = 3;
        const CLIENT_THREAD_WIRE: gremlin.ProtoWireNumber = 4;
        const IS_MAIN_THREAD_WIRE: gremlin.ProtoWireNumber = 5;
        const CLIENT_TS_WIRE: gremlin.ProtoWireNumber = 6;
        const CLIENT_DUR_WIRE: gremlin.ProtoWireNumber = 7;
        const CLIENT_MONOTONIC_DUR_WIRE: gremlin.ProtoWireNumber = 28;
        const CLIENT_OOM_SCORE_WIRE: gremlin.ProtoWireNumber = 19;
        const CLIENT_PACKAGE_VERSION_CODE_WIRE: gremlin.ProtoWireNumber = 24;
        const IS_CLIENT_PACKAGE_DEBUGGABLE_WIRE: gremlin.ProtoWireNumber = 25;
        const SERVER_PROCESS_WIRE: gremlin.ProtoWireNumber = 9;
        const SERVER_THREAD_WIRE: gremlin.ProtoWireNumber = 10;
        const SERVER_TS_WIRE: gremlin.ProtoWireNumber = 11;
        const SERVER_DUR_WIRE: gremlin.ProtoWireNumber = 12;
        const SERVER_MONOTONIC_DUR_WIRE: gremlin.ProtoWireNumber = 29;
        const SERVER_OOM_SCORE_WIRE: gremlin.ProtoWireNumber = 20;
        const SERVER_PACKAGE_VERSION_CODE_WIRE: gremlin.ProtoWireNumber = 26;
        const IS_SERVER_PACKAGE_DEBUGGABLE_WIRE: gremlin.ProtoWireNumber = 27;
        const THREAD_STATES_WIRE: gremlin.ProtoWireNumber = 13;
        const BLOCKED_FUNCTIONS_WIRE: gremlin.ProtoWireNumber = 14;
        const LOGICAL_REASONS_WIRE: gremlin.ProtoWireNumber = 31;
        const CLIENT_TID_WIRE: gremlin.ProtoWireNumber = 15;
        const SERVER_TID_WIRE: gremlin.ProtoWireNumber = 16;
        const CLIENT_PID_WIRE: gremlin.ProtoWireNumber = 17;
        const SERVER_PID_WIRE: gremlin.ProtoWireNumber = 18;
    };
    pub const UnaggregatedTxnBreakdown = struct {
        // fields
        aidl_name: ?[]const u8 = null,
        aidl_ts: i64 = 0,
        aidl_dur: i64 = 0,
        is_sync: bool = false,
        client_process: ?[]const u8 = null,
        client_thread: ?[]const u8 = null,
        is_main_thread: bool = false,
        client_ts: i64 = 0,
        client_dur: i64 = 0,
        client_monotonic_dur: i64 = 0,
        client_oom_score: i64 = 0,
        client_package_version_code: i64 = 0,
        is_client_package_debuggable: bool = false,
        server_process: ?[]const u8 = null,
        server_thread: ?[]const u8 = null,
        server_ts: i64 = 0,
        server_dur: i64 = 0,
        server_monotonic_dur: i64 = 0,
        server_oom_score: i64 = 0,
        server_package_version_code: i64 = 0,
        is_server_package_debuggable: bool = false,
        thread_states: ?[]const ?AndroidBinderMetric.ThreadStateBreakdown = null,
        blocked_functions: ?[]const ?AndroidBinderMetric.BlockedFunctionBreakdown = null,
        logical_reasons: ?[]const ?AndroidBinderMetric.LogicalReasonBreakdown = null,
        client_tid: u32 = 0,
        server_tid: u32 = 0,
        client_pid: u32 = 0,
        server_pid: u32 = 0,
        pub fn calcProtobufSize(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdown) usize {
            var res: usize = 0;
            if (self.aidl_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.AIDL_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.aidl_ts != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.AIDL_TS_WIRE) + gremlin.sizes.sizeI64(self.aidl_ts);
            }
            if (self.aidl_dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.AIDL_DUR_WIRE) + gremlin.sizes.sizeI64(self.aidl_dur);
            }
            if (self.is_sync != false) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.IS_SYNC_WIRE) + gremlin.sizes.sizeBool(self.is_sync);
            }
            if (self.client_process) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_PROCESS_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.client_thread) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_THREAD_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.is_main_thread != false) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.IS_MAIN_THREAD_WIRE) + gremlin.sizes.sizeBool(self.is_main_thread);
            }
            if (self.client_ts != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_TS_WIRE) + gremlin.sizes.sizeI64(self.client_ts);
            }
            if (self.client_dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_DUR_WIRE) + gremlin.sizes.sizeI64(self.client_dur);
            }
            if (self.client_monotonic_dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_MONOTONIC_DUR_WIRE) + gremlin.sizes.sizeI64(self.client_monotonic_dur);
            }
            if (self.client_oom_score != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_OOM_SCORE_WIRE) + gremlin.sizes.sizeI64(self.client_oom_score);
            }
            if (self.client_package_version_code != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_PACKAGE_VERSION_CODE_WIRE) + gremlin.sizes.sizeI64(self.client_package_version_code);
            }
            if (self.is_client_package_debuggable != false) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.IS_CLIENT_PACKAGE_DEBUGGABLE_WIRE) + gremlin.sizes.sizeBool(self.is_client_package_debuggable);
            }
            if (self.server_process) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_PROCESS_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.server_thread) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_THREAD_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.server_ts != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_TS_WIRE) + gremlin.sizes.sizeI64(self.server_ts);
            }
            if (self.server_dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_DUR_WIRE) + gremlin.sizes.sizeI64(self.server_dur);
            }
            if (self.server_monotonic_dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_MONOTONIC_DUR_WIRE) + gremlin.sizes.sizeI64(self.server_monotonic_dur);
            }
            if (self.server_oom_score != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_OOM_SCORE_WIRE) + gremlin.sizes.sizeI64(self.server_oom_score);
            }
            if (self.server_package_version_code != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_PACKAGE_VERSION_CODE_WIRE) + gremlin.sizes.sizeI64(self.server_package_version_code);
            }
            if (self.is_server_package_debuggable != false) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.IS_SERVER_PACKAGE_DEBUGGABLE_WIRE) + gremlin.sizes.sizeBool(self.is_server_package_debuggable);
            }
            if (self.thread_states) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.THREAD_STATES_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.blocked_functions) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.BLOCKED_FUNCTIONS_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.logical_reasons) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.LOGICAL_REASONS_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.client_tid != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_TID_WIRE) + gremlin.sizes.sizeU32(self.client_tid);
            }
            if (self.server_tid != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_TID_WIRE) + gremlin.sizes.sizeU32(self.server_tid);
            }
            if (self.client_pid != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_PID_WIRE) + gremlin.sizes.sizeU32(self.client_pid);
            }
            if (self.server_pid != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_PID_WIRE) + gremlin.sizes.sizeU32(self.server_pid);
            }
            return res;
        }
        pub fn encode(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdown, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdown, target: *gremlin.Writer) void {
            if (self.aidl_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.AIDL_NAME_WIRE, v);
                }
            }
            if (self.aidl_ts != 0) {
                target.appendInt64(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.AIDL_TS_WIRE, self.aidl_ts);
            }
            if (self.aidl_dur != 0) {
                target.appendInt64(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.AIDL_DUR_WIRE, self.aidl_dur);
            }
            if (self.is_sync != false) {
                target.appendBool(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.IS_SYNC_WIRE, self.is_sync);
            }
            if (self.client_process) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_PROCESS_WIRE, v);
                }
            }
            if (self.client_thread) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_THREAD_WIRE, v);
                }
            }
            if (self.is_main_thread != false) {
                target.appendBool(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.IS_MAIN_THREAD_WIRE, self.is_main_thread);
            }
            if (self.client_ts != 0) {
                target.appendInt64(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_TS_WIRE, self.client_ts);
            }
            if (self.client_dur != 0) {
                target.appendInt64(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_DUR_WIRE, self.client_dur);
            }
            if (self.client_monotonic_dur != 0) {
                target.appendInt64(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_MONOTONIC_DUR_WIRE, self.client_monotonic_dur);
            }
            if (self.client_oom_score != 0) {
                target.appendInt64(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_OOM_SCORE_WIRE, self.client_oom_score);
            }
            if (self.client_package_version_code != 0) {
                target.appendInt64(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_PACKAGE_VERSION_CODE_WIRE, self.client_package_version_code);
            }
            if (self.is_client_package_debuggable != false) {
                target.appendBool(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.IS_CLIENT_PACKAGE_DEBUGGABLE_WIRE, self.is_client_package_debuggable);
            }
            if (self.server_process) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_PROCESS_WIRE, v);
                }
            }
            if (self.server_thread) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_THREAD_WIRE, v);
                }
            }
            if (self.server_ts != 0) {
                target.appendInt64(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_TS_WIRE, self.server_ts);
            }
            if (self.server_dur != 0) {
                target.appendInt64(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_DUR_WIRE, self.server_dur);
            }
            if (self.server_monotonic_dur != 0) {
                target.appendInt64(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_MONOTONIC_DUR_WIRE, self.server_monotonic_dur);
            }
            if (self.server_oom_score != 0) {
                target.appendInt64(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_OOM_SCORE_WIRE, self.server_oom_score);
            }
            if (self.server_package_version_code != 0) {
                target.appendInt64(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_PACKAGE_VERSION_CODE_WIRE, self.server_package_version_code);
            }
            if (self.is_server_package_debuggable != false) {
                target.appendBool(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.IS_SERVER_PACKAGE_DEBUGGABLE_WIRE, self.is_server_package_debuggable);
            }
            if (self.thread_states) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.THREAD_STATES_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.THREAD_STATES_WIRE, 0);
                    }
                }
            }
            if (self.blocked_functions) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.BLOCKED_FUNCTIONS_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.BLOCKED_FUNCTIONS_WIRE, 0);
                    }
                }
            }
            if (self.logical_reasons) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.LOGICAL_REASONS_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.LOGICAL_REASONS_WIRE, 0);
                    }
                }
            }
            if (self.client_tid != 0) {
                target.appendUint32(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_TID_WIRE, self.client_tid);
            }
            if (self.server_tid != 0) {
                target.appendUint32(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_TID_WIRE, self.server_tid);
            }
            if (self.client_pid != 0) {
                target.appendUint32(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_PID_WIRE, self.client_pid);
            }
            if (self.server_pid != 0) {
                target.appendUint32(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_PID_WIRE, self.server_pid);
            }
        }
    };
    pub const UnaggregatedTxnBreakdownReader = struct {
        buf: gremlin.Reader,
        _aidl_name: ?[]const u8 = null,
        _aidl_ts: i64 = 0,
        _aidl_dur: i64 = 0,
        _is_sync: bool = false,
        _client_process: ?[]const u8 = null,
        _client_thread: ?[]const u8 = null,
        _is_main_thread: bool = false,
        _client_ts: i64 = 0,
        _client_dur: i64 = 0,
        _client_monotonic_dur: i64 = 0,
        _client_oom_score: i64 = 0,
        _client_package_version_code: i64 = 0,
        _is_client_package_debuggable: bool = false,
        _server_process: ?[]const u8 = null,
        _server_thread: ?[]const u8 = null,
        _server_ts: i64 = 0,
        _server_dur: i64 = 0,
        _server_monotonic_dur: i64 = 0,
        _server_oom_score: i64 = 0,
        _server_package_version_code: i64 = 0,
        _is_server_package_debuggable: bool = false,
        _thread_states_offset: ?usize = null,
        _thread_states_last_offset: ?usize = null,
        _thread_states_cnt: usize = 0,
        _blocked_functions_offset: ?usize = null,
        _blocked_functions_last_offset: ?usize = null,
        _blocked_functions_cnt: usize = 0,
        _logical_reasons_offset: ?usize = null,
        _logical_reasons_last_offset: ?usize = null,
        _logical_reasons_cnt: usize = 0,
        _client_tid: u32 = 0,
        _server_tid: u32 = 0,
        _client_pid: u32 = 0,
        _server_pid: u32 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidBinderMetric.UnaggregatedTxnBreakdownReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidBinderMetric.UnaggregatedTxnBreakdownReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.AIDL_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._aidl_name = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.AIDL_TS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._aidl_ts = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.AIDL_DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._aidl_dur = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.IS_SYNC_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._is_sync = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_PROCESS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._client_process = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_THREAD_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._client_thread = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.IS_MAIN_THREAD_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._is_main_thread = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_TS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._client_ts = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._client_dur = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_MONOTONIC_DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._client_monotonic_dur = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_OOM_SCORE_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._client_oom_score = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_PACKAGE_VERSION_CODE_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._client_package_version_code = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.IS_CLIENT_PACKAGE_DEBUGGABLE_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._is_client_package_debuggable = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_PROCESS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._server_process = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_THREAD_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._server_thread = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_TS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._server_ts = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._server_dur = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_MONOTONIC_DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._server_monotonic_dur = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_OOM_SCORE_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._server_oom_score = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_PACKAGE_VERSION_CODE_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._server_package_version_code = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.IS_SERVER_PACKAGE_DEBUGGABLE_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._is_server_package_debuggable = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.THREAD_STATES_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._thread_states_offset == null) {
                            res._thread_states_offset = offset - result.size;
                        }
                        res._thread_states_last_offset = offset;
                        res._thread_states_cnt += 1;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.BLOCKED_FUNCTIONS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._blocked_functions_offset == null) {
                            res._blocked_functions_offset = offset - result.size;
                        }
                        res._blocked_functions_last_offset = offset;
                        res._blocked_functions_cnt += 1;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.LOGICAL_REASONS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._logical_reasons_offset == null) {
                            res._logical_reasons_offset = offset - result.size;
                        }
                        res._logical_reasons_last_offset = offset;
                        res._logical_reasons_cnt += 1;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_TID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._client_tid = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_TID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._server_tid = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_PID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._client_pid = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_PID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._server_pid = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getAidlName(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) []const u8 {
            return self._aidl_name orelse &[_]u8{};
        }
        pub inline fn getAidlTs(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) i64 {
            return self._aidl_ts;
        }
        pub inline fn getAidlDur(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) i64 {
            return self._aidl_dur;
        }
        pub inline fn getIsSync(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) bool {
            return self._is_sync;
        }
        pub inline fn getClientProcess(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) []const u8 {
            return self._client_process orelse &[_]u8{};
        }
        pub inline fn getClientThread(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) []const u8 {
            return self._client_thread orelse &[_]u8{};
        }
        pub inline fn getIsMainThread(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) bool {
            return self._is_main_thread;
        }
        pub inline fn getClientTs(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) i64 {
            return self._client_ts;
        }
        pub inline fn getClientDur(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) i64 {
            return self._client_dur;
        }
        pub inline fn getClientMonotonicDur(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) i64 {
            return self._client_monotonic_dur;
        }
        pub inline fn getClientOomScore(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) i64 {
            return self._client_oom_score;
        }
        pub inline fn getClientPackageVersionCode(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) i64 {
            return self._client_package_version_code;
        }
        pub inline fn getIsClientPackageDebuggable(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) bool {
            return self._is_client_package_debuggable;
        }
        pub inline fn getServerProcess(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) []const u8 {
            return self._server_process orelse &[_]u8{};
        }
        pub inline fn getServerThread(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) []const u8 {
            return self._server_thread orelse &[_]u8{};
        }
        pub inline fn getServerTs(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) i64 {
            return self._server_ts;
        }
        pub inline fn getServerDur(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) i64 {
            return self._server_dur;
        }
        pub inline fn getServerMonotonicDur(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) i64 {
            return self._server_monotonic_dur;
        }
        pub inline fn getServerOomScore(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) i64 {
            return self._server_oom_score;
        }
        pub inline fn getServerPackageVersionCode(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) i64 {
            return self._server_package_version_code;
        }
        pub inline fn getIsServerPackageDebuggable(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) bool {
            return self._is_server_package_debuggable;
        }
        pub fn threadStatesCount(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) usize {
            return self._thread_states_cnt;
        }
        pub fn threadStatesNext(self: *AndroidBinderMetric.UnaggregatedTxnBreakdownReader) ?AndroidBinderMetric.ThreadStateBreakdownReader {
            if (self._thread_states_offset == null) return null;
            const current_offset = self._thread_states_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidBinderMetric.ThreadStateBreakdownReader.init(result.value) catch return null;
            if (self._thread_states_last_offset != null and current_offset >= self._thread_states_last_offset.?) {
                self._thread_states_offset = null;
                return msg;
            }
            if (self._thread_states_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._thread_states_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidBinderMetric.UnaggregatedTxnBreakdownWire.THREAD_STATES_WIRE) {
                    self._thread_states_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._thread_states_offset = null;
            return msg;
        }
        pub fn blockedFunctionsCount(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) usize {
            return self._blocked_functions_cnt;
        }
        pub fn blockedFunctionsNext(self: *AndroidBinderMetric.UnaggregatedTxnBreakdownReader) ?AndroidBinderMetric.BlockedFunctionBreakdownReader {
            if (self._blocked_functions_offset == null) return null;
            const current_offset = self._blocked_functions_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidBinderMetric.BlockedFunctionBreakdownReader.init(result.value) catch return null;
            if (self._blocked_functions_last_offset != null and current_offset >= self._blocked_functions_last_offset.?) {
                self._blocked_functions_offset = null;
                return msg;
            }
            if (self._blocked_functions_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._blocked_functions_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidBinderMetric.UnaggregatedTxnBreakdownWire.BLOCKED_FUNCTIONS_WIRE) {
                    self._blocked_functions_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._blocked_functions_offset = null;
            return msg;
        }
        pub fn logicalReasonsCount(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) usize {
            return self._logical_reasons_cnt;
        }
        pub fn logicalReasonsNext(self: *AndroidBinderMetric.UnaggregatedTxnBreakdownReader) ?AndroidBinderMetric.LogicalReasonBreakdownReader {
            if (self._logical_reasons_offset == null) return null;
            const current_offset = self._logical_reasons_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidBinderMetric.LogicalReasonBreakdownReader.init(result.value) catch return null;
            if (self._logical_reasons_last_offset != null and current_offset >= self._logical_reasons_last_offset.?) {
                self._logical_reasons_offset = null;
                return msg;
            }
            if (self._logical_reasons_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._logical_reasons_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidBinderMetric.UnaggregatedTxnBreakdownWire.LOGICAL_REASONS_WIRE) {
                    self._logical_reasons_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._logical_reasons_offset = null;
            return msg;
        }
        pub inline fn getClientTid(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) u32 {
            return self._client_tid;
        }
        pub inline fn getServerTid(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) u32 {
            return self._server_tid;
        }
        pub inline fn getClientPid(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) u32 {
            return self._client_pid;
        }
        pub inline fn getServerPid(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) u32 {
            return self._server_pid;
        }
    };
    const ThreadStateBreakdownWire = struct {
        const THREAD_STATE_TYPE_WIRE: gremlin.ProtoWireNumber = 1;
        const THREAD_STATE_WIRE: gremlin.ProtoWireNumber = 2;
        const THREAD_STATE_DUR_WIRE: gremlin.ProtoWireNumber = 3;
        const THREAD_STATE_COUNT_WIRE: gremlin.ProtoWireNumber = 4;
    };
    pub const ThreadStateBreakdown = struct {
        // fields
        thread_state_type: ?[]const u8 = null,
        thread_state: ?[]const u8 = null,
        thread_state_dur: i64 = 0,
        thread_state_count: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidBinderMetric.ThreadStateBreakdown) usize {
            var res: usize = 0;
            if (self.thread_state_type) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.ThreadStateBreakdownWire.THREAD_STATE_TYPE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.thread_state) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.ThreadStateBreakdownWire.THREAD_STATE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.thread_state_dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.ThreadStateBreakdownWire.THREAD_STATE_DUR_WIRE) + gremlin.sizes.sizeI64(self.thread_state_dur);
            }
            if (self.thread_state_count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.ThreadStateBreakdownWire.THREAD_STATE_COUNT_WIRE) + gremlin.sizes.sizeI64(self.thread_state_count);
            }
            return res;
        }
        pub fn encode(self: *const AndroidBinderMetric.ThreadStateBreakdown, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidBinderMetric.ThreadStateBreakdown, target: *gremlin.Writer) void {
            if (self.thread_state_type) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidBinderMetric.ThreadStateBreakdownWire.THREAD_STATE_TYPE_WIRE, v);
                }
            }
            if (self.thread_state) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidBinderMetric.ThreadStateBreakdownWire.THREAD_STATE_WIRE, v);
                }
            }
            if (self.thread_state_dur != 0) {
                target.appendInt64(AndroidBinderMetric.ThreadStateBreakdownWire.THREAD_STATE_DUR_WIRE, self.thread_state_dur);
            }
            if (self.thread_state_count != 0) {
                target.appendInt64(AndroidBinderMetric.ThreadStateBreakdownWire.THREAD_STATE_COUNT_WIRE, self.thread_state_count);
            }
        }
    };
    pub const ThreadStateBreakdownReader = struct {
        buf: gremlin.Reader,
        _thread_state_type: ?[]const u8 = null,
        _thread_state: ?[]const u8 = null,
        _thread_state_dur: i64 = 0,
        _thread_state_count: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidBinderMetric.ThreadStateBreakdownReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidBinderMetric.ThreadStateBreakdownReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidBinderMetric.ThreadStateBreakdownWire.THREAD_STATE_TYPE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._thread_state_type = result.value;
                    },
                    AndroidBinderMetric.ThreadStateBreakdownWire.THREAD_STATE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._thread_state = result.value;
                    },
                    AndroidBinderMetric.ThreadStateBreakdownWire.THREAD_STATE_DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._thread_state_dur = result.value;
                    },
                    AndroidBinderMetric.ThreadStateBreakdownWire.THREAD_STATE_COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._thread_state_count = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getThreadStateType(self: *const AndroidBinderMetric.ThreadStateBreakdownReader) []const u8 {
            return self._thread_state_type orelse &[_]u8{};
        }
        pub inline fn getThreadState(self: *const AndroidBinderMetric.ThreadStateBreakdownReader) []const u8 {
            return self._thread_state orelse &[_]u8{};
        }
        pub inline fn getThreadStateDur(self: *const AndroidBinderMetric.ThreadStateBreakdownReader) i64 {
            return self._thread_state_dur;
        }
        pub inline fn getThreadStateCount(self: *const AndroidBinderMetric.ThreadStateBreakdownReader) i64 {
            return self._thread_state_count;
        }
    };
    const BlockedFunctionBreakdownWire = struct {
        const THREAD_STATE_TYPE_WIRE: gremlin.ProtoWireNumber = 1;
        const BLOCKED_FUNCTION_WIRE: gremlin.ProtoWireNumber = 2;
        const BLOCKED_FUNCTION_DUR_WIRE: gremlin.ProtoWireNumber = 3;
        const BLOCKED_FUNCTION_COUNT_WIRE: gremlin.ProtoWireNumber = 4;
    };
    pub const BlockedFunctionBreakdown = struct {
        // fields
        thread_state_type: ?[]const u8 = null,
        blocked_function: ?[]const u8 = null,
        blocked_function_dur: i64 = 0,
        blocked_function_count: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidBinderMetric.BlockedFunctionBreakdown) usize {
            var res: usize = 0;
            if (self.thread_state_type) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.BlockedFunctionBreakdownWire.THREAD_STATE_TYPE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.blocked_function) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.BlockedFunctionBreakdownWire.BLOCKED_FUNCTION_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.blocked_function_dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.BlockedFunctionBreakdownWire.BLOCKED_FUNCTION_DUR_WIRE) + gremlin.sizes.sizeI64(self.blocked_function_dur);
            }
            if (self.blocked_function_count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.BlockedFunctionBreakdownWire.BLOCKED_FUNCTION_COUNT_WIRE) + gremlin.sizes.sizeI64(self.blocked_function_count);
            }
            return res;
        }
        pub fn encode(self: *const AndroidBinderMetric.BlockedFunctionBreakdown, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidBinderMetric.BlockedFunctionBreakdown, target: *gremlin.Writer) void {
            if (self.thread_state_type) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidBinderMetric.BlockedFunctionBreakdownWire.THREAD_STATE_TYPE_WIRE, v);
                }
            }
            if (self.blocked_function) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidBinderMetric.BlockedFunctionBreakdownWire.BLOCKED_FUNCTION_WIRE, v);
                }
            }
            if (self.blocked_function_dur != 0) {
                target.appendInt64(AndroidBinderMetric.BlockedFunctionBreakdownWire.BLOCKED_FUNCTION_DUR_WIRE, self.blocked_function_dur);
            }
            if (self.blocked_function_count != 0) {
                target.appendInt64(AndroidBinderMetric.BlockedFunctionBreakdownWire.BLOCKED_FUNCTION_COUNT_WIRE, self.blocked_function_count);
            }
        }
    };
    pub const BlockedFunctionBreakdownReader = struct {
        buf: gremlin.Reader,
        _thread_state_type: ?[]const u8 = null,
        _blocked_function: ?[]const u8 = null,
        _blocked_function_dur: i64 = 0,
        _blocked_function_count: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidBinderMetric.BlockedFunctionBreakdownReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidBinderMetric.BlockedFunctionBreakdownReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidBinderMetric.BlockedFunctionBreakdownWire.THREAD_STATE_TYPE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._thread_state_type = result.value;
                    },
                    AndroidBinderMetric.BlockedFunctionBreakdownWire.BLOCKED_FUNCTION_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._blocked_function = result.value;
                    },
                    AndroidBinderMetric.BlockedFunctionBreakdownWire.BLOCKED_FUNCTION_DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._blocked_function_dur = result.value;
                    },
                    AndroidBinderMetric.BlockedFunctionBreakdownWire.BLOCKED_FUNCTION_COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._blocked_function_count = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getThreadStateType(self: *const AndroidBinderMetric.BlockedFunctionBreakdownReader) []const u8 {
            return self._thread_state_type orelse &[_]u8{};
        }
        pub inline fn getBlockedFunction(self: *const AndroidBinderMetric.BlockedFunctionBreakdownReader) []const u8 {
            return self._blocked_function orelse &[_]u8{};
        }
        pub inline fn getBlockedFunctionDur(self: *const AndroidBinderMetric.BlockedFunctionBreakdownReader) i64 {
            return self._blocked_function_dur;
        }
        pub inline fn getBlockedFunctionCount(self: *const AndroidBinderMetric.BlockedFunctionBreakdownReader) i64 {
            return self._blocked_function_count;
        }
    };
    const LogicalReasonBreakdownWire = struct {
        const THREAD_STATE_TYPE_WIRE: gremlin.ProtoWireNumber = 1;
        const REASON_WIRE: gremlin.ProtoWireNumber = 2;
        const REASON_DUR_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const LogicalReasonBreakdown = struct {
        // fields
        thread_state_type: ?[]const u8 = null,
        reason: ?[]const u8 = null,
        reason_dur: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidBinderMetric.LogicalReasonBreakdown) usize {
            var res: usize = 0;
            if (self.thread_state_type) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.LogicalReasonBreakdownWire.THREAD_STATE_TYPE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.reason) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.LogicalReasonBreakdownWire.REASON_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.reason_dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.LogicalReasonBreakdownWire.REASON_DUR_WIRE) + gremlin.sizes.sizeI64(self.reason_dur);
            }
            return res;
        }
        pub fn encode(self: *const AndroidBinderMetric.LogicalReasonBreakdown, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidBinderMetric.LogicalReasonBreakdown, target: *gremlin.Writer) void {
            if (self.thread_state_type) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidBinderMetric.LogicalReasonBreakdownWire.THREAD_STATE_TYPE_WIRE, v);
                }
            }
            if (self.reason) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidBinderMetric.LogicalReasonBreakdownWire.REASON_WIRE, v);
                }
            }
            if (self.reason_dur != 0) {
                target.appendInt64(AndroidBinderMetric.LogicalReasonBreakdownWire.REASON_DUR_WIRE, self.reason_dur);
            }
        }
    };
    pub const LogicalReasonBreakdownReader = struct {
        buf: gremlin.Reader,
        _thread_state_type: ?[]const u8 = null,
        _reason: ?[]const u8 = null,
        _reason_dur: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidBinderMetric.LogicalReasonBreakdownReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidBinderMetric.LogicalReasonBreakdownReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidBinderMetric.LogicalReasonBreakdownWire.THREAD_STATE_TYPE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._thread_state_type = result.value;
                    },
                    AndroidBinderMetric.LogicalReasonBreakdownWire.REASON_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._reason = result.value;
                    },
                    AndroidBinderMetric.LogicalReasonBreakdownWire.REASON_DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._reason_dur = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getThreadStateType(self: *const AndroidBinderMetric.LogicalReasonBreakdownReader) []const u8 {
            return self._thread_state_type orelse &[_]u8{};
        }
        pub inline fn getReason(self: *const AndroidBinderMetric.LogicalReasonBreakdownReader) []const u8 {
            return self._reason orelse &[_]u8{};
        }
        pub inline fn getReasonDur(self: *const AndroidBinderMetric.LogicalReasonBreakdownReader) i64 {
            return self._reason_dur;
        }
    };
    // fields
    process_breakdown: ?[]const ?AndroidBinderMetric.PerProcessBreakdown = null,
    unaggregated_txn_breakdown: ?[]const ?AndroidBinderMetric.UnaggregatedTxnBreakdown = null,
    pub fn calcProtobufSize(self: *const AndroidBinderMetric) usize {
        var res: usize = 0;
        if (self.process_breakdown) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetricWire.PROCESS_BREAKDOWN_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.unaggregated_txn_breakdown) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetricWire.UNAGGREGATED_TXN_BREAKDOWN_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidBinderMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidBinderMetric, target: *gremlin.Writer) void {
        if (self.process_breakdown) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidBinderMetricWire.PROCESS_BREAKDOWN_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidBinderMetricWire.PROCESS_BREAKDOWN_WIRE, 0);
                }
            }
        }
        if (self.unaggregated_txn_breakdown) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidBinderMetricWire.UNAGGREGATED_TXN_BREAKDOWN_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidBinderMetricWire.UNAGGREGATED_TXN_BREAKDOWN_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidBinderMetricReader = struct {
    buf: gremlin.Reader,
    _process_breakdown_offset: ?usize = null,
    _process_breakdown_last_offset: ?usize = null,
    _process_breakdown_cnt: usize = 0,
    _unaggregated_txn_breakdown_offset: ?usize = null,
    _unaggregated_txn_breakdown_last_offset: ?usize = null,
    _unaggregated_txn_breakdown_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidBinderMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidBinderMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidBinderMetricWire.PROCESS_BREAKDOWN_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._process_breakdown_offset == null) {
                        res._process_breakdown_offset = offset - result.size;
                    }
                    res._process_breakdown_last_offset = offset;
                    res._process_breakdown_cnt += 1;
                },
                AndroidBinderMetricWire.UNAGGREGATED_TXN_BREAKDOWN_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._unaggregated_txn_breakdown_offset == null) {
                        res._unaggregated_txn_breakdown_offset = offset - result.size;
                    }
                    res._unaggregated_txn_breakdown_last_offset = offset;
                    res._unaggregated_txn_breakdown_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn processBreakdownCount(self: *const AndroidBinderMetricReader) usize {
        return self._process_breakdown_cnt;
    }
    pub fn processBreakdownNext(self: *AndroidBinderMetricReader) ?AndroidBinderMetric.PerProcessBreakdownReader {
        if (self._process_breakdown_offset == null) return null;
        const current_offset = self._process_breakdown_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidBinderMetric.PerProcessBreakdownReader.init(result.value) catch return null;
        if (self._process_breakdown_last_offset != null and current_offset >= self._process_breakdown_last_offset.?) {
            self._process_breakdown_offset = null;
            return msg;
        }
        if (self._process_breakdown_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._process_breakdown_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidBinderMetricWire.PROCESS_BREAKDOWN_WIRE) {
                self._process_breakdown_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._process_breakdown_offset = null;
        return msg;
    }
    pub fn unaggregatedTxnBreakdownCount(self: *const AndroidBinderMetricReader) usize {
        return self._unaggregated_txn_breakdown_cnt;
    }
    pub fn unaggregatedTxnBreakdownNext(self: *AndroidBinderMetricReader) ?AndroidBinderMetric.UnaggregatedTxnBreakdownReader {
        if (self._unaggregated_txn_breakdown_offset == null) return null;
        const current_offset = self._unaggregated_txn_breakdown_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidBinderMetric.UnaggregatedTxnBreakdownReader.init(result.value) catch return null;
        if (self._unaggregated_txn_breakdown_last_offset != null and current_offset >= self._unaggregated_txn_breakdown_last_offset.?) {
            self._unaggregated_txn_breakdown_offset = null;
            return msg;
        }
        if (self._unaggregated_txn_breakdown_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._unaggregated_txn_breakdown_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidBinderMetricWire.UNAGGREGATED_TXN_BREAKDOWN_WIRE) {
                self._unaggregated_txn_breakdown_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._unaggregated_txn_breakdown_offset = null;
        return msg;
    }
};
const AndroidCameraMetricWire = struct {
    const GC_RSS_AND_DMA_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const AndroidCameraMetric = struct {
    // nested structs
    const CounterWire = struct {
        const MIN_WIRE: gremlin.ProtoWireNumber = 1;
        const MAX_WIRE: gremlin.ProtoWireNumber = 2;
        const AVG_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const Counter = struct {
        // fields
        min: f64 = 0.0,
        max: f64 = 0.0,
        avg: f64 = 0.0,
        pub fn calcProtobufSize(self: *const AndroidCameraMetric.Counter) usize {
            var res: usize = 0;
            if (self.min != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidCameraMetric.CounterWire.MIN_WIRE) + gremlin.sizes.sizeDouble(self.min);
            }
            if (self.max != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidCameraMetric.CounterWire.MAX_WIRE) + gremlin.sizes.sizeDouble(self.max);
            }
            if (self.avg != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidCameraMetric.CounterWire.AVG_WIRE) + gremlin.sizes.sizeDouble(self.avg);
            }
            return res;
        }
        pub fn encode(self: *const AndroidCameraMetric.Counter, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidCameraMetric.Counter, target: *gremlin.Writer) void {
            if (self.min != 0.0) {
                target.appendFloat64(AndroidCameraMetric.CounterWire.MIN_WIRE, self.min);
            }
            if (self.max != 0.0) {
                target.appendFloat64(AndroidCameraMetric.CounterWire.MAX_WIRE, self.max);
            }
            if (self.avg != 0.0) {
                target.appendFloat64(AndroidCameraMetric.CounterWire.AVG_WIRE, self.avg);
            }
        }
    };
    pub const CounterReader = struct {
        buf: gremlin.Reader,
        _min: f64 = 0.0,
        _max: f64 = 0.0,
        _avg: f64 = 0.0,
        pub fn init(src: []const u8) gremlin.Error!AndroidCameraMetric.CounterReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidCameraMetric.CounterReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidCameraMetric.CounterWire.MIN_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._min = result.value;
                    },
                    AndroidCameraMetric.CounterWire.MAX_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._max = result.value;
                    },
                    AndroidCameraMetric.CounterWire.AVG_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._avg = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getMin(self: *const AndroidCameraMetric.CounterReader) f64 {
            return self._min;
        }
        pub inline fn getMax(self: *const AndroidCameraMetric.CounterReader) f64 {
            return self._max;
        }
        pub inline fn getAvg(self: *const AndroidCameraMetric.CounterReader) f64 {
            return self._avg;
        }
    };
    // fields
    gc_rss_and_dma: ?AndroidCameraMetric.Counter = null,
    pub fn calcProtobufSize(self: *const AndroidCameraMetric) usize {
        var res: usize = 0;
        if (self.gc_rss_and_dma) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidCameraMetricWire.GC_RSS_AND_DMA_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidCameraMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidCameraMetric, target: *gremlin.Writer) void {
        if (self.gc_rss_and_dma) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidCameraMetricWire.GC_RSS_AND_DMA_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const AndroidCameraMetricReader = struct {
    buf: gremlin.Reader,
    _gc_rss_and_dma_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!AndroidCameraMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidCameraMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidCameraMetricWire.GC_RSS_AND_DMA_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._gc_rss_and_dma_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getGcRssAndDma(self: *const AndroidCameraMetricReader) gremlin.Error!AndroidCameraMetric.CounterReader {
        if (self._gc_rss_and_dma_buf) |buf| {
            return try AndroidCameraMetric.CounterReader.init(buf);
        }
        return try AndroidCameraMetric.CounterReader.init(&[_]u8{});
    }
};
const AndroidCameraUnaggregatedMetricWire = struct {
    const GC_RSS_AND_DMA_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const AndroidCameraUnaggregatedMetric = struct {
    // nested structs
    const ValueWire = struct {
        const TS_WIRE: gremlin.ProtoWireNumber = 1;
        const GCA_RSS_VAL_WIRE: gremlin.ProtoWireNumber = 2;
        const HAL_RSS_VAL_WIRE: gremlin.ProtoWireNumber = 3;
        const CAMERASERVER_RSS_VAL_WIRE: gremlin.ProtoWireNumber = 4;
        const DMA_VAL_WIRE: gremlin.ProtoWireNumber = 5;
        const VALUE_WIRE: gremlin.ProtoWireNumber = 6;
    };
    pub const Value = struct {
        // fields
        ts: i64 = 0,
        gca_rss_val: f64 = 0.0,
        hal_rss_val: f64 = 0.0,
        cameraserver_rss_val: f64 = 0.0,
        dma_val: f64 = 0.0,
        value: f64 = 0.0,
        pub fn calcProtobufSize(self: *const AndroidCameraUnaggregatedMetric.Value) usize {
            var res: usize = 0;
            if (self.ts != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidCameraUnaggregatedMetric.ValueWire.TS_WIRE) + gremlin.sizes.sizeI64(self.ts);
            }
            if (self.gca_rss_val != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidCameraUnaggregatedMetric.ValueWire.GCA_RSS_VAL_WIRE) + gremlin.sizes.sizeDouble(self.gca_rss_val);
            }
            if (self.hal_rss_val != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidCameraUnaggregatedMetric.ValueWire.HAL_RSS_VAL_WIRE) + gremlin.sizes.sizeDouble(self.hal_rss_val);
            }
            if (self.cameraserver_rss_val != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidCameraUnaggregatedMetric.ValueWire.CAMERASERVER_RSS_VAL_WIRE) + gremlin.sizes.sizeDouble(self.cameraserver_rss_val);
            }
            if (self.dma_val != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidCameraUnaggregatedMetric.ValueWire.DMA_VAL_WIRE) + gremlin.sizes.sizeDouble(self.dma_val);
            }
            if (self.value != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidCameraUnaggregatedMetric.ValueWire.VALUE_WIRE) + gremlin.sizes.sizeDouble(self.value);
            }
            return res;
        }
        pub fn encode(self: *const AndroidCameraUnaggregatedMetric.Value, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidCameraUnaggregatedMetric.Value, target: *gremlin.Writer) void {
            if (self.ts != 0) {
                target.appendInt64(AndroidCameraUnaggregatedMetric.ValueWire.TS_WIRE, self.ts);
            }
            if (self.gca_rss_val != 0.0) {
                target.appendFloat64(AndroidCameraUnaggregatedMetric.ValueWire.GCA_RSS_VAL_WIRE, self.gca_rss_val);
            }
            if (self.hal_rss_val != 0.0) {
                target.appendFloat64(AndroidCameraUnaggregatedMetric.ValueWire.HAL_RSS_VAL_WIRE, self.hal_rss_val);
            }
            if (self.cameraserver_rss_val != 0.0) {
                target.appendFloat64(AndroidCameraUnaggregatedMetric.ValueWire.CAMERASERVER_RSS_VAL_WIRE, self.cameraserver_rss_val);
            }
            if (self.dma_val != 0.0) {
                target.appendFloat64(AndroidCameraUnaggregatedMetric.ValueWire.DMA_VAL_WIRE, self.dma_val);
            }
            if (self.value != 0.0) {
                target.appendFloat64(AndroidCameraUnaggregatedMetric.ValueWire.VALUE_WIRE, self.value);
            }
        }
    };
    pub const ValueReader = struct {
        buf: gremlin.Reader,
        _ts: i64 = 0,
        _gca_rss_val: f64 = 0.0,
        _hal_rss_val: f64 = 0.0,
        _cameraserver_rss_val: f64 = 0.0,
        _dma_val: f64 = 0.0,
        _value: f64 = 0.0,
        pub fn init(src: []const u8) gremlin.Error!AndroidCameraUnaggregatedMetric.ValueReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidCameraUnaggregatedMetric.ValueReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidCameraUnaggregatedMetric.ValueWire.TS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._ts = result.value;
                    },
                    AndroidCameraUnaggregatedMetric.ValueWire.GCA_RSS_VAL_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._gca_rss_val = result.value;
                    },
                    AndroidCameraUnaggregatedMetric.ValueWire.HAL_RSS_VAL_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._hal_rss_val = result.value;
                    },
                    AndroidCameraUnaggregatedMetric.ValueWire.CAMERASERVER_RSS_VAL_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._cameraserver_rss_val = result.value;
                    },
                    AndroidCameraUnaggregatedMetric.ValueWire.DMA_VAL_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._dma_val = result.value;
                    },
                    AndroidCameraUnaggregatedMetric.ValueWire.VALUE_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._value = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getTs(self: *const AndroidCameraUnaggregatedMetric.ValueReader) i64 {
            return self._ts;
        }
        pub inline fn getGcaRssVal(self: *const AndroidCameraUnaggregatedMetric.ValueReader) f64 {
            return self._gca_rss_val;
        }
        pub inline fn getHalRssVal(self: *const AndroidCameraUnaggregatedMetric.ValueReader) f64 {
            return self._hal_rss_val;
        }
        pub inline fn getCameraserverRssVal(self: *const AndroidCameraUnaggregatedMetric.ValueReader) f64 {
            return self._cameraserver_rss_val;
        }
        pub inline fn getDmaVal(self: *const AndroidCameraUnaggregatedMetric.ValueReader) f64 {
            return self._dma_val;
        }
        pub inline fn getValue(self: *const AndroidCameraUnaggregatedMetric.ValueReader) f64 {
            return self._value;
        }
    };
    // fields
    gc_rss_and_dma: ?[]const ?AndroidCameraUnaggregatedMetric.Value = null,
    pub fn calcProtobufSize(self: *const AndroidCameraUnaggregatedMetric) usize {
        var res: usize = 0;
        if (self.gc_rss_and_dma) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidCameraUnaggregatedMetricWire.GC_RSS_AND_DMA_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidCameraUnaggregatedMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidCameraUnaggregatedMetric, target: *gremlin.Writer) void {
        if (self.gc_rss_and_dma) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidCameraUnaggregatedMetricWire.GC_RSS_AND_DMA_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidCameraUnaggregatedMetricWire.GC_RSS_AND_DMA_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidCameraUnaggregatedMetricReader = struct {
    buf: gremlin.Reader,
    _gc_rss_and_dma_offset: ?usize = null,
    _gc_rss_and_dma_last_offset: ?usize = null,
    _gc_rss_and_dma_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidCameraUnaggregatedMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidCameraUnaggregatedMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidCameraUnaggregatedMetricWire.GC_RSS_AND_DMA_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._gc_rss_and_dma_offset == null) {
                        res._gc_rss_and_dma_offset = offset - result.size;
                    }
                    res._gc_rss_and_dma_last_offset = offset;
                    res._gc_rss_and_dma_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn gcRssAndDmaCount(self: *const AndroidCameraUnaggregatedMetricReader) usize {
        return self._gc_rss_and_dma_cnt;
    }
    pub fn gcRssAndDmaNext(self: *AndroidCameraUnaggregatedMetricReader) ?AndroidCameraUnaggregatedMetric.ValueReader {
        if (self._gc_rss_and_dma_offset == null) return null;
        const current_offset = self._gc_rss_and_dma_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidCameraUnaggregatedMetric.ValueReader.init(result.value) catch return null;
        if (self._gc_rss_and_dma_last_offset != null and current_offset >= self._gc_rss_and_dma_last_offset.?) {
            self._gc_rss_and_dma_offset = null;
            return msg;
        }
        if (self._gc_rss_and_dma_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._gc_rss_and_dma_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidCameraUnaggregatedMetricWire.GC_RSS_AND_DMA_WIRE) {
                self._gc_rss_and_dma_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._gc_rss_and_dma_offset = null;
        return msg;
    }
};
const AndroidCpuMetricWire = struct {
    const PROCESS_INFO_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const AndroidCpuMetric = struct {
    // nested structs
    const MetricsWire = struct {
        const MCYCLES_WIRE: gremlin.ProtoWireNumber = 1;
        const RUNTIME_NS_WIRE: gremlin.ProtoWireNumber = 2;
        const MIN_FREQ_KHZ_WIRE: gremlin.ProtoWireNumber = 3;
        const MAX_FREQ_KHZ_WIRE: gremlin.ProtoWireNumber = 4;
        const AVG_FREQ_KHZ_WIRE: gremlin.ProtoWireNumber = 5;
    };
    pub const Metrics = struct {
        // fields
        mcycles: i64 = 0,
        runtime_ns: i64 = 0,
        min_freq_khz: i64 = 0,
        max_freq_khz: i64 = 0,
        avg_freq_khz: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidCpuMetric.Metrics) usize {
            var res: usize = 0;
            if (self.mcycles != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidCpuMetric.MetricsWire.MCYCLES_WIRE) + gremlin.sizes.sizeI64(self.mcycles);
            }
            if (self.runtime_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidCpuMetric.MetricsWire.RUNTIME_NS_WIRE) + gremlin.sizes.sizeI64(self.runtime_ns);
            }
            if (self.min_freq_khz != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidCpuMetric.MetricsWire.MIN_FREQ_KHZ_WIRE) + gremlin.sizes.sizeI64(self.min_freq_khz);
            }
            if (self.max_freq_khz != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidCpuMetric.MetricsWire.MAX_FREQ_KHZ_WIRE) + gremlin.sizes.sizeI64(self.max_freq_khz);
            }
            if (self.avg_freq_khz != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidCpuMetric.MetricsWire.AVG_FREQ_KHZ_WIRE) + gremlin.sizes.sizeI64(self.avg_freq_khz);
            }
            return res;
        }
        pub fn encode(self: *const AndroidCpuMetric.Metrics, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidCpuMetric.Metrics, target: *gremlin.Writer) void {
            if (self.mcycles != 0) {
                target.appendInt64(AndroidCpuMetric.MetricsWire.MCYCLES_WIRE, self.mcycles);
            }
            if (self.runtime_ns != 0) {
                target.appendInt64(AndroidCpuMetric.MetricsWire.RUNTIME_NS_WIRE, self.runtime_ns);
            }
            if (self.min_freq_khz != 0) {
                target.appendInt64(AndroidCpuMetric.MetricsWire.MIN_FREQ_KHZ_WIRE, self.min_freq_khz);
            }
            if (self.max_freq_khz != 0) {
                target.appendInt64(AndroidCpuMetric.MetricsWire.MAX_FREQ_KHZ_WIRE, self.max_freq_khz);
            }
            if (self.avg_freq_khz != 0) {
                target.appendInt64(AndroidCpuMetric.MetricsWire.AVG_FREQ_KHZ_WIRE, self.avg_freq_khz);
            }
        }
    };
    pub const MetricsReader = struct {
        buf: gremlin.Reader,
        _mcycles: i64 = 0,
        _runtime_ns: i64 = 0,
        _min_freq_khz: i64 = 0,
        _max_freq_khz: i64 = 0,
        _avg_freq_khz: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidCpuMetric.MetricsReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidCpuMetric.MetricsReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidCpuMetric.MetricsWire.MCYCLES_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._mcycles = result.value;
                    },
                    AndroidCpuMetric.MetricsWire.RUNTIME_NS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._runtime_ns = result.value;
                    },
                    AndroidCpuMetric.MetricsWire.MIN_FREQ_KHZ_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._min_freq_khz = result.value;
                    },
                    AndroidCpuMetric.MetricsWire.MAX_FREQ_KHZ_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._max_freq_khz = result.value;
                    },
                    AndroidCpuMetric.MetricsWire.AVG_FREQ_KHZ_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._avg_freq_khz = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getMcycles(self: *const AndroidCpuMetric.MetricsReader) i64 {
            return self._mcycles;
        }
        pub inline fn getRuntimeNs(self: *const AndroidCpuMetric.MetricsReader) i64 {
            return self._runtime_ns;
        }
        pub inline fn getMinFreqKhz(self: *const AndroidCpuMetric.MetricsReader) i64 {
            return self._min_freq_khz;
        }
        pub inline fn getMaxFreqKhz(self: *const AndroidCpuMetric.MetricsReader) i64 {
            return self._max_freq_khz;
        }
        pub inline fn getAvgFreqKhz(self: *const AndroidCpuMetric.MetricsReader) i64 {
            return self._avg_freq_khz;
        }
    };
    const CoreDataWire = struct {
        const ID_WIRE: gremlin.ProtoWireNumber = 1;
        const METRICS_WIRE: gremlin.ProtoWireNumber = 6;
    };
    pub const CoreData = struct {
        // fields
        id: u32 = 0,
        metrics: ?AndroidCpuMetric.Metrics = null,
        pub fn calcProtobufSize(self: *const AndroidCpuMetric.CoreData) usize {
            var res: usize = 0;
            if (self.id != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidCpuMetric.CoreDataWire.ID_WIRE) + gremlin.sizes.sizeU32(self.id);
            }
            if (self.metrics) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidCpuMetric.CoreDataWire.METRICS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidCpuMetric.CoreData, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidCpuMetric.CoreData, target: *gremlin.Writer) void {
            if (self.id != 0) {
                target.appendUint32(AndroidCpuMetric.CoreDataWire.ID_WIRE, self.id);
            }
            if (self.metrics) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidCpuMetric.CoreDataWire.METRICS_WIRE, size);
                    v.encodeTo(target);
                }
            }
        }
    };
    pub const CoreDataReader = struct {
        buf: gremlin.Reader,
        _id: u32 = 0,
        _metrics_buf: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!AndroidCpuMetric.CoreDataReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidCpuMetric.CoreDataReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidCpuMetric.CoreDataWire.ID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._id = result.value;
                    },
                    AndroidCpuMetric.CoreDataWire.METRICS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._metrics_buf = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getId(self: *const AndroidCpuMetric.CoreDataReader) u32 {
            return self._id;
        }
        pub fn getMetrics(self: *const AndroidCpuMetric.CoreDataReader) gremlin.Error!AndroidCpuMetric.MetricsReader {
            if (self._metrics_buf) |buf| {
                return try AndroidCpuMetric.MetricsReader.init(buf);
            }
            return try AndroidCpuMetric.MetricsReader.init(&[_]u8{});
        }
    };
    const CoreTypeDataWire = struct {
        const TYPE_WIRE: gremlin.ProtoWireNumber = 1;
        const METRICS_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const CoreTypeData = struct {
        // fields
        type: ?[]const u8 = null,
        metrics: ?AndroidCpuMetric.Metrics = null,
        pub fn calcProtobufSize(self: *const AndroidCpuMetric.CoreTypeData) usize {
            var res: usize = 0;
            if (self.type) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidCpuMetric.CoreTypeDataWire.TYPE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.metrics) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidCpuMetric.CoreTypeDataWire.METRICS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidCpuMetric.CoreTypeData, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidCpuMetric.CoreTypeData, target: *gremlin.Writer) void {
            if (self.type) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidCpuMetric.CoreTypeDataWire.TYPE_WIRE, v);
                }
            }
            if (self.metrics) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidCpuMetric.CoreTypeDataWire.METRICS_WIRE, size);
                    v.encodeTo(target);
                }
            }
        }
    };
    pub const CoreTypeDataReader = struct {
        buf: gremlin.Reader,
        _type: ?[]const u8 = null,
        _metrics_buf: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!AndroidCpuMetric.CoreTypeDataReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidCpuMetric.CoreTypeDataReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidCpuMetric.CoreTypeDataWire.TYPE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._type = result.value;
                    },
                    AndroidCpuMetric.CoreTypeDataWire.METRICS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._metrics_buf = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getType(self: *const AndroidCpuMetric.CoreTypeDataReader) []const u8 {
            return self._type orelse &[_]u8{};
        }
        pub fn getMetrics(self: *const AndroidCpuMetric.CoreTypeDataReader) gremlin.Error!AndroidCpuMetric.MetricsReader {
            if (self._metrics_buf) |buf| {
                return try AndroidCpuMetric.MetricsReader.init(buf);
            }
            return try AndroidCpuMetric.MetricsReader.init(&[_]u8{});
        }
    };
    const ThreadWire = struct {
        const NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const METRICS_WIRE: gremlin.ProtoWireNumber = 4;
        const CORE_WIRE: gremlin.ProtoWireNumber = 2;
        const CORE_TYPE_WIRE: gremlin.ProtoWireNumber = 5;
    };
    pub const Thread = struct {
        // fields
        name: ?[]const u8 = null,
        metrics: ?AndroidCpuMetric.Metrics = null,
        core: ?[]const ?AndroidCpuMetric.CoreData = null,
        core_type: ?[]const ?AndroidCpuMetric.CoreTypeData = null,
        pub fn calcProtobufSize(self: *const AndroidCpuMetric.Thread) usize {
            var res: usize = 0;
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidCpuMetric.ThreadWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.metrics) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidCpuMetric.ThreadWire.METRICS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.core) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidCpuMetric.ThreadWire.CORE_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.core_type) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidCpuMetric.ThreadWire.CORE_TYPE_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidCpuMetric.Thread, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidCpuMetric.Thread, target: *gremlin.Writer) void {
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidCpuMetric.ThreadWire.NAME_WIRE, v);
                }
            }
            if (self.metrics) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidCpuMetric.ThreadWire.METRICS_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.core) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidCpuMetric.ThreadWire.CORE_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidCpuMetric.ThreadWire.CORE_WIRE, 0);
                    }
                }
            }
            if (self.core_type) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidCpuMetric.ThreadWire.CORE_TYPE_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidCpuMetric.ThreadWire.CORE_TYPE_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const ThreadReader = struct {
        buf: gremlin.Reader,
        _name: ?[]const u8 = null,
        _metrics_buf: ?[]const u8 = null,
        _core_offset: ?usize = null,
        _core_last_offset: ?usize = null,
        _core_cnt: usize = 0,
        _core_type_offset: ?usize = null,
        _core_type_last_offset: ?usize = null,
        _core_type_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidCpuMetric.ThreadReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidCpuMetric.ThreadReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidCpuMetric.ThreadWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    AndroidCpuMetric.ThreadWire.METRICS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._metrics_buf = result.value;
                    },
                    AndroidCpuMetric.ThreadWire.CORE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._core_offset == null) {
                            res._core_offset = offset - result.size;
                        }
                        res._core_last_offset = offset;
                        res._core_cnt += 1;
                    },
                    AndroidCpuMetric.ThreadWire.CORE_TYPE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._core_type_offset == null) {
                            res._core_type_offset = offset - result.size;
                        }
                        res._core_type_last_offset = offset;
                        res._core_type_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getName(self: *const AndroidCpuMetric.ThreadReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub fn getMetrics(self: *const AndroidCpuMetric.ThreadReader) gremlin.Error!AndroidCpuMetric.MetricsReader {
            if (self._metrics_buf) |buf| {
                return try AndroidCpuMetric.MetricsReader.init(buf);
            }
            return try AndroidCpuMetric.MetricsReader.init(&[_]u8{});
        }
        pub fn coreCount(self: *const AndroidCpuMetric.ThreadReader) usize {
            return self._core_cnt;
        }
        pub fn coreNext(self: *AndroidCpuMetric.ThreadReader) ?AndroidCpuMetric.CoreDataReader {
            if (self._core_offset == null) return null;
            const current_offset = self._core_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidCpuMetric.CoreDataReader.init(result.value) catch return null;
            if (self._core_last_offset != null and current_offset >= self._core_last_offset.?) {
                self._core_offset = null;
                return msg;
            }
            if (self._core_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._core_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidCpuMetric.ThreadWire.CORE_WIRE) {
                    self._core_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._core_offset = null;
            return msg;
        }
        pub fn coreTypeCount(self: *const AndroidCpuMetric.ThreadReader) usize {
            return self._core_type_cnt;
        }
        pub fn coreTypeNext(self: *AndroidCpuMetric.ThreadReader) ?AndroidCpuMetric.CoreTypeDataReader {
            if (self._core_type_offset == null) return null;
            const current_offset = self._core_type_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidCpuMetric.CoreTypeDataReader.init(result.value) catch return null;
            if (self._core_type_last_offset != null and current_offset >= self._core_type_last_offset.?) {
                self._core_type_offset = null;
                return msg;
            }
            if (self._core_type_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._core_type_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidCpuMetric.ThreadWire.CORE_TYPE_WIRE) {
                    self._core_type_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._core_type_offset = null;
            return msg;
        }
    };
    const ProcessWire = struct {
        const NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const PROCESS_WIRE: gremlin.ProtoWireNumber = 8;
        const METRICS_WIRE: gremlin.ProtoWireNumber = 4;
        const THREADS_WIRE: gremlin.ProtoWireNumber = 6;
        const CORE_WIRE: gremlin.ProtoWireNumber = 7;
        const CORE_TYPE_WIRE: gremlin.ProtoWireNumber = 5;
    };
    pub const Process = struct {
        // fields
        name: ?[]const u8 = null,
        process: ?AndroidProcessMetadata = null,
        metrics: ?AndroidCpuMetric.Metrics = null,
        threads: ?[]const ?AndroidCpuMetric.Thread = null,
        core: ?[]const ?AndroidCpuMetric.CoreData = null,
        core_type: ?[]const ?AndroidCpuMetric.CoreTypeData = null,
        pub fn calcProtobufSize(self: *const AndroidCpuMetric.Process) usize {
            var res: usize = 0;
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidCpuMetric.ProcessWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.process) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidCpuMetric.ProcessWire.PROCESS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.metrics) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidCpuMetric.ProcessWire.METRICS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.threads) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidCpuMetric.ProcessWire.THREADS_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.core) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidCpuMetric.ProcessWire.CORE_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.core_type) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidCpuMetric.ProcessWire.CORE_TYPE_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidCpuMetric.Process, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidCpuMetric.Process, target: *gremlin.Writer) void {
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidCpuMetric.ProcessWire.NAME_WIRE, v);
                }
            }
            if (self.process) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidCpuMetric.ProcessWire.PROCESS_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.metrics) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidCpuMetric.ProcessWire.METRICS_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.threads) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidCpuMetric.ProcessWire.THREADS_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidCpuMetric.ProcessWire.THREADS_WIRE, 0);
                    }
                }
            }
            if (self.core) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidCpuMetric.ProcessWire.CORE_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidCpuMetric.ProcessWire.CORE_WIRE, 0);
                    }
                }
            }
            if (self.core_type) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidCpuMetric.ProcessWire.CORE_TYPE_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidCpuMetric.ProcessWire.CORE_TYPE_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const ProcessReader = struct {
        buf: gremlin.Reader,
        _name: ?[]const u8 = null,
        _process_buf: ?[]const u8 = null,
        _metrics_buf: ?[]const u8 = null,
        _threads_offset: ?usize = null,
        _threads_last_offset: ?usize = null,
        _threads_cnt: usize = 0,
        _core_offset: ?usize = null,
        _core_last_offset: ?usize = null,
        _core_cnt: usize = 0,
        _core_type_offset: ?usize = null,
        _core_type_last_offset: ?usize = null,
        _core_type_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidCpuMetric.ProcessReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidCpuMetric.ProcessReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidCpuMetric.ProcessWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    AndroidCpuMetric.ProcessWire.PROCESS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._process_buf = result.value;
                    },
                    AndroidCpuMetric.ProcessWire.METRICS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._metrics_buf = result.value;
                    },
                    AndroidCpuMetric.ProcessWire.THREADS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._threads_offset == null) {
                            res._threads_offset = offset - result.size;
                        }
                        res._threads_last_offset = offset;
                        res._threads_cnt += 1;
                    },
                    AndroidCpuMetric.ProcessWire.CORE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._core_offset == null) {
                            res._core_offset = offset - result.size;
                        }
                        res._core_last_offset = offset;
                        res._core_cnt += 1;
                    },
                    AndroidCpuMetric.ProcessWire.CORE_TYPE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._core_type_offset == null) {
                            res._core_type_offset = offset - result.size;
                        }
                        res._core_type_last_offset = offset;
                        res._core_type_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getName(self: *const AndroidCpuMetric.ProcessReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub fn getProcess(self: *const AndroidCpuMetric.ProcessReader) gremlin.Error!AndroidProcessMetadataReader {
            if (self._process_buf) |buf| {
                return try AndroidProcessMetadataReader.init(buf);
            }
            return try AndroidProcessMetadataReader.init(&[_]u8{});
        }
        pub fn getMetrics(self: *const AndroidCpuMetric.ProcessReader) gremlin.Error!AndroidCpuMetric.MetricsReader {
            if (self._metrics_buf) |buf| {
                return try AndroidCpuMetric.MetricsReader.init(buf);
            }
            return try AndroidCpuMetric.MetricsReader.init(&[_]u8{});
        }
        pub fn threadsCount(self: *const AndroidCpuMetric.ProcessReader) usize {
            return self._threads_cnt;
        }
        pub fn threadsNext(self: *AndroidCpuMetric.ProcessReader) ?AndroidCpuMetric.ThreadReader {
            if (self._threads_offset == null) return null;
            const current_offset = self._threads_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidCpuMetric.ThreadReader.init(result.value) catch return null;
            if (self._threads_last_offset != null and current_offset >= self._threads_last_offset.?) {
                self._threads_offset = null;
                return msg;
            }
            if (self._threads_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._threads_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidCpuMetric.ProcessWire.THREADS_WIRE) {
                    self._threads_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._threads_offset = null;
            return msg;
        }
        pub fn coreCount(self: *const AndroidCpuMetric.ProcessReader) usize {
            return self._core_cnt;
        }
        pub fn coreNext(self: *AndroidCpuMetric.ProcessReader) ?AndroidCpuMetric.CoreDataReader {
            if (self._core_offset == null) return null;
            const current_offset = self._core_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidCpuMetric.CoreDataReader.init(result.value) catch return null;
            if (self._core_last_offset != null and current_offset >= self._core_last_offset.?) {
                self._core_offset = null;
                return msg;
            }
            if (self._core_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._core_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidCpuMetric.ProcessWire.CORE_WIRE) {
                    self._core_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._core_offset = null;
            return msg;
        }
        pub fn coreTypeCount(self: *const AndroidCpuMetric.ProcessReader) usize {
            return self._core_type_cnt;
        }
        pub fn coreTypeNext(self: *AndroidCpuMetric.ProcessReader) ?AndroidCpuMetric.CoreTypeDataReader {
            if (self._core_type_offset == null) return null;
            const current_offset = self._core_type_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidCpuMetric.CoreTypeDataReader.init(result.value) catch return null;
            if (self._core_type_last_offset != null and current_offset >= self._core_type_last_offset.?) {
                self._core_type_offset = null;
                return msg;
            }
            if (self._core_type_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._core_type_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidCpuMetric.ProcessWire.CORE_TYPE_WIRE) {
                    self._core_type_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._core_type_offset = null;
            return msg;
        }
    };
    // fields
    process_info: ?[]const ?AndroidCpuMetric.Process = null,
    pub fn calcProtobufSize(self: *const AndroidCpuMetric) usize {
        var res: usize = 0;
        if (self.process_info) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidCpuMetricWire.PROCESS_INFO_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidCpuMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidCpuMetric, target: *gremlin.Writer) void {
        if (self.process_info) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidCpuMetricWire.PROCESS_INFO_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidCpuMetricWire.PROCESS_INFO_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidCpuMetricReader = struct {
    buf: gremlin.Reader,
    _process_info_offset: ?usize = null,
    _process_info_last_offset: ?usize = null,
    _process_info_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidCpuMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidCpuMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidCpuMetricWire.PROCESS_INFO_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._process_info_offset == null) {
                        res._process_info_offset = offset - result.size;
                    }
                    res._process_info_last_offset = offset;
                    res._process_info_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn processInfoCount(self: *const AndroidCpuMetricReader) usize {
        return self._process_info_cnt;
    }
    pub fn processInfoNext(self: *AndroidCpuMetricReader) ?AndroidCpuMetric.ProcessReader {
        if (self._process_info_offset == null) return null;
        const current_offset = self._process_info_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidCpuMetric.ProcessReader.init(result.value) catch return null;
        if (self._process_info_last_offset != null and current_offset >= self._process_info_last_offset.?) {
            self._process_info_offset = null;
            return msg;
        }
        if (self._process_info_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._process_info_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidCpuMetricWire.PROCESS_INFO_WIRE) {
                self._process_info_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._process_info_offset = null;
        return msg;
    }
};
const AndroidCodecMetricsWire = struct {
    const CPU_USAGE_WIRE: gremlin.ProtoWireNumber = 1;
    const CODEC_FUNCTION_WIRE: gremlin.ProtoWireNumber = 2;
    const ENERGY_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const AndroidCodecMetrics = struct {
    // nested structs
    const DetailWire = struct {
        const TOTAL_CPU_NS_WIRE: gremlin.ProtoWireNumber = 2;
        const RUNNING_CPU_NS_WIRE: gremlin.ProtoWireNumber = 3;
        const AVG_RUNNING_CPU_NS_WIRE: gremlin.ProtoWireNumber = 9;
        const TOTAL_CPU_CYCLES_WIRE: gremlin.ProtoWireNumber = 4;
        const AVG_CPU_CYCLES_WIRE: gremlin.ProtoWireNumber = 8;
        const AVG_TIME_NS_WIRE: gremlin.ProtoWireNumber = 5;
        const COUNT_WIRE: gremlin.ProtoWireNumber = 6;
        const SELF_WIRE: gremlin.ProtoWireNumber = 7;
    };
    pub const Detail = struct {
        // nested structs
        const LatencyWire = struct {
            const MAX_US_WIRE: gremlin.ProtoWireNumber = 1;
            const MIN_US_WIRE: gremlin.ProtoWireNumber = 2;
            const AVG_US_WIRE: gremlin.ProtoWireNumber = 3;
            const AGG_US_WIRE: gremlin.ProtoWireNumber = 4;
            const COUNT_WIRE: gremlin.ProtoWireNumber = 5;
        };
        pub const Latency = struct {
            // fields
            max_us: i64 = 0,
            min_us: i64 = 0,
            avg_us: i64 = 0,
            agg_us: i64 = 0,
            count: u32 = 0,
            pub fn calcProtobufSize(self: *const AndroidCodecMetrics.Detail.Latency) usize {
                var res: usize = 0;
                if (self.max_us != 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.Detail.LatencyWire.MAX_US_WIRE) + gremlin.sizes.sizeI64(self.max_us);
                }
                if (self.min_us != 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.Detail.LatencyWire.MIN_US_WIRE) + gremlin.sizes.sizeI64(self.min_us);
                }
                if (self.avg_us != 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.Detail.LatencyWire.AVG_US_WIRE) + gremlin.sizes.sizeI64(self.avg_us);
                }
                if (self.agg_us != 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.Detail.LatencyWire.AGG_US_WIRE) + gremlin.sizes.sizeI64(self.agg_us);
                }
                if (self.count != 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.Detail.LatencyWire.COUNT_WIRE) + gremlin.sizes.sizeU32(self.count);
                }
                return res;
            }
            pub fn encode(self: *const AndroidCodecMetrics.Detail.Latency, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const AndroidCodecMetrics.Detail.Latency, target: *gremlin.Writer) void {
                if (self.max_us != 0) {
                    target.appendInt64(AndroidCodecMetrics.Detail.LatencyWire.MAX_US_WIRE, self.max_us);
                }
                if (self.min_us != 0) {
                    target.appendInt64(AndroidCodecMetrics.Detail.LatencyWire.MIN_US_WIRE, self.min_us);
                }
                if (self.avg_us != 0) {
                    target.appendInt64(AndroidCodecMetrics.Detail.LatencyWire.AVG_US_WIRE, self.avg_us);
                }
                if (self.agg_us != 0) {
                    target.appendInt64(AndroidCodecMetrics.Detail.LatencyWire.AGG_US_WIRE, self.agg_us);
                }
                if (self.count != 0) {
                    target.appendUint32(AndroidCodecMetrics.Detail.LatencyWire.COUNT_WIRE, self.count);
                }
            }
        };
        pub const LatencyReader = struct {
            buf: gremlin.Reader,
            _max_us: i64 = 0,
            _min_us: i64 = 0,
            _avg_us: i64 = 0,
            _agg_us: i64 = 0,
            _count: u32 = 0,
            pub fn init(src: []const u8) gremlin.Error!AndroidCodecMetrics.Detail.LatencyReader {
                const buf = gremlin.Reader.init(src);
                var res = AndroidCodecMetrics.Detail.LatencyReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        AndroidCodecMetrics.Detail.LatencyWire.MAX_US_WIRE => {
                            const result = try buf.readInt64(offset);
                            offset += result.size;
                            res._max_us = result.value;
                        },
                        AndroidCodecMetrics.Detail.LatencyWire.MIN_US_WIRE => {
                            const result = try buf.readInt64(offset);
                            offset += result.size;
                            res._min_us = result.value;
                        },
                        AndroidCodecMetrics.Detail.LatencyWire.AVG_US_WIRE => {
                            const result = try buf.readInt64(offset);
                            offset += result.size;
                            res._avg_us = result.value;
                        },
                        AndroidCodecMetrics.Detail.LatencyWire.AGG_US_WIRE => {
                            const result = try buf.readInt64(offset);
                            offset += result.size;
                            res._agg_us = result.value;
                        },
                        AndroidCodecMetrics.Detail.LatencyWire.COUNT_WIRE => {
                            const result = try buf.readUInt32(offset);
                            offset += result.size;
                            res._count = result.value;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub inline fn getMaxUs(self: *const AndroidCodecMetrics.Detail.LatencyReader) i64 {
                return self._max_us;
            }
            pub inline fn getMinUs(self: *const AndroidCodecMetrics.Detail.LatencyReader) i64 {
                return self._min_us;
            }
            pub inline fn getAvgUs(self: *const AndroidCodecMetrics.Detail.LatencyReader) i64 {
                return self._avg_us;
            }
            pub inline fn getAggUs(self: *const AndroidCodecMetrics.Detail.LatencyReader) i64 {
                return self._agg_us;
            }
            pub inline fn getCount(self: *const AndroidCodecMetrics.Detail.LatencyReader) u32 {
                return self._count;
            }
        };
        // fields
        total_cpu_ns: i64 = 0,
        running_cpu_ns: i64 = 0,
        avg_running_cpu_ns: i64 = 0,
        total_cpu_cycles: i64 = 0,
        avg_cpu_cycles: i64 = 0,
        avg_time_ns: i64 = 0,
        count: i32 = 0,
        self: ?AndroidCodecMetrics.Detail.Latency = null,
        pub fn calcProtobufSize(self: *const AndroidCodecMetrics.Detail) usize {
            var res: usize = 0;
            if (self.total_cpu_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.DetailWire.TOTAL_CPU_NS_WIRE) + gremlin.sizes.sizeI64(self.total_cpu_ns);
            }
            if (self.running_cpu_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.DetailWire.RUNNING_CPU_NS_WIRE) + gremlin.sizes.sizeI64(self.running_cpu_ns);
            }
            if (self.avg_running_cpu_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.DetailWire.AVG_RUNNING_CPU_NS_WIRE) + gremlin.sizes.sizeI64(self.avg_running_cpu_ns);
            }
            if (self.total_cpu_cycles != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.DetailWire.TOTAL_CPU_CYCLES_WIRE) + gremlin.sizes.sizeI64(self.total_cpu_cycles);
            }
            if (self.avg_cpu_cycles != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.DetailWire.AVG_CPU_CYCLES_WIRE) + gremlin.sizes.sizeI64(self.avg_cpu_cycles);
            }
            if (self.avg_time_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.DetailWire.AVG_TIME_NS_WIRE) + gremlin.sizes.sizeI64(self.avg_time_ns);
            }
            if (self.count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.DetailWire.COUNT_WIRE) + gremlin.sizes.sizeI32(self.count);
            }
            if (self.self) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.DetailWire.SELF_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidCodecMetrics.Detail, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidCodecMetrics.Detail, target: *gremlin.Writer) void {
            if (self.total_cpu_ns != 0) {
                target.appendInt64(AndroidCodecMetrics.DetailWire.TOTAL_CPU_NS_WIRE, self.total_cpu_ns);
            }
            if (self.running_cpu_ns != 0) {
                target.appendInt64(AndroidCodecMetrics.DetailWire.RUNNING_CPU_NS_WIRE, self.running_cpu_ns);
            }
            if (self.avg_running_cpu_ns != 0) {
                target.appendInt64(AndroidCodecMetrics.DetailWire.AVG_RUNNING_CPU_NS_WIRE, self.avg_running_cpu_ns);
            }
            if (self.total_cpu_cycles != 0) {
                target.appendInt64(AndroidCodecMetrics.DetailWire.TOTAL_CPU_CYCLES_WIRE, self.total_cpu_cycles);
            }
            if (self.avg_cpu_cycles != 0) {
                target.appendInt64(AndroidCodecMetrics.DetailWire.AVG_CPU_CYCLES_WIRE, self.avg_cpu_cycles);
            }
            if (self.avg_time_ns != 0) {
                target.appendInt64(AndroidCodecMetrics.DetailWire.AVG_TIME_NS_WIRE, self.avg_time_ns);
            }
            if (self.count != 0) {
                target.appendInt32(AndroidCodecMetrics.DetailWire.COUNT_WIRE, self.count);
            }
            if (self.self) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidCodecMetrics.DetailWire.SELF_WIRE, size);
                    v.encodeTo(target);
                }
            }
        }
    };
    pub const DetailReader = struct {
        buf: gremlin.Reader,
        _total_cpu_ns: i64 = 0,
        _running_cpu_ns: i64 = 0,
        _avg_running_cpu_ns: i64 = 0,
        _total_cpu_cycles: i64 = 0,
        _avg_cpu_cycles: i64 = 0,
        _avg_time_ns: i64 = 0,
        _count: i32 = 0,
        _self_buf: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!AndroidCodecMetrics.DetailReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidCodecMetrics.DetailReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidCodecMetrics.DetailWire.TOTAL_CPU_NS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._total_cpu_ns = result.value;
                    },
                    AndroidCodecMetrics.DetailWire.RUNNING_CPU_NS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._running_cpu_ns = result.value;
                    },
                    AndroidCodecMetrics.DetailWire.AVG_RUNNING_CPU_NS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._avg_running_cpu_ns = result.value;
                    },
                    AndroidCodecMetrics.DetailWire.TOTAL_CPU_CYCLES_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._total_cpu_cycles = result.value;
                    },
                    AndroidCodecMetrics.DetailWire.AVG_CPU_CYCLES_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._avg_cpu_cycles = result.value;
                    },
                    AndroidCodecMetrics.DetailWire.AVG_TIME_NS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._avg_time_ns = result.value;
                    },
                    AndroidCodecMetrics.DetailWire.COUNT_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._count = result.value;
                    },
                    AndroidCodecMetrics.DetailWire.SELF_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._self_buf = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getTotalCpuNs(self: *const AndroidCodecMetrics.DetailReader) i64 {
            return self._total_cpu_ns;
        }
        pub inline fn getRunningCpuNs(self: *const AndroidCodecMetrics.DetailReader) i64 {
            return self._running_cpu_ns;
        }
        pub inline fn getAvgRunningCpuNs(self: *const AndroidCodecMetrics.DetailReader) i64 {
            return self._avg_running_cpu_ns;
        }
        pub inline fn getTotalCpuCycles(self: *const AndroidCodecMetrics.DetailReader) i64 {
            return self._total_cpu_cycles;
        }
        pub inline fn getAvgCpuCycles(self: *const AndroidCodecMetrics.DetailReader) i64 {
            return self._avg_cpu_cycles;
        }
        pub inline fn getAvgTimeNs(self: *const AndroidCodecMetrics.DetailReader) i64 {
            return self._avg_time_ns;
        }
        pub inline fn getCount(self: *const AndroidCodecMetrics.DetailReader) i32 {
            return self._count;
        }
        pub fn getSelf(self: *const AndroidCodecMetrics.DetailReader) gremlin.Error!AndroidCodecMetrics.Detail.LatencyReader {
            if (self._self_buf) |buf| {
                return try AndroidCodecMetrics.Detail.LatencyReader.init(buf);
            }
            return try AndroidCodecMetrics.Detail.LatencyReader.init(&[_]u8{});
        }
    };
    const CodecFunctionWire = struct {
        const CODEC_STRING_WIRE: gremlin.ProtoWireNumber = 1;
        const PROCESS_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const CodecFunction = struct {
        // nested structs
        const ProcessWire = struct {
            const NAME_WIRE: gremlin.ProtoWireNumber = 1;
            const THREAD_WIRE: gremlin.ProtoWireNumber = 2;
        };
        pub const Process = struct {
            // nested structs
            const ThreadWire = struct {
                const NAME_WIRE: gremlin.ProtoWireNumber = 1;
                const DETAIL_WIRE: gremlin.ProtoWireNumber = 2;
            };
            pub const Thread = struct {
                // fields
                name: ?[]const u8 = null,
                detail: ?AndroidCodecMetrics.Detail = null,
                pub fn calcProtobufSize(self: *const AndroidCodecMetrics.CodecFunction.Process.Thread) usize {
                    var res: usize = 0;
                    if (self.name) |v| {
                        if (v.len > 0) {
                            res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.CodecFunction.Process.ThreadWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                        }
                    }
                    if (self.detail) |v| {
                        const size = v.calcProtobufSize();
                        if (size > 0) {
                            res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.CodecFunction.Process.ThreadWire.DETAIL_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                        }
                    }
                    return res;
                }
                pub fn encode(self: *const AndroidCodecMetrics.CodecFunction.Process.Thread, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                    const size = self.calcProtobufSize();
                    if (size == 0) {
                        return &[_]u8{};
                    }
                    const buf = try allocator.alloc(u8, self.calcProtobufSize());
                    var writer = gremlin.Writer.init(buf);
                    self.encodeTo(&writer);
                    return buf;
                }
                pub fn encodeTo(self: *const AndroidCodecMetrics.CodecFunction.Process.Thread, target: *gremlin.Writer) void {
                    if (self.name) |v| {
                        if (v.len > 0) {
                            target.appendBytes(AndroidCodecMetrics.CodecFunction.Process.ThreadWire.NAME_WIRE, v);
                        }
                    }
                    if (self.detail) |v| {
                        const size = v.calcProtobufSize();
                        if (size > 0) {
                            target.appendBytesTag(AndroidCodecMetrics.CodecFunction.Process.ThreadWire.DETAIL_WIRE, size);
                            v.encodeTo(target);
                        }
                    }
                }
            };
            pub const ThreadReader = struct {
                buf: gremlin.Reader,
                _name: ?[]const u8 = null,
                _detail_buf: ?[]const u8 = null,
                pub fn init(src: []const u8) gremlin.Error!AndroidCodecMetrics.CodecFunction.Process.ThreadReader {
                    const buf = gremlin.Reader.init(src);
                    var res = AndroidCodecMetrics.CodecFunction.Process.ThreadReader{ .buf = buf };
                    if (buf.buf.len == 0) {
                        return res;
                    }
                    var offset: usize = 0;
                    while (buf.hasNext(offset, 0)) {
                        const tag = try buf.readTagAt(offset);
                        offset += tag.size;
                        switch (tag.number) {
                            AndroidCodecMetrics.CodecFunction.Process.ThreadWire.NAME_WIRE => {
                                const result = try buf.readBytes(offset);
                                offset += result.size;
                                res._name = result.value;
                            },
                            AndroidCodecMetrics.CodecFunction.Process.ThreadWire.DETAIL_WIRE => {
                                const result = try buf.readBytes(offset);
                                offset += result.size;
                                res._detail_buf = result.value;
                            },
                            else => {
                                offset = try buf.skipData(offset, tag.wire);
                            },
                        }
                    }
                    return res;
                }
                pub fn sourceBytes(self: *const @This()) []const u8 {
                    return self.buf.buf;
                }
                pub inline fn getName(self: *const AndroidCodecMetrics.CodecFunction.Process.ThreadReader) []const u8 {
                    return self._name orelse &[_]u8{};
                }
                pub fn getDetail(self: *const AndroidCodecMetrics.CodecFunction.Process.ThreadReader) gremlin.Error!AndroidCodecMetrics.DetailReader {
                    if (self._detail_buf) |buf| {
                        return try AndroidCodecMetrics.DetailReader.init(buf);
                    }
                    return try AndroidCodecMetrics.DetailReader.init(&[_]u8{});
                }
            };
            // fields
            name: ?[]const u8 = null,
            thread: ?AndroidCodecMetrics.CodecFunction.Process.Thread = null,
            pub fn calcProtobufSize(self: *const AndroidCodecMetrics.CodecFunction.Process) usize {
                var res: usize = 0;
                if (self.name) |v| {
                    if (v.len > 0) {
                        res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.CodecFunction.ProcessWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                    }
                }
                if (self.thread) |v| {
                    const size = v.calcProtobufSize();
                    if (size > 0) {
                        res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.CodecFunction.ProcessWire.THREAD_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                    }
                }
                return res;
            }
            pub fn encode(self: *const AndroidCodecMetrics.CodecFunction.Process, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const AndroidCodecMetrics.CodecFunction.Process, target: *gremlin.Writer) void {
                if (self.name) |v| {
                    if (v.len > 0) {
                        target.appendBytes(AndroidCodecMetrics.CodecFunction.ProcessWire.NAME_WIRE, v);
                    }
                }
                if (self.thread) |v| {
                    const size = v.calcProtobufSize();
                    if (size > 0) {
                        target.appendBytesTag(AndroidCodecMetrics.CodecFunction.ProcessWire.THREAD_WIRE, size);
                        v.encodeTo(target);
                    }
                }
            }
        };
        pub const ProcessReader = struct {
            buf: gremlin.Reader,
            _name: ?[]const u8 = null,
            _thread_buf: ?[]const u8 = null,
            pub fn init(src: []const u8) gremlin.Error!AndroidCodecMetrics.CodecFunction.ProcessReader {
                const buf = gremlin.Reader.init(src);
                var res = AndroidCodecMetrics.CodecFunction.ProcessReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        AndroidCodecMetrics.CodecFunction.ProcessWire.NAME_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._name = result.value;
                        },
                        AndroidCodecMetrics.CodecFunction.ProcessWire.THREAD_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._thread_buf = result.value;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub inline fn getName(self: *const AndroidCodecMetrics.CodecFunction.ProcessReader) []const u8 {
                return self._name orelse &[_]u8{};
            }
            pub fn getThread(self: *const AndroidCodecMetrics.CodecFunction.ProcessReader) gremlin.Error!AndroidCodecMetrics.CodecFunction.Process.ThreadReader {
                if (self._thread_buf) |buf| {
                    return try AndroidCodecMetrics.CodecFunction.Process.ThreadReader.init(buf);
                }
                return try AndroidCodecMetrics.CodecFunction.Process.ThreadReader.init(&[_]u8{});
            }
        };
        // fields
        codec_string: ?[]const u8 = null,
        process: ?AndroidCodecMetrics.CodecFunction.Process = null,
        pub fn calcProtobufSize(self: *const AndroidCodecMetrics.CodecFunction) usize {
            var res: usize = 0;
            if (self.codec_string) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.CodecFunctionWire.CODEC_STRING_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.process) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.CodecFunctionWire.PROCESS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidCodecMetrics.CodecFunction, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidCodecMetrics.CodecFunction, target: *gremlin.Writer) void {
            if (self.codec_string) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidCodecMetrics.CodecFunctionWire.CODEC_STRING_WIRE, v);
                }
            }
            if (self.process) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidCodecMetrics.CodecFunctionWire.PROCESS_WIRE, size);
                    v.encodeTo(target);
                }
            }
        }
    };
    pub const CodecFunctionReader = struct {
        buf: gremlin.Reader,
        _codec_string: ?[]const u8 = null,
        _process_buf: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!AndroidCodecMetrics.CodecFunctionReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidCodecMetrics.CodecFunctionReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidCodecMetrics.CodecFunctionWire.CODEC_STRING_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._codec_string = result.value;
                    },
                    AndroidCodecMetrics.CodecFunctionWire.PROCESS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._process_buf = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getCodecString(self: *const AndroidCodecMetrics.CodecFunctionReader) []const u8 {
            return self._codec_string orelse &[_]u8{};
        }
        pub fn getProcess(self: *const AndroidCodecMetrics.CodecFunctionReader) gremlin.Error!AndroidCodecMetrics.CodecFunction.ProcessReader {
            if (self._process_buf) |buf| {
                return try AndroidCodecMetrics.CodecFunction.ProcessReader.init(buf);
            }
            return try AndroidCodecMetrics.CodecFunction.ProcessReader.init(&[_]u8{});
        }
    };
    const CpuUsageWire = struct {
        const PROCESS_NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const THREAD_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const CpuUsage = struct {
        // nested structs
        const ThreadInfoWire = struct {
            const NAME_WIRE: gremlin.ProtoWireNumber = 1;
            const INFO_WIRE: gremlin.ProtoWireNumber = 2;
        };
        pub const ThreadInfo = struct {
            // nested structs
            const DetailsWire = struct {
                const THREAD_CPU_NS_WIRE: gremlin.ProtoWireNumber = 1;
                const NUM_THREADS_WIRE: gremlin.ProtoWireNumber = 2;
                const CORE_DATA_WIRE: gremlin.ProtoWireNumber = 3;
            };
            pub const Details = struct {
                // fields
                thread_cpu_ns: i64 = 0,
                num_threads: u32 = 0,
                core_data: ?[]const ?AndroidCpuMetric.CoreTypeData = null,
                pub fn calcProtobufSize(self: *const AndroidCodecMetrics.CpuUsage.ThreadInfo.Details) usize {
                    var res: usize = 0;
                    if (self.thread_cpu_ns != 0) {
                        res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.CpuUsage.ThreadInfo.DetailsWire.THREAD_CPU_NS_WIRE) + gremlin.sizes.sizeI64(self.thread_cpu_ns);
                    }
                    if (self.num_threads != 0) {
                        res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.CpuUsage.ThreadInfo.DetailsWire.NUM_THREADS_WIRE) + gremlin.sizes.sizeU32(self.num_threads);
                    }
                    if (self.core_data) |arr| {
                        for (arr) |maybe_v| {
                            res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.CpuUsage.ThreadInfo.DetailsWire.CORE_DATA_WIRE);
                            if (maybe_v) |v| {
                                const size = v.calcProtobufSize();
                                res += gremlin.sizes.sizeUsize(size) + size;
                            } else {
                                res += gremlin.sizes.sizeUsize(0);
                            }
                        }
                    }
                    return res;
                }
                pub fn encode(self: *const AndroidCodecMetrics.CpuUsage.ThreadInfo.Details, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                    const size = self.calcProtobufSize();
                    if (size == 0) {
                        return &[_]u8{};
                    }
                    const buf = try allocator.alloc(u8, self.calcProtobufSize());
                    var writer = gremlin.Writer.init(buf);
                    self.encodeTo(&writer);
                    return buf;
                }
                pub fn encodeTo(self: *const AndroidCodecMetrics.CpuUsage.ThreadInfo.Details, target: *gremlin.Writer) void {
                    if (self.thread_cpu_ns != 0) {
                        target.appendInt64(AndroidCodecMetrics.CpuUsage.ThreadInfo.DetailsWire.THREAD_CPU_NS_WIRE, self.thread_cpu_ns);
                    }
                    if (self.num_threads != 0) {
                        target.appendUint32(AndroidCodecMetrics.CpuUsage.ThreadInfo.DetailsWire.NUM_THREADS_WIRE, self.num_threads);
                    }
                    if (self.core_data) |arr| {
                        for (arr) |maybe_v| {
                            if (maybe_v) |v| {
                                const size = v.calcProtobufSize();
                                target.appendBytesTag(AndroidCodecMetrics.CpuUsage.ThreadInfo.DetailsWire.CORE_DATA_WIRE, size);
                                v.encodeTo(target);
                            } else {
                                target.appendBytesTag(AndroidCodecMetrics.CpuUsage.ThreadInfo.DetailsWire.CORE_DATA_WIRE, 0);
                            }
                        }
                    }
                }
            };
            pub const DetailsReader = struct {
                buf: gremlin.Reader,
                _thread_cpu_ns: i64 = 0,
                _num_threads: u32 = 0,
                _core_data_offset: ?usize = null,
                _core_data_last_offset: ?usize = null,
                _core_data_cnt: usize = 0,
                pub fn init(src: []const u8) gremlin.Error!AndroidCodecMetrics.CpuUsage.ThreadInfo.DetailsReader {
                    const buf = gremlin.Reader.init(src);
                    var res = AndroidCodecMetrics.CpuUsage.ThreadInfo.DetailsReader{ .buf = buf };
                    if (buf.buf.len == 0) {
                        return res;
                    }
                    var offset: usize = 0;
                    while (buf.hasNext(offset, 0)) {
                        const tag = try buf.readTagAt(offset);
                        offset += tag.size;
                        switch (tag.number) {
                            AndroidCodecMetrics.CpuUsage.ThreadInfo.DetailsWire.THREAD_CPU_NS_WIRE => {
                                const result = try buf.readInt64(offset);
                                offset += result.size;
                                res._thread_cpu_ns = result.value;
                            },
                            AndroidCodecMetrics.CpuUsage.ThreadInfo.DetailsWire.NUM_THREADS_WIRE => {
                                const result = try buf.readUInt32(offset);
                                offset += result.size;
                                res._num_threads = result.value;
                            },
                            AndroidCodecMetrics.CpuUsage.ThreadInfo.DetailsWire.CORE_DATA_WIRE => {
                                const result = try buf.readBytes(offset);
                                offset += result.size;
                                if (res._core_data_offset == null) {
                                    res._core_data_offset = offset - result.size;
                                }
                                res._core_data_last_offset = offset;
                                res._core_data_cnt += 1;
                            },
                            else => {
                                offset = try buf.skipData(offset, tag.wire);
                            },
                        }
                    }
                    return res;
                }
                pub fn sourceBytes(self: *const @This()) []const u8 {
                    return self.buf.buf;
                }
                pub inline fn getThreadCpuNs(self: *const AndroidCodecMetrics.CpuUsage.ThreadInfo.DetailsReader) i64 {
                    return self._thread_cpu_ns;
                }
                pub inline fn getNumThreads(self: *const AndroidCodecMetrics.CpuUsage.ThreadInfo.DetailsReader) u32 {
                    return self._num_threads;
                }
                pub fn coreDataCount(self: *const AndroidCodecMetrics.CpuUsage.ThreadInfo.DetailsReader) usize {
                    return self._core_data_cnt;
                }
                pub fn coreDataNext(self: *AndroidCodecMetrics.CpuUsage.ThreadInfo.DetailsReader) ?AndroidCpuMetric.CoreTypeDataReader {
                    if (self._core_data_offset == null) return null;
                    const current_offset = self._core_data_offset.?;
                    const result = self.buf.readBytes(current_offset) catch return null;
                    const msg = AndroidCpuMetric.CoreTypeDataReader.init(result.value) catch return null;
                    if (self._core_data_last_offset != null and current_offset >= self._core_data_last_offset.?) {
                        self._core_data_offset = null;
                        return msg;
                    }
                    if (self._core_data_last_offset == null) unreachable;
                    var next_offset = current_offset + result.size;
                    const max_offset = self._core_data_last_offset.?;
                    while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                        const tag = self.buf.readTagAt(next_offset) catch break;
                        next_offset += tag.size;
                        if (tag.number == AndroidCodecMetrics.CpuUsage.ThreadInfo.DetailsWire.CORE_DATA_WIRE) {
                            self._core_data_offset = next_offset;
                            return msg;
                        } else {
                            next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                        }
                    }
                    self._core_data_offset = null;
                    return msg;
                }
            };
            // fields
            name: ?[]const u8 = null,
            info: ?AndroidCodecMetrics.CpuUsage.ThreadInfo.Details = null,
            pub fn calcProtobufSize(self: *const AndroidCodecMetrics.CpuUsage.ThreadInfo) usize {
                var res: usize = 0;
                if (self.name) |v| {
                    if (v.len > 0) {
                        res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.CpuUsage.ThreadInfoWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                    }
                }
                if (self.info) |v| {
                    const size = v.calcProtobufSize();
                    if (size > 0) {
                        res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.CpuUsage.ThreadInfoWire.INFO_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                    }
                }
                return res;
            }
            pub fn encode(self: *const AndroidCodecMetrics.CpuUsage.ThreadInfo, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const AndroidCodecMetrics.CpuUsage.ThreadInfo, target: *gremlin.Writer) void {
                if (self.name) |v| {
                    if (v.len > 0) {
                        target.appendBytes(AndroidCodecMetrics.CpuUsage.ThreadInfoWire.NAME_WIRE, v);
                    }
                }
                if (self.info) |v| {
                    const size = v.calcProtobufSize();
                    if (size > 0) {
                        target.appendBytesTag(AndroidCodecMetrics.CpuUsage.ThreadInfoWire.INFO_WIRE, size);
                        v.encodeTo(target);
                    }
                }
            }
        };
        pub const ThreadInfoReader = struct {
            buf: gremlin.Reader,
            _name: ?[]const u8 = null,
            _info_buf: ?[]const u8 = null,
            pub fn init(src: []const u8) gremlin.Error!AndroidCodecMetrics.CpuUsage.ThreadInfoReader {
                const buf = gremlin.Reader.init(src);
                var res = AndroidCodecMetrics.CpuUsage.ThreadInfoReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        AndroidCodecMetrics.CpuUsage.ThreadInfoWire.NAME_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._name = result.value;
                        },
                        AndroidCodecMetrics.CpuUsage.ThreadInfoWire.INFO_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._info_buf = result.value;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub inline fn getName(self: *const AndroidCodecMetrics.CpuUsage.ThreadInfoReader) []const u8 {
                return self._name orelse &[_]u8{};
            }
            pub fn getInfo(self: *const AndroidCodecMetrics.CpuUsage.ThreadInfoReader) gremlin.Error!AndroidCodecMetrics.CpuUsage.ThreadInfo.DetailsReader {
                if (self._info_buf) |buf| {
                    return try AndroidCodecMetrics.CpuUsage.ThreadInfo.DetailsReader.init(buf);
                }
                return try AndroidCodecMetrics.CpuUsage.ThreadInfo.DetailsReader.init(&[_]u8{});
            }
        };
        // fields
        process_name: ?[]const u8 = null,
        thread: ?AndroidCodecMetrics.CpuUsage.ThreadInfo = null,
        pub fn calcProtobufSize(self: *const AndroidCodecMetrics.CpuUsage) usize {
            var res: usize = 0;
            if (self.process_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.CpuUsageWire.PROCESS_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.thread) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.CpuUsageWire.THREAD_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidCodecMetrics.CpuUsage, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidCodecMetrics.CpuUsage, target: *gremlin.Writer) void {
            if (self.process_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidCodecMetrics.CpuUsageWire.PROCESS_NAME_WIRE, v);
                }
            }
            if (self.thread) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidCodecMetrics.CpuUsageWire.THREAD_WIRE, size);
                    v.encodeTo(target);
                }
            }
        }
    };
    pub const CpuUsageReader = struct {
        buf: gremlin.Reader,
        _process_name: ?[]const u8 = null,
        _thread_buf: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!AndroidCodecMetrics.CpuUsageReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidCodecMetrics.CpuUsageReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidCodecMetrics.CpuUsageWire.PROCESS_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._process_name = result.value;
                    },
                    AndroidCodecMetrics.CpuUsageWire.THREAD_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._thread_buf = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getProcessName(self: *const AndroidCodecMetrics.CpuUsageReader) []const u8 {
            return self._process_name orelse &[_]u8{};
        }
        pub fn getThread(self: *const AndroidCodecMetrics.CpuUsageReader) gremlin.Error!AndroidCodecMetrics.CpuUsage.ThreadInfoReader {
            if (self._thread_buf) |buf| {
                return try AndroidCodecMetrics.CpuUsage.ThreadInfoReader.init(buf);
            }
            return try AndroidCodecMetrics.CpuUsage.ThreadInfoReader.init(&[_]u8{});
        }
    };
    const RailWire = struct {
        const NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const INFO_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const Rail = struct {
        // nested structs
        const InfoWire = struct {
            const ENERGY_WIRE: gremlin.ProtoWireNumber = 1;
            const POWER_MW_WIRE: gremlin.ProtoWireNumber = 2;
        };
        pub const Info = struct {
            // fields
            energy: f64 = 0.0,
            power_mw: f64 = 0.0,
            pub fn calcProtobufSize(self: *const AndroidCodecMetrics.Rail.Info) usize {
                var res: usize = 0;
                if (self.energy != 0.0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.Rail.InfoWire.ENERGY_WIRE) + gremlin.sizes.sizeDouble(self.energy);
                }
                if (self.power_mw != 0.0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.Rail.InfoWire.POWER_MW_WIRE) + gremlin.sizes.sizeDouble(self.power_mw);
                }
                return res;
            }
            pub fn encode(self: *const AndroidCodecMetrics.Rail.Info, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const AndroidCodecMetrics.Rail.Info, target: *gremlin.Writer) void {
                if (self.energy != 0.0) {
                    target.appendFloat64(AndroidCodecMetrics.Rail.InfoWire.ENERGY_WIRE, self.energy);
                }
                if (self.power_mw != 0.0) {
                    target.appendFloat64(AndroidCodecMetrics.Rail.InfoWire.POWER_MW_WIRE, self.power_mw);
                }
            }
        };
        pub const InfoReader = struct {
            buf: gremlin.Reader,
            _energy: f64 = 0.0,
            _power_mw: f64 = 0.0,
            pub fn init(src: []const u8) gremlin.Error!AndroidCodecMetrics.Rail.InfoReader {
                const buf = gremlin.Reader.init(src);
                var res = AndroidCodecMetrics.Rail.InfoReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        AndroidCodecMetrics.Rail.InfoWire.ENERGY_WIRE => {
                            const result = try buf.readFloat64(offset);
                            offset += result.size;
                            res._energy = result.value;
                        },
                        AndroidCodecMetrics.Rail.InfoWire.POWER_MW_WIRE => {
                            const result = try buf.readFloat64(offset);
                            offset += result.size;
                            res._power_mw = result.value;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub inline fn getEnergy(self: *const AndroidCodecMetrics.Rail.InfoReader) f64 {
                return self._energy;
            }
            pub inline fn getPowerMw(self: *const AndroidCodecMetrics.Rail.InfoReader) f64 {
                return self._power_mw;
            }
        };
        // fields
        name: ?[]const u8 = null,
        info: ?AndroidCodecMetrics.Rail.Info = null,
        pub fn calcProtobufSize(self: *const AndroidCodecMetrics.Rail) usize {
            var res: usize = 0;
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.RailWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.info) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.RailWire.INFO_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidCodecMetrics.Rail, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidCodecMetrics.Rail, target: *gremlin.Writer) void {
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidCodecMetrics.RailWire.NAME_WIRE, v);
                }
            }
            if (self.info) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidCodecMetrics.RailWire.INFO_WIRE, size);
                    v.encodeTo(target);
                }
            }
        }
    };
    pub const RailReader = struct {
        buf: gremlin.Reader,
        _name: ?[]const u8 = null,
        _info_buf: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!AndroidCodecMetrics.RailReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidCodecMetrics.RailReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidCodecMetrics.RailWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    AndroidCodecMetrics.RailWire.INFO_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._info_buf = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getName(self: *const AndroidCodecMetrics.RailReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub fn getInfo(self: *const AndroidCodecMetrics.RailReader) gremlin.Error!AndroidCodecMetrics.Rail.InfoReader {
            if (self._info_buf) |buf| {
                return try AndroidCodecMetrics.Rail.InfoReader.init(buf);
            }
            return try AndroidCodecMetrics.Rail.InfoReader.init(&[_]u8{});
        }
    };
    const EnergyWire = struct {
        const TOTAL_ENERGY_WIRE: gremlin.ProtoWireNumber = 1;
        const DURATION_WIRE: gremlin.ProtoWireNumber = 2;
        const POWER_MW_WIRE: gremlin.ProtoWireNumber = 3;
        const RAIL_WIRE: gremlin.ProtoWireNumber = 4;
    };
    pub const Energy = struct {
        // fields
        total_energy: f64 = 0.0,
        duration: i64 = 0,
        power_mw: f64 = 0.0,
        rail: ?[]const ?AndroidCodecMetrics.Rail = null,
        pub fn calcProtobufSize(self: *const AndroidCodecMetrics.Energy) usize {
            var res: usize = 0;
            if (self.total_energy != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.EnergyWire.TOTAL_ENERGY_WIRE) + gremlin.sizes.sizeDouble(self.total_energy);
            }
            if (self.duration != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.EnergyWire.DURATION_WIRE) + gremlin.sizes.sizeI64(self.duration);
            }
            if (self.power_mw != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.EnergyWire.POWER_MW_WIRE) + gremlin.sizes.sizeDouble(self.power_mw);
            }
            if (self.rail) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.EnergyWire.RAIL_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidCodecMetrics.Energy, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidCodecMetrics.Energy, target: *gremlin.Writer) void {
            if (self.total_energy != 0.0) {
                target.appendFloat64(AndroidCodecMetrics.EnergyWire.TOTAL_ENERGY_WIRE, self.total_energy);
            }
            if (self.duration != 0) {
                target.appendInt64(AndroidCodecMetrics.EnergyWire.DURATION_WIRE, self.duration);
            }
            if (self.power_mw != 0.0) {
                target.appendFloat64(AndroidCodecMetrics.EnergyWire.POWER_MW_WIRE, self.power_mw);
            }
            if (self.rail) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidCodecMetrics.EnergyWire.RAIL_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidCodecMetrics.EnergyWire.RAIL_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const EnergyReader = struct {
        buf: gremlin.Reader,
        _total_energy: f64 = 0.0,
        _duration: i64 = 0,
        _power_mw: f64 = 0.0,
        _rail_offset: ?usize = null,
        _rail_last_offset: ?usize = null,
        _rail_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidCodecMetrics.EnergyReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidCodecMetrics.EnergyReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidCodecMetrics.EnergyWire.TOTAL_ENERGY_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._total_energy = result.value;
                    },
                    AndroidCodecMetrics.EnergyWire.DURATION_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._duration = result.value;
                    },
                    AndroidCodecMetrics.EnergyWire.POWER_MW_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._power_mw = result.value;
                    },
                    AndroidCodecMetrics.EnergyWire.RAIL_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._rail_offset == null) {
                            res._rail_offset = offset - result.size;
                        }
                        res._rail_last_offset = offset;
                        res._rail_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getTotalEnergy(self: *const AndroidCodecMetrics.EnergyReader) f64 {
            return self._total_energy;
        }
        pub inline fn getDuration(self: *const AndroidCodecMetrics.EnergyReader) i64 {
            return self._duration;
        }
        pub inline fn getPowerMw(self: *const AndroidCodecMetrics.EnergyReader) f64 {
            return self._power_mw;
        }
        pub fn railCount(self: *const AndroidCodecMetrics.EnergyReader) usize {
            return self._rail_cnt;
        }
        pub fn railNext(self: *AndroidCodecMetrics.EnergyReader) ?AndroidCodecMetrics.RailReader {
            if (self._rail_offset == null) return null;
            const current_offset = self._rail_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidCodecMetrics.RailReader.init(result.value) catch return null;
            if (self._rail_last_offset != null and current_offset >= self._rail_last_offset.?) {
                self._rail_offset = null;
                return msg;
            }
            if (self._rail_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._rail_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidCodecMetrics.EnergyWire.RAIL_WIRE) {
                    self._rail_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._rail_offset = null;
            return msg;
        }
    };
    // fields
    cpu_usage: ?[]const ?AndroidCodecMetrics.CpuUsage = null,
    codec_function: ?[]const ?AndroidCodecMetrics.CodecFunction = null,
    energy: ?AndroidCodecMetrics.Energy = null,
    pub fn calcProtobufSize(self: *const AndroidCodecMetrics) usize {
        var res: usize = 0;
        if (self.cpu_usage) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidCodecMetricsWire.CPU_USAGE_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.codec_function) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidCodecMetricsWire.CODEC_FUNCTION_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.energy) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidCodecMetricsWire.ENERGY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidCodecMetrics, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidCodecMetrics, target: *gremlin.Writer) void {
        if (self.cpu_usage) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidCodecMetricsWire.CPU_USAGE_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidCodecMetricsWire.CPU_USAGE_WIRE, 0);
                }
            }
        }
        if (self.codec_function) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidCodecMetricsWire.CODEC_FUNCTION_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidCodecMetricsWire.CODEC_FUNCTION_WIRE, 0);
                }
            }
        }
        if (self.energy) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidCodecMetricsWire.ENERGY_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const AndroidCodecMetricsReader = struct {
    buf: gremlin.Reader,
    _cpu_usage_offset: ?usize = null,
    _cpu_usage_last_offset: ?usize = null,
    _cpu_usage_cnt: usize = 0,
    _codec_function_offset: ?usize = null,
    _codec_function_last_offset: ?usize = null,
    _codec_function_cnt: usize = 0,
    _energy_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!AndroidCodecMetricsReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidCodecMetricsReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidCodecMetricsWire.CPU_USAGE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._cpu_usage_offset == null) {
                        res._cpu_usage_offset = offset - result.size;
                    }
                    res._cpu_usage_last_offset = offset;
                    res._cpu_usage_cnt += 1;
                },
                AndroidCodecMetricsWire.CODEC_FUNCTION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._codec_function_offset == null) {
                        res._codec_function_offset = offset - result.size;
                    }
                    res._codec_function_last_offset = offset;
                    res._codec_function_cnt += 1;
                },
                AndroidCodecMetricsWire.ENERGY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._energy_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn cpuUsageCount(self: *const AndroidCodecMetricsReader) usize {
        return self._cpu_usage_cnt;
    }
    pub fn cpuUsageNext(self: *AndroidCodecMetricsReader) ?AndroidCodecMetrics.CpuUsageReader {
        if (self._cpu_usage_offset == null) return null;
        const current_offset = self._cpu_usage_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidCodecMetrics.CpuUsageReader.init(result.value) catch return null;
        if (self._cpu_usage_last_offset != null and current_offset >= self._cpu_usage_last_offset.?) {
            self._cpu_usage_offset = null;
            return msg;
        }
        if (self._cpu_usage_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._cpu_usage_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidCodecMetricsWire.CPU_USAGE_WIRE) {
                self._cpu_usage_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._cpu_usage_offset = null;
        return msg;
    }
    pub fn codecFunctionCount(self: *const AndroidCodecMetricsReader) usize {
        return self._codec_function_cnt;
    }
    pub fn codecFunctionNext(self: *AndroidCodecMetricsReader) ?AndroidCodecMetrics.CodecFunctionReader {
        if (self._codec_function_offset == null) return null;
        const current_offset = self._codec_function_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidCodecMetrics.CodecFunctionReader.init(result.value) catch return null;
        if (self._codec_function_last_offset != null and current_offset >= self._codec_function_last_offset.?) {
            self._codec_function_offset = null;
            return msg;
        }
        if (self._codec_function_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._codec_function_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidCodecMetricsWire.CODEC_FUNCTION_WIRE) {
                self._codec_function_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._codec_function_offset = null;
        return msg;
    }
    pub fn getEnergy(self: *const AndroidCodecMetricsReader) gremlin.Error!AndroidCodecMetrics.EnergyReader {
        if (self._energy_buf) |buf| {
            return try AndroidCodecMetrics.EnergyReader.init(buf);
        }
        return try AndroidCodecMetrics.EnergyReader.init(&[_]u8{});
    }
};
const AndroidDisplayMetricsWire = struct {
    const TOTAL_DUPLICATE_FRAMES_WIRE: gremlin.ProtoWireNumber = 1;
    const DUPLICATE_FRAMES_LOGGED_WIRE: gremlin.ProtoWireNumber = 2;
    const TOTAL_DPU_UNDERRUN_COUNT_WIRE: gremlin.ProtoWireNumber = 3;
    const REFRESH_RATE_SWITCHES_WIRE: gremlin.ProtoWireNumber = 4;
    const REFRESH_RATE_STATS_WIRE: gremlin.ProtoWireNumber = 5;
    const UPDATE_POWER_STATE_WIRE: gremlin.ProtoWireNumber = 6;
    const DPU_STATE_WIRE: gremlin.ProtoWireNumber = 7;
};
pub const AndroidDisplayMetrics = struct {
    // nested structs
    const RefreshRateStatWire = struct {
        const REFRESH_RATE_FPS_WIRE: gremlin.ProtoWireNumber = 1;
        const COUNT_WIRE: gremlin.ProtoWireNumber = 2;
        const TOTAL_DUR_MS_WIRE: gremlin.ProtoWireNumber = 3;
        const AVG_DUR_MS_WIRE: gremlin.ProtoWireNumber = 4;
    };
    pub const RefreshRateStat = struct {
        // fields
        refresh_rate_fps: u32 = 0,
        count: u32 = 0,
        total_dur_ms: f64 = 0.0,
        avg_dur_ms: f64 = 0.0,
        pub fn calcProtobufSize(self: *const AndroidDisplayMetrics.RefreshRateStat) usize {
            var res: usize = 0;
            if (self.refresh_rate_fps != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidDisplayMetrics.RefreshRateStatWire.REFRESH_RATE_FPS_WIRE) + gremlin.sizes.sizeU32(self.refresh_rate_fps);
            }
            if (self.count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidDisplayMetrics.RefreshRateStatWire.COUNT_WIRE) + gremlin.sizes.sizeU32(self.count);
            }
            if (self.total_dur_ms != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidDisplayMetrics.RefreshRateStatWire.TOTAL_DUR_MS_WIRE) + gremlin.sizes.sizeDouble(self.total_dur_ms);
            }
            if (self.avg_dur_ms != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidDisplayMetrics.RefreshRateStatWire.AVG_DUR_MS_WIRE) + gremlin.sizes.sizeDouble(self.avg_dur_ms);
            }
            return res;
        }
        pub fn encode(self: *const AndroidDisplayMetrics.RefreshRateStat, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidDisplayMetrics.RefreshRateStat, target: *gremlin.Writer) void {
            if (self.refresh_rate_fps != 0) {
                target.appendUint32(AndroidDisplayMetrics.RefreshRateStatWire.REFRESH_RATE_FPS_WIRE, self.refresh_rate_fps);
            }
            if (self.count != 0) {
                target.appendUint32(AndroidDisplayMetrics.RefreshRateStatWire.COUNT_WIRE, self.count);
            }
            if (self.total_dur_ms != 0.0) {
                target.appendFloat64(AndroidDisplayMetrics.RefreshRateStatWire.TOTAL_DUR_MS_WIRE, self.total_dur_ms);
            }
            if (self.avg_dur_ms != 0.0) {
                target.appendFloat64(AndroidDisplayMetrics.RefreshRateStatWire.AVG_DUR_MS_WIRE, self.avg_dur_ms);
            }
        }
    };
    pub const RefreshRateStatReader = struct {
        buf: gremlin.Reader,
        _refresh_rate_fps: u32 = 0,
        _count: u32 = 0,
        _total_dur_ms: f64 = 0.0,
        _avg_dur_ms: f64 = 0.0,
        pub fn init(src: []const u8) gremlin.Error!AndroidDisplayMetrics.RefreshRateStatReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidDisplayMetrics.RefreshRateStatReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidDisplayMetrics.RefreshRateStatWire.REFRESH_RATE_FPS_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._refresh_rate_fps = result.value;
                    },
                    AndroidDisplayMetrics.RefreshRateStatWire.COUNT_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._count = result.value;
                    },
                    AndroidDisplayMetrics.RefreshRateStatWire.TOTAL_DUR_MS_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._total_dur_ms = result.value;
                    },
                    AndroidDisplayMetrics.RefreshRateStatWire.AVG_DUR_MS_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._avg_dur_ms = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getRefreshRateFps(self: *const AndroidDisplayMetrics.RefreshRateStatReader) u32 {
            return self._refresh_rate_fps;
        }
        pub inline fn getCount(self: *const AndroidDisplayMetrics.RefreshRateStatReader) u32 {
            return self._count;
        }
        pub inline fn getTotalDurMs(self: *const AndroidDisplayMetrics.RefreshRateStatReader) f64 {
            return self._total_dur_ms;
        }
        pub inline fn getAvgDurMs(self: *const AndroidDisplayMetrics.RefreshRateStatReader) f64 {
            return self._avg_dur_ms;
        }
    };
    const UpdatePowerStateWire = struct {
        const AVG_RUNTIME_MICRO_SECS_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const UpdatePowerState = struct {
        // fields
        avg_runtime_micro_secs: u32 = 0,
        pub fn calcProtobufSize(self: *const AndroidDisplayMetrics.UpdatePowerState) usize {
            var res: usize = 0;
            if (self.avg_runtime_micro_secs != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidDisplayMetrics.UpdatePowerStateWire.AVG_RUNTIME_MICRO_SECS_WIRE) + gremlin.sizes.sizeU32(self.avg_runtime_micro_secs);
            }
            return res;
        }
        pub fn encode(self: *const AndroidDisplayMetrics.UpdatePowerState, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidDisplayMetrics.UpdatePowerState, target: *gremlin.Writer) void {
            if (self.avg_runtime_micro_secs != 0) {
                target.appendUint32(AndroidDisplayMetrics.UpdatePowerStateWire.AVG_RUNTIME_MICRO_SECS_WIRE, self.avg_runtime_micro_secs);
            }
        }
    };
    pub const UpdatePowerStateReader = struct {
        buf: gremlin.Reader,
        _avg_runtime_micro_secs: u32 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidDisplayMetrics.UpdatePowerStateReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidDisplayMetrics.UpdatePowerStateReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidDisplayMetrics.UpdatePowerStateWire.AVG_RUNTIME_MICRO_SECS_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._avg_runtime_micro_secs = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getAvgRuntimeMicroSecs(self: *const AndroidDisplayMetrics.UpdatePowerStateReader) u32 {
            return self._avg_runtime_micro_secs;
        }
    };
    const DpuUnderrunDetailWire = struct {
        const NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const DPU_UNDERRUN_COUNT_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const DpuUnderrunDetail = struct {
        // fields
        name: ?[]const u8 = null,
        dpu_underrun_count: u32 = 0,
        pub fn calcProtobufSize(self: *const AndroidDisplayMetrics.DpuUnderrunDetail) usize {
            var res: usize = 0;
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidDisplayMetrics.DpuUnderrunDetailWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.dpu_underrun_count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidDisplayMetrics.DpuUnderrunDetailWire.DPU_UNDERRUN_COUNT_WIRE) + gremlin.sizes.sizeU32(self.dpu_underrun_count);
            }
            return res;
        }
        pub fn encode(self: *const AndroidDisplayMetrics.DpuUnderrunDetail, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidDisplayMetrics.DpuUnderrunDetail, target: *gremlin.Writer) void {
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidDisplayMetrics.DpuUnderrunDetailWire.NAME_WIRE, v);
                }
            }
            if (self.dpu_underrun_count != 0) {
                target.appendUint32(AndroidDisplayMetrics.DpuUnderrunDetailWire.DPU_UNDERRUN_COUNT_WIRE, self.dpu_underrun_count);
            }
        }
    };
    pub const DpuUnderrunDetailReader = struct {
        buf: gremlin.Reader,
        _name: ?[]const u8 = null,
        _dpu_underrun_count: u32 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidDisplayMetrics.DpuUnderrunDetailReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidDisplayMetrics.DpuUnderrunDetailReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidDisplayMetrics.DpuUnderrunDetailWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    AndroidDisplayMetrics.DpuUnderrunDetailWire.DPU_UNDERRUN_COUNT_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._dpu_underrun_count = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getName(self: *const AndroidDisplayMetrics.DpuUnderrunDetailReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub inline fn getDpuUnderrunCount(self: *const AndroidDisplayMetrics.DpuUnderrunDetailReader) u32 {
            return self._dpu_underrun_count;
        }
    };
    const DpuStateWire = struct {
        const TOTAL_DPU_UNDERRUN_COUNT_WIRE: gremlin.ProtoWireNumber = 1;
        const DPU_UNDERRUN_DETAIL_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const DpuState = struct {
        // fields
        total_dpu_underrun_count: u32 = 0,
        dpu_underrun_detail: ?[]const ?AndroidDisplayMetrics.DpuUnderrunDetail = null,
        pub fn calcProtobufSize(self: *const AndroidDisplayMetrics.DpuState) usize {
            var res: usize = 0;
            if (self.total_dpu_underrun_count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidDisplayMetrics.DpuStateWire.TOTAL_DPU_UNDERRUN_COUNT_WIRE) + gremlin.sizes.sizeU32(self.total_dpu_underrun_count);
            }
            if (self.dpu_underrun_detail) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidDisplayMetrics.DpuStateWire.DPU_UNDERRUN_DETAIL_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidDisplayMetrics.DpuState, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidDisplayMetrics.DpuState, target: *gremlin.Writer) void {
            if (self.total_dpu_underrun_count != 0) {
                target.appendUint32(AndroidDisplayMetrics.DpuStateWire.TOTAL_DPU_UNDERRUN_COUNT_WIRE, self.total_dpu_underrun_count);
            }
            if (self.dpu_underrun_detail) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidDisplayMetrics.DpuStateWire.DPU_UNDERRUN_DETAIL_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidDisplayMetrics.DpuStateWire.DPU_UNDERRUN_DETAIL_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const DpuStateReader = struct {
        buf: gremlin.Reader,
        _total_dpu_underrun_count: u32 = 0,
        _dpu_underrun_detail_offset: ?usize = null,
        _dpu_underrun_detail_last_offset: ?usize = null,
        _dpu_underrun_detail_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidDisplayMetrics.DpuStateReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidDisplayMetrics.DpuStateReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidDisplayMetrics.DpuStateWire.TOTAL_DPU_UNDERRUN_COUNT_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._total_dpu_underrun_count = result.value;
                    },
                    AndroidDisplayMetrics.DpuStateWire.DPU_UNDERRUN_DETAIL_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._dpu_underrun_detail_offset == null) {
                            res._dpu_underrun_detail_offset = offset - result.size;
                        }
                        res._dpu_underrun_detail_last_offset = offset;
                        res._dpu_underrun_detail_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getTotalDpuUnderrunCount(self: *const AndroidDisplayMetrics.DpuStateReader) u32 {
            return self._total_dpu_underrun_count;
        }
        pub fn dpuUnderrunDetailCount(self: *const AndroidDisplayMetrics.DpuStateReader) usize {
            return self._dpu_underrun_detail_cnt;
        }
        pub fn dpuUnderrunDetailNext(self: *AndroidDisplayMetrics.DpuStateReader) ?AndroidDisplayMetrics.DpuUnderrunDetailReader {
            if (self._dpu_underrun_detail_offset == null) return null;
            const current_offset = self._dpu_underrun_detail_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidDisplayMetrics.DpuUnderrunDetailReader.init(result.value) catch return null;
            if (self._dpu_underrun_detail_last_offset != null and current_offset >= self._dpu_underrun_detail_last_offset.?) {
                self._dpu_underrun_detail_offset = null;
                return msg;
            }
            if (self._dpu_underrun_detail_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._dpu_underrun_detail_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidDisplayMetrics.DpuStateWire.DPU_UNDERRUN_DETAIL_WIRE) {
                    self._dpu_underrun_detail_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._dpu_underrun_detail_offset = null;
            return msg;
        }
    };
    // fields
    total_duplicate_frames: u32 = 0,
    duplicate_frames_logged: u32 = 0,
    total_dpu_underrun_count: u32 = 0,
    refresh_rate_switches: u32 = 0,
    refresh_rate_stats: ?[]const ?AndroidDisplayMetrics.RefreshRateStat = null,
    update_power_state: ?AndroidDisplayMetrics.UpdatePowerState = null,
    dpu_state: ?AndroidDisplayMetrics.DpuState = null,
    pub fn calcProtobufSize(self: *const AndroidDisplayMetrics) usize {
        var res: usize = 0;
        if (self.total_duplicate_frames != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidDisplayMetricsWire.TOTAL_DUPLICATE_FRAMES_WIRE) + gremlin.sizes.sizeU32(self.total_duplicate_frames);
        }
        if (self.duplicate_frames_logged != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidDisplayMetricsWire.DUPLICATE_FRAMES_LOGGED_WIRE) + gremlin.sizes.sizeU32(self.duplicate_frames_logged);
        }
        if (self.total_dpu_underrun_count != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidDisplayMetricsWire.TOTAL_DPU_UNDERRUN_COUNT_WIRE) + gremlin.sizes.sizeU32(self.total_dpu_underrun_count);
        }
        if (self.refresh_rate_switches != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidDisplayMetricsWire.REFRESH_RATE_SWITCHES_WIRE) + gremlin.sizes.sizeU32(self.refresh_rate_switches);
        }
        if (self.refresh_rate_stats) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidDisplayMetricsWire.REFRESH_RATE_STATS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.update_power_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidDisplayMetricsWire.UPDATE_POWER_STATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.dpu_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidDisplayMetricsWire.DPU_STATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidDisplayMetrics, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidDisplayMetrics, target: *gremlin.Writer) void {
        if (self.total_duplicate_frames != 0) {
            target.appendUint32(AndroidDisplayMetricsWire.TOTAL_DUPLICATE_FRAMES_WIRE, self.total_duplicate_frames);
        }
        if (self.duplicate_frames_logged != 0) {
            target.appendUint32(AndroidDisplayMetricsWire.DUPLICATE_FRAMES_LOGGED_WIRE, self.duplicate_frames_logged);
        }
        if (self.total_dpu_underrun_count != 0) {
            target.appendUint32(AndroidDisplayMetricsWire.TOTAL_DPU_UNDERRUN_COUNT_WIRE, self.total_dpu_underrun_count);
        }
        if (self.refresh_rate_switches != 0) {
            target.appendUint32(AndroidDisplayMetricsWire.REFRESH_RATE_SWITCHES_WIRE, self.refresh_rate_switches);
        }
        if (self.refresh_rate_stats) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidDisplayMetricsWire.REFRESH_RATE_STATS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidDisplayMetricsWire.REFRESH_RATE_STATS_WIRE, 0);
                }
            }
        }
        if (self.update_power_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidDisplayMetricsWire.UPDATE_POWER_STATE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.dpu_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidDisplayMetricsWire.DPU_STATE_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const AndroidDisplayMetricsReader = struct {
    buf: gremlin.Reader,
    _total_duplicate_frames: u32 = 0,
    _duplicate_frames_logged: u32 = 0,
    _total_dpu_underrun_count: u32 = 0,
    _refresh_rate_switches: u32 = 0,
    _refresh_rate_stats_offset: ?usize = null,
    _refresh_rate_stats_last_offset: ?usize = null,
    _refresh_rate_stats_cnt: usize = 0,
    _update_power_state_buf: ?[]const u8 = null,
    _dpu_state_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!AndroidDisplayMetricsReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidDisplayMetricsReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidDisplayMetricsWire.TOTAL_DUPLICATE_FRAMES_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._total_duplicate_frames = result.value;
                },
                AndroidDisplayMetricsWire.DUPLICATE_FRAMES_LOGGED_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._duplicate_frames_logged = result.value;
                },
                AndroidDisplayMetricsWire.TOTAL_DPU_UNDERRUN_COUNT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._total_dpu_underrun_count = result.value;
                },
                AndroidDisplayMetricsWire.REFRESH_RATE_SWITCHES_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._refresh_rate_switches = result.value;
                },
                AndroidDisplayMetricsWire.REFRESH_RATE_STATS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._refresh_rate_stats_offset == null) {
                        res._refresh_rate_stats_offset = offset - result.size;
                    }
                    res._refresh_rate_stats_last_offset = offset;
                    res._refresh_rate_stats_cnt += 1;
                },
                AndroidDisplayMetricsWire.UPDATE_POWER_STATE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._update_power_state_buf = result.value;
                },
                AndroidDisplayMetricsWire.DPU_STATE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dpu_state_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getTotalDuplicateFrames(self: *const AndroidDisplayMetricsReader) u32 {
        return self._total_duplicate_frames;
    }
    pub inline fn getDuplicateFramesLogged(self: *const AndroidDisplayMetricsReader) u32 {
        return self._duplicate_frames_logged;
    }
    pub inline fn getTotalDpuUnderrunCount(self: *const AndroidDisplayMetricsReader) u32 {
        return self._total_dpu_underrun_count;
    }
    pub inline fn getRefreshRateSwitches(self: *const AndroidDisplayMetricsReader) u32 {
        return self._refresh_rate_switches;
    }
    pub fn refreshRateStatsCount(self: *const AndroidDisplayMetricsReader) usize {
        return self._refresh_rate_stats_cnt;
    }
    pub fn refreshRateStatsNext(self: *AndroidDisplayMetricsReader) ?AndroidDisplayMetrics.RefreshRateStatReader {
        if (self._refresh_rate_stats_offset == null) return null;
        const current_offset = self._refresh_rate_stats_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidDisplayMetrics.RefreshRateStatReader.init(result.value) catch return null;
        if (self._refresh_rate_stats_last_offset != null and current_offset >= self._refresh_rate_stats_last_offset.?) {
            self._refresh_rate_stats_offset = null;
            return msg;
        }
        if (self._refresh_rate_stats_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._refresh_rate_stats_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidDisplayMetricsWire.REFRESH_RATE_STATS_WIRE) {
                self._refresh_rate_stats_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._refresh_rate_stats_offset = null;
        return msg;
    }
    pub fn getUpdatePowerState(self: *const AndroidDisplayMetricsReader) gremlin.Error!AndroidDisplayMetrics.UpdatePowerStateReader {
        if (self._update_power_state_buf) |buf| {
            return try AndroidDisplayMetrics.UpdatePowerStateReader.init(buf);
        }
        return try AndroidDisplayMetrics.UpdatePowerStateReader.init(&[_]u8{});
    }
    pub fn getDpuState(self: *const AndroidDisplayMetricsReader) gremlin.Error!AndroidDisplayMetrics.DpuStateReader {
        if (self._dpu_state_buf) |buf| {
            return try AndroidDisplayMetrics.DpuStateReader.init(buf);
        }
        return try AndroidDisplayMetrics.DpuStateReader.init(&[_]u8{});
    }
};
const AndroidDmaHeapMetricWire = struct {
    const AVG_SIZE_BYTES_WIRE: gremlin.ProtoWireNumber = 1;
    const MIN_SIZE_BYTES_WIRE: gremlin.ProtoWireNumber = 2;
    const MAX_SIZE_BYTES_WIRE: gremlin.ProtoWireNumber = 3;
    const TOTAL_ALLOC_SIZE_BYTES_WIRE: gremlin.ProtoWireNumber = 4;
    const TOTAL_DELTA_BYTES_WIRE: gremlin.ProtoWireNumber = 5;
    const PROCESS_STATS_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const AndroidDmaHeapMetric = struct {
    // nested structs
    const ProcessStatsWire = struct {
        const PROCESS_NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const DELTA_BYTES_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const ProcessStats = struct {
        // fields
        process_name: ?[]const u8 = null,
        delta_bytes: i32 = 0,
        pub fn calcProtobufSize(self: *const AndroidDmaHeapMetric.ProcessStats) usize {
            var res: usize = 0;
            if (self.process_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidDmaHeapMetric.ProcessStatsWire.PROCESS_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.delta_bytes != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidDmaHeapMetric.ProcessStatsWire.DELTA_BYTES_WIRE) + gremlin.sizes.sizeI32(self.delta_bytes);
            }
            return res;
        }
        pub fn encode(self: *const AndroidDmaHeapMetric.ProcessStats, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidDmaHeapMetric.ProcessStats, target: *gremlin.Writer) void {
            if (self.process_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidDmaHeapMetric.ProcessStatsWire.PROCESS_NAME_WIRE, v);
                }
            }
            if (self.delta_bytes != 0) {
                target.appendInt32(AndroidDmaHeapMetric.ProcessStatsWire.DELTA_BYTES_WIRE, self.delta_bytes);
            }
        }
    };
    pub const ProcessStatsReader = struct {
        buf: gremlin.Reader,
        _process_name: ?[]const u8 = null,
        _delta_bytes: i32 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidDmaHeapMetric.ProcessStatsReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidDmaHeapMetric.ProcessStatsReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidDmaHeapMetric.ProcessStatsWire.PROCESS_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._process_name = result.value;
                    },
                    AndroidDmaHeapMetric.ProcessStatsWire.DELTA_BYTES_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._delta_bytes = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getProcessName(self: *const AndroidDmaHeapMetric.ProcessStatsReader) []const u8 {
            return self._process_name orelse &[_]u8{};
        }
        pub inline fn getDeltaBytes(self: *const AndroidDmaHeapMetric.ProcessStatsReader) i32 {
            return self._delta_bytes;
        }
    };
    // fields
    avg_size_bytes: f64 = 0.0,
    min_size_bytes: f64 = 0.0,
    max_size_bytes: f64 = 0.0,
    total_alloc_size_bytes: f64 = 0.0,
    total_delta_bytes: i32 = 0,
    process_stats: ?[]const ?AndroidDmaHeapMetric.ProcessStats = null,
    pub fn calcProtobufSize(self: *const AndroidDmaHeapMetric) usize {
        var res: usize = 0;
        if (self.avg_size_bytes != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidDmaHeapMetricWire.AVG_SIZE_BYTES_WIRE) + gremlin.sizes.sizeDouble(self.avg_size_bytes);
        }
        if (self.min_size_bytes != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidDmaHeapMetricWire.MIN_SIZE_BYTES_WIRE) + gremlin.sizes.sizeDouble(self.min_size_bytes);
        }
        if (self.max_size_bytes != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidDmaHeapMetricWire.MAX_SIZE_BYTES_WIRE) + gremlin.sizes.sizeDouble(self.max_size_bytes);
        }
        if (self.total_alloc_size_bytes != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidDmaHeapMetricWire.TOTAL_ALLOC_SIZE_BYTES_WIRE) + gremlin.sizes.sizeDouble(self.total_alloc_size_bytes);
        }
        if (self.total_delta_bytes != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidDmaHeapMetricWire.TOTAL_DELTA_BYTES_WIRE) + gremlin.sizes.sizeI32(self.total_delta_bytes);
        }
        if (self.process_stats) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidDmaHeapMetricWire.PROCESS_STATS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidDmaHeapMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidDmaHeapMetric, target: *gremlin.Writer) void {
        if (self.avg_size_bytes != 0.0) {
            target.appendFloat64(AndroidDmaHeapMetricWire.AVG_SIZE_BYTES_WIRE, self.avg_size_bytes);
        }
        if (self.min_size_bytes != 0.0) {
            target.appendFloat64(AndroidDmaHeapMetricWire.MIN_SIZE_BYTES_WIRE, self.min_size_bytes);
        }
        if (self.max_size_bytes != 0.0) {
            target.appendFloat64(AndroidDmaHeapMetricWire.MAX_SIZE_BYTES_WIRE, self.max_size_bytes);
        }
        if (self.total_alloc_size_bytes != 0.0) {
            target.appendFloat64(AndroidDmaHeapMetricWire.TOTAL_ALLOC_SIZE_BYTES_WIRE, self.total_alloc_size_bytes);
        }
        if (self.total_delta_bytes != 0) {
            target.appendInt32(AndroidDmaHeapMetricWire.TOTAL_DELTA_BYTES_WIRE, self.total_delta_bytes);
        }
        if (self.process_stats) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidDmaHeapMetricWire.PROCESS_STATS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidDmaHeapMetricWire.PROCESS_STATS_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidDmaHeapMetricReader = struct {
    buf: gremlin.Reader,
    _avg_size_bytes: f64 = 0.0,
    _min_size_bytes: f64 = 0.0,
    _max_size_bytes: f64 = 0.0,
    _total_alloc_size_bytes: f64 = 0.0,
    _total_delta_bytes: i32 = 0,
    _process_stats_offset: ?usize = null,
    _process_stats_last_offset: ?usize = null,
    _process_stats_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidDmaHeapMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidDmaHeapMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidDmaHeapMetricWire.AVG_SIZE_BYTES_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._avg_size_bytes = result.value;
                },
                AndroidDmaHeapMetricWire.MIN_SIZE_BYTES_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._min_size_bytes = result.value;
                },
                AndroidDmaHeapMetricWire.MAX_SIZE_BYTES_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._max_size_bytes = result.value;
                },
                AndroidDmaHeapMetricWire.TOTAL_ALLOC_SIZE_BYTES_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._total_alloc_size_bytes = result.value;
                },
                AndroidDmaHeapMetricWire.TOTAL_DELTA_BYTES_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._total_delta_bytes = result.value;
                },
                AndroidDmaHeapMetricWire.PROCESS_STATS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._process_stats_offset == null) {
                        res._process_stats_offset = offset - result.size;
                    }
                    res._process_stats_last_offset = offset;
                    res._process_stats_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getAvgSizeBytes(self: *const AndroidDmaHeapMetricReader) f64 {
        return self._avg_size_bytes;
    }
    pub inline fn getMinSizeBytes(self: *const AndroidDmaHeapMetricReader) f64 {
        return self._min_size_bytes;
    }
    pub inline fn getMaxSizeBytes(self: *const AndroidDmaHeapMetricReader) f64 {
        return self._max_size_bytes;
    }
    pub inline fn getTotalAllocSizeBytes(self: *const AndroidDmaHeapMetricReader) f64 {
        return self._total_alloc_size_bytes;
    }
    pub inline fn getTotalDeltaBytes(self: *const AndroidDmaHeapMetricReader) i32 {
        return self._total_delta_bytes;
    }
    pub fn processStatsCount(self: *const AndroidDmaHeapMetricReader) usize {
        return self._process_stats_cnt;
    }
    pub fn processStatsNext(self: *AndroidDmaHeapMetricReader) ?AndroidDmaHeapMetric.ProcessStatsReader {
        if (self._process_stats_offset == null) return null;
        const current_offset = self._process_stats_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidDmaHeapMetric.ProcessStatsReader.init(result.value) catch return null;
        if (self._process_stats_last_offset != null and current_offset >= self._process_stats_last_offset.?) {
            self._process_stats_offset = null;
            return msg;
        }
        if (self._process_stats_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._process_stats_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidDmaHeapMetricWire.PROCESS_STATS_WIRE) {
                self._process_stats_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._process_stats_offset = null;
        return msg;
    }
};
const AndroidDvfsMetricWire = struct {
    const FREQ_RESIDENCIES_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const AndroidDvfsMetric = struct {
    // nested structs
    const BandStatWire = struct {
        const FREQ_VALUE_WIRE: gremlin.ProtoWireNumber = 1;
        const PERCENTAGE_WIRE: gremlin.ProtoWireNumber = 2;
        const DURATION_NS_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const BandStat = struct {
        // fields
        freq_value: i32 = 0,
        percentage: f64 = 0.0,
        duration_ns: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidDvfsMetric.BandStat) usize {
            var res: usize = 0;
            if (self.freq_value != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidDvfsMetric.BandStatWire.FREQ_VALUE_WIRE) + gremlin.sizes.sizeI32(self.freq_value);
            }
            if (self.percentage != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidDvfsMetric.BandStatWire.PERCENTAGE_WIRE) + gremlin.sizes.sizeDouble(self.percentage);
            }
            if (self.duration_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidDvfsMetric.BandStatWire.DURATION_NS_WIRE) + gremlin.sizes.sizeI64(self.duration_ns);
            }
            return res;
        }
        pub fn encode(self: *const AndroidDvfsMetric.BandStat, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidDvfsMetric.BandStat, target: *gremlin.Writer) void {
            if (self.freq_value != 0) {
                target.appendInt32(AndroidDvfsMetric.BandStatWire.FREQ_VALUE_WIRE, self.freq_value);
            }
            if (self.percentage != 0.0) {
                target.appendFloat64(AndroidDvfsMetric.BandStatWire.PERCENTAGE_WIRE, self.percentage);
            }
            if (self.duration_ns != 0) {
                target.appendInt64(AndroidDvfsMetric.BandStatWire.DURATION_NS_WIRE, self.duration_ns);
            }
        }
    };
    pub const BandStatReader = struct {
        buf: gremlin.Reader,
        _freq_value: i32 = 0,
        _percentage: f64 = 0.0,
        _duration_ns: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidDvfsMetric.BandStatReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidDvfsMetric.BandStatReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidDvfsMetric.BandStatWire.FREQ_VALUE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._freq_value = result.value;
                    },
                    AndroidDvfsMetric.BandStatWire.PERCENTAGE_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._percentage = result.value;
                    },
                    AndroidDvfsMetric.BandStatWire.DURATION_NS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._duration_ns = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getFreqValue(self: *const AndroidDvfsMetric.BandStatReader) i32 {
            return self._freq_value;
        }
        pub inline fn getPercentage(self: *const AndroidDvfsMetric.BandStatReader) f64 {
            return self._percentage;
        }
        pub inline fn getDurationNs(self: *const AndroidDvfsMetric.BandStatReader) i64 {
            return self._duration_ns;
        }
    };
    const FrequencyResidencyWire = struct {
        const FREQ_NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const BAND_STAT_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const FrequencyResidency = struct {
        // fields
        freq_name: ?[]const u8 = null,
        band_stat: ?[]const ?AndroidDvfsMetric.BandStat = null,
        pub fn calcProtobufSize(self: *const AndroidDvfsMetric.FrequencyResidency) usize {
            var res: usize = 0;
            if (self.freq_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidDvfsMetric.FrequencyResidencyWire.FREQ_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.band_stat) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidDvfsMetric.FrequencyResidencyWire.BAND_STAT_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidDvfsMetric.FrequencyResidency, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidDvfsMetric.FrequencyResidency, target: *gremlin.Writer) void {
            if (self.freq_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidDvfsMetric.FrequencyResidencyWire.FREQ_NAME_WIRE, v);
                }
            }
            if (self.band_stat) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidDvfsMetric.FrequencyResidencyWire.BAND_STAT_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidDvfsMetric.FrequencyResidencyWire.BAND_STAT_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const FrequencyResidencyReader = struct {
        buf: gremlin.Reader,
        _freq_name: ?[]const u8 = null,
        _band_stat_offset: ?usize = null,
        _band_stat_last_offset: ?usize = null,
        _band_stat_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidDvfsMetric.FrequencyResidencyReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidDvfsMetric.FrequencyResidencyReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidDvfsMetric.FrequencyResidencyWire.FREQ_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._freq_name = result.value;
                    },
                    AndroidDvfsMetric.FrequencyResidencyWire.BAND_STAT_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._band_stat_offset == null) {
                            res._band_stat_offset = offset - result.size;
                        }
                        res._band_stat_last_offset = offset;
                        res._band_stat_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getFreqName(self: *const AndroidDvfsMetric.FrequencyResidencyReader) []const u8 {
            return self._freq_name orelse &[_]u8{};
        }
        pub fn bandStatCount(self: *const AndroidDvfsMetric.FrequencyResidencyReader) usize {
            return self._band_stat_cnt;
        }
        pub fn bandStatNext(self: *AndroidDvfsMetric.FrequencyResidencyReader) ?AndroidDvfsMetric.BandStatReader {
            if (self._band_stat_offset == null) return null;
            const current_offset = self._band_stat_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidDvfsMetric.BandStatReader.init(result.value) catch return null;
            if (self._band_stat_last_offset != null and current_offset >= self._band_stat_last_offset.?) {
                self._band_stat_offset = null;
                return msg;
            }
            if (self._band_stat_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._band_stat_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidDvfsMetric.FrequencyResidencyWire.BAND_STAT_WIRE) {
                    self._band_stat_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._band_stat_offset = null;
            return msg;
        }
    };
    // fields
    freq_residencies: ?[]const ?AndroidDvfsMetric.FrequencyResidency = null,
    pub fn calcProtobufSize(self: *const AndroidDvfsMetric) usize {
        var res: usize = 0;
        if (self.freq_residencies) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidDvfsMetricWire.FREQ_RESIDENCIES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidDvfsMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidDvfsMetric, target: *gremlin.Writer) void {
        if (self.freq_residencies) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidDvfsMetricWire.FREQ_RESIDENCIES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidDvfsMetricWire.FREQ_RESIDENCIES_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidDvfsMetricReader = struct {
    buf: gremlin.Reader,
    _freq_residencies_offset: ?usize = null,
    _freq_residencies_last_offset: ?usize = null,
    _freq_residencies_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidDvfsMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidDvfsMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidDvfsMetricWire.FREQ_RESIDENCIES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._freq_residencies_offset == null) {
                        res._freq_residencies_offset = offset - result.size;
                    }
                    res._freq_residencies_last_offset = offset;
                    res._freq_residencies_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn freqResidenciesCount(self: *const AndroidDvfsMetricReader) usize {
        return self._freq_residencies_cnt;
    }
    pub fn freqResidenciesNext(self: *AndroidDvfsMetricReader) ?AndroidDvfsMetric.FrequencyResidencyReader {
        if (self._freq_residencies_offset == null) return null;
        const current_offset = self._freq_residencies_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidDvfsMetric.FrequencyResidencyReader.init(result.value) catch return null;
        if (self._freq_residencies_last_offset != null and current_offset >= self._freq_residencies_last_offset.?) {
            self._freq_residencies_offset = null;
            return msg;
        }
        if (self._freq_residencies_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._freq_residencies_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidDvfsMetricWire.FREQ_RESIDENCIES_WIRE) {
                self._freq_residencies_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._freq_residencies_offset = null;
        return msg;
    }
};
const AndroidFastrpcMetricWire = struct {
    const SUBSYSTEM_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const AndroidFastrpcMetric = struct {
    // nested structs
    const SubsystemWire = struct {
        const NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const AVG_SIZE_BYTES_WIRE: gremlin.ProtoWireNumber = 2;
        const MIN_SIZE_BYTES_WIRE: gremlin.ProtoWireNumber = 3;
        const MAX_SIZE_BYTES_WIRE: gremlin.ProtoWireNumber = 4;
        const TOTAL_ALLOC_SIZE_BYTES_WIRE: gremlin.ProtoWireNumber = 5;
    };
    pub const Subsystem = struct {
        // fields
        name: ?[]const u8 = null,
        avg_size_bytes: f64 = 0.0,
        min_size_bytes: f64 = 0.0,
        max_size_bytes: f64 = 0.0,
        total_alloc_size_bytes: f64 = 0.0,
        pub fn calcProtobufSize(self: *const AndroidFastrpcMetric.Subsystem) usize {
            var res: usize = 0;
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidFastrpcMetric.SubsystemWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.avg_size_bytes != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidFastrpcMetric.SubsystemWire.AVG_SIZE_BYTES_WIRE) + gremlin.sizes.sizeDouble(self.avg_size_bytes);
            }
            if (self.min_size_bytes != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidFastrpcMetric.SubsystemWire.MIN_SIZE_BYTES_WIRE) + gremlin.sizes.sizeDouble(self.min_size_bytes);
            }
            if (self.max_size_bytes != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidFastrpcMetric.SubsystemWire.MAX_SIZE_BYTES_WIRE) + gremlin.sizes.sizeDouble(self.max_size_bytes);
            }
            if (self.total_alloc_size_bytes != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidFastrpcMetric.SubsystemWire.TOTAL_ALLOC_SIZE_BYTES_WIRE) + gremlin.sizes.sizeDouble(self.total_alloc_size_bytes);
            }
            return res;
        }
        pub fn encode(self: *const AndroidFastrpcMetric.Subsystem, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidFastrpcMetric.Subsystem, target: *gremlin.Writer) void {
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidFastrpcMetric.SubsystemWire.NAME_WIRE, v);
                }
            }
            if (self.avg_size_bytes != 0.0) {
                target.appendFloat64(AndroidFastrpcMetric.SubsystemWire.AVG_SIZE_BYTES_WIRE, self.avg_size_bytes);
            }
            if (self.min_size_bytes != 0.0) {
                target.appendFloat64(AndroidFastrpcMetric.SubsystemWire.MIN_SIZE_BYTES_WIRE, self.min_size_bytes);
            }
            if (self.max_size_bytes != 0.0) {
                target.appendFloat64(AndroidFastrpcMetric.SubsystemWire.MAX_SIZE_BYTES_WIRE, self.max_size_bytes);
            }
            if (self.total_alloc_size_bytes != 0.0) {
                target.appendFloat64(AndroidFastrpcMetric.SubsystemWire.TOTAL_ALLOC_SIZE_BYTES_WIRE, self.total_alloc_size_bytes);
            }
        }
    };
    pub const SubsystemReader = struct {
        buf: gremlin.Reader,
        _name: ?[]const u8 = null,
        _avg_size_bytes: f64 = 0.0,
        _min_size_bytes: f64 = 0.0,
        _max_size_bytes: f64 = 0.0,
        _total_alloc_size_bytes: f64 = 0.0,
        pub fn init(src: []const u8) gremlin.Error!AndroidFastrpcMetric.SubsystemReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidFastrpcMetric.SubsystemReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidFastrpcMetric.SubsystemWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    AndroidFastrpcMetric.SubsystemWire.AVG_SIZE_BYTES_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._avg_size_bytes = result.value;
                    },
                    AndroidFastrpcMetric.SubsystemWire.MIN_SIZE_BYTES_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._min_size_bytes = result.value;
                    },
                    AndroidFastrpcMetric.SubsystemWire.MAX_SIZE_BYTES_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._max_size_bytes = result.value;
                    },
                    AndroidFastrpcMetric.SubsystemWire.TOTAL_ALLOC_SIZE_BYTES_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._total_alloc_size_bytes = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getName(self: *const AndroidFastrpcMetric.SubsystemReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub inline fn getAvgSizeBytes(self: *const AndroidFastrpcMetric.SubsystemReader) f64 {
            return self._avg_size_bytes;
        }
        pub inline fn getMinSizeBytes(self: *const AndroidFastrpcMetric.SubsystemReader) f64 {
            return self._min_size_bytes;
        }
        pub inline fn getMaxSizeBytes(self: *const AndroidFastrpcMetric.SubsystemReader) f64 {
            return self._max_size_bytes;
        }
        pub inline fn getTotalAllocSizeBytes(self: *const AndroidFastrpcMetric.SubsystemReader) f64 {
            return self._total_alloc_size_bytes;
        }
    };
    // fields
    subsystem: ?[]const ?AndroidFastrpcMetric.Subsystem = null,
    pub fn calcProtobufSize(self: *const AndroidFastrpcMetric) usize {
        var res: usize = 0;
        if (self.subsystem) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidFastrpcMetricWire.SUBSYSTEM_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidFastrpcMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidFastrpcMetric, target: *gremlin.Writer) void {
        if (self.subsystem) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidFastrpcMetricWire.SUBSYSTEM_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidFastrpcMetricWire.SUBSYSTEM_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidFastrpcMetricReader = struct {
    buf: gremlin.Reader,
    _subsystem_offset: ?usize = null,
    _subsystem_last_offset: ?usize = null,
    _subsystem_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidFastrpcMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidFastrpcMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidFastrpcMetricWire.SUBSYSTEM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._subsystem_offset == null) {
                        res._subsystem_offset = offset - result.size;
                    }
                    res._subsystem_last_offset = offset;
                    res._subsystem_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn subsystemCount(self: *const AndroidFastrpcMetricReader) usize {
        return self._subsystem_cnt;
    }
    pub fn subsystemNext(self: *AndroidFastrpcMetricReader) ?AndroidFastrpcMetric.SubsystemReader {
        if (self._subsystem_offset == null) return null;
        const current_offset = self._subsystem_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidFastrpcMetric.SubsystemReader.init(result.value) catch return null;
        if (self._subsystem_last_offset != null and current_offset >= self._subsystem_last_offset.?) {
            self._subsystem_offset = null;
            return msg;
        }
        if (self._subsystem_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._subsystem_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidFastrpcMetricWire.SUBSYSTEM_WIRE) {
                self._subsystem_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._subsystem_offset = null;
        return msg;
    }
};
const G2dMetricsWire = struct {
    const G2D_HW_WIRE: gremlin.ProtoWireNumber = 1;
    const G2D_SW_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const G2dMetrics = struct {
    // nested structs
    const G2dInstanceWire = struct {
        const NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const FRAME_COUNT_WIRE: gremlin.ProtoWireNumber = 5;
        const ERROR_COUNT_WIRE: gremlin.ProtoWireNumber = 6;
        const MAX_DUR_MS_WIRE: gremlin.ProtoWireNumber = 7;
        const MIN_DUR_MS_WIRE: gremlin.ProtoWireNumber = 8;
        const AVG_DUR_MS_WIRE: gremlin.ProtoWireNumber = 9;
    };
    pub const G2dInstance = struct {
        // fields
        name: ?[]const u8 = null,
        frame_count: u32 = 0,
        error_count: u32 = 0,
        max_dur_ms: f64 = 0.0,
        min_dur_ms: f64 = 0.0,
        avg_dur_ms: f64 = 0.0,
        pub fn calcProtobufSize(self: *const G2dMetrics.G2dInstance) usize {
            var res: usize = 0;
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(G2dMetrics.G2dInstanceWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.frame_count != 0) {
                res += gremlin.sizes.sizeWireNumber(G2dMetrics.G2dInstanceWire.FRAME_COUNT_WIRE) + gremlin.sizes.sizeU32(self.frame_count);
            }
            if (self.error_count != 0) {
                res += gremlin.sizes.sizeWireNumber(G2dMetrics.G2dInstanceWire.ERROR_COUNT_WIRE) + gremlin.sizes.sizeU32(self.error_count);
            }
            if (self.max_dur_ms != 0.0) {
                res += gremlin.sizes.sizeWireNumber(G2dMetrics.G2dInstanceWire.MAX_DUR_MS_WIRE) + gremlin.sizes.sizeDouble(self.max_dur_ms);
            }
            if (self.min_dur_ms != 0.0) {
                res += gremlin.sizes.sizeWireNumber(G2dMetrics.G2dInstanceWire.MIN_DUR_MS_WIRE) + gremlin.sizes.sizeDouble(self.min_dur_ms);
            }
            if (self.avg_dur_ms != 0.0) {
                res += gremlin.sizes.sizeWireNumber(G2dMetrics.G2dInstanceWire.AVG_DUR_MS_WIRE) + gremlin.sizes.sizeDouble(self.avg_dur_ms);
            }
            return res;
        }
        pub fn encode(self: *const G2dMetrics.G2dInstance, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const G2dMetrics.G2dInstance, target: *gremlin.Writer) void {
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(G2dMetrics.G2dInstanceWire.NAME_WIRE, v);
                }
            }
            if (self.frame_count != 0) {
                target.appendUint32(G2dMetrics.G2dInstanceWire.FRAME_COUNT_WIRE, self.frame_count);
            }
            if (self.error_count != 0) {
                target.appendUint32(G2dMetrics.G2dInstanceWire.ERROR_COUNT_WIRE, self.error_count);
            }
            if (self.max_dur_ms != 0.0) {
                target.appendFloat64(G2dMetrics.G2dInstanceWire.MAX_DUR_MS_WIRE, self.max_dur_ms);
            }
            if (self.min_dur_ms != 0.0) {
                target.appendFloat64(G2dMetrics.G2dInstanceWire.MIN_DUR_MS_WIRE, self.min_dur_ms);
            }
            if (self.avg_dur_ms != 0.0) {
                target.appendFloat64(G2dMetrics.G2dInstanceWire.AVG_DUR_MS_WIRE, self.avg_dur_ms);
            }
        }
    };
    pub const G2dInstanceReader = struct {
        buf: gremlin.Reader,
        _name: ?[]const u8 = null,
        _frame_count: u32 = 0,
        _error_count: u32 = 0,
        _max_dur_ms: f64 = 0.0,
        _min_dur_ms: f64 = 0.0,
        _avg_dur_ms: f64 = 0.0,
        pub fn init(src: []const u8) gremlin.Error!G2dMetrics.G2dInstanceReader {
            const buf = gremlin.Reader.init(src);
            var res = G2dMetrics.G2dInstanceReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    G2dMetrics.G2dInstanceWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    G2dMetrics.G2dInstanceWire.FRAME_COUNT_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._frame_count = result.value;
                    },
                    G2dMetrics.G2dInstanceWire.ERROR_COUNT_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._error_count = result.value;
                    },
                    G2dMetrics.G2dInstanceWire.MAX_DUR_MS_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._max_dur_ms = result.value;
                    },
                    G2dMetrics.G2dInstanceWire.MIN_DUR_MS_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._min_dur_ms = result.value;
                    },
                    G2dMetrics.G2dInstanceWire.AVG_DUR_MS_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._avg_dur_ms = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getName(self: *const G2dMetrics.G2dInstanceReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub inline fn getFrameCount(self: *const G2dMetrics.G2dInstanceReader) u32 {
            return self._frame_count;
        }
        pub inline fn getErrorCount(self: *const G2dMetrics.G2dInstanceReader) u32 {
            return self._error_count;
        }
        pub inline fn getMaxDurMs(self: *const G2dMetrics.G2dInstanceReader) f64 {
            return self._max_dur_ms;
        }
        pub inline fn getMinDurMs(self: *const G2dMetrics.G2dInstanceReader) f64 {
            return self._min_dur_ms;
        }
        pub inline fn getAvgDurMs(self: *const G2dMetrics.G2dInstanceReader) f64 {
            return self._avg_dur_ms;
        }
    };
    const G2dMetricWire = struct {
        const INSTANCES_WIRE: gremlin.ProtoWireNumber = 1;
        const FRAME_COUNT_WIRE: gremlin.ProtoWireNumber = 5;
        const ERROR_COUNT_WIRE: gremlin.ProtoWireNumber = 6;
        const MAX_DUR_MS_WIRE: gremlin.ProtoWireNumber = 7;
        const MIN_DUR_MS_WIRE: gremlin.ProtoWireNumber = 8;
        const AVG_DUR_MS_WIRE: gremlin.ProtoWireNumber = 9;
    };
    pub const G2dMetric = struct {
        // fields
        instances: ?[]const ?G2dMetrics.G2dInstance = null,
        frame_count: u32 = 0,
        error_count: u32 = 0,
        max_dur_ms: f64 = 0.0,
        min_dur_ms: f64 = 0.0,
        avg_dur_ms: f64 = 0.0,
        pub fn calcProtobufSize(self: *const G2dMetrics.G2dMetric) usize {
            var res: usize = 0;
            if (self.instances) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(G2dMetrics.G2dMetricWire.INSTANCES_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.frame_count != 0) {
                res += gremlin.sizes.sizeWireNumber(G2dMetrics.G2dMetricWire.FRAME_COUNT_WIRE) + gremlin.sizes.sizeU32(self.frame_count);
            }
            if (self.error_count != 0) {
                res += gremlin.sizes.sizeWireNumber(G2dMetrics.G2dMetricWire.ERROR_COUNT_WIRE) + gremlin.sizes.sizeU32(self.error_count);
            }
            if (self.max_dur_ms != 0.0) {
                res += gremlin.sizes.sizeWireNumber(G2dMetrics.G2dMetricWire.MAX_DUR_MS_WIRE) + gremlin.sizes.sizeDouble(self.max_dur_ms);
            }
            if (self.min_dur_ms != 0.0) {
                res += gremlin.sizes.sizeWireNumber(G2dMetrics.G2dMetricWire.MIN_DUR_MS_WIRE) + gremlin.sizes.sizeDouble(self.min_dur_ms);
            }
            if (self.avg_dur_ms != 0.0) {
                res += gremlin.sizes.sizeWireNumber(G2dMetrics.G2dMetricWire.AVG_DUR_MS_WIRE) + gremlin.sizes.sizeDouble(self.avg_dur_ms);
            }
            return res;
        }
        pub fn encode(self: *const G2dMetrics.G2dMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const G2dMetrics.G2dMetric, target: *gremlin.Writer) void {
            if (self.instances) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(G2dMetrics.G2dMetricWire.INSTANCES_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(G2dMetrics.G2dMetricWire.INSTANCES_WIRE, 0);
                    }
                }
            }
            if (self.frame_count != 0) {
                target.appendUint32(G2dMetrics.G2dMetricWire.FRAME_COUNT_WIRE, self.frame_count);
            }
            if (self.error_count != 0) {
                target.appendUint32(G2dMetrics.G2dMetricWire.ERROR_COUNT_WIRE, self.error_count);
            }
            if (self.max_dur_ms != 0.0) {
                target.appendFloat64(G2dMetrics.G2dMetricWire.MAX_DUR_MS_WIRE, self.max_dur_ms);
            }
            if (self.min_dur_ms != 0.0) {
                target.appendFloat64(G2dMetrics.G2dMetricWire.MIN_DUR_MS_WIRE, self.min_dur_ms);
            }
            if (self.avg_dur_ms != 0.0) {
                target.appendFloat64(G2dMetrics.G2dMetricWire.AVG_DUR_MS_WIRE, self.avg_dur_ms);
            }
        }
    };
    pub const G2dMetricReader = struct {
        buf: gremlin.Reader,
        _instances_offset: ?usize = null,
        _instances_last_offset: ?usize = null,
        _instances_cnt: usize = 0,
        _frame_count: u32 = 0,
        _error_count: u32 = 0,
        _max_dur_ms: f64 = 0.0,
        _min_dur_ms: f64 = 0.0,
        _avg_dur_ms: f64 = 0.0,
        pub fn init(src: []const u8) gremlin.Error!G2dMetrics.G2dMetricReader {
            const buf = gremlin.Reader.init(src);
            var res = G2dMetrics.G2dMetricReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    G2dMetrics.G2dMetricWire.INSTANCES_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._instances_offset == null) {
                            res._instances_offset = offset - result.size;
                        }
                        res._instances_last_offset = offset;
                        res._instances_cnt += 1;
                    },
                    G2dMetrics.G2dMetricWire.FRAME_COUNT_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._frame_count = result.value;
                    },
                    G2dMetrics.G2dMetricWire.ERROR_COUNT_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._error_count = result.value;
                    },
                    G2dMetrics.G2dMetricWire.MAX_DUR_MS_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._max_dur_ms = result.value;
                    },
                    G2dMetrics.G2dMetricWire.MIN_DUR_MS_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._min_dur_ms = result.value;
                    },
                    G2dMetrics.G2dMetricWire.AVG_DUR_MS_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._avg_dur_ms = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn instancesCount(self: *const G2dMetrics.G2dMetricReader) usize {
            return self._instances_cnt;
        }
        pub fn instancesNext(self: *G2dMetrics.G2dMetricReader) ?G2dMetrics.G2dInstanceReader {
            if (self._instances_offset == null) return null;
            const current_offset = self._instances_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = G2dMetrics.G2dInstanceReader.init(result.value) catch return null;
            if (self._instances_last_offset != null and current_offset >= self._instances_last_offset.?) {
                self._instances_offset = null;
                return msg;
            }
            if (self._instances_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._instances_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == G2dMetrics.G2dMetricWire.INSTANCES_WIRE) {
                    self._instances_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._instances_offset = null;
            return msg;
        }
        pub inline fn getFrameCount(self: *const G2dMetrics.G2dMetricReader) u32 {
            return self._frame_count;
        }
        pub inline fn getErrorCount(self: *const G2dMetrics.G2dMetricReader) u32 {
            return self._error_count;
        }
        pub inline fn getMaxDurMs(self: *const G2dMetrics.G2dMetricReader) f64 {
            return self._max_dur_ms;
        }
        pub inline fn getMinDurMs(self: *const G2dMetrics.G2dMetricReader) f64 {
            return self._min_dur_ms;
        }
        pub inline fn getAvgDurMs(self: *const G2dMetrics.G2dMetricReader) f64 {
            return self._avg_dur_ms;
        }
    };
    // fields
    g2d_hw: ?G2dMetrics.G2dMetric = null,
    g2d_sw: ?G2dMetrics.G2dMetric = null,
    pub fn calcProtobufSize(self: *const G2dMetrics) usize {
        var res: usize = 0;
        if (self.g2d_hw) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(G2dMetricsWire.G2D_HW_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.g2d_sw) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(G2dMetricsWire.G2D_SW_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const G2dMetrics, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const G2dMetrics, target: *gremlin.Writer) void {
        if (self.g2d_hw) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(G2dMetricsWire.G2D_HW_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.g2d_sw) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(G2dMetricsWire.G2D_SW_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const G2dMetricsReader = struct {
    buf: gremlin.Reader,
    _g2d_hw_buf: ?[]const u8 = null,
    _g2d_sw_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!G2dMetricsReader {
        const buf = gremlin.Reader.init(src);
        var res = G2dMetricsReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                G2dMetricsWire.G2D_HW_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._g2d_hw_buf = result.value;
                },
                G2dMetricsWire.G2D_SW_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._g2d_sw_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getG2dHw(self: *const G2dMetricsReader) gremlin.Error!G2dMetrics.G2dMetricReader {
        if (self._g2d_hw_buf) |buf| {
            return try G2dMetrics.G2dMetricReader.init(buf);
        }
        return try G2dMetrics.G2dMetricReader.init(&[_]u8{});
    }
    pub fn getG2dSw(self: *const G2dMetricsReader) gremlin.Error!G2dMetrics.G2dMetricReader {
        if (self._g2d_sw_buf) |buf| {
            return try G2dMetrics.G2dMetricReader.init(buf);
        }
        return try G2dMetrics.G2dMetricReader.init(&[_]u8{});
    }
};
const AndroidGpuMetricWire = struct {
    const PROCESSES_WIRE: gremlin.ProtoWireNumber = 1;
    const MEM_MAX_WIRE: gremlin.ProtoWireNumber = 2;
    const MEM_MIN_WIRE: gremlin.ProtoWireNumber = 3;
    const MEM_AVG_WIRE: gremlin.ProtoWireNumber = 4;
    const FREQ_METRICS_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const AndroidGpuMetric = struct {
    // nested structs
    const ProcessWire = struct {
        const NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const MEM_MAX_WIRE: gremlin.ProtoWireNumber = 2;
        const MEM_MIN_WIRE: gremlin.ProtoWireNumber = 3;
        const MEM_AVG_WIRE: gremlin.ProtoWireNumber = 4;
    };
    pub const Process = struct {
        // fields
        name: ?[]const u8 = null,
        mem_max: i64 = 0,
        mem_min: i64 = 0,
        mem_avg: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidGpuMetric.Process) usize {
            var res: usize = 0;
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidGpuMetric.ProcessWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.mem_max != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidGpuMetric.ProcessWire.MEM_MAX_WIRE) + gremlin.sizes.sizeI64(self.mem_max);
            }
            if (self.mem_min != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidGpuMetric.ProcessWire.MEM_MIN_WIRE) + gremlin.sizes.sizeI64(self.mem_min);
            }
            if (self.mem_avg != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidGpuMetric.ProcessWire.MEM_AVG_WIRE) + gremlin.sizes.sizeI64(self.mem_avg);
            }
            return res;
        }
        pub fn encode(self: *const AndroidGpuMetric.Process, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidGpuMetric.Process, target: *gremlin.Writer) void {
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidGpuMetric.ProcessWire.NAME_WIRE, v);
                }
            }
            if (self.mem_max != 0) {
                target.appendInt64(AndroidGpuMetric.ProcessWire.MEM_MAX_WIRE, self.mem_max);
            }
            if (self.mem_min != 0) {
                target.appendInt64(AndroidGpuMetric.ProcessWire.MEM_MIN_WIRE, self.mem_min);
            }
            if (self.mem_avg != 0) {
                target.appendInt64(AndroidGpuMetric.ProcessWire.MEM_AVG_WIRE, self.mem_avg);
            }
        }
    };
    pub const ProcessReader = struct {
        buf: gremlin.Reader,
        _name: ?[]const u8 = null,
        _mem_max: i64 = 0,
        _mem_min: i64 = 0,
        _mem_avg: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidGpuMetric.ProcessReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidGpuMetric.ProcessReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidGpuMetric.ProcessWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    AndroidGpuMetric.ProcessWire.MEM_MAX_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._mem_max = result.value;
                    },
                    AndroidGpuMetric.ProcessWire.MEM_MIN_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._mem_min = result.value;
                    },
                    AndroidGpuMetric.ProcessWire.MEM_AVG_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._mem_avg = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getName(self: *const AndroidGpuMetric.ProcessReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub inline fn getMemMax(self: *const AndroidGpuMetric.ProcessReader) i64 {
            return self._mem_max;
        }
        pub inline fn getMemMin(self: *const AndroidGpuMetric.ProcessReader) i64 {
            return self._mem_min;
        }
        pub inline fn getMemAvg(self: *const AndroidGpuMetric.ProcessReader) i64 {
            return self._mem_avg;
        }
    };
    const FrequencyMetricWire = struct {
        const GPU_ID_WIRE: gremlin.ProtoWireNumber = 1;
        const FREQ_MAX_WIRE: gremlin.ProtoWireNumber = 2;
        const FREQ_MIN_WIRE: gremlin.ProtoWireNumber = 3;
        const FREQ_AVG_WIRE: gremlin.ProtoWireNumber = 4;
        const USED_FREQS_WIRE: gremlin.ProtoWireNumber = 5;
    };
    pub const FrequencyMetric = struct {
        // nested structs
        const MetricsPerFrequencyWire = struct {
            const FREQ_WIRE: gremlin.ProtoWireNumber = 1;
            const DUR_MS_WIRE: gremlin.ProtoWireNumber = 2;
            const PERCENTAGE_WIRE: gremlin.ProtoWireNumber = 3;
        };
        pub const MetricsPerFrequency = struct {
            // fields
            freq: i64 = 0,
            dur_ms: f64 = 0.0,
            percentage: f64 = 0.0,
            pub fn calcProtobufSize(self: *const AndroidGpuMetric.FrequencyMetric.MetricsPerFrequency) usize {
                var res: usize = 0;
                if (self.freq != 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidGpuMetric.FrequencyMetric.MetricsPerFrequencyWire.FREQ_WIRE) + gremlin.sizes.sizeI64(self.freq);
                }
                if (self.dur_ms != 0.0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidGpuMetric.FrequencyMetric.MetricsPerFrequencyWire.DUR_MS_WIRE) + gremlin.sizes.sizeDouble(self.dur_ms);
                }
                if (self.percentage != 0.0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidGpuMetric.FrequencyMetric.MetricsPerFrequencyWire.PERCENTAGE_WIRE) + gremlin.sizes.sizeDouble(self.percentage);
                }
                return res;
            }
            pub fn encode(self: *const AndroidGpuMetric.FrequencyMetric.MetricsPerFrequency, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const AndroidGpuMetric.FrequencyMetric.MetricsPerFrequency, target: *gremlin.Writer) void {
                if (self.freq != 0) {
                    target.appendInt64(AndroidGpuMetric.FrequencyMetric.MetricsPerFrequencyWire.FREQ_WIRE, self.freq);
                }
                if (self.dur_ms != 0.0) {
                    target.appendFloat64(AndroidGpuMetric.FrequencyMetric.MetricsPerFrequencyWire.DUR_MS_WIRE, self.dur_ms);
                }
                if (self.percentage != 0.0) {
                    target.appendFloat64(AndroidGpuMetric.FrequencyMetric.MetricsPerFrequencyWire.PERCENTAGE_WIRE, self.percentage);
                }
            }
        };
        pub const MetricsPerFrequencyReader = struct {
            buf: gremlin.Reader,
            _freq: i64 = 0,
            _dur_ms: f64 = 0.0,
            _percentage: f64 = 0.0,
            pub fn init(src: []const u8) gremlin.Error!AndroidGpuMetric.FrequencyMetric.MetricsPerFrequencyReader {
                const buf = gremlin.Reader.init(src);
                var res = AndroidGpuMetric.FrequencyMetric.MetricsPerFrequencyReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        AndroidGpuMetric.FrequencyMetric.MetricsPerFrequencyWire.FREQ_WIRE => {
                            const result = try buf.readInt64(offset);
                            offset += result.size;
                            res._freq = result.value;
                        },
                        AndroidGpuMetric.FrequencyMetric.MetricsPerFrequencyWire.DUR_MS_WIRE => {
                            const result = try buf.readFloat64(offset);
                            offset += result.size;
                            res._dur_ms = result.value;
                        },
                        AndroidGpuMetric.FrequencyMetric.MetricsPerFrequencyWire.PERCENTAGE_WIRE => {
                            const result = try buf.readFloat64(offset);
                            offset += result.size;
                            res._percentage = result.value;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub inline fn getFreq(self: *const AndroidGpuMetric.FrequencyMetric.MetricsPerFrequencyReader) i64 {
                return self._freq;
            }
            pub inline fn getDurMs(self: *const AndroidGpuMetric.FrequencyMetric.MetricsPerFrequencyReader) f64 {
                return self._dur_ms;
            }
            pub inline fn getPercentage(self: *const AndroidGpuMetric.FrequencyMetric.MetricsPerFrequencyReader) f64 {
                return self._percentage;
            }
        };
        // fields
        gpu_id: u32 = 0,
        freq_max: i64 = 0,
        freq_min: i64 = 0,
        freq_avg: f64 = 0.0,
        used_freqs: ?[]const ?AndroidGpuMetric.FrequencyMetric.MetricsPerFrequency = null,
        pub fn calcProtobufSize(self: *const AndroidGpuMetric.FrequencyMetric) usize {
            var res: usize = 0;
            if (self.gpu_id != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidGpuMetric.FrequencyMetricWire.GPU_ID_WIRE) + gremlin.sizes.sizeU32(self.gpu_id);
            }
            if (self.freq_max != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidGpuMetric.FrequencyMetricWire.FREQ_MAX_WIRE) + gremlin.sizes.sizeI64(self.freq_max);
            }
            if (self.freq_min != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidGpuMetric.FrequencyMetricWire.FREQ_MIN_WIRE) + gremlin.sizes.sizeI64(self.freq_min);
            }
            if (self.freq_avg != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidGpuMetric.FrequencyMetricWire.FREQ_AVG_WIRE) + gremlin.sizes.sizeDouble(self.freq_avg);
            }
            if (self.used_freqs) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidGpuMetric.FrequencyMetricWire.USED_FREQS_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidGpuMetric.FrequencyMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidGpuMetric.FrequencyMetric, target: *gremlin.Writer) void {
            if (self.gpu_id != 0) {
                target.appendUint32(AndroidGpuMetric.FrequencyMetricWire.GPU_ID_WIRE, self.gpu_id);
            }
            if (self.freq_max != 0) {
                target.appendInt64(AndroidGpuMetric.FrequencyMetricWire.FREQ_MAX_WIRE, self.freq_max);
            }
            if (self.freq_min != 0) {
                target.appendInt64(AndroidGpuMetric.FrequencyMetricWire.FREQ_MIN_WIRE, self.freq_min);
            }
            if (self.freq_avg != 0.0) {
                target.appendFloat64(AndroidGpuMetric.FrequencyMetricWire.FREQ_AVG_WIRE, self.freq_avg);
            }
            if (self.used_freqs) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidGpuMetric.FrequencyMetricWire.USED_FREQS_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidGpuMetric.FrequencyMetricWire.USED_FREQS_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const FrequencyMetricReader = struct {
        buf: gremlin.Reader,
        _gpu_id: u32 = 0,
        _freq_max: i64 = 0,
        _freq_min: i64 = 0,
        _freq_avg: f64 = 0.0,
        _used_freqs_offset: ?usize = null,
        _used_freqs_last_offset: ?usize = null,
        _used_freqs_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidGpuMetric.FrequencyMetricReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidGpuMetric.FrequencyMetricReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidGpuMetric.FrequencyMetricWire.GPU_ID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._gpu_id = result.value;
                    },
                    AndroidGpuMetric.FrequencyMetricWire.FREQ_MAX_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._freq_max = result.value;
                    },
                    AndroidGpuMetric.FrequencyMetricWire.FREQ_MIN_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._freq_min = result.value;
                    },
                    AndroidGpuMetric.FrequencyMetricWire.FREQ_AVG_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._freq_avg = result.value;
                    },
                    AndroidGpuMetric.FrequencyMetricWire.USED_FREQS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._used_freqs_offset == null) {
                            res._used_freqs_offset = offset - result.size;
                        }
                        res._used_freqs_last_offset = offset;
                        res._used_freqs_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getGpuId(self: *const AndroidGpuMetric.FrequencyMetricReader) u32 {
            return self._gpu_id;
        }
        pub inline fn getFreqMax(self: *const AndroidGpuMetric.FrequencyMetricReader) i64 {
            return self._freq_max;
        }
        pub inline fn getFreqMin(self: *const AndroidGpuMetric.FrequencyMetricReader) i64 {
            return self._freq_min;
        }
        pub inline fn getFreqAvg(self: *const AndroidGpuMetric.FrequencyMetricReader) f64 {
            return self._freq_avg;
        }
        pub fn usedFreqsCount(self: *const AndroidGpuMetric.FrequencyMetricReader) usize {
            return self._used_freqs_cnt;
        }
        pub fn usedFreqsNext(self: *AndroidGpuMetric.FrequencyMetricReader) ?AndroidGpuMetric.FrequencyMetric.MetricsPerFrequencyReader {
            if (self._used_freqs_offset == null) return null;
            const current_offset = self._used_freqs_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidGpuMetric.FrequencyMetric.MetricsPerFrequencyReader.init(result.value) catch return null;
            if (self._used_freqs_last_offset != null and current_offset >= self._used_freqs_last_offset.?) {
                self._used_freqs_offset = null;
                return msg;
            }
            if (self._used_freqs_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._used_freqs_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidGpuMetric.FrequencyMetricWire.USED_FREQS_WIRE) {
                    self._used_freqs_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._used_freqs_offset = null;
            return msg;
        }
    };
    // fields
    processes: ?[]const ?AndroidGpuMetric.Process = null,
    mem_max: i64 = 0,
    mem_min: i64 = 0,
    mem_avg: i64 = 0,
    freq_metrics: ?[]const ?AndroidGpuMetric.FrequencyMetric = null,
    pub fn calcProtobufSize(self: *const AndroidGpuMetric) usize {
        var res: usize = 0;
        if (self.processes) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidGpuMetricWire.PROCESSES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.mem_max != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidGpuMetricWire.MEM_MAX_WIRE) + gremlin.sizes.sizeI64(self.mem_max);
        }
        if (self.mem_min != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidGpuMetricWire.MEM_MIN_WIRE) + gremlin.sizes.sizeI64(self.mem_min);
        }
        if (self.mem_avg != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidGpuMetricWire.MEM_AVG_WIRE) + gremlin.sizes.sizeI64(self.mem_avg);
        }
        if (self.freq_metrics) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidGpuMetricWire.FREQ_METRICS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidGpuMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidGpuMetric, target: *gremlin.Writer) void {
        if (self.processes) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidGpuMetricWire.PROCESSES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidGpuMetricWire.PROCESSES_WIRE, 0);
                }
            }
        }
        if (self.mem_max != 0) {
            target.appendInt64(AndroidGpuMetricWire.MEM_MAX_WIRE, self.mem_max);
        }
        if (self.mem_min != 0) {
            target.appendInt64(AndroidGpuMetricWire.MEM_MIN_WIRE, self.mem_min);
        }
        if (self.mem_avg != 0) {
            target.appendInt64(AndroidGpuMetricWire.MEM_AVG_WIRE, self.mem_avg);
        }
        if (self.freq_metrics) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidGpuMetricWire.FREQ_METRICS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidGpuMetricWire.FREQ_METRICS_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidGpuMetricReader = struct {
    buf: gremlin.Reader,
    _processes_offset: ?usize = null,
    _processes_last_offset: ?usize = null,
    _processes_cnt: usize = 0,
    _mem_max: i64 = 0,
    _mem_min: i64 = 0,
    _mem_avg: i64 = 0,
    _freq_metrics_offset: ?usize = null,
    _freq_metrics_last_offset: ?usize = null,
    _freq_metrics_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidGpuMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidGpuMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidGpuMetricWire.PROCESSES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._processes_offset == null) {
                        res._processes_offset = offset - result.size;
                    }
                    res._processes_last_offset = offset;
                    res._processes_cnt += 1;
                },
                AndroidGpuMetricWire.MEM_MAX_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._mem_max = result.value;
                },
                AndroidGpuMetricWire.MEM_MIN_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._mem_min = result.value;
                },
                AndroidGpuMetricWire.MEM_AVG_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._mem_avg = result.value;
                },
                AndroidGpuMetricWire.FREQ_METRICS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._freq_metrics_offset == null) {
                        res._freq_metrics_offset = offset - result.size;
                    }
                    res._freq_metrics_last_offset = offset;
                    res._freq_metrics_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn processesCount(self: *const AndroidGpuMetricReader) usize {
        return self._processes_cnt;
    }
    pub fn processesNext(self: *AndroidGpuMetricReader) ?AndroidGpuMetric.ProcessReader {
        if (self._processes_offset == null) return null;
        const current_offset = self._processes_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidGpuMetric.ProcessReader.init(result.value) catch return null;
        if (self._processes_last_offset != null and current_offset >= self._processes_last_offset.?) {
            self._processes_offset = null;
            return msg;
        }
        if (self._processes_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._processes_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidGpuMetricWire.PROCESSES_WIRE) {
                self._processes_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._processes_offset = null;
        return msg;
    }
    pub inline fn getMemMax(self: *const AndroidGpuMetricReader) i64 {
        return self._mem_max;
    }
    pub inline fn getMemMin(self: *const AndroidGpuMetricReader) i64 {
        return self._mem_min;
    }
    pub inline fn getMemAvg(self: *const AndroidGpuMetricReader) i64 {
        return self._mem_avg;
    }
    pub fn freqMetricsCount(self: *const AndroidGpuMetricReader) usize {
        return self._freq_metrics_cnt;
    }
    pub fn freqMetricsNext(self: *AndroidGpuMetricReader) ?AndroidGpuMetric.FrequencyMetricReader {
        if (self._freq_metrics_offset == null) return null;
        const current_offset = self._freq_metrics_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidGpuMetric.FrequencyMetricReader.init(result.value) catch return null;
        if (self._freq_metrics_last_offset != null and current_offset >= self._freq_metrics_last_offset.?) {
            self._freq_metrics_offset = null;
            return msg;
        }
        if (self._freq_metrics_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._freq_metrics_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidGpuMetricWire.FREQ_METRICS_WIRE) {
                self._freq_metrics_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._freq_metrics_offset = null;
        return msg;
    }
};
const AndroidHwcomposerMetricsWire = struct {
    const COMPOSITION_TOTAL_LAYERS_WIRE: gremlin.ProtoWireNumber = 1;
    const COMPOSITION_DPU_LAYERS_WIRE: gremlin.ProtoWireNumber = 2;
    const COMPOSITION_GPU_LAYERS_WIRE: gremlin.ProtoWireNumber = 3;
    const COMPOSITION_DPU_CACHED_LAYERS_WIRE: gremlin.ProtoWireNumber = 4;
    const COMPOSITION_SF_CACHED_LAYERS_WIRE: gremlin.ProtoWireNumber = 5;
    const COMPOSITION_RCD_LAYERS_WIRE: gremlin.ProtoWireNumber = 15;
    const SKIPPED_VALIDATION_COUNT_WIRE: gremlin.ProtoWireNumber = 6;
    const UNSKIPPED_VALIDATION_COUNT_WIRE: gremlin.ProtoWireNumber = 7;
    const SEPARATED_VALIDATION_COUNT_WIRE: gremlin.ProtoWireNumber = 8;
    const UNKNOWN_VALIDATION_COUNT_WIRE: gremlin.ProtoWireNumber = 9;
    const AVG_ALL_EXECUTION_TIME_MS_WIRE: gremlin.ProtoWireNumber = 10;
    const AVG_SKIPPED_EXECUTION_TIME_MS_WIRE: gremlin.ProtoWireNumber = 11;
    const AVG_UNSKIPPED_EXECUTION_TIME_MS_WIRE: gremlin.ProtoWireNumber = 12;
    const AVG_SEPARATED_EXECUTION_TIME_MS_WIRE: gremlin.ProtoWireNumber = 13;
    const DPU_VOTE_METRICS_WIRE: gremlin.ProtoWireNumber = 14;
    const METRICS_PER_DISPLAY_WIRE: gremlin.ProtoWireNumber = 16;
};
pub const AndroidHwcomposerMetrics = struct {
    // nested structs
    const DpuVoteMetricsWire = struct {
        const TID_WIRE: gremlin.ProtoWireNumber = 1;
        const AVG_DPU_VOTE_CLOCK_WIRE: gremlin.ProtoWireNumber = 2;
        const AVG_DPU_VOTE_AVG_BW_WIRE: gremlin.ProtoWireNumber = 3;
        const AVG_DPU_VOTE_PEAK_BW_WIRE: gremlin.ProtoWireNumber = 4;
        const AVG_DPU_VOTE_RT_BW_WIRE: gremlin.ProtoWireNumber = 5;
    };
    pub const DpuVoteMetrics = struct {
        // fields
        tid: u32 = 0,
        avg_dpu_vote_clock: f64 = 0.0,
        avg_dpu_vote_avg_bw: f64 = 0.0,
        avg_dpu_vote_peak_bw: f64 = 0.0,
        avg_dpu_vote_rt_bw: f64 = 0.0,
        pub fn calcProtobufSize(self: *const AndroidHwcomposerMetrics.DpuVoteMetrics) usize {
            var res: usize = 0;
            if (self.tid != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidHwcomposerMetrics.DpuVoteMetricsWire.TID_WIRE) + gremlin.sizes.sizeU32(self.tid);
            }
            if (self.avg_dpu_vote_clock != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidHwcomposerMetrics.DpuVoteMetricsWire.AVG_DPU_VOTE_CLOCK_WIRE) + gremlin.sizes.sizeDouble(self.avg_dpu_vote_clock);
            }
            if (self.avg_dpu_vote_avg_bw != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidHwcomposerMetrics.DpuVoteMetricsWire.AVG_DPU_VOTE_AVG_BW_WIRE) + gremlin.sizes.sizeDouble(self.avg_dpu_vote_avg_bw);
            }
            if (self.avg_dpu_vote_peak_bw != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidHwcomposerMetrics.DpuVoteMetricsWire.AVG_DPU_VOTE_PEAK_BW_WIRE) + gremlin.sizes.sizeDouble(self.avg_dpu_vote_peak_bw);
            }
            if (self.avg_dpu_vote_rt_bw != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidHwcomposerMetrics.DpuVoteMetricsWire.AVG_DPU_VOTE_RT_BW_WIRE) + gremlin.sizes.sizeDouble(self.avg_dpu_vote_rt_bw);
            }
            return res;
        }
        pub fn encode(self: *const AndroidHwcomposerMetrics.DpuVoteMetrics, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidHwcomposerMetrics.DpuVoteMetrics, target: *gremlin.Writer) void {
            if (self.tid != 0) {
                target.appendUint32(AndroidHwcomposerMetrics.DpuVoteMetricsWire.TID_WIRE, self.tid);
            }
            if (self.avg_dpu_vote_clock != 0.0) {
                target.appendFloat64(AndroidHwcomposerMetrics.DpuVoteMetricsWire.AVG_DPU_VOTE_CLOCK_WIRE, self.avg_dpu_vote_clock);
            }
            if (self.avg_dpu_vote_avg_bw != 0.0) {
                target.appendFloat64(AndroidHwcomposerMetrics.DpuVoteMetricsWire.AVG_DPU_VOTE_AVG_BW_WIRE, self.avg_dpu_vote_avg_bw);
            }
            if (self.avg_dpu_vote_peak_bw != 0.0) {
                target.appendFloat64(AndroidHwcomposerMetrics.DpuVoteMetricsWire.AVG_DPU_VOTE_PEAK_BW_WIRE, self.avg_dpu_vote_peak_bw);
            }
            if (self.avg_dpu_vote_rt_bw != 0.0) {
                target.appendFloat64(AndroidHwcomposerMetrics.DpuVoteMetricsWire.AVG_DPU_VOTE_RT_BW_WIRE, self.avg_dpu_vote_rt_bw);
            }
        }
    };
    pub const DpuVoteMetricsReader = struct {
        buf: gremlin.Reader,
        _tid: u32 = 0,
        _avg_dpu_vote_clock: f64 = 0.0,
        _avg_dpu_vote_avg_bw: f64 = 0.0,
        _avg_dpu_vote_peak_bw: f64 = 0.0,
        _avg_dpu_vote_rt_bw: f64 = 0.0,
        pub fn init(src: []const u8) gremlin.Error!AndroidHwcomposerMetrics.DpuVoteMetricsReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidHwcomposerMetrics.DpuVoteMetricsReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidHwcomposerMetrics.DpuVoteMetricsWire.TID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._tid = result.value;
                    },
                    AndroidHwcomposerMetrics.DpuVoteMetricsWire.AVG_DPU_VOTE_CLOCK_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._avg_dpu_vote_clock = result.value;
                    },
                    AndroidHwcomposerMetrics.DpuVoteMetricsWire.AVG_DPU_VOTE_AVG_BW_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._avg_dpu_vote_avg_bw = result.value;
                    },
                    AndroidHwcomposerMetrics.DpuVoteMetricsWire.AVG_DPU_VOTE_PEAK_BW_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._avg_dpu_vote_peak_bw = result.value;
                    },
                    AndroidHwcomposerMetrics.DpuVoteMetricsWire.AVG_DPU_VOTE_RT_BW_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._avg_dpu_vote_rt_bw = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getTid(self: *const AndroidHwcomposerMetrics.DpuVoteMetricsReader) u32 {
            return self._tid;
        }
        pub inline fn getAvgDpuVoteClock(self: *const AndroidHwcomposerMetrics.DpuVoteMetricsReader) f64 {
            return self._avg_dpu_vote_clock;
        }
        pub inline fn getAvgDpuVoteAvgBw(self: *const AndroidHwcomposerMetrics.DpuVoteMetricsReader) f64 {
            return self._avg_dpu_vote_avg_bw;
        }
        pub inline fn getAvgDpuVotePeakBw(self: *const AndroidHwcomposerMetrics.DpuVoteMetricsReader) f64 {
            return self._avg_dpu_vote_peak_bw;
        }
        pub inline fn getAvgDpuVoteRtBw(self: *const AndroidHwcomposerMetrics.DpuVoteMetricsReader) f64 {
            return self._avg_dpu_vote_rt_bw;
        }
    };
    const MetricsPerDisplayWire = struct {
        const DISPLAY_ID_WIRE: gremlin.ProtoWireNumber = 1;
        const COMPOSITION_TOTAL_LAYERS_WIRE: gremlin.ProtoWireNumber = 2;
        const COMPOSITION_DPU_LAYERS_WIRE: gremlin.ProtoWireNumber = 3;
        const COMPOSITION_GPU_LAYERS_WIRE: gremlin.ProtoWireNumber = 4;
        const COMPOSITION_DPU_CACHED_LAYERS_WIRE: gremlin.ProtoWireNumber = 5;
        const COMPOSITION_SF_CACHED_LAYERS_WIRE: gremlin.ProtoWireNumber = 6;
        const COMPOSITION_RCD_LAYERS_WIRE: gremlin.ProtoWireNumber = 7;
        const SKIPPED_VALIDATION_COUNT_WIRE: gremlin.ProtoWireNumber = 8;
        const UNSKIPPED_VALIDATION_COUNT_WIRE: gremlin.ProtoWireNumber = 9;
        const SEPARATED_VALIDATION_COUNT_WIRE: gremlin.ProtoWireNumber = 10;
        const UNKNOWN_VALIDATION_COUNT_WIRE: gremlin.ProtoWireNumber = 11;
        const AVG_ALL_EXECUTION_TIME_MS_WIRE: gremlin.ProtoWireNumber = 12;
        const AVG_SKIPPED_EXECUTION_TIME_MS_WIRE: gremlin.ProtoWireNumber = 13;
        const AVG_UNSKIPPED_EXECUTION_TIME_MS_WIRE: gremlin.ProtoWireNumber = 14;
        const AVG_SEPARATED_EXECUTION_TIME_MS_WIRE: gremlin.ProtoWireNumber = 15;
    };
    pub const MetricsPerDisplay = struct {
        // fields
        display_id: ?[]const u8 = null,
        composition_total_layers: f64 = 0.0,
        composition_dpu_layers: f64 = 0.0,
        composition_gpu_layers: f64 = 0.0,
        composition_dpu_cached_layers: f64 = 0.0,
        composition_sf_cached_layers: f64 = 0.0,
        composition_rcd_layers: f64 = 0.0,
        skipped_validation_count: i32 = 0,
        unskipped_validation_count: i32 = 0,
        separated_validation_count: i32 = 0,
        unknown_validation_count: i32 = 0,
        avg_all_execution_time_ms: f64 = 0.0,
        avg_skipped_execution_time_ms: f64 = 0.0,
        avg_unskipped_execution_time_ms: f64 = 0.0,
        avg_separated_execution_time_ms: f64 = 0.0,
        pub fn calcProtobufSize(self: *const AndroidHwcomposerMetrics.MetricsPerDisplay) usize {
            var res: usize = 0;
            if (self.display_id) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidHwcomposerMetrics.MetricsPerDisplayWire.DISPLAY_ID_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.composition_total_layers != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidHwcomposerMetrics.MetricsPerDisplayWire.COMPOSITION_TOTAL_LAYERS_WIRE) + gremlin.sizes.sizeDouble(self.composition_total_layers);
            }
            if (self.composition_dpu_layers != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidHwcomposerMetrics.MetricsPerDisplayWire.COMPOSITION_DPU_LAYERS_WIRE) + gremlin.sizes.sizeDouble(self.composition_dpu_layers);
            }
            if (self.composition_gpu_layers != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidHwcomposerMetrics.MetricsPerDisplayWire.COMPOSITION_GPU_LAYERS_WIRE) + gremlin.sizes.sizeDouble(self.composition_gpu_layers);
            }
            if (self.composition_dpu_cached_layers != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidHwcomposerMetrics.MetricsPerDisplayWire.COMPOSITION_DPU_CACHED_LAYERS_WIRE) + gremlin.sizes.sizeDouble(self.composition_dpu_cached_layers);
            }
            if (self.composition_sf_cached_layers != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidHwcomposerMetrics.MetricsPerDisplayWire.COMPOSITION_SF_CACHED_LAYERS_WIRE) + gremlin.sizes.sizeDouble(self.composition_sf_cached_layers);
            }
            if (self.composition_rcd_layers != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidHwcomposerMetrics.MetricsPerDisplayWire.COMPOSITION_RCD_LAYERS_WIRE) + gremlin.sizes.sizeDouble(self.composition_rcd_layers);
            }
            if (self.skipped_validation_count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidHwcomposerMetrics.MetricsPerDisplayWire.SKIPPED_VALIDATION_COUNT_WIRE) + gremlin.sizes.sizeI32(self.skipped_validation_count);
            }
            if (self.unskipped_validation_count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidHwcomposerMetrics.MetricsPerDisplayWire.UNSKIPPED_VALIDATION_COUNT_WIRE) + gremlin.sizes.sizeI32(self.unskipped_validation_count);
            }
            if (self.separated_validation_count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidHwcomposerMetrics.MetricsPerDisplayWire.SEPARATED_VALIDATION_COUNT_WIRE) + gremlin.sizes.sizeI32(self.separated_validation_count);
            }
            if (self.unknown_validation_count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidHwcomposerMetrics.MetricsPerDisplayWire.UNKNOWN_VALIDATION_COUNT_WIRE) + gremlin.sizes.sizeI32(self.unknown_validation_count);
            }
            if (self.avg_all_execution_time_ms != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidHwcomposerMetrics.MetricsPerDisplayWire.AVG_ALL_EXECUTION_TIME_MS_WIRE) + gremlin.sizes.sizeDouble(self.avg_all_execution_time_ms);
            }
            if (self.avg_skipped_execution_time_ms != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidHwcomposerMetrics.MetricsPerDisplayWire.AVG_SKIPPED_EXECUTION_TIME_MS_WIRE) + gremlin.sizes.sizeDouble(self.avg_skipped_execution_time_ms);
            }
            if (self.avg_unskipped_execution_time_ms != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidHwcomposerMetrics.MetricsPerDisplayWire.AVG_UNSKIPPED_EXECUTION_TIME_MS_WIRE) + gremlin.sizes.sizeDouble(self.avg_unskipped_execution_time_ms);
            }
            if (self.avg_separated_execution_time_ms != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidHwcomposerMetrics.MetricsPerDisplayWire.AVG_SEPARATED_EXECUTION_TIME_MS_WIRE) + gremlin.sizes.sizeDouble(self.avg_separated_execution_time_ms);
            }
            return res;
        }
        pub fn encode(self: *const AndroidHwcomposerMetrics.MetricsPerDisplay, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidHwcomposerMetrics.MetricsPerDisplay, target: *gremlin.Writer) void {
            if (self.display_id) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidHwcomposerMetrics.MetricsPerDisplayWire.DISPLAY_ID_WIRE, v);
                }
            }
            if (self.composition_total_layers != 0.0) {
                target.appendFloat64(AndroidHwcomposerMetrics.MetricsPerDisplayWire.COMPOSITION_TOTAL_LAYERS_WIRE, self.composition_total_layers);
            }
            if (self.composition_dpu_layers != 0.0) {
                target.appendFloat64(AndroidHwcomposerMetrics.MetricsPerDisplayWire.COMPOSITION_DPU_LAYERS_WIRE, self.composition_dpu_layers);
            }
            if (self.composition_gpu_layers != 0.0) {
                target.appendFloat64(AndroidHwcomposerMetrics.MetricsPerDisplayWire.COMPOSITION_GPU_LAYERS_WIRE, self.composition_gpu_layers);
            }
            if (self.composition_dpu_cached_layers != 0.0) {
                target.appendFloat64(AndroidHwcomposerMetrics.MetricsPerDisplayWire.COMPOSITION_DPU_CACHED_LAYERS_WIRE, self.composition_dpu_cached_layers);
            }
            if (self.composition_sf_cached_layers != 0.0) {
                target.appendFloat64(AndroidHwcomposerMetrics.MetricsPerDisplayWire.COMPOSITION_SF_CACHED_LAYERS_WIRE, self.composition_sf_cached_layers);
            }
            if (self.composition_rcd_layers != 0.0) {
                target.appendFloat64(AndroidHwcomposerMetrics.MetricsPerDisplayWire.COMPOSITION_RCD_LAYERS_WIRE, self.composition_rcd_layers);
            }
            if (self.skipped_validation_count != 0) {
                target.appendInt32(AndroidHwcomposerMetrics.MetricsPerDisplayWire.SKIPPED_VALIDATION_COUNT_WIRE, self.skipped_validation_count);
            }
            if (self.unskipped_validation_count != 0) {
                target.appendInt32(AndroidHwcomposerMetrics.MetricsPerDisplayWire.UNSKIPPED_VALIDATION_COUNT_WIRE, self.unskipped_validation_count);
            }
            if (self.separated_validation_count != 0) {
                target.appendInt32(AndroidHwcomposerMetrics.MetricsPerDisplayWire.SEPARATED_VALIDATION_COUNT_WIRE, self.separated_validation_count);
            }
            if (self.unknown_validation_count != 0) {
                target.appendInt32(AndroidHwcomposerMetrics.MetricsPerDisplayWire.UNKNOWN_VALIDATION_COUNT_WIRE, self.unknown_validation_count);
            }
            if (self.avg_all_execution_time_ms != 0.0) {
                target.appendFloat64(AndroidHwcomposerMetrics.MetricsPerDisplayWire.AVG_ALL_EXECUTION_TIME_MS_WIRE, self.avg_all_execution_time_ms);
            }
            if (self.avg_skipped_execution_time_ms != 0.0) {
                target.appendFloat64(AndroidHwcomposerMetrics.MetricsPerDisplayWire.AVG_SKIPPED_EXECUTION_TIME_MS_WIRE, self.avg_skipped_execution_time_ms);
            }
            if (self.avg_unskipped_execution_time_ms != 0.0) {
                target.appendFloat64(AndroidHwcomposerMetrics.MetricsPerDisplayWire.AVG_UNSKIPPED_EXECUTION_TIME_MS_WIRE, self.avg_unskipped_execution_time_ms);
            }
            if (self.avg_separated_execution_time_ms != 0.0) {
                target.appendFloat64(AndroidHwcomposerMetrics.MetricsPerDisplayWire.AVG_SEPARATED_EXECUTION_TIME_MS_WIRE, self.avg_separated_execution_time_ms);
            }
        }
    };
    pub const MetricsPerDisplayReader = struct {
        buf: gremlin.Reader,
        _display_id: ?[]const u8 = null,
        _composition_total_layers: f64 = 0.0,
        _composition_dpu_layers: f64 = 0.0,
        _composition_gpu_layers: f64 = 0.0,
        _composition_dpu_cached_layers: f64 = 0.0,
        _composition_sf_cached_layers: f64 = 0.0,
        _composition_rcd_layers: f64 = 0.0,
        _skipped_validation_count: i32 = 0,
        _unskipped_validation_count: i32 = 0,
        _separated_validation_count: i32 = 0,
        _unknown_validation_count: i32 = 0,
        _avg_all_execution_time_ms: f64 = 0.0,
        _avg_skipped_execution_time_ms: f64 = 0.0,
        _avg_unskipped_execution_time_ms: f64 = 0.0,
        _avg_separated_execution_time_ms: f64 = 0.0,
        pub fn init(src: []const u8) gremlin.Error!AndroidHwcomposerMetrics.MetricsPerDisplayReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidHwcomposerMetrics.MetricsPerDisplayReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidHwcomposerMetrics.MetricsPerDisplayWire.DISPLAY_ID_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._display_id = result.value;
                    },
                    AndroidHwcomposerMetrics.MetricsPerDisplayWire.COMPOSITION_TOTAL_LAYERS_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._composition_total_layers = result.value;
                    },
                    AndroidHwcomposerMetrics.MetricsPerDisplayWire.COMPOSITION_DPU_LAYERS_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._composition_dpu_layers = result.value;
                    },
                    AndroidHwcomposerMetrics.MetricsPerDisplayWire.COMPOSITION_GPU_LAYERS_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._composition_gpu_layers = result.value;
                    },
                    AndroidHwcomposerMetrics.MetricsPerDisplayWire.COMPOSITION_DPU_CACHED_LAYERS_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._composition_dpu_cached_layers = result.value;
                    },
                    AndroidHwcomposerMetrics.MetricsPerDisplayWire.COMPOSITION_SF_CACHED_LAYERS_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._composition_sf_cached_layers = result.value;
                    },
                    AndroidHwcomposerMetrics.MetricsPerDisplayWire.COMPOSITION_RCD_LAYERS_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._composition_rcd_layers = result.value;
                    },
                    AndroidHwcomposerMetrics.MetricsPerDisplayWire.SKIPPED_VALIDATION_COUNT_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._skipped_validation_count = result.value;
                    },
                    AndroidHwcomposerMetrics.MetricsPerDisplayWire.UNSKIPPED_VALIDATION_COUNT_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._unskipped_validation_count = result.value;
                    },
                    AndroidHwcomposerMetrics.MetricsPerDisplayWire.SEPARATED_VALIDATION_COUNT_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._separated_validation_count = result.value;
                    },
                    AndroidHwcomposerMetrics.MetricsPerDisplayWire.UNKNOWN_VALIDATION_COUNT_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._unknown_validation_count = result.value;
                    },
                    AndroidHwcomposerMetrics.MetricsPerDisplayWire.AVG_ALL_EXECUTION_TIME_MS_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._avg_all_execution_time_ms = result.value;
                    },
                    AndroidHwcomposerMetrics.MetricsPerDisplayWire.AVG_SKIPPED_EXECUTION_TIME_MS_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._avg_skipped_execution_time_ms = result.value;
                    },
                    AndroidHwcomposerMetrics.MetricsPerDisplayWire.AVG_UNSKIPPED_EXECUTION_TIME_MS_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._avg_unskipped_execution_time_ms = result.value;
                    },
                    AndroidHwcomposerMetrics.MetricsPerDisplayWire.AVG_SEPARATED_EXECUTION_TIME_MS_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._avg_separated_execution_time_ms = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getDisplayId(self: *const AndroidHwcomposerMetrics.MetricsPerDisplayReader) []const u8 {
            return self._display_id orelse &[_]u8{};
        }
        pub inline fn getCompositionTotalLayers(self: *const AndroidHwcomposerMetrics.MetricsPerDisplayReader) f64 {
            return self._composition_total_layers;
        }
        pub inline fn getCompositionDpuLayers(self: *const AndroidHwcomposerMetrics.MetricsPerDisplayReader) f64 {
            return self._composition_dpu_layers;
        }
        pub inline fn getCompositionGpuLayers(self: *const AndroidHwcomposerMetrics.MetricsPerDisplayReader) f64 {
            return self._composition_gpu_layers;
        }
        pub inline fn getCompositionDpuCachedLayers(self: *const AndroidHwcomposerMetrics.MetricsPerDisplayReader) f64 {
            return self._composition_dpu_cached_layers;
        }
        pub inline fn getCompositionSfCachedLayers(self: *const AndroidHwcomposerMetrics.MetricsPerDisplayReader) f64 {
            return self._composition_sf_cached_layers;
        }
        pub inline fn getCompositionRcdLayers(self: *const AndroidHwcomposerMetrics.MetricsPerDisplayReader) f64 {
            return self._composition_rcd_layers;
        }
        pub inline fn getSkippedValidationCount(self: *const AndroidHwcomposerMetrics.MetricsPerDisplayReader) i32 {
            return self._skipped_validation_count;
        }
        pub inline fn getUnskippedValidationCount(self: *const AndroidHwcomposerMetrics.MetricsPerDisplayReader) i32 {
            return self._unskipped_validation_count;
        }
        pub inline fn getSeparatedValidationCount(self: *const AndroidHwcomposerMetrics.MetricsPerDisplayReader) i32 {
            return self._separated_validation_count;
        }
        pub inline fn getUnknownValidationCount(self: *const AndroidHwcomposerMetrics.MetricsPerDisplayReader) i32 {
            return self._unknown_validation_count;
        }
        pub inline fn getAvgAllExecutionTimeMs(self: *const AndroidHwcomposerMetrics.MetricsPerDisplayReader) f64 {
            return self._avg_all_execution_time_ms;
        }
        pub inline fn getAvgSkippedExecutionTimeMs(self: *const AndroidHwcomposerMetrics.MetricsPerDisplayReader) f64 {
            return self._avg_skipped_execution_time_ms;
        }
        pub inline fn getAvgUnskippedExecutionTimeMs(self: *const AndroidHwcomposerMetrics.MetricsPerDisplayReader) f64 {
            return self._avg_unskipped_execution_time_ms;
        }
        pub inline fn getAvgSeparatedExecutionTimeMs(self: *const AndroidHwcomposerMetrics.MetricsPerDisplayReader) f64 {
            return self._avg_separated_execution_time_ms;
        }
    };
    // fields
    composition_total_layers: f64 = 0.0,
    composition_dpu_layers: f64 = 0.0,
    composition_gpu_layers: f64 = 0.0,
    composition_dpu_cached_layers: f64 = 0.0,
    composition_sf_cached_layers: f64 = 0.0,
    composition_rcd_layers: f64 = 0.0,
    skipped_validation_count: i32 = 0,
    unskipped_validation_count: i32 = 0,
    separated_validation_count: i32 = 0,
    unknown_validation_count: i32 = 0,
    avg_all_execution_time_ms: f64 = 0.0,
    avg_skipped_execution_time_ms: f64 = 0.0,
    avg_unskipped_execution_time_ms: f64 = 0.0,
    avg_separated_execution_time_ms: f64 = 0.0,
    dpu_vote_metrics: ?[]const ?AndroidHwcomposerMetrics.DpuVoteMetrics = null,
    metrics_per_display: ?[]const ?AndroidHwcomposerMetrics.MetricsPerDisplay = null,
    pub fn calcProtobufSize(self: *const AndroidHwcomposerMetrics) usize {
        var res: usize = 0;
        if (self.composition_total_layers != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidHwcomposerMetricsWire.COMPOSITION_TOTAL_LAYERS_WIRE) + gremlin.sizes.sizeDouble(self.composition_total_layers);
        }
        if (self.composition_dpu_layers != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidHwcomposerMetricsWire.COMPOSITION_DPU_LAYERS_WIRE) + gremlin.sizes.sizeDouble(self.composition_dpu_layers);
        }
        if (self.composition_gpu_layers != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidHwcomposerMetricsWire.COMPOSITION_GPU_LAYERS_WIRE) + gremlin.sizes.sizeDouble(self.composition_gpu_layers);
        }
        if (self.composition_dpu_cached_layers != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidHwcomposerMetricsWire.COMPOSITION_DPU_CACHED_LAYERS_WIRE) + gremlin.sizes.sizeDouble(self.composition_dpu_cached_layers);
        }
        if (self.composition_sf_cached_layers != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidHwcomposerMetricsWire.COMPOSITION_SF_CACHED_LAYERS_WIRE) + gremlin.sizes.sizeDouble(self.composition_sf_cached_layers);
        }
        if (self.composition_rcd_layers != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidHwcomposerMetricsWire.COMPOSITION_RCD_LAYERS_WIRE) + gremlin.sizes.sizeDouble(self.composition_rcd_layers);
        }
        if (self.skipped_validation_count != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidHwcomposerMetricsWire.SKIPPED_VALIDATION_COUNT_WIRE) + gremlin.sizes.sizeI32(self.skipped_validation_count);
        }
        if (self.unskipped_validation_count != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidHwcomposerMetricsWire.UNSKIPPED_VALIDATION_COUNT_WIRE) + gremlin.sizes.sizeI32(self.unskipped_validation_count);
        }
        if (self.separated_validation_count != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidHwcomposerMetricsWire.SEPARATED_VALIDATION_COUNT_WIRE) + gremlin.sizes.sizeI32(self.separated_validation_count);
        }
        if (self.unknown_validation_count != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidHwcomposerMetricsWire.UNKNOWN_VALIDATION_COUNT_WIRE) + gremlin.sizes.sizeI32(self.unknown_validation_count);
        }
        if (self.avg_all_execution_time_ms != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidHwcomposerMetricsWire.AVG_ALL_EXECUTION_TIME_MS_WIRE) + gremlin.sizes.sizeDouble(self.avg_all_execution_time_ms);
        }
        if (self.avg_skipped_execution_time_ms != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidHwcomposerMetricsWire.AVG_SKIPPED_EXECUTION_TIME_MS_WIRE) + gremlin.sizes.sizeDouble(self.avg_skipped_execution_time_ms);
        }
        if (self.avg_unskipped_execution_time_ms != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidHwcomposerMetricsWire.AVG_UNSKIPPED_EXECUTION_TIME_MS_WIRE) + gremlin.sizes.sizeDouble(self.avg_unskipped_execution_time_ms);
        }
        if (self.avg_separated_execution_time_ms != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidHwcomposerMetricsWire.AVG_SEPARATED_EXECUTION_TIME_MS_WIRE) + gremlin.sizes.sizeDouble(self.avg_separated_execution_time_ms);
        }
        if (self.dpu_vote_metrics) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidHwcomposerMetricsWire.DPU_VOTE_METRICS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.metrics_per_display) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidHwcomposerMetricsWire.METRICS_PER_DISPLAY_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidHwcomposerMetrics, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidHwcomposerMetrics, target: *gremlin.Writer) void {
        if (self.composition_total_layers != 0.0) {
            target.appendFloat64(AndroidHwcomposerMetricsWire.COMPOSITION_TOTAL_LAYERS_WIRE, self.composition_total_layers);
        }
        if (self.composition_dpu_layers != 0.0) {
            target.appendFloat64(AndroidHwcomposerMetricsWire.COMPOSITION_DPU_LAYERS_WIRE, self.composition_dpu_layers);
        }
        if (self.composition_gpu_layers != 0.0) {
            target.appendFloat64(AndroidHwcomposerMetricsWire.COMPOSITION_GPU_LAYERS_WIRE, self.composition_gpu_layers);
        }
        if (self.composition_dpu_cached_layers != 0.0) {
            target.appendFloat64(AndroidHwcomposerMetricsWire.COMPOSITION_DPU_CACHED_LAYERS_WIRE, self.composition_dpu_cached_layers);
        }
        if (self.composition_sf_cached_layers != 0.0) {
            target.appendFloat64(AndroidHwcomposerMetricsWire.COMPOSITION_SF_CACHED_LAYERS_WIRE, self.composition_sf_cached_layers);
        }
        if (self.composition_rcd_layers != 0.0) {
            target.appendFloat64(AndroidHwcomposerMetricsWire.COMPOSITION_RCD_LAYERS_WIRE, self.composition_rcd_layers);
        }
        if (self.skipped_validation_count != 0) {
            target.appendInt32(AndroidHwcomposerMetricsWire.SKIPPED_VALIDATION_COUNT_WIRE, self.skipped_validation_count);
        }
        if (self.unskipped_validation_count != 0) {
            target.appendInt32(AndroidHwcomposerMetricsWire.UNSKIPPED_VALIDATION_COUNT_WIRE, self.unskipped_validation_count);
        }
        if (self.separated_validation_count != 0) {
            target.appendInt32(AndroidHwcomposerMetricsWire.SEPARATED_VALIDATION_COUNT_WIRE, self.separated_validation_count);
        }
        if (self.unknown_validation_count != 0) {
            target.appendInt32(AndroidHwcomposerMetricsWire.UNKNOWN_VALIDATION_COUNT_WIRE, self.unknown_validation_count);
        }
        if (self.avg_all_execution_time_ms != 0.0) {
            target.appendFloat64(AndroidHwcomposerMetricsWire.AVG_ALL_EXECUTION_TIME_MS_WIRE, self.avg_all_execution_time_ms);
        }
        if (self.avg_skipped_execution_time_ms != 0.0) {
            target.appendFloat64(AndroidHwcomposerMetricsWire.AVG_SKIPPED_EXECUTION_TIME_MS_WIRE, self.avg_skipped_execution_time_ms);
        }
        if (self.avg_unskipped_execution_time_ms != 0.0) {
            target.appendFloat64(AndroidHwcomposerMetricsWire.AVG_UNSKIPPED_EXECUTION_TIME_MS_WIRE, self.avg_unskipped_execution_time_ms);
        }
        if (self.avg_separated_execution_time_ms != 0.0) {
            target.appendFloat64(AndroidHwcomposerMetricsWire.AVG_SEPARATED_EXECUTION_TIME_MS_WIRE, self.avg_separated_execution_time_ms);
        }
        if (self.dpu_vote_metrics) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidHwcomposerMetricsWire.DPU_VOTE_METRICS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidHwcomposerMetricsWire.DPU_VOTE_METRICS_WIRE, 0);
                }
            }
        }
        if (self.metrics_per_display) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidHwcomposerMetricsWire.METRICS_PER_DISPLAY_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidHwcomposerMetricsWire.METRICS_PER_DISPLAY_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidHwcomposerMetricsReader = struct {
    buf: gremlin.Reader,
    _composition_total_layers: f64 = 0.0,
    _composition_dpu_layers: f64 = 0.0,
    _composition_gpu_layers: f64 = 0.0,
    _composition_dpu_cached_layers: f64 = 0.0,
    _composition_sf_cached_layers: f64 = 0.0,
    _composition_rcd_layers: f64 = 0.0,
    _skipped_validation_count: i32 = 0,
    _unskipped_validation_count: i32 = 0,
    _separated_validation_count: i32 = 0,
    _unknown_validation_count: i32 = 0,
    _avg_all_execution_time_ms: f64 = 0.0,
    _avg_skipped_execution_time_ms: f64 = 0.0,
    _avg_unskipped_execution_time_ms: f64 = 0.0,
    _avg_separated_execution_time_ms: f64 = 0.0,
    _dpu_vote_metrics_offset: ?usize = null,
    _dpu_vote_metrics_last_offset: ?usize = null,
    _dpu_vote_metrics_cnt: usize = 0,
    _metrics_per_display_offset: ?usize = null,
    _metrics_per_display_last_offset: ?usize = null,
    _metrics_per_display_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidHwcomposerMetricsReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidHwcomposerMetricsReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidHwcomposerMetricsWire.COMPOSITION_TOTAL_LAYERS_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._composition_total_layers = result.value;
                },
                AndroidHwcomposerMetricsWire.COMPOSITION_DPU_LAYERS_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._composition_dpu_layers = result.value;
                },
                AndroidHwcomposerMetricsWire.COMPOSITION_GPU_LAYERS_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._composition_gpu_layers = result.value;
                },
                AndroidHwcomposerMetricsWire.COMPOSITION_DPU_CACHED_LAYERS_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._composition_dpu_cached_layers = result.value;
                },
                AndroidHwcomposerMetricsWire.COMPOSITION_SF_CACHED_LAYERS_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._composition_sf_cached_layers = result.value;
                },
                AndroidHwcomposerMetricsWire.COMPOSITION_RCD_LAYERS_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._composition_rcd_layers = result.value;
                },
                AndroidHwcomposerMetricsWire.SKIPPED_VALIDATION_COUNT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._skipped_validation_count = result.value;
                },
                AndroidHwcomposerMetricsWire.UNSKIPPED_VALIDATION_COUNT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._unskipped_validation_count = result.value;
                },
                AndroidHwcomposerMetricsWire.SEPARATED_VALIDATION_COUNT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._separated_validation_count = result.value;
                },
                AndroidHwcomposerMetricsWire.UNKNOWN_VALIDATION_COUNT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._unknown_validation_count = result.value;
                },
                AndroidHwcomposerMetricsWire.AVG_ALL_EXECUTION_TIME_MS_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._avg_all_execution_time_ms = result.value;
                },
                AndroidHwcomposerMetricsWire.AVG_SKIPPED_EXECUTION_TIME_MS_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._avg_skipped_execution_time_ms = result.value;
                },
                AndroidHwcomposerMetricsWire.AVG_UNSKIPPED_EXECUTION_TIME_MS_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._avg_unskipped_execution_time_ms = result.value;
                },
                AndroidHwcomposerMetricsWire.AVG_SEPARATED_EXECUTION_TIME_MS_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._avg_separated_execution_time_ms = result.value;
                },
                AndroidHwcomposerMetricsWire.DPU_VOTE_METRICS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._dpu_vote_metrics_offset == null) {
                        res._dpu_vote_metrics_offset = offset - result.size;
                    }
                    res._dpu_vote_metrics_last_offset = offset;
                    res._dpu_vote_metrics_cnt += 1;
                },
                AndroidHwcomposerMetricsWire.METRICS_PER_DISPLAY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._metrics_per_display_offset == null) {
                        res._metrics_per_display_offset = offset - result.size;
                    }
                    res._metrics_per_display_last_offset = offset;
                    res._metrics_per_display_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getCompositionTotalLayers(self: *const AndroidHwcomposerMetricsReader) f64 {
        return self._composition_total_layers;
    }
    pub inline fn getCompositionDpuLayers(self: *const AndroidHwcomposerMetricsReader) f64 {
        return self._composition_dpu_layers;
    }
    pub inline fn getCompositionGpuLayers(self: *const AndroidHwcomposerMetricsReader) f64 {
        return self._composition_gpu_layers;
    }
    pub inline fn getCompositionDpuCachedLayers(self: *const AndroidHwcomposerMetricsReader) f64 {
        return self._composition_dpu_cached_layers;
    }
    pub inline fn getCompositionSfCachedLayers(self: *const AndroidHwcomposerMetricsReader) f64 {
        return self._composition_sf_cached_layers;
    }
    pub inline fn getCompositionRcdLayers(self: *const AndroidHwcomposerMetricsReader) f64 {
        return self._composition_rcd_layers;
    }
    pub inline fn getSkippedValidationCount(self: *const AndroidHwcomposerMetricsReader) i32 {
        return self._skipped_validation_count;
    }
    pub inline fn getUnskippedValidationCount(self: *const AndroidHwcomposerMetricsReader) i32 {
        return self._unskipped_validation_count;
    }
    pub inline fn getSeparatedValidationCount(self: *const AndroidHwcomposerMetricsReader) i32 {
        return self._separated_validation_count;
    }
    pub inline fn getUnknownValidationCount(self: *const AndroidHwcomposerMetricsReader) i32 {
        return self._unknown_validation_count;
    }
    pub inline fn getAvgAllExecutionTimeMs(self: *const AndroidHwcomposerMetricsReader) f64 {
        return self._avg_all_execution_time_ms;
    }
    pub inline fn getAvgSkippedExecutionTimeMs(self: *const AndroidHwcomposerMetricsReader) f64 {
        return self._avg_skipped_execution_time_ms;
    }
    pub inline fn getAvgUnskippedExecutionTimeMs(self: *const AndroidHwcomposerMetricsReader) f64 {
        return self._avg_unskipped_execution_time_ms;
    }
    pub inline fn getAvgSeparatedExecutionTimeMs(self: *const AndroidHwcomposerMetricsReader) f64 {
        return self._avg_separated_execution_time_ms;
    }
    pub fn dpuVoteMetricsCount(self: *const AndroidHwcomposerMetricsReader) usize {
        return self._dpu_vote_metrics_cnt;
    }
    pub fn dpuVoteMetricsNext(self: *AndroidHwcomposerMetricsReader) ?AndroidHwcomposerMetrics.DpuVoteMetricsReader {
        if (self._dpu_vote_metrics_offset == null) return null;
        const current_offset = self._dpu_vote_metrics_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidHwcomposerMetrics.DpuVoteMetricsReader.init(result.value) catch return null;
        if (self._dpu_vote_metrics_last_offset != null and current_offset >= self._dpu_vote_metrics_last_offset.?) {
            self._dpu_vote_metrics_offset = null;
            return msg;
        }
        if (self._dpu_vote_metrics_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._dpu_vote_metrics_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidHwcomposerMetricsWire.DPU_VOTE_METRICS_WIRE) {
                self._dpu_vote_metrics_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._dpu_vote_metrics_offset = null;
        return msg;
    }
    pub fn metricsPerDisplayCount(self: *const AndroidHwcomposerMetricsReader) usize {
        return self._metrics_per_display_cnt;
    }
    pub fn metricsPerDisplayNext(self: *AndroidHwcomposerMetricsReader) ?AndroidHwcomposerMetrics.MetricsPerDisplayReader {
        if (self._metrics_per_display_offset == null) return null;
        const current_offset = self._metrics_per_display_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidHwcomposerMetrics.MetricsPerDisplayReader.init(result.value) catch return null;
        if (self._metrics_per_display_last_offset != null and current_offset >= self._metrics_per_display_last_offset.?) {
            self._metrics_per_display_offset = null;
            return msg;
        }
        if (self._metrics_per_display_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._metrics_per_display_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidHwcomposerMetricsWire.METRICS_PER_DISPLAY_WIRE) {
                self._metrics_per_display_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._metrics_per_display_offset = null;
        return msg;
    }
};
const ProcessRenderInfoWire = struct {
    const PROCESS_NAME_WIRE: gremlin.ProtoWireNumber = 1;
    const RT_CPU_TIME_MS_WIRE: gremlin.ProtoWireNumber = 2;
    const DRAW_FRAME_COUNT_WIRE: gremlin.ProtoWireNumber = 3;
    const DRAW_FRAME_MAX_WIRE: gremlin.ProtoWireNumber = 4;
    const DRAW_FRAME_MIN_WIRE: gremlin.ProtoWireNumber = 5;
    const DRAW_FRAME_AVG_WIRE: gremlin.ProtoWireNumber = 6;
    const FLUSH_COUNT_WIRE: gremlin.ProtoWireNumber = 7;
    const FLUSH_MAX_WIRE: gremlin.ProtoWireNumber = 8;
    const FLUSH_MIN_WIRE: gremlin.ProtoWireNumber = 9;
    const FLUSH_AVG_WIRE: gremlin.ProtoWireNumber = 10;
    const PREPARE_TREE_COUNT_WIRE: gremlin.ProtoWireNumber = 11;
    const PREPARE_TREE_MAX_WIRE: gremlin.ProtoWireNumber = 12;
    const PREPARE_TREE_MIN_WIRE: gremlin.ProtoWireNumber = 13;
    const PREPARE_TREE_AVG_WIRE: gremlin.ProtoWireNumber = 14;
    const GPU_COMPLETION_COUNT_WIRE: gremlin.ProtoWireNumber = 15;
    const GPU_COMPLETION_MAX_WIRE: gremlin.ProtoWireNumber = 16;
    const GPU_COMPLETION_MIN_WIRE: gremlin.ProtoWireNumber = 17;
    const GPU_COMPLETION_AVG_WIRE: gremlin.ProtoWireNumber = 18;
    const UI_RECORD_COUNT_WIRE: gremlin.ProtoWireNumber = 19;
    const UI_RECORD_MAX_WIRE: gremlin.ProtoWireNumber = 20;
    const UI_RECORD_MIN_WIRE: gremlin.ProtoWireNumber = 21;
    const UI_RECORD_AVG_WIRE: gremlin.ProtoWireNumber = 22;
    const SHADER_COMPILE_COUNT_WIRE: gremlin.ProtoWireNumber = 23;
    const SHADER_COMPILE_TIME_WIRE: gremlin.ProtoWireNumber = 24;
    const SHADER_COMPILE_AVG_WIRE: gremlin.ProtoWireNumber = 25;
    const CACHE_HIT_COUNT_WIRE: gremlin.ProtoWireNumber = 26;
    const CACHE_HIT_TIME_WIRE: gremlin.ProtoWireNumber = 27;
    const CACHE_HIT_AVG_WIRE: gremlin.ProtoWireNumber = 28;
    const CACHE_MISS_COUNT_WIRE: gremlin.ProtoWireNumber = 29;
    const CACHE_MISS_TIME_WIRE: gremlin.ProtoWireNumber = 30;
    const CACHE_MISS_AVG_WIRE: gremlin.ProtoWireNumber = 31;
    const GRAPHICS_CPU_MEM_MAX_WIRE: gremlin.ProtoWireNumber = 32;
    const GRAPHICS_CPU_MEM_MIN_WIRE: gremlin.ProtoWireNumber = 33;
    const GRAPHICS_CPU_MEM_AVG_WIRE: gremlin.ProtoWireNumber = 34;
    const GRAPHICS_GPU_MEM_MAX_WIRE: gremlin.ProtoWireNumber = 35;
    const GRAPHICS_GPU_MEM_MIN_WIRE: gremlin.ProtoWireNumber = 36;
    const GRAPHICS_GPU_MEM_AVG_WIRE: gremlin.ProtoWireNumber = 37;
    const TEXTURE_MEM_MAX_WIRE: gremlin.ProtoWireNumber = 38;
    const TEXTURE_MEM_MIN_WIRE: gremlin.ProtoWireNumber = 39;
    const TEXTURE_MEM_AVG_WIRE: gremlin.ProtoWireNumber = 40;
    const ALL_MEM_MAX_WIRE: gremlin.ProtoWireNumber = 41;
    const ALL_MEM_MIN_WIRE: gremlin.ProtoWireNumber = 42;
    const ALL_MEM_AVG_WIRE: gremlin.ProtoWireNumber = 43;
};
pub const ProcessRenderInfo = struct {
    // fields
    process_name: ?[]const u8 = null,
    rt_cpu_time_ms: i64 = 0,
    draw_frame_count: u32 = 0,
    draw_frame_max: i64 = 0,
    draw_frame_min: i64 = 0,
    draw_frame_avg: f64 = 0.0,
    flush_count: u32 = 0,
    flush_max: i64 = 0,
    flush_min: i64 = 0,
    flush_avg: f64 = 0.0,
    prepare_tree_count: u32 = 0,
    prepare_tree_max: i64 = 0,
    prepare_tree_min: i64 = 0,
    prepare_tree_avg: f64 = 0.0,
    gpu_completion_count: u32 = 0,
    gpu_completion_max: i64 = 0,
    gpu_completion_min: i64 = 0,
    gpu_completion_avg: f64 = 0.0,
    ui_record_count: u32 = 0,
    ui_record_max: i64 = 0,
    ui_record_min: i64 = 0,
    ui_record_avg: f64 = 0.0,
    shader_compile_count: u32 = 0,
    shader_compile_time: i64 = 0,
    shader_compile_avg: f64 = 0.0,
    cache_hit_count: u32 = 0,
    cache_hit_time: i64 = 0,
    cache_hit_avg: f64 = 0.0,
    cache_miss_count: u32 = 0,
    cache_miss_time: i64 = 0,
    cache_miss_avg: f64 = 0.0,
    graphics_cpu_mem_max: i64 = 0,
    graphics_cpu_mem_min: i64 = 0,
    graphics_cpu_mem_avg: f64 = 0.0,
    graphics_gpu_mem_max: i64 = 0,
    graphics_gpu_mem_min: i64 = 0,
    graphics_gpu_mem_avg: f64 = 0.0,
    texture_mem_max: i64 = 0,
    texture_mem_min: i64 = 0,
    texture_mem_avg: f64 = 0.0,
    all_mem_max: i64 = 0,
    all_mem_min: i64 = 0,
    all_mem_avg: f64 = 0.0,
    pub fn calcProtobufSize(self: *const ProcessRenderInfo) usize {
        var res: usize = 0;
        if (self.process_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(ProcessRenderInfoWire.PROCESS_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.rt_cpu_time_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(ProcessRenderInfoWire.RT_CPU_TIME_MS_WIRE) + gremlin.sizes.sizeI64(self.rt_cpu_time_ms);
        }
        if (self.draw_frame_count != 0) {
            res += gremlin.sizes.sizeWireNumber(ProcessRenderInfoWire.DRAW_FRAME_COUNT_WIRE) + gremlin.sizes.sizeU32(self.draw_frame_count);
        }
        if (self.draw_frame_max != 0) {
            res += gremlin.sizes.sizeWireNumber(ProcessRenderInfoWire.DRAW_FRAME_MAX_WIRE) + gremlin.sizes.sizeI64(self.draw_frame_max);
        }
        if (self.draw_frame_min != 0) {
            res += gremlin.sizes.sizeWireNumber(ProcessRenderInfoWire.DRAW_FRAME_MIN_WIRE) + gremlin.sizes.sizeI64(self.draw_frame_min);
        }
        if (self.draw_frame_avg != 0.0) {
            res += gremlin.sizes.sizeWireNumber(ProcessRenderInfoWire.DRAW_FRAME_AVG_WIRE) + gremlin.sizes.sizeDouble(self.draw_frame_avg);
        }
        if (self.flush_count != 0) {
            res += gremlin.sizes.sizeWireNumber(ProcessRenderInfoWire.FLUSH_COUNT_WIRE) + gremlin.sizes.sizeU32(self.flush_count);
        }
        if (self.flush_max != 0) {
            res += gremlin.sizes.sizeWireNumber(ProcessRenderInfoWire.FLUSH_MAX_WIRE) + gremlin.sizes.sizeI64(self.flush_max);
        }
        if (self.flush_min != 0) {
            res += gremlin.sizes.sizeWireNumber(ProcessRenderInfoWire.FLUSH_MIN_WIRE) + gremlin.sizes.sizeI64(self.flush_min);
        }
        if (self.flush_avg != 0.0) {
            res += gremlin.sizes.sizeWireNumber(ProcessRenderInfoWire.FLUSH_AVG_WIRE) + gremlin.sizes.sizeDouble(self.flush_avg);
        }
        if (self.prepare_tree_count != 0) {
            res += gremlin.sizes.sizeWireNumber(ProcessRenderInfoWire.PREPARE_TREE_COUNT_WIRE) + gremlin.sizes.sizeU32(self.prepare_tree_count);
        }
        if (self.prepare_tree_max != 0) {
            res += gremlin.sizes.sizeWireNumber(ProcessRenderInfoWire.PREPARE_TREE_MAX_WIRE) + gremlin.sizes.sizeI64(self.prepare_tree_max);
        }
        if (self.prepare_tree_min != 0) {
            res += gremlin.sizes.sizeWireNumber(ProcessRenderInfoWire.PREPARE_TREE_MIN_WIRE) + gremlin.sizes.sizeI64(self.prepare_tree_min);
        }
        if (self.prepare_tree_avg != 0.0) {
            res += gremlin.sizes.sizeWireNumber(ProcessRenderInfoWire.PREPARE_TREE_AVG_WIRE) + gremlin.sizes.sizeDouble(self.prepare_tree_avg);
        }
        if (self.gpu_completion_count != 0) {
            res += gremlin.sizes.sizeWireNumber(ProcessRenderInfoWire.GPU_COMPLETION_COUNT_WIRE) + gremlin.sizes.sizeU32(self.gpu_completion_count);
        }
        if (self.gpu_completion_max != 0) {
            res += gremlin.sizes.sizeWireNumber(ProcessRenderInfoWire.GPU_COMPLETION_MAX_WIRE) + gremlin.sizes.sizeI64(self.gpu_completion_max);
        }
        if (self.gpu_completion_min != 0) {
            res += gremlin.sizes.sizeWireNumber(ProcessRenderInfoWire.GPU_COMPLETION_MIN_WIRE) + gremlin.sizes.sizeI64(self.gpu_completion_min);
        }
        if (self.gpu_completion_avg != 0.0) {
            res += gremlin.sizes.sizeWireNumber(ProcessRenderInfoWire.GPU_COMPLETION_AVG_WIRE) + gremlin.sizes.sizeDouble(self.gpu_completion_avg);
        }
        if (self.ui_record_count != 0) {
            res += gremlin.sizes.sizeWireNumber(ProcessRenderInfoWire.UI_RECORD_COUNT_WIRE) + gremlin.sizes.sizeU32(self.ui_record_count);
        }
        if (self.ui_record_max != 0) {
            res += gremlin.sizes.sizeWireNumber(ProcessRenderInfoWire.UI_RECORD_MAX_WIRE) + gremlin.sizes.sizeI64(self.ui_record_max);
        }
        if (self.ui_record_min != 0) {
            res += gremlin.sizes.sizeWireNumber(ProcessRenderInfoWire.UI_RECORD_MIN_WIRE) + gremlin.sizes.sizeI64(self.ui_record_min);
        }
        if (self.ui_record_avg != 0.0) {
            res += gremlin.sizes.sizeWireNumber(ProcessRenderInfoWire.UI_RECORD_AVG_WIRE) + gremlin.sizes.sizeDouble(self.ui_record_avg);
        }
        if (self.shader_compile_count != 0) {
            res += gremlin.sizes.sizeWireNumber(ProcessRenderInfoWire.SHADER_COMPILE_COUNT_WIRE) + gremlin.sizes.sizeU32(self.shader_compile_count);
        }
        if (self.shader_compile_time != 0) {
            res += gremlin.sizes.sizeWireNumber(ProcessRenderInfoWire.SHADER_COMPILE_TIME_WIRE) + gremlin.sizes.sizeI64(self.shader_compile_time);
        }
        if (self.shader_compile_avg != 0.0) {
            res += gremlin.sizes.sizeWireNumber(ProcessRenderInfoWire.SHADER_COMPILE_AVG_WIRE) + gremlin.sizes.sizeDouble(self.shader_compile_avg);
        }
        if (self.cache_hit_count != 0) {
            res += gremlin.sizes.sizeWireNumber(ProcessRenderInfoWire.CACHE_HIT_COUNT_WIRE) + gremlin.sizes.sizeU32(self.cache_hit_count);
        }
        if (self.cache_hit_time != 0) {
            res += gremlin.sizes.sizeWireNumber(ProcessRenderInfoWire.CACHE_HIT_TIME_WIRE) + gremlin.sizes.sizeI64(self.cache_hit_time);
        }
        if (self.cache_hit_avg != 0.0) {
            res += gremlin.sizes.sizeWireNumber(ProcessRenderInfoWire.CACHE_HIT_AVG_WIRE) + gremlin.sizes.sizeDouble(self.cache_hit_avg);
        }
        if (self.cache_miss_count != 0) {
            res += gremlin.sizes.sizeWireNumber(ProcessRenderInfoWire.CACHE_MISS_COUNT_WIRE) + gremlin.sizes.sizeU32(self.cache_miss_count);
        }
        if (self.cache_miss_time != 0) {
            res += gremlin.sizes.sizeWireNumber(ProcessRenderInfoWire.CACHE_MISS_TIME_WIRE) + gremlin.sizes.sizeI64(self.cache_miss_time);
        }
        if (self.cache_miss_avg != 0.0) {
            res += gremlin.sizes.sizeWireNumber(ProcessRenderInfoWire.CACHE_MISS_AVG_WIRE) + gremlin.sizes.sizeDouble(self.cache_miss_avg);
        }
        if (self.graphics_cpu_mem_max != 0) {
            res += gremlin.sizes.sizeWireNumber(ProcessRenderInfoWire.GRAPHICS_CPU_MEM_MAX_WIRE) + gremlin.sizes.sizeI64(self.graphics_cpu_mem_max);
        }
        if (self.graphics_cpu_mem_min != 0) {
            res += gremlin.sizes.sizeWireNumber(ProcessRenderInfoWire.GRAPHICS_CPU_MEM_MIN_WIRE) + gremlin.sizes.sizeI64(self.graphics_cpu_mem_min);
        }
        if (self.graphics_cpu_mem_avg != 0.0) {
            res += gremlin.sizes.sizeWireNumber(ProcessRenderInfoWire.GRAPHICS_CPU_MEM_AVG_WIRE) + gremlin.sizes.sizeDouble(self.graphics_cpu_mem_avg);
        }
        if (self.graphics_gpu_mem_max != 0) {
            res += gremlin.sizes.sizeWireNumber(ProcessRenderInfoWire.GRAPHICS_GPU_MEM_MAX_WIRE) + gremlin.sizes.sizeI64(self.graphics_gpu_mem_max);
        }
        if (self.graphics_gpu_mem_min != 0) {
            res += gremlin.sizes.sizeWireNumber(ProcessRenderInfoWire.GRAPHICS_GPU_MEM_MIN_WIRE) + gremlin.sizes.sizeI64(self.graphics_gpu_mem_min);
        }
        if (self.graphics_gpu_mem_avg != 0.0) {
            res += gremlin.sizes.sizeWireNumber(ProcessRenderInfoWire.GRAPHICS_GPU_MEM_AVG_WIRE) + gremlin.sizes.sizeDouble(self.graphics_gpu_mem_avg);
        }
        if (self.texture_mem_max != 0) {
            res += gremlin.sizes.sizeWireNumber(ProcessRenderInfoWire.TEXTURE_MEM_MAX_WIRE) + gremlin.sizes.sizeI64(self.texture_mem_max);
        }
        if (self.texture_mem_min != 0) {
            res += gremlin.sizes.sizeWireNumber(ProcessRenderInfoWire.TEXTURE_MEM_MIN_WIRE) + gremlin.sizes.sizeI64(self.texture_mem_min);
        }
        if (self.texture_mem_avg != 0.0) {
            res += gremlin.sizes.sizeWireNumber(ProcessRenderInfoWire.TEXTURE_MEM_AVG_WIRE) + gremlin.sizes.sizeDouble(self.texture_mem_avg);
        }
        if (self.all_mem_max != 0) {
            res += gremlin.sizes.sizeWireNumber(ProcessRenderInfoWire.ALL_MEM_MAX_WIRE) + gremlin.sizes.sizeI64(self.all_mem_max);
        }
        if (self.all_mem_min != 0) {
            res += gremlin.sizes.sizeWireNumber(ProcessRenderInfoWire.ALL_MEM_MIN_WIRE) + gremlin.sizes.sizeI64(self.all_mem_min);
        }
        if (self.all_mem_avg != 0.0) {
            res += gremlin.sizes.sizeWireNumber(ProcessRenderInfoWire.ALL_MEM_AVG_WIRE) + gremlin.sizes.sizeDouble(self.all_mem_avg);
        }
        return res;
    }
    pub fn encode(self: *const ProcessRenderInfo, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ProcessRenderInfo, target: *gremlin.Writer) void {
        if (self.process_name) |v| {
            if (v.len > 0) {
                target.appendBytes(ProcessRenderInfoWire.PROCESS_NAME_WIRE, v);
            }
        }
        if (self.rt_cpu_time_ms != 0) {
            target.appendInt64(ProcessRenderInfoWire.RT_CPU_TIME_MS_WIRE, self.rt_cpu_time_ms);
        }
        if (self.draw_frame_count != 0) {
            target.appendUint32(ProcessRenderInfoWire.DRAW_FRAME_COUNT_WIRE, self.draw_frame_count);
        }
        if (self.draw_frame_max != 0) {
            target.appendInt64(ProcessRenderInfoWire.DRAW_FRAME_MAX_WIRE, self.draw_frame_max);
        }
        if (self.draw_frame_min != 0) {
            target.appendInt64(ProcessRenderInfoWire.DRAW_FRAME_MIN_WIRE, self.draw_frame_min);
        }
        if (self.draw_frame_avg != 0.0) {
            target.appendFloat64(ProcessRenderInfoWire.DRAW_FRAME_AVG_WIRE, self.draw_frame_avg);
        }
        if (self.flush_count != 0) {
            target.appendUint32(ProcessRenderInfoWire.FLUSH_COUNT_WIRE, self.flush_count);
        }
        if (self.flush_max != 0) {
            target.appendInt64(ProcessRenderInfoWire.FLUSH_MAX_WIRE, self.flush_max);
        }
        if (self.flush_min != 0) {
            target.appendInt64(ProcessRenderInfoWire.FLUSH_MIN_WIRE, self.flush_min);
        }
        if (self.flush_avg != 0.0) {
            target.appendFloat64(ProcessRenderInfoWire.FLUSH_AVG_WIRE, self.flush_avg);
        }
        if (self.prepare_tree_count != 0) {
            target.appendUint32(ProcessRenderInfoWire.PREPARE_TREE_COUNT_WIRE, self.prepare_tree_count);
        }
        if (self.prepare_tree_max != 0) {
            target.appendInt64(ProcessRenderInfoWire.PREPARE_TREE_MAX_WIRE, self.prepare_tree_max);
        }
        if (self.prepare_tree_min != 0) {
            target.appendInt64(ProcessRenderInfoWire.PREPARE_TREE_MIN_WIRE, self.prepare_tree_min);
        }
        if (self.prepare_tree_avg != 0.0) {
            target.appendFloat64(ProcessRenderInfoWire.PREPARE_TREE_AVG_WIRE, self.prepare_tree_avg);
        }
        if (self.gpu_completion_count != 0) {
            target.appendUint32(ProcessRenderInfoWire.GPU_COMPLETION_COUNT_WIRE, self.gpu_completion_count);
        }
        if (self.gpu_completion_max != 0) {
            target.appendInt64(ProcessRenderInfoWire.GPU_COMPLETION_MAX_WIRE, self.gpu_completion_max);
        }
        if (self.gpu_completion_min != 0) {
            target.appendInt64(ProcessRenderInfoWire.GPU_COMPLETION_MIN_WIRE, self.gpu_completion_min);
        }
        if (self.gpu_completion_avg != 0.0) {
            target.appendFloat64(ProcessRenderInfoWire.GPU_COMPLETION_AVG_WIRE, self.gpu_completion_avg);
        }
        if (self.ui_record_count != 0) {
            target.appendUint32(ProcessRenderInfoWire.UI_RECORD_COUNT_WIRE, self.ui_record_count);
        }
        if (self.ui_record_max != 0) {
            target.appendInt64(ProcessRenderInfoWire.UI_RECORD_MAX_WIRE, self.ui_record_max);
        }
        if (self.ui_record_min != 0) {
            target.appendInt64(ProcessRenderInfoWire.UI_RECORD_MIN_WIRE, self.ui_record_min);
        }
        if (self.ui_record_avg != 0.0) {
            target.appendFloat64(ProcessRenderInfoWire.UI_RECORD_AVG_WIRE, self.ui_record_avg);
        }
        if (self.shader_compile_count != 0) {
            target.appendUint32(ProcessRenderInfoWire.SHADER_COMPILE_COUNT_WIRE, self.shader_compile_count);
        }
        if (self.shader_compile_time != 0) {
            target.appendInt64(ProcessRenderInfoWire.SHADER_COMPILE_TIME_WIRE, self.shader_compile_time);
        }
        if (self.shader_compile_avg != 0.0) {
            target.appendFloat64(ProcessRenderInfoWire.SHADER_COMPILE_AVG_WIRE, self.shader_compile_avg);
        }
        if (self.cache_hit_count != 0) {
            target.appendUint32(ProcessRenderInfoWire.CACHE_HIT_COUNT_WIRE, self.cache_hit_count);
        }
        if (self.cache_hit_time != 0) {
            target.appendInt64(ProcessRenderInfoWire.CACHE_HIT_TIME_WIRE, self.cache_hit_time);
        }
        if (self.cache_hit_avg != 0.0) {
            target.appendFloat64(ProcessRenderInfoWire.CACHE_HIT_AVG_WIRE, self.cache_hit_avg);
        }
        if (self.cache_miss_count != 0) {
            target.appendUint32(ProcessRenderInfoWire.CACHE_MISS_COUNT_WIRE, self.cache_miss_count);
        }
        if (self.cache_miss_time != 0) {
            target.appendInt64(ProcessRenderInfoWire.CACHE_MISS_TIME_WIRE, self.cache_miss_time);
        }
        if (self.cache_miss_avg != 0.0) {
            target.appendFloat64(ProcessRenderInfoWire.CACHE_MISS_AVG_WIRE, self.cache_miss_avg);
        }
        if (self.graphics_cpu_mem_max != 0) {
            target.appendInt64(ProcessRenderInfoWire.GRAPHICS_CPU_MEM_MAX_WIRE, self.graphics_cpu_mem_max);
        }
        if (self.graphics_cpu_mem_min != 0) {
            target.appendInt64(ProcessRenderInfoWire.GRAPHICS_CPU_MEM_MIN_WIRE, self.graphics_cpu_mem_min);
        }
        if (self.graphics_cpu_mem_avg != 0.0) {
            target.appendFloat64(ProcessRenderInfoWire.GRAPHICS_CPU_MEM_AVG_WIRE, self.graphics_cpu_mem_avg);
        }
        if (self.graphics_gpu_mem_max != 0) {
            target.appendInt64(ProcessRenderInfoWire.GRAPHICS_GPU_MEM_MAX_WIRE, self.graphics_gpu_mem_max);
        }
        if (self.graphics_gpu_mem_min != 0) {
            target.appendInt64(ProcessRenderInfoWire.GRAPHICS_GPU_MEM_MIN_WIRE, self.graphics_gpu_mem_min);
        }
        if (self.graphics_gpu_mem_avg != 0.0) {
            target.appendFloat64(ProcessRenderInfoWire.GRAPHICS_GPU_MEM_AVG_WIRE, self.graphics_gpu_mem_avg);
        }
        if (self.texture_mem_max != 0) {
            target.appendInt64(ProcessRenderInfoWire.TEXTURE_MEM_MAX_WIRE, self.texture_mem_max);
        }
        if (self.texture_mem_min != 0) {
            target.appendInt64(ProcessRenderInfoWire.TEXTURE_MEM_MIN_WIRE, self.texture_mem_min);
        }
        if (self.texture_mem_avg != 0.0) {
            target.appendFloat64(ProcessRenderInfoWire.TEXTURE_MEM_AVG_WIRE, self.texture_mem_avg);
        }
        if (self.all_mem_max != 0) {
            target.appendInt64(ProcessRenderInfoWire.ALL_MEM_MAX_WIRE, self.all_mem_max);
        }
        if (self.all_mem_min != 0) {
            target.appendInt64(ProcessRenderInfoWire.ALL_MEM_MIN_WIRE, self.all_mem_min);
        }
        if (self.all_mem_avg != 0.0) {
            target.appendFloat64(ProcessRenderInfoWire.ALL_MEM_AVG_WIRE, self.all_mem_avg);
        }
    }
};
pub const ProcessRenderInfoReader = struct {
    buf: gremlin.Reader,
    _process_name: ?[]const u8 = null,
    _rt_cpu_time_ms: i64 = 0,
    _draw_frame_count: u32 = 0,
    _draw_frame_max: i64 = 0,
    _draw_frame_min: i64 = 0,
    _draw_frame_avg: f64 = 0.0,
    _flush_count: u32 = 0,
    _flush_max: i64 = 0,
    _flush_min: i64 = 0,
    _flush_avg: f64 = 0.0,
    _prepare_tree_count: u32 = 0,
    _prepare_tree_max: i64 = 0,
    _prepare_tree_min: i64 = 0,
    _prepare_tree_avg: f64 = 0.0,
    _gpu_completion_count: u32 = 0,
    _gpu_completion_max: i64 = 0,
    _gpu_completion_min: i64 = 0,
    _gpu_completion_avg: f64 = 0.0,
    _ui_record_count: u32 = 0,
    _ui_record_max: i64 = 0,
    _ui_record_min: i64 = 0,
    _ui_record_avg: f64 = 0.0,
    _shader_compile_count: u32 = 0,
    _shader_compile_time: i64 = 0,
    _shader_compile_avg: f64 = 0.0,
    _cache_hit_count: u32 = 0,
    _cache_hit_time: i64 = 0,
    _cache_hit_avg: f64 = 0.0,
    _cache_miss_count: u32 = 0,
    _cache_miss_time: i64 = 0,
    _cache_miss_avg: f64 = 0.0,
    _graphics_cpu_mem_max: i64 = 0,
    _graphics_cpu_mem_min: i64 = 0,
    _graphics_cpu_mem_avg: f64 = 0.0,
    _graphics_gpu_mem_max: i64 = 0,
    _graphics_gpu_mem_min: i64 = 0,
    _graphics_gpu_mem_avg: f64 = 0.0,
    _texture_mem_max: i64 = 0,
    _texture_mem_min: i64 = 0,
    _texture_mem_avg: f64 = 0.0,
    _all_mem_max: i64 = 0,
    _all_mem_min: i64 = 0,
    _all_mem_avg: f64 = 0.0,
    pub fn init(src: []const u8) gremlin.Error!ProcessRenderInfoReader {
        const buf = gremlin.Reader.init(src);
        var res = ProcessRenderInfoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ProcessRenderInfoWire.PROCESS_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._process_name = result.value;
                },
                ProcessRenderInfoWire.RT_CPU_TIME_MS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._rt_cpu_time_ms = result.value;
                },
                ProcessRenderInfoWire.DRAW_FRAME_COUNT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._draw_frame_count = result.value;
                },
                ProcessRenderInfoWire.DRAW_FRAME_MAX_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._draw_frame_max = result.value;
                },
                ProcessRenderInfoWire.DRAW_FRAME_MIN_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._draw_frame_min = result.value;
                },
                ProcessRenderInfoWire.DRAW_FRAME_AVG_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._draw_frame_avg = result.value;
                },
                ProcessRenderInfoWire.FLUSH_COUNT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._flush_count = result.value;
                },
                ProcessRenderInfoWire.FLUSH_MAX_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._flush_max = result.value;
                },
                ProcessRenderInfoWire.FLUSH_MIN_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._flush_min = result.value;
                },
                ProcessRenderInfoWire.FLUSH_AVG_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._flush_avg = result.value;
                },
                ProcessRenderInfoWire.PREPARE_TREE_COUNT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._prepare_tree_count = result.value;
                },
                ProcessRenderInfoWire.PREPARE_TREE_MAX_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._prepare_tree_max = result.value;
                },
                ProcessRenderInfoWire.PREPARE_TREE_MIN_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._prepare_tree_min = result.value;
                },
                ProcessRenderInfoWire.PREPARE_TREE_AVG_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._prepare_tree_avg = result.value;
                },
                ProcessRenderInfoWire.GPU_COMPLETION_COUNT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._gpu_completion_count = result.value;
                },
                ProcessRenderInfoWire.GPU_COMPLETION_MAX_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._gpu_completion_max = result.value;
                },
                ProcessRenderInfoWire.GPU_COMPLETION_MIN_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._gpu_completion_min = result.value;
                },
                ProcessRenderInfoWire.GPU_COMPLETION_AVG_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._gpu_completion_avg = result.value;
                },
                ProcessRenderInfoWire.UI_RECORD_COUNT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._ui_record_count = result.value;
                },
                ProcessRenderInfoWire.UI_RECORD_MAX_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._ui_record_max = result.value;
                },
                ProcessRenderInfoWire.UI_RECORD_MIN_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._ui_record_min = result.value;
                },
                ProcessRenderInfoWire.UI_RECORD_AVG_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._ui_record_avg = result.value;
                },
                ProcessRenderInfoWire.SHADER_COMPILE_COUNT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._shader_compile_count = result.value;
                },
                ProcessRenderInfoWire.SHADER_COMPILE_TIME_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._shader_compile_time = result.value;
                },
                ProcessRenderInfoWire.SHADER_COMPILE_AVG_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._shader_compile_avg = result.value;
                },
                ProcessRenderInfoWire.CACHE_HIT_COUNT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._cache_hit_count = result.value;
                },
                ProcessRenderInfoWire.CACHE_HIT_TIME_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._cache_hit_time = result.value;
                },
                ProcessRenderInfoWire.CACHE_HIT_AVG_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._cache_hit_avg = result.value;
                },
                ProcessRenderInfoWire.CACHE_MISS_COUNT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._cache_miss_count = result.value;
                },
                ProcessRenderInfoWire.CACHE_MISS_TIME_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._cache_miss_time = result.value;
                },
                ProcessRenderInfoWire.CACHE_MISS_AVG_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._cache_miss_avg = result.value;
                },
                ProcessRenderInfoWire.GRAPHICS_CPU_MEM_MAX_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._graphics_cpu_mem_max = result.value;
                },
                ProcessRenderInfoWire.GRAPHICS_CPU_MEM_MIN_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._graphics_cpu_mem_min = result.value;
                },
                ProcessRenderInfoWire.GRAPHICS_CPU_MEM_AVG_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._graphics_cpu_mem_avg = result.value;
                },
                ProcessRenderInfoWire.GRAPHICS_GPU_MEM_MAX_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._graphics_gpu_mem_max = result.value;
                },
                ProcessRenderInfoWire.GRAPHICS_GPU_MEM_MIN_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._graphics_gpu_mem_min = result.value;
                },
                ProcessRenderInfoWire.GRAPHICS_GPU_MEM_AVG_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._graphics_gpu_mem_avg = result.value;
                },
                ProcessRenderInfoWire.TEXTURE_MEM_MAX_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._texture_mem_max = result.value;
                },
                ProcessRenderInfoWire.TEXTURE_MEM_MIN_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._texture_mem_min = result.value;
                },
                ProcessRenderInfoWire.TEXTURE_MEM_AVG_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._texture_mem_avg = result.value;
                },
                ProcessRenderInfoWire.ALL_MEM_MAX_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._all_mem_max = result.value;
                },
                ProcessRenderInfoWire.ALL_MEM_MIN_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._all_mem_min = result.value;
                },
                ProcessRenderInfoWire.ALL_MEM_AVG_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._all_mem_avg = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getProcessName(self: *const ProcessRenderInfoReader) []const u8 {
        return self._process_name orelse &[_]u8{};
    }
    pub inline fn getRtCpuTimeMs(self: *const ProcessRenderInfoReader) i64 {
        return self._rt_cpu_time_ms;
    }
    pub inline fn getDrawFrameCount(self: *const ProcessRenderInfoReader) u32 {
        return self._draw_frame_count;
    }
    pub inline fn getDrawFrameMax(self: *const ProcessRenderInfoReader) i64 {
        return self._draw_frame_max;
    }
    pub inline fn getDrawFrameMin(self: *const ProcessRenderInfoReader) i64 {
        return self._draw_frame_min;
    }
    pub inline fn getDrawFrameAvg(self: *const ProcessRenderInfoReader) f64 {
        return self._draw_frame_avg;
    }
    pub inline fn getFlushCount(self: *const ProcessRenderInfoReader) u32 {
        return self._flush_count;
    }
    pub inline fn getFlushMax(self: *const ProcessRenderInfoReader) i64 {
        return self._flush_max;
    }
    pub inline fn getFlushMin(self: *const ProcessRenderInfoReader) i64 {
        return self._flush_min;
    }
    pub inline fn getFlushAvg(self: *const ProcessRenderInfoReader) f64 {
        return self._flush_avg;
    }
    pub inline fn getPrepareTreeCount(self: *const ProcessRenderInfoReader) u32 {
        return self._prepare_tree_count;
    }
    pub inline fn getPrepareTreeMax(self: *const ProcessRenderInfoReader) i64 {
        return self._prepare_tree_max;
    }
    pub inline fn getPrepareTreeMin(self: *const ProcessRenderInfoReader) i64 {
        return self._prepare_tree_min;
    }
    pub inline fn getPrepareTreeAvg(self: *const ProcessRenderInfoReader) f64 {
        return self._prepare_tree_avg;
    }
    pub inline fn getGpuCompletionCount(self: *const ProcessRenderInfoReader) u32 {
        return self._gpu_completion_count;
    }
    pub inline fn getGpuCompletionMax(self: *const ProcessRenderInfoReader) i64 {
        return self._gpu_completion_max;
    }
    pub inline fn getGpuCompletionMin(self: *const ProcessRenderInfoReader) i64 {
        return self._gpu_completion_min;
    }
    pub inline fn getGpuCompletionAvg(self: *const ProcessRenderInfoReader) f64 {
        return self._gpu_completion_avg;
    }
    pub inline fn getUiRecordCount(self: *const ProcessRenderInfoReader) u32 {
        return self._ui_record_count;
    }
    pub inline fn getUiRecordMax(self: *const ProcessRenderInfoReader) i64 {
        return self._ui_record_max;
    }
    pub inline fn getUiRecordMin(self: *const ProcessRenderInfoReader) i64 {
        return self._ui_record_min;
    }
    pub inline fn getUiRecordAvg(self: *const ProcessRenderInfoReader) f64 {
        return self._ui_record_avg;
    }
    pub inline fn getShaderCompileCount(self: *const ProcessRenderInfoReader) u32 {
        return self._shader_compile_count;
    }
    pub inline fn getShaderCompileTime(self: *const ProcessRenderInfoReader) i64 {
        return self._shader_compile_time;
    }
    pub inline fn getShaderCompileAvg(self: *const ProcessRenderInfoReader) f64 {
        return self._shader_compile_avg;
    }
    pub inline fn getCacheHitCount(self: *const ProcessRenderInfoReader) u32 {
        return self._cache_hit_count;
    }
    pub inline fn getCacheHitTime(self: *const ProcessRenderInfoReader) i64 {
        return self._cache_hit_time;
    }
    pub inline fn getCacheHitAvg(self: *const ProcessRenderInfoReader) f64 {
        return self._cache_hit_avg;
    }
    pub inline fn getCacheMissCount(self: *const ProcessRenderInfoReader) u32 {
        return self._cache_miss_count;
    }
    pub inline fn getCacheMissTime(self: *const ProcessRenderInfoReader) i64 {
        return self._cache_miss_time;
    }
    pub inline fn getCacheMissAvg(self: *const ProcessRenderInfoReader) f64 {
        return self._cache_miss_avg;
    }
    pub inline fn getGraphicsCpuMemMax(self: *const ProcessRenderInfoReader) i64 {
        return self._graphics_cpu_mem_max;
    }
    pub inline fn getGraphicsCpuMemMin(self: *const ProcessRenderInfoReader) i64 {
        return self._graphics_cpu_mem_min;
    }
    pub inline fn getGraphicsCpuMemAvg(self: *const ProcessRenderInfoReader) f64 {
        return self._graphics_cpu_mem_avg;
    }
    pub inline fn getGraphicsGpuMemMax(self: *const ProcessRenderInfoReader) i64 {
        return self._graphics_gpu_mem_max;
    }
    pub inline fn getGraphicsGpuMemMin(self: *const ProcessRenderInfoReader) i64 {
        return self._graphics_gpu_mem_min;
    }
    pub inline fn getGraphicsGpuMemAvg(self: *const ProcessRenderInfoReader) f64 {
        return self._graphics_gpu_mem_avg;
    }
    pub inline fn getTextureMemMax(self: *const ProcessRenderInfoReader) i64 {
        return self._texture_mem_max;
    }
    pub inline fn getTextureMemMin(self: *const ProcessRenderInfoReader) i64 {
        return self._texture_mem_min;
    }
    pub inline fn getTextureMemAvg(self: *const ProcessRenderInfoReader) f64 {
        return self._texture_mem_avg;
    }
    pub inline fn getAllMemMax(self: *const ProcessRenderInfoReader) i64 {
        return self._all_mem_max;
    }
    pub inline fn getAllMemMin(self: *const ProcessRenderInfoReader) i64 {
        return self._all_mem_min;
    }
    pub inline fn getAllMemAvg(self: *const ProcessRenderInfoReader) f64 {
        return self._all_mem_avg;
    }
};
const AndroidHwuiMetricWire = struct {
    const PROCESS_INFO_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const AndroidHwuiMetric = struct {
    // fields
    process_info: ?[]const ?ProcessRenderInfo = null,
    pub fn calcProtobufSize(self: *const AndroidHwuiMetric) usize {
        var res: usize = 0;
        if (self.process_info) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidHwuiMetricWire.PROCESS_INFO_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidHwuiMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidHwuiMetric, target: *gremlin.Writer) void {
        if (self.process_info) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidHwuiMetricWire.PROCESS_INFO_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidHwuiMetricWire.PROCESS_INFO_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidHwuiMetricReader = struct {
    buf: gremlin.Reader,
    _process_info_offset: ?usize = null,
    _process_info_last_offset: ?usize = null,
    _process_info_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidHwuiMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidHwuiMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidHwuiMetricWire.PROCESS_INFO_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._process_info_offset == null) {
                        res._process_info_offset = offset - result.size;
                    }
                    res._process_info_last_offset = offset;
                    res._process_info_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn processInfoCount(self: *const AndroidHwuiMetricReader) usize {
        return self._process_info_cnt;
    }
    pub fn processInfoNext(self: *AndroidHwuiMetricReader) ?ProcessRenderInfoReader {
        if (self._process_info_offset == null) return null;
        const current_offset = self._process_info_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = ProcessRenderInfoReader.init(result.value) catch return null;
        if (self._process_info_last_offset != null and current_offset >= self._process_info_last_offset.?) {
            self._process_info_offset = null;
            return msg;
        }
        if (self._process_info_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._process_info_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidHwuiMetricWire.PROCESS_INFO_WIRE) {
                self._process_info_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._process_info_offset = null;
        return msg;
    }
};
const AndroidIoWire = struct {
    const F2FS_COUNTER_STATS_WIRE: gremlin.ProtoWireNumber = 1;
    const F2FS_WRITE_STATS_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const AndroidIo = struct {
    // nested structs
    const F2fsCounterStatsWire = struct {
        const NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const MAX_WIRE: gremlin.ProtoWireNumber = 2;
        const SUM_WIRE: gremlin.ProtoWireNumber = 3;
        const MIN_WIRE: gremlin.ProtoWireNumber = 5;
        const DUR_WIRE: gremlin.ProtoWireNumber = 6;
        const COUNT_WIRE: gremlin.ProtoWireNumber = 7;
        const AVG_WIRE: gremlin.ProtoWireNumber = 8;
    };
    pub const F2fsCounterStats = struct {
        // fields
        name: ?[]const u8 = null,
        max: f64 = 0.0,
        sum: f64 = 0.0,
        min: f64 = 0.0,
        dur: i64 = 0,
        count: i64 = 0,
        avg: f64 = 0.0,
        pub fn calcProtobufSize(self: *const AndroidIo.F2fsCounterStats) usize {
            var res: usize = 0;
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidIo.F2fsCounterStatsWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.max != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidIo.F2fsCounterStatsWire.MAX_WIRE) + gremlin.sizes.sizeDouble(self.max);
            }
            if (self.sum != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidIo.F2fsCounterStatsWire.SUM_WIRE) + gremlin.sizes.sizeDouble(self.sum);
            }
            if (self.min != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidIo.F2fsCounterStatsWire.MIN_WIRE) + gremlin.sizes.sizeDouble(self.min);
            }
            if (self.dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidIo.F2fsCounterStatsWire.DUR_WIRE) + gremlin.sizes.sizeI64(self.dur);
            }
            if (self.count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidIo.F2fsCounterStatsWire.COUNT_WIRE) + gremlin.sizes.sizeI64(self.count);
            }
            if (self.avg != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidIo.F2fsCounterStatsWire.AVG_WIRE) + gremlin.sizes.sizeDouble(self.avg);
            }
            return res;
        }
        pub fn encode(self: *const AndroidIo.F2fsCounterStats, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidIo.F2fsCounterStats, target: *gremlin.Writer) void {
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidIo.F2fsCounterStatsWire.NAME_WIRE, v);
                }
            }
            if (self.max != 0.0) {
                target.appendFloat64(AndroidIo.F2fsCounterStatsWire.MAX_WIRE, self.max);
            }
            if (self.sum != 0.0) {
                target.appendFloat64(AndroidIo.F2fsCounterStatsWire.SUM_WIRE, self.sum);
            }
            if (self.min != 0.0) {
                target.appendFloat64(AndroidIo.F2fsCounterStatsWire.MIN_WIRE, self.min);
            }
            if (self.dur != 0) {
                target.appendInt64(AndroidIo.F2fsCounterStatsWire.DUR_WIRE, self.dur);
            }
            if (self.count != 0) {
                target.appendInt64(AndroidIo.F2fsCounterStatsWire.COUNT_WIRE, self.count);
            }
            if (self.avg != 0.0) {
                target.appendFloat64(AndroidIo.F2fsCounterStatsWire.AVG_WIRE, self.avg);
            }
        }
    };
    pub const F2fsCounterStatsReader = struct {
        buf: gremlin.Reader,
        _name: ?[]const u8 = null,
        _max: f64 = 0.0,
        _sum: f64 = 0.0,
        _min: f64 = 0.0,
        _dur: i64 = 0,
        _count: i64 = 0,
        _avg: f64 = 0.0,
        pub fn init(src: []const u8) gremlin.Error!AndroidIo.F2fsCounterStatsReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidIo.F2fsCounterStatsReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidIo.F2fsCounterStatsWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    AndroidIo.F2fsCounterStatsWire.MAX_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._max = result.value;
                    },
                    AndroidIo.F2fsCounterStatsWire.SUM_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._sum = result.value;
                    },
                    AndroidIo.F2fsCounterStatsWire.MIN_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._min = result.value;
                    },
                    AndroidIo.F2fsCounterStatsWire.DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._dur = result.value;
                    },
                    AndroidIo.F2fsCounterStatsWire.COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._count = result.value;
                    },
                    AndroidIo.F2fsCounterStatsWire.AVG_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._avg = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getName(self: *const AndroidIo.F2fsCounterStatsReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub inline fn getMax(self: *const AndroidIo.F2fsCounterStatsReader) f64 {
            return self._max;
        }
        pub inline fn getSum(self: *const AndroidIo.F2fsCounterStatsReader) f64 {
            return self._sum;
        }
        pub inline fn getMin(self: *const AndroidIo.F2fsCounterStatsReader) f64 {
            return self._min;
        }
        pub inline fn getDur(self: *const AndroidIo.F2fsCounterStatsReader) i64 {
            return self._dur;
        }
        pub inline fn getCount(self: *const AndroidIo.F2fsCounterStatsReader) i64 {
            return self._count;
        }
        pub inline fn getAvg(self: *const AndroidIo.F2fsCounterStatsReader) f64 {
            return self._avg;
        }
    };
    const F2fsWriteStatsWire = struct {
        const TOTAL_WRITE_COUNT_WIRE: gremlin.ProtoWireNumber = 1;
        const DISTINCT_PROCESSES_WIRE: gremlin.ProtoWireNumber = 2;
        const TOTAL_BYTES_WRITTEN_WIRE: gremlin.ProtoWireNumber = 3;
        const DISTINCT_DEVICE_COUNT_WIRE: gremlin.ProtoWireNumber = 4;
        const DISTINCT_INODE_COUNT_WIRE: gremlin.ProtoWireNumber = 5;
        const DISTINCT_THREAD_COUNT_WIRE: gremlin.ProtoWireNumber = 6;
    };
    pub const F2fsWriteStats = struct {
        // fields
        total_write_count: i64 = 0,
        distinct_processes: i64 = 0,
        total_bytes_written: i64 = 0,
        distinct_device_count: i64 = 0,
        distinct_inode_count: i64 = 0,
        distinct_thread_count: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidIo.F2fsWriteStats) usize {
            var res: usize = 0;
            if (self.total_write_count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidIo.F2fsWriteStatsWire.TOTAL_WRITE_COUNT_WIRE) + gremlin.sizes.sizeI64(self.total_write_count);
            }
            if (self.distinct_processes != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidIo.F2fsWriteStatsWire.DISTINCT_PROCESSES_WIRE) + gremlin.sizes.sizeI64(self.distinct_processes);
            }
            if (self.total_bytes_written != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidIo.F2fsWriteStatsWire.TOTAL_BYTES_WRITTEN_WIRE) + gremlin.sizes.sizeI64(self.total_bytes_written);
            }
            if (self.distinct_device_count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidIo.F2fsWriteStatsWire.DISTINCT_DEVICE_COUNT_WIRE) + gremlin.sizes.sizeI64(self.distinct_device_count);
            }
            if (self.distinct_inode_count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidIo.F2fsWriteStatsWire.DISTINCT_INODE_COUNT_WIRE) + gremlin.sizes.sizeI64(self.distinct_inode_count);
            }
            if (self.distinct_thread_count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidIo.F2fsWriteStatsWire.DISTINCT_THREAD_COUNT_WIRE) + gremlin.sizes.sizeI64(self.distinct_thread_count);
            }
            return res;
        }
        pub fn encode(self: *const AndroidIo.F2fsWriteStats, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidIo.F2fsWriteStats, target: *gremlin.Writer) void {
            if (self.total_write_count != 0) {
                target.appendInt64(AndroidIo.F2fsWriteStatsWire.TOTAL_WRITE_COUNT_WIRE, self.total_write_count);
            }
            if (self.distinct_processes != 0) {
                target.appendInt64(AndroidIo.F2fsWriteStatsWire.DISTINCT_PROCESSES_WIRE, self.distinct_processes);
            }
            if (self.total_bytes_written != 0) {
                target.appendInt64(AndroidIo.F2fsWriteStatsWire.TOTAL_BYTES_WRITTEN_WIRE, self.total_bytes_written);
            }
            if (self.distinct_device_count != 0) {
                target.appendInt64(AndroidIo.F2fsWriteStatsWire.DISTINCT_DEVICE_COUNT_WIRE, self.distinct_device_count);
            }
            if (self.distinct_inode_count != 0) {
                target.appendInt64(AndroidIo.F2fsWriteStatsWire.DISTINCT_INODE_COUNT_WIRE, self.distinct_inode_count);
            }
            if (self.distinct_thread_count != 0) {
                target.appendInt64(AndroidIo.F2fsWriteStatsWire.DISTINCT_THREAD_COUNT_WIRE, self.distinct_thread_count);
            }
        }
    };
    pub const F2fsWriteStatsReader = struct {
        buf: gremlin.Reader,
        _total_write_count: i64 = 0,
        _distinct_processes: i64 = 0,
        _total_bytes_written: i64 = 0,
        _distinct_device_count: i64 = 0,
        _distinct_inode_count: i64 = 0,
        _distinct_thread_count: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidIo.F2fsWriteStatsReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidIo.F2fsWriteStatsReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidIo.F2fsWriteStatsWire.TOTAL_WRITE_COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._total_write_count = result.value;
                    },
                    AndroidIo.F2fsWriteStatsWire.DISTINCT_PROCESSES_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._distinct_processes = result.value;
                    },
                    AndroidIo.F2fsWriteStatsWire.TOTAL_BYTES_WRITTEN_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._total_bytes_written = result.value;
                    },
                    AndroidIo.F2fsWriteStatsWire.DISTINCT_DEVICE_COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._distinct_device_count = result.value;
                    },
                    AndroidIo.F2fsWriteStatsWire.DISTINCT_INODE_COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._distinct_inode_count = result.value;
                    },
                    AndroidIo.F2fsWriteStatsWire.DISTINCT_THREAD_COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._distinct_thread_count = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getTotalWriteCount(self: *const AndroidIo.F2fsWriteStatsReader) i64 {
            return self._total_write_count;
        }
        pub inline fn getDistinctProcesses(self: *const AndroidIo.F2fsWriteStatsReader) i64 {
            return self._distinct_processes;
        }
        pub inline fn getTotalBytesWritten(self: *const AndroidIo.F2fsWriteStatsReader) i64 {
            return self._total_bytes_written;
        }
        pub inline fn getDistinctDeviceCount(self: *const AndroidIo.F2fsWriteStatsReader) i64 {
            return self._distinct_device_count;
        }
        pub inline fn getDistinctInodeCount(self: *const AndroidIo.F2fsWriteStatsReader) i64 {
            return self._distinct_inode_count;
        }
        pub inline fn getDistinctThreadCount(self: *const AndroidIo.F2fsWriteStatsReader) i64 {
            return self._distinct_thread_count;
        }
    };
    // fields
    f2fs_counter_stats: ?[]const ?AndroidIo.F2fsCounterStats = null,
    f2fs_write_stats: ?[]const ?AndroidIo.F2fsWriteStats = null,
    pub fn calcProtobufSize(self: *const AndroidIo) usize {
        var res: usize = 0;
        if (self.f2fs_counter_stats) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidIoWire.F2FS_COUNTER_STATS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.f2fs_write_stats) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidIoWire.F2FS_WRITE_STATS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidIo, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidIo, target: *gremlin.Writer) void {
        if (self.f2fs_counter_stats) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidIoWire.F2FS_COUNTER_STATS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidIoWire.F2FS_COUNTER_STATS_WIRE, 0);
                }
            }
        }
        if (self.f2fs_write_stats) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidIoWire.F2FS_WRITE_STATS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidIoWire.F2FS_WRITE_STATS_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidIoReader = struct {
    buf: gremlin.Reader,
    _f2fs_counter_stats_offset: ?usize = null,
    _f2fs_counter_stats_last_offset: ?usize = null,
    _f2fs_counter_stats_cnt: usize = 0,
    _f2fs_write_stats_offset: ?usize = null,
    _f2fs_write_stats_last_offset: ?usize = null,
    _f2fs_write_stats_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidIoReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidIoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidIoWire.F2FS_COUNTER_STATS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._f2fs_counter_stats_offset == null) {
                        res._f2fs_counter_stats_offset = offset - result.size;
                    }
                    res._f2fs_counter_stats_last_offset = offset;
                    res._f2fs_counter_stats_cnt += 1;
                },
                AndroidIoWire.F2FS_WRITE_STATS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._f2fs_write_stats_offset == null) {
                        res._f2fs_write_stats_offset = offset - result.size;
                    }
                    res._f2fs_write_stats_last_offset = offset;
                    res._f2fs_write_stats_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn f2fsCounterStatsCount(self: *const AndroidIoReader) usize {
        return self._f2fs_counter_stats_cnt;
    }
    pub fn f2fsCounterStatsNext(self: *AndroidIoReader) ?AndroidIo.F2fsCounterStatsReader {
        if (self._f2fs_counter_stats_offset == null) return null;
        const current_offset = self._f2fs_counter_stats_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidIo.F2fsCounterStatsReader.init(result.value) catch return null;
        if (self._f2fs_counter_stats_last_offset != null and current_offset >= self._f2fs_counter_stats_last_offset.?) {
            self._f2fs_counter_stats_offset = null;
            return msg;
        }
        if (self._f2fs_counter_stats_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._f2fs_counter_stats_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidIoWire.F2FS_COUNTER_STATS_WIRE) {
                self._f2fs_counter_stats_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._f2fs_counter_stats_offset = null;
        return msg;
    }
    pub fn f2fsWriteStatsCount(self: *const AndroidIoReader) usize {
        return self._f2fs_write_stats_cnt;
    }
    pub fn f2fsWriteStatsNext(self: *AndroidIoReader) ?AndroidIo.F2fsWriteStatsReader {
        if (self._f2fs_write_stats_offset == null) return null;
        const current_offset = self._f2fs_write_stats_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidIo.F2fsWriteStatsReader.init(result.value) catch return null;
        if (self._f2fs_write_stats_last_offset != null and current_offset >= self._f2fs_write_stats_last_offset.?) {
            self._f2fs_write_stats_offset = null;
            return msg;
        }
        if (self._f2fs_write_stats_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._f2fs_write_stats_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidIoWire.F2FS_WRITE_STATS_WIRE) {
                self._f2fs_write_stats_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._f2fs_write_stats_offset = null;
        return msg;
    }
};
const AndroidIoUnaggregatedWire = struct {
    const F2FS_WRITE_UNAGGREGATED_STATS_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const AndroidIoUnaggregated = struct {
    // nested structs
    const F2fsWriteUnaggreagatedStatWire = struct {
        const TID_WIRE: gremlin.ProtoWireNumber = 1;
        const THREAD_NAME_WIRE: gremlin.ProtoWireNumber = 2;
        const PID_WIRE: gremlin.ProtoWireNumber = 3;
        const PROCESS_NAME_WIRE: gremlin.ProtoWireNumber = 4;
        const INO_WIRE: gremlin.ProtoWireNumber = 5;
        const DEV_WIRE: gremlin.ProtoWireNumber = 6;
    };
    pub const F2fsWriteUnaggreagatedStat = struct {
        // fields
        tid: u32 = 0,
        thread_name: ?[]const u8 = null,
        pid: u32 = 0,
        process_name: ?[]const u8 = null,
        ino: i64 = 0,
        dev: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidIoUnaggregated.F2fsWriteUnaggreagatedStat) usize {
            var res: usize = 0;
            if (self.tid != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidIoUnaggregated.F2fsWriteUnaggreagatedStatWire.TID_WIRE) + gremlin.sizes.sizeU32(self.tid);
            }
            if (self.thread_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidIoUnaggregated.F2fsWriteUnaggreagatedStatWire.THREAD_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.pid != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidIoUnaggregated.F2fsWriteUnaggreagatedStatWire.PID_WIRE) + gremlin.sizes.sizeU32(self.pid);
            }
            if (self.process_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidIoUnaggregated.F2fsWriteUnaggreagatedStatWire.PROCESS_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.ino != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidIoUnaggregated.F2fsWriteUnaggreagatedStatWire.INO_WIRE) + gremlin.sizes.sizeI64(self.ino);
            }
            if (self.dev != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidIoUnaggregated.F2fsWriteUnaggreagatedStatWire.DEV_WIRE) + gremlin.sizes.sizeI64(self.dev);
            }
            return res;
        }
        pub fn encode(self: *const AndroidIoUnaggregated.F2fsWriteUnaggreagatedStat, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidIoUnaggregated.F2fsWriteUnaggreagatedStat, target: *gremlin.Writer) void {
            if (self.tid != 0) {
                target.appendUint32(AndroidIoUnaggregated.F2fsWriteUnaggreagatedStatWire.TID_WIRE, self.tid);
            }
            if (self.thread_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidIoUnaggregated.F2fsWriteUnaggreagatedStatWire.THREAD_NAME_WIRE, v);
                }
            }
            if (self.pid != 0) {
                target.appendUint32(AndroidIoUnaggregated.F2fsWriteUnaggreagatedStatWire.PID_WIRE, self.pid);
            }
            if (self.process_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidIoUnaggregated.F2fsWriteUnaggreagatedStatWire.PROCESS_NAME_WIRE, v);
                }
            }
            if (self.ino != 0) {
                target.appendInt64(AndroidIoUnaggregated.F2fsWriteUnaggreagatedStatWire.INO_WIRE, self.ino);
            }
            if (self.dev != 0) {
                target.appendInt64(AndroidIoUnaggregated.F2fsWriteUnaggreagatedStatWire.DEV_WIRE, self.dev);
            }
        }
    };
    pub const F2fsWriteUnaggreagatedStatReader = struct {
        buf: gremlin.Reader,
        _tid: u32 = 0,
        _thread_name: ?[]const u8 = null,
        _pid: u32 = 0,
        _process_name: ?[]const u8 = null,
        _ino: i64 = 0,
        _dev: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidIoUnaggregated.F2fsWriteUnaggreagatedStatReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidIoUnaggregated.F2fsWriteUnaggreagatedStatReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidIoUnaggregated.F2fsWriteUnaggreagatedStatWire.TID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._tid = result.value;
                    },
                    AndroidIoUnaggregated.F2fsWriteUnaggreagatedStatWire.THREAD_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._thread_name = result.value;
                    },
                    AndroidIoUnaggregated.F2fsWriteUnaggreagatedStatWire.PID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._pid = result.value;
                    },
                    AndroidIoUnaggregated.F2fsWriteUnaggreagatedStatWire.PROCESS_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._process_name = result.value;
                    },
                    AndroidIoUnaggregated.F2fsWriteUnaggreagatedStatWire.INO_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._ino = result.value;
                    },
                    AndroidIoUnaggregated.F2fsWriteUnaggreagatedStatWire.DEV_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._dev = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getTid(self: *const AndroidIoUnaggregated.F2fsWriteUnaggreagatedStatReader) u32 {
            return self._tid;
        }
        pub inline fn getThreadName(self: *const AndroidIoUnaggregated.F2fsWriteUnaggreagatedStatReader) []const u8 {
            return self._thread_name orelse &[_]u8{};
        }
        pub inline fn getPid(self: *const AndroidIoUnaggregated.F2fsWriteUnaggreagatedStatReader) u32 {
            return self._pid;
        }
        pub inline fn getProcessName(self: *const AndroidIoUnaggregated.F2fsWriteUnaggreagatedStatReader) []const u8 {
            return self._process_name orelse &[_]u8{};
        }
        pub inline fn getIno(self: *const AndroidIoUnaggregated.F2fsWriteUnaggreagatedStatReader) i64 {
            return self._ino;
        }
        pub inline fn getDev(self: *const AndroidIoUnaggregated.F2fsWriteUnaggreagatedStatReader) i64 {
            return self._dev;
        }
    };
    // fields
    f2fs_write_unaggregated_stats: ?[]const ?AndroidIoUnaggregated.F2fsWriteUnaggreagatedStat = null,
    pub fn calcProtobufSize(self: *const AndroidIoUnaggregated) usize {
        var res: usize = 0;
        if (self.f2fs_write_unaggregated_stats) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidIoUnaggregatedWire.F2FS_WRITE_UNAGGREGATED_STATS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidIoUnaggregated, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidIoUnaggregated, target: *gremlin.Writer) void {
        if (self.f2fs_write_unaggregated_stats) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidIoUnaggregatedWire.F2FS_WRITE_UNAGGREGATED_STATS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidIoUnaggregatedWire.F2FS_WRITE_UNAGGREGATED_STATS_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidIoUnaggregatedReader = struct {
    buf: gremlin.Reader,
    _f2fs_write_unaggregated_stats_offset: ?usize = null,
    _f2fs_write_unaggregated_stats_last_offset: ?usize = null,
    _f2fs_write_unaggregated_stats_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidIoUnaggregatedReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidIoUnaggregatedReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidIoUnaggregatedWire.F2FS_WRITE_UNAGGREGATED_STATS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._f2fs_write_unaggregated_stats_offset == null) {
                        res._f2fs_write_unaggregated_stats_offset = offset - result.size;
                    }
                    res._f2fs_write_unaggregated_stats_last_offset = offset;
                    res._f2fs_write_unaggregated_stats_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn f2fsWriteUnaggregatedStatsCount(self: *const AndroidIoUnaggregatedReader) usize {
        return self._f2fs_write_unaggregated_stats_cnt;
    }
    pub fn f2fsWriteUnaggregatedStatsNext(self: *AndroidIoUnaggregatedReader) ?AndroidIoUnaggregated.F2fsWriteUnaggreagatedStatReader {
        if (self._f2fs_write_unaggregated_stats_offset == null) return null;
        const current_offset = self._f2fs_write_unaggregated_stats_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidIoUnaggregated.F2fsWriteUnaggreagatedStatReader.init(result.value) catch return null;
        if (self._f2fs_write_unaggregated_stats_last_offset != null and current_offset >= self._f2fs_write_unaggregated_stats_last_offset.?) {
            self._f2fs_write_unaggregated_stats_offset = null;
            return msg;
        }
        if (self._f2fs_write_unaggregated_stats_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._f2fs_write_unaggregated_stats_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidIoUnaggregatedWire.F2FS_WRITE_UNAGGREGATED_STATS_WIRE) {
                self._f2fs_write_unaggregated_stats_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._f2fs_write_unaggregated_stats_offset = null;
        return msg;
    }
};
const AndroidIonMetricWire = struct {
    const BUFFER_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const AndroidIonMetric = struct {
    // nested structs
    const BufferWire = struct {
        const NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const AVG_SIZE_BYTES_WIRE: gremlin.ProtoWireNumber = 2;
        const MIN_SIZE_BYTES_WIRE: gremlin.ProtoWireNumber = 3;
        const MAX_SIZE_BYTES_WIRE: gremlin.ProtoWireNumber = 4;
        const TOTAL_ALLOC_SIZE_BYTES_WIRE: gremlin.ProtoWireNumber = 5;
    };
    pub const Buffer = struct {
        // fields
        name: ?[]const u8 = null,
        avg_size_bytes: f64 = 0.0,
        min_size_bytes: f64 = 0.0,
        max_size_bytes: f64 = 0.0,
        total_alloc_size_bytes: f64 = 0.0,
        pub fn calcProtobufSize(self: *const AndroidIonMetric.Buffer) usize {
            var res: usize = 0;
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidIonMetric.BufferWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.avg_size_bytes != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidIonMetric.BufferWire.AVG_SIZE_BYTES_WIRE) + gremlin.sizes.sizeDouble(self.avg_size_bytes);
            }
            if (self.min_size_bytes != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidIonMetric.BufferWire.MIN_SIZE_BYTES_WIRE) + gremlin.sizes.sizeDouble(self.min_size_bytes);
            }
            if (self.max_size_bytes != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidIonMetric.BufferWire.MAX_SIZE_BYTES_WIRE) + gremlin.sizes.sizeDouble(self.max_size_bytes);
            }
            if (self.total_alloc_size_bytes != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidIonMetric.BufferWire.TOTAL_ALLOC_SIZE_BYTES_WIRE) + gremlin.sizes.sizeDouble(self.total_alloc_size_bytes);
            }
            return res;
        }
        pub fn encode(self: *const AndroidIonMetric.Buffer, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidIonMetric.Buffer, target: *gremlin.Writer) void {
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidIonMetric.BufferWire.NAME_WIRE, v);
                }
            }
            if (self.avg_size_bytes != 0.0) {
                target.appendFloat64(AndroidIonMetric.BufferWire.AVG_SIZE_BYTES_WIRE, self.avg_size_bytes);
            }
            if (self.min_size_bytes != 0.0) {
                target.appendFloat64(AndroidIonMetric.BufferWire.MIN_SIZE_BYTES_WIRE, self.min_size_bytes);
            }
            if (self.max_size_bytes != 0.0) {
                target.appendFloat64(AndroidIonMetric.BufferWire.MAX_SIZE_BYTES_WIRE, self.max_size_bytes);
            }
            if (self.total_alloc_size_bytes != 0.0) {
                target.appendFloat64(AndroidIonMetric.BufferWire.TOTAL_ALLOC_SIZE_BYTES_WIRE, self.total_alloc_size_bytes);
            }
        }
    };
    pub const BufferReader = struct {
        buf: gremlin.Reader,
        _name: ?[]const u8 = null,
        _avg_size_bytes: f64 = 0.0,
        _min_size_bytes: f64 = 0.0,
        _max_size_bytes: f64 = 0.0,
        _total_alloc_size_bytes: f64 = 0.0,
        pub fn init(src: []const u8) gremlin.Error!AndroidIonMetric.BufferReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidIonMetric.BufferReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidIonMetric.BufferWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    AndroidIonMetric.BufferWire.AVG_SIZE_BYTES_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._avg_size_bytes = result.value;
                    },
                    AndroidIonMetric.BufferWire.MIN_SIZE_BYTES_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._min_size_bytes = result.value;
                    },
                    AndroidIonMetric.BufferWire.MAX_SIZE_BYTES_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._max_size_bytes = result.value;
                    },
                    AndroidIonMetric.BufferWire.TOTAL_ALLOC_SIZE_BYTES_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._total_alloc_size_bytes = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getName(self: *const AndroidIonMetric.BufferReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub inline fn getAvgSizeBytes(self: *const AndroidIonMetric.BufferReader) f64 {
            return self._avg_size_bytes;
        }
        pub inline fn getMinSizeBytes(self: *const AndroidIonMetric.BufferReader) f64 {
            return self._min_size_bytes;
        }
        pub inline fn getMaxSizeBytes(self: *const AndroidIonMetric.BufferReader) f64 {
            return self._max_size_bytes;
        }
        pub inline fn getTotalAllocSizeBytes(self: *const AndroidIonMetric.BufferReader) f64 {
            return self._total_alloc_size_bytes;
        }
    };
    // fields
    buffer: ?[]const ?AndroidIonMetric.Buffer = null,
    pub fn calcProtobufSize(self: *const AndroidIonMetric) usize {
        var res: usize = 0;
        if (self.buffer) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidIonMetricWire.BUFFER_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidIonMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidIonMetric, target: *gremlin.Writer) void {
        if (self.buffer) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidIonMetricWire.BUFFER_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidIonMetricWire.BUFFER_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidIonMetricReader = struct {
    buf: gremlin.Reader,
    _buffer_offset: ?usize = null,
    _buffer_last_offset: ?usize = null,
    _buffer_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidIonMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidIonMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidIonMetricWire.BUFFER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._buffer_offset == null) {
                        res._buffer_offset = offset - result.size;
                    }
                    res._buffer_last_offset = offset;
                    res._buffer_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn bufferCount(self: *const AndroidIonMetricReader) usize {
        return self._buffer_cnt;
    }
    pub fn bufferNext(self: *AndroidIonMetricReader) ?AndroidIonMetric.BufferReader {
        if (self._buffer_offset == null) return null;
        const current_offset = self._buffer_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidIonMetric.BufferReader.init(result.value) catch return null;
        if (self._buffer_last_offset != null and current_offset >= self._buffer_last_offset.?) {
            self._buffer_offset = null;
            return msg;
        }
        if (self._buffer_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._buffer_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidIonMetricWire.BUFFER_WIRE) {
                self._buffer_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._buffer_offset = null;
        return msg;
    }
};
const AndroidIrqRuntimeMetricWire = struct {
    const HW_IRQ_WIRE: gremlin.ProtoWireNumber = 1;
    const SW_IRQ_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const AndroidIrqRuntimeMetric = struct {
    // nested structs
    const IrqSliceWire = struct {
        const IRQ_NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const TS_WIRE: gremlin.ProtoWireNumber = 2;
        const DUR_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const IrqSlice = struct {
        // fields
        irq_name: ?[]const u8 = null,
        ts: i64 = 0,
        dur: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidIrqRuntimeMetric.IrqSlice) usize {
            var res: usize = 0;
            if (self.irq_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidIrqRuntimeMetric.IrqSliceWire.IRQ_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.ts != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidIrqRuntimeMetric.IrqSliceWire.TS_WIRE) + gremlin.sizes.sizeI64(self.ts);
            }
            if (self.dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidIrqRuntimeMetric.IrqSliceWire.DUR_WIRE) + gremlin.sizes.sizeI64(self.dur);
            }
            return res;
        }
        pub fn encode(self: *const AndroidIrqRuntimeMetric.IrqSlice, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidIrqRuntimeMetric.IrqSlice, target: *gremlin.Writer) void {
            if (self.irq_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidIrqRuntimeMetric.IrqSliceWire.IRQ_NAME_WIRE, v);
                }
            }
            if (self.ts != 0) {
                target.appendInt64(AndroidIrqRuntimeMetric.IrqSliceWire.TS_WIRE, self.ts);
            }
            if (self.dur != 0) {
                target.appendInt64(AndroidIrqRuntimeMetric.IrqSliceWire.DUR_WIRE, self.dur);
            }
        }
    };
    pub const IrqSliceReader = struct {
        buf: gremlin.Reader,
        _irq_name: ?[]const u8 = null,
        _ts: i64 = 0,
        _dur: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidIrqRuntimeMetric.IrqSliceReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidIrqRuntimeMetric.IrqSliceReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidIrqRuntimeMetric.IrqSliceWire.IRQ_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._irq_name = result.value;
                    },
                    AndroidIrqRuntimeMetric.IrqSliceWire.TS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._ts = result.value;
                    },
                    AndroidIrqRuntimeMetric.IrqSliceWire.DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._dur = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getIrqName(self: *const AndroidIrqRuntimeMetric.IrqSliceReader) []const u8 {
            return self._irq_name orelse &[_]u8{};
        }
        pub inline fn getTs(self: *const AndroidIrqRuntimeMetric.IrqSliceReader) i64 {
            return self._ts;
        }
        pub inline fn getDur(self: *const AndroidIrqRuntimeMetric.IrqSliceReader) i64 {
            return self._dur;
        }
    };
    const ThresholdMetricWire = struct {
        const THRESHOLD_WIRE: gremlin.ProtoWireNumber = 1;
        const OVER_THRESHOLD_COUNT_WIRE: gremlin.ProtoWireNumber = 2;
        const ANOMALY_RATIO_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const ThresholdMetric = struct {
        // fields
        threshold: ?[]const u8 = null,
        over_threshold_count: i64 = 0,
        anomaly_ratio: f64 = 0.0,
        pub fn calcProtobufSize(self: *const AndroidIrqRuntimeMetric.ThresholdMetric) usize {
            var res: usize = 0;
            if (self.threshold) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidIrqRuntimeMetric.ThresholdMetricWire.THRESHOLD_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.over_threshold_count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidIrqRuntimeMetric.ThresholdMetricWire.OVER_THRESHOLD_COUNT_WIRE) + gremlin.sizes.sizeI64(self.over_threshold_count);
            }
            if (self.anomaly_ratio != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidIrqRuntimeMetric.ThresholdMetricWire.ANOMALY_RATIO_WIRE) + gremlin.sizes.sizeDouble(self.anomaly_ratio);
            }
            return res;
        }
        pub fn encode(self: *const AndroidIrqRuntimeMetric.ThresholdMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidIrqRuntimeMetric.ThresholdMetric, target: *gremlin.Writer) void {
            if (self.threshold) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidIrqRuntimeMetric.ThresholdMetricWire.THRESHOLD_WIRE, v);
                }
            }
            if (self.over_threshold_count != 0) {
                target.appendInt64(AndroidIrqRuntimeMetric.ThresholdMetricWire.OVER_THRESHOLD_COUNT_WIRE, self.over_threshold_count);
            }
            if (self.anomaly_ratio != 0.0) {
                target.appendFloat64(AndroidIrqRuntimeMetric.ThresholdMetricWire.ANOMALY_RATIO_WIRE, self.anomaly_ratio);
            }
        }
    };
    pub const ThresholdMetricReader = struct {
        buf: gremlin.Reader,
        _threshold: ?[]const u8 = null,
        _over_threshold_count: i64 = 0,
        _anomaly_ratio: f64 = 0.0,
        pub fn init(src: []const u8) gremlin.Error!AndroidIrqRuntimeMetric.ThresholdMetricReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidIrqRuntimeMetric.ThresholdMetricReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidIrqRuntimeMetric.ThresholdMetricWire.THRESHOLD_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._threshold = result.value;
                    },
                    AndroidIrqRuntimeMetric.ThresholdMetricWire.OVER_THRESHOLD_COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._over_threshold_count = result.value;
                    },
                    AndroidIrqRuntimeMetric.ThresholdMetricWire.ANOMALY_RATIO_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._anomaly_ratio = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getThreshold(self: *const AndroidIrqRuntimeMetric.ThresholdMetricReader) []const u8 {
            return self._threshold orelse &[_]u8{};
        }
        pub inline fn getOverThresholdCount(self: *const AndroidIrqRuntimeMetric.ThresholdMetricReader) i64 {
            return self._over_threshold_count;
        }
        pub inline fn getAnomalyRatio(self: *const AndroidIrqRuntimeMetric.ThresholdMetricReader) f64 {
            return self._anomaly_ratio;
        }
    };
    const IrqRuntimeMetricWire = struct {
        const MAX_RUNTIME_WIRE: gremlin.ProtoWireNumber = 1;
        const TOTAL_COUNT_WIRE: gremlin.ProtoWireNumber = 2;
        const THRESHOLD_METRIC_WIRE: gremlin.ProtoWireNumber = 3;
        const LONGEST_IRQ_SLICES_WIRE: gremlin.ProtoWireNumber = 4;
    };
    pub const IrqRuntimeMetric = struct {
        // fields
        max_runtime: i64 = 0,
        total_count: i64 = 0,
        threshold_metric: ?AndroidIrqRuntimeMetric.ThresholdMetric = null,
        longest_irq_slices: ?[]const ?AndroidIrqRuntimeMetric.IrqSlice = null,
        pub fn calcProtobufSize(self: *const AndroidIrqRuntimeMetric.IrqRuntimeMetric) usize {
            var res: usize = 0;
            if (self.max_runtime != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidIrqRuntimeMetric.IrqRuntimeMetricWire.MAX_RUNTIME_WIRE) + gremlin.sizes.sizeI64(self.max_runtime);
            }
            if (self.total_count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidIrqRuntimeMetric.IrqRuntimeMetricWire.TOTAL_COUNT_WIRE) + gremlin.sizes.sizeI64(self.total_count);
            }
            if (self.threshold_metric) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidIrqRuntimeMetric.IrqRuntimeMetricWire.THRESHOLD_METRIC_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.longest_irq_slices) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidIrqRuntimeMetric.IrqRuntimeMetricWire.LONGEST_IRQ_SLICES_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidIrqRuntimeMetric.IrqRuntimeMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidIrqRuntimeMetric.IrqRuntimeMetric, target: *gremlin.Writer) void {
            if (self.max_runtime != 0) {
                target.appendInt64(AndroidIrqRuntimeMetric.IrqRuntimeMetricWire.MAX_RUNTIME_WIRE, self.max_runtime);
            }
            if (self.total_count != 0) {
                target.appendInt64(AndroidIrqRuntimeMetric.IrqRuntimeMetricWire.TOTAL_COUNT_WIRE, self.total_count);
            }
            if (self.threshold_metric) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidIrqRuntimeMetric.IrqRuntimeMetricWire.THRESHOLD_METRIC_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.longest_irq_slices) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidIrqRuntimeMetric.IrqRuntimeMetricWire.LONGEST_IRQ_SLICES_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidIrqRuntimeMetric.IrqRuntimeMetricWire.LONGEST_IRQ_SLICES_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const IrqRuntimeMetricReader = struct {
        buf: gremlin.Reader,
        _max_runtime: i64 = 0,
        _total_count: i64 = 0,
        _threshold_metric_buf: ?[]const u8 = null,
        _longest_irq_slices_offset: ?usize = null,
        _longest_irq_slices_last_offset: ?usize = null,
        _longest_irq_slices_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidIrqRuntimeMetric.IrqRuntimeMetricReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidIrqRuntimeMetric.IrqRuntimeMetricReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidIrqRuntimeMetric.IrqRuntimeMetricWire.MAX_RUNTIME_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._max_runtime = result.value;
                    },
                    AndroidIrqRuntimeMetric.IrqRuntimeMetricWire.TOTAL_COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._total_count = result.value;
                    },
                    AndroidIrqRuntimeMetric.IrqRuntimeMetricWire.THRESHOLD_METRIC_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._threshold_metric_buf = result.value;
                    },
                    AndroidIrqRuntimeMetric.IrqRuntimeMetricWire.LONGEST_IRQ_SLICES_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._longest_irq_slices_offset == null) {
                            res._longest_irq_slices_offset = offset - result.size;
                        }
                        res._longest_irq_slices_last_offset = offset;
                        res._longest_irq_slices_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getMaxRuntime(self: *const AndroidIrqRuntimeMetric.IrqRuntimeMetricReader) i64 {
            return self._max_runtime;
        }
        pub inline fn getTotalCount(self: *const AndroidIrqRuntimeMetric.IrqRuntimeMetricReader) i64 {
            return self._total_count;
        }
        pub fn getThresholdMetric(self: *const AndroidIrqRuntimeMetric.IrqRuntimeMetricReader) gremlin.Error!AndroidIrqRuntimeMetric.ThresholdMetricReader {
            if (self._threshold_metric_buf) |buf| {
                return try AndroidIrqRuntimeMetric.ThresholdMetricReader.init(buf);
            }
            return try AndroidIrqRuntimeMetric.ThresholdMetricReader.init(&[_]u8{});
        }
        pub fn longestIrqSlicesCount(self: *const AndroidIrqRuntimeMetric.IrqRuntimeMetricReader) usize {
            return self._longest_irq_slices_cnt;
        }
        pub fn longestIrqSlicesNext(self: *AndroidIrqRuntimeMetric.IrqRuntimeMetricReader) ?AndroidIrqRuntimeMetric.IrqSliceReader {
            if (self._longest_irq_slices_offset == null) return null;
            const current_offset = self._longest_irq_slices_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidIrqRuntimeMetric.IrqSliceReader.init(result.value) catch return null;
            if (self._longest_irq_slices_last_offset != null and current_offset >= self._longest_irq_slices_last_offset.?) {
                self._longest_irq_slices_offset = null;
                return msg;
            }
            if (self._longest_irq_slices_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._longest_irq_slices_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidIrqRuntimeMetric.IrqRuntimeMetricWire.LONGEST_IRQ_SLICES_WIRE) {
                    self._longest_irq_slices_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._longest_irq_slices_offset = null;
            return msg;
        }
    };
    // fields
    hw_irq: ?AndroidIrqRuntimeMetric.IrqRuntimeMetric = null,
    sw_irq: ?AndroidIrqRuntimeMetric.IrqRuntimeMetric = null,
    pub fn calcProtobufSize(self: *const AndroidIrqRuntimeMetric) usize {
        var res: usize = 0;
        if (self.hw_irq) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidIrqRuntimeMetricWire.HW_IRQ_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.sw_irq) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidIrqRuntimeMetricWire.SW_IRQ_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidIrqRuntimeMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidIrqRuntimeMetric, target: *gremlin.Writer) void {
        if (self.hw_irq) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidIrqRuntimeMetricWire.HW_IRQ_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.sw_irq) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidIrqRuntimeMetricWire.SW_IRQ_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const AndroidIrqRuntimeMetricReader = struct {
    buf: gremlin.Reader,
    _hw_irq_buf: ?[]const u8 = null,
    _sw_irq_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!AndroidIrqRuntimeMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidIrqRuntimeMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidIrqRuntimeMetricWire.HW_IRQ_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._hw_irq_buf = result.value;
                },
                AndroidIrqRuntimeMetricWire.SW_IRQ_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._sw_irq_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getHwIrq(self: *const AndroidIrqRuntimeMetricReader) gremlin.Error!AndroidIrqRuntimeMetric.IrqRuntimeMetricReader {
        if (self._hw_irq_buf) |buf| {
            return try AndroidIrqRuntimeMetric.IrqRuntimeMetricReader.init(buf);
        }
        return try AndroidIrqRuntimeMetric.IrqRuntimeMetricReader.init(&[_]u8{});
    }
    pub fn getSwIrq(self: *const AndroidIrqRuntimeMetricReader) gremlin.Error!AndroidIrqRuntimeMetric.IrqRuntimeMetricReader {
        if (self._sw_irq_buf) |buf| {
            return try AndroidIrqRuntimeMetric.IrqRuntimeMetricReader.init(buf);
        }
        return try AndroidIrqRuntimeMetric.IrqRuntimeMetricReader.init(&[_]u8{});
    }
};
const AndroidJankCujMetricWire = struct {
    const CUJ_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const AndroidJankCujMetric = struct {
    // nested structs
    const CujWire = struct {
        const ID_WIRE: gremlin.ProtoWireNumber = 1;
        const NAME_WIRE: gremlin.ProtoWireNumber = 2;
        const PROCESS_WIRE: gremlin.ProtoWireNumber = 3;
        const TS_WIRE: gremlin.ProtoWireNumber = 4;
        const DUR_WIRE: gremlin.ProtoWireNumber = 5;
        const FRAME_WIRE: gremlin.ProtoWireNumber = 6;
        const SF_FRAME_WIRE: gremlin.ProtoWireNumber = 10;
        const COUNTER_METRICS_WIRE: gremlin.ProtoWireNumber = 7;
        const TIMELINE_METRICS_WIRE: gremlin.ProtoWireNumber = 8;
        const TRACE_METRICS_WIRE: gremlin.ProtoWireNumber = 9;
        const LAYER_NAME_WIRE: gremlin.ProtoWireNumber = 11;
    };
    pub const Cuj = struct {
        // fields
        id: i32 = 0,
        name: ?[]const u8 = null,
        process: ?AndroidProcessMetadata = null,
        ts: i64 = 0,
        dur: i64 = 0,
        frame: ?[]const ?AndroidJankCujMetric.Frame = null,
        sf_frame: ?[]const ?AndroidJankCujMetric.Frame = null,
        counter_metrics: ?AndroidJankCujMetric.Metrics = null,
        timeline_metrics: ?AndroidJankCujMetric.Metrics = null,
        trace_metrics: ?AndroidJankCujMetric.Metrics = null,
        layer_name: ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const AndroidJankCujMetric.Cuj) usize {
            var res: usize = 0;
            if (self.id != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidJankCujMetric.CujWire.ID_WIRE) + gremlin.sizes.sizeI32(self.id);
            }
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidJankCujMetric.CujWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.process) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidJankCujMetric.CujWire.PROCESS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.ts != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidJankCujMetric.CujWire.TS_WIRE) + gremlin.sizes.sizeI64(self.ts);
            }
            if (self.dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidJankCujMetric.CujWire.DUR_WIRE) + gremlin.sizes.sizeI64(self.dur);
            }
            if (self.frame) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidJankCujMetric.CujWire.FRAME_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.sf_frame) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidJankCujMetric.CujWire.SF_FRAME_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.counter_metrics) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidJankCujMetric.CujWire.COUNTER_METRICS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.timeline_metrics) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidJankCujMetric.CujWire.TIMELINE_METRICS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.trace_metrics) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidJankCujMetric.CujWire.TRACE_METRICS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.layer_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidJankCujMetric.CujWire.LAYER_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidJankCujMetric.Cuj, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidJankCujMetric.Cuj, target: *gremlin.Writer) void {
            if (self.id != 0) {
                target.appendInt32(AndroidJankCujMetric.CujWire.ID_WIRE, self.id);
            }
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidJankCujMetric.CujWire.NAME_WIRE, v);
                }
            }
            if (self.process) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidJankCujMetric.CujWire.PROCESS_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.ts != 0) {
                target.appendInt64(AndroidJankCujMetric.CujWire.TS_WIRE, self.ts);
            }
            if (self.dur != 0) {
                target.appendInt64(AndroidJankCujMetric.CujWire.DUR_WIRE, self.dur);
            }
            if (self.frame) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidJankCujMetric.CujWire.FRAME_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidJankCujMetric.CujWire.FRAME_WIRE, 0);
                    }
                }
            }
            if (self.sf_frame) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidJankCujMetric.CujWire.SF_FRAME_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidJankCujMetric.CujWire.SF_FRAME_WIRE, 0);
                    }
                }
            }
            if (self.counter_metrics) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidJankCujMetric.CujWire.COUNTER_METRICS_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.timeline_metrics) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidJankCujMetric.CujWire.TIMELINE_METRICS_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.trace_metrics) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidJankCujMetric.CujWire.TRACE_METRICS_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.layer_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidJankCujMetric.CujWire.LAYER_NAME_WIRE, v);
                }
            }
        }
    };
    pub const CujReader = struct {
        buf: gremlin.Reader,
        _id: i32 = 0,
        _name: ?[]const u8 = null,
        _process_buf: ?[]const u8 = null,
        _ts: i64 = 0,
        _dur: i64 = 0,
        _frame_offset: ?usize = null,
        _frame_last_offset: ?usize = null,
        _frame_cnt: usize = 0,
        _sf_frame_offset: ?usize = null,
        _sf_frame_last_offset: ?usize = null,
        _sf_frame_cnt: usize = 0,
        _counter_metrics_buf: ?[]const u8 = null,
        _timeline_metrics_buf: ?[]const u8 = null,
        _trace_metrics_buf: ?[]const u8 = null,
        _layer_name: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!AndroidJankCujMetric.CujReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidJankCujMetric.CujReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidJankCujMetric.CujWire.ID_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._id = result.value;
                    },
                    AndroidJankCujMetric.CujWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    AndroidJankCujMetric.CujWire.PROCESS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._process_buf = result.value;
                    },
                    AndroidJankCujMetric.CujWire.TS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._ts = result.value;
                    },
                    AndroidJankCujMetric.CujWire.DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._dur = result.value;
                    },
                    AndroidJankCujMetric.CujWire.FRAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._frame_offset == null) {
                            res._frame_offset = offset - result.size;
                        }
                        res._frame_last_offset = offset;
                        res._frame_cnt += 1;
                    },
                    AndroidJankCujMetric.CujWire.SF_FRAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._sf_frame_offset == null) {
                            res._sf_frame_offset = offset - result.size;
                        }
                        res._sf_frame_last_offset = offset;
                        res._sf_frame_cnt += 1;
                    },
                    AndroidJankCujMetric.CujWire.COUNTER_METRICS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._counter_metrics_buf = result.value;
                    },
                    AndroidJankCujMetric.CujWire.TIMELINE_METRICS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._timeline_metrics_buf = result.value;
                    },
                    AndroidJankCujMetric.CujWire.TRACE_METRICS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._trace_metrics_buf = result.value;
                    },
                    AndroidJankCujMetric.CujWire.LAYER_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._layer_name = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getId(self: *const AndroidJankCujMetric.CujReader) i32 {
            return self._id;
        }
        pub inline fn getName(self: *const AndroidJankCujMetric.CujReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub fn getProcess(self: *const AndroidJankCujMetric.CujReader) gremlin.Error!AndroidProcessMetadataReader {
            if (self._process_buf) |buf| {
                return try AndroidProcessMetadataReader.init(buf);
            }
            return try AndroidProcessMetadataReader.init(&[_]u8{});
        }
        pub inline fn getTs(self: *const AndroidJankCujMetric.CujReader) i64 {
            return self._ts;
        }
        pub inline fn getDur(self: *const AndroidJankCujMetric.CujReader) i64 {
            return self._dur;
        }
        pub fn frameCount(self: *const AndroidJankCujMetric.CujReader) usize {
            return self._frame_cnt;
        }
        pub fn frameNext(self: *AndroidJankCujMetric.CujReader) ?AndroidJankCujMetric.FrameReader {
            if (self._frame_offset == null) return null;
            const current_offset = self._frame_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidJankCujMetric.FrameReader.init(result.value) catch return null;
            if (self._frame_last_offset != null and current_offset >= self._frame_last_offset.?) {
                self._frame_offset = null;
                return msg;
            }
            if (self._frame_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._frame_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidJankCujMetric.CujWire.FRAME_WIRE) {
                    self._frame_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._frame_offset = null;
            return msg;
        }
        pub fn sfFrameCount(self: *const AndroidJankCujMetric.CujReader) usize {
            return self._sf_frame_cnt;
        }
        pub fn sfFrameNext(self: *AndroidJankCujMetric.CujReader) ?AndroidJankCujMetric.FrameReader {
            if (self._sf_frame_offset == null) return null;
            const current_offset = self._sf_frame_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidJankCujMetric.FrameReader.init(result.value) catch return null;
            if (self._sf_frame_last_offset != null and current_offset >= self._sf_frame_last_offset.?) {
                self._sf_frame_offset = null;
                return msg;
            }
            if (self._sf_frame_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._sf_frame_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidJankCujMetric.CujWire.SF_FRAME_WIRE) {
                    self._sf_frame_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._sf_frame_offset = null;
            return msg;
        }
        pub fn getCounterMetrics(self: *const AndroidJankCujMetric.CujReader) gremlin.Error!AndroidJankCujMetric.MetricsReader {
            if (self._counter_metrics_buf) |buf| {
                return try AndroidJankCujMetric.MetricsReader.init(buf);
            }
            return try AndroidJankCujMetric.MetricsReader.init(&[_]u8{});
        }
        pub fn getTimelineMetrics(self: *const AndroidJankCujMetric.CujReader) gremlin.Error!AndroidJankCujMetric.MetricsReader {
            if (self._timeline_metrics_buf) |buf| {
                return try AndroidJankCujMetric.MetricsReader.init(buf);
            }
            return try AndroidJankCujMetric.MetricsReader.init(&[_]u8{});
        }
        pub fn getTraceMetrics(self: *const AndroidJankCujMetric.CujReader) gremlin.Error!AndroidJankCujMetric.MetricsReader {
            if (self._trace_metrics_buf) |buf| {
                return try AndroidJankCujMetric.MetricsReader.init(buf);
            }
            return try AndroidJankCujMetric.MetricsReader.init(&[_]u8{});
        }
        pub inline fn getLayerName(self: *const AndroidJankCujMetric.CujReader) []const u8 {
            return self._layer_name orelse &[_]u8{};
        }
    };
    const FrameWire = struct {
        const FRAME_NUMBER_WIRE: gremlin.ProtoWireNumber = 1;
        const VSYNC_WIRE: gremlin.ProtoWireNumber = 2;
        const TS_WIRE: gremlin.ProtoWireNumber = 3;
        const DUR_WIRE: gremlin.ProtoWireNumber = 4;
        const DUR_EXPECTED_WIRE: gremlin.ProtoWireNumber = 7;
        const APP_MISSED_WIRE: gremlin.ProtoWireNumber = 5;
        const SF_MISSED_WIRE: gremlin.ProtoWireNumber = 6;
        const SF_CALLBACK_MISSED_WIRE: gremlin.ProtoWireNumber = 8;
        const HWUI_CALLBACK_MISSED_WIRE: gremlin.ProtoWireNumber = 9;
    };
    pub const Frame = struct {
        // fields
        frame_number: i64 = 0,
        vsync: i64 = 0,
        ts: i64 = 0,
        dur: i64 = 0,
        dur_expected: i64 = 0,
        app_missed: bool = false,
        sf_missed: bool = false,
        sf_callback_missed: bool = false,
        hwui_callback_missed: bool = false,
        pub fn calcProtobufSize(self: *const AndroidJankCujMetric.Frame) usize {
            var res: usize = 0;
            if (self.frame_number != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidJankCujMetric.FrameWire.FRAME_NUMBER_WIRE) + gremlin.sizes.sizeI64(self.frame_number);
            }
            if (self.vsync != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidJankCujMetric.FrameWire.VSYNC_WIRE) + gremlin.sizes.sizeI64(self.vsync);
            }
            if (self.ts != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidJankCujMetric.FrameWire.TS_WIRE) + gremlin.sizes.sizeI64(self.ts);
            }
            if (self.dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidJankCujMetric.FrameWire.DUR_WIRE) + gremlin.sizes.sizeI64(self.dur);
            }
            if (self.dur_expected != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidJankCujMetric.FrameWire.DUR_EXPECTED_WIRE) + gremlin.sizes.sizeI64(self.dur_expected);
            }
            if (self.app_missed != false) {
                res += gremlin.sizes.sizeWireNumber(AndroidJankCujMetric.FrameWire.APP_MISSED_WIRE) + gremlin.sizes.sizeBool(self.app_missed);
            }
            if (self.sf_missed != false) {
                res += gremlin.sizes.sizeWireNumber(AndroidJankCujMetric.FrameWire.SF_MISSED_WIRE) + gremlin.sizes.sizeBool(self.sf_missed);
            }
            if (self.sf_callback_missed != false) {
                res += gremlin.sizes.sizeWireNumber(AndroidJankCujMetric.FrameWire.SF_CALLBACK_MISSED_WIRE) + gremlin.sizes.sizeBool(self.sf_callback_missed);
            }
            if (self.hwui_callback_missed != false) {
                res += gremlin.sizes.sizeWireNumber(AndroidJankCujMetric.FrameWire.HWUI_CALLBACK_MISSED_WIRE) + gremlin.sizes.sizeBool(self.hwui_callback_missed);
            }
            return res;
        }
        pub fn encode(self: *const AndroidJankCujMetric.Frame, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidJankCujMetric.Frame, target: *gremlin.Writer) void {
            if (self.frame_number != 0) {
                target.appendInt64(AndroidJankCujMetric.FrameWire.FRAME_NUMBER_WIRE, self.frame_number);
            }
            if (self.vsync != 0) {
                target.appendInt64(AndroidJankCujMetric.FrameWire.VSYNC_WIRE, self.vsync);
            }
            if (self.ts != 0) {
                target.appendInt64(AndroidJankCujMetric.FrameWire.TS_WIRE, self.ts);
            }
            if (self.dur != 0) {
                target.appendInt64(AndroidJankCujMetric.FrameWire.DUR_WIRE, self.dur);
            }
            if (self.dur_expected != 0) {
                target.appendInt64(AndroidJankCujMetric.FrameWire.DUR_EXPECTED_WIRE, self.dur_expected);
            }
            if (self.app_missed != false) {
                target.appendBool(AndroidJankCujMetric.FrameWire.APP_MISSED_WIRE, self.app_missed);
            }
            if (self.sf_missed != false) {
                target.appendBool(AndroidJankCujMetric.FrameWire.SF_MISSED_WIRE, self.sf_missed);
            }
            if (self.sf_callback_missed != false) {
                target.appendBool(AndroidJankCujMetric.FrameWire.SF_CALLBACK_MISSED_WIRE, self.sf_callback_missed);
            }
            if (self.hwui_callback_missed != false) {
                target.appendBool(AndroidJankCujMetric.FrameWire.HWUI_CALLBACK_MISSED_WIRE, self.hwui_callback_missed);
            }
        }
    };
    pub const FrameReader = struct {
        buf: gremlin.Reader,
        _frame_number: i64 = 0,
        _vsync: i64 = 0,
        _ts: i64 = 0,
        _dur: i64 = 0,
        _dur_expected: i64 = 0,
        _app_missed: bool = false,
        _sf_missed: bool = false,
        _sf_callback_missed: bool = false,
        _hwui_callback_missed: bool = false,
        pub fn init(src: []const u8) gremlin.Error!AndroidJankCujMetric.FrameReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidJankCujMetric.FrameReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidJankCujMetric.FrameWire.FRAME_NUMBER_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._frame_number = result.value;
                    },
                    AndroidJankCujMetric.FrameWire.VSYNC_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._vsync = result.value;
                    },
                    AndroidJankCujMetric.FrameWire.TS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._ts = result.value;
                    },
                    AndroidJankCujMetric.FrameWire.DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._dur = result.value;
                    },
                    AndroidJankCujMetric.FrameWire.DUR_EXPECTED_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._dur_expected = result.value;
                    },
                    AndroidJankCujMetric.FrameWire.APP_MISSED_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._app_missed = result.value;
                    },
                    AndroidJankCujMetric.FrameWire.SF_MISSED_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._sf_missed = result.value;
                    },
                    AndroidJankCujMetric.FrameWire.SF_CALLBACK_MISSED_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._sf_callback_missed = result.value;
                    },
                    AndroidJankCujMetric.FrameWire.HWUI_CALLBACK_MISSED_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._hwui_callback_missed = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getFrameNumber(self: *const AndroidJankCujMetric.FrameReader) i64 {
            return self._frame_number;
        }
        pub inline fn getVsync(self: *const AndroidJankCujMetric.FrameReader) i64 {
            return self._vsync;
        }
        pub inline fn getTs(self: *const AndroidJankCujMetric.FrameReader) i64 {
            return self._ts;
        }
        pub inline fn getDur(self: *const AndroidJankCujMetric.FrameReader) i64 {
            return self._dur;
        }
        pub inline fn getDurExpected(self: *const AndroidJankCujMetric.FrameReader) i64 {
            return self._dur_expected;
        }
        pub inline fn getAppMissed(self: *const AndroidJankCujMetric.FrameReader) bool {
            return self._app_missed;
        }
        pub inline fn getSfMissed(self: *const AndroidJankCujMetric.FrameReader) bool {
            return self._sf_missed;
        }
        pub inline fn getSfCallbackMissed(self: *const AndroidJankCujMetric.FrameReader) bool {
            return self._sf_callback_missed;
        }
        pub inline fn getHwuiCallbackMissed(self: *const AndroidJankCujMetric.FrameReader) bool {
            return self._hwui_callback_missed;
        }
    };
    const MetricsWire = struct {
        const TOTAL_FRAMES_WIRE: gremlin.ProtoWireNumber = 1;
        const MISSED_FRAMES_WIRE: gremlin.ProtoWireNumber = 2;
        const MISSED_APP_FRAMES_WIRE: gremlin.ProtoWireNumber = 3;
        const MISSED_SF_FRAMES_WIRE: gremlin.ProtoWireNumber = 4;
        const MISSED_FRAMES_MAX_SUCCESSIVE_WIRE: gremlin.ProtoWireNumber = 5;
        const FRAME_DUR_MAX_WIRE: gremlin.ProtoWireNumber = 6;
        const FRAME_DUR_AVG_WIRE: gremlin.ProtoWireNumber = 7;
        const FRAME_DUR_P50_WIRE: gremlin.ProtoWireNumber = 8;
        const FRAME_DUR_P90_WIRE: gremlin.ProtoWireNumber = 9;
        const FRAME_DUR_P95_WIRE: gremlin.ProtoWireNumber = 10;
        const FRAME_DUR_P99_WIRE: gremlin.ProtoWireNumber = 11;
        const FRAME_DUR_MS_P50_WIRE: gremlin.ProtoWireNumber = 12;
        const FRAME_DUR_MS_P90_WIRE: gremlin.ProtoWireNumber = 13;
        const FRAME_DUR_MS_P95_WIRE: gremlin.ProtoWireNumber = 14;
        const FRAME_DUR_MS_P99_WIRE: gremlin.ProtoWireNumber = 15;
        const SF_CALLBACK_MISSED_FRAMES_WIRE: gremlin.ProtoWireNumber = 16;
        const HWUI_CALLBACK_MISSED_FRAMES_WIRE: gremlin.ProtoWireNumber = 17;
    };
    pub const Metrics = struct {
        // fields
        total_frames: i64 = 0,
        missed_frames: i64 = 0,
        missed_app_frames: i64 = 0,
        missed_sf_frames: i64 = 0,
        missed_frames_max_successive: i64 = 0,
        frame_dur_max: i64 = 0,
        frame_dur_avg: i64 = 0,
        frame_dur_p50: i64 = 0,
        frame_dur_p90: i64 = 0,
        frame_dur_p95: i64 = 0,
        frame_dur_p99: i64 = 0,
        frame_dur_ms_p50: f64 = 0.0,
        frame_dur_ms_p90: f64 = 0.0,
        frame_dur_ms_p95: f64 = 0.0,
        frame_dur_ms_p99: f64 = 0.0,
        sf_callback_missed_frames: i64 = 0,
        hwui_callback_missed_frames: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidJankCujMetric.Metrics) usize {
            var res: usize = 0;
            if (self.total_frames != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidJankCujMetric.MetricsWire.TOTAL_FRAMES_WIRE) + gremlin.sizes.sizeI64(self.total_frames);
            }
            if (self.missed_frames != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidJankCujMetric.MetricsWire.MISSED_FRAMES_WIRE) + gremlin.sizes.sizeI64(self.missed_frames);
            }
            if (self.missed_app_frames != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidJankCujMetric.MetricsWire.MISSED_APP_FRAMES_WIRE) + gremlin.sizes.sizeI64(self.missed_app_frames);
            }
            if (self.missed_sf_frames != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidJankCujMetric.MetricsWire.MISSED_SF_FRAMES_WIRE) + gremlin.sizes.sizeI64(self.missed_sf_frames);
            }
            if (self.missed_frames_max_successive != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidJankCujMetric.MetricsWire.MISSED_FRAMES_MAX_SUCCESSIVE_WIRE) + gremlin.sizes.sizeI64(self.missed_frames_max_successive);
            }
            if (self.frame_dur_max != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidJankCujMetric.MetricsWire.FRAME_DUR_MAX_WIRE) + gremlin.sizes.sizeI64(self.frame_dur_max);
            }
            if (self.frame_dur_avg != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidJankCujMetric.MetricsWire.FRAME_DUR_AVG_WIRE) + gremlin.sizes.sizeI64(self.frame_dur_avg);
            }
            if (self.frame_dur_p50 != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidJankCujMetric.MetricsWire.FRAME_DUR_P50_WIRE) + gremlin.sizes.sizeI64(self.frame_dur_p50);
            }
            if (self.frame_dur_p90 != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidJankCujMetric.MetricsWire.FRAME_DUR_P90_WIRE) + gremlin.sizes.sizeI64(self.frame_dur_p90);
            }
            if (self.frame_dur_p95 != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidJankCujMetric.MetricsWire.FRAME_DUR_P95_WIRE) + gremlin.sizes.sizeI64(self.frame_dur_p95);
            }
            if (self.frame_dur_p99 != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidJankCujMetric.MetricsWire.FRAME_DUR_P99_WIRE) + gremlin.sizes.sizeI64(self.frame_dur_p99);
            }
            if (self.frame_dur_ms_p50 != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidJankCujMetric.MetricsWire.FRAME_DUR_MS_P50_WIRE) + gremlin.sizes.sizeDouble(self.frame_dur_ms_p50);
            }
            if (self.frame_dur_ms_p90 != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidJankCujMetric.MetricsWire.FRAME_DUR_MS_P90_WIRE) + gremlin.sizes.sizeDouble(self.frame_dur_ms_p90);
            }
            if (self.frame_dur_ms_p95 != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidJankCujMetric.MetricsWire.FRAME_DUR_MS_P95_WIRE) + gremlin.sizes.sizeDouble(self.frame_dur_ms_p95);
            }
            if (self.frame_dur_ms_p99 != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidJankCujMetric.MetricsWire.FRAME_DUR_MS_P99_WIRE) + gremlin.sizes.sizeDouble(self.frame_dur_ms_p99);
            }
            if (self.sf_callback_missed_frames != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidJankCujMetric.MetricsWire.SF_CALLBACK_MISSED_FRAMES_WIRE) + gremlin.sizes.sizeI64(self.sf_callback_missed_frames);
            }
            if (self.hwui_callback_missed_frames != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidJankCujMetric.MetricsWire.HWUI_CALLBACK_MISSED_FRAMES_WIRE) + gremlin.sizes.sizeI64(self.hwui_callback_missed_frames);
            }
            return res;
        }
        pub fn encode(self: *const AndroidJankCujMetric.Metrics, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidJankCujMetric.Metrics, target: *gremlin.Writer) void {
            if (self.total_frames != 0) {
                target.appendInt64(AndroidJankCujMetric.MetricsWire.TOTAL_FRAMES_WIRE, self.total_frames);
            }
            if (self.missed_frames != 0) {
                target.appendInt64(AndroidJankCujMetric.MetricsWire.MISSED_FRAMES_WIRE, self.missed_frames);
            }
            if (self.missed_app_frames != 0) {
                target.appendInt64(AndroidJankCujMetric.MetricsWire.MISSED_APP_FRAMES_WIRE, self.missed_app_frames);
            }
            if (self.missed_sf_frames != 0) {
                target.appendInt64(AndroidJankCujMetric.MetricsWire.MISSED_SF_FRAMES_WIRE, self.missed_sf_frames);
            }
            if (self.missed_frames_max_successive != 0) {
                target.appendInt64(AndroidJankCujMetric.MetricsWire.MISSED_FRAMES_MAX_SUCCESSIVE_WIRE, self.missed_frames_max_successive);
            }
            if (self.frame_dur_max != 0) {
                target.appendInt64(AndroidJankCujMetric.MetricsWire.FRAME_DUR_MAX_WIRE, self.frame_dur_max);
            }
            if (self.frame_dur_avg != 0) {
                target.appendInt64(AndroidJankCujMetric.MetricsWire.FRAME_DUR_AVG_WIRE, self.frame_dur_avg);
            }
            if (self.frame_dur_p50 != 0) {
                target.appendInt64(AndroidJankCujMetric.MetricsWire.FRAME_DUR_P50_WIRE, self.frame_dur_p50);
            }
            if (self.frame_dur_p90 != 0) {
                target.appendInt64(AndroidJankCujMetric.MetricsWire.FRAME_DUR_P90_WIRE, self.frame_dur_p90);
            }
            if (self.frame_dur_p95 != 0) {
                target.appendInt64(AndroidJankCujMetric.MetricsWire.FRAME_DUR_P95_WIRE, self.frame_dur_p95);
            }
            if (self.frame_dur_p99 != 0) {
                target.appendInt64(AndroidJankCujMetric.MetricsWire.FRAME_DUR_P99_WIRE, self.frame_dur_p99);
            }
            if (self.frame_dur_ms_p50 != 0.0) {
                target.appendFloat64(AndroidJankCujMetric.MetricsWire.FRAME_DUR_MS_P50_WIRE, self.frame_dur_ms_p50);
            }
            if (self.frame_dur_ms_p90 != 0.0) {
                target.appendFloat64(AndroidJankCujMetric.MetricsWire.FRAME_DUR_MS_P90_WIRE, self.frame_dur_ms_p90);
            }
            if (self.frame_dur_ms_p95 != 0.0) {
                target.appendFloat64(AndroidJankCujMetric.MetricsWire.FRAME_DUR_MS_P95_WIRE, self.frame_dur_ms_p95);
            }
            if (self.frame_dur_ms_p99 != 0.0) {
                target.appendFloat64(AndroidJankCujMetric.MetricsWire.FRAME_DUR_MS_P99_WIRE, self.frame_dur_ms_p99);
            }
            if (self.sf_callback_missed_frames != 0) {
                target.appendInt64(AndroidJankCujMetric.MetricsWire.SF_CALLBACK_MISSED_FRAMES_WIRE, self.sf_callback_missed_frames);
            }
            if (self.hwui_callback_missed_frames != 0) {
                target.appendInt64(AndroidJankCujMetric.MetricsWire.HWUI_CALLBACK_MISSED_FRAMES_WIRE, self.hwui_callback_missed_frames);
            }
        }
    };
    pub const MetricsReader = struct {
        buf: gremlin.Reader,
        _total_frames: i64 = 0,
        _missed_frames: i64 = 0,
        _missed_app_frames: i64 = 0,
        _missed_sf_frames: i64 = 0,
        _missed_frames_max_successive: i64 = 0,
        _frame_dur_max: i64 = 0,
        _frame_dur_avg: i64 = 0,
        _frame_dur_p50: i64 = 0,
        _frame_dur_p90: i64 = 0,
        _frame_dur_p95: i64 = 0,
        _frame_dur_p99: i64 = 0,
        _frame_dur_ms_p50: f64 = 0.0,
        _frame_dur_ms_p90: f64 = 0.0,
        _frame_dur_ms_p95: f64 = 0.0,
        _frame_dur_ms_p99: f64 = 0.0,
        _sf_callback_missed_frames: i64 = 0,
        _hwui_callback_missed_frames: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidJankCujMetric.MetricsReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidJankCujMetric.MetricsReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidJankCujMetric.MetricsWire.TOTAL_FRAMES_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._total_frames = result.value;
                    },
                    AndroidJankCujMetric.MetricsWire.MISSED_FRAMES_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._missed_frames = result.value;
                    },
                    AndroidJankCujMetric.MetricsWire.MISSED_APP_FRAMES_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._missed_app_frames = result.value;
                    },
                    AndroidJankCujMetric.MetricsWire.MISSED_SF_FRAMES_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._missed_sf_frames = result.value;
                    },
                    AndroidJankCujMetric.MetricsWire.MISSED_FRAMES_MAX_SUCCESSIVE_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._missed_frames_max_successive = result.value;
                    },
                    AndroidJankCujMetric.MetricsWire.FRAME_DUR_MAX_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._frame_dur_max = result.value;
                    },
                    AndroidJankCujMetric.MetricsWire.FRAME_DUR_AVG_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._frame_dur_avg = result.value;
                    },
                    AndroidJankCujMetric.MetricsWire.FRAME_DUR_P50_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._frame_dur_p50 = result.value;
                    },
                    AndroidJankCujMetric.MetricsWire.FRAME_DUR_P90_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._frame_dur_p90 = result.value;
                    },
                    AndroidJankCujMetric.MetricsWire.FRAME_DUR_P95_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._frame_dur_p95 = result.value;
                    },
                    AndroidJankCujMetric.MetricsWire.FRAME_DUR_P99_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._frame_dur_p99 = result.value;
                    },
                    AndroidJankCujMetric.MetricsWire.FRAME_DUR_MS_P50_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._frame_dur_ms_p50 = result.value;
                    },
                    AndroidJankCujMetric.MetricsWire.FRAME_DUR_MS_P90_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._frame_dur_ms_p90 = result.value;
                    },
                    AndroidJankCujMetric.MetricsWire.FRAME_DUR_MS_P95_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._frame_dur_ms_p95 = result.value;
                    },
                    AndroidJankCujMetric.MetricsWire.FRAME_DUR_MS_P99_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._frame_dur_ms_p99 = result.value;
                    },
                    AndroidJankCujMetric.MetricsWire.SF_CALLBACK_MISSED_FRAMES_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._sf_callback_missed_frames = result.value;
                    },
                    AndroidJankCujMetric.MetricsWire.HWUI_CALLBACK_MISSED_FRAMES_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._hwui_callback_missed_frames = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getTotalFrames(self: *const AndroidJankCujMetric.MetricsReader) i64 {
            return self._total_frames;
        }
        pub inline fn getMissedFrames(self: *const AndroidJankCujMetric.MetricsReader) i64 {
            return self._missed_frames;
        }
        pub inline fn getMissedAppFrames(self: *const AndroidJankCujMetric.MetricsReader) i64 {
            return self._missed_app_frames;
        }
        pub inline fn getMissedSfFrames(self: *const AndroidJankCujMetric.MetricsReader) i64 {
            return self._missed_sf_frames;
        }
        pub inline fn getMissedFramesMaxSuccessive(self: *const AndroidJankCujMetric.MetricsReader) i64 {
            return self._missed_frames_max_successive;
        }
        pub inline fn getFrameDurMax(self: *const AndroidJankCujMetric.MetricsReader) i64 {
            return self._frame_dur_max;
        }
        pub inline fn getFrameDurAvg(self: *const AndroidJankCujMetric.MetricsReader) i64 {
            return self._frame_dur_avg;
        }
        pub inline fn getFrameDurP50(self: *const AndroidJankCujMetric.MetricsReader) i64 {
            return self._frame_dur_p50;
        }
        pub inline fn getFrameDurP90(self: *const AndroidJankCujMetric.MetricsReader) i64 {
            return self._frame_dur_p90;
        }
        pub inline fn getFrameDurP95(self: *const AndroidJankCujMetric.MetricsReader) i64 {
            return self._frame_dur_p95;
        }
        pub inline fn getFrameDurP99(self: *const AndroidJankCujMetric.MetricsReader) i64 {
            return self._frame_dur_p99;
        }
        pub inline fn getFrameDurMsP50(self: *const AndroidJankCujMetric.MetricsReader) f64 {
            return self._frame_dur_ms_p50;
        }
        pub inline fn getFrameDurMsP90(self: *const AndroidJankCujMetric.MetricsReader) f64 {
            return self._frame_dur_ms_p90;
        }
        pub inline fn getFrameDurMsP95(self: *const AndroidJankCujMetric.MetricsReader) f64 {
            return self._frame_dur_ms_p95;
        }
        pub inline fn getFrameDurMsP99(self: *const AndroidJankCujMetric.MetricsReader) f64 {
            return self._frame_dur_ms_p99;
        }
        pub inline fn getSfCallbackMissedFrames(self: *const AndroidJankCujMetric.MetricsReader) i64 {
            return self._sf_callback_missed_frames;
        }
        pub inline fn getHwuiCallbackMissedFrames(self: *const AndroidJankCujMetric.MetricsReader) i64 {
            return self._hwui_callback_missed_frames;
        }
    };
    // fields
    cuj: ?[]const ?AndroidJankCujMetric.Cuj = null,
    pub fn calcProtobufSize(self: *const AndroidJankCujMetric) usize {
        var res: usize = 0;
        if (self.cuj) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidJankCujMetricWire.CUJ_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidJankCujMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidJankCujMetric, target: *gremlin.Writer) void {
        if (self.cuj) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidJankCujMetricWire.CUJ_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidJankCujMetricWire.CUJ_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidJankCujMetricReader = struct {
    buf: gremlin.Reader,
    _cuj_offset: ?usize = null,
    _cuj_last_offset: ?usize = null,
    _cuj_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidJankCujMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidJankCujMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidJankCujMetricWire.CUJ_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._cuj_offset == null) {
                        res._cuj_offset = offset - result.size;
                    }
                    res._cuj_last_offset = offset;
                    res._cuj_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn cujCount(self: *const AndroidJankCujMetricReader) usize {
        return self._cuj_cnt;
    }
    pub fn cujNext(self: *AndroidJankCujMetricReader) ?AndroidJankCujMetric.CujReader {
        if (self._cuj_offset == null) return null;
        const current_offset = self._cuj_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidJankCujMetric.CujReader.init(result.value) catch return null;
        if (self._cuj_last_offset != null and current_offset >= self._cuj_last_offset.?) {
            self._cuj_offset = null;
            return msg;
        }
        if (self._cuj_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._cuj_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidJankCujMetricWire.CUJ_WIRE) {
                self._cuj_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._cuj_offset = null;
        return msg;
    }
};
const JavaHeapClassStatsWire = struct {
    const INSTANCE_STATS_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const JavaHeapClassStats = struct {
    // nested structs
    const TypeCountWire = struct {
        const TYPE_NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const IS_LIBCORE_OR_ARRAY_WIRE: gremlin.ProtoWireNumber = 12;
        const OBJ_COUNT_WIRE: gremlin.ProtoWireNumber = 2;
        const SIZE_BYTES_WIRE: gremlin.ProtoWireNumber = 3;
        const NATIVE_SIZE_BYTES_WIRE: gremlin.ProtoWireNumber = 4;
        const REACHABLE_OBJ_COUNT_WIRE: gremlin.ProtoWireNumber = 5;
        const REACHABLE_SIZE_BYTES_WIRE: gremlin.ProtoWireNumber = 6;
        const REACHABLE_NATIVE_SIZE_BYTES_WIRE: gremlin.ProtoWireNumber = 7;
        const DOMINATED_OBJ_COUNT_WIRE: gremlin.ProtoWireNumber = 8;
        const DOMINATED_SIZE_BYTES_WIRE: gremlin.ProtoWireNumber = 9;
        const DOMINATED_NATIVE_SIZE_BYTES_WIRE: gremlin.ProtoWireNumber = 10;
    };
    pub const TypeCount = struct {
        // fields
        type_name: ?[]const u8 = null,
        is_libcore_or_array: bool = false,
        obj_count: i64 = 0,
        size_bytes: i64 = 0,
        native_size_bytes: i64 = 0,
        reachable_obj_count: i64 = 0,
        reachable_size_bytes: i64 = 0,
        reachable_native_size_bytes: i64 = 0,
        dominated_obj_count: i64 = 0,
        dominated_size_bytes: i64 = 0,
        dominated_native_size_bytes: i64 = 0,
        pub fn calcProtobufSize(self: *const JavaHeapClassStats.TypeCount) usize {
            var res: usize = 0;
            if (self.type_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(JavaHeapClassStats.TypeCountWire.TYPE_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.is_libcore_or_array != false) {
                res += gremlin.sizes.sizeWireNumber(JavaHeapClassStats.TypeCountWire.IS_LIBCORE_OR_ARRAY_WIRE) + gremlin.sizes.sizeBool(self.is_libcore_or_array);
            }
            if (self.obj_count != 0) {
                res += gremlin.sizes.sizeWireNumber(JavaHeapClassStats.TypeCountWire.OBJ_COUNT_WIRE) + gremlin.sizes.sizeI64(self.obj_count);
            }
            if (self.size_bytes != 0) {
                res += gremlin.sizes.sizeWireNumber(JavaHeapClassStats.TypeCountWire.SIZE_BYTES_WIRE) + gremlin.sizes.sizeI64(self.size_bytes);
            }
            if (self.native_size_bytes != 0) {
                res += gremlin.sizes.sizeWireNumber(JavaHeapClassStats.TypeCountWire.NATIVE_SIZE_BYTES_WIRE) + gremlin.sizes.sizeI64(self.native_size_bytes);
            }
            if (self.reachable_obj_count != 0) {
                res += gremlin.sizes.sizeWireNumber(JavaHeapClassStats.TypeCountWire.REACHABLE_OBJ_COUNT_WIRE) + gremlin.sizes.sizeI64(self.reachable_obj_count);
            }
            if (self.reachable_size_bytes != 0) {
                res += gremlin.sizes.sizeWireNumber(JavaHeapClassStats.TypeCountWire.REACHABLE_SIZE_BYTES_WIRE) + gremlin.sizes.sizeI64(self.reachable_size_bytes);
            }
            if (self.reachable_native_size_bytes != 0) {
                res += gremlin.sizes.sizeWireNumber(JavaHeapClassStats.TypeCountWire.REACHABLE_NATIVE_SIZE_BYTES_WIRE) + gremlin.sizes.sizeI64(self.reachable_native_size_bytes);
            }
            if (self.dominated_obj_count != 0) {
                res += gremlin.sizes.sizeWireNumber(JavaHeapClassStats.TypeCountWire.DOMINATED_OBJ_COUNT_WIRE) + gremlin.sizes.sizeI64(self.dominated_obj_count);
            }
            if (self.dominated_size_bytes != 0) {
                res += gremlin.sizes.sizeWireNumber(JavaHeapClassStats.TypeCountWire.DOMINATED_SIZE_BYTES_WIRE) + gremlin.sizes.sizeI64(self.dominated_size_bytes);
            }
            if (self.dominated_native_size_bytes != 0) {
                res += gremlin.sizes.sizeWireNumber(JavaHeapClassStats.TypeCountWire.DOMINATED_NATIVE_SIZE_BYTES_WIRE) + gremlin.sizes.sizeI64(self.dominated_native_size_bytes);
            }
            return res;
        }
        pub fn encode(self: *const JavaHeapClassStats.TypeCount, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const JavaHeapClassStats.TypeCount, target: *gremlin.Writer) void {
            if (self.type_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(JavaHeapClassStats.TypeCountWire.TYPE_NAME_WIRE, v);
                }
            }
            if (self.is_libcore_or_array != false) {
                target.appendBool(JavaHeapClassStats.TypeCountWire.IS_LIBCORE_OR_ARRAY_WIRE, self.is_libcore_or_array);
            }
            if (self.obj_count != 0) {
                target.appendInt64(JavaHeapClassStats.TypeCountWire.OBJ_COUNT_WIRE, self.obj_count);
            }
            if (self.size_bytes != 0) {
                target.appendInt64(JavaHeapClassStats.TypeCountWire.SIZE_BYTES_WIRE, self.size_bytes);
            }
            if (self.native_size_bytes != 0) {
                target.appendInt64(JavaHeapClassStats.TypeCountWire.NATIVE_SIZE_BYTES_WIRE, self.native_size_bytes);
            }
            if (self.reachable_obj_count != 0) {
                target.appendInt64(JavaHeapClassStats.TypeCountWire.REACHABLE_OBJ_COUNT_WIRE, self.reachable_obj_count);
            }
            if (self.reachable_size_bytes != 0) {
                target.appendInt64(JavaHeapClassStats.TypeCountWire.REACHABLE_SIZE_BYTES_WIRE, self.reachable_size_bytes);
            }
            if (self.reachable_native_size_bytes != 0) {
                target.appendInt64(JavaHeapClassStats.TypeCountWire.REACHABLE_NATIVE_SIZE_BYTES_WIRE, self.reachable_native_size_bytes);
            }
            if (self.dominated_obj_count != 0) {
                target.appendInt64(JavaHeapClassStats.TypeCountWire.DOMINATED_OBJ_COUNT_WIRE, self.dominated_obj_count);
            }
            if (self.dominated_size_bytes != 0) {
                target.appendInt64(JavaHeapClassStats.TypeCountWire.DOMINATED_SIZE_BYTES_WIRE, self.dominated_size_bytes);
            }
            if (self.dominated_native_size_bytes != 0) {
                target.appendInt64(JavaHeapClassStats.TypeCountWire.DOMINATED_NATIVE_SIZE_BYTES_WIRE, self.dominated_native_size_bytes);
            }
        }
    };
    pub const TypeCountReader = struct {
        buf: gremlin.Reader,
        _type_name: ?[]const u8 = null,
        _is_libcore_or_array: bool = false,
        _obj_count: i64 = 0,
        _size_bytes: i64 = 0,
        _native_size_bytes: i64 = 0,
        _reachable_obj_count: i64 = 0,
        _reachable_size_bytes: i64 = 0,
        _reachable_native_size_bytes: i64 = 0,
        _dominated_obj_count: i64 = 0,
        _dominated_size_bytes: i64 = 0,
        _dominated_native_size_bytes: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!JavaHeapClassStats.TypeCountReader {
            const buf = gremlin.Reader.init(src);
            var res = JavaHeapClassStats.TypeCountReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    JavaHeapClassStats.TypeCountWire.TYPE_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._type_name = result.value;
                    },
                    JavaHeapClassStats.TypeCountWire.IS_LIBCORE_OR_ARRAY_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._is_libcore_or_array = result.value;
                    },
                    JavaHeapClassStats.TypeCountWire.OBJ_COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._obj_count = result.value;
                    },
                    JavaHeapClassStats.TypeCountWire.SIZE_BYTES_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._size_bytes = result.value;
                    },
                    JavaHeapClassStats.TypeCountWire.NATIVE_SIZE_BYTES_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._native_size_bytes = result.value;
                    },
                    JavaHeapClassStats.TypeCountWire.REACHABLE_OBJ_COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._reachable_obj_count = result.value;
                    },
                    JavaHeapClassStats.TypeCountWire.REACHABLE_SIZE_BYTES_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._reachable_size_bytes = result.value;
                    },
                    JavaHeapClassStats.TypeCountWire.REACHABLE_NATIVE_SIZE_BYTES_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._reachable_native_size_bytes = result.value;
                    },
                    JavaHeapClassStats.TypeCountWire.DOMINATED_OBJ_COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._dominated_obj_count = result.value;
                    },
                    JavaHeapClassStats.TypeCountWire.DOMINATED_SIZE_BYTES_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._dominated_size_bytes = result.value;
                    },
                    JavaHeapClassStats.TypeCountWire.DOMINATED_NATIVE_SIZE_BYTES_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._dominated_native_size_bytes = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getTypeName(self: *const JavaHeapClassStats.TypeCountReader) []const u8 {
            return self._type_name orelse &[_]u8{};
        }
        pub inline fn getIsLibcoreOrArray(self: *const JavaHeapClassStats.TypeCountReader) bool {
            return self._is_libcore_or_array;
        }
        pub inline fn getObjCount(self: *const JavaHeapClassStats.TypeCountReader) i64 {
            return self._obj_count;
        }
        pub inline fn getSizeBytes(self: *const JavaHeapClassStats.TypeCountReader) i64 {
            return self._size_bytes;
        }
        pub inline fn getNativeSizeBytes(self: *const JavaHeapClassStats.TypeCountReader) i64 {
            return self._native_size_bytes;
        }
        pub inline fn getReachableObjCount(self: *const JavaHeapClassStats.TypeCountReader) i64 {
            return self._reachable_obj_count;
        }
        pub inline fn getReachableSizeBytes(self: *const JavaHeapClassStats.TypeCountReader) i64 {
            return self._reachable_size_bytes;
        }
        pub inline fn getReachableNativeSizeBytes(self: *const JavaHeapClassStats.TypeCountReader) i64 {
            return self._reachable_native_size_bytes;
        }
        pub inline fn getDominatedObjCount(self: *const JavaHeapClassStats.TypeCountReader) i64 {
            return self._dominated_obj_count;
        }
        pub inline fn getDominatedSizeBytes(self: *const JavaHeapClassStats.TypeCountReader) i64 {
            return self._dominated_size_bytes;
        }
        pub inline fn getDominatedNativeSizeBytes(self: *const JavaHeapClassStats.TypeCountReader) i64 {
            return self._dominated_native_size_bytes;
        }
    };
    const SampleWire = struct {
        const TS_WIRE: gremlin.ProtoWireNumber = 1;
        const TYPE_COUNT_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const Sample = struct {
        // fields
        ts: i64 = 0,
        type_count: ?[]const ?JavaHeapClassStats.TypeCount = null,
        pub fn calcProtobufSize(self: *const JavaHeapClassStats.Sample) usize {
            var res: usize = 0;
            if (self.ts != 0) {
                res += gremlin.sizes.sizeWireNumber(JavaHeapClassStats.SampleWire.TS_WIRE) + gremlin.sizes.sizeI64(self.ts);
            }
            if (self.type_count) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(JavaHeapClassStats.SampleWire.TYPE_COUNT_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const JavaHeapClassStats.Sample, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const JavaHeapClassStats.Sample, target: *gremlin.Writer) void {
            if (self.ts != 0) {
                target.appendInt64(JavaHeapClassStats.SampleWire.TS_WIRE, self.ts);
            }
            if (self.type_count) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(JavaHeapClassStats.SampleWire.TYPE_COUNT_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(JavaHeapClassStats.SampleWire.TYPE_COUNT_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const SampleReader = struct {
        buf: gremlin.Reader,
        _ts: i64 = 0,
        _type_count_offset: ?usize = null,
        _type_count_last_offset: ?usize = null,
        _type_count_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!JavaHeapClassStats.SampleReader {
            const buf = gremlin.Reader.init(src);
            var res = JavaHeapClassStats.SampleReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    JavaHeapClassStats.SampleWire.TS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._ts = result.value;
                    },
                    JavaHeapClassStats.SampleWire.TYPE_COUNT_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._type_count_offset == null) {
                            res._type_count_offset = offset - result.size;
                        }
                        res._type_count_last_offset = offset;
                        res._type_count_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getTs(self: *const JavaHeapClassStats.SampleReader) i64 {
            return self._ts;
        }
        pub fn typeCountCount(self: *const JavaHeapClassStats.SampleReader) usize {
            return self._type_count_cnt;
        }
        pub fn typeCountNext(self: *JavaHeapClassStats.SampleReader) ?JavaHeapClassStats.TypeCountReader {
            if (self._type_count_offset == null) return null;
            const current_offset = self._type_count_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = JavaHeapClassStats.TypeCountReader.init(result.value) catch return null;
            if (self._type_count_last_offset != null and current_offset >= self._type_count_last_offset.?) {
                self._type_count_offset = null;
                return msg;
            }
            if (self._type_count_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._type_count_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == JavaHeapClassStats.SampleWire.TYPE_COUNT_WIRE) {
                    self._type_count_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._type_count_offset = null;
            return msg;
        }
    };
    const InstanceStatsWire = struct {
        const UPID_WIRE: gremlin.ProtoWireNumber = 1;
        const PROCESS_WIRE: gremlin.ProtoWireNumber = 2;
        const SAMPLES_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const InstanceStats = struct {
        // fields
        upid: u32 = 0,
        process: ?AndroidProcessMetadata = null,
        samples: ?[]const ?JavaHeapClassStats.Sample = null,
        pub fn calcProtobufSize(self: *const JavaHeapClassStats.InstanceStats) usize {
            var res: usize = 0;
            if (self.upid != 0) {
                res += gremlin.sizes.sizeWireNumber(JavaHeapClassStats.InstanceStatsWire.UPID_WIRE) + gremlin.sizes.sizeU32(self.upid);
            }
            if (self.process) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(JavaHeapClassStats.InstanceStatsWire.PROCESS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.samples) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(JavaHeapClassStats.InstanceStatsWire.SAMPLES_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const JavaHeapClassStats.InstanceStats, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const JavaHeapClassStats.InstanceStats, target: *gremlin.Writer) void {
            if (self.upid != 0) {
                target.appendUint32(JavaHeapClassStats.InstanceStatsWire.UPID_WIRE, self.upid);
            }
            if (self.process) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(JavaHeapClassStats.InstanceStatsWire.PROCESS_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.samples) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(JavaHeapClassStats.InstanceStatsWire.SAMPLES_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(JavaHeapClassStats.InstanceStatsWire.SAMPLES_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const InstanceStatsReader = struct {
        buf: gremlin.Reader,
        _upid: u32 = 0,
        _process_buf: ?[]const u8 = null,
        _samples_offset: ?usize = null,
        _samples_last_offset: ?usize = null,
        _samples_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!JavaHeapClassStats.InstanceStatsReader {
            const buf = gremlin.Reader.init(src);
            var res = JavaHeapClassStats.InstanceStatsReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    JavaHeapClassStats.InstanceStatsWire.UPID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._upid = result.value;
                    },
                    JavaHeapClassStats.InstanceStatsWire.PROCESS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._process_buf = result.value;
                    },
                    JavaHeapClassStats.InstanceStatsWire.SAMPLES_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._samples_offset == null) {
                            res._samples_offset = offset - result.size;
                        }
                        res._samples_last_offset = offset;
                        res._samples_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getUpid(self: *const JavaHeapClassStats.InstanceStatsReader) u32 {
            return self._upid;
        }
        pub fn getProcess(self: *const JavaHeapClassStats.InstanceStatsReader) gremlin.Error!AndroidProcessMetadataReader {
            if (self._process_buf) |buf| {
                return try AndroidProcessMetadataReader.init(buf);
            }
            return try AndroidProcessMetadataReader.init(&[_]u8{});
        }
        pub fn samplesCount(self: *const JavaHeapClassStats.InstanceStatsReader) usize {
            return self._samples_cnt;
        }
        pub fn samplesNext(self: *JavaHeapClassStats.InstanceStatsReader) ?JavaHeapClassStats.SampleReader {
            if (self._samples_offset == null) return null;
            const current_offset = self._samples_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = JavaHeapClassStats.SampleReader.init(result.value) catch return null;
            if (self._samples_last_offset != null and current_offset >= self._samples_last_offset.?) {
                self._samples_offset = null;
                return msg;
            }
            if (self._samples_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._samples_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == JavaHeapClassStats.InstanceStatsWire.SAMPLES_WIRE) {
                    self._samples_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._samples_offset = null;
            return msg;
        }
    };
    // fields
    instance_stats: ?[]const ?JavaHeapClassStats.InstanceStats = null,
    pub fn calcProtobufSize(self: *const JavaHeapClassStats) usize {
        var res: usize = 0;
        if (self.instance_stats) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(JavaHeapClassStatsWire.INSTANCE_STATS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const JavaHeapClassStats, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const JavaHeapClassStats, target: *gremlin.Writer) void {
        if (self.instance_stats) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(JavaHeapClassStatsWire.INSTANCE_STATS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(JavaHeapClassStatsWire.INSTANCE_STATS_WIRE, 0);
                }
            }
        }
    }
};
pub const JavaHeapClassStatsReader = struct {
    buf: gremlin.Reader,
    _instance_stats_offset: ?usize = null,
    _instance_stats_last_offset: ?usize = null,
    _instance_stats_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!JavaHeapClassStatsReader {
        const buf = gremlin.Reader.init(src);
        var res = JavaHeapClassStatsReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                JavaHeapClassStatsWire.INSTANCE_STATS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._instance_stats_offset == null) {
                        res._instance_stats_offset = offset - result.size;
                    }
                    res._instance_stats_last_offset = offset;
                    res._instance_stats_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn instanceStatsCount(self: *const JavaHeapClassStatsReader) usize {
        return self._instance_stats_cnt;
    }
    pub fn instanceStatsNext(self: *JavaHeapClassStatsReader) ?JavaHeapClassStats.InstanceStatsReader {
        if (self._instance_stats_offset == null) return null;
        const current_offset = self._instance_stats_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = JavaHeapClassStats.InstanceStatsReader.init(result.value) catch return null;
        if (self._instance_stats_last_offset != null and current_offset >= self._instance_stats_last_offset.?) {
            self._instance_stats_offset = null;
            return msg;
        }
        if (self._instance_stats_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._instance_stats_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == JavaHeapClassStatsWire.INSTANCE_STATS_WIRE) {
                self._instance_stats_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._instance_stats_offset = null;
        return msg;
    }
};
const JavaHeapHistogramWire = struct {
    const INSTANCE_STATS_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const JavaHeapHistogram = struct {
    // nested structs
    const TypeCountWire = struct {
        const TYPE_NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const CATEGORY_WIRE: gremlin.ProtoWireNumber = 4;
        const OBJ_COUNT_WIRE: gremlin.ProtoWireNumber = 2;
        const REACHABLE_OBJ_COUNT_WIRE: gremlin.ProtoWireNumber = 3;
        const SIZE_KB_WIRE: gremlin.ProtoWireNumber = 5;
        const REACHABLE_SIZE_KB_WIRE: gremlin.ProtoWireNumber = 6;
        const NATIVE_SIZE_KB_WIRE: gremlin.ProtoWireNumber = 7;
        const REACHABLE_NATIVE_SIZE_KB_WIRE: gremlin.ProtoWireNumber = 8;
    };
    pub const TypeCount = struct {
        // fields
        type_name: ?[]const u8 = null,
        category: ?[]const u8 = null,
        obj_count: u32 = 0,
        reachable_obj_count: u32 = 0,
        size_kb: u32 = 0,
        reachable_size_kb: u32 = 0,
        native_size_kb: u32 = 0,
        reachable_native_size_kb: u32 = 0,
        pub fn calcProtobufSize(self: *const JavaHeapHistogram.TypeCount) usize {
            var res: usize = 0;
            if (self.type_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(JavaHeapHistogram.TypeCountWire.TYPE_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.category) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(JavaHeapHistogram.TypeCountWire.CATEGORY_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.obj_count != 0) {
                res += gremlin.sizes.sizeWireNumber(JavaHeapHistogram.TypeCountWire.OBJ_COUNT_WIRE) + gremlin.sizes.sizeU32(self.obj_count);
            }
            if (self.reachable_obj_count != 0) {
                res += gremlin.sizes.sizeWireNumber(JavaHeapHistogram.TypeCountWire.REACHABLE_OBJ_COUNT_WIRE) + gremlin.sizes.sizeU32(self.reachable_obj_count);
            }
            if (self.size_kb != 0) {
                res += gremlin.sizes.sizeWireNumber(JavaHeapHistogram.TypeCountWire.SIZE_KB_WIRE) + gremlin.sizes.sizeU32(self.size_kb);
            }
            if (self.reachable_size_kb != 0) {
                res += gremlin.sizes.sizeWireNumber(JavaHeapHistogram.TypeCountWire.REACHABLE_SIZE_KB_WIRE) + gremlin.sizes.sizeU32(self.reachable_size_kb);
            }
            if (self.native_size_kb != 0) {
                res += gremlin.sizes.sizeWireNumber(JavaHeapHistogram.TypeCountWire.NATIVE_SIZE_KB_WIRE) + gremlin.sizes.sizeU32(self.native_size_kb);
            }
            if (self.reachable_native_size_kb != 0) {
                res += gremlin.sizes.sizeWireNumber(JavaHeapHistogram.TypeCountWire.REACHABLE_NATIVE_SIZE_KB_WIRE) + gremlin.sizes.sizeU32(self.reachable_native_size_kb);
            }
            return res;
        }
        pub fn encode(self: *const JavaHeapHistogram.TypeCount, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const JavaHeapHistogram.TypeCount, target: *gremlin.Writer) void {
            if (self.type_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(JavaHeapHistogram.TypeCountWire.TYPE_NAME_WIRE, v);
                }
            }
            if (self.category) |v| {
                if (v.len > 0) {
                    target.appendBytes(JavaHeapHistogram.TypeCountWire.CATEGORY_WIRE, v);
                }
            }
            if (self.obj_count != 0) {
                target.appendUint32(JavaHeapHistogram.TypeCountWire.OBJ_COUNT_WIRE, self.obj_count);
            }
            if (self.reachable_obj_count != 0) {
                target.appendUint32(JavaHeapHistogram.TypeCountWire.REACHABLE_OBJ_COUNT_WIRE, self.reachable_obj_count);
            }
            if (self.size_kb != 0) {
                target.appendUint32(JavaHeapHistogram.TypeCountWire.SIZE_KB_WIRE, self.size_kb);
            }
            if (self.reachable_size_kb != 0) {
                target.appendUint32(JavaHeapHistogram.TypeCountWire.REACHABLE_SIZE_KB_WIRE, self.reachable_size_kb);
            }
            if (self.native_size_kb != 0) {
                target.appendUint32(JavaHeapHistogram.TypeCountWire.NATIVE_SIZE_KB_WIRE, self.native_size_kb);
            }
            if (self.reachable_native_size_kb != 0) {
                target.appendUint32(JavaHeapHistogram.TypeCountWire.REACHABLE_NATIVE_SIZE_KB_WIRE, self.reachable_native_size_kb);
            }
        }
    };
    pub const TypeCountReader = struct {
        buf: gremlin.Reader,
        _type_name: ?[]const u8 = null,
        _category: ?[]const u8 = null,
        _obj_count: u32 = 0,
        _reachable_obj_count: u32 = 0,
        _size_kb: u32 = 0,
        _reachable_size_kb: u32 = 0,
        _native_size_kb: u32 = 0,
        _reachable_native_size_kb: u32 = 0,
        pub fn init(src: []const u8) gremlin.Error!JavaHeapHistogram.TypeCountReader {
            const buf = gremlin.Reader.init(src);
            var res = JavaHeapHistogram.TypeCountReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    JavaHeapHistogram.TypeCountWire.TYPE_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._type_name = result.value;
                    },
                    JavaHeapHistogram.TypeCountWire.CATEGORY_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._category = result.value;
                    },
                    JavaHeapHistogram.TypeCountWire.OBJ_COUNT_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._obj_count = result.value;
                    },
                    JavaHeapHistogram.TypeCountWire.REACHABLE_OBJ_COUNT_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._reachable_obj_count = result.value;
                    },
                    JavaHeapHistogram.TypeCountWire.SIZE_KB_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._size_kb = result.value;
                    },
                    JavaHeapHistogram.TypeCountWire.REACHABLE_SIZE_KB_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._reachable_size_kb = result.value;
                    },
                    JavaHeapHistogram.TypeCountWire.NATIVE_SIZE_KB_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._native_size_kb = result.value;
                    },
                    JavaHeapHistogram.TypeCountWire.REACHABLE_NATIVE_SIZE_KB_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._reachable_native_size_kb = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getTypeName(self: *const JavaHeapHistogram.TypeCountReader) []const u8 {
            return self._type_name orelse &[_]u8{};
        }
        pub inline fn getCategory(self: *const JavaHeapHistogram.TypeCountReader) []const u8 {
            return self._category orelse &[_]u8{};
        }
        pub inline fn getObjCount(self: *const JavaHeapHistogram.TypeCountReader) u32 {
            return self._obj_count;
        }
        pub inline fn getReachableObjCount(self: *const JavaHeapHistogram.TypeCountReader) u32 {
            return self._reachable_obj_count;
        }
        pub inline fn getSizeKb(self: *const JavaHeapHistogram.TypeCountReader) u32 {
            return self._size_kb;
        }
        pub inline fn getReachableSizeKb(self: *const JavaHeapHistogram.TypeCountReader) u32 {
            return self._reachable_size_kb;
        }
        pub inline fn getNativeSizeKb(self: *const JavaHeapHistogram.TypeCountReader) u32 {
            return self._native_size_kb;
        }
        pub inline fn getReachableNativeSizeKb(self: *const JavaHeapHistogram.TypeCountReader) u32 {
            return self._reachable_native_size_kb;
        }
    };
    const SampleWire = struct {
        const TS_WIRE: gremlin.ProtoWireNumber = 1;
        const TYPE_COUNT_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const Sample = struct {
        // fields
        ts: i64 = 0,
        type_count: ?[]const ?JavaHeapHistogram.TypeCount = null,
        pub fn calcProtobufSize(self: *const JavaHeapHistogram.Sample) usize {
            var res: usize = 0;
            if (self.ts != 0) {
                res += gremlin.sizes.sizeWireNumber(JavaHeapHistogram.SampleWire.TS_WIRE) + gremlin.sizes.sizeI64(self.ts);
            }
            if (self.type_count) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(JavaHeapHistogram.SampleWire.TYPE_COUNT_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const JavaHeapHistogram.Sample, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const JavaHeapHistogram.Sample, target: *gremlin.Writer) void {
            if (self.ts != 0) {
                target.appendInt64(JavaHeapHistogram.SampleWire.TS_WIRE, self.ts);
            }
            if (self.type_count) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(JavaHeapHistogram.SampleWire.TYPE_COUNT_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(JavaHeapHistogram.SampleWire.TYPE_COUNT_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const SampleReader = struct {
        buf: gremlin.Reader,
        _ts: i64 = 0,
        _type_count_offset: ?usize = null,
        _type_count_last_offset: ?usize = null,
        _type_count_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!JavaHeapHistogram.SampleReader {
            const buf = gremlin.Reader.init(src);
            var res = JavaHeapHistogram.SampleReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    JavaHeapHistogram.SampleWire.TS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._ts = result.value;
                    },
                    JavaHeapHistogram.SampleWire.TYPE_COUNT_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._type_count_offset == null) {
                            res._type_count_offset = offset - result.size;
                        }
                        res._type_count_last_offset = offset;
                        res._type_count_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getTs(self: *const JavaHeapHistogram.SampleReader) i64 {
            return self._ts;
        }
        pub fn typeCountCount(self: *const JavaHeapHistogram.SampleReader) usize {
            return self._type_count_cnt;
        }
        pub fn typeCountNext(self: *JavaHeapHistogram.SampleReader) ?JavaHeapHistogram.TypeCountReader {
            if (self._type_count_offset == null) return null;
            const current_offset = self._type_count_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = JavaHeapHistogram.TypeCountReader.init(result.value) catch return null;
            if (self._type_count_last_offset != null and current_offset >= self._type_count_last_offset.?) {
                self._type_count_offset = null;
                return msg;
            }
            if (self._type_count_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._type_count_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == JavaHeapHistogram.SampleWire.TYPE_COUNT_WIRE) {
                    self._type_count_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._type_count_offset = null;
            return msg;
        }
    };
    const InstanceStatsWire = struct {
        const UPID_WIRE: gremlin.ProtoWireNumber = 1;
        const PROCESS_WIRE: gremlin.ProtoWireNumber = 2;
        const SAMPLES_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const InstanceStats = struct {
        // fields
        upid: u32 = 0,
        process: ?AndroidProcessMetadata = null,
        samples: ?[]const ?JavaHeapHistogram.Sample = null,
        pub fn calcProtobufSize(self: *const JavaHeapHistogram.InstanceStats) usize {
            var res: usize = 0;
            if (self.upid != 0) {
                res += gremlin.sizes.sizeWireNumber(JavaHeapHistogram.InstanceStatsWire.UPID_WIRE) + gremlin.sizes.sizeU32(self.upid);
            }
            if (self.process) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(JavaHeapHistogram.InstanceStatsWire.PROCESS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.samples) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(JavaHeapHistogram.InstanceStatsWire.SAMPLES_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const JavaHeapHistogram.InstanceStats, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const JavaHeapHistogram.InstanceStats, target: *gremlin.Writer) void {
            if (self.upid != 0) {
                target.appendUint32(JavaHeapHistogram.InstanceStatsWire.UPID_WIRE, self.upid);
            }
            if (self.process) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(JavaHeapHistogram.InstanceStatsWire.PROCESS_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.samples) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(JavaHeapHistogram.InstanceStatsWire.SAMPLES_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(JavaHeapHistogram.InstanceStatsWire.SAMPLES_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const InstanceStatsReader = struct {
        buf: gremlin.Reader,
        _upid: u32 = 0,
        _process_buf: ?[]const u8 = null,
        _samples_offset: ?usize = null,
        _samples_last_offset: ?usize = null,
        _samples_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!JavaHeapHistogram.InstanceStatsReader {
            const buf = gremlin.Reader.init(src);
            var res = JavaHeapHistogram.InstanceStatsReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    JavaHeapHistogram.InstanceStatsWire.UPID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._upid = result.value;
                    },
                    JavaHeapHistogram.InstanceStatsWire.PROCESS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._process_buf = result.value;
                    },
                    JavaHeapHistogram.InstanceStatsWire.SAMPLES_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._samples_offset == null) {
                            res._samples_offset = offset - result.size;
                        }
                        res._samples_last_offset = offset;
                        res._samples_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getUpid(self: *const JavaHeapHistogram.InstanceStatsReader) u32 {
            return self._upid;
        }
        pub fn getProcess(self: *const JavaHeapHistogram.InstanceStatsReader) gremlin.Error!AndroidProcessMetadataReader {
            if (self._process_buf) |buf| {
                return try AndroidProcessMetadataReader.init(buf);
            }
            return try AndroidProcessMetadataReader.init(&[_]u8{});
        }
        pub fn samplesCount(self: *const JavaHeapHistogram.InstanceStatsReader) usize {
            return self._samples_cnt;
        }
        pub fn samplesNext(self: *JavaHeapHistogram.InstanceStatsReader) ?JavaHeapHistogram.SampleReader {
            if (self._samples_offset == null) return null;
            const current_offset = self._samples_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = JavaHeapHistogram.SampleReader.init(result.value) catch return null;
            if (self._samples_last_offset != null and current_offset >= self._samples_last_offset.?) {
                self._samples_offset = null;
                return msg;
            }
            if (self._samples_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._samples_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == JavaHeapHistogram.InstanceStatsWire.SAMPLES_WIRE) {
                    self._samples_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._samples_offset = null;
            return msg;
        }
    };
    // fields
    instance_stats: ?[]const ?JavaHeapHistogram.InstanceStats = null,
    pub fn calcProtobufSize(self: *const JavaHeapHistogram) usize {
        var res: usize = 0;
        if (self.instance_stats) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(JavaHeapHistogramWire.INSTANCE_STATS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const JavaHeapHistogram, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const JavaHeapHistogram, target: *gremlin.Writer) void {
        if (self.instance_stats) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(JavaHeapHistogramWire.INSTANCE_STATS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(JavaHeapHistogramWire.INSTANCE_STATS_WIRE, 0);
                }
            }
        }
    }
};
pub const JavaHeapHistogramReader = struct {
    buf: gremlin.Reader,
    _instance_stats_offset: ?usize = null,
    _instance_stats_last_offset: ?usize = null,
    _instance_stats_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!JavaHeapHistogramReader {
        const buf = gremlin.Reader.init(src);
        var res = JavaHeapHistogramReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                JavaHeapHistogramWire.INSTANCE_STATS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._instance_stats_offset == null) {
                        res._instance_stats_offset = offset - result.size;
                    }
                    res._instance_stats_last_offset = offset;
                    res._instance_stats_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn instanceStatsCount(self: *const JavaHeapHistogramReader) usize {
        return self._instance_stats_cnt;
    }
    pub fn instanceStatsNext(self: *JavaHeapHistogramReader) ?JavaHeapHistogram.InstanceStatsReader {
        if (self._instance_stats_offset == null) return null;
        const current_offset = self._instance_stats_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = JavaHeapHistogram.InstanceStatsReader.init(result.value) catch return null;
        if (self._instance_stats_last_offset != null and current_offset >= self._instance_stats_last_offset.?) {
            self._instance_stats_offset = null;
            return msg;
        }
        if (self._instance_stats_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._instance_stats_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == JavaHeapHistogramWire.INSTANCE_STATS_WIRE) {
                self._instance_stats_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._instance_stats_offset = null;
        return msg;
    }
};
const JavaHeapStatsWire = struct {
    const INSTANCE_STATS_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const JavaHeapStats = struct {
    // nested structs
    const HeapRootsWire = struct {
        const ROOT_TYPE_WIRE: gremlin.ProtoWireNumber = 1;
        const TYPE_NAME_WIRE: gremlin.ProtoWireNumber = 2;
        const OBJ_COUNT_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const HeapRoots = struct {
        // fields
        root_type: ?[]const u8 = null,
        type_name: ?[]const u8 = null,
        obj_count: i64 = 0,
        pub fn calcProtobufSize(self: *const JavaHeapStats.HeapRoots) usize {
            var res: usize = 0;
            if (self.root_type) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(JavaHeapStats.HeapRootsWire.ROOT_TYPE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.type_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(JavaHeapStats.HeapRootsWire.TYPE_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.obj_count != 0) {
                res += gremlin.sizes.sizeWireNumber(JavaHeapStats.HeapRootsWire.OBJ_COUNT_WIRE) + gremlin.sizes.sizeI64(self.obj_count);
            }
            return res;
        }
        pub fn encode(self: *const JavaHeapStats.HeapRoots, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const JavaHeapStats.HeapRoots, target: *gremlin.Writer) void {
            if (self.root_type) |v| {
                if (v.len > 0) {
                    target.appendBytes(JavaHeapStats.HeapRootsWire.ROOT_TYPE_WIRE, v);
                }
            }
            if (self.type_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(JavaHeapStats.HeapRootsWire.TYPE_NAME_WIRE, v);
                }
            }
            if (self.obj_count != 0) {
                target.appendInt64(JavaHeapStats.HeapRootsWire.OBJ_COUNT_WIRE, self.obj_count);
            }
        }
    };
    pub const HeapRootsReader = struct {
        buf: gremlin.Reader,
        _root_type: ?[]const u8 = null,
        _type_name: ?[]const u8 = null,
        _obj_count: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!JavaHeapStats.HeapRootsReader {
            const buf = gremlin.Reader.init(src);
            var res = JavaHeapStats.HeapRootsReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    JavaHeapStats.HeapRootsWire.ROOT_TYPE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._root_type = result.value;
                    },
                    JavaHeapStats.HeapRootsWire.TYPE_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._type_name = result.value;
                    },
                    JavaHeapStats.HeapRootsWire.OBJ_COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._obj_count = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getRootType(self: *const JavaHeapStats.HeapRootsReader) []const u8 {
            return self._root_type orelse &[_]u8{};
        }
        pub inline fn getTypeName(self: *const JavaHeapStats.HeapRootsReader) []const u8 {
            return self._type_name orelse &[_]u8{};
        }
        pub inline fn getObjCount(self: *const JavaHeapStats.HeapRootsReader) i64 {
            return self._obj_count;
        }
    };
    const SampleWire = struct {
        const TS_WIRE: gremlin.ProtoWireNumber = 1;
        const HEAP_SIZE_WIRE: gremlin.ProtoWireNumber = 2;
        const HEAP_NATIVE_SIZE_WIRE: gremlin.ProtoWireNumber = 8;
        const OBJ_COUNT_WIRE: gremlin.ProtoWireNumber = 4;
        const REACHABLE_HEAP_SIZE_WIRE: gremlin.ProtoWireNumber = 3;
        const REACHABLE_HEAP_NATIVE_SIZE_WIRE: gremlin.ProtoWireNumber = 9;
        const REACHABLE_OBJ_COUNT_WIRE: gremlin.ProtoWireNumber = 5;
        const ANON_RSS_AND_SWAP_SIZE_WIRE: gremlin.ProtoWireNumber = 6;
        const ROOTS_WIRE: gremlin.ProtoWireNumber = 7;
        const OOM_SCORE_ADJ_WIRE: gremlin.ProtoWireNumber = 10;
        const PROCESS_UPTIME_MS_WIRE: gremlin.ProtoWireNumber = 11;
    };
    pub const Sample = struct {
        // fields
        ts: i64 = 0,
        heap_size: i64 = 0,
        heap_native_size: i64 = 0,
        obj_count: i64 = 0,
        reachable_heap_size: i64 = 0,
        reachable_heap_native_size: i64 = 0,
        reachable_obj_count: i64 = 0,
        anon_rss_and_swap_size: i64 = 0,
        roots: ?[]const ?JavaHeapStats.HeapRoots = null,
        oom_score_adj: i64 = 0,
        process_uptime_ms: i64 = 0,
        pub fn calcProtobufSize(self: *const JavaHeapStats.Sample) usize {
            var res: usize = 0;
            if (self.ts != 0) {
                res += gremlin.sizes.sizeWireNumber(JavaHeapStats.SampleWire.TS_WIRE) + gremlin.sizes.sizeI64(self.ts);
            }
            if (self.heap_size != 0) {
                res += gremlin.sizes.sizeWireNumber(JavaHeapStats.SampleWire.HEAP_SIZE_WIRE) + gremlin.sizes.sizeI64(self.heap_size);
            }
            if (self.heap_native_size != 0) {
                res += gremlin.sizes.sizeWireNumber(JavaHeapStats.SampleWire.HEAP_NATIVE_SIZE_WIRE) + gremlin.sizes.sizeI64(self.heap_native_size);
            }
            if (self.obj_count != 0) {
                res += gremlin.sizes.sizeWireNumber(JavaHeapStats.SampleWire.OBJ_COUNT_WIRE) + gremlin.sizes.sizeI64(self.obj_count);
            }
            if (self.reachable_heap_size != 0) {
                res += gremlin.sizes.sizeWireNumber(JavaHeapStats.SampleWire.REACHABLE_HEAP_SIZE_WIRE) + gremlin.sizes.sizeI64(self.reachable_heap_size);
            }
            if (self.reachable_heap_native_size != 0) {
                res += gremlin.sizes.sizeWireNumber(JavaHeapStats.SampleWire.REACHABLE_HEAP_NATIVE_SIZE_WIRE) + gremlin.sizes.sizeI64(self.reachable_heap_native_size);
            }
            if (self.reachable_obj_count != 0) {
                res += gremlin.sizes.sizeWireNumber(JavaHeapStats.SampleWire.REACHABLE_OBJ_COUNT_WIRE) + gremlin.sizes.sizeI64(self.reachable_obj_count);
            }
            if (self.anon_rss_and_swap_size != 0) {
                res += gremlin.sizes.sizeWireNumber(JavaHeapStats.SampleWire.ANON_RSS_AND_SWAP_SIZE_WIRE) + gremlin.sizes.sizeI64(self.anon_rss_and_swap_size);
            }
            if (self.roots) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(JavaHeapStats.SampleWire.ROOTS_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.oom_score_adj != 0) {
                res += gremlin.sizes.sizeWireNumber(JavaHeapStats.SampleWire.OOM_SCORE_ADJ_WIRE) + gremlin.sizes.sizeI64(self.oom_score_adj);
            }
            if (self.process_uptime_ms != 0) {
                res += gremlin.sizes.sizeWireNumber(JavaHeapStats.SampleWire.PROCESS_UPTIME_MS_WIRE) + gremlin.sizes.sizeI64(self.process_uptime_ms);
            }
            return res;
        }
        pub fn encode(self: *const JavaHeapStats.Sample, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const JavaHeapStats.Sample, target: *gremlin.Writer) void {
            if (self.ts != 0) {
                target.appendInt64(JavaHeapStats.SampleWire.TS_WIRE, self.ts);
            }
            if (self.heap_size != 0) {
                target.appendInt64(JavaHeapStats.SampleWire.HEAP_SIZE_WIRE, self.heap_size);
            }
            if (self.heap_native_size != 0) {
                target.appendInt64(JavaHeapStats.SampleWire.HEAP_NATIVE_SIZE_WIRE, self.heap_native_size);
            }
            if (self.obj_count != 0) {
                target.appendInt64(JavaHeapStats.SampleWire.OBJ_COUNT_WIRE, self.obj_count);
            }
            if (self.reachable_heap_size != 0) {
                target.appendInt64(JavaHeapStats.SampleWire.REACHABLE_HEAP_SIZE_WIRE, self.reachable_heap_size);
            }
            if (self.reachable_heap_native_size != 0) {
                target.appendInt64(JavaHeapStats.SampleWire.REACHABLE_HEAP_NATIVE_SIZE_WIRE, self.reachable_heap_native_size);
            }
            if (self.reachable_obj_count != 0) {
                target.appendInt64(JavaHeapStats.SampleWire.REACHABLE_OBJ_COUNT_WIRE, self.reachable_obj_count);
            }
            if (self.anon_rss_and_swap_size != 0) {
                target.appendInt64(JavaHeapStats.SampleWire.ANON_RSS_AND_SWAP_SIZE_WIRE, self.anon_rss_and_swap_size);
            }
            if (self.roots) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(JavaHeapStats.SampleWire.ROOTS_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(JavaHeapStats.SampleWire.ROOTS_WIRE, 0);
                    }
                }
            }
            if (self.oom_score_adj != 0) {
                target.appendInt64(JavaHeapStats.SampleWire.OOM_SCORE_ADJ_WIRE, self.oom_score_adj);
            }
            if (self.process_uptime_ms != 0) {
                target.appendInt64(JavaHeapStats.SampleWire.PROCESS_UPTIME_MS_WIRE, self.process_uptime_ms);
            }
        }
    };
    pub const SampleReader = struct {
        buf: gremlin.Reader,
        _ts: i64 = 0,
        _heap_size: i64 = 0,
        _heap_native_size: i64 = 0,
        _obj_count: i64 = 0,
        _reachable_heap_size: i64 = 0,
        _reachable_heap_native_size: i64 = 0,
        _reachable_obj_count: i64 = 0,
        _anon_rss_and_swap_size: i64 = 0,
        _roots_offset: ?usize = null,
        _roots_last_offset: ?usize = null,
        _roots_cnt: usize = 0,
        _oom_score_adj: i64 = 0,
        _process_uptime_ms: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!JavaHeapStats.SampleReader {
            const buf = gremlin.Reader.init(src);
            var res = JavaHeapStats.SampleReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    JavaHeapStats.SampleWire.TS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._ts = result.value;
                    },
                    JavaHeapStats.SampleWire.HEAP_SIZE_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._heap_size = result.value;
                    },
                    JavaHeapStats.SampleWire.HEAP_NATIVE_SIZE_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._heap_native_size = result.value;
                    },
                    JavaHeapStats.SampleWire.OBJ_COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._obj_count = result.value;
                    },
                    JavaHeapStats.SampleWire.REACHABLE_HEAP_SIZE_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._reachable_heap_size = result.value;
                    },
                    JavaHeapStats.SampleWire.REACHABLE_HEAP_NATIVE_SIZE_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._reachable_heap_native_size = result.value;
                    },
                    JavaHeapStats.SampleWire.REACHABLE_OBJ_COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._reachable_obj_count = result.value;
                    },
                    JavaHeapStats.SampleWire.ANON_RSS_AND_SWAP_SIZE_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._anon_rss_and_swap_size = result.value;
                    },
                    JavaHeapStats.SampleWire.ROOTS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._roots_offset == null) {
                            res._roots_offset = offset - result.size;
                        }
                        res._roots_last_offset = offset;
                        res._roots_cnt += 1;
                    },
                    JavaHeapStats.SampleWire.OOM_SCORE_ADJ_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._oom_score_adj = result.value;
                    },
                    JavaHeapStats.SampleWire.PROCESS_UPTIME_MS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._process_uptime_ms = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getTs(self: *const JavaHeapStats.SampleReader) i64 {
            return self._ts;
        }
        pub inline fn getHeapSize(self: *const JavaHeapStats.SampleReader) i64 {
            return self._heap_size;
        }
        pub inline fn getHeapNativeSize(self: *const JavaHeapStats.SampleReader) i64 {
            return self._heap_native_size;
        }
        pub inline fn getObjCount(self: *const JavaHeapStats.SampleReader) i64 {
            return self._obj_count;
        }
        pub inline fn getReachableHeapSize(self: *const JavaHeapStats.SampleReader) i64 {
            return self._reachable_heap_size;
        }
        pub inline fn getReachableHeapNativeSize(self: *const JavaHeapStats.SampleReader) i64 {
            return self._reachable_heap_native_size;
        }
        pub inline fn getReachableObjCount(self: *const JavaHeapStats.SampleReader) i64 {
            return self._reachable_obj_count;
        }
        pub inline fn getAnonRssAndSwapSize(self: *const JavaHeapStats.SampleReader) i64 {
            return self._anon_rss_and_swap_size;
        }
        pub fn rootsCount(self: *const JavaHeapStats.SampleReader) usize {
            return self._roots_cnt;
        }
        pub fn rootsNext(self: *JavaHeapStats.SampleReader) ?JavaHeapStats.HeapRootsReader {
            if (self._roots_offset == null) return null;
            const current_offset = self._roots_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = JavaHeapStats.HeapRootsReader.init(result.value) catch return null;
            if (self._roots_last_offset != null and current_offset >= self._roots_last_offset.?) {
                self._roots_offset = null;
                return msg;
            }
            if (self._roots_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._roots_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == JavaHeapStats.SampleWire.ROOTS_WIRE) {
                    self._roots_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._roots_offset = null;
            return msg;
        }
        pub inline fn getOomScoreAdj(self: *const JavaHeapStats.SampleReader) i64 {
            return self._oom_score_adj;
        }
        pub inline fn getProcessUptimeMs(self: *const JavaHeapStats.SampleReader) i64 {
            return self._process_uptime_ms;
        }
    };
    const InstanceStatsWire = struct {
        const UPID_WIRE: gremlin.ProtoWireNumber = 1;
        const PROCESS_WIRE: gremlin.ProtoWireNumber = 2;
        const SAMPLES_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const InstanceStats = struct {
        // fields
        upid: u32 = 0,
        process: ?AndroidProcessMetadata = null,
        samples: ?[]const ?JavaHeapStats.Sample = null,
        pub fn calcProtobufSize(self: *const JavaHeapStats.InstanceStats) usize {
            var res: usize = 0;
            if (self.upid != 0) {
                res += gremlin.sizes.sizeWireNumber(JavaHeapStats.InstanceStatsWire.UPID_WIRE) + gremlin.sizes.sizeU32(self.upid);
            }
            if (self.process) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(JavaHeapStats.InstanceStatsWire.PROCESS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.samples) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(JavaHeapStats.InstanceStatsWire.SAMPLES_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const JavaHeapStats.InstanceStats, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const JavaHeapStats.InstanceStats, target: *gremlin.Writer) void {
            if (self.upid != 0) {
                target.appendUint32(JavaHeapStats.InstanceStatsWire.UPID_WIRE, self.upid);
            }
            if (self.process) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(JavaHeapStats.InstanceStatsWire.PROCESS_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.samples) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(JavaHeapStats.InstanceStatsWire.SAMPLES_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(JavaHeapStats.InstanceStatsWire.SAMPLES_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const InstanceStatsReader = struct {
        buf: gremlin.Reader,
        _upid: u32 = 0,
        _process_buf: ?[]const u8 = null,
        _samples_offset: ?usize = null,
        _samples_last_offset: ?usize = null,
        _samples_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!JavaHeapStats.InstanceStatsReader {
            const buf = gremlin.Reader.init(src);
            var res = JavaHeapStats.InstanceStatsReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    JavaHeapStats.InstanceStatsWire.UPID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._upid = result.value;
                    },
                    JavaHeapStats.InstanceStatsWire.PROCESS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._process_buf = result.value;
                    },
                    JavaHeapStats.InstanceStatsWire.SAMPLES_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._samples_offset == null) {
                            res._samples_offset = offset - result.size;
                        }
                        res._samples_last_offset = offset;
                        res._samples_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getUpid(self: *const JavaHeapStats.InstanceStatsReader) u32 {
            return self._upid;
        }
        pub fn getProcess(self: *const JavaHeapStats.InstanceStatsReader) gremlin.Error!AndroidProcessMetadataReader {
            if (self._process_buf) |buf| {
                return try AndroidProcessMetadataReader.init(buf);
            }
            return try AndroidProcessMetadataReader.init(&[_]u8{});
        }
        pub fn samplesCount(self: *const JavaHeapStats.InstanceStatsReader) usize {
            return self._samples_cnt;
        }
        pub fn samplesNext(self: *JavaHeapStats.InstanceStatsReader) ?JavaHeapStats.SampleReader {
            if (self._samples_offset == null) return null;
            const current_offset = self._samples_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = JavaHeapStats.SampleReader.init(result.value) catch return null;
            if (self._samples_last_offset != null and current_offset >= self._samples_last_offset.?) {
                self._samples_offset = null;
                return msg;
            }
            if (self._samples_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._samples_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == JavaHeapStats.InstanceStatsWire.SAMPLES_WIRE) {
                    self._samples_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._samples_offset = null;
            return msg;
        }
    };
    // fields
    instance_stats: ?[]const ?JavaHeapStats.InstanceStats = null,
    pub fn calcProtobufSize(self: *const JavaHeapStats) usize {
        var res: usize = 0;
        if (self.instance_stats) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(JavaHeapStatsWire.INSTANCE_STATS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const JavaHeapStats, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const JavaHeapStats, target: *gremlin.Writer) void {
        if (self.instance_stats) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(JavaHeapStatsWire.INSTANCE_STATS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(JavaHeapStatsWire.INSTANCE_STATS_WIRE, 0);
                }
            }
        }
    }
};
pub const JavaHeapStatsReader = struct {
    buf: gremlin.Reader,
    _instance_stats_offset: ?usize = null,
    _instance_stats_last_offset: ?usize = null,
    _instance_stats_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!JavaHeapStatsReader {
        const buf = gremlin.Reader.init(src);
        var res = JavaHeapStatsReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                JavaHeapStatsWire.INSTANCE_STATS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._instance_stats_offset == null) {
                        res._instance_stats_offset = offset - result.size;
                    }
                    res._instance_stats_last_offset = offset;
                    res._instance_stats_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn instanceStatsCount(self: *const JavaHeapStatsReader) usize {
        return self._instance_stats_cnt;
    }
    pub fn instanceStatsNext(self: *JavaHeapStatsReader) ?JavaHeapStats.InstanceStatsReader {
        if (self._instance_stats_offset == null) return null;
        const current_offset = self._instance_stats_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = JavaHeapStats.InstanceStatsReader.init(result.value) catch return null;
        if (self._instance_stats_last_offset != null and current_offset >= self._instance_stats_last_offset.?) {
            self._instance_stats_offset = null;
            return msg;
        }
        if (self._instance_stats_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._instance_stats_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == JavaHeapStatsWire.INSTANCE_STATS_WIRE) {
                self._instance_stats_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._instance_stats_offset = null;
        return msg;
    }
};
const AndroidLmkMetricWire = struct {
    const TOTAL_COUNT_WIRE: gremlin.ProtoWireNumber = 1;
    const BY_OOM_SCORE_WIRE: gremlin.ProtoWireNumber = 2;
    const OOM_VICTIM_COUNT_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const AndroidLmkMetric = struct {
    // nested structs
    const ByOomScoreWire = struct {
        const OOM_SCORE_ADJ_WIRE: gremlin.ProtoWireNumber = 1;
        const COUNT_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const ByOomScore = struct {
        // fields
        oom_score_adj: i32 = 0,
        count: i32 = 0,
        pub fn calcProtobufSize(self: *const AndroidLmkMetric.ByOomScore) usize {
            var res: usize = 0;
            if (self.oom_score_adj != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidLmkMetric.ByOomScoreWire.OOM_SCORE_ADJ_WIRE) + gremlin.sizes.sizeI32(self.oom_score_adj);
            }
            if (self.count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidLmkMetric.ByOomScoreWire.COUNT_WIRE) + gremlin.sizes.sizeI32(self.count);
            }
            return res;
        }
        pub fn encode(self: *const AndroidLmkMetric.ByOomScore, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidLmkMetric.ByOomScore, target: *gremlin.Writer) void {
            if (self.oom_score_adj != 0) {
                target.appendInt32(AndroidLmkMetric.ByOomScoreWire.OOM_SCORE_ADJ_WIRE, self.oom_score_adj);
            }
            if (self.count != 0) {
                target.appendInt32(AndroidLmkMetric.ByOomScoreWire.COUNT_WIRE, self.count);
            }
        }
    };
    pub const ByOomScoreReader = struct {
        buf: gremlin.Reader,
        _oom_score_adj: i32 = 0,
        _count: i32 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidLmkMetric.ByOomScoreReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidLmkMetric.ByOomScoreReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidLmkMetric.ByOomScoreWire.OOM_SCORE_ADJ_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._oom_score_adj = result.value;
                    },
                    AndroidLmkMetric.ByOomScoreWire.COUNT_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._count = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getOomScoreAdj(self: *const AndroidLmkMetric.ByOomScoreReader) i32 {
            return self._oom_score_adj;
        }
        pub inline fn getCount(self: *const AndroidLmkMetric.ByOomScoreReader) i32 {
            return self._count;
        }
    };
    // fields
    total_count: i32 = 0,
    by_oom_score: ?[]const ?AndroidLmkMetric.ByOomScore = null,
    oom_victim_count: i32 = 0,
    pub fn calcProtobufSize(self: *const AndroidLmkMetric) usize {
        var res: usize = 0;
        if (self.total_count != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidLmkMetricWire.TOTAL_COUNT_WIRE) + gremlin.sizes.sizeI32(self.total_count);
        }
        if (self.by_oom_score) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidLmkMetricWire.BY_OOM_SCORE_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.oom_victim_count != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidLmkMetricWire.OOM_VICTIM_COUNT_WIRE) + gremlin.sizes.sizeI32(self.oom_victim_count);
        }
        return res;
    }
    pub fn encode(self: *const AndroidLmkMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidLmkMetric, target: *gremlin.Writer) void {
        if (self.total_count != 0) {
            target.appendInt32(AndroidLmkMetricWire.TOTAL_COUNT_WIRE, self.total_count);
        }
        if (self.by_oom_score) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidLmkMetricWire.BY_OOM_SCORE_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidLmkMetricWire.BY_OOM_SCORE_WIRE, 0);
                }
            }
        }
        if (self.oom_victim_count != 0) {
            target.appendInt32(AndroidLmkMetricWire.OOM_VICTIM_COUNT_WIRE, self.oom_victim_count);
        }
    }
};
pub const AndroidLmkMetricReader = struct {
    buf: gremlin.Reader,
    _total_count: i32 = 0,
    _by_oom_score_offset: ?usize = null,
    _by_oom_score_last_offset: ?usize = null,
    _by_oom_score_cnt: usize = 0,
    _oom_victim_count: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidLmkMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidLmkMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidLmkMetricWire.TOTAL_COUNT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._total_count = result.value;
                },
                AndroidLmkMetricWire.BY_OOM_SCORE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._by_oom_score_offset == null) {
                        res._by_oom_score_offset = offset - result.size;
                    }
                    res._by_oom_score_last_offset = offset;
                    res._by_oom_score_cnt += 1;
                },
                AndroidLmkMetricWire.OOM_VICTIM_COUNT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._oom_victim_count = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getTotalCount(self: *const AndroidLmkMetricReader) i32 {
        return self._total_count;
    }
    pub fn byOomScoreCount(self: *const AndroidLmkMetricReader) usize {
        return self._by_oom_score_cnt;
    }
    pub fn byOomScoreNext(self: *AndroidLmkMetricReader) ?AndroidLmkMetric.ByOomScoreReader {
        if (self._by_oom_score_offset == null) return null;
        const current_offset = self._by_oom_score_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidLmkMetric.ByOomScoreReader.init(result.value) catch return null;
        if (self._by_oom_score_last_offset != null and current_offset >= self._by_oom_score_last_offset.?) {
            self._by_oom_score_offset = null;
            return msg;
        }
        if (self._by_oom_score_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._by_oom_score_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidLmkMetricWire.BY_OOM_SCORE_WIRE) {
                self._by_oom_score_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._by_oom_score_offset = null;
        return msg;
    }
    pub inline fn getOomVictimCount(self: *const AndroidLmkMetricReader) i32 {
        return self._oom_victim_count;
    }
};
const AndroidLmkReasonMetricWire = struct {
    const LMKS_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const AndroidLmkReasonMetric = struct {
    // nested structs
    const ProcessWire = struct {
        const PROCESS_WIRE: gremlin.ProtoWireNumber = 1;
        const OOM_SCORE_ADJ_WIRE: gremlin.ProtoWireNumber = 2;
        const SIZE_WIRE: gremlin.ProtoWireNumber = 3;
        const FILE_RSS_BYTES_WIRE: gremlin.ProtoWireNumber = 4;
        const ANON_RSS_BYTES_WIRE: gremlin.ProtoWireNumber = 5;
        const SHMEM_RSS_BYTES_WIRE: gremlin.ProtoWireNumber = 6;
        const SWAP_BYTES_WIRE: gremlin.ProtoWireNumber = 7;
    };
    pub const Process = struct {
        // fields
        process: ?AndroidProcessMetadata = null,
        oom_score_adj: i32 = 0,
        size: i64 = 0,
        file_rss_bytes: i64 = 0,
        anon_rss_bytes: i64 = 0,
        shmem_rss_bytes: i64 = 0,
        swap_bytes: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidLmkReasonMetric.Process) usize {
            var res: usize = 0;
            if (self.process) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidLmkReasonMetric.ProcessWire.PROCESS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.oom_score_adj != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidLmkReasonMetric.ProcessWire.OOM_SCORE_ADJ_WIRE) + gremlin.sizes.sizeI32(self.oom_score_adj);
            }
            if (self.size != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidLmkReasonMetric.ProcessWire.SIZE_WIRE) + gremlin.sizes.sizeI64(self.size);
            }
            if (self.file_rss_bytes != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidLmkReasonMetric.ProcessWire.FILE_RSS_BYTES_WIRE) + gremlin.sizes.sizeI64(self.file_rss_bytes);
            }
            if (self.anon_rss_bytes != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidLmkReasonMetric.ProcessWire.ANON_RSS_BYTES_WIRE) + gremlin.sizes.sizeI64(self.anon_rss_bytes);
            }
            if (self.shmem_rss_bytes != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidLmkReasonMetric.ProcessWire.SHMEM_RSS_BYTES_WIRE) + gremlin.sizes.sizeI64(self.shmem_rss_bytes);
            }
            if (self.swap_bytes != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidLmkReasonMetric.ProcessWire.SWAP_BYTES_WIRE) + gremlin.sizes.sizeI64(self.swap_bytes);
            }
            return res;
        }
        pub fn encode(self: *const AndroidLmkReasonMetric.Process, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidLmkReasonMetric.Process, target: *gremlin.Writer) void {
            if (self.process) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidLmkReasonMetric.ProcessWire.PROCESS_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.oom_score_adj != 0) {
                target.appendInt32(AndroidLmkReasonMetric.ProcessWire.OOM_SCORE_ADJ_WIRE, self.oom_score_adj);
            }
            if (self.size != 0) {
                target.appendInt64(AndroidLmkReasonMetric.ProcessWire.SIZE_WIRE, self.size);
            }
            if (self.file_rss_bytes != 0) {
                target.appendInt64(AndroidLmkReasonMetric.ProcessWire.FILE_RSS_BYTES_WIRE, self.file_rss_bytes);
            }
            if (self.anon_rss_bytes != 0) {
                target.appendInt64(AndroidLmkReasonMetric.ProcessWire.ANON_RSS_BYTES_WIRE, self.anon_rss_bytes);
            }
            if (self.shmem_rss_bytes != 0) {
                target.appendInt64(AndroidLmkReasonMetric.ProcessWire.SHMEM_RSS_BYTES_WIRE, self.shmem_rss_bytes);
            }
            if (self.swap_bytes != 0) {
                target.appendInt64(AndroidLmkReasonMetric.ProcessWire.SWAP_BYTES_WIRE, self.swap_bytes);
            }
        }
    };
    pub const ProcessReader = struct {
        buf: gremlin.Reader,
        _process_buf: ?[]const u8 = null,
        _oom_score_adj: i32 = 0,
        _size: i64 = 0,
        _file_rss_bytes: i64 = 0,
        _anon_rss_bytes: i64 = 0,
        _shmem_rss_bytes: i64 = 0,
        _swap_bytes: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidLmkReasonMetric.ProcessReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidLmkReasonMetric.ProcessReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidLmkReasonMetric.ProcessWire.PROCESS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._process_buf = result.value;
                    },
                    AndroidLmkReasonMetric.ProcessWire.OOM_SCORE_ADJ_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._oom_score_adj = result.value;
                    },
                    AndroidLmkReasonMetric.ProcessWire.SIZE_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._size = result.value;
                    },
                    AndroidLmkReasonMetric.ProcessWire.FILE_RSS_BYTES_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._file_rss_bytes = result.value;
                    },
                    AndroidLmkReasonMetric.ProcessWire.ANON_RSS_BYTES_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._anon_rss_bytes = result.value;
                    },
                    AndroidLmkReasonMetric.ProcessWire.SHMEM_RSS_BYTES_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._shmem_rss_bytes = result.value;
                    },
                    AndroidLmkReasonMetric.ProcessWire.SWAP_BYTES_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._swap_bytes = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn getProcess(self: *const AndroidLmkReasonMetric.ProcessReader) gremlin.Error!AndroidProcessMetadataReader {
            if (self._process_buf) |buf| {
                return try AndroidProcessMetadataReader.init(buf);
            }
            return try AndroidProcessMetadataReader.init(&[_]u8{});
        }
        pub inline fn getOomScoreAdj(self: *const AndroidLmkReasonMetric.ProcessReader) i32 {
            return self._oom_score_adj;
        }
        pub inline fn getSize(self: *const AndroidLmkReasonMetric.ProcessReader) i64 {
            return self._size;
        }
        pub inline fn getFileRssBytes(self: *const AndroidLmkReasonMetric.ProcessReader) i64 {
            return self._file_rss_bytes;
        }
        pub inline fn getAnonRssBytes(self: *const AndroidLmkReasonMetric.ProcessReader) i64 {
            return self._anon_rss_bytes;
        }
        pub inline fn getShmemRssBytes(self: *const AndroidLmkReasonMetric.ProcessReader) i64 {
            return self._shmem_rss_bytes;
        }
        pub inline fn getSwapBytes(self: *const AndroidLmkReasonMetric.ProcessReader) i64 {
            return self._swap_bytes;
        }
    };
    const LmkWire = struct {
        const OOM_SCORE_ADJ_WIRE: gremlin.ProtoWireNumber = 1;
        const ION_HEAPS_BYTES_WIRE: gremlin.ProtoWireNumber = 4;
        const SYSTEM_ION_HEAP_SIZE_WIRE: gremlin.ProtoWireNumber = 2;
        const PROCESSES_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const Lmk = struct {
        // fields
        oom_score_adj: i32 = 0,
        ion_heaps_bytes: i64 = 0,
        system_ion_heap_size: i64 = 0,
        processes: ?[]const ?AndroidLmkReasonMetric.Process = null,
        pub fn calcProtobufSize(self: *const AndroidLmkReasonMetric.Lmk) usize {
            var res: usize = 0;
            if (self.oom_score_adj != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidLmkReasonMetric.LmkWire.OOM_SCORE_ADJ_WIRE) + gremlin.sizes.sizeI32(self.oom_score_adj);
            }
            if (self.ion_heaps_bytes != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidLmkReasonMetric.LmkWire.ION_HEAPS_BYTES_WIRE) + gremlin.sizes.sizeI64(self.ion_heaps_bytes);
            }
            if (self.system_ion_heap_size != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidLmkReasonMetric.LmkWire.SYSTEM_ION_HEAP_SIZE_WIRE) + gremlin.sizes.sizeI64(self.system_ion_heap_size);
            }
            if (self.processes) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidLmkReasonMetric.LmkWire.PROCESSES_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidLmkReasonMetric.Lmk, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidLmkReasonMetric.Lmk, target: *gremlin.Writer) void {
            if (self.oom_score_adj != 0) {
                target.appendInt32(AndroidLmkReasonMetric.LmkWire.OOM_SCORE_ADJ_WIRE, self.oom_score_adj);
            }
            if (self.ion_heaps_bytes != 0) {
                target.appendInt64(AndroidLmkReasonMetric.LmkWire.ION_HEAPS_BYTES_WIRE, self.ion_heaps_bytes);
            }
            if (self.system_ion_heap_size != 0) {
                target.appendInt64(AndroidLmkReasonMetric.LmkWire.SYSTEM_ION_HEAP_SIZE_WIRE, self.system_ion_heap_size);
            }
            if (self.processes) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidLmkReasonMetric.LmkWire.PROCESSES_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidLmkReasonMetric.LmkWire.PROCESSES_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const LmkReader = struct {
        buf: gremlin.Reader,
        _oom_score_adj: i32 = 0,
        _ion_heaps_bytes: i64 = 0,
        _system_ion_heap_size: i64 = 0,
        _processes_offset: ?usize = null,
        _processes_last_offset: ?usize = null,
        _processes_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidLmkReasonMetric.LmkReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidLmkReasonMetric.LmkReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidLmkReasonMetric.LmkWire.OOM_SCORE_ADJ_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._oom_score_adj = result.value;
                    },
                    AndroidLmkReasonMetric.LmkWire.ION_HEAPS_BYTES_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._ion_heaps_bytes = result.value;
                    },
                    AndroidLmkReasonMetric.LmkWire.SYSTEM_ION_HEAP_SIZE_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._system_ion_heap_size = result.value;
                    },
                    AndroidLmkReasonMetric.LmkWire.PROCESSES_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._processes_offset == null) {
                            res._processes_offset = offset - result.size;
                        }
                        res._processes_last_offset = offset;
                        res._processes_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getOomScoreAdj(self: *const AndroidLmkReasonMetric.LmkReader) i32 {
            return self._oom_score_adj;
        }
        pub inline fn getIonHeapsBytes(self: *const AndroidLmkReasonMetric.LmkReader) i64 {
            return self._ion_heaps_bytes;
        }
        pub inline fn getSystemIonHeapSize(self: *const AndroidLmkReasonMetric.LmkReader) i64 {
            return self._system_ion_heap_size;
        }
        pub fn processesCount(self: *const AndroidLmkReasonMetric.LmkReader) usize {
            return self._processes_cnt;
        }
        pub fn processesNext(self: *AndroidLmkReasonMetric.LmkReader) ?AndroidLmkReasonMetric.ProcessReader {
            if (self._processes_offset == null) return null;
            const current_offset = self._processes_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidLmkReasonMetric.ProcessReader.init(result.value) catch return null;
            if (self._processes_last_offset != null and current_offset >= self._processes_last_offset.?) {
                self._processes_offset = null;
                return msg;
            }
            if (self._processes_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._processes_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidLmkReasonMetric.LmkWire.PROCESSES_WIRE) {
                    self._processes_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._processes_offset = null;
            return msg;
        }
    };
    // fields
    lmks: ?[]const ?AndroidLmkReasonMetric.Lmk = null,
    pub fn calcProtobufSize(self: *const AndroidLmkReasonMetric) usize {
        var res: usize = 0;
        if (self.lmks) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidLmkReasonMetricWire.LMKS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidLmkReasonMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidLmkReasonMetric, target: *gremlin.Writer) void {
        if (self.lmks) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidLmkReasonMetricWire.LMKS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidLmkReasonMetricWire.LMKS_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidLmkReasonMetricReader = struct {
    buf: gremlin.Reader,
    _lmks_offset: ?usize = null,
    _lmks_last_offset: ?usize = null,
    _lmks_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidLmkReasonMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidLmkReasonMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidLmkReasonMetricWire.LMKS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._lmks_offset == null) {
                        res._lmks_offset = offset - result.size;
                    }
                    res._lmks_last_offset = offset;
                    res._lmks_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn lmksCount(self: *const AndroidLmkReasonMetricReader) usize {
        return self._lmks_cnt;
    }
    pub fn lmksNext(self: *AndroidLmkReasonMetricReader) ?AndroidLmkReasonMetric.LmkReader {
        if (self._lmks_offset == null) return null;
        const current_offset = self._lmks_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidLmkReasonMetric.LmkReader.init(result.value) catch return null;
        if (self._lmks_last_offset != null and current_offset >= self._lmks_last_offset.?) {
            self._lmks_offset = null;
            return msg;
        }
        if (self._lmks_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._lmks_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidLmkReasonMetricWire.LMKS_WIRE) {
                self._lmks_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._lmks_offset = null;
        return msg;
    }
};
const AndroidMemoryMetricWire = struct {
    const PROCESS_METRICS_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const AndroidMemoryMetric = struct {
    // nested structs
    const ProcessMetricsWire = struct {
        const PROCESS_NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const TOTAL_COUNTERS_WIRE: gremlin.ProtoWireNumber = 2;
        const PRIORITY_BREAKDOWN_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const ProcessMetrics = struct {
        // fields
        process_name: ?[]const u8 = null,
        total_counters: ?AndroidMemoryMetric.ProcessMemoryCounters = null,
        priority_breakdown: ?[]const ?AndroidMemoryMetric.PriorityBreakdown = null,
        pub fn calcProtobufSize(self: *const AndroidMemoryMetric.ProcessMetrics) usize {
            var res: usize = 0;
            if (self.process_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidMemoryMetric.ProcessMetricsWire.PROCESS_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.total_counters) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidMemoryMetric.ProcessMetricsWire.TOTAL_COUNTERS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.priority_breakdown) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidMemoryMetric.ProcessMetricsWire.PRIORITY_BREAKDOWN_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidMemoryMetric.ProcessMetrics, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidMemoryMetric.ProcessMetrics, target: *gremlin.Writer) void {
            if (self.process_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidMemoryMetric.ProcessMetricsWire.PROCESS_NAME_WIRE, v);
                }
            }
            if (self.total_counters) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidMemoryMetric.ProcessMetricsWire.TOTAL_COUNTERS_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.priority_breakdown) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidMemoryMetric.ProcessMetricsWire.PRIORITY_BREAKDOWN_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidMemoryMetric.ProcessMetricsWire.PRIORITY_BREAKDOWN_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const ProcessMetricsReader = struct {
        buf: gremlin.Reader,
        _process_name: ?[]const u8 = null,
        _total_counters_buf: ?[]const u8 = null,
        _priority_breakdown_offset: ?usize = null,
        _priority_breakdown_last_offset: ?usize = null,
        _priority_breakdown_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidMemoryMetric.ProcessMetricsReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidMemoryMetric.ProcessMetricsReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidMemoryMetric.ProcessMetricsWire.PROCESS_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._process_name = result.value;
                    },
                    AndroidMemoryMetric.ProcessMetricsWire.TOTAL_COUNTERS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._total_counters_buf = result.value;
                    },
                    AndroidMemoryMetric.ProcessMetricsWire.PRIORITY_BREAKDOWN_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._priority_breakdown_offset == null) {
                            res._priority_breakdown_offset = offset - result.size;
                        }
                        res._priority_breakdown_last_offset = offset;
                        res._priority_breakdown_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getProcessName(self: *const AndroidMemoryMetric.ProcessMetricsReader) []const u8 {
            return self._process_name orelse &[_]u8{};
        }
        pub fn getTotalCounters(self: *const AndroidMemoryMetric.ProcessMetricsReader) gremlin.Error!AndroidMemoryMetric.ProcessMemoryCountersReader {
            if (self._total_counters_buf) |buf| {
                return try AndroidMemoryMetric.ProcessMemoryCountersReader.init(buf);
            }
            return try AndroidMemoryMetric.ProcessMemoryCountersReader.init(&[_]u8{});
        }
        pub fn priorityBreakdownCount(self: *const AndroidMemoryMetric.ProcessMetricsReader) usize {
            return self._priority_breakdown_cnt;
        }
        pub fn priorityBreakdownNext(self: *AndroidMemoryMetric.ProcessMetricsReader) ?AndroidMemoryMetric.PriorityBreakdownReader {
            if (self._priority_breakdown_offset == null) return null;
            const current_offset = self._priority_breakdown_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidMemoryMetric.PriorityBreakdownReader.init(result.value) catch return null;
            if (self._priority_breakdown_last_offset != null and current_offset >= self._priority_breakdown_last_offset.?) {
                self._priority_breakdown_offset = null;
                return msg;
            }
            if (self._priority_breakdown_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._priority_breakdown_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidMemoryMetric.ProcessMetricsWire.PRIORITY_BREAKDOWN_WIRE) {
                    self._priority_breakdown_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._priority_breakdown_offset = null;
            return msg;
        }
    };
    const PriorityBreakdownWire = struct {
        const PRIORITY_WIRE: gremlin.ProtoWireNumber = 1;
        const COUNTERS_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const PriorityBreakdown = struct {
        // fields
        priority: ?[]const u8 = null,
        counters: ?AndroidMemoryMetric.ProcessMemoryCounters = null,
        pub fn calcProtobufSize(self: *const AndroidMemoryMetric.PriorityBreakdown) usize {
            var res: usize = 0;
            if (self.priority) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidMemoryMetric.PriorityBreakdownWire.PRIORITY_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.counters) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidMemoryMetric.PriorityBreakdownWire.COUNTERS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidMemoryMetric.PriorityBreakdown, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidMemoryMetric.PriorityBreakdown, target: *gremlin.Writer) void {
            if (self.priority) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidMemoryMetric.PriorityBreakdownWire.PRIORITY_WIRE, v);
                }
            }
            if (self.counters) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidMemoryMetric.PriorityBreakdownWire.COUNTERS_WIRE, size);
                    v.encodeTo(target);
                }
            }
        }
    };
    pub const PriorityBreakdownReader = struct {
        buf: gremlin.Reader,
        _priority: ?[]const u8 = null,
        _counters_buf: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!AndroidMemoryMetric.PriorityBreakdownReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidMemoryMetric.PriorityBreakdownReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidMemoryMetric.PriorityBreakdownWire.PRIORITY_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._priority = result.value;
                    },
                    AndroidMemoryMetric.PriorityBreakdownWire.COUNTERS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._counters_buf = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getPriority(self: *const AndroidMemoryMetric.PriorityBreakdownReader) []const u8 {
            return self._priority orelse &[_]u8{};
        }
        pub fn getCounters(self: *const AndroidMemoryMetric.PriorityBreakdownReader) gremlin.Error!AndroidMemoryMetric.ProcessMemoryCountersReader {
            if (self._counters_buf) |buf| {
                return try AndroidMemoryMetric.ProcessMemoryCountersReader.init(buf);
            }
            return try AndroidMemoryMetric.ProcessMemoryCountersReader.init(&[_]u8{});
        }
    };
    const ProcessMemoryCountersWire = struct {
        const ANON_RSS_WIRE: gremlin.ProtoWireNumber = 1;
        const FILE_RSS_WIRE: gremlin.ProtoWireNumber = 2;
        const SWAP_WIRE: gremlin.ProtoWireNumber = 3;
        const ANON_AND_SWAP_WIRE: gremlin.ProtoWireNumber = 4;
        const JAVA_HEAP_WIRE: gremlin.ProtoWireNumber = 5;
    };
    pub const ProcessMemoryCounters = struct {
        // fields
        anon_rss: ?AndroidMemoryMetric.Counter = null,
        file_rss: ?AndroidMemoryMetric.Counter = null,
        swap: ?AndroidMemoryMetric.Counter = null,
        anon_and_swap: ?AndroidMemoryMetric.Counter = null,
        java_heap: ?AndroidMemoryMetric.Counter = null,
        pub fn calcProtobufSize(self: *const AndroidMemoryMetric.ProcessMemoryCounters) usize {
            var res: usize = 0;
            if (self.anon_rss) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidMemoryMetric.ProcessMemoryCountersWire.ANON_RSS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.file_rss) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidMemoryMetric.ProcessMemoryCountersWire.FILE_RSS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.swap) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidMemoryMetric.ProcessMemoryCountersWire.SWAP_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.anon_and_swap) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidMemoryMetric.ProcessMemoryCountersWire.ANON_AND_SWAP_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.java_heap) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidMemoryMetric.ProcessMemoryCountersWire.JAVA_HEAP_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidMemoryMetric.ProcessMemoryCounters, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidMemoryMetric.ProcessMemoryCounters, target: *gremlin.Writer) void {
            if (self.anon_rss) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidMemoryMetric.ProcessMemoryCountersWire.ANON_RSS_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.file_rss) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidMemoryMetric.ProcessMemoryCountersWire.FILE_RSS_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.swap) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidMemoryMetric.ProcessMemoryCountersWire.SWAP_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.anon_and_swap) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidMemoryMetric.ProcessMemoryCountersWire.ANON_AND_SWAP_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.java_heap) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidMemoryMetric.ProcessMemoryCountersWire.JAVA_HEAP_WIRE, size);
                    v.encodeTo(target);
                }
            }
        }
    };
    pub const ProcessMemoryCountersReader = struct {
        buf: gremlin.Reader,
        _anon_rss_buf: ?[]const u8 = null,
        _file_rss_buf: ?[]const u8 = null,
        _swap_buf: ?[]const u8 = null,
        _anon_and_swap_buf: ?[]const u8 = null,
        _java_heap_buf: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!AndroidMemoryMetric.ProcessMemoryCountersReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidMemoryMetric.ProcessMemoryCountersReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidMemoryMetric.ProcessMemoryCountersWire.ANON_RSS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._anon_rss_buf = result.value;
                    },
                    AndroidMemoryMetric.ProcessMemoryCountersWire.FILE_RSS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._file_rss_buf = result.value;
                    },
                    AndroidMemoryMetric.ProcessMemoryCountersWire.SWAP_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._swap_buf = result.value;
                    },
                    AndroidMemoryMetric.ProcessMemoryCountersWire.ANON_AND_SWAP_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._anon_and_swap_buf = result.value;
                    },
                    AndroidMemoryMetric.ProcessMemoryCountersWire.JAVA_HEAP_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._java_heap_buf = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn getAnonRss(self: *const AndroidMemoryMetric.ProcessMemoryCountersReader) gremlin.Error!AndroidMemoryMetric.CounterReader {
            if (self._anon_rss_buf) |buf| {
                return try AndroidMemoryMetric.CounterReader.init(buf);
            }
            return try AndroidMemoryMetric.CounterReader.init(&[_]u8{});
        }
        pub fn getFileRss(self: *const AndroidMemoryMetric.ProcessMemoryCountersReader) gremlin.Error!AndroidMemoryMetric.CounterReader {
            if (self._file_rss_buf) |buf| {
                return try AndroidMemoryMetric.CounterReader.init(buf);
            }
            return try AndroidMemoryMetric.CounterReader.init(&[_]u8{});
        }
        pub fn getSwap(self: *const AndroidMemoryMetric.ProcessMemoryCountersReader) gremlin.Error!AndroidMemoryMetric.CounterReader {
            if (self._swap_buf) |buf| {
                return try AndroidMemoryMetric.CounterReader.init(buf);
            }
            return try AndroidMemoryMetric.CounterReader.init(&[_]u8{});
        }
        pub fn getAnonAndSwap(self: *const AndroidMemoryMetric.ProcessMemoryCountersReader) gremlin.Error!AndroidMemoryMetric.CounterReader {
            if (self._anon_and_swap_buf) |buf| {
                return try AndroidMemoryMetric.CounterReader.init(buf);
            }
            return try AndroidMemoryMetric.CounterReader.init(&[_]u8{});
        }
        pub fn getJavaHeap(self: *const AndroidMemoryMetric.ProcessMemoryCountersReader) gremlin.Error!AndroidMemoryMetric.CounterReader {
            if (self._java_heap_buf) |buf| {
                return try AndroidMemoryMetric.CounterReader.init(buf);
            }
            return try AndroidMemoryMetric.CounterReader.init(&[_]u8{});
        }
    };
    const CounterWire = struct {
        const MIN_WIRE: gremlin.ProtoWireNumber = 1;
        const MAX_WIRE: gremlin.ProtoWireNumber = 2;
        const AVG_WIRE: gremlin.ProtoWireNumber = 3;
        const DELTA_WIRE: gremlin.ProtoWireNumber = 4;
    };
    pub const Counter = struct {
        // fields
        min: f64 = 0.0,
        max: f64 = 0.0,
        avg: f64 = 0.0,
        delta: f64 = 0.0,
        pub fn calcProtobufSize(self: *const AndroidMemoryMetric.Counter) usize {
            var res: usize = 0;
            if (self.min != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidMemoryMetric.CounterWire.MIN_WIRE) + gremlin.sizes.sizeDouble(self.min);
            }
            if (self.max != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidMemoryMetric.CounterWire.MAX_WIRE) + gremlin.sizes.sizeDouble(self.max);
            }
            if (self.avg != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidMemoryMetric.CounterWire.AVG_WIRE) + gremlin.sizes.sizeDouble(self.avg);
            }
            if (self.delta != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidMemoryMetric.CounterWire.DELTA_WIRE) + gremlin.sizes.sizeDouble(self.delta);
            }
            return res;
        }
        pub fn encode(self: *const AndroidMemoryMetric.Counter, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidMemoryMetric.Counter, target: *gremlin.Writer) void {
            if (self.min != 0.0) {
                target.appendFloat64(AndroidMemoryMetric.CounterWire.MIN_WIRE, self.min);
            }
            if (self.max != 0.0) {
                target.appendFloat64(AndroidMemoryMetric.CounterWire.MAX_WIRE, self.max);
            }
            if (self.avg != 0.0) {
                target.appendFloat64(AndroidMemoryMetric.CounterWire.AVG_WIRE, self.avg);
            }
            if (self.delta != 0.0) {
                target.appendFloat64(AndroidMemoryMetric.CounterWire.DELTA_WIRE, self.delta);
            }
        }
    };
    pub const CounterReader = struct {
        buf: gremlin.Reader,
        _min: f64 = 0.0,
        _max: f64 = 0.0,
        _avg: f64 = 0.0,
        _delta: f64 = 0.0,
        pub fn init(src: []const u8) gremlin.Error!AndroidMemoryMetric.CounterReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidMemoryMetric.CounterReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidMemoryMetric.CounterWire.MIN_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._min = result.value;
                    },
                    AndroidMemoryMetric.CounterWire.MAX_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._max = result.value;
                    },
                    AndroidMemoryMetric.CounterWire.AVG_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._avg = result.value;
                    },
                    AndroidMemoryMetric.CounterWire.DELTA_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._delta = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getMin(self: *const AndroidMemoryMetric.CounterReader) f64 {
            return self._min;
        }
        pub inline fn getMax(self: *const AndroidMemoryMetric.CounterReader) f64 {
            return self._max;
        }
        pub inline fn getAvg(self: *const AndroidMemoryMetric.CounterReader) f64 {
            return self._avg;
        }
        pub inline fn getDelta(self: *const AndroidMemoryMetric.CounterReader) f64 {
            return self._delta;
        }
    };
    // fields
    process_metrics: ?[]const ?AndroidMemoryMetric.ProcessMetrics = null,
    pub fn calcProtobufSize(self: *const AndroidMemoryMetric) usize {
        var res: usize = 0;
        if (self.process_metrics) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidMemoryMetricWire.PROCESS_METRICS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidMemoryMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidMemoryMetric, target: *gremlin.Writer) void {
        if (self.process_metrics) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidMemoryMetricWire.PROCESS_METRICS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidMemoryMetricWire.PROCESS_METRICS_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidMemoryMetricReader = struct {
    buf: gremlin.Reader,
    _process_metrics_offset: ?usize = null,
    _process_metrics_last_offset: ?usize = null,
    _process_metrics_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidMemoryMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidMemoryMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidMemoryMetricWire.PROCESS_METRICS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._process_metrics_offset == null) {
                        res._process_metrics_offset = offset - result.size;
                    }
                    res._process_metrics_last_offset = offset;
                    res._process_metrics_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn processMetricsCount(self: *const AndroidMemoryMetricReader) usize {
        return self._process_metrics_cnt;
    }
    pub fn processMetricsNext(self: *AndroidMemoryMetricReader) ?AndroidMemoryMetric.ProcessMetricsReader {
        if (self._process_metrics_offset == null) return null;
        const current_offset = self._process_metrics_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidMemoryMetric.ProcessMetricsReader.init(result.value) catch return null;
        if (self._process_metrics_last_offset != null and current_offset >= self._process_metrics_last_offset.?) {
            self._process_metrics_offset = null;
            return msg;
        }
        if (self._process_metrics_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._process_metrics_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidMemoryMetricWire.PROCESS_METRICS_WIRE) {
                self._process_metrics_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._process_metrics_offset = null;
        return msg;
    }
};
const AndroidMemoryUnaggregatedMetricWire = struct {
    const PROCESS_VALUES_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const AndroidMemoryUnaggregatedMetric = struct {
    // nested structs
    const ProcessValuesWire = struct {
        const PROCESS_NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const MEM_VALUES_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const ProcessValues = struct {
        // fields
        process_name: ?[]const u8 = null,
        mem_values: ?AndroidMemoryUnaggregatedMetric.ProcessMemoryValues = null,
        pub fn calcProtobufSize(self: *const AndroidMemoryUnaggregatedMetric.ProcessValues) usize {
            var res: usize = 0;
            if (self.process_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidMemoryUnaggregatedMetric.ProcessValuesWire.PROCESS_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.mem_values) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidMemoryUnaggregatedMetric.ProcessValuesWire.MEM_VALUES_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidMemoryUnaggregatedMetric.ProcessValues, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidMemoryUnaggregatedMetric.ProcessValues, target: *gremlin.Writer) void {
            if (self.process_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidMemoryUnaggregatedMetric.ProcessValuesWire.PROCESS_NAME_WIRE, v);
                }
            }
            if (self.mem_values) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidMemoryUnaggregatedMetric.ProcessValuesWire.MEM_VALUES_WIRE, size);
                    v.encodeTo(target);
                }
            }
        }
    };
    pub const ProcessValuesReader = struct {
        buf: gremlin.Reader,
        _process_name: ?[]const u8 = null,
        _mem_values_buf: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!AndroidMemoryUnaggregatedMetric.ProcessValuesReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidMemoryUnaggregatedMetric.ProcessValuesReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidMemoryUnaggregatedMetric.ProcessValuesWire.PROCESS_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._process_name = result.value;
                    },
                    AndroidMemoryUnaggregatedMetric.ProcessValuesWire.MEM_VALUES_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._mem_values_buf = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getProcessName(self: *const AndroidMemoryUnaggregatedMetric.ProcessValuesReader) []const u8 {
            return self._process_name orelse &[_]u8{};
        }
        pub fn getMemValues(self: *const AndroidMemoryUnaggregatedMetric.ProcessValuesReader) gremlin.Error!AndroidMemoryUnaggregatedMetric.ProcessMemoryValuesReader {
            if (self._mem_values_buf) |buf| {
                return try AndroidMemoryUnaggregatedMetric.ProcessMemoryValuesReader.init(buf);
            }
            return try AndroidMemoryUnaggregatedMetric.ProcessMemoryValuesReader.init(&[_]u8{});
        }
    };
    const ProcessMemoryValuesWire = struct {
        const ANON_RSS_WIRE: gremlin.ProtoWireNumber = 1;
        const FILE_RSS_WIRE: gremlin.ProtoWireNumber = 2;
        const SWAP_WIRE: gremlin.ProtoWireNumber = 3;
        const ANON_AND_SWAP_WIRE: gremlin.ProtoWireNumber = 4;
    };
    pub const ProcessMemoryValues = struct {
        // fields
        anon_rss: ?[]const ?AndroidMemoryUnaggregatedMetric.Value = null,
        file_rss: ?[]const ?AndroidMemoryUnaggregatedMetric.Value = null,
        swap: ?[]const ?AndroidMemoryUnaggregatedMetric.Value = null,
        anon_and_swap: ?[]const ?AndroidMemoryUnaggregatedMetric.Value = null,
        pub fn calcProtobufSize(self: *const AndroidMemoryUnaggregatedMetric.ProcessMemoryValues) usize {
            var res: usize = 0;
            if (self.anon_rss) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidMemoryUnaggregatedMetric.ProcessMemoryValuesWire.ANON_RSS_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.file_rss) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidMemoryUnaggregatedMetric.ProcessMemoryValuesWire.FILE_RSS_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.swap) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidMemoryUnaggregatedMetric.ProcessMemoryValuesWire.SWAP_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.anon_and_swap) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidMemoryUnaggregatedMetric.ProcessMemoryValuesWire.ANON_AND_SWAP_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidMemoryUnaggregatedMetric.ProcessMemoryValues, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidMemoryUnaggregatedMetric.ProcessMemoryValues, target: *gremlin.Writer) void {
            if (self.anon_rss) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidMemoryUnaggregatedMetric.ProcessMemoryValuesWire.ANON_RSS_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidMemoryUnaggregatedMetric.ProcessMemoryValuesWire.ANON_RSS_WIRE, 0);
                    }
                }
            }
            if (self.file_rss) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidMemoryUnaggregatedMetric.ProcessMemoryValuesWire.FILE_RSS_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidMemoryUnaggregatedMetric.ProcessMemoryValuesWire.FILE_RSS_WIRE, 0);
                    }
                }
            }
            if (self.swap) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidMemoryUnaggregatedMetric.ProcessMemoryValuesWire.SWAP_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidMemoryUnaggregatedMetric.ProcessMemoryValuesWire.SWAP_WIRE, 0);
                    }
                }
            }
            if (self.anon_and_swap) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidMemoryUnaggregatedMetric.ProcessMemoryValuesWire.ANON_AND_SWAP_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidMemoryUnaggregatedMetric.ProcessMemoryValuesWire.ANON_AND_SWAP_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const ProcessMemoryValuesReader = struct {
        buf: gremlin.Reader,
        _anon_rss_offset: ?usize = null,
        _anon_rss_last_offset: ?usize = null,
        _anon_rss_cnt: usize = 0,
        _file_rss_offset: ?usize = null,
        _file_rss_last_offset: ?usize = null,
        _file_rss_cnt: usize = 0,
        _swap_offset: ?usize = null,
        _swap_last_offset: ?usize = null,
        _swap_cnt: usize = 0,
        _anon_and_swap_offset: ?usize = null,
        _anon_and_swap_last_offset: ?usize = null,
        _anon_and_swap_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidMemoryUnaggregatedMetric.ProcessMemoryValuesReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidMemoryUnaggregatedMetric.ProcessMemoryValuesReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidMemoryUnaggregatedMetric.ProcessMemoryValuesWire.ANON_RSS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._anon_rss_offset == null) {
                            res._anon_rss_offset = offset - result.size;
                        }
                        res._anon_rss_last_offset = offset;
                        res._anon_rss_cnt += 1;
                    },
                    AndroidMemoryUnaggregatedMetric.ProcessMemoryValuesWire.FILE_RSS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._file_rss_offset == null) {
                            res._file_rss_offset = offset - result.size;
                        }
                        res._file_rss_last_offset = offset;
                        res._file_rss_cnt += 1;
                    },
                    AndroidMemoryUnaggregatedMetric.ProcessMemoryValuesWire.SWAP_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._swap_offset == null) {
                            res._swap_offset = offset - result.size;
                        }
                        res._swap_last_offset = offset;
                        res._swap_cnt += 1;
                    },
                    AndroidMemoryUnaggregatedMetric.ProcessMemoryValuesWire.ANON_AND_SWAP_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._anon_and_swap_offset == null) {
                            res._anon_and_swap_offset = offset - result.size;
                        }
                        res._anon_and_swap_last_offset = offset;
                        res._anon_and_swap_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn anonRssCount(self: *const AndroidMemoryUnaggregatedMetric.ProcessMemoryValuesReader) usize {
            return self._anon_rss_cnt;
        }
        pub fn anonRssNext(self: *AndroidMemoryUnaggregatedMetric.ProcessMemoryValuesReader) ?AndroidMemoryUnaggregatedMetric.ValueReader {
            if (self._anon_rss_offset == null) return null;
            const current_offset = self._anon_rss_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidMemoryUnaggregatedMetric.ValueReader.init(result.value) catch return null;
            if (self._anon_rss_last_offset != null and current_offset >= self._anon_rss_last_offset.?) {
                self._anon_rss_offset = null;
                return msg;
            }
            if (self._anon_rss_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._anon_rss_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidMemoryUnaggregatedMetric.ProcessMemoryValuesWire.ANON_RSS_WIRE) {
                    self._anon_rss_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._anon_rss_offset = null;
            return msg;
        }
        pub fn fileRssCount(self: *const AndroidMemoryUnaggregatedMetric.ProcessMemoryValuesReader) usize {
            return self._file_rss_cnt;
        }
        pub fn fileRssNext(self: *AndroidMemoryUnaggregatedMetric.ProcessMemoryValuesReader) ?AndroidMemoryUnaggregatedMetric.ValueReader {
            if (self._file_rss_offset == null) return null;
            const current_offset = self._file_rss_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidMemoryUnaggregatedMetric.ValueReader.init(result.value) catch return null;
            if (self._file_rss_last_offset != null and current_offset >= self._file_rss_last_offset.?) {
                self._file_rss_offset = null;
                return msg;
            }
            if (self._file_rss_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._file_rss_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidMemoryUnaggregatedMetric.ProcessMemoryValuesWire.FILE_RSS_WIRE) {
                    self._file_rss_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._file_rss_offset = null;
            return msg;
        }
        pub fn swapCount(self: *const AndroidMemoryUnaggregatedMetric.ProcessMemoryValuesReader) usize {
            return self._swap_cnt;
        }
        pub fn swapNext(self: *AndroidMemoryUnaggregatedMetric.ProcessMemoryValuesReader) ?AndroidMemoryUnaggregatedMetric.ValueReader {
            if (self._swap_offset == null) return null;
            const current_offset = self._swap_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidMemoryUnaggregatedMetric.ValueReader.init(result.value) catch return null;
            if (self._swap_last_offset != null and current_offset >= self._swap_last_offset.?) {
                self._swap_offset = null;
                return msg;
            }
            if (self._swap_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._swap_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidMemoryUnaggregatedMetric.ProcessMemoryValuesWire.SWAP_WIRE) {
                    self._swap_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._swap_offset = null;
            return msg;
        }
        pub fn anonAndSwapCount(self: *const AndroidMemoryUnaggregatedMetric.ProcessMemoryValuesReader) usize {
            return self._anon_and_swap_cnt;
        }
        pub fn anonAndSwapNext(self: *AndroidMemoryUnaggregatedMetric.ProcessMemoryValuesReader) ?AndroidMemoryUnaggregatedMetric.ValueReader {
            if (self._anon_and_swap_offset == null) return null;
            const current_offset = self._anon_and_swap_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidMemoryUnaggregatedMetric.ValueReader.init(result.value) catch return null;
            if (self._anon_and_swap_last_offset != null and current_offset >= self._anon_and_swap_last_offset.?) {
                self._anon_and_swap_offset = null;
                return msg;
            }
            if (self._anon_and_swap_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._anon_and_swap_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidMemoryUnaggregatedMetric.ProcessMemoryValuesWire.ANON_AND_SWAP_WIRE) {
                    self._anon_and_swap_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._anon_and_swap_offset = null;
            return msg;
        }
    };
    const ValueWire = struct {
        const TS_WIRE: gremlin.ProtoWireNumber = 1;
        const OOM_SCORE_WIRE: gremlin.ProtoWireNumber = 2;
        const VALUE_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const Value = struct {
        // fields
        ts: i64 = 0,
        oom_score: i32 = 0,
        value: f64 = 0.0,
        pub fn calcProtobufSize(self: *const AndroidMemoryUnaggregatedMetric.Value) usize {
            var res: usize = 0;
            if (self.ts != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidMemoryUnaggregatedMetric.ValueWire.TS_WIRE) + gremlin.sizes.sizeI64(self.ts);
            }
            if (self.oom_score != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidMemoryUnaggregatedMetric.ValueWire.OOM_SCORE_WIRE) + gremlin.sizes.sizeI32(self.oom_score);
            }
            if (self.value != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidMemoryUnaggregatedMetric.ValueWire.VALUE_WIRE) + gremlin.sizes.sizeDouble(self.value);
            }
            return res;
        }
        pub fn encode(self: *const AndroidMemoryUnaggregatedMetric.Value, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidMemoryUnaggregatedMetric.Value, target: *gremlin.Writer) void {
            if (self.ts != 0) {
                target.appendInt64(AndroidMemoryUnaggregatedMetric.ValueWire.TS_WIRE, self.ts);
            }
            if (self.oom_score != 0) {
                target.appendInt32(AndroidMemoryUnaggregatedMetric.ValueWire.OOM_SCORE_WIRE, self.oom_score);
            }
            if (self.value != 0.0) {
                target.appendFloat64(AndroidMemoryUnaggregatedMetric.ValueWire.VALUE_WIRE, self.value);
            }
        }
    };
    pub const ValueReader = struct {
        buf: gremlin.Reader,
        _ts: i64 = 0,
        _oom_score: i32 = 0,
        _value: f64 = 0.0,
        pub fn init(src: []const u8) gremlin.Error!AndroidMemoryUnaggregatedMetric.ValueReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidMemoryUnaggregatedMetric.ValueReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidMemoryUnaggregatedMetric.ValueWire.TS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._ts = result.value;
                    },
                    AndroidMemoryUnaggregatedMetric.ValueWire.OOM_SCORE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._oom_score = result.value;
                    },
                    AndroidMemoryUnaggregatedMetric.ValueWire.VALUE_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._value = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getTs(self: *const AndroidMemoryUnaggregatedMetric.ValueReader) i64 {
            return self._ts;
        }
        pub inline fn getOomScore(self: *const AndroidMemoryUnaggregatedMetric.ValueReader) i32 {
            return self._oom_score;
        }
        pub inline fn getValue(self: *const AndroidMemoryUnaggregatedMetric.ValueReader) f64 {
            return self._value;
        }
    };
    // fields
    process_values: ?[]const ?AndroidMemoryUnaggregatedMetric.ProcessValues = null,
    pub fn calcProtobufSize(self: *const AndroidMemoryUnaggregatedMetric) usize {
        var res: usize = 0;
        if (self.process_values) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidMemoryUnaggregatedMetricWire.PROCESS_VALUES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidMemoryUnaggregatedMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidMemoryUnaggregatedMetric, target: *gremlin.Writer) void {
        if (self.process_values) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidMemoryUnaggregatedMetricWire.PROCESS_VALUES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidMemoryUnaggregatedMetricWire.PROCESS_VALUES_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidMemoryUnaggregatedMetricReader = struct {
    buf: gremlin.Reader,
    _process_values_offset: ?usize = null,
    _process_values_last_offset: ?usize = null,
    _process_values_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidMemoryUnaggregatedMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidMemoryUnaggregatedMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidMemoryUnaggregatedMetricWire.PROCESS_VALUES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._process_values_offset == null) {
                        res._process_values_offset = offset - result.size;
                    }
                    res._process_values_last_offset = offset;
                    res._process_values_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn processValuesCount(self: *const AndroidMemoryUnaggregatedMetricReader) usize {
        return self._process_values_cnt;
    }
    pub fn processValuesNext(self: *AndroidMemoryUnaggregatedMetricReader) ?AndroidMemoryUnaggregatedMetric.ProcessValuesReader {
        if (self._process_values_offset == null) return null;
        const current_offset = self._process_values_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidMemoryUnaggregatedMetric.ProcessValuesReader.init(result.value) catch return null;
        if (self._process_values_last_offset != null and current_offset >= self._process_values_last_offset.?) {
            self._process_values_offset = null;
            return msg;
        }
        if (self._process_values_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._process_values_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidMemoryUnaggregatedMetricWire.PROCESS_VALUES_WIRE) {
                self._process_values_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._process_values_offset = null;
        return msg;
    }
};
const AndroidMonitorContentionAggMetricWire = struct {
    const PROCESS_AGGREGATION_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const AndroidMonitorContentionAggMetric = struct {
    // nested structs
    const ProcessAggregationWire = struct {
        const NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const TOTAL_CONTENTION_COUNT_WIRE: gremlin.ProtoWireNumber = 2;
        const TOTAL_CONTENTION_DUR_WIRE: gremlin.ProtoWireNumber = 3;
        const MAIN_THREAD_CONTENTION_COUNT_WIRE: gremlin.ProtoWireNumber = 4;
        const MAIN_THREAD_CONTENTION_DUR_WIRE: gremlin.ProtoWireNumber = 5;
    };
    pub const ProcessAggregation = struct {
        // fields
        name: ?[]const u8 = null,
        total_contention_count: i64 = 0,
        total_contention_dur: i64 = 0,
        main_thread_contention_count: i64 = 0,
        main_thread_contention_dur: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidMonitorContentionAggMetric.ProcessAggregation) usize {
            var res: usize = 0;
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidMonitorContentionAggMetric.ProcessAggregationWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.total_contention_count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidMonitorContentionAggMetric.ProcessAggregationWire.TOTAL_CONTENTION_COUNT_WIRE) + gremlin.sizes.sizeI64(self.total_contention_count);
            }
            if (self.total_contention_dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidMonitorContentionAggMetric.ProcessAggregationWire.TOTAL_CONTENTION_DUR_WIRE) + gremlin.sizes.sizeI64(self.total_contention_dur);
            }
            if (self.main_thread_contention_count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidMonitorContentionAggMetric.ProcessAggregationWire.MAIN_THREAD_CONTENTION_COUNT_WIRE) + gremlin.sizes.sizeI64(self.main_thread_contention_count);
            }
            if (self.main_thread_contention_dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidMonitorContentionAggMetric.ProcessAggregationWire.MAIN_THREAD_CONTENTION_DUR_WIRE) + gremlin.sizes.sizeI64(self.main_thread_contention_dur);
            }
            return res;
        }
        pub fn encode(self: *const AndroidMonitorContentionAggMetric.ProcessAggregation, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidMonitorContentionAggMetric.ProcessAggregation, target: *gremlin.Writer) void {
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidMonitorContentionAggMetric.ProcessAggregationWire.NAME_WIRE, v);
                }
            }
            if (self.total_contention_count != 0) {
                target.appendInt64(AndroidMonitorContentionAggMetric.ProcessAggregationWire.TOTAL_CONTENTION_COUNT_WIRE, self.total_contention_count);
            }
            if (self.total_contention_dur != 0) {
                target.appendInt64(AndroidMonitorContentionAggMetric.ProcessAggregationWire.TOTAL_CONTENTION_DUR_WIRE, self.total_contention_dur);
            }
            if (self.main_thread_contention_count != 0) {
                target.appendInt64(AndroidMonitorContentionAggMetric.ProcessAggregationWire.MAIN_THREAD_CONTENTION_COUNT_WIRE, self.main_thread_contention_count);
            }
            if (self.main_thread_contention_dur != 0) {
                target.appendInt64(AndroidMonitorContentionAggMetric.ProcessAggregationWire.MAIN_THREAD_CONTENTION_DUR_WIRE, self.main_thread_contention_dur);
            }
        }
    };
    pub const ProcessAggregationReader = struct {
        buf: gremlin.Reader,
        _name: ?[]const u8 = null,
        _total_contention_count: i64 = 0,
        _total_contention_dur: i64 = 0,
        _main_thread_contention_count: i64 = 0,
        _main_thread_contention_dur: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidMonitorContentionAggMetric.ProcessAggregationReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidMonitorContentionAggMetric.ProcessAggregationReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidMonitorContentionAggMetric.ProcessAggregationWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    AndroidMonitorContentionAggMetric.ProcessAggregationWire.TOTAL_CONTENTION_COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._total_contention_count = result.value;
                    },
                    AndroidMonitorContentionAggMetric.ProcessAggregationWire.TOTAL_CONTENTION_DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._total_contention_dur = result.value;
                    },
                    AndroidMonitorContentionAggMetric.ProcessAggregationWire.MAIN_THREAD_CONTENTION_COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._main_thread_contention_count = result.value;
                    },
                    AndroidMonitorContentionAggMetric.ProcessAggregationWire.MAIN_THREAD_CONTENTION_DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._main_thread_contention_dur = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getName(self: *const AndroidMonitorContentionAggMetric.ProcessAggregationReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub inline fn getTotalContentionCount(self: *const AndroidMonitorContentionAggMetric.ProcessAggregationReader) i64 {
            return self._total_contention_count;
        }
        pub inline fn getTotalContentionDur(self: *const AndroidMonitorContentionAggMetric.ProcessAggregationReader) i64 {
            return self._total_contention_dur;
        }
        pub inline fn getMainThreadContentionCount(self: *const AndroidMonitorContentionAggMetric.ProcessAggregationReader) i64 {
            return self._main_thread_contention_count;
        }
        pub inline fn getMainThreadContentionDur(self: *const AndroidMonitorContentionAggMetric.ProcessAggregationReader) i64 {
            return self._main_thread_contention_dur;
        }
    };
    // fields
    process_aggregation: ?[]const ?AndroidMonitorContentionAggMetric.ProcessAggregation = null,
    pub fn calcProtobufSize(self: *const AndroidMonitorContentionAggMetric) usize {
        var res: usize = 0;
        if (self.process_aggregation) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidMonitorContentionAggMetricWire.PROCESS_AGGREGATION_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidMonitorContentionAggMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidMonitorContentionAggMetric, target: *gremlin.Writer) void {
        if (self.process_aggregation) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidMonitorContentionAggMetricWire.PROCESS_AGGREGATION_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidMonitorContentionAggMetricWire.PROCESS_AGGREGATION_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidMonitorContentionAggMetricReader = struct {
    buf: gremlin.Reader,
    _process_aggregation_offset: ?usize = null,
    _process_aggregation_last_offset: ?usize = null,
    _process_aggregation_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidMonitorContentionAggMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidMonitorContentionAggMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidMonitorContentionAggMetricWire.PROCESS_AGGREGATION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._process_aggregation_offset == null) {
                        res._process_aggregation_offset = offset - result.size;
                    }
                    res._process_aggregation_last_offset = offset;
                    res._process_aggregation_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn processAggregationCount(self: *const AndroidMonitorContentionAggMetricReader) usize {
        return self._process_aggregation_cnt;
    }
    pub fn processAggregationNext(self: *AndroidMonitorContentionAggMetricReader) ?AndroidMonitorContentionAggMetric.ProcessAggregationReader {
        if (self._process_aggregation_offset == null) return null;
        const current_offset = self._process_aggregation_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidMonitorContentionAggMetric.ProcessAggregationReader.init(result.value) catch return null;
        if (self._process_aggregation_last_offset != null and current_offset >= self._process_aggregation_last_offset.?) {
            self._process_aggregation_offset = null;
            return msg;
        }
        if (self._process_aggregation_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._process_aggregation_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidMonitorContentionAggMetricWire.PROCESS_AGGREGATION_WIRE) {
                self._process_aggregation_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._process_aggregation_offset = null;
        return msg;
    }
};
const AndroidMonitorContentionMetricWire = struct {
    const NODE_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const AndroidMonitorContentionMetric = struct {
    // nested structs
    const NodeWire = struct {
        const NODE_PARENT_ID_WIRE: gremlin.ProtoWireNumber = 1;
        const NODE_CHILD_ID_WIRE: gremlin.ProtoWireNumber = 24;
        const NODE_ID_WIRE: gremlin.ProtoWireNumber = 2;
        const TS_WIRE: gremlin.ProtoWireNumber = 3;
        const DUR_WIRE: gremlin.ProtoWireNumber = 4;
        const MONOTONIC_DUR_WIRE: gremlin.ProtoWireNumber = 25;
        const PROCESS_NAME_WIRE: gremlin.ProtoWireNumber = 14;
        const PID_WIRE: gremlin.ProtoWireNumber = 23;
        const WAITER_COUNT_WIRE: gremlin.ProtoWireNumber = 11;
        const THREAD_STATES_WIRE: gremlin.ProtoWireNumber = 19;
        const BLOCKED_FUNCTIONS_WIRE: gremlin.ProtoWireNumber = 20;
        const BLOCKING_METHOD_WIRE: gremlin.ProtoWireNumber = 5;
        const SHORT_BLOCKING_METHOD_WIRE: gremlin.ProtoWireNumber = 7;
        const BLOCKING_SRC_WIRE: gremlin.ProtoWireNumber = 9;
        const BLOCKING_THREAD_NAME_WIRE: gremlin.ProtoWireNumber = 13;
        const IS_BLOCKING_THREAD_MAIN_WIRE: gremlin.ProtoWireNumber = 16;
        const BLOCKING_THREAD_TID_WIRE: gremlin.ProtoWireNumber = 22;
        const BLOCKED_METHOD_WIRE: gremlin.ProtoWireNumber = 6;
        const SHORT_BLOCKED_METHOD_WIRE: gremlin.ProtoWireNumber = 8;
        const BLOCKED_SRC_WIRE: gremlin.ProtoWireNumber = 10;
        const BLOCKED_THREAD_NAME_WIRE: gremlin.ProtoWireNumber = 12;
        const IS_BLOCKED_THREAD_MAIN_WIRE: gremlin.ProtoWireNumber = 15;
        const BLOCKED_THREAD_TID_WIRE: gremlin.ProtoWireNumber = 21;
        const BINDER_REPLY_TS_WIRE: gremlin.ProtoWireNumber = 17;
        const BINDER_REPLY_TID_WIRE: gremlin.ProtoWireNumber = 18;
    };
    pub const Node = struct {
        // fields
        node_parent_id: i64 = 0,
        node_child_id: i64 = 0,
        node_id: i64 = 0,
        ts: i64 = 0,
        dur: i64 = 0,
        monotonic_dur: i64 = 0,
        process_name: ?[]const u8 = null,
        pid: u32 = 0,
        waiter_count: u32 = 0,
        thread_states: ?[]const ?AndroidMonitorContentionMetric.ThreadStateBreakdown = null,
        blocked_functions: ?[]const ?AndroidMonitorContentionMetric.BlockedFunctionBreakdown = null,
        blocking_method: ?[]const u8 = null,
        short_blocking_method: ?[]const u8 = null,
        blocking_src: ?[]const u8 = null,
        blocking_thread_name: ?[]const u8 = null,
        is_blocking_thread_main: bool = false,
        blocking_thread_tid: u32 = 0,
        blocked_method: ?[]const u8 = null,
        short_blocked_method: ?[]const u8 = null,
        blocked_src: ?[]const u8 = null,
        blocked_thread_name: ?[]const u8 = null,
        is_blocked_thread_main: bool = false,
        blocked_thread_tid: u32 = 0,
        binder_reply_ts: i64 = 0,
        binder_reply_tid: u32 = 0,
        pub fn calcProtobufSize(self: *const AndroidMonitorContentionMetric.Node) usize {
            var res: usize = 0;
            if (self.node_parent_id != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidMonitorContentionMetric.NodeWire.NODE_PARENT_ID_WIRE) + gremlin.sizes.sizeI64(self.node_parent_id);
            }
            if (self.node_child_id != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidMonitorContentionMetric.NodeWire.NODE_CHILD_ID_WIRE) + gremlin.sizes.sizeI64(self.node_child_id);
            }
            if (self.node_id != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidMonitorContentionMetric.NodeWire.NODE_ID_WIRE) + gremlin.sizes.sizeI64(self.node_id);
            }
            if (self.ts != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidMonitorContentionMetric.NodeWire.TS_WIRE) + gremlin.sizes.sizeI64(self.ts);
            }
            if (self.dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidMonitorContentionMetric.NodeWire.DUR_WIRE) + gremlin.sizes.sizeI64(self.dur);
            }
            if (self.monotonic_dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidMonitorContentionMetric.NodeWire.MONOTONIC_DUR_WIRE) + gremlin.sizes.sizeI64(self.monotonic_dur);
            }
            if (self.process_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidMonitorContentionMetric.NodeWire.PROCESS_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.pid != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidMonitorContentionMetric.NodeWire.PID_WIRE) + gremlin.sizes.sizeU32(self.pid);
            }
            if (self.waiter_count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidMonitorContentionMetric.NodeWire.WAITER_COUNT_WIRE) + gremlin.sizes.sizeU32(self.waiter_count);
            }
            if (self.thread_states) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidMonitorContentionMetric.NodeWire.THREAD_STATES_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.blocked_functions) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidMonitorContentionMetric.NodeWire.BLOCKED_FUNCTIONS_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.blocking_method) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidMonitorContentionMetric.NodeWire.BLOCKING_METHOD_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.short_blocking_method) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidMonitorContentionMetric.NodeWire.SHORT_BLOCKING_METHOD_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.blocking_src) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidMonitorContentionMetric.NodeWire.BLOCKING_SRC_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.blocking_thread_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidMonitorContentionMetric.NodeWire.BLOCKING_THREAD_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.is_blocking_thread_main != false) {
                res += gremlin.sizes.sizeWireNumber(AndroidMonitorContentionMetric.NodeWire.IS_BLOCKING_THREAD_MAIN_WIRE) + gremlin.sizes.sizeBool(self.is_blocking_thread_main);
            }
            if (self.blocking_thread_tid != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidMonitorContentionMetric.NodeWire.BLOCKING_THREAD_TID_WIRE) + gremlin.sizes.sizeU32(self.blocking_thread_tid);
            }
            if (self.blocked_method) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidMonitorContentionMetric.NodeWire.BLOCKED_METHOD_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.short_blocked_method) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidMonitorContentionMetric.NodeWire.SHORT_BLOCKED_METHOD_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.blocked_src) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidMonitorContentionMetric.NodeWire.BLOCKED_SRC_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.blocked_thread_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidMonitorContentionMetric.NodeWire.BLOCKED_THREAD_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.is_blocked_thread_main != false) {
                res += gremlin.sizes.sizeWireNumber(AndroidMonitorContentionMetric.NodeWire.IS_BLOCKED_THREAD_MAIN_WIRE) + gremlin.sizes.sizeBool(self.is_blocked_thread_main);
            }
            if (self.blocked_thread_tid != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidMonitorContentionMetric.NodeWire.BLOCKED_THREAD_TID_WIRE) + gremlin.sizes.sizeU32(self.blocked_thread_tid);
            }
            if (self.binder_reply_ts != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidMonitorContentionMetric.NodeWire.BINDER_REPLY_TS_WIRE) + gremlin.sizes.sizeI64(self.binder_reply_ts);
            }
            if (self.binder_reply_tid != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidMonitorContentionMetric.NodeWire.BINDER_REPLY_TID_WIRE) + gremlin.sizes.sizeU32(self.binder_reply_tid);
            }
            return res;
        }
        pub fn encode(self: *const AndroidMonitorContentionMetric.Node, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidMonitorContentionMetric.Node, target: *gremlin.Writer) void {
            if (self.node_parent_id != 0) {
                target.appendInt64(AndroidMonitorContentionMetric.NodeWire.NODE_PARENT_ID_WIRE, self.node_parent_id);
            }
            if (self.node_child_id != 0) {
                target.appendInt64(AndroidMonitorContentionMetric.NodeWire.NODE_CHILD_ID_WIRE, self.node_child_id);
            }
            if (self.node_id != 0) {
                target.appendInt64(AndroidMonitorContentionMetric.NodeWire.NODE_ID_WIRE, self.node_id);
            }
            if (self.ts != 0) {
                target.appendInt64(AndroidMonitorContentionMetric.NodeWire.TS_WIRE, self.ts);
            }
            if (self.dur != 0) {
                target.appendInt64(AndroidMonitorContentionMetric.NodeWire.DUR_WIRE, self.dur);
            }
            if (self.monotonic_dur != 0) {
                target.appendInt64(AndroidMonitorContentionMetric.NodeWire.MONOTONIC_DUR_WIRE, self.monotonic_dur);
            }
            if (self.process_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidMonitorContentionMetric.NodeWire.PROCESS_NAME_WIRE, v);
                }
            }
            if (self.pid != 0) {
                target.appendUint32(AndroidMonitorContentionMetric.NodeWire.PID_WIRE, self.pid);
            }
            if (self.waiter_count != 0) {
                target.appendUint32(AndroidMonitorContentionMetric.NodeWire.WAITER_COUNT_WIRE, self.waiter_count);
            }
            if (self.thread_states) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidMonitorContentionMetric.NodeWire.THREAD_STATES_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidMonitorContentionMetric.NodeWire.THREAD_STATES_WIRE, 0);
                    }
                }
            }
            if (self.blocked_functions) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidMonitorContentionMetric.NodeWire.BLOCKED_FUNCTIONS_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidMonitorContentionMetric.NodeWire.BLOCKED_FUNCTIONS_WIRE, 0);
                    }
                }
            }
            if (self.blocking_method) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidMonitorContentionMetric.NodeWire.BLOCKING_METHOD_WIRE, v);
                }
            }
            if (self.short_blocking_method) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidMonitorContentionMetric.NodeWire.SHORT_BLOCKING_METHOD_WIRE, v);
                }
            }
            if (self.blocking_src) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidMonitorContentionMetric.NodeWire.BLOCKING_SRC_WIRE, v);
                }
            }
            if (self.blocking_thread_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidMonitorContentionMetric.NodeWire.BLOCKING_THREAD_NAME_WIRE, v);
                }
            }
            if (self.is_blocking_thread_main != false) {
                target.appendBool(AndroidMonitorContentionMetric.NodeWire.IS_BLOCKING_THREAD_MAIN_WIRE, self.is_blocking_thread_main);
            }
            if (self.blocking_thread_tid != 0) {
                target.appendUint32(AndroidMonitorContentionMetric.NodeWire.BLOCKING_THREAD_TID_WIRE, self.blocking_thread_tid);
            }
            if (self.blocked_method) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidMonitorContentionMetric.NodeWire.BLOCKED_METHOD_WIRE, v);
                }
            }
            if (self.short_blocked_method) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidMonitorContentionMetric.NodeWire.SHORT_BLOCKED_METHOD_WIRE, v);
                }
            }
            if (self.blocked_src) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidMonitorContentionMetric.NodeWire.BLOCKED_SRC_WIRE, v);
                }
            }
            if (self.blocked_thread_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidMonitorContentionMetric.NodeWire.BLOCKED_THREAD_NAME_WIRE, v);
                }
            }
            if (self.is_blocked_thread_main != false) {
                target.appendBool(AndroidMonitorContentionMetric.NodeWire.IS_BLOCKED_THREAD_MAIN_WIRE, self.is_blocked_thread_main);
            }
            if (self.blocked_thread_tid != 0) {
                target.appendUint32(AndroidMonitorContentionMetric.NodeWire.BLOCKED_THREAD_TID_WIRE, self.blocked_thread_tid);
            }
            if (self.binder_reply_ts != 0) {
                target.appendInt64(AndroidMonitorContentionMetric.NodeWire.BINDER_REPLY_TS_WIRE, self.binder_reply_ts);
            }
            if (self.binder_reply_tid != 0) {
                target.appendUint32(AndroidMonitorContentionMetric.NodeWire.BINDER_REPLY_TID_WIRE, self.binder_reply_tid);
            }
        }
    };
    pub const NodeReader = struct {
        buf: gremlin.Reader,
        _node_parent_id: i64 = 0,
        _node_child_id: i64 = 0,
        _node_id: i64 = 0,
        _ts: i64 = 0,
        _dur: i64 = 0,
        _monotonic_dur: i64 = 0,
        _process_name: ?[]const u8 = null,
        _pid: u32 = 0,
        _waiter_count: u32 = 0,
        _thread_states_offset: ?usize = null,
        _thread_states_last_offset: ?usize = null,
        _thread_states_cnt: usize = 0,
        _blocked_functions_offset: ?usize = null,
        _blocked_functions_last_offset: ?usize = null,
        _blocked_functions_cnt: usize = 0,
        _blocking_method: ?[]const u8 = null,
        _short_blocking_method: ?[]const u8 = null,
        _blocking_src: ?[]const u8 = null,
        _blocking_thread_name: ?[]const u8 = null,
        _is_blocking_thread_main: bool = false,
        _blocking_thread_tid: u32 = 0,
        _blocked_method: ?[]const u8 = null,
        _short_blocked_method: ?[]const u8 = null,
        _blocked_src: ?[]const u8 = null,
        _blocked_thread_name: ?[]const u8 = null,
        _is_blocked_thread_main: bool = false,
        _blocked_thread_tid: u32 = 0,
        _binder_reply_ts: i64 = 0,
        _binder_reply_tid: u32 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidMonitorContentionMetric.NodeReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidMonitorContentionMetric.NodeReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidMonitorContentionMetric.NodeWire.NODE_PARENT_ID_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._node_parent_id = result.value;
                    },
                    AndroidMonitorContentionMetric.NodeWire.NODE_CHILD_ID_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._node_child_id = result.value;
                    },
                    AndroidMonitorContentionMetric.NodeWire.NODE_ID_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._node_id = result.value;
                    },
                    AndroidMonitorContentionMetric.NodeWire.TS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._ts = result.value;
                    },
                    AndroidMonitorContentionMetric.NodeWire.DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._dur = result.value;
                    },
                    AndroidMonitorContentionMetric.NodeWire.MONOTONIC_DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._monotonic_dur = result.value;
                    },
                    AndroidMonitorContentionMetric.NodeWire.PROCESS_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._process_name = result.value;
                    },
                    AndroidMonitorContentionMetric.NodeWire.PID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._pid = result.value;
                    },
                    AndroidMonitorContentionMetric.NodeWire.WAITER_COUNT_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._waiter_count = result.value;
                    },
                    AndroidMonitorContentionMetric.NodeWire.THREAD_STATES_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._thread_states_offset == null) {
                            res._thread_states_offset = offset - result.size;
                        }
                        res._thread_states_last_offset = offset;
                        res._thread_states_cnt += 1;
                    },
                    AndroidMonitorContentionMetric.NodeWire.BLOCKED_FUNCTIONS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._blocked_functions_offset == null) {
                            res._blocked_functions_offset = offset - result.size;
                        }
                        res._blocked_functions_last_offset = offset;
                        res._blocked_functions_cnt += 1;
                    },
                    AndroidMonitorContentionMetric.NodeWire.BLOCKING_METHOD_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._blocking_method = result.value;
                    },
                    AndroidMonitorContentionMetric.NodeWire.SHORT_BLOCKING_METHOD_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._short_blocking_method = result.value;
                    },
                    AndroidMonitorContentionMetric.NodeWire.BLOCKING_SRC_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._blocking_src = result.value;
                    },
                    AndroidMonitorContentionMetric.NodeWire.BLOCKING_THREAD_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._blocking_thread_name = result.value;
                    },
                    AndroidMonitorContentionMetric.NodeWire.IS_BLOCKING_THREAD_MAIN_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._is_blocking_thread_main = result.value;
                    },
                    AndroidMonitorContentionMetric.NodeWire.BLOCKING_THREAD_TID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._blocking_thread_tid = result.value;
                    },
                    AndroidMonitorContentionMetric.NodeWire.BLOCKED_METHOD_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._blocked_method = result.value;
                    },
                    AndroidMonitorContentionMetric.NodeWire.SHORT_BLOCKED_METHOD_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._short_blocked_method = result.value;
                    },
                    AndroidMonitorContentionMetric.NodeWire.BLOCKED_SRC_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._blocked_src = result.value;
                    },
                    AndroidMonitorContentionMetric.NodeWire.BLOCKED_THREAD_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._blocked_thread_name = result.value;
                    },
                    AndroidMonitorContentionMetric.NodeWire.IS_BLOCKED_THREAD_MAIN_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._is_blocked_thread_main = result.value;
                    },
                    AndroidMonitorContentionMetric.NodeWire.BLOCKED_THREAD_TID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._blocked_thread_tid = result.value;
                    },
                    AndroidMonitorContentionMetric.NodeWire.BINDER_REPLY_TS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._binder_reply_ts = result.value;
                    },
                    AndroidMonitorContentionMetric.NodeWire.BINDER_REPLY_TID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._binder_reply_tid = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getNodeParentId(self: *const AndroidMonitorContentionMetric.NodeReader) i64 {
            return self._node_parent_id;
        }
        pub inline fn getNodeChildId(self: *const AndroidMonitorContentionMetric.NodeReader) i64 {
            return self._node_child_id;
        }
        pub inline fn getNodeId(self: *const AndroidMonitorContentionMetric.NodeReader) i64 {
            return self._node_id;
        }
        pub inline fn getTs(self: *const AndroidMonitorContentionMetric.NodeReader) i64 {
            return self._ts;
        }
        pub inline fn getDur(self: *const AndroidMonitorContentionMetric.NodeReader) i64 {
            return self._dur;
        }
        pub inline fn getMonotonicDur(self: *const AndroidMonitorContentionMetric.NodeReader) i64 {
            return self._monotonic_dur;
        }
        pub inline fn getProcessName(self: *const AndroidMonitorContentionMetric.NodeReader) []const u8 {
            return self._process_name orelse &[_]u8{};
        }
        pub inline fn getPid(self: *const AndroidMonitorContentionMetric.NodeReader) u32 {
            return self._pid;
        }
        pub inline fn getWaiterCount(self: *const AndroidMonitorContentionMetric.NodeReader) u32 {
            return self._waiter_count;
        }
        pub fn threadStatesCount(self: *const AndroidMonitorContentionMetric.NodeReader) usize {
            return self._thread_states_cnt;
        }
        pub fn threadStatesNext(self: *AndroidMonitorContentionMetric.NodeReader) ?AndroidMonitorContentionMetric.ThreadStateBreakdownReader {
            if (self._thread_states_offset == null) return null;
            const current_offset = self._thread_states_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidMonitorContentionMetric.ThreadStateBreakdownReader.init(result.value) catch return null;
            if (self._thread_states_last_offset != null and current_offset >= self._thread_states_last_offset.?) {
                self._thread_states_offset = null;
                return msg;
            }
            if (self._thread_states_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._thread_states_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidMonitorContentionMetric.NodeWire.THREAD_STATES_WIRE) {
                    self._thread_states_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._thread_states_offset = null;
            return msg;
        }
        pub fn blockedFunctionsCount(self: *const AndroidMonitorContentionMetric.NodeReader) usize {
            return self._blocked_functions_cnt;
        }
        pub fn blockedFunctionsNext(self: *AndroidMonitorContentionMetric.NodeReader) ?AndroidMonitorContentionMetric.BlockedFunctionBreakdownReader {
            if (self._blocked_functions_offset == null) return null;
            const current_offset = self._blocked_functions_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidMonitorContentionMetric.BlockedFunctionBreakdownReader.init(result.value) catch return null;
            if (self._blocked_functions_last_offset != null and current_offset >= self._blocked_functions_last_offset.?) {
                self._blocked_functions_offset = null;
                return msg;
            }
            if (self._blocked_functions_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._blocked_functions_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidMonitorContentionMetric.NodeWire.BLOCKED_FUNCTIONS_WIRE) {
                    self._blocked_functions_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._blocked_functions_offset = null;
            return msg;
        }
        pub inline fn getBlockingMethod(self: *const AndroidMonitorContentionMetric.NodeReader) []const u8 {
            return self._blocking_method orelse &[_]u8{};
        }
        pub inline fn getShortBlockingMethod(self: *const AndroidMonitorContentionMetric.NodeReader) []const u8 {
            return self._short_blocking_method orelse &[_]u8{};
        }
        pub inline fn getBlockingSrc(self: *const AndroidMonitorContentionMetric.NodeReader) []const u8 {
            return self._blocking_src orelse &[_]u8{};
        }
        pub inline fn getBlockingThreadName(self: *const AndroidMonitorContentionMetric.NodeReader) []const u8 {
            return self._blocking_thread_name orelse &[_]u8{};
        }
        pub inline fn getIsBlockingThreadMain(self: *const AndroidMonitorContentionMetric.NodeReader) bool {
            return self._is_blocking_thread_main;
        }
        pub inline fn getBlockingThreadTid(self: *const AndroidMonitorContentionMetric.NodeReader) u32 {
            return self._blocking_thread_tid;
        }
        pub inline fn getBlockedMethod(self: *const AndroidMonitorContentionMetric.NodeReader) []const u8 {
            return self._blocked_method orelse &[_]u8{};
        }
        pub inline fn getShortBlockedMethod(self: *const AndroidMonitorContentionMetric.NodeReader) []const u8 {
            return self._short_blocked_method orelse &[_]u8{};
        }
        pub inline fn getBlockedSrc(self: *const AndroidMonitorContentionMetric.NodeReader) []const u8 {
            return self._blocked_src orelse &[_]u8{};
        }
        pub inline fn getBlockedThreadName(self: *const AndroidMonitorContentionMetric.NodeReader) []const u8 {
            return self._blocked_thread_name orelse &[_]u8{};
        }
        pub inline fn getIsBlockedThreadMain(self: *const AndroidMonitorContentionMetric.NodeReader) bool {
            return self._is_blocked_thread_main;
        }
        pub inline fn getBlockedThreadTid(self: *const AndroidMonitorContentionMetric.NodeReader) u32 {
            return self._blocked_thread_tid;
        }
        pub inline fn getBinderReplyTs(self: *const AndroidMonitorContentionMetric.NodeReader) i64 {
            return self._binder_reply_ts;
        }
        pub inline fn getBinderReplyTid(self: *const AndroidMonitorContentionMetric.NodeReader) u32 {
            return self._binder_reply_tid;
        }
    };
    const ThreadStateBreakdownWire = struct {
        const THREAD_STATE_WIRE: gremlin.ProtoWireNumber = 1;
        const THREAD_STATE_DUR_WIRE: gremlin.ProtoWireNumber = 2;
        const THREAD_STATE_COUNT_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const ThreadStateBreakdown = struct {
        // fields
        thread_state: ?[]const u8 = null,
        thread_state_dur: i64 = 0,
        thread_state_count: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidMonitorContentionMetric.ThreadStateBreakdown) usize {
            var res: usize = 0;
            if (self.thread_state) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidMonitorContentionMetric.ThreadStateBreakdownWire.THREAD_STATE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.thread_state_dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidMonitorContentionMetric.ThreadStateBreakdownWire.THREAD_STATE_DUR_WIRE) + gremlin.sizes.sizeI64(self.thread_state_dur);
            }
            if (self.thread_state_count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidMonitorContentionMetric.ThreadStateBreakdownWire.THREAD_STATE_COUNT_WIRE) + gremlin.sizes.sizeI64(self.thread_state_count);
            }
            return res;
        }
        pub fn encode(self: *const AndroidMonitorContentionMetric.ThreadStateBreakdown, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidMonitorContentionMetric.ThreadStateBreakdown, target: *gremlin.Writer) void {
            if (self.thread_state) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidMonitorContentionMetric.ThreadStateBreakdownWire.THREAD_STATE_WIRE, v);
                }
            }
            if (self.thread_state_dur != 0) {
                target.appendInt64(AndroidMonitorContentionMetric.ThreadStateBreakdownWire.THREAD_STATE_DUR_WIRE, self.thread_state_dur);
            }
            if (self.thread_state_count != 0) {
                target.appendInt64(AndroidMonitorContentionMetric.ThreadStateBreakdownWire.THREAD_STATE_COUNT_WIRE, self.thread_state_count);
            }
        }
    };
    pub const ThreadStateBreakdownReader = struct {
        buf: gremlin.Reader,
        _thread_state: ?[]const u8 = null,
        _thread_state_dur: i64 = 0,
        _thread_state_count: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidMonitorContentionMetric.ThreadStateBreakdownReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidMonitorContentionMetric.ThreadStateBreakdownReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidMonitorContentionMetric.ThreadStateBreakdownWire.THREAD_STATE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._thread_state = result.value;
                    },
                    AndroidMonitorContentionMetric.ThreadStateBreakdownWire.THREAD_STATE_DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._thread_state_dur = result.value;
                    },
                    AndroidMonitorContentionMetric.ThreadStateBreakdownWire.THREAD_STATE_COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._thread_state_count = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getThreadState(self: *const AndroidMonitorContentionMetric.ThreadStateBreakdownReader) []const u8 {
            return self._thread_state orelse &[_]u8{};
        }
        pub inline fn getThreadStateDur(self: *const AndroidMonitorContentionMetric.ThreadStateBreakdownReader) i64 {
            return self._thread_state_dur;
        }
        pub inline fn getThreadStateCount(self: *const AndroidMonitorContentionMetric.ThreadStateBreakdownReader) i64 {
            return self._thread_state_count;
        }
    };
    const BlockedFunctionBreakdownWire = struct {
        const BLOCKED_FUNCTION_WIRE: gremlin.ProtoWireNumber = 1;
        const BLOCKED_FUNCTION_DUR_WIRE: gremlin.ProtoWireNumber = 2;
        const BLOCKED_FUNCTION_COUNT_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const BlockedFunctionBreakdown = struct {
        // fields
        blocked_function: ?[]const u8 = null,
        blocked_function_dur: i64 = 0,
        blocked_function_count: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidMonitorContentionMetric.BlockedFunctionBreakdown) usize {
            var res: usize = 0;
            if (self.blocked_function) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidMonitorContentionMetric.BlockedFunctionBreakdownWire.BLOCKED_FUNCTION_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.blocked_function_dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidMonitorContentionMetric.BlockedFunctionBreakdownWire.BLOCKED_FUNCTION_DUR_WIRE) + gremlin.sizes.sizeI64(self.blocked_function_dur);
            }
            if (self.blocked_function_count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidMonitorContentionMetric.BlockedFunctionBreakdownWire.BLOCKED_FUNCTION_COUNT_WIRE) + gremlin.sizes.sizeI64(self.blocked_function_count);
            }
            return res;
        }
        pub fn encode(self: *const AndroidMonitorContentionMetric.BlockedFunctionBreakdown, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidMonitorContentionMetric.BlockedFunctionBreakdown, target: *gremlin.Writer) void {
            if (self.blocked_function) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidMonitorContentionMetric.BlockedFunctionBreakdownWire.BLOCKED_FUNCTION_WIRE, v);
                }
            }
            if (self.blocked_function_dur != 0) {
                target.appendInt64(AndroidMonitorContentionMetric.BlockedFunctionBreakdownWire.BLOCKED_FUNCTION_DUR_WIRE, self.blocked_function_dur);
            }
            if (self.blocked_function_count != 0) {
                target.appendInt64(AndroidMonitorContentionMetric.BlockedFunctionBreakdownWire.BLOCKED_FUNCTION_COUNT_WIRE, self.blocked_function_count);
            }
        }
    };
    pub const BlockedFunctionBreakdownReader = struct {
        buf: gremlin.Reader,
        _blocked_function: ?[]const u8 = null,
        _blocked_function_dur: i64 = 0,
        _blocked_function_count: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidMonitorContentionMetric.BlockedFunctionBreakdownReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidMonitorContentionMetric.BlockedFunctionBreakdownReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidMonitorContentionMetric.BlockedFunctionBreakdownWire.BLOCKED_FUNCTION_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._blocked_function = result.value;
                    },
                    AndroidMonitorContentionMetric.BlockedFunctionBreakdownWire.BLOCKED_FUNCTION_DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._blocked_function_dur = result.value;
                    },
                    AndroidMonitorContentionMetric.BlockedFunctionBreakdownWire.BLOCKED_FUNCTION_COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._blocked_function_count = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getBlockedFunction(self: *const AndroidMonitorContentionMetric.BlockedFunctionBreakdownReader) []const u8 {
            return self._blocked_function orelse &[_]u8{};
        }
        pub inline fn getBlockedFunctionDur(self: *const AndroidMonitorContentionMetric.BlockedFunctionBreakdownReader) i64 {
            return self._blocked_function_dur;
        }
        pub inline fn getBlockedFunctionCount(self: *const AndroidMonitorContentionMetric.BlockedFunctionBreakdownReader) i64 {
            return self._blocked_function_count;
        }
    };
    // fields
    node: ?[]const ?AndroidMonitorContentionMetric.Node = null,
    pub fn calcProtobufSize(self: *const AndroidMonitorContentionMetric) usize {
        var res: usize = 0;
        if (self.node) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidMonitorContentionMetricWire.NODE_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidMonitorContentionMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidMonitorContentionMetric, target: *gremlin.Writer) void {
        if (self.node) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidMonitorContentionMetricWire.NODE_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidMonitorContentionMetricWire.NODE_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidMonitorContentionMetricReader = struct {
    buf: gremlin.Reader,
    _node_offset: ?usize = null,
    _node_last_offset: ?usize = null,
    _node_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidMonitorContentionMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidMonitorContentionMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidMonitorContentionMetricWire.NODE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._node_offset == null) {
                        res._node_offset = offset - result.size;
                    }
                    res._node_last_offset = offset;
                    res._node_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn nodeCount(self: *const AndroidMonitorContentionMetricReader) usize {
        return self._node_cnt;
    }
    pub fn nodeNext(self: *AndroidMonitorContentionMetricReader) ?AndroidMonitorContentionMetric.NodeReader {
        if (self._node_offset == null) return null;
        const current_offset = self._node_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidMonitorContentionMetric.NodeReader.init(result.value) catch return null;
        if (self._node_last_offset != null and current_offset >= self._node_last_offset.?) {
            self._node_offset = null;
            return msg;
        }
        if (self._node_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._node_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidMonitorContentionMetricWire.NODE_WIRE) {
                self._node_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._node_offset = null;
        return msg;
    }
};
const AndroidMultiuserMetricWire = struct {
    const USER_SWITCH_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const AndroidMultiuserMetric = struct {
    // nested structs
    const EventDataWire = struct {
        const DURATION_MS_WIRE: gremlin.ProtoWireNumber = 1;
        const CPU_USAGE_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const EventData = struct {
        // nested structs
        const CpuUsageWire = struct {
            const USER_ID_WIRE: gremlin.ProtoWireNumber = 1;
            const PROCESS_NAME_WIRE: gremlin.ProtoWireNumber = 2;
            const CPU_MCYCLES_WIRE: gremlin.ProtoWireNumber = 3;
            const CPU_PERCENTAGE_WIRE: gremlin.ProtoWireNumber = 4;
            const IDENTIFIER_WIRE: gremlin.ProtoWireNumber = 5;
        };
        pub const CpuUsage = struct {
            // fields
            user_id: i32 = 0,
            process_name: ?[]const u8 = null,
            cpu_mcycles: i32 = 0,
            cpu_percentage: f32 = 0.0,
            identifier: ?[]const u8 = null,
            pub fn calcProtobufSize(self: *const AndroidMultiuserMetric.EventData.CpuUsage) usize {
                var res: usize = 0;
                if (self.user_id != 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidMultiuserMetric.EventData.CpuUsageWire.USER_ID_WIRE) + gremlin.sizes.sizeI32(self.user_id);
                }
                if (self.process_name) |v| {
                    if (v.len > 0) {
                        res += gremlin.sizes.sizeWireNumber(AndroidMultiuserMetric.EventData.CpuUsageWire.PROCESS_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                    }
                }
                if (self.cpu_mcycles != 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidMultiuserMetric.EventData.CpuUsageWire.CPU_MCYCLES_WIRE) + gremlin.sizes.sizeI32(self.cpu_mcycles);
                }
                if (self.cpu_percentage != 0.0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidMultiuserMetric.EventData.CpuUsageWire.CPU_PERCENTAGE_WIRE) + gremlin.sizes.sizeFloat(self.cpu_percentage);
                }
                if (self.identifier) |v| {
                    if (v.len > 0) {
                        res += gremlin.sizes.sizeWireNumber(AndroidMultiuserMetric.EventData.CpuUsageWire.IDENTIFIER_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                    }
                }
                return res;
            }
            pub fn encode(self: *const AndroidMultiuserMetric.EventData.CpuUsage, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const AndroidMultiuserMetric.EventData.CpuUsage, target: *gremlin.Writer) void {
                if (self.user_id != 0) {
                    target.appendInt32(AndroidMultiuserMetric.EventData.CpuUsageWire.USER_ID_WIRE, self.user_id);
                }
                if (self.process_name) |v| {
                    if (v.len > 0) {
                        target.appendBytes(AndroidMultiuserMetric.EventData.CpuUsageWire.PROCESS_NAME_WIRE, v);
                    }
                }
                if (self.cpu_mcycles != 0) {
                    target.appendInt32(AndroidMultiuserMetric.EventData.CpuUsageWire.CPU_MCYCLES_WIRE, self.cpu_mcycles);
                }
                if (self.cpu_percentage != 0.0) {
                    target.appendFloat32(AndroidMultiuserMetric.EventData.CpuUsageWire.CPU_PERCENTAGE_WIRE, self.cpu_percentage);
                }
                if (self.identifier) |v| {
                    if (v.len > 0) {
                        target.appendBytes(AndroidMultiuserMetric.EventData.CpuUsageWire.IDENTIFIER_WIRE, v);
                    }
                }
            }
        };
        pub const CpuUsageReader = struct {
            buf: gremlin.Reader,
            _user_id: i32 = 0,
            _process_name: ?[]const u8 = null,
            _cpu_mcycles: i32 = 0,
            _cpu_percentage: f32 = 0.0,
            _identifier: ?[]const u8 = null,
            pub fn init(src: []const u8) gremlin.Error!AndroidMultiuserMetric.EventData.CpuUsageReader {
                const buf = gremlin.Reader.init(src);
                var res = AndroidMultiuserMetric.EventData.CpuUsageReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        AndroidMultiuserMetric.EventData.CpuUsageWire.USER_ID_WIRE => {
                            const result = try buf.readInt32(offset);
                            offset += result.size;
                            res._user_id = result.value;
                        },
                        AndroidMultiuserMetric.EventData.CpuUsageWire.PROCESS_NAME_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._process_name = result.value;
                        },
                        AndroidMultiuserMetric.EventData.CpuUsageWire.CPU_MCYCLES_WIRE => {
                            const result = try buf.readInt32(offset);
                            offset += result.size;
                            res._cpu_mcycles = result.value;
                        },
                        AndroidMultiuserMetric.EventData.CpuUsageWire.CPU_PERCENTAGE_WIRE => {
                            const result = try buf.readFloat32(offset);
                            offset += result.size;
                            res._cpu_percentage = result.value;
                        },
                        AndroidMultiuserMetric.EventData.CpuUsageWire.IDENTIFIER_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._identifier = result.value;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub inline fn getUserId(self: *const AndroidMultiuserMetric.EventData.CpuUsageReader) i32 {
                return self._user_id;
            }
            pub inline fn getProcessName(self: *const AndroidMultiuserMetric.EventData.CpuUsageReader) []const u8 {
                return self._process_name orelse &[_]u8{};
            }
            pub inline fn getCpuMcycles(self: *const AndroidMultiuserMetric.EventData.CpuUsageReader) i32 {
                return self._cpu_mcycles;
            }
            pub inline fn getCpuPercentage(self: *const AndroidMultiuserMetric.EventData.CpuUsageReader) f32 {
                return self._cpu_percentage;
            }
            pub inline fn getIdentifier(self: *const AndroidMultiuserMetric.EventData.CpuUsageReader) []const u8 {
                return self._identifier orelse &[_]u8{};
            }
        };
        // fields
        duration_ms: i32 = 0,
        cpu_usage: ?[]const ?AndroidMultiuserMetric.EventData.CpuUsage = null,
        pub fn calcProtobufSize(self: *const AndroidMultiuserMetric.EventData) usize {
            var res: usize = 0;
            if (self.duration_ms != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidMultiuserMetric.EventDataWire.DURATION_MS_WIRE) + gremlin.sizes.sizeI32(self.duration_ms);
            }
            if (self.cpu_usage) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidMultiuserMetric.EventDataWire.CPU_USAGE_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidMultiuserMetric.EventData, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidMultiuserMetric.EventData, target: *gremlin.Writer) void {
            if (self.duration_ms != 0) {
                target.appendInt32(AndroidMultiuserMetric.EventDataWire.DURATION_MS_WIRE, self.duration_ms);
            }
            if (self.cpu_usage) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidMultiuserMetric.EventDataWire.CPU_USAGE_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidMultiuserMetric.EventDataWire.CPU_USAGE_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const EventDataReader = struct {
        buf: gremlin.Reader,
        _duration_ms: i32 = 0,
        _cpu_usage_offset: ?usize = null,
        _cpu_usage_last_offset: ?usize = null,
        _cpu_usage_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidMultiuserMetric.EventDataReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidMultiuserMetric.EventDataReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidMultiuserMetric.EventDataWire.DURATION_MS_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._duration_ms = result.value;
                    },
                    AndroidMultiuserMetric.EventDataWire.CPU_USAGE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._cpu_usage_offset == null) {
                            res._cpu_usage_offset = offset - result.size;
                        }
                        res._cpu_usage_last_offset = offset;
                        res._cpu_usage_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getDurationMs(self: *const AndroidMultiuserMetric.EventDataReader) i32 {
            return self._duration_ms;
        }
        pub fn cpuUsageCount(self: *const AndroidMultiuserMetric.EventDataReader) usize {
            return self._cpu_usage_cnt;
        }
        pub fn cpuUsageNext(self: *AndroidMultiuserMetric.EventDataReader) ?AndroidMultiuserMetric.EventData.CpuUsageReader {
            if (self._cpu_usage_offset == null) return null;
            const current_offset = self._cpu_usage_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidMultiuserMetric.EventData.CpuUsageReader.init(result.value) catch return null;
            if (self._cpu_usage_last_offset != null and current_offset >= self._cpu_usage_last_offset.?) {
                self._cpu_usage_offset = null;
                return msg;
            }
            if (self._cpu_usage_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._cpu_usage_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidMultiuserMetric.EventDataWire.CPU_USAGE_WIRE) {
                    self._cpu_usage_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._cpu_usage_offset = null;
            return msg;
        }
    };
    // fields
    user_switch: ?AndroidMultiuserMetric.EventData = null,
    pub fn calcProtobufSize(self: *const AndroidMultiuserMetric) usize {
        var res: usize = 0;
        if (self.user_switch) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidMultiuserMetricWire.USER_SWITCH_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidMultiuserMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidMultiuserMetric, target: *gremlin.Writer) void {
        if (self.user_switch) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidMultiuserMetricWire.USER_SWITCH_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const AndroidMultiuserMetricReader = struct {
    buf: gremlin.Reader,
    _user_switch_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!AndroidMultiuserMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidMultiuserMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidMultiuserMetricWire.USER_SWITCH_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._user_switch_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getUserSwitch(self: *const AndroidMultiuserMetricReader) gremlin.Error!AndroidMultiuserMetric.EventDataReader {
        if (self._user_switch_buf) |buf| {
            return try AndroidMultiuserMetric.EventDataReader.init(buf);
        }
        return try AndroidMultiuserMetric.EventDataReader.init(&[_]u8{});
    }
};
const AndroidNetworkMetricWire = struct {
    const NET_DEVICES_WIRE: gremlin.ProtoWireNumber = 1;
    const NET_RX_ACTION_WIRE: gremlin.ProtoWireNumber = 2;
    const RETRANSMISSION_RATE_WIRE: gremlin.ProtoWireNumber = 3;
    const KFREE_SKB_RATE_WIRE: gremlin.ProtoWireNumber = 4;
    const NET_TX_ACTION_WIRE: gremlin.ProtoWireNumber = 5;
    const IPI_ACTION_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const AndroidNetworkMetric = struct {
    // nested structs
    const PacketStatisticWire = struct {
        const PACKETS_WIRE: gremlin.ProtoWireNumber = 1;
        const BYTES_WIRE: gremlin.ProtoWireNumber = 2;
        const FIRST_PACKET_TIMESTAMP_NS_WIRE: gremlin.ProtoWireNumber = 3;
        const LAST_PACKET_TIMESTAMP_NS_WIRE: gremlin.ProtoWireNumber = 4;
        const INTERVAL_NS_WIRE: gremlin.ProtoWireNumber = 5;
        const DATA_RATE_KBPS_WIRE: gremlin.ProtoWireNumber = 6;
    };
    pub const PacketStatistic = struct {
        // fields
        packets: i64 = 0,
        bytes: i64 = 0,
        first_packet_timestamp_ns: i64 = 0,
        last_packet_timestamp_ns: i64 = 0,
        interval_ns: i64 = 0,
        data_rate_kbps: f64 = 0.0,
        pub fn calcProtobufSize(self: *const AndroidNetworkMetric.PacketStatistic) usize {
            var res: usize = 0;
            if (self.packets != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetric.PacketStatisticWire.PACKETS_WIRE) + gremlin.sizes.sizeI64(self.packets);
            }
            if (self.bytes != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetric.PacketStatisticWire.BYTES_WIRE) + gremlin.sizes.sizeI64(self.bytes);
            }
            if (self.first_packet_timestamp_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetric.PacketStatisticWire.FIRST_PACKET_TIMESTAMP_NS_WIRE) + gremlin.sizes.sizeI64(self.first_packet_timestamp_ns);
            }
            if (self.last_packet_timestamp_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetric.PacketStatisticWire.LAST_PACKET_TIMESTAMP_NS_WIRE) + gremlin.sizes.sizeI64(self.last_packet_timestamp_ns);
            }
            if (self.interval_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetric.PacketStatisticWire.INTERVAL_NS_WIRE) + gremlin.sizes.sizeI64(self.interval_ns);
            }
            if (self.data_rate_kbps != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetric.PacketStatisticWire.DATA_RATE_KBPS_WIRE) + gremlin.sizes.sizeDouble(self.data_rate_kbps);
            }
            return res;
        }
        pub fn encode(self: *const AndroidNetworkMetric.PacketStatistic, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidNetworkMetric.PacketStatistic, target: *gremlin.Writer) void {
            if (self.packets != 0) {
                target.appendInt64(AndroidNetworkMetric.PacketStatisticWire.PACKETS_WIRE, self.packets);
            }
            if (self.bytes != 0) {
                target.appendInt64(AndroidNetworkMetric.PacketStatisticWire.BYTES_WIRE, self.bytes);
            }
            if (self.first_packet_timestamp_ns != 0) {
                target.appendInt64(AndroidNetworkMetric.PacketStatisticWire.FIRST_PACKET_TIMESTAMP_NS_WIRE, self.first_packet_timestamp_ns);
            }
            if (self.last_packet_timestamp_ns != 0) {
                target.appendInt64(AndroidNetworkMetric.PacketStatisticWire.LAST_PACKET_TIMESTAMP_NS_WIRE, self.last_packet_timestamp_ns);
            }
            if (self.interval_ns != 0) {
                target.appendInt64(AndroidNetworkMetric.PacketStatisticWire.INTERVAL_NS_WIRE, self.interval_ns);
            }
            if (self.data_rate_kbps != 0.0) {
                target.appendFloat64(AndroidNetworkMetric.PacketStatisticWire.DATA_RATE_KBPS_WIRE, self.data_rate_kbps);
            }
        }
    };
    pub const PacketStatisticReader = struct {
        buf: gremlin.Reader,
        _packets: i64 = 0,
        _bytes: i64 = 0,
        _first_packet_timestamp_ns: i64 = 0,
        _last_packet_timestamp_ns: i64 = 0,
        _interval_ns: i64 = 0,
        _data_rate_kbps: f64 = 0.0,
        pub fn init(src: []const u8) gremlin.Error!AndroidNetworkMetric.PacketStatisticReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidNetworkMetric.PacketStatisticReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidNetworkMetric.PacketStatisticWire.PACKETS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._packets = result.value;
                    },
                    AndroidNetworkMetric.PacketStatisticWire.BYTES_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._bytes = result.value;
                    },
                    AndroidNetworkMetric.PacketStatisticWire.FIRST_PACKET_TIMESTAMP_NS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._first_packet_timestamp_ns = result.value;
                    },
                    AndroidNetworkMetric.PacketStatisticWire.LAST_PACKET_TIMESTAMP_NS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._last_packet_timestamp_ns = result.value;
                    },
                    AndroidNetworkMetric.PacketStatisticWire.INTERVAL_NS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._interval_ns = result.value;
                    },
                    AndroidNetworkMetric.PacketStatisticWire.DATA_RATE_KBPS_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._data_rate_kbps = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getPackets(self: *const AndroidNetworkMetric.PacketStatisticReader) i64 {
            return self._packets;
        }
        pub inline fn getBytes(self: *const AndroidNetworkMetric.PacketStatisticReader) i64 {
            return self._bytes;
        }
        pub inline fn getFirstPacketTimestampNs(self: *const AndroidNetworkMetric.PacketStatisticReader) i64 {
            return self._first_packet_timestamp_ns;
        }
        pub inline fn getLastPacketTimestampNs(self: *const AndroidNetworkMetric.PacketStatisticReader) i64 {
            return self._last_packet_timestamp_ns;
        }
        pub inline fn getIntervalNs(self: *const AndroidNetworkMetric.PacketStatisticReader) i64 {
            return self._interval_ns;
        }
        pub inline fn getDataRateKbps(self: *const AndroidNetworkMetric.PacketStatisticReader) f64 {
            return self._data_rate_kbps;
        }
    };
    const CorePacketStatisticWire = struct {
        const ID_WIRE: gremlin.ProtoWireNumber = 1;
        const PACKET_STATISTIC_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const CorePacketStatistic = struct {
        // fields
        id: u32 = 0,
        packet_statistic: ?AndroidNetworkMetric.PacketStatistic = null,
        pub fn calcProtobufSize(self: *const AndroidNetworkMetric.CorePacketStatistic) usize {
            var res: usize = 0;
            if (self.id != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetric.CorePacketStatisticWire.ID_WIRE) + gremlin.sizes.sizeU32(self.id);
            }
            if (self.packet_statistic) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetric.CorePacketStatisticWire.PACKET_STATISTIC_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidNetworkMetric.CorePacketStatistic, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidNetworkMetric.CorePacketStatistic, target: *gremlin.Writer) void {
            if (self.id != 0) {
                target.appendUint32(AndroidNetworkMetric.CorePacketStatisticWire.ID_WIRE, self.id);
            }
            if (self.packet_statistic) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidNetworkMetric.CorePacketStatisticWire.PACKET_STATISTIC_WIRE, size);
                    v.encodeTo(target);
                }
            }
        }
    };
    pub const CorePacketStatisticReader = struct {
        buf: gremlin.Reader,
        _id: u32 = 0,
        _packet_statistic_buf: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!AndroidNetworkMetric.CorePacketStatisticReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidNetworkMetric.CorePacketStatisticReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidNetworkMetric.CorePacketStatisticWire.ID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._id = result.value;
                    },
                    AndroidNetworkMetric.CorePacketStatisticWire.PACKET_STATISTIC_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._packet_statistic_buf = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getId(self: *const AndroidNetworkMetric.CorePacketStatisticReader) u32 {
            return self._id;
        }
        pub fn getPacketStatistic(self: *const AndroidNetworkMetric.CorePacketStatisticReader) gremlin.Error!AndroidNetworkMetric.PacketStatisticReader {
            if (self._packet_statistic_buf) |buf| {
                return try AndroidNetworkMetric.PacketStatisticReader.init(buf);
            }
            return try AndroidNetworkMetric.PacketStatisticReader.init(&[_]u8{});
        }
    };
    const RxWire = struct {
        const TOTAL_WIRE: gremlin.ProtoWireNumber = 1;
        const CORE_WIRE: gremlin.ProtoWireNumber = 2;
        const GRO_AGGREGATION_RATIO_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const Rx = struct {
        // fields
        total: ?AndroidNetworkMetric.PacketStatistic = null,
        core: ?[]const ?AndroidNetworkMetric.CorePacketStatistic = null,
        gro_aggregation_ratio: ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const AndroidNetworkMetric.Rx) usize {
            var res: usize = 0;
            if (self.total) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetric.RxWire.TOTAL_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.core) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetric.RxWire.CORE_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.gro_aggregation_ratio) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetric.RxWire.GRO_AGGREGATION_RATIO_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidNetworkMetric.Rx, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidNetworkMetric.Rx, target: *gremlin.Writer) void {
            if (self.total) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidNetworkMetric.RxWire.TOTAL_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.core) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidNetworkMetric.RxWire.CORE_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidNetworkMetric.RxWire.CORE_WIRE, 0);
                    }
                }
            }
            if (self.gro_aggregation_ratio) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidNetworkMetric.RxWire.GRO_AGGREGATION_RATIO_WIRE, v);
                }
            }
        }
    };
    pub const RxReader = struct {
        buf: gremlin.Reader,
        _total_buf: ?[]const u8 = null,
        _core_offset: ?usize = null,
        _core_last_offset: ?usize = null,
        _core_cnt: usize = 0,
        _gro_aggregation_ratio: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!AndroidNetworkMetric.RxReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidNetworkMetric.RxReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidNetworkMetric.RxWire.TOTAL_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._total_buf = result.value;
                    },
                    AndroidNetworkMetric.RxWire.CORE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._core_offset == null) {
                            res._core_offset = offset - result.size;
                        }
                        res._core_last_offset = offset;
                        res._core_cnt += 1;
                    },
                    AndroidNetworkMetric.RxWire.GRO_AGGREGATION_RATIO_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._gro_aggregation_ratio = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn getTotal(self: *const AndroidNetworkMetric.RxReader) gremlin.Error!AndroidNetworkMetric.PacketStatisticReader {
            if (self._total_buf) |buf| {
                return try AndroidNetworkMetric.PacketStatisticReader.init(buf);
            }
            return try AndroidNetworkMetric.PacketStatisticReader.init(&[_]u8{});
        }
        pub fn coreCount(self: *const AndroidNetworkMetric.RxReader) usize {
            return self._core_cnt;
        }
        pub fn coreNext(self: *AndroidNetworkMetric.RxReader) ?AndroidNetworkMetric.CorePacketStatisticReader {
            if (self._core_offset == null) return null;
            const current_offset = self._core_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidNetworkMetric.CorePacketStatisticReader.init(result.value) catch return null;
            if (self._core_last_offset != null and current_offset >= self._core_last_offset.?) {
                self._core_offset = null;
                return msg;
            }
            if (self._core_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._core_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidNetworkMetric.RxWire.CORE_WIRE) {
                    self._core_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._core_offset = null;
            return msg;
        }
        pub inline fn getGroAggregationRatio(self: *const AndroidNetworkMetric.RxReader) []const u8 {
            return self._gro_aggregation_ratio orelse &[_]u8{};
        }
    };
    const TxWire = struct {
        const TOTAL_WIRE: gremlin.ProtoWireNumber = 1;
        const CORE_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const Tx = struct {
        // fields
        total: ?AndroidNetworkMetric.PacketStatistic = null,
        core: ?[]const ?AndroidNetworkMetric.CorePacketStatistic = null,
        pub fn calcProtobufSize(self: *const AndroidNetworkMetric.Tx) usize {
            var res: usize = 0;
            if (self.total) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetric.TxWire.TOTAL_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.core) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetric.TxWire.CORE_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidNetworkMetric.Tx, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidNetworkMetric.Tx, target: *gremlin.Writer) void {
            if (self.total) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidNetworkMetric.TxWire.TOTAL_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.core) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidNetworkMetric.TxWire.CORE_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidNetworkMetric.TxWire.CORE_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const TxReader = struct {
        buf: gremlin.Reader,
        _total_buf: ?[]const u8 = null,
        _core_offset: ?usize = null,
        _core_last_offset: ?usize = null,
        _core_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidNetworkMetric.TxReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidNetworkMetric.TxReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidNetworkMetric.TxWire.TOTAL_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._total_buf = result.value;
                    },
                    AndroidNetworkMetric.TxWire.CORE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._core_offset == null) {
                            res._core_offset = offset - result.size;
                        }
                        res._core_last_offset = offset;
                        res._core_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn getTotal(self: *const AndroidNetworkMetric.TxReader) gremlin.Error!AndroidNetworkMetric.PacketStatisticReader {
            if (self._total_buf) |buf| {
                return try AndroidNetworkMetric.PacketStatisticReader.init(buf);
            }
            return try AndroidNetworkMetric.PacketStatisticReader.init(&[_]u8{});
        }
        pub fn coreCount(self: *const AndroidNetworkMetric.TxReader) usize {
            return self._core_cnt;
        }
        pub fn coreNext(self: *AndroidNetworkMetric.TxReader) ?AndroidNetworkMetric.CorePacketStatisticReader {
            if (self._core_offset == null) return null;
            const current_offset = self._core_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidNetworkMetric.CorePacketStatisticReader.init(result.value) catch return null;
            if (self._core_last_offset != null and current_offset >= self._core_last_offset.?) {
                self._core_offset = null;
                return msg;
            }
            if (self._core_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._core_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidNetworkMetric.TxWire.CORE_WIRE) {
                    self._core_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._core_offset = null;
            return msg;
        }
    };
    const NetDeviceWire = struct {
        const NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const RX_WIRE: gremlin.ProtoWireNumber = 2;
        const TX_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const NetDevice = struct {
        // fields
        name: ?[]const u8 = null,
        rx: ?AndroidNetworkMetric.Rx = null,
        tx: ?AndroidNetworkMetric.Tx = null,
        pub fn calcProtobufSize(self: *const AndroidNetworkMetric.NetDevice) usize {
            var res: usize = 0;
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetric.NetDeviceWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.rx) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetric.NetDeviceWire.RX_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.tx) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetric.NetDeviceWire.TX_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidNetworkMetric.NetDevice, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidNetworkMetric.NetDevice, target: *gremlin.Writer) void {
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidNetworkMetric.NetDeviceWire.NAME_WIRE, v);
                }
            }
            if (self.rx) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidNetworkMetric.NetDeviceWire.RX_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.tx) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidNetworkMetric.NetDeviceWire.TX_WIRE, size);
                    v.encodeTo(target);
                }
            }
        }
    };
    pub const NetDeviceReader = struct {
        buf: gremlin.Reader,
        _name: ?[]const u8 = null,
        _rx_buf: ?[]const u8 = null,
        _tx_buf: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!AndroidNetworkMetric.NetDeviceReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidNetworkMetric.NetDeviceReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidNetworkMetric.NetDeviceWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    AndroidNetworkMetric.NetDeviceWire.RX_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._rx_buf = result.value;
                    },
                    AndroidNetworkMetric.NetDeviceWire.TX_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._tx_buf = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getName(self: *const AndroidNetworkMetric.NetDeviceReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub fn getRx(self: *const AndroidNetworkMetric.NetDeviceReader) gremlin.Error!AndroidNetworkMetric.RxReader {
            if (self._rx_buf) |buf| {
                return try AndroidNetworkMetric.RxReader.init(buf);
            }
            return try AndroidNetworkMetric.RxReader.init(&[_]u8{});
        }
        pub fn getTx(self: *const AndroidNetworkMetric.NetDeviceReader) gremlin.Error!AndroidNetworkMetric.TxReader {
            if (self._tx_buf) |buf| {
                return try AndroidNetworkMetric.TxReader.init(buf);
            }
            return try AndroidNetworkMetric.TxReader.init(&[_]u8{});
        }
    };
    const NetRxActionStatisticWire = struct {
        const COUNT_WIRE: gremlin.ProtoWireNumber = 1;
        const RUNTIME_MS_WIRE: gremlin.ProtoWireNumber = 2;
        const AVG_RUNTIME_MS_WIRE: gremlin.ProtoWireNumber = 3;
        const MCYCLES_WIRE: gremlin.ProtoWireNumber = 4;
        const AVG_FREQ_KHZ_WIRE: gremlin.ProtoWireNumber = 5;
    };
    pub const NetRxActionStatistic = struct {
        // fields
        count: i64 = 0,
        runtime_ms: f64 = 0.0,
        avg_runtime_ms: f64 = 0.0,
        mcycles: i64 = 0,
        avg_freq_khz: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidNetworkMetric.NetRxActionStatistic) usize {
            var res: usize = 0;
            if (self.count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetric.NetRxActionStatisticWire.COUNT_WIRE) + gremlin.sizes.sizeI64(self.count);
            }
            if (self.runtime_ms != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetric.NetRxActionStatisticWire.RUNTIME_MS_WIRE) + gremlin.sizes.sizeDouble(self.runtime_ms);
            }
            if (self.avg_runtime_ms != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetric.NetRxActionStatisticWire.AVG_RUNTIME_MS_WIRE) + gremlin.sizes.sizeDouble(self.avg_runtime_ms);
            }
            if (self.mcycles != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetric.NetRxActionStatisticWire.MCYCLES_WIRE) + gremlin.sizes.sizeI64(self.mcycles);
            }
            if (self.avg_freq_khz != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetric.NetRxActionStatisticWire.AVG_FREQ_KHZ_WIRE) + gremlin.sizes.sizeI64(self.avg_freq_khz);
            }
            return res;
        }
        pub fn encode(self: *const AndroidNetworkMetric.NetRxActionStatistic, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidNetworkMetric.NetRxActionStatistic, target: *gremlin.Writer) void {
            if (self.count != 0) {
                target.appendInt64(AndroidNetworkMetric.NetRxActionStatisticWire.COUNT_WIRE, self.count);
            }
            if (self.runtime_ms != 0.0) {
                target.appendFloat64(AndroidNetworkMetric.NetRxActionStatisticWire.RUNTIME_MS_WIRE, self.runtime_ms);
            }
            if (self.avg_runtime_ms != 0.0) {
                target.appendFloat64(AndroidNetworkMetric.NetRxActionStatisticWire.AVG_RUNTIME_MS_WIRE, self.avg_runtime_ms);
            }
            if (self.mcycles != 0) {
                target.appendInt64(AndroidNetworkMetric.NetRxActionStatisticWire.MCYCLES_WIRE, self.mcycles);
            }
            if (self.avg_freq_khz != 0) {
                target.appendInt64(AndroidNetworkMetric.NetRxActionStatisticWire.AVG_FREQ_KHZ_WIRE, self.avg_freq_khz);
            }
        }
    };
    pub const NetRxActionStatisticReader = struct {
        buf: gremlin.Reader,
        _count: i64 = 0,
        _runtime_ms: f64 = 0.0,
        _avg_runtime_ms: f64 = 0.0,
        _mcycles: i64 = 0,
        _avg_freq_khz: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidNetworkMetric.NetRxActionStatisticReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidNetworkMetric.NetRxActionStatisticReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidNetworkMetric.NetRxActionStatisticWire.COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._count = result.value;
                    },
                    AndroidNetworkMetric.NetRxActionStatisticWire.RUNTIME_MS_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._runtime_ms = result.value;
                    },
                    AndroidNetworkMetric.NetRxActionStatisticWire.AVG_RUNTIME_MS_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._avg_runtime_ms = result.value;
                    },
                    AndroidNetworkMetric.NetRxActionStatisticWire.MCYCLES_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._mcycles = result.value;
                    },
                    AndroidNetworkMetric.NetRxActionStatisticWire.AVG_FREQ_KHZ_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._avg_freq_khz = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getCount(self: *const AndroidNetworkMetric.NetRxActionStatisticReader) i64 {
            return self._count;
        }
        pub inline fn getRuntimeMs(self: *const AndroidNetworkMetric.NetRxActionStatisticReader) f64 {
            return self._runtime_ms;
        }
        pub inline fn getAvgRuntimeMs(self: *const AndroidNetworkMetric.NetRxActionStatisticReader) f64 {
            return self._avg_runtime_ms;
        }
        pub inline fn getMcycles(self: *const AndroidNetworkMetric.NetRxActionStatisticReader) i64 {
            return self._mcycles;
        }
        pub inline fn getAvgFreqKhz(self: *const AndroidNetworkMetric.NetRxActionStatisticReader) i64 {
            return self._avg_freq_khz;
        }
    };
    const NetTxActionStatisticWire = struct {
        const COUNT_WIRE: gremlin.ProtoWireNumber = 1;
        const RUNTIME_MS_WIRE: gremlin.ProtoWireNumber = 2;
        const AVG_RUNTIME_MS_WIRE: gremlin.ProtoWireNumber = 3;
        const MCYCLES_WIRE: gremlin.ProtoWireNumber = 4;
        const AVG_FREQ_KHZ_WIRE: gremlin.ProtoWireNumber = 5;
    };
    pub const NetTxActionStatistic = struct {
        // fields
        count: i64 = 0,
        runtime_ms: f64 = 0.0,
        avg_runtime_ms: f64 = 0.0,
        mcycles: i64 = 0,
        avg_freq_khz: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidNetworkMetric.NetTxActionStatistic) usize {
            var res: usize = 0;
            if (self.count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetric.NetTxActionStatisticWire.COUNT_WIRE) + gremlin.sizes.sizeI64(self.count);
            }
            if (self.runtime_ms != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetric.NetTxActionStatisticWire.RUNTIME_MS_WIRE) + gremlin.sizes.sizeDouble(self.runtime_ms);
            }
            if (self.avg_runtime_ms != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetric.NetTxActionStatisticWire.AVG_RUNTIME_MS_WIRE) + gremlin.sizes.sizeDouble(self.avg_runtime_ms);
            }
            if (self.mcycles != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetric.NetTxActionStatisticWire.MCYCLES_WIRE) + gremlin.sizes.sizeI64(self.mcycles);
            }
            if (self.avg_freq_khz != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetric.NetTxActionStatisticWire.AVG_FREQ_KHZ_WIRE) + gremlin.sizes.sizeI64(self.avg_freq_khz);
            }
            return res;
        }
        pub fn encode(self: *const AndroidNetworkMetric.NetTxActionStatistic, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidNetworkMetric.NetTxActionStatistic, target: *gremlin.Writer) void {
            if (self.count != 0) {
                target.appendInt64(AndroidNetworkMetric.NetTxActionStatisticWire.COUNT_WIRE, self.count);
            }
            if (self.runtime_ms != 0.0) {
                target.appendFloat64(AndroidNetworkMetric.NetTxActionStatisticWire.RUNTIME_MS_WIRE, self.runtime_ms);
            }
            if (self.avg_runtime_ms != 0.0) {
                target.appendFloat64(AndroidNetworkMetric.NetTxActionStatisticWire.AVG_RUNTIME_MS_WIRE, self.avg_runtime_ms);
            }
            if (self.mcycles != 0) {
                target.appendInt64(AndroidNetworkMetric.NetTxActionStatisticWire.MCYCLES_WIRE, self.mcycles);
            }
            if (self.avg_freq_khz != 0) {
                target.appendInt64(AndroidNetworkMetric.NetTxActionStatisticWire.AVG_FREQ_KHZ_WIRE, self.avg_freq_khz);
            }
        }
    };
    pub const NetTxActionStatisticReader = struct {
        buf: gremlin.Reader,
        _count: i64 = 0,
        _runtime_ms: f64 = 0.0,
        _avg_runtime_ms: f64 = 0.0,
        _mcycles: i64 = 0,
        _avg_freq_khz: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidNetworkMetric.NetTxActionStatisticReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidNetworkMetric.NetTxActionStatisticReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidNetworkMetric.NetTxActionStatisticWire.COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._count = result.value;
                    },
                    AndroidNetworkMetric.NetTxActionStatisticWire.RUNTIME_MS_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._runtime_ms = result.value;
                    },
                    AndroidNetworkMetric.NetTxActionStatisticWire.AVG_RUNTIME_MS_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._avg_runtime_ms = result.value;
                    },
                    AndroidNetworkMetric.NetTxActionStatisticWire.MCYCLES_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._mcycles = result.value;
                    },
                    AndroidNetworkMetric.NetTxActionStatisticWire.AVG_FREQ_KHZ_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._avg_freq_khz = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getCount(self: *const AndroidNetworkMetric.NetTxActionStatisticReader) i64 {
            return self._count;
        }
        pub inline fn getRuntimeMs(self: *const AndroidNetworkMetric.NetTxActionStatisticReader) f64 {
            return self._runtime_ms;
        }
        pub inline fn getAvgRuntimeMs(self: *const AndroidNetworkMetric.NetTxActionStatisticReader) f64 {
            return self._avg_runtime_ms;
        }
        pub inline fn getMcycles(self: *const AndroidNetworkMetric.NetTxActionStatisticReader) i64 {
            return self._mcycles;
        }
        pub inline fn getAvgFreqKhz(self: *const AndroidNetworkMetric.NetTxActionStatisticReader) i64 {
            return self._avg_freq_khz;
        }
    };
    const IpiActionStatisticWire = struct {
        const COUNT_WIRE: gremlin.ProtoWireNumber = 1;
        const RUNTIME_MS_WIRE: gremlin.ProtoWireNumber = 2;
        const AVG_RUNTIME_MS_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const IpiActionStatistic = struct {
        // fields
        count: i64 = 0,
        runtime_ms: f64 = 0.0,
        avg_runtime_ms: f64 = 0.0,
        pub fn calcProtobufSize(self: *const AndroidNetworkMetric.IpiActionStatistic) usize {
            var res: usize = 0;
            if (self.count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetric.IpiActionStatisticWire.COUNT_WIRE) + gremlin.sizes.sizeI64(self.count);
            }
            if (self.runtime_ms != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetric.IpiActionStatisticWire.RUNTIME_MS_WIRE) + gremlin.sizes.sizeDouble(self.runtime_ms);
            }
            if (self.avg_runtime_ms != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetric.IpiActionStatisticWire.AVG_RUNTIME_MS_WIRE) + gremlin.sizes.sizeDouble(self.avg_runtime_ms);
            }
            return res;
        }
        pub fn encode(self: *const AndroidNetworkMetric.IpiActionStatistic, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidNetworkMetric.IpiActionStatistic, target: *gremlin.Writer) void {
            if (self.count != 0) {
                target.appendInt64(AndroidNetworkMetric.IpiActionStatisticWire.COUNT_WIRE, self.count);
            }
            if (self.runtime_ms != 0.0) {
                target.appendFloat64(AndroidNetworkMetric.IpiActionStatisticWire.RUNTIME_MS_WIRE, self.runtime_ms);
            }
            if (self.avg_runtime_ms != 0.0) {
                target.appendFloat64(AndroidNetworkMetric.IpiActionStatisticWire.AVG_RUNTIME_MS_WIRE, self.avg_runtime_ms);
            }
        }
    };
    pub const IpiActionStatisticReader = struct {
        buf: gremlin.Reader,
        _count: i64 = 0,
        _runtime_ms: f64 = 0.0,
        _avg_runtime_ms: f64 = 0.0,
        pub fn init(src: []const u8) gremlin.Error!AndroidNetworkMetric.IpiActionStatisticReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidNetworkMetric.IpiActionStatisticReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidNetworkMetric.IpiActionStatisticWire.COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._count = result.value;
                    },
                    AndroidNetworkMetric.IpiActionStatisticWire.RUNTIME_MS_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._runtime_ms = result.value;
                    },
                    AndroidNetworkMetric.IpiActionStatisticWire.AVG_RUNTIME_MS_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._avg_runtime_ms = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getCount(self: *const AndroidNetworkMetric.IpiActionStatisticReader) i64 {
            return self._count;
        }
        pub inline fn getRuntimeMs(self: *const AndroidNetworkMetric.IpiActionStatisticReader) f64 {
            return self._runtime_ms;
        }
        pub inline fn getAvgRuntimeMs(self: *const AndroidNetworkMetric.IpiActionStatisticReader) f64 {
            return self._avg_runtime_ms;
        }
    };
    const CoreNetRxActionStatisticWire = struct {
        const ID_WIRE: gremlin.ProtoWireNumber = 1;
        const NET_RX_ACTION_STATISTIC_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const CoreNetRxActionStatistic = struct {
        // fields
        id: u32 = 0,
        net_rx_action_statistic: ?AndroidNetworkMetric.NetRxActionStatistic = null,
        pub fn calcProtobufSize(self: *const AndroidNetworkMetric.CoreNetRxActionStatistic) usize {
            var res: usize = 0;
            if (self.id != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetric.CoreNetRxActionStatisticWire.ID_WIRE) + gremlin.sizes.sizeU32(self.id);
            }
            if (self.net_rx_action_statistic) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetric.CoreNetRxActionStatisticWire.NET_RX_ACTION_STATISTIC_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidNetworkMetric.CoreNetRxActionStatistic, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidNetworkMetric.CoreNetRxActionStatistic, target: *gremlin.Writer) void {
            if (self.id != 0) {
                target.appendUint32(AndroidNetworkMetric.CoreNetRxActionStatisticWire.ID_WIRE, self.id);
            }
            if (self.net_rx_action_statistic) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidNetworkMetric.CoreNetRxActionStatisticWire.NET_RX_ACTION_STATISTIC_WIRE, size);
                    v.encodeTo(target);
                }
            }
        }
    };
    pub const CoreNetRxActionStatisticReader = struct {
        buf: gremlin.Reader,
        _id: u32 = 0,
        _net_rx_action_statistic_buf: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!AndroidNetworkMetric.CoreNetRxActionStatisticReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidNetworkMetric.CoreNetRxActionStatisticReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidNetworkMetric.CoreNetRxActionStatisticWire.ID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._id = result.value;
                    },
                    AndroidNetworkMetric.CoreNetRxActionStatisticWire.NET_RX_ACTION_STATISTIC_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._net_rx_action_statistic_buf = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getId(self: *const AndroidNetworkMetric.CoreNetRxActionStatisticReader) u32 {
            return self._id;
        }
        pub fn getNetRxActionStatistic(self: *const AndroidNetworkMetric.CoreNetRxActionStatisticReader) gremlin.Error!AndroidNetworkMetric.NetRxActionStatisticReader {
            if (self._net_rx_action_statistic_buf) |buf| {
                return try AndroidNetworkMetric.NetRxActionStatisticReader.init(buf);
            }
            return try AndroidNetworkMetric.NetRxActionStatisticReader.init(&[_]u8{});
        }
    };
    const CoreNetTxActionStatisticWire = struct {
        const ID_WIRE: gremlin.ProtoWireNumber = 1;
        const NET_TX_ACTION_STATISTIC_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const CoreNetTxActionStatistic = struct {
        // fields
        id: u32 = 0,
        net_tx_action_statistic: ?AndroidNetworkMetric.NetTxActionStatistic = null,
        pub fn calcProtobufSize(self: *const AndroidNetworkMetric.CoreNetTxActionStatistic) usize {
            var res: usize = 0;
            if (self.id != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetric.CoreNetTxActionStatisticWire.ID_WIRE) + gremlin.sizes.sizeU32(self.id);
            }
            if (self.net_tx_action_statistic) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetric.CoreNetTxActionStatisticWire.NET_TX_ACTION_STATISTIC_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidNetworkMetric.CoreNetTxActionStatistic, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidNetworkMetric.CoreNetTxActionStatistic, target: *gremlin.Writer) void {
            if (self.id != 0) {
                target.appendUint32(AndroidNetworkMetric.CoreNetTxActionStatisticWire.ID_WIRE, self.id);
            }
            if (self.net_tx_action_statistic) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidNetworkMetric.CoreNetTxActionStatisticWire.NET_TX_ACTION_STATISTIC_WIRE, size);
                    v.encodeTo(target);
                }
            }
        }
    };
    pub const CoreNetTxActionStatisticReader = struct {
        buf: gremlin.Reader,
        _id: u32 = 0,
        _net_tx_action_statistic_buf: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!AndroidNetworkMetric.CoreNetTxActionStatisticReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidNetworkMetric.CoreNetTxActionStatisticReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidNetworkMetric.CoreNetTxActionStatisticWire.ID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._id = result.value;
                    },
                    AndroidNetworkMetric.CoreNetTxActionStatisticWire.NET_TX_ACTION_STATISTIC_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._net_tx_action_statistic_buf = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getId(self: *const AndroidNetworkMetric.CoreNetTxActionStatisticReader) u32 {
            return self._id;
        }
        pub fn getNetTxActionStatistic(self: *const AndroidNetworkMetric.CoreNetTxActionStatisticReader) gremlin.Error!AndroidNetworkMetric.NetTxActionStatisticReader {
            if (self._net_tx_action_statistic_buf) |buf| {
                return try AndroidNetworkMetric.NetTxActionStatisticReader.init(buf);
            }
            return try AndroidNetworkMetric.NetTxActionStatisticReader.init(&[_]u8{});
        }
    };
    const NetRxActionWire = struct {
        const TOTAL_WIRE: gremlin.ProtoWireNumber = 1;
        const CORE_WIRE: gremlin.ProtoWireNumber = 2;
        const AVG_INTERSTACK_LATENCY_MS_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const NetRxAction = struct {
        // fields
        total: ?AndroidNetworkMetric.NetRxActionStatistic = null,
        core: ?[]const ?AndroidNetworkMetric.CoreNetRxActionStatistic = null,
        avg_interstack_latency_ms: f64 = 0.0,
        pub fn calcProtobufSize(self: *const AndroidNetworkMetric.NetRxAction) usize {
            var res: usize = 0;
            if (self.total) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetric.NetRxActionWire.TOTAL_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.core) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetric.NetRxActionWire.CORE_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.avg_interstack_latency_ms != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetric.NetRxActionWire.AVG_INTERSTACK_LATENCY_MS_WIRE) + gremlin.sizes.sizeDouble(self.avg_interstack_latency_ms);
            }
            return res;
        }
        pub fn encode(self: *const AndroidNetworkMetric.NetRxAction, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidNetworkMetric.NetRxAction, target: *gremlin.Writer) void {
            if (self.total) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidNetworkMetric.NetRxActionWire.TOTAL_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.core) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidNetworkMetric.NetRxActionWire.CORE_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidNetworkMetric.NetRxActionWire.CORE_WIRE, 0);
                    }
                }
            }
            if (self.avg_interstack_latency_ms != 0.0) {
                target.appendFloat64(AndroidNetworkMetric.NetRxActionWire.AVG_INTERSTACK_LATENCY_MS_WIRE, self.avg_interstack_latency_ms);
            }
        }
    };
    pub const NetRxActionReader = struct {
        buf: gremlin.Reader,
        _total_buf: ?[]const u8 = null,
        _core_offset: ?usize = null,
        _core_last_offset: ?usize = null,
        _core_cnt: usize = 0,
        _avg_interstack_latency_ms: f64 = 0.0,
        pub fn init(src: []const u8) gremlin.Error!AndroidNetworkMetric.NetRxActionReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidNetworkMetric.NetRxActionReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidNetworkMetric.NetRxActionWire.TOTAL_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._total_buf = result.value;
                    },
                    AndroidNetworkMetric.NetRxActionWire.CORE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._core_offset == null) {
                            res._core_offset = offset - result.size;
                        }
                        res._core_last_offset = offset;
                        res._core_cnt += 1;
                    },
                    AndroidNetworkMetric.NetRxActionWire.AVG_INTERSTACK_LATENCY_MS_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._avg_interstack_latency_ms = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn getTotal(self: *const AndroidNetworkMetric.NetRxActionReader) gremlin.Error!AndroidNetworkMetric.NetRxActionStatisticReader {
            if (self._total_buf) |buf| {
                return try AndroidNetworkMetric.NetRxActionStatisticReader.init(buf);
            }
            return try AndroidNetworkMetric.NetRxActionStatisticReader.init(&[_]u8{});
        }
        pub fn coreCount(self: *const AndroidNetworkMetric.NetRxActionReader) usize {
            return self._core_cnt;
        }
        pub fn coreNext(self: *AndroidNetworkMetric.NetRxActionReader) ?AndroidNetworkMetric.CoreNetRxActionStatisticReader {
            if (self._core_offset == null) return null;
            const current_offset = self._core_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidNetworkMetric.CoreNetRxActionStatisticReader.init(result.value) catch return null;
            if (self._core_last_offset != null and current_offset >= self._core_last_offset.?) {
                self._core_offset = null;
                return msg;
            }
            if (self._core_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._core_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidNetworkMetric.NetRxActionWire.CORE_WIRE) {
                    self._core_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._core_offset = null;
            return msg;
        }
        pub inline fn getAvgInterstackLatencyMs(self: *const AndroidNetworkMetric.NetRxActionReader) f64 {
            return self._avg_interstack_latency_ms;
        }
    };
    const NetTxActionWire = struct {
        const TOTAL_WIRE: gremlin.ProtoWireNumber = 1;
        const CORE_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const NetTxAction = struct {
        // fields
        total: ?AndroidNetworkMetric.NetTxActionStatistic = null,
        core: ?[]const ?AndroidNetworkMetric.CoreNetTxActionStatistic = null,
        pub fn calcProtobufSize(self: *const AndroidNetworkMetric.NetTxAction) usize {
            var res: usize = 0;
            if (self.total) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetric.NetTxActionWire.TOTAL_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.core) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetric.NetTxActionWire.CORE_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidNetworkMetric.NetTxAction, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidNetworkMetric.NetTxAction, target: *gremlin.Writer) void {
            if (self.total) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidNetworkMetric.NetTxActionWire.TOTAL_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.core) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidNetworkMetric.NetTxActionWire.CORE_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidNetworkMetric.NetTxActionWire.CORE_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const NetTxActionReader = struct {
        buf: gremlin.Reader,
        _total_buf: ?[]const u8 = null,
        _core_offset: ?usize = null,
        _core_last_offset: ?usize = null,
        _core_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidNetworkMetric.NetTxActionReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidNetworkMetric.NetTxActionReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidNetworkMetric.NetTxActionWire.TOTAL_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._total_buf = result.value;
                    },
                    AndroidNetworkMetric.NetTxActionWire.CORE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._core_offset == null) {
                            res._core_offset = offset - result.size;
                        }
                        res._core_last_offset = offset;
                        res._core_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn getTotal(self: *const AndroidNetworkMetric.NetTxActionReader) gremlin.Error!AndroidNetworkMetric.NetTxActionStatisticReader {
            if (self._total_buf) |buf| {
                return try AndroidNetworkMetric.NetTxActionStatisticReader.init(buf);
            }
            return try AndroidNetworkMetric.NetTxActionStatisticReader.init(&[_]u8{});
        }
        pub fn coreCount(self: *const AndroidNetworkMetric.NetTxActionReader) usize {
            return self._core_cnt;
        }
        pub fn coreNext(self: *AndroidNetworkMetric.NetTxActionReader) ?AndroidNetworkMetric.CoreNetTxActionStatisticReader {
            if (self._core_offset == null) return null;
            const current_offset = self._core_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidNetworkMetric.CoreNetTxActionStatisticReader.init(result.value) catch return null;
            if (self._core_last_offset != null and current_offset >= self._core_last_offset.?) {
                self._core_offset = null;
                return msg;
            }
            if (self._core_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._core_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidNetworkMetric.NetTxActionWire.CORE_WIRE) {
                    self._core_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._core_offset = null;
            return msg;
        }
    };
    const IpiActionWire = struct {
        const TOTAL_WIRE: gremlin.ProtoWireNumber = 1;
    };
    pub const IpiAction = struct {
        // fields
        total: ?AndroidNetworkMetric.IpiActionStatistic = null,
        pub fn calcProtobufSize(self: *const AndroidNetworkMetric.IpiAction) usize {
            var res: usize = 0;
            if (self.total) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetric.IpiActionWire.TOTAL_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidNetworkMetric.IpiAction, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidNetworkMetric.IpiAction, target: *gremlin.Writer) void {
            if (self.total) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidNetworkMetric.IpiActionWire.TOTAL_WIRE, size);
                    v.encodeTo(target);
                }
            }
        }
    };
    pub const IpiActionReader = struct {
        buf: gremlin.Reader,
        _total_buf: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!AndroidNetworkMetric.IpiActionReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidNetworkMetric.IpiActionReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidNetworkMetric.IpiActionWire.TOTAL_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._total_buf = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn getTotal(self: *const AndroidNetworkMetric.IpiActionReader) gremlin.Error!AndroidNetworkMetric.IpiActionStatisticReader {
            if (self._total_buf) |buf| {
                return try AndroidNetworkMetric.IpiActionStatisticReader.init(buf);
            }
            return try AndroidNetworkMetric.IpiActionStatisticReader.init(&[_]u8{});
        }
    };
    // fields
    net_devices: ?[]const ?AndroidNetworkMetric.NetDevice = null,
    net_rx_action: ?AndroidNetworkMetric.NetRxAction = null,
    retransmission_rate: f64 = 0.0,
    kfree_skb_rate: f64 = 0.0,
    net_tx_action: ?AndroidNetworkMetric.NetTxAction = null,
    ipi_action: ?AndroidNetworkMetric.IpiAction = null,
    pub fn calcProtobufSize(self: *const AndroidNetworkMetric) usize {
        var res: usize = 0;
        if (self.net_devices) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetricWire.NET_DEVICES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.net_rx_action) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetricWire.NET_RX_ACTION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.retransmission_rate != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetricWire.RETRANSMISSION_RATE_WIRE) + gremlin.sizes.sizeDouble(self.retransmission_rate);
        }
        if (self.kfree_skb_rate != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetricWire.KFREE_SKB_RATE_WIRE) + gremlin.sizes.sizeDouble(self.kfree_skb_rate);
        }
        if (self.net_tx_action) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetricWire.NET_TX_ACTION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ipi_action) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidNetworkMetricWire.IPI_ACTION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidNetworkMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidNetworkMetric, target: *gremlin.Writer) void {
        if (self.net_devices) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidNetworkMetricWire.NET_DEVICES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidNetworkMetricWire.NET_DEVICES_WIRE, 0);
                }
            }
        }
        if (self.net_rx_action) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidNetworkMetricWire.NET_RX_ACTION_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.retransmission_rate != 0.0) {
            target.appendFloat64(AndroidNetworkMetricWire.RETRANSMISSION_RATE_WIRE, self.retransmission_rate);
        }
        if (self.kfree_skb_rate != 0.0) {
            target.appendFloat64(AndroidNetworkMetricWire.KFREE_SKB_RATE_WIRE, self.kfree_skb_rate);
        }
        if (self.net_tx_action) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidNetworkMetricWire.NET_TX_ACTION_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ipi_action) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidNetworkMetricWire.IPI_ACTION_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const AndroidNetworkMetricReader = struct {
    buf: gremlin.Reader,
    _net_devices_offset: ?usize = null,
    _net_devices_last_offset: ?usize = null,
    _net_devices_cnt: usize = 0,
    _net_rx_action_buf: ?[]const u8 = null,
    _retransmission_rate: f64 = 0.0,
    _kfree_skb_rate: f64 = 0.0,
    _net_tx_action_buf: ?[]const u8 = null,
    _ipi_action_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!AndroidNetworkMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidNetworkMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidNetworkMetricWire.NET_DEVICES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._net_devices_offset == null) {
                        res._net_devices_offset = offset - result.size;
                    }
                    res._net_devices_last_offset = offset;
                    res._net_devices_cnt += 1;
                },
                AndroidNetworkMetricWire.NET_RX_ACTION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._net_rx_action_buf = result.value;
                },
                AndroidNetworkMetricWire.RETRANSMISSION_RATE_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._retransmission_rate = result.value;
                },
                AndroidNetworkMetricWire.KFREE_SKB_RATE_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._kfree_skb_rate = result.value;
                },
                AndroidNetworkMetricWire.NET_TX_ACTION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._net_tx_action_buf = result.value;
                },
                AndroidNetworkMetricWire.IPI_ACTION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ipi_action_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn netDevicesCount(self: *const AndroidNetworkMetricReader) usize {
        return self._net_devices_cnt;
    }
    pub fn netDevicesNext(self: *AndroidNetworkMetricReader) ?AndroidNetworkMetric.NetDeviceReader {
        if (self._net_devices_offset == null) return null;
        const current_offset = self._net_devices_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidNetworkMetric.NetDeviceReader.init(result.value) catch return null;
        if (self._net_devices_last_offset != null and current_offset >= self._net_devices_last_offset.?) {
            self._net_devices_offset = null;
            return msg;
        }
        if (self._net_devices_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._net_devices_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidNetworkMetricWire.NET_DEVICES_WIRE) {
                self._net_devices_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._net_devices_offset = null;
        return msg;
    }
    pub fn getNetRxAction(self: *const AndroidNetworkMetricReader) gremlin.Error!AndroidNetworkMetric.NetRxActionReader {
        if (self._net_rx_action_buf) |buf| {
            return try AndroidNetworkMetric.NetRxActionReader.init(buf);
        }
        return try AndroidNetworkMetric.NetRxActionReader.init(&[_]u8{});
    }
    pub inline fn getRetransmissionRate(self: *const AndroidNetworkMetricReader) f64 {
        return self._retransmission_rate;
    }
    pub inline fn getKfreeSkbRate(self: *const AndroidNetworkMetricReader) f64 {
        return self._kfree_skb_rate;
    }
    pub fn getNetTxAction(self: *const AndroidNetworkMetricReader) gremlin.Error!AndroidNetworkMetric.NetTxActionReader {
        if (self._net_tx_action_buf) |buf| {
            return try AndroidNetworkMetric.NetTxActionReader.init(buf);
        }
        return try AndroidNetworkMetric.NetTxActionReader.init(&[_]u8{});
    }
    pub fn getIpiAction(self: *const AndroidNetworkMetricReader) gremlin.Error!AndroidNetworkMetric.IpiActionReader {
        if (self._ipi_action_buf) |buf| {
            return try AndroidNetworkMetric.IpiActionReader.init(buf);
        }
        return try AndroidNetworkMetric.IpiActionReader.init(&[_]u8{});
    }
};
const AndroidPackageListWire = struct {
    const PACKAGES_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const AndroidPackageList = struct {
    // nested structs
    const PackageWire = struct {
        const PACKAGE_NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const UID_WIRE: gremlin.ProtoWireNumber = 2;
        const VERSION_CODE_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const Package = struct {
        // fields
        package_name: ?[]const u8 = null,
        uid: i64 = 0,
        version_code: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidPackageList.Package) usize {
            var res: usize = 0;
            if (self.package_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidPackageList.PackageWire.PACKAGE_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.uid != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidPackageList.PackageWire.UID_WIRE) + gremlin.sizes.sizeI64(self.uid);
            }
            if (self.version_code != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidPackageList.PackageWire.VERSION_CODE_WIRE) + gremlin.sizes.sizeI64(self.version_code);
            }
            return res;
        }
        pub fn encode(self: *const AndroidPackageList.Package, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidPackageList.Package, target: *gremlin.Writer) void {
            if (self.package_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidPackageList.PackageWire.PACKAGE_NAME_WIRE, v);
                }
            }
            if (self.uid != 0) {
                target.appendInt64(AndroidPackageList.PackageWire.UID_WIRE, self.uid);
            }
            if (self.version_code != 0) {
                target.appendInt64(AndroidPackageList.PackageWire.VERSION_CODE_WIRE, self.version_code);
            }
        }
    };
    pub const PackageReader = struct {
        buf: gremlin.Reader,
        _package_name: ?[]const u8 = null,
        _uid: i64 = 0,
        _version_code: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidPackageList.PackageReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidPackageList.PackageReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidPackageList.PackageWire.PACKAGE_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._package_name = result.value;
                    },
                    AndroidPackageList.PackageWire.UID_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._uid = result.value;
                    },
                    AndroidPackageList.PackageWire.VERSION_CODE_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._version_code = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getPackageName(self: *const AndroidPackageList.PackageReader) []const u8 {
            return self._package_name orelse &[_]u8{};
        }
        pub inline fn getUid(self: *const AndroidPackageList.PackageReader) i64 {
            return self._uid;
        }
        pub inline fn getVersionCode(self: *const AndroidPackageList.PackageReader) i64 {
            return self._version_code;
        }
    };
    // fields
    packages: ?[]const ?AndroidPackageList.Package = null,
    pub fn calcProtobufSize(self: *const AndroidPackageList) usize {
        var res: usize = 0;
        if (self.packages) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidPackageListWire.PACKAGES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidPackageList, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidPackageList, target: *gremlin.Writer) void {
        if (self.packages) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidPackageListWire.PACKAGES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidPackageListWire.PACKAGES_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidPackageListReader = struct {
    buf: gremlin.Reader,
    _packages_offset: ?usize = null,
    _packages_last_offset: ?usize = null,
    _packages_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidPackageListReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidPackageListReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidPackageListWire.PACKAGES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._packages_offset == null) {
                        res._packages_offset = offset - result.size;
                    }
                    res._packages_last_offset = offset;
                    res._packages_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn packagesCount(self: *const AndroidPackageListReader) usize {
        return self._packages_cnt;
    }
    pub fn packagesNext(self: *AndroidPackageListReader) ?AndroidPackageList.PackageReader {
        if (self._packages_offset == null) return null;
        const current_offset = self._packages_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidPackageList.PackageReader.init(result.value) catch return null;
        if (self._packages_last_offset != null and current_offset >= self._packages_last_offset.?) {
            self._packages_offset = null;
            return msg;
        }
        if (self._packages_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._packages_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidPackageListWire.PACKAGES_WIRE) {
                self._packages_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._packages_offset = null;
        return msg;
    }
};
const AndroidPowerRailsWire = struct {
    const POWER_RAILS_WIRE: gremlin.ProtoWireNumber = 1;
    const AVG_TOTAL_USED_POWER_MW_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const AndroidPowerRails = struct {
    // nested structs
    const EnergyDataWire = struct {
        const TIMESTAMP_MS_WIRE: gremlin.ProtoWireNumber = 1;
        const ENERGY_UWS_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const EnergyData = struct {
        // fields
        timestamp_ms: i64 = 0,
        energy_uws: f64 = 0.0,
        pub fn calcProtobufSize(self: *const AndroidPowerRails.EnergyData) usize {
            var res: usize = 0;
            if (self.timestamp_ms != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidPowerRails.EnergyDataWire.TIMESTAMP_MS_WIRE) + gremlin.sizes.sizeI64(self.timestamp_ms);
            }
            if (self.energy_uws != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidPowerRails.EnergyDataWire.ENERGY_UWS_WIRE) + gremlin.sizes.sizeDouble(self.energy_uws);
            }
            return res;
        }
        pub fn encode(self: *const AndroidPowerRails.EnergyData, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidPowerRails.EnergyData, target: *gremlin.Writer) void {
            if (self.timestamp_ms != 0) {
                target.appendInt64(AndroidPowerRails.EnergyDataWire.TIMESTAMP_MS_WIRE, self.timestamp_ms);
            }
            if (self.energy_uws != 0.0) {
                target.appendFloat64(AndroidPowerRails.EnergyDataWire.ENERGY_UWS_WIRE, self.energy_uws);
            }
        }
    };
    pub const EnergyDataReader = struct {
        buf: gremlin.Reader,
        _timestamp_ms: i64 = 0,
        _energy_uws: f64 = 0.0,
        pub fn init(src: []const u8) gremlin.Error!AndroidPowerRails.EnergyDataReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidPowerRails.EnergyDataReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidPowerRails.EnergyDataWire.TIMESTAMP_MS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._timestamp_ms = result.value;
                    },
                    AndroidPowerRails.EnergyDataWire.ENERGY_UWS_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._energy_uws = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getTimestampMs(self: *const AndroidPowerRails.EnergyDataReader) i64 {
            return self._timestamp_ms;
        }
        pub inline fn getEnergyUws(self: *const AndroidPowerRails.EnergyDataReader) f64 {
            return self._energy_uws;
        }
    };
    const PowerRailsWire = struct {
        const NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const ENERGY_DATA_WIRE: gremlin.ProtoWireNumber = 2;
        const AVG_USED_POWER_MW_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const PowerRails = struct {
        // fields
        name: ?[]const u8 = null,
        energy_data: ?[]const ?AndroidPowerRails.EnergyData = null,
        avg_used_power_mw: f64 = 0.0,
        pub fn calcProtobufSize(self: *const AndroidPowerRails.PowerRails) usize {
            var res: usize = 0;
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidPowerRails.PowerRailsWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.energy_data) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidPowerRails.PowerRailsWire.ENERGY_DATA_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.avg_used_power_mw != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidPowerRails.PowerRailsWire.AVG_USED_POWER_MW_WIRE) + gremlin.sizes.sizeDouble(self.avg_used_power_mw);
            }
            return res;
        }
        pub fn encode(self: *const AndroidPowerRails.PowerRails, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidPowerRails.PowerRails, target: *gremlin.Writer) void {
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidPowerRails.PowerRailsWire.NAME_WIRE, v);
                }
            }
            if (self.energy_data) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidPowerRails.PowerRailsWire.ENERGY_DATA_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidPowerRails.PowerRailsWire.ENERGY_DATA_WIRE, 0);
                    }
                }
            }
            if (self.avg_used_power_mw != 0.0) {
                target.appendFloat64(AndroidPowerRails.PowerRailsWire.AVG_USED_POWER_MW_WIRE, self.avg_used_power_mw);
            }
        }
    };
    pub const PowerRailsReader = struct {
        buf: gremlin.Reader,
        _name: ?[]const u8 = null,
        _energy_data_offset: ?usize = null,
        _energy_data_last_offset: ?usize = null,
        _energy_data_cnt: usize = 0,
        _avg_used_power_mw: f64 = 0.0,
        pub fn init(src: []const u8) gremlin.Error!AndroidPowerRails.PowerRailsReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidPowerRails.PowerRailsReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidPowerRails.PowerRailsWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    AndroidPowerRails.PowerRailsWire.ENERGY_DATA_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._energy_data_offset == null) {
                            res._energy_data_offset = offset - result.size;
                        }
                        res._energy_data_last_offset = offset;
                        res._energy_data_cnt += 1;
                    },
                    AndroidPowerRails.PowerRailsWire.AVG_USED_POWER_MW_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._avg_used_power_mw = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getName(self: *const AndroidPowerRails.PowerRailsReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub fn energyDataCount(self: *const AndroidPowerRails.PowerRailsReader) usize {
            return self._energy_data_cnt;
        }
        pub fn energyDataNext(self: *AndroidPowerRails.PowerRailsReader) ?AndroidPowerRails.EnergyDataReader {
            if (self._energy_data_offset == null) return null;
            const current_offset = self._energy_data_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidPowerRails.EnergyDataReader.init(result.value) catch return null;
            if (self._energy_data_last_offset != null and current_offset >= self._energy_data_last_offset.?) {
                self._energy_data_offset = null;
                return msg;
            }
            if (self._energy_data_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._energy_data_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidPowerRails.PowerRailsWire.ENERGY_DATA_WIRE) {
                    self._energy_data_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._energy_data_offset = null;
            return msg;
        }
        pub inline fn getAvgUsedPowerMw(self: *const AndroidPowerRails.PowerRailsReader) f64 {
            return self._avg_used_power_mw;
        }
    };
    // fields
    power_rails: ?[]const ?AndroidPowerRails.PowerRails = null,
    avg_total_used_power_mw: f64 = 0.0,
    pub fn calcProtobufSize(self: *const AndroidPowerRails) usize {
        var res: usize = 0;
        if (self.power_rails) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidPowerRailsWire.POWER_RAILS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.avg_total_used_power_mw != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidPowerRailsWire.AVG_TOTAL_USED_POWER_MW_WIRE) + gremlin.sizes.sizeDouble(self.avg_total_used_power_mw);
        }
        return res;
    }
    pub fn encode(self: *const AndroidPowerRails, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidPowerRails, target: *gremlin.Writer) void {
        if (self.power_rails) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidPowerRailsWire.POWER_RAILS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidPowerRailsWire.POWER_RAILS_WIRE, 0);
                }
            }
        }
        if (self.avg_total_used_power_mw != 0.0) {
            target.appendFloat64(AndroidPowerRailsWire.AVG_TOTAL_USED_POWER_MW_WIRE, self.avg_total_used_power_mw);
        }
    }
};
pub const AndroidPowerRailsReader = struct {
    buf: gremlin.Reader,
    _power_rails_offset: ?usize = null,
    _power_rails_last_offset: ?usize = null,
    _power_rails_cnt: usize = 0,
    _avg_total_used_power_mw: f64 = 0.0,
    pub fn init(src: []const u8) gremlin.Error!AndroidPowerRailsReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidPowerRailsReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidPowerRailsWire.POWER_RAILS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._power_rails_offset == null) {
                        res._power_rails_offset = offset - result.size;
                    }
                    res._power_rails_last_offset = offset;
                    res._power_rails_cnt += 1;
                },
                AndroidPowerRailsWire.AVG_TOTAL_USED_POWER_MW_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._avg_total_used_power_mw = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn powerRailsCount(self: *const AndroidPowerRailsReader) usize {
        return self._power_rails_cnt;
    }
    pub fn powerRailsNext(self: *AndroidPowerRailsReader) ?AndroidPowerRails.PowerRailsReader {
        if (self._power_rails_offset == null) return null;
        const current_offset = self._power_rails_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidPowerRails.PowerRailsReader.init(result.value) catch return null;
        if (self._power_rails_last_offset != null and current_offset >= self._power_rails_last_offset.?) {
            self._power_rails_offset = null;
            return msg;
        }
        if (self._power_rails_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._power_rails_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidPowerRailsWire.POWER_RAILS_WIRE) {
                self._power_rails_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._power_rails_offset = null;
        return msg;
    }
    pub inline fn getAvgTotalUsedPowerMw(self: *const AndroidPowerRailsReader) f64 {
        return self._avg_total_used_power_mw;
    }
};
const ProfilerSmapsWire = struct {
    const INSTANCE_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const ProfilerSmaps = struct {
    // nested structs
    const MappingWire = struct {
        const PATH_WIRE: gremlin.ProtoWireNumber = 1;
        const SIZE_KB_WIRE: gremlin.ProtoWireNumber = 2;
        const PRIVATE_DIRTY_KB_WIRE: gremlin.ProtoWireNumber = 3;
        const SWAP_KB_WIRE: gremlin.ProtoWireNumber = 4;
    };
    pub const Mapping = struct {
        // fields
        path: ?[]const u8 = null,
        size_kb: i32 = 0,
        private_dirty_kb: i32 = 0,
        swap_kb: i32 = 0,
        pub fn calcProtobufSize(self: *const ProfilerSmaps.Mapping) usize {
            var res: usize = 0;
            if (self.path) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(ProfilerSmaps.MappingWire.PATH_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.size_kb != 0) {
                res += gremlin.sizes.sizeWireNumber(ProfilerSmaps.MappingWire.SIZE_KB_WIRE) + gremlin.sizes.sizeI32(self.size_kb);
            }
            if (self.private_dirty_kb != 0) {
                res += gremlin.sizes.sizeWireNumber(ProfilerSmaps.MappingWire.PRIVATE_DIRTY_KB_WIRE) + gremlin.sizes.sizeI32(self.private_dirty_kb);
            }
            if (self.swap_kb != 0) {
                res += gremlin.sizes.sizeWireNumber(ProfilerSmaps.MappingWire.SWAP_KB_WIRE) + gremlin.sizes.sizeI32(self.swap_kb);
            }
            return res;
        }
        pub fn encode(self: *const ProfilerSmaps.Mapping, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const ProfilerSmaps.Mapping, target: *gremlin.Writer) void {
            if (self.path) |v| {
                if (v.len > 0) {
                    target.appendBytes(ProfilerSmaps.MappingWire.PATH_WIRE, v);
                }
            }
            if (self.size_kb != 0) {
                target.appendInt32(ProfilerSmaps.MappingWire.SIZE_KB_WIRE, self.size_kb);
            }
            if (self.private_dirty_kb != 0) {
                target.appendInt32(ProfilerSmaps.MappingWire.PRIVATE_DIRTY_KB_WIRE, self.private_dirty_kb);
            }
            if (self.swap_kb != 0) {
                target.appendInt32(ProfilerSmaps.MappingWire.SWAP_KB_WIRE, self.swap_kb);
            }
        }
    };
    pub const MappingReader = struct {
        buf: gremlin.Reader,
        _path: ?[]const u8 = null,
        _size_kb: i32 = 0,
        _private_dirty_kb: i32 = 0,
        _swap_kb: i32 = 0,
        pub fn init(src: []const u8) gremlin.Error!ProfilerSmaps.MappingReader {
            const buf = gremlin.Reader.init(src);
            var res = ProfilerSmaps.MappingReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    ProfilerSmaps.MappingWire.PATH_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._path = result.value;
                    },
                    ProfilerSmaps.MappingWire.SIZE_KB_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._size_kb = result.value;
                    },
                    ProfilerSmaps.MappingWire.PRIVATE_DIRTY_KB_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._private_dirty_kb = result.value;
                    },
                    ProfilerSmaps.MappingWire.SWAP_KB_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._swap_kb = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getPath(self: *const ProfilerSmaps.MappingReader) []const u8 {
            return self._path orelse &[_]u8{};
        }
        pub inline fn getSizeKb(self: *const ProfilerSmaps.MappingReader) i32 {
            return self._size_kb;
        }
        pub inline fn getPrivateDirtyKb(self: *const ProfilerSmaps.MappingReader) i32 {
            return self._private_dirty_kb;
        }
        pub inline fn getSwapKb(self: *const ProfilerSmaps.MappingReader) i32 {
            return self._swap_kb;
        }
    };
    const InstanceWire = struct {
        const PROCESS_WIRE: gremlin.ProtoWireNumber = 1;
        const MAPPINGS_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const Instance = struct {
        // fields
        process: ?AndroidProcessMetadata = null,
        mappings: ?[]const ?ProfilerSmaps.Mapping = null,
        pub fn calcProtobufSize(self: *const ProfilerSmaps.Instance) usize {
            var res: usize = 0;
            if (self.process) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(ProfilerSmaps.InstanceWire.PROCESS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.mappings) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(ProfilerSmaps.InstanceWire.MAPPINGS_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const ProfilerSmaps.Instance, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const ProfilerSmaps.Instance, target: *gremlin.Writer) void {
            if (self.process) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(ProfilerSmaps.InstanceWire.PROCESS_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.mappings) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(ProfilerSmaps.InstanceWire.MAPPINGS_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(ProfilerSmaps.InstanceWire.MAPPINGS_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const InstanceReader = struct {
        buf: gremlin.Reader,
        _process_buf: ?[]const u8 = null,
        _mappings_offset: ?usize = null,
        _mappings_last_offset: ?usize = null,
        _mappings_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!ProfilerSmaps.InstanceReader {
            const buf = gremlin.Reader.init(src);
            var res = ProfilerSmaps.InstanceReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    ProfilerSmaps.InstanceWire.PROCESS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._process_buf = result.value;
                    },
                    ProfilerSmaps.InstanceWire.MAPPINGS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._mappings_offset == null) {
                            res._mappings_offset = offset - result.size;
                        }
                        res._mappings_last_offset = offset;
                        res._mappings_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn getProcess(self: *const ProfilerSmaps.InstanceReader) gremlin.Error!AndroidProcessMetadataReader {
            if (self._process_buf) |buf| {
                return try AndroidProcessMetadataReader.init(buf);
            }
            return try AndroidProcessMetadataReader.init(&[_]u8{});
        }
        pub fn mappingsCount(self: *const ProfilerSmaps.InstanceReader) usize {
            return self._mappings_cnt;
        }
        pub fn mappingsNext(self: *ProfilerSmaps.InstanceReader) ?ProfilerSmaps.MappingReader {
            if (self._mappings_offset == null) return null;
            const current_offset = self._mappings_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = ProfilerSmaps.MappingReader.init(result.value) catch return null;
            if (self._mappings_last_offset != null and current_offset >= self._mappings_last_offset.?) {
                self._mappings_offset = null;
                return msg;
            }
            if (self._mappings_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._mappings_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == ProfilerSmaps.InstanceWire.MAPPINGS_WIRE) {
                    self._mappings_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._mappings_offset = null;
            return msg;
        }
    };
    // fields
    instance: ?[]const ?ProfilerSmaps.Instance = null,
    pub fn calcProtobufSize(self: *const ProfilerSmaps) usize {
        var res: usize = 0;
        if (self.instance) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ProfilerSmapsWire.INSTANCE_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const ProfilerSmaps, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ProfilerSmaps, target: *gremlin.Writer) void {
        if (self.instance) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(ProfilerSmapsWire.INSTANCE_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(ProfilerSmapsWire.INSTANCE_WIRE, 0);
                }
            }
        }
    }
};
pub const ProfilerSmapsReader = struct {
    buf: gremlin.Reader,
    _instance_offset: ?usize = null,
    _instance_last_offset: ?usize = null,
    _instance_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!ProfilerSmapsReader {
        const buf = gremlin.Reader.init(src);
        var res = ProfilerSmapsReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ProfilerSmapsWire.INSTANCE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._instance_offset == null) {
                        res._instance_offset = offset - result.size;
                    }
                    res._instance_last_offset = offset;
                    res._instance_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn instanceCount(self: *const ProfilerSmapsReader) usize {
        return self._instance_cnt;
    }
    pub fn instanceNext(self: *ProfilerSmapsReader) ?ProfilerSmaps.InstanceReader {
        if (self._instance_offset == null) return null;
        const current_offset = self._instance_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = ProfilerSmaps.InstanceReader.init(result.value) catch return null;
        if (self._instance_last_offset != null and current_offset >= self._instance_last_offset.?) {
            self._instance_offset = null;
            return msg;
        }
        if (self._instance_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._instance_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ProfilerSmapsWire.INSTANCE_WIRE) {
                self._instance_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._instance_offset = null;
        return msg;
    }
};
const AndroidRtRuntimeMetricWire = struct {
    const MAX_RUNTIME_WIRE: gremlin.ProtoWireNumber = 1;
    const OVER_5MS_COUNT_WIRE: gremlin.ProtoWireNumber = 2;
    const LONGEST_RT_SLICES_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const AndroidRtRuntimeMetric = struct {
    // nested structs
    const RtSliceWire = struct {
        const TNAME_WIRE: gremlin.ProtoWireNumber = 1;
        const TS_WIRE: gremlin.ProtoWireNumber = 2;
        const DUR_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const RtSlice = struct {
        // fields
        tname: ?[]const u8 = null,
        ts: i64 = 0,
        dur: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidRtRuntimeMetric.RtSlice) usize {
            var res: usize = 0;
            if (self.tname) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidRtRuntimeMetric.RtSliceWire.TNAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.ts != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidRtRuntimeMetric.RtSliceWire.TS_WIRE) + gremlin.sizes.sizeI64(self.ts);
            }
            if (self.dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidRtRuntimeMetric.RtSliceWire.DUR_WIRE) + gremlin.sizes.sizeI64(self.dur);
            }
            return res;
        }
        pub fn encode(self: *const AndroidRtRuntimeMetric.RtSlice, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidRtRuntimeMetric.RtSlice, target: *gremlin.Writer) void {
            if (self.tname) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidRtRuntimeMetric.RtSliceWire.TNAME_WIRE, v);
                }
            }
            if (self.ts != 0) {
                target.appendInt64(AndroidRtRuntimeMetric.RtSliceWire.TS_WIRE, self.ts);
            }
            if (self.dur != 0) {
                target.appendInt64(AndroidRtRuntimeMetric.RtSliceWire.DUR_WIRE, self.dur);
            }
        }
    };
    pub const RtSliceReader = struct {
        buf: gremlin.Reader,
        _tname: ?[]const u8 = null,
        _ts: i64 = 0,
        _dur: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidRtRuntimeMetric.RtSliceReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidRtRuntimeMetric.RtSliceReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidRtRuntimeMetric.RtSliceWire.TNAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._tname = result.value;
                    },
                    AndroidRtRuntimeMetric.RtSliceWire.TS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._ts = result.value;
                    },
                    AndroidRtRuntimeMetric.RtSliceWire.DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._dur = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getTname(self: *const AndroidRtRuntimeMetric.RtSliceReader) []const u8 {
            return self._tname orelse &[_]u8{};
        }
        pub inline fn getTs(self: *const AndroidRtRuntimeMetric.RtSliceReader) i64 {
            return self._ts;
        }
        pub inline fn getDur(self: *const AndroidRtRuntimeMetric.RtSliceReader) i64 {
            return self._dur;
        }
    };
    // fields
    max_runtime: i64 = 0,
    over_5ms_count: i64 = 0,
    longest_rt_slices: ?[]const ?AndroidRtRuntimeMetric.RtSlice = null,
    pub fn calcProtobufSize(self: *const AndroidRtRuntimeMetric) usize {
        var res: usize = 0;
        if (self.max_runtime != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidRtRuntimeMetricWire.MAX_RUNTIME_WIRE) + gremlin.sizes.sizeI64(self.max_runtime);
        }
        if (self.over_5ms_count != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidRtRuntimeMetricWire.OVER_5MS_COUNT_WIRE) + gremlin.sizes.sizeI64(self.over_5ms_count);
        }
        if (self.longest_rt_slices) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidRtRuntimeMetricWire.LONGEST_RT_SLICES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidRtRuntimeMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidRtRuntimeMetric, target: *gremlin.Writer) void {
        if (self.max_runtime != 0) {
            target.appendInt64(AndroidRtRuntimeMetricWire.MAX_RUNTIME_WIRE, self.max_runtime);
        }
        if (self.over_5ms_count != 0) {
            target.appendInt64(AndroidRtRuntimeMetricWire.OVER_5MS_COUNT_WIRE, self.over_5ms_count);
        }
        if (self.longest_rt_slices) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidRtRuntimeMetricWire.LONGEST_RT_SLICES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidRtRuntimeMetricWire.LONGEST_RT_SLICES_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidRtRuntimeMetricReader = struct {
    buf: gremlin.Reader,
    _max_runtime: i64 = 0,
    _over_5ms_count: i64 = 0,
    _longest_rt_slices_offset: ?usize = null,
    _longest_rt_slices_last_offset: ?usize = null,
    _longest_rt_slices_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidRtRuntimeMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidRtRuntimeMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidRtRuntimeMetricWire.MAX_RUNTIME_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._max_runtime = result.value;
                },
                AndroidRtRuntimeMetricWire.OVER_5MS_COUNT_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._over_5ms_count = result.value;
                },
                AndroidRtRuntimeMetricWire.LONGEST_RT_SLICES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._longest_rt_slices_offset == null) {
                        res._longest_rt_slices_offset = offset - result.size;
                    }
                    res._longest_rt_slices_last_offset = offset;
                    res._longest_rt_slices_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getMaxRuntime(self: *const AndroidRtRuntimeMetricReader) i64 {
        return self._max_runtime;
    }
    pub inline fn getOver5msCount(self: *const AndroidRtRuntimeMetricReader) i64 {
        return self._over_5ms_count;
    }
    pub fn longestRtSlicesCount(self: *const AndroidRtRuntimeMetricReader) usize {
        return self._longest_rt_slices_cnt;
    }
    pub fn longestRtSlicesNext(self: *AndroidRtRuntimeMetricReader) ?AndroidRtRuntimeMetric.RtSliceReader {
        if (self._longest_rt_slices_offset == null) return null;
        const current_offset = self._longest_rt_slices_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidRtRuntimeMetric.RtSliceReader.init(result.value) catch return null;
        if (self._longest_rt_slices_last_offset != null and current_offset >= self._longest_rt_slices_last_offset.?) {
            self._longest_rt_slices_offset = null;
            return msg;
        }
        if (self._longest_rt_slices_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._longest_rt_slices_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidRtRuntimeMetricWire.LONGEST_RT_SLICES_WIRE) {
                self._longest_rt_slices_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._longest_rt_slices_offset = null;
        return msg;
    }
};
const AndroidSimpleperfMetricWire = struct {
    const URGENT_RATIO_WIRE: gremlin.ProtoWireNumber = 1;
    const EVENTS_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const AndroidSimpleperfMetric = struct {
    // nested structs
    const PerfEventMetricWire = struct {
        const NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const PROCESSES_WIRE: gremlin.ProtoWireNumber = 2;
        const TOTAL_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const PerfEventMetric = struct {
        // nested structs
        const ThreadWire = struct {
            const TID_WIRE: gremlin.ProtoWireNumber = 1;
            const NAME_WIRE: gremlin.ProtoWireNumber = 2;
            const CPU_WIRE: gremlin.ProtoWireNumber = 3;
            const TOTAL_WIRE: gremlin.ProtoWireNumber = 4;
        };
        pub const Thread = struct {
            // fields
            tid: i32 = 0,
            name: ?[]const u8 = null,
            cpu: i32 = 0,
            total: f64 = 0.0,
            pub fn calcProtobufSize(self: *const AndroidSimpleperfMetric.PerfEventMetric.Thread) usize {
                var res: usize = 0;
                if (self.tid != 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidSimpleperfMetric.PerfEventMetric.ThreadWire.TID_WIRE) + gremlin.sizes.sizeI32(self.tid);
                }
                if (self.name) |v| {
                    if (v.len > 0) {
                        res += gremlin.sizes.sizeWireNumber(AndroidSimpleperfMetric.PerfEventMetric.ThreadWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                    }
                }
                if (self.cpu != 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidSimpleperfMetric.PerfEventMetric.ThreadWire.CPU_WIRE) + gremlin.sizes.sizeI32(self.cpu);
                }
                if (self.total != 0.0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidSimpleperfMetric.PerfEventMetric.ThreadWire.TOTAL_WIRE) + gremlin.sizes.sizeDouble(self.total);
                }
                return res;
            }
            pub fn encode(self: *const AndroidSimpleperfMetric.PerfEventMetric.Thread, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const AndroidSimpleperfMetric.PerfEventMetric.Thread, target: *gremlin.Writer) void {
                if (self.tid != 0) {
                    target.appendInt32(AndroidSimpleperfMetric.PerfEventMetric.ThreadWire.TID_WIRE, self.tid);
                }
                if (self.name) |v| {
                    if (v.len > 0) {
                        target.appendBytes(AndroidSimpleperfMetric.PerfEventMetric.ThreadWire.NAME_WIRE, v);
                    }
                }
                if (self.cpu != 0) {
                    target.appendInt32(AndroidSimpleperfMetric.PerfEventMetric.ThreadWire.CPU_WIRE, self.cpu);
                }
                if (self.total != 0.0) {
                    target.appendFloat64(AndroidSimpleperfMetric.PerfEventMetric.ThreadWire.TOTAL_WIRE, self.total);
                }
            }
        };
        pub const ThreadReader = struct {
            buf: gremlin.Reader,
            _tid: i32 = 0,
            _name: ?[]const u8 = null,
            _cpu: i32 = 0,
            _total: f64 = 0.0,
            pub fn init(src: []const u8) gremlin.Error!AndroidSimpleperfMetric.PerfEventMetric.ThreadReader {
                const buf = gremlin.Reader.init(src);
                var res = AndroidSimpleperfMetric.PerfEventMetric.ThreadReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        AndroidSimpleperfMetric.PerfEventMetric.ThreadWire.TID_WIRE => {
                            const result = try buf.readInt32(offset);
                            offset += result.size;
                            res._tid = result.value;
                        },
                        AndroidSimpleperfMetric.PerfEventMetric.ThreadWire.NAME_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._name = result.value;
                        },
                        AndroidSimpleperfMetric.PerfEventMetric.ThreadWire.CPU_WIRE => {
                            const result = try buf.readInt32(offset);
                            offset += result.size;
                            res._cpu = result.value;
                        },
                        AndroidSimpleperfMetric.PerfEventMetric.ThreadWire.TOTAL_WIRE => {
                            const result = try buf.readFloat64(offset);
                            offset += result.size;
                            res._total = result.value;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub inline fn getTid(self: *const AndroidSimpleperfMetric.PerfEventMetric.ThreadReader) i32 {
                return self._tid;
            }
            pub inline fn getName(self: *const AndroidSimpleperfMetric.PerfEventMetric.ThreadReader) []const u8 {
                return self._name orelse &[_]u8{};
            }
            pub inline fn getCpu(self: *const AndroidSimpleperfMetric.PerfEventMetric.ThreadReader) i32 {
                return self._cpu;
            }
            pub inline fn getTotal(self: *const AndroidSimpleperfMetric.PerfEventMetric.ThreadReader) f64 {
                return self._total;
            }
        };
        const ProcessWire = struct {
            const PID_WIRE: gremlin.ProtoWireNumber = 1;
            const NAME_WIRE: gremlin.ProtoWireNumber = 2;
            const THREADS_WIRE: gremlin.ProtoWireNumber = 3;
            const TOTAL_WIRE: gremlin.ProtoWireNumber = 4;
        };
        pub const Process = struct {
            // fields
            pid: i32 = 0,
            name: ?[]const u8 = null,
            threads: ?[]const ?AndroidSimpleperfMetric.PerfEventMetric.Thread = null,
            total: f64 = 0.0,
            pub fn calcProtobufSize(self: *const AndroidSimpleperfMetric.PerfEventMetric.Process) usize {
                var res: usize = 0;
                if (self.pid != 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidSimpleperfMetric.PerfEventMetric.ProcessWire.PID_WIRE) + gremlin.sizes.sizeI32(self.pid);
                }
                if (self.name) |v| {
                    if (v.len > 0) {
                        res += gremlin.sizes.sizeWireNumber(AndroidSimpleperfMetric.PerfEventMetric.ProcessWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                    }
                }
                if (self.threads) |arr| {
                    for (arr) |maybe_v| {
                        res += gremlin.sizes.sizeWireNumber(AndroidSimpleperfMetric.PerfEventMetric.ProcessWire.THREADS_WIRE);
                        if (maybe_v) |v| {
                            const size = v.calcProtobufSize();
                            res += gremlin.sizes.sizeUsize(size) + size;
                        } else {
                            res += gremlin.sizes.sizeUsize(0);
                        }
                    }
                }
                if (self.total != 0.0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidSimpleperfMetric.PerfEventMetric.ProcessWire.TOTAL_WIRE) + gremlin.sizes.sizeDouble(self.total);
                }
                return res;
            }
            pub fn encode(self: *const AndroidSimpleperfMetric.PerfEventMetric.Process, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const AndroidSimpleperfMetric.PerfEventMetric.Process, target: *gremlin.Writer) void {
                if (self.pid != 0) {
                    target.appendInt32(AndroidSimpleperfMetric.PerfEventMetric.ProcessWire.PID_WIRE, self.pid);
                }
                if (self.name) |v| {
                    if (v.len > 0) {
                        target.appendBytes(AndroidSimpleperfMetric.PerfEventMetric.ProcessWire.NAME_WIRE, v);
                    }
                }
                if (self.threads) |arr| {
                    for (arr) |maybe_v| {
                        if (maybe_v) |v| {
                            const size = v.calcProtobufSize();
                            target.appendBytesTag(AndroidSimpleperfMetric.PerfEventMetric.ProcessWire.THREADS_WIRE, size);
                            v.encodeTo(target);
                        } else {
                            target.appendBytesTag(AndroidSimpleperfMetric.PerfEventMetric.ProcessWire.THREADS_WIRE, 0);
                        }
                    }
                }
                if (self.total != 0.0) {
                    target.appendFloat64(AndroidSimpleperfMetric.PerfEventMetric.ProcessWire.TOTAL_WIRE, self.total);
                }
            }
        };
        pub const ProcessReader = struct {
            buf: gremlin.Reader,
            _pid: i32 = 0,
            _name: ?[]const u8 = null,
            _threads_offset: ?usize = null,
            _threads_last_offset: ?usize = null,
            _threads_cnt: usize = 0,
            _total: f64 = 0.0,
            pub fn init(src: []const u8) gremlin.Error!AndroidSimpleperfMetric.PerfEventMetric.ProcessReader {
                const buf = gremlin.Reader.init(src);
                var res = AndroidSimpleperfMetric.PerfEventMetric.ProcessReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        AndroidSimpleperfMetric.PerfEventMetric.ProcessWire.PID_WIRE => {
                            const result = try buf.readInt32(offset);
                            offset += result.size;
                            res._pid = result.value;
                        },
                        AndroidSimpleperfMetric.PerfEventMetric.ProcessWire.NAME_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._name = result.value;
                        },
                        AndroidSimpleperfMetric.PerfEventMetric.ProcessWire.THREADS_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            if (res._threads_offset == null) {
                                res._threads_offset = offset - result.size;
                            }
                            res._threads_last_offset = offset;
                            res._threads_cnt += 1;
                        },
                        AndroidSimpleperfMetric.PerfEventMetric.ProcessWire.TOTAL_WIRE => {
                            const result = try buf.readFloat64(offset);
                            offset += result.size;
                            res._total = result.value;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub inline fn getPid(self: *const AndroidSimpleperfMetric.PerfEventMetric.ProcessReader) i32 {
                return self._pid;
            }
            pub inline fn getName(self: *const AndroidSimpleperfMetric.PerfEventMetric.ProcessReader) []const u8 {
                return self._name orelse &[_]u8{};
            }
            pub fn threadsCount(self: *const AndroidSimpleperfMetric.PerfEventMetric.ProcessReader) usize {
                return self._threads_cnt;
            }
            pub fn threadsNext(self: *AndroidSimpleperfMetric.PerfEventMetric.ProcessReader) ?AndroidSimpleperfMetric.PerfEventMetric.ThreadReader {
                if (self._threads_offset == null) return null;
                const current_offset = self._threads_offset.?;
                const result = self.buf.readBytes(current_offset) catch return null;
                const msg = AndroidSimpleperfMetric.PerfEventMetric.ThreadReader.init(result.value) catch return null;
                if (self._threads_last_offset != null and current_offset >= self._threads_last_offset.?) {
                    self._threads_offset = null;
                    return msg;
                }
                if (self._threads_last_offset == null) unreachable;
                var next_offset = current_offset + result.size;
                const max_offset = self._threads_last_offset.?;
                while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                    const tag = self.buf.readTagAt(next_offset) catch break;
                    next_offset += tag.size;
                    if (tag.number == AndroidSimpleperfMetric.PerfEventMetric.ProcessWire.THREADS_WIRE) {
                        self._threads_offset = next_offset;
                        return msg;
                    } else {
                        next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                    }
                }
                self._threads_offset = null;
                return msg;
            }
            pub inline fn getTotal(self: *const AndroidSimpleperfMetric.PerfEventMetric.ProcessReader) f64 {
                return self._total;
            }
        };
        // fields
        name: ?[]const u8 = null,
        processes: ?[]const ?AndroidSimpleperfMetric.PerfEventMetric.Process = null,
        total: f64 = 0.0,
        pub fn calcProtobufSize(self: *const AndroidSimpleperfMetric.PerfEventMetric) usize {
            var res: usize = 0;
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidSimpleperfMetric.PerfEventMetricWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.processes) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidSimpleperfMetric.PerfEventMetricWire.PROCESSES_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.total != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidSimpleperfMetric.PerfEventMetricWire.TOTAL_WIRE) + gremlin.sizes.sizeDouble(self.total);
            }
            return res;
        }
        pub fn encode(self: *const AndroidSimpleperfMetric.PerfEventMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidSimpleperfMetric.PerfEventMetric, target: *gremlin.Writer) void {
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidSimpleperfMetric.PerfEventMetricWire.NAME_WIRE, v);
                }
            }
            if (self.processes) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidSimpleperfMetric.PerfEventMetricWire.PROCESSES_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidSimpleperfMetric.PerfEventMetricWire.PROCESSES_WIRE, 0);
                    }
                }
            }
            if (self.total != 0.0) {
                target.appendFloat64(AndroidSimpleperfMetric.PerfEventMetricWire.TOTAL_WIRE, self.total);
            }
        }
    };
    pub const PerfEventMetricReader = struct {
        buf: gremlin.Reader,
        _name: ?[]const u8 = null,
        _processes_offset: ?usize = null,
        _processes_last_offset: ?usize = null,
        _processes_cnt: usize = 0,
        _total: f64 = 0.0,
        pub fn init(src: []const u8) gremlin.Error!AndroidSimpleperfMetric.PerfEventMetricReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidSimpleperfMetric.PerfEventMetricReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidSimpleperfMetric.PerfEventMetricWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    AndroidSimpleperfMetric.PerfEventMetricWire.PROCESSES_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._processes_offset == null) {
                            res._processes_offset = offset - result.size;
                        }
                        res._processes_last_offset = offset;
                        res._processes_cnt += 1;
                    },
                    AndroidSimpleperfMetric.PerfEventMetricWire.TOTAL_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._total = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getName(self: *const AndroidSimpleperfMetric.PerfEventMetricReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub fn processesCount(self: *const AndroidSimpleperfMetric.PerfEventMetricReader) usize {
            return self._processes_cnt;
        }
        pub fn processesNext(self: *AndroidSimpleperfMetric.PerfEventMetricReader) ?AndroidSimpleperfMetric.PerfEventMetric.ProcessReader {
            if (self._processes_offset == null) return null;
            const current_offset = self._processes_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidSimpleperfMetric.PerfEventMetric.ProcessReader.init(result.value) catch return null;
            if (self._processes_last_offset != null and current_offset >= self._processes_last_offset.?) {
                self._processes_offset = null;
                return msg;
            }
            if (self._processes_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._processes_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidSimpleperfMetric.PerfEventMetricWire.PROCESSES_WIRE) {
                    self._processes_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._processes_offset = null;
            return msg;
        }
        pub inline fn getTotal(self: *const AndroidSimpleperfMetric.PerfEventMetricReader) f64 {
            return self._total;
        }
    };
    // fields
    urgent_ratio: f64 = 0.0,
    events: ?[]const ?AndroidSimpleperfMetric.PerfEventMetric = null,
    pub fn calcProtobufSize(self: *const AndroidSimpleperfMetric) usize {
        var res: usize = 0;
        if (self.urgent_ratio != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidSimpleperfMetricWire.URGENT_RATIO_WIRE) + gremlin.sizes.sizeDouble(self.urgent_ratio);
        }
        if (self.events) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidSimpleperfMetricWire.EVENTS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidSimpleperfMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidSimpleperfMetric, target: *gremlin.Writer) void {
        if (self.urgent_ratio != 0.0) {
            target.appendFloat64(AndroidSimpleperfMetricWire.URGENT_RATIO_WIRE, self.urgent_ratio);
        }
        if (self.events) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidSimpleperfMetricWire.EVENTS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidSimpleperfMetricWire.EVENTS_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidSimpleperfMetricReader = struct {
    buf: gremlin.Reader,
    _urgent_ratio: f64 = 0.0,
    _events_offset: ?usize = null,
    _events_last_offset: ?usize = null,
    _events_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidSimpleperfMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidSimpleperfMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidSimpleperfMetricWire.URGENT_RATIO_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._urgent_ratio = result.value;
                },
                AndroidSimpleperfMetricWire.EVENTS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._events_offset == null) {
                        res._events_offset = offset - result.size;
                    }
                    res._events_last_offset = offset;
                    res._events_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getUrgentRatio(self: *const AndroidSimpleperfMetricReader) f64 {
        return self._urgent_ratio;
    }
    pub fn eventsCount(self: *const AndroidSimpleperfMetricReader) usize {
        return self._events_cnt;
    }
    pub fn eventsNext(self: *AndroidSimpleperfMetricReader) ?AndroidSimpleperfMetric.PerfEventMetricReader {
        if (self._events_offset == null) return null;
        const current_offset = self._events_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidSimpleperfMetric.PerfEventMetricReader.init(result.value) catch return null;
        if (self._events_last_offset != null and current_offset >= self._events_last_offset.?) {
            self._events_offset = null;
            return msg;
        }
        if (self._events_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._events_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidSimpleperfMetricWire.EVENTS_WIRE) {
                self._events_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._events_offset = null;
        return msg;
    }
};
const AndroidStartupMetricWire = struct {
    const STARTUP_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const AndroidStartupMetric = struct {
    // nested structs
    const TaskStateBreakdownWire = struct {
        const RUNNING_DUR_NS_WIRE: gremlin.ProtoWireNumber = 1;
        const RUNNABLE_DUR_NS_WIRE: gremlin.ProtoWireNumber = 2;
        const UNINTERRUPTIBLE_SLEEP_DUR_NS_WIRE: gremlin.ProtoWireNumber = 3;
        const INTERRUPTIBLE_SLEEP_DUR_NS_WIRE: gremlin.ProtoWireNumber = 4;
        const UNINTERRUPTIBLE_IO_SLEEP_DUR_NS_WIRE: gremlin.ProtoWireNumber = 5;
        const UNINTERRUPTIBLE_NON_IO_SLEEP_DUR_NS_WIRE: gremlin.ProtoWireNumber = 6;
    };
    pub const TaskStateBreakdown = struct {
        // fields
        running_dur_ns: i64 = 0,
        runnable_dur_ns: i64 = 0,
        uninterruptible_sleep_dur_ns: i64 = 0,
        interruptible_sleep_dur_ns: i64 = 0,
        uninterruptible_io_sleep_dur_ns: i64 = 0,
        uninterruptible_non_io_sleep_dur_ns: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidStartupMetric.TaskStateBreakdown) usize {
            var res: usize = 0;
            if (self.running_dur_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.TaskStateBreakdownWire.RUNNING_DUR_NS_WIRE) + gremlin.sizes.sizeI64(self.running_dur_ns);
            }
            if (self.runnable_dur_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.TaskStateBreakdownWire.RUNNABLE_DUR_NS_WIRE) + gremlin.sizes.sizeI64(self.runnable_dur_ns);
            }
            if (self.uninterruptible_sleep_dur_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.TaskStateBreakdownWire.UNINTERRUPTIBLE_SLEEP_DUR_NS_WIRE) + gremlin.sizes.sizeI64(self.uninterruptible_sleep_dur_ns);
            }
            if (self.interruptible_sleep_dur_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.TaskStateBreakdownWire.INTERRUPTIBLE_SLEEP_DUR_NS_WIRE) + gremlin.sizes.sizeI64(self.interruptible_sleep_dur_ns);
            }
            if (self.uninterruptible_io_sleep_dur_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.TaskStateBreakdownWire.UNINTERRUPTIBLE_IO_SLEEP_DUR_NS_WIRE) + gremlin.sizes.sizeI64(self.uninterruptible_io_sleep_dur_ns);
            }
            if (self.uninterruptible_non_io_sleep_dur_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.TaskStateBreakdownWire.UNINTERRUPTIBLE_NON_IO_SLEEP_DUR_NS_WIRE) + gremlin.sizes.sizeI64(self.uninterruptible_non_io_sleep_dur_ns);
            }
            return res;
        }
        pub fn encode(self: *const AndroidStartupMetric.TaskStateBreakdown, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidStartupMetric.TaskStateBreakdown, target: *gremlin.Writer) void {
            if (self.running_dur_ns != 0) {
                target.appendInt64(AndroidStartupMetric.TaskStateBreakdownWire.RUNNING_DUR_NS_WIRE, self.running_dur_ns);
            }
            if (self.runnable_dur_ns != 0) {
                target.appendInt64(AndroidStartupMetric.TaskStateBreakdownWire.RUNNABLE_DUR_NS_WIRE, self.runnable_dur_ns);
            }
            if (self.uninterruptible_sleep_dur_ns != 0) {
                target.appendInt64(AndroidStartupMetric.TaskStateBreakdownWire.UNINTERRUPTIBLE_SLEEP_DUR_NS_WIRE, self.uninterruptible_sleep_dur_ns);
            }
            if (self.interruptible_sleep_dur_ns != 0) {
                target.appendInt64(AndroidStartupMetric.TaskStateBreakdownWire.INTERRUPTIBLE_SLEEP_DUR_NS_WIRE, self.interruptible_sleep_dur_ns);
            }
            if (self.uninterruptible_io_sleep_dur_ns != 0) {
                target.appendInt64(AndroidStartupMetric.TaskStateBreakdownWire.UNINTERRUPTIBLE_IO_SLEEP_DUR_NS_WIRE, self.uninterruptible_io_sleep_dur_ns);
            }
            if (self.uninterruptible_non_io_sleep_dur_ns != 0) {
                target.appendInt64(AndroidStartupMetric.TaskStateBreakdownWire.UNINTERRUPTIBLE_NON_IO_SLEEP_DUR_NS_WIRE, self.uninterruptible_non_io_sleep_dur_ns);
            }
        }
    };
    pub const TaskStateBreakdownReader = struct {
        buf: gremlin.Reader,
        _running_dur_ns: i64 = 0,
        _runnable_dur_ns: i64 = 0,
        _uninterruptible_sleep_dur_ns: i64 = 0,
        _interruptible_sleep_dur_ns: i64 = 0,
        _uninterruptible_io_sleep_dur_ns: i64 = 0,
        _uninterruptible_non_io_sleep_dur_ns: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidStartupMetric.TaskStateBreakdownReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidStartupMetric.TaskStateBreakdownReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidStartupMetric.TaskStateBreakdownWire.RUNNING_DUR_NS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._running_dur_ns = result.value;
                    },
                    AndroidStartupMetric.TaskStateBreakdownWire.RUNNABLE_DUR_NS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._runnable_dur_ns = result.value;
                    },
                    AndroidStartupMetric.TaskStateBreakdownWire.UNINTERRUPTIBLE_SLEEP_DUR_NS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._uninterruptible_sleep_dur_ns = result.value;
                    },
                    AndroidStartupMetric.TaskStateBreakdownWire.INTERRUPTIBLE_SLEEP_DUR_NS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._interruptible_sleep_dur_ns = result.value;
                    },
                    AndroidStartupMetric.TaskStateBreakdownWire.UNINTERRUPTIBLE_IO_SLEEP_DUR_NS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._uninterruptible_io_sleep_dur_ns = result.value;
                    },
                    AndroidStartupMetric.TaskStateBreakdownWire.UNINTERRUPTIBLE_NON_IO_SLEEP_DUR_NS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._uninterruptible_non_io_sleep_dur_ns = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getRunningDurNs(self: *const AndroidStartupMetric.TaskStateBreakdownReader) i64 {
            return self._running_dur_ns;
        }
        pub inline fn getRunnableDurNs(self: *const AndroidStartupMetric.TaskStateBreakdownReader) i64 {
            return self._runnable_dur_ns;
        }
        pub inline fn getUninterruptibleSleepDurNs(self: *const AndroidStartupMetric.TaskStateBreakdownReader) i64 {
            return self._uninterruptible_sleep_dur_ns;
        }
        pub inline fn getInterruptibleSleepDurNs(self: *const AndroidStartupMetric.TaskStateBreakdownReader) i64 {
            return self._interruptible_sleep_dur_ns;
        }
        pub inline fn getUninterruptibleIoSleepDurNs(self: *const AndroidStartupMetric.TaskStateBreakdownReader) i64 {
            return self._uninterruptible_io_sleep_dur_ns;
        }
        pub inline fn getUninterruptibleNonIoSleepDurNs(self: *const AndroidStartupMetric.TaskStateBreakdownReader) i64 {
            return self._uninterruptible_non_io_sleep_dur_ns;
        }
    };
    const McyclesByCoreTypeWire = struct {
        const LITTLE_WIRE: gremlin.ProtoWireNumber = 1;
        const BIG_WIRE: gremlin.ProtoWireNumber = 2;
        const BIGGER_WIRE: gremlin.ProtoWireNumber = 3;
        const UNKNOWN_WIRE: gremlin.ProtoWireNumber = 4;
    };
    pub const McyclesByCoreType = struct {
        // fields
        little: i64 = 0,
        big: i64 = 0,
        bigger: i64 = 0,
        unknown: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidStartupMetric.McyclesByCoreType) usize {
            var res: usize = 0;
            if (self.little != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.McyclesByCoreTypeWire.LITTLE_WIRE) + gremlin.sizes.sizeI64(self.little);
            }
            if (self.big != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.McyclesByCoreTypeWire.BIG_WIRE) + gremlin.sizes.sizeI64(self.big);
            }
            if (self.bigger != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.McyclesByCoreTypeWire.BIGGER_WIRE) + gremlin.sizes.sizeI64(self.bigger);
            }
            if (self.unknown != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.McyclesByCoreTypeWire.UNKNOWN_WIRE) + gremlin.sizes.sizeI64(self.unknown);
            }
            return res;
        }
        pub fn encode(self: *const AndroidStartupMetric.McyclesByCoreType, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidStartupMetric.McyclesByCoreType, target: *gremlin.Writer) void {
            if (self.little != 0) {
                target.appendInt64(AndroidStartupMetric.McyclesByCoreTypeWire.LITTLE_WIRE, self.little);
            }
            if (self.big != 0) {
                target.appendInt64(AndroidStartupMetric.McyclesByCoreTypeWire.BIG_WIRE, self.big);
            }
            if (self.bigger != 0) {
                target.appendInt64(AndroidStartupMetric.McyclesByCoreTypeWire.BIGGER_WIRE, self.bigger);
            }
            if (self.unknown != 0) {
                target.appendInt64(AndroidStartupMetric.McyclesByCoreTypeWire.UNKNOWN_WIRE, self.unknown);
            }
        }
    };
    pub const McyclesByCoreTypeReader = struct {
        buf: gremlin.Reader,
        _little: i64 = 0,
        _big: i64 = 0,
        _bigger: i64 = 0,
        _unknown: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidStartupMetric.McyclesByCoreTypeReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidStartupMetric.McyclesByCoreTypeReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidStartupMetric.McyclesByCoreTypeWire.LITTLE_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._little = result.value;
                    },
                    AndroidStartupMetric.McyclesByCoreTypeWire.BIG_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._big = result.value;
                    },
                    AndroidStartupMetric.McyclesByCoreTypeWire.BIGGER_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._bigger = result.value;
                    },
                    AndroidStartupMetric.McyclesByCoreTypeWire.UNKNOWN_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._unknown = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getLittle(self: *const AndroidStartupMetric.McyclesByCoreTypeReader) i64 {
            return self._little;
        }
        pub inline fn getBig(self: *const AndroidStartupMetric.McyclesByCoreTypeReader) i64 {
            return self._big;
        }
        pub inline fn getBigger(self: *const AndroidStartupMetric.McyclesByCoreTypeReader) i64 {
            return self._bigger;
        }
        pub inline fn getUnknown(self: *const AndroidStartupMetric.McyclesByCoreTypeReader) i64 {
            return self._unknown;
        }
    };
    const SliceWire = struct {
        const DUR_NS_WIRE: gremlin.ProtoWireNumber = 1;
        const DUR_MS_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const Slice = struct {
        // fields
        dur_ns: i64 = 0,
        dur_ms: f64 = 0.0,
        pub fn calcProtobufSize(self: *const AndroidStartupMetric.Slice) usize {
            var res: usize = 0;
            if (self.dur_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.SliceWire.DUR_NS_WIRE) + gremlin.sizes.sizeI64(self.dur_ns);
            }
            if (self.dur_ms != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.SliceWire.DUR_MS_WIRE) + gremlin.sizes.sizeDouble(self.dur_ms);
            }
            return res;
        }
        pub fn encode(self: *const AndroidStartupMetric.Slice, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidStartupMetric.Slice, target: *gremlin.Writer) void {
            if (self.dur_ns != 0) {
                target.appendInt64(AndroidStartupMetric.SliceWire.DUR_NS_WIRE, self.dur_ns);
            }
            if (self.dur_ms != 0.0) {
                target.appendFloat64(AndroidStartupMetric.SliceWire.DUR_MS_WIRE, self.dur_ms);
            }
        }
    };
    pub const SliceReader = struct {
        buf: gremlin.Reader,
        _dur_ns: i64 = 0,
        _dur_ms: f64 = 0.0,
        pub fn init(src: []const u8) gremlin.Error!AndroidStartupMetric.SliceReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidStartupMetric.SliceReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidStartupMetric.SliceWire.DUR_NS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._dur_ns = result.value;
                    },
                    AndroidStartupMetric.SliceWire.DUR_MS_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._dur_ms = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getDurNs(self: *const AndroidStartupMetric.SliceReader) i64 {
            return self._dur_ns;
        }
        pub inline fn getDurMs(self: *const AndroidStartupMetric.SliceReader) f64 {
            return self._dur_ms;
        }
    };
    const ToFirstFrameWire = struct {
        const DUR_NS_WIRE: gremlin.ProtoWireNumber = 1;
        const DUR_MS_WIRE: gremlin.ProtoWireNumber = 17;
        const MAIN_THREAD_BY_TASK_STATE_WIRE: gremlin.ProtoWireNumber = 2;
        const MCYCLES_BY_CORE_TYPE_WIRE: gremlin.ProtoWireNumber = 26;
        const OTHER_PROCESSES_SPAWNED_COUNT_WIRE: gremlin.ProtoWireNumber = 3;
        const TIME_ACTIVITY_MANAGER_WIRE: gremlin.ProtoWireNumber = 4;
        const TIME_ACTIVITY_THREAD_MAIN_WIRE: gremlin.ProtoWireNumber = 5;
        const TIME_BIND_APPLICATION_WIRE: gremlin.ProtoWireNumber = 6;
        const TIME_ACTIVITY_START_WIRE: gremlin.ProtoWireNumber = 7;
        const TIME_ACTIVITY_RESUME_WIRE: gremlin.ProtoWireNumber = 8;
        const TIME_ACTIVITY_RESTART_WIRE: gremlin.ProtoWireNumber = 21;
        const TIME_CHOREOGRAPHER_WIRE: gremlin.ProtoWireNumber = 9;
        const TIME_INFLATE_WIRE: gremlin.ProtoWireNumber = 22;
        const TIME_GET_RESOURCES_WIRE: gremlin.ProtoWireNumber = 23;
        const TIME_BEFORE_START_PROCESS_WIRE: gremlin.ProtoWireNumber = 10;
        const TIME_DURING_START_PROCESS_WIRE: gremlin.ProtoWireNumber = 11;
        const TIME_TO_RUNNING_STATE_WIRE: gremlin.ProtoWireNumber = 35;
        const TO_POST_FORK_WIRE: gremlin.ProtoWireNumber = 18;
        const TO_ACTIVITY_THREAD_MAIN_WIRE: gremlin.ProtoWireNumber = 19;
        const TO_BIND_APPLICATION_WIRE: gremlin.ProtoWireNumber = 20;
        const TIME_POST_FORK_WIRE: gremlin.ProtoWireNumber = 16;
        const TIME_CLASS_INITIALIZATION_WIRE: gremlin.ProtoWireNumber = 36;
        const TIME_DEX_OPEN_WIRE: gremlin.ProtoWireNumber = 24;
        const TIME_VERIFY_CLASS_WIRE: gremlin.ProtoWireNumber = 25;
        const JIT_COMPILED_METHODS_WIRE: gremlin.ProtoWireNumber = 27;
        const CLASS_INITIALIZATION_COUNT_WIRE: gremlin.ProtoWireNumber = 37;
        const TIME_JIT_THREAD_POOL_ON_CPU_WIRE: gremlin.ProtoWireNumber = 28;
        const TIME_GC_TOTAL_WIRE: gremlin.ProtoWireNumber = 29;
        const TIME_GC_ON_CPU_WIRE: gremlin.ProtoWireNumber = 30;
        const TIME_LOCK_CONTENTION_THREAD_MAIN_WIRE: gremlin.ProtoWireNumber = 31;
        const TIME_MONITOR_CONTENTION_THREAD_MAIN_WIRE: gremlin.ProtoWireNumber = 32;
        const TIME_DEX_OPEN_THREAD_MAIN_WIRE: gremlin.ProtoWireNumber = 33;
        const TIME_DLOPEN_THREAD_MAIN_WIRE: gremlin.ProtoWireNumber = 34;
    };
    pub const ToFirstFrame = struct {
        // fields
        dur_ns: i64 = 0,
        dur_ms: f64 = 0.0,
        main_thread_by_task_state: ?AndroidStartupMetric.TaskStateBreakdown = null,
        mcycles_by_core_type: ?AndroidStartupMetric.McyclesByCoreType = null,
        other_processes_spawned_count: u32 = 0,
        time_activity_manager: ?AndroidStartupMetric.Slice = null,
        time_activity_thread_main: ?AndroidStartupMetric.Slice = null,
        time_bind_application: ?AndroidStartupMetric.Slice = null,
        time_activity_start: ?AndroidStartupMetric.Slice = null,
        time_activity_resume: ?AndroidStartupMetric.Slice = null,
        time_activity_restart: ?AndroidStartupMetric.Slice = null,
        time_choreographer: ?AndroidStartupMetric.Slice = null,
        time_inflate: ?AndroidStartupMetric.Slice = null,
        time_get_resources: ?AndroidStartupMetric.Slice = null,
        time_before_start_process: ?AndroidStartupMetric.Slice = null,
        time_during_start_process: ?AndroidStartupMetric.Slice = null,
        time_to_running_state: ?AndroidStartupMetric.Slice = null,
        to_post_fork: ?AndroidStartupMetric.Slice = null,
        to_activity_thread_main: ?AndroidStartupMetric.Slice = null,
        to_bind_application: ?AndroidStartupMetric.Slice = null,
        time_post_fork: ?AndroidStartupMetric.Slice = null,
        time_class_initialization: ?AndroidStartupMetric.Slice = null,
        time_dex_open: ?AndroidStartupMetric.Slice = null,
        time_verify_class: ?AndroidStartupMetric.Slice = null,
        jit_compiled_methods: u32 = 0,
        class_initialization_count: u32 = 0,
        time_jit_thread_pool_on_cpu: ?AndroidStartupMetric.Slice = null,
        time_gc_total: ?AndroidStartupMetric.Slice = null,
        time_gc_on_cpu: ?AndroidStartupMetric.Slice = null,
        time_lock_contention_thread_main: ?AndroidStartupMetric.Slice = null,
        time_monitor_contention_thread_main: ?AndroidStartupMetric.Slice = null,
        time_dex_open_thread_main: ?AndroidStartupMetric.Slice = null,
        time_dlopen_thread_main: ?AndroidStartupMetric.Slice = null,
        pub fn calcProtobufSize(self: *const AndroidStartupMetric.ToFirstFrame) usize {
            var res: usize = 0;
            if (self.dur_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.ToFirstFrameWire.DUR_NS_WIRE) + gremlin.sizes.sizeI64(self.dur_ns);
            }
            if (self.dur_ms != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.ToFirstFrameWire.DUR_MS_WIRE) + gremlin.sizes.sizeDouble(self.dur_ms);
            }
            if (self.main_thread_by_task_state) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.ToFirstFrameWire.MAIN_THREAD_BY_TASK_STATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.mcycles_by_core_type) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.ToFirstFrameWire.MCYCLES_BY_CORE_TYPE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.other_processes_spawned_count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.ToFirstFrameWire.OTHER_PROCESSES_SPAWNED_COUNT_WIRE) + gremlin.sizes.sizeU32(self.other_processes_spawned_count);
            }
            if (self.time_activity_manager) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.ToFirstFrameWire.TIME_ACTIVITY_MANAGER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.time_activity_thread_main) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.ToFirstFrameWire.TIME_ACTIVITY_THREAD_MAIN_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.time_bind_application) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.ToFirstFrameWire.TIME_BIND_APPLICATION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.time_activity_start) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.ToFirstFrameWire.TIME_ACTIVITY_START_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.time_activity_resume) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.ToFirstFrameWire.TIME_ACTIVITY_RESUME_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.time_activity_restart) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.ToFirstFrameWire.TIME_ACTIVITY_RESTART_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.time_choreographer) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.ToFirstFrameWire.TIME_CHOREOGRAPHER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.time_inflate) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.ToFirstFrameWire.TIME_INFLATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.time_get_resources) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.ToFirstFrameWire.TIME_GET_RESOURCES_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.time_before_start_process) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.ToFirstFrameWire.TIME_BEFORE_START_PROCESS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.time_during_start_process) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.ToFirstFrameWire.TIME_DURING_START_PROCESS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.time_to_running_state) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.ToFirstFrameWire.TIME_TO_RUNNING_STATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.to_post_fork) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.ToFirstFrameWire.TO_POST_FORK_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.to_activity_thread_main) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.ToFirstFrameWire.TO_ACTIVITY_THREAD_MAIN_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.to_bind_application) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.ToFirstFrameWire.TO_BIND_APPLICATION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.time_post_fork) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.ToFirstFrameWire.TIME_POST_FORK_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.time_class_initialization) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.ToFirstFrameWire.TIME_CLASS_INITIALIZATION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.time_dex_open) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.ToFirstFrameWire.TIME_DEX_OPEN_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.time_verify_class) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.ToFirstFrameWire.TIME_VERIFY_CLASS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.jit_compiled_methods != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.ToFirstFrameWire.JIT_COMPILED_METHODS_WIRE) + gremlin.sizes.sizeU32(self.jit_compiled_methods);
            }
            if (self.class_initialization_count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.ToFirstFrameWire.CLASS_INITIALIZATION_COUNT_WIRE) + gremlin.sizes.sizeU32(self.class_initialization_count);
            }
            if (self.time_jit_thread_pool_on_cpu) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.ToFirstFrameWire.TIME_JIT_THREAD_POOL_ON_CPU_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.time_gc_total) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.ToFirstFrameWire.TIME_GC_TOTAL_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.time_gc_on_cpu) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.ToFirstFrameWire.TIME_GC_ON_CPU_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.time_lock_contention_thread_main) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.ToFirstFrameWire.TIME_LOCK_CONTENTION_THREAD_MAIN_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.time_monitor_contention_thread_main) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.ToFirstFrameWire.TIME_MONITOR_CONTENTION_THREAD_MAIN_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.time_dex_open_thread_main) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.ToFirstFrameWire.TIME_DEX_OPEN_THREAD_MAIN_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.time_dlopen_thread_main) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.ToFirstFrameWire.TIME_DLOPEN_THREAD_MAIN_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidStartupMetric.ToFirstFrame, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidStartupMetric.ToFirstFrame, target: *gremlin.Writer) void {
            if (self.dur_ns != 0) {
                target.appendInt64(AndroidStartupMetric.ToFirstFrameWire.DUR_NS_WIRE, self.dur_ns);
            }
            if (self.dur_ms != 0.0) {
                target.appendFloat64(AndroidStartupMetric.ToFirstFrameWire.DUR_MS_WIRE, self.dur_ms);
            }
            if (self.main_thread_by_task_state) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidStartupMetric.ToFirstFrameWire.MAIN_THREAD_BY_TASK_STATE_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.mcycles_by_core_type) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidStartupMetric.ToFirstFrameWire.MCYCLES_BY_CORE_TYPE_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.other_processes_spawned_count != 0) {
                target.appendUint32(AndroidStartupMetric.ToFirstFrameWire.OTHER_PROCESSES_SPAWNED_COUNT_WIRE, self.other_processes_spawned_count);
            }
            if (self.time_activity_manager) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidStartupMetric.ToFirstFrameWire.TIME_ACTIVITY_MANAGER_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.time_activity_thread_main) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidStartupMetric.ToFirstFrameWire.TIME_ACTIVITY_THREAD_MAIN_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.time_bind_application) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidStartupMetric.ToFirstFrameWire.TIME_BIND_APPLICATION_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.time_activity_start) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidStartupMetric.ToFirstFrameWire.TIME_ACTIVITY_START_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.time_activity_resume) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidStartupMetric.ToFirstFrameWire.TIME_ACTIVITY_RESUME_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.time_activity_restart) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidStartupMetric.ToFirstFrameWire.TIME_ACTIVITY_RESTART_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.time_choreographer) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidStartupMetric.ToFirstFrameWire.TIME_CHOREOGRAPHER_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.time_inflate) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidStartupMetric.ToFirstFrameWire.TIME_INFLATE_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.time_get_resources) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidStartupMetric.ToFirstFrameWire.TIME_GET_RESOURCES_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.time_before_start_process) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidStartupMetric.ToFirstFrameWire.TIME_BEFORE_START_PROCESS_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.time_during_start_process) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidStartupMetric.ToFirstFrameWire.TIME_DURING_START_PROCESS_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.time_to_running_state) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidStartupMetric.ToFirstFrameWire.TIME_TO_RUNNING_STATE_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.to_post_fork) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidStartupMetric.ToFirstFrameWire.TO_POST_FORK_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.to_activity_thread_main) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidStartupMetric.ToFirstFrameWire.TO_ACTIVITY_THREAD_MAIN_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.to_bind_application) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidStartupMetric.ToFirstFrameWire.TO_BIND_APPLICATION_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.time_post_fork) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidStartupMetric.ToFirstFrameWire.TIME_POST_FORK_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.time_class_initialization) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidStartupMetric.ToFirstFrameWire.TIME_CLASS_INITIALIZATION_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.time_dex_open) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidStartupMetric.ToFirstFrameWire.TIME_DEX_OPEN_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.time_verify_class) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidStartupMetric.ToFirstFrameWire.TIME_VERIFY_CLASS_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.jit_compiled_methods != 0) {
                target.appendUint32(AndroidStartupMetric.ToFirstFrameWire.JIT_COMPILED_METHODS_WIRE, self.jit_compiled_methods);
            }
            if (self.class_initialization_count != 0) {
                target.appendUint32(AndroidStartupMetric.ToFirstFrameWire.CLASS_INITIALIZATION_COUNT_WIRE, self.class_initialization_count);
            }
            if (self.time_jit_thread_pool_on_cpu) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidStartupMetric.ToFirstFrameWire.TIME_JIT_THREAD_POOL_ON_CPU_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.time_gc_total) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidStartupMetric.ToFirstFrameWire.TIME_GC_TOTAL_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.time_gc_on_cpu) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidStartupMetric.ToFirstFrameWire.TIME_GC_ON_CPU_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.time_lock_contention_thread_main) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidStartupMetric.ToFirstFrameWire.TIME_LOCK_CONTENTION_THREAD_MAIN_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.time_monitor_contention_thread_main) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidStartupMetric.ToFirstFrameWire.TIME_MONITOR_CONTENTION_THREAD_MAIN_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.time_dex_open_thread_main) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidStartupMetric.ToFirstFrameWire.TIME_DEX_OPEN_THREAD_MAIN_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.time_dlopen_thread_main) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidStartupMetric.ToFirstFrameWire.TIME_DLOPEN_THREAD_MAIN_WIRE, size);
                    v.encodeTo(target);
                }
            }
        }
    };
    pub const ToFirstFrameReader = struct {
        buf: gremlin.Reader,
        _dur_ns: i64 = 0,
        _dur_ms: f64 = 0.0,
        _main_thread_by_task_state_buf: ?[]const u8 = null,
        _mcycles_by_core_type_buf: ?[]const u8 = null,
        _other_processes_spawned_count: u32 = 0,
        _time_activity_manager_buf: ?[]const u8 = null,
        _time_activity_thread_main_buf: ?[]const u8 = null,
        _time_bind_application_buf: ?[]const u8 = null,
        _time_activity_start_buf: ?[]const u8 = null,
        _time_activity_resume_buf: ?[]const u8 = null,
        _time_activity_restart_buf: ?[]const u8 = null,
        _time_choreographer_buf: ?[]const u8 = null,
        _time_inflate_buf: ?[]const u8 = null,
        _time_get_resources_buf: ?[]const u8 = null,
        _time_before_start_process_buf: ?[]const u8 = null,
        _time_during_start_process_buf: ?[]const u8 = null,
        _time_to_running_state_buf: ?[]const u8 = null,
        _to_post_fork_buf: ?[]const u8 = null,
        _to_activity_thread_main_buf: ?[]const u8 = null,
        _to_bind_application_buf: ?[]const u8 = null,
        _time_post_fork_buf: ?[]const u8 = null,
        _time_class_initialization_buf: ?[]const u8 = null,
        _time_dex_open_buf: ?[]const u8 = null,
        _time_verify_class_buf: ?[]const u8 = null,
        _jit_compiled_methods: u32 = 0,
        _class_initialization_count: u32 = 0,
        _time_jit_thread_pool_on_cpu_buf: ?[]const u8 = null,
        _time_gc_total_buf: ?[]const u8 = null,
        _time_gc_on_cpu_buf: ?[]const u8 = null,
        _time_lock_contention_thread_main_buf: ?[]const u8 = null,
        _time_monitor_contention_thread_main_buf: ?[]const u8 = null,
        _time_dex_open_thread_main_buf: ?[]const u8 = null,
        _time_dlopen_thread_main_buf: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!AndroidStartupMetric.ToFirstFrameReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidStartupMetric.ToFirstFrameReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidStartupMetric.ToFirstFrameWire.DUR_NS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._dur_ns = result.value;
                    },
                    AndroidStartupMetric.ToFirstFrameWire.DUR_MS_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._dur_ms = result.value;
                    },
                    AndroidStartupMetric.ToFirstFrameWire.MAIN_THREAD_BY_TASK_STATE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._main_thread_by_task_state_buf = result.value;
                    },
                    AndroidStartupMetric.ToFirstFrameWire.MCYCLES_BY_CORE_TYPE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._mcycles_by_core_type_buf = result.value;
                    },
                    AndroidStartupMetric.ToFirstFrameWire.OTHER_PROCESSES_SPAWNED_COUNT_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._other_processes_spawned_count = result.value;
                    },
                    AndroidStartupMetric.ToFirstFrameWire.TIME_ACTIVITY_MANAGER_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._time_activity_manager_buf = result.value;
                    },
                    AndroidStartupMetric.ToFirstFrameWire.TIME_ACTIVITY_THREAD_MAIN_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._time_activity_thread_main_buf = result.value;
                    },
                    AndroidStartupMetric.ToFirstFrameWire.TIME_BIND_APPLICATION_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._time_bind_application_buf = result.value;
                    },
                    AndroidStartupMetric.ToFirstFrameWire.TIME_ACTIVITY_START_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._time_activity_start_buf = result.value;
                    },
                    AndroidStartupMetric.ToFirstFrameWire.TIME_ACTIVITY_RESUME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._time_activity_resume_buf = result.value;
                    },
                    AndroidStartupMetric.ToFirstFrameWire.TIME_ACTIVITY_RESTART_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._time_activity_restart_buf = result.value;
                    },
                    AndroidStartupMetric.ToFirstFrameWire.TIME_CHOREOGRAPHER_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._time_choreographer_buf = result.value;
                    },
                    AndroidStartupMetric.ToFirstFrameWire.TIME_INFLATE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._time_inflate_buf = result.value;
                    },
                    AndroidStartupMetric.ToFirstFrameWire.TIME_GET_RESOURCES_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._time_get_resources_buf = result.value;
                    },
                    AndroidStartupMetric.ToFirstFrameWire.TIME_BEFORE_START_PROCESS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._time_before_start_process_buf = result.value;
                    },
                    AndroidStartupMetric.ToFirstFrameWire.TIME_DURING_START_PROCESS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._time_during_start_process_buf = result.value;
                    },
                    AndroidStartupMetric.ToFirstFrameWire.TIME_TO_RUNNING_STATE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._time_to_running_state_buf = result.value;
                    },
                    AndroidStartupMetric.ToFirstFrameWire.TO_POST_FORK_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._to_post_fork_buf = result.value;
                    },
                    AndroidStartupMetric.ToFirstFrameWire.TO_ACTIVITY_THREAD_MAIN_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._to_activity_thread_main_buf = result.value;
                    },
                    AndroidStartupMetric.ToFirstFrameWire.TO_BIND_APPLICATION_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._to_bind_application_buf = result.value;
                    },
                    AndroidStartupMetric.ToFirstFrameWire.TIME_POST_FORK_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._time_post_fork_buf = result.value;
                    },
                    AndroidStartupMetric.ToFirstFrameWire.TIME_CLASS_INITIALIZATION_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._time_class_initialization_buf = result.value;
                    },
                    AndroidStartupMetric.ToFirstFrameWire.TIME_DEX_OPEN_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._time_dex_open_buf = result.value;
                    },
                    AndroidStartupMetric.ToFirstFrameWire.TIME_VERIFY_CLASS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._time_verify_class_buf = result.value;
                    },
                    AndroidStartupMetric.ToFirstFrameWire.JIT_COMPILED_METHODS_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._jit_compiled_methods = result.value;
                    },
                    AndroidStartupMetric.ToFirstFrameWire.CLASS_INITIALIZATION_COUNT_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._class_initialization_count = result.value;
                    },
                    AndroidStartupMetric.ToFirstFrameWire.TIME_JIT_THREAD_POOL_ON_CPU_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._time_jit_thread_pool_on_cpu_buf = result.value;
                    },
                    AndroidStartupMetric.ToFirstFrameWire.TIME_GC_TOTAL_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._time_gc_total_buf = result.value;
                    },
                    AndroidStartupMetric.ToFirstFrameWire.TIME_GC_ON_CPU_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._time_gc_on_cpu_buf = result.value;
                    },
                    AndroidStartupMetric.ToFirstFrameWire.TIME_LOCK_CONTENTION_THREAD_MAIN_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._time_lock_contention_thread_main_buf = result.value;
                    },
                    AndroidStartupMetric.ToFirstFrameWire.TIME_MONITOR_CONTENTION_THREAD_MAIN_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._time_monitor_contention_thread_main_buf = result.value;
                    },
                    AndroidStartupMetric.ToFirstFrameWire.TIME_DEX_OPEN_THREAD_MAIN_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._time_dex_open_thread_main_buf = result.value;
                    },
                    AndroidStartupMetric.ToFirstFrameWire.TIME_DLOPEN_THREAD_MAIN_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._time_dlopen_thread_main_buf = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getDurNs(self: *const AndroidStartupMetric.ToFirstFrameReader) i64 {
            return self._dur_ns;
        }
        pub inline fn getDurMs(self: *const AndroidStartupMetric.ToFirstFrameReader) f64 {
            return self._dur_ms;
        }
        pub fn getMainThreadByTaskState(self: *const AndroidStartupMetric.ToFirstFrameReader) gremlin.Error!AndroidStartupMetric.TaskStateBreakdownReader {
            if (self._main_thread_by_task_state_buf) |buf| {
                return try AndroidStartupMetric.TaskStateBreakdownReader.init(buf);
            }
            return try AndroidStartupMetric.TaskStateBreakdownReader.init(&[_]u8{});
        }
        pub fn getMcyclesByCoreType(self: *const AndroidStartupMetric.ToFirstFrameReader) gremlin.Error!AndroidStartupMetric.McyclesByCoreTypeReader {
            if (self._mcycles_by_core_type_buf) |buf| {
                return try AndroidStartupMetric.McyclesByCoreTypeReader.init(buf);
            }
            return try AndroidStartupMetric.McyclesByCoreTypeReader.init(&[_]u8{});
        }
        pub inline fn getOtherProcessesSpawnedCount(self: *const AndroidStartupMetric.ToFirstFrameReader) u32 {
            return self._other_processes_spawned_count;
        }
        pub fn getTimeActivityManager(self: *const AndroidStartupMetric.ToFirstFrameReader) gremlin.Error!AndroidStartupMetric.SliceReader {
            if (self._time_activity_manager_buf) |buf| {
                return try AndroidStartupMetric.SliceReader.init(buf);
            }
            return try AndroidStartupMetric.SliceReader.init(&[_]u8{});
        }
        pub fn getTimeActivityThreadMain(self: *const AndroidStartupMetric.ToFirstFrameReader) gremlin.Error!AndroidStartupMetric.SliceReader {
            if (self._time_activity_thread_main_buf) |buf| {
                return try AndroidStartupMetric.SliceReader.init(buf);
            }
            return try AndroidStartupMetric.SliceReader.init(&[_]u8{});
        }
        pub fn getTimeBindApplication(self: *const AndroidStartupMetric.ToFirstFrameReader) gremlin.Error!AndroidStartupMetric.SliceReader {
            if (self._time_bind_application_buf) |buf| {
                return try AndroidStartupMetric.SliceReader.init(buf);
            }
            return try AndroidStartupMetric.SliceReader.init(&[_]u8{});
        }
        pub fn getTimeActivityStart(self: *const AndroidStartupMetric.ToFirstFrameReader) gremlin.Error!AndroidStartupMetric.SliceReader {
            if (self._time_activity_start_buf) |buf| {
                return try AndroidStartupMetric.SliceReader.init(buf);
            }
            return try AndroidStartupMetric.SliceReader.init(&[_]u8{});
        }
        pub fn getTimeActivityResume(self: *const AndroidStartupMetric.ToFirstFrameReader) gremlin.Error!AndroidStartupMetric.SliceReader {
            if (self._time_activity_resume_buf) |buf| {
                return try AndroidStartupMetric.SliceReader.init(buf);
            }
            return try AndroidStartupMetric.SliceReader.init(&[_]u8{});
        }
        pub fn getTimeActivityRestart(self: *const AndroidStartupMetric.ToFirstFrameReader) gremlin.Error!AndroidStartupMetric.SliceReader {
            if (self._time_activity_restart_buf) |buf| {
                return try AndroidStartupMetric.SliceReader.init(buf);
            }
            return try AndroidStartupMetric.SliceReader.init(&[_]u8{});
        }
        pub fn getTimeChoreographer(self: *const AndroidStartupMetric.ToFirstFrameReader) gremlin.Error!AndroidStartupMetric.SliceReader {
            if (self._time_choreographer_buf) |buf| {
                return try AndroidStartupMetric.SliceReader.init(buf);
            }
            return try AndroidStartupMetric.SliceReader.init(&[_]u8{});
        }
        pub fn getTimeInflate(self: *const AndroidStartupMetric.ToFirstFrameReader) gremlin.Error!AndroidStartupMetric.SliceReader {
            if (self._time_inflate_buf) |buf| {
                return try AndroidStartupMetric.SliceReader.init(buf);
            }
            return try AndroidStartupMetric.SliceReader.init(&[_]u8{});
        }
        pub fn getTimeGetResources(self: *const AndroidStartupMetric.ToFirstFrameReader) gremlin.Error!AndroidStartupMetric.SliceReader {
            if (self._time_get_resources_buf) |buf| {
                return try AndroidStartupMetric.SliceReader.init(buf);
            }
            return try AndroidStartupMetric.SliceReader.init(&[_]u8{});
        }
        pub fn getTimeBeforeStartProcess(self: *const AndroidStartupMetric.ToFirstFrameReader) gremlin.Error!AndroidStartupMetric.SliceReader {
            if (self._time_before_start_process_buf) |buf| {
                return try AndroidStartupMetric.SliceReader.init(buf);
            }
            return try AndroidStartupMetric.SliceReader.init(&[_]u8{});
        }
        pub fn getTimeDuringStartProcess(self: *const AndroidStartupMetric.ToFirstFrameReader) gremlin.Error!AndroidStartupMetric.SliceReader {
            if (self._time_during_start_process_buf) |buf| {
                return try AndroidStartupMetric.SliceReader.init(buf);
            }
            return try AndroidStartupMetric.SliceReader.init(&[_]u8{});
        }
        pub fn getTimeToRunningState(self: *const AndroidStartupMetric.ToFirstFrameReader) gremlin.Error!AndroidStartupMetric.SliceReader {
            if (self._time_to_running_state_buf) |buf| {
                return try AndroidStartupMetric.SliceReader.init(buf);
            }
            return try AndroidStartupMetric.SliceReader.init(&[_]u8{});
        }
        pub fn getToPostFork(self: *const AndroidStartupMetric.ToFirstFrameReader) gremlin.Error!AndroidStartupMetric.SliceReader {
            if (self._to_post_fork_buf) |buf| {
                return try AndroidStartupMetric.SliceReader.init(buf);
            }
            return try AndroidStartupMetric.SliceReader.init(&[_]u8{});
        }
        pub fn getToActivityThreadMain(self: *const AndroidStartupMetric.ToFirstFrameReader) gremlin.Error!AndroidStartupMetric.SliceReader {
            if (self._to_activity_thread_main_buf) |buf| {
                return try AndroidStartupMetric.SliceReader.init(buf);
            }
            return try AndroidStartupMetric.SliceReader.init(&[_]u8{});
        }
        pub fn getToBindApplication(self: *const AndroidStartupMetric.ToFirstFrameReader) gremlin.Error!AndroidStartupMetric.SliceReader {
            if (self._to_bind_application_buf) |buf| {
                return try AndroidStartupMetric.SliceReader.init(buf);
            }
            return try AndroidStartupMetric.SliceReader.init(&[_]u8{});
        }
        pub fn getTimePostFork(self: *const AndroidStartupMetric.ToFirstFrameReader) gremlin.Error!AndroidStartupMetric.SliceReader {
            if (self._time_post_fork_buf) |buf| {
                return try AndroidStartupMetric.SliceReader.init(buf);
            }
            return try AndroidStartupMetric.SliceReader.init(&[_]u8{});
        }
        pub fn getTimeClassInitialization(self: *const AndroidStartupMetric.ToFirstFrameReader) gremlin.Error!AndroidStartupMetric.SliceReader {
            if (self._time_class_initialization_buf) |buf| {
                return try AndroidStartupMetric.SliceReader.init(buf);
            }
            return try AndroidStartupMetric.SliceReader.init(&[_]u8{});
        }
        pub fn getTimeDexOpen(self: *const AndroidStartupMetric.ToFirstFrameReader) gremlin.Error!AndroidStartupMetric.SliceReader {
            if (self._time_dex_open_buf) |buf| {
                return try AndroidStartupMetric.SliceReader.init(buf);
            }
            return try AndroidStartupMetric.SliceReader.init(&[_]u8{});
        }
        pub fn getTimeVerifyClass(self: *const AndroidStartupMetric.ToFirstFrameReader) gremlin.Error!AndroidStartupMetric.SliceReader {
            if (self._time_verify_class_buf) |buf| {
                return try AndroidStartupMetric.SliceReader.init(buf);
            }
            return try AndroidStartupMetric.SliceReader.init(&[_]u8{});
        }
        pub inline fn getJitCompiledMethods(self: *const AndroidStartupMetric.ToFirstFrameReader) u32 {
            return self._jit_compiled_methods;
        }
        pub inline fn getClassInitializationCount(self: *const AndroidStartupMetric.ToFirstFrameReader) u32 {
            return self._class_initialization_count;
        }
        pub fn getTimeJitThreadPoolOnCpu(self: *const AndroidStartupMetric.ToFirstFrameReader) gremlin.Error!AndroidStartupMetric.SliceReader {
            if (self._time_jit_thread_pool_on_cpu_buf) |buf| {
                return try AndroidStartupMetric.SliceReader.init(buf);
            }
            return try AndroidStartupMetric.SliceReader.init(&[_]u8{});
        }
        pub fn getTimeGcTotal(self: *const AndroidStartupMetric.ToFirstFrameReader) gremlin.Error!AndroidStartupMetric.SliceReader {
            if (self._time_gc_total_buf) |buf| {
                return try AndroidStartupMetric.SliceReader.init(buf);
            }
            return try AndroidStartupMetric.SliceReader.init(&[_]u8{});
        }
        pub fn getTimeGcOnCpu(self: *const AndroidStartupMetric.ToFirstFrameReader) gremlin.Error!AndroidStartupMetric.SliceReader {
            if (self._time_gc_on_cpu_buf) |buf| {
                return try AndroidStartupMetric.SliceReader.init(buf);
            }
            return try AndroidStartupMetric.SliceReader.init(&[_]u8{});
        }
        pub fn getTimeLockContentionThreadMain(self: *const AndroidStartupMetric.ToFirstFrameReader) gremlin.Error!AndroidStartupMetric.SliceReader {
            if (self._time_lock_contention_thread_main_buf) |buf| {
                return try AndroidStartupMetric.SliceReader.init(buf);
            }
            return try AndroidStartupMetric.SliceReader.init(&[_]u8{});
        }
        pub fn getTimeMonitorContentionThreadMain(self: *const AndroidStartupMetric.ToFirstFrameReader) gremlin.Error!AndroidStartupMetric.SliceReader {
            if (self._time_monitor_contention_thread_main_buf) |buf| {
                return try AndroidStartupMetric.SliceReader.init(buf);
            }
            return try AndroidStartupMetric.SliceReader.init(&[_]u8{});
        }
        pub fn getTimeDexOpenThreadMain(self: *const AndroidStartupMetric.ToFirstFrameReader) gremlin.Error!AndroidStartupMetric.SliceReader {
            if (self._time_dex_open_thread_main_buf) |buf| {
                return try AndroidStartupMetric.SliceReader.init(buf);
            }
            return try AndroidStartupMetric.SliceReader.init(&[_]u8{});
        }
        pub fn getTimeDlopenThreadMain(self: *const AndroidStartupMetric.ToFirstFrameReader) gremlin.Error!AndroidStartupMetric.SliceReader {
            if (self._time_dlopen_thread_main_buf) |buf| {
                return try AndroidStartupMetric.SliceReader.init(buf);
            }
            return try AndroidStartupMetric.SliceReader.init(&[_]u8{});
        }
    };
    const HscMetricsWire = struct {
        const FULL_STARTUP_WIRE: gremlin.ProtoWireNumber = 1;
    };
    pub const HscMetrics = struct {
        // fields
        full_startup: ?AndroidStartupMetric.Slice = null,
        pub fn calcProtobufSize(self: *const AndroidStartupMetric.HscMetrics) usize {
            var res: usize = 0;
            if (self.full_startup) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.HscMetricsWire.FULL_STARTUP_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidStartupMetric.HscMetrics, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidStartupMetric.HscMetrics, target: *gremlin.Writer) void {
            if (self.full_startup) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidStartupMetric.HscMetricsWire.FULL_STARTUP_WIRE, size);
                    v.encodeTo(target);
                }
            }
        }
    };
    pub const HscMetricsReader = struct {
        buf: gremlin.Reader,
        _full_startup_buf: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!AndroidStartupMetric.HscMetricsReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidStartupMetric.HscMetricsReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidStartupMetric.HscMetricsWire.FULL_STARTUP_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._full_startup_buf = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn getFullStartup(self: *const AndroidStartupMetric.HscMetricsReader) gremlin.Error!AndroidStartupMetric.SliceReader {
            if (self._full_startup_buf) |buf| {
                return try AndroidStartupMetric.SliceReader.init(buf);
            }
            return try AndroidStartupMetric.SliceReader.init(&[_]u8{});
        }
    };
    const ActivityWire = struct {
        const NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const METHOD_WIRE: gremlin.ProtoWireNumber = 2;
        const TS_METHOD_START_WIRE: gremlin.ProtoWireNumber = 4;
    };
    pub const Activity = struct {
        // fields
        name: ?[]const u8 = null,
        method: ?[]const u8 = null,
        ts_method_start: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidStartupMetric.Activity) usize {
            var res: usize = 0;
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.ActivityWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.method) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.ActivityWire.METHOD_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.ts_method_start != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.ActivityWire.TS_METHOD_START_WIRE) + gremlin.sizes.sizeI64(self.ts_method_start);
            }
            return res;
        }
        pub fn encode(self: *const AndroidStartupMetric.Activity, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidStartupMetric.Activity, target: *gremlin.Writer) void {
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidStartupMetric.ActivityWire.NAME_WIRE, v);
                }
            }
            if (self.method) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidStartupMetric.ActivityWire.METHOD_WIRE, v);
                }
            }
            if (self.ts_method_start != 0) {
                target.appendInt64(AndroidStartupMetric.ActivityWire.TS_METHOD_START_WIRE, self.ts_method_start);
            }
        }
    };
    pub const ActivityReader = struct {
        buf: gremlin.Reader,
        _name: ?[]const u8 = null,
        _method: ?[]const u8 = null,
        _ts_method_start: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidStartupMetric.ActivityReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidStartupMetric.ActivityReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidStartupMetric.ActivityWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    AndroidStartupMetric.ActivityWire.METHOD_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._method = result.value;
                    },
                    AndroidStartupMetric.ActivityWire.TS_METHOD_START_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._ts_method_start = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getName(self: *const AndroidStartupMetric.ActivityReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub inline fn getMethod(self: *const AndroidStartupMetric.ActivityReader) []const u8 {
            return self._method orelse &[_]u8{};
        }
        pub inline fn getTsMethodStart(self: *const AndroidStartupMetric.ActivityReader) i64 {
            return self._ts_method_start;
        }
    };
    const BinderTransactionWire = struct {
        const DURATION_WIRE: gremlin.ProtoWireNumber = 1;
        const THREAD_WIRE: gremlin.ProtoWireNumber = 2;
        const DESTINATION_THREAD_WIRE: gremlin.ProtoWireNumber = 3;
        const DESTINATION_PROCESS_WIRE: gremlin.ProtoWireNumber = 4;
        const FLAGS_WIRE: gremlin.ProtoWireNumber = 5;
        const CODE_WIRE: gremlin.ProtoWireNumber = 6;
        const DATA_SIZE_WIRE: gremlin.ProtoWireNumber = 7;
    };
    pub const BinderTransaction = struct {
        // fields
        duration: ?AndroidStartupMetric.Slice = null,
        thread: ?[]const u8 = null,
        destination_thread: ?[]const u8 = null,
        destination_process: ?[]const u8 = null,
        flags: ?[]const u8 = null,
        code: ?[]const u8 = null,
        data_size: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidStartupMetric.BinderTransaction) usize {
            var res: usize = 0;
            if (self.duration) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.BinderTransactionWire.DURATION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.thread) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.BinderTransactionWire.THREAD_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.destination_thread) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.BinderTransactionWire.DESTINATION_THREAD_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.destination_process) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.BinderTransactionWire.DESTINATION_PROCESS_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.flags) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.BinderTransactionWire.FLAGS_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.code) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.BinderTransactionWire.CODE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.data_size != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.BinderTransactionWire.DATA_SIZE_WIRE) + gremlin.sizes.sizeI64(self.data_size);
            }
            return res;
        }
        pub fn encode(self: *const AndroidStartupMetric.BinderTransaction, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidStartupMetric.BinderTransaction, target: *gremlin.Writer) void {
            if (self.duration) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidStartupMetric.BinderTransactionWire.DURATION_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.thread) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidStartupMetric.BinderTransactionWire.THREAD_WIRE, v);
                }
            }
            if (self.destination_thread) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidStartupMetric.BinderTransactionWire.DESTINATION_THREAD_WIRE, v);
                }
            }
            if (self.destination_process) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidStartupMetric.BinderTransactionWire.DESTINATION_PROCESS_WIRE, v);
                }
            }
            if (self.flags) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidStartupMetric.BinderTransactionWire.FLAGS_WIRE, v);
                }
            }
            if (self.code) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidStartupMetric.BinderTransactionWire.CODE_WIRE, v);
                }
            }
            if (self.data_size != 0) {
                target.appendInt64(AndroidStartupMetric.BinderTransactionWire.DATA_SIZE_WIRE, self.data_size);
            }
        }
    };
    pub const BinderTransactionReader = struct {
        buf: gremlin.Reader,
        _duration_buf: ?[]const u8 = null,
        _thread: ?[]const u8 = null,
        _destination_thread: ?[]const u8 = null,
        _destination_process: ?[]const u8 = null,
        _flags: ?[]const u8 = null,
        _code: ?[]const u8 = null,
        _data_size: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidStartupMetric.BinderTransactionReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidStartupMetric.BinderTransactionReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidStartupMetric.BinderTransactionWire.DURATION_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._duration_buf = result.value;
                    },
                    AndroidStartupMetric.BinderTransactionWire.THREAD_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._thread = result.value;
                    },
                    AndroidStartupMetric.BinderTransactionWire.DESTINATION_THREAD_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._destination_thread = result.value;
                    },
                    AndroidStartupMetric.BinderTransactionWire.DESTINATION_PROCESS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._destination_process = result.value;
                    },
                    AndroidStartupMetric.BinderTransactionWire.FLAGS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._flags = result.value;
                    },
                    AndroidStartupMetric.BinderTransactionWire.CODE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._code = result.value;
                    },
                    AndroidStartupMetric.BinderTransactionWire.DATA_SIZE_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._data_size = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn getDuration(self: *const AndroidStartupMetric.BinderTransactionReader) gremlin.Error!AndroidStartupMetric.SliceReader {
            if (self._duration_buf) |buf| {
                return try AndroidStartupMetric.SliceReader.init(buf);
            }
            return try AndroidStartupMetric.SliceReader.init(&[_]u8{});
        }
        pub inline fn getThread(self: *const AndroidStartupMetric.BinderTransactionReader) []const u8 {
            return self._thread orelse &[_]u8{};
        }
        pub inline fn getDestinationThread(self: *const AndroidStartupMetric.BinderTransactionReader) []const u8 {
            return self._destination_thread orelse &[_]u8{};
        }
        pub inline fn getDestinationProcess(self: *const AndroidStartupMetric.BinderTransactionReader) []const u8 {
            return self._destination_process orelse &[_]u8{};
        }
        pub inline fn getFlags(self: *const AndroidStartupMetric.BinderTransactionReader) []const u8 {
            return self._flags orelse &[_]u8{};
        }
        pub inline fn getCode(self: *const AndroidStartupMetric.BinderTransactionReader) []const u8 {
            return self._code orelse &[_]u8{};
        }
        pub inline fn getDataSize(self: *const AndroidStartupMetric.BinderTransactionReader) i64 {
            return self._data_size;
        }
    };
    const OptimizationStatusWire = struct {
        const ODEX_STATUS_WIRE: gremlin.ProtoWireNumber = 1;
        const COMPILATION_FILTER_WIRE: gremlin.ProtoWireNumber = 2;
        const COMPILATION_REASON_WIRE: gremlin.ProtoWireNumber = 3;
        const LOCATION_WIRE: gremlin.ProtoWireNumber = 4;
        const SUMMARY_WIRE: gremlin.ProtoWireNumber = 5;
    };
    pub const OptimizationStatus = struct {
        // fields
        odex_status: ?[]const u8 = null,
        compilation_filter: ?[]const u8 = null,
        compilation_reason: ?[]const u8 = null,
        location: ?[]const u8 = null,
        summary: ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const AndroidStartupMetric.OptimizationStatus) usize {
            var res: usize = 0;
            if (self.odex_status) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.OptimizationStatusWire.ODEX_STATUS_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.compilation_filter) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.OptimizationStatusWire.COMPILATION_FILTER_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.compilation_reason) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.OptimizationStatusWire.COMPILATION_REASON_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.location) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.OptimizationStatusWire.LOCATION_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.summary) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.OptimizationStatusWire.SUMMARY_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidStartupMetric.OptimizationStatus, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidStartupMetric.OptimizationStatus, target: *gremlin.Writer) void {
            if (self.odex_status) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidStartupMetric.OptimizationStatusWire.ODEX_STATUS_WIRE, v);
                }
            }
            if (self.compilation_filter) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidStartupMetric.OptimizationStatusWire.COMPILATION_FILTER_WIRE, v);
                }
            }
            if (self.compilation_reason) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidStartupMetric.OptimizationStatusWire.COMPILATION_REASON_WIRE, v);
                }
            }
            if (self.location) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidStartupMetric.OptimizationStatusWire.LOCATION_WIRE, v);
                }
            }
            if (self.summary) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidStartupMetric.OptimizationStatusWire.SUMMARY_WIRE, v);
                }
            }
        }
    };
    pub const OptimizationStatusReader = struct {
        buf: gremlin.Reader,
        _odex_status: ?[]const u8 = null,
        _compilation_filter: ?[]const u8 = null,
        _compilation_reason: ?[]const u8 = null,
        _location: ?[]const u8 = null,
        _summary: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!AndroidStartupMetric.OptimizationStatusReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidStartupMetric.OptimizationStatusReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidStartupMetric.OptimizationStatusWire.ODEX_STATUS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._odex_status = result.value;
                    },
                    AndroidStartupMetric.OptimizationStatusWire.COMPILATION_FILTER_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._compilation_filter = result.value;
                    },
                    AndroidStartupMetric.OptimizationStatusWire.COMPILATION_REASON_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._compilation_reason = result.value;
                    },
                    AndroidStartupMetric.OptimizationStatusWire.LOCATION_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._location = result.value;
                    },
                    AndroidStartupMetric.OptimizationStatusWire.SUMMARY_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._summary = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getOdexStatus(self: *const AndroidStartupMetric.OptimizationStatusReader) []const u8 {
            return self._odex_status orelse &[_]u8{};
        }
        pub inline fn getCompilationFilter(self: *const AndroidStartupMetric.OptimizationStatusReader) []const u8 {
            return self._compilation_filter orelse &[_]u8{};
        }
        pub inline fn getCompilationReason(self: *const AndroidStartupMetric.OptimizationStatusReader) []const u8 {
            return self._compilation_reason orelse &[_]u8{};
        }
        pub inline fn getLocation(self: *const AndroidStartupMetric.OptimizationStatusReader) []const u8 {
            return self._location orelse &[_]u8{};
        }
        pub inline fn getSummary(self: *const AndroidStartupMetric.OptimizationStatusReader) []const u8 {
            return self._summary orelse &[_]u8{};
        }
    };
    const VerifyClassWire = struct {
        const NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const DUR_NS_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const VerifyClass = struct {
        // fields
        name: ?[]const u8 = null,
        dur_ns: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidStartupMetric.VerifyClass) usize {
            var res: usize = 0;
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.VerifyClassWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.dur_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.VerifyClassWire.DUR_NS_WIRE) + gremlin.sizes.sizeI64(self.dur_ns);
            }
            return res;
        }
        pub fn encode(self: *const AndroidStartupMetric.VerifyClass, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidStartupMetric.VerifyClass, target: *gremlin.Writer) void {
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidStartupMetric.VerifyClassWire.NAME_WIRE, v);
                }
            }
            if (self.dur_ns != 0) {
                target.appendInt64(AndroidStartupMetric.VerifyClassWire.DUR_NS_WIRE, self.dur_ns);
            }
        }
    };
    pub const VerifyClassReader = struct {
        buf: gremlin.Reader,
        _name: ?[]const u8 = null,
        _dur_ns: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidStartupMetric.VerifyClassReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidStartupMetric.VerifyClassReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidStartupMetric.VerifyClassWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    AndroidStartupMetric.VerifyClassWire.DUR_NS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._dur_ns = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getName(self: *const AndroidStartupMetric.VerifyClassReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub inline fn getDurNs(self: *const AndroidStartupMetric.VerifyClassReader) i64 {
            return self._dur_ns;
        }
    };
    const EventTimestampsWire = struct {
        const INTENT_RECEIVED_WIRE: gremlin.ProtoWireNumber = 1;
        const FIRST_FRAME_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const EventTimestamps = struct {
        // fields
        intent_received: i64 = 0,
        first_frame: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidStartupMetric.EventTimestamps) usize {
            var res: usize = 0;
            if (self.intent_received != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.EventTimestampsWire.INTENT_RECEIVED_WIRE) + gremlin.sizes.sizeI64(self.intent_received);
            }
            if (self.first_frame != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.EventTimestampsWire.FIRST_FRAME_WIRE) + gremlin.sizes.sizeI64(self.first_frame);
            }
            return res;
        }
        pub fn encode(self: *const AndroidStartupMetric.EventTimestamps, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidStartupMetric.EventTimestamps, target: *gremlin.Writer) void {
            if (self.intent_received != 0) {
                target.appendInt64(AndroidStartupMetric.EventTimestampsWire.INTENT_RECEIVED_WIRE, self.intent_received);
            }
            if (self.first_frame != 0) {
                target.appendInt64(AndroidStartupMetric.EventTimestampsWire.FIRST_FRAME_WIRE, self.first_frame);
            }
        }
    };
    pub const EventTimestampsReader = struct {
        buf: gremlin.Reader,
        _intent_received: i64 = 0,
        _first_frame: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidStartupMetric.EventTimestampsReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidStartupMetric.EventTimestampsReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidStartupMetric.EventTimestampsWire.INTENT_RECEIVED_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._intent_received = result.value;
                    },
                    AndroidStartupMetric.EventTimestampsWire.FIRST_FRAME_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._first_frame = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getIntentReceived(self: *const AndroidStartupMetric.EventTimestampsReader) i64 {
            return self._intent_received;
        }
        pub inline fn getFirstFrame(self: *const AndroidStartupMetric.EventTimestampsReader) i64 {
            return self._first_frame;
        }
    };
    const SystemStateWire = struct {
        const DEX2OAT_RUNNING_WIRE: gremlin.ProtoWireNumber = 1;
        const INSTALLD_RUNNING_WIRE: gremlin.ProtoWireNumber = 2;
        const BROADCAST_DISPATCHED_COUNT_WIRE: gremlin.ProtoWireNumber = 3;
        const BROADCAST_RECEIVED_COUNT_WIRE: gremlin.ProtoWireNumber = 4;
        const MOST_ACTIVE_NON_LAUNCH_PROCESSES_WIRE: gremlin.ProtoWireNumber = 5;
        const INSTALLD_DUR_NS_WIRE: gremlin.ProtoWireNumber = 6;
        const DEX2OAT_DUR_NS_WIRE: gremlin.ProtoWireNumber = 7;
    };
    pub const SystemState = struct {
        // fields
        dex2oat_running: bool = false,
        installd_running: bool = false,
        broadcast_dispatched_count: i64 = 0,
        broadcast_received_count: i64 = 0,
        most_active_non_launch_processes: ?[]const ?[]const u8 = null,
        installd_dur_ns: i64 = 0,
        dex2oat_dur_ns: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidStartupMetric.SystemState) usize {
            var res: usize = 0;
            if (self.dex2oat_running != false) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.SystemStateWire.DEX2OAT_RUNNING_WIRE) + gremlin.sizes.sizeBool(self.dex2oat_running);
            }
            if (self.installd_running != false) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.SystemStateWire.INSTALLD_RUNNING_WIRE) + gremlin.sizes.sizeBool(self.installd_running);
            }
            if (self.broadcast_dispatched_count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.SystemStateWire.BROADCAST_DISPATCHED_COUNT_WIRE) + gremlin.sizes.sizeI64(self.broadcast_dispatched_count);
            }
            if (self.broadcast_received_count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.SystemStateWire.BROADCAST_RECEIVED_COUNT_WIRE) + gremlin.sizes.sizeI64(self.broadcast_received_count);
            }
            if (self.most_active_non_launch_processes) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.SystemStateWire.MOST_ACTIVE_NON_LAUNCH_PROCESSES_WIRE);
                    if (maybe_v) |v| {
                        res += gremlin.sizes.sizeUsize(v.len) + v.len;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.installd_dur_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.SystemStateWire.INSTALLD_DUR_NS_WIRE) + gremlin.sizes.sizeI64(self.installd_dur_ns);
            }
            if (self.dex2oat_dur_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.SystemStateWire.DEX2OAT_DUR_NS_WIRE) + gremlin.sizes.sizeI64(self.dex2oat_dur_ns);
            }
            return res;
        }
        pub fn encode(self: *const AndroidStartupMetric.SystemState, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidStartupMetric.SystemState, target: *gremlin.Writer) void {
            if (self.dex2oat_running != false) {
                target.appendBool(AndroidStartupMetric.SystemStateWire.DEX2OAT_RUNNING_WIRE, self.dex2oat_running);
            }
            if (self.installd_running != false) {
                target.appendBool(AndroidStartupMetric.SystemStateWire.INSTALLD_RUNNING_WIRE, self.installd_running);
            }
            if (self.broadcast_dispatched_count != 0) {
                target.appendInt64(AndroidStartupMetric.SystemStateWire.BROADCAST_DISPATCHED_COUNT_WIRE, self.broadcast_dispatched_count);
            }
            if (self.broadcast_received_count != 0) {
                target.appendInt64(AndroidStartupMetric.SystemStateWire.BROADCAST_RECEIVED_COUNT_WIRE, self.broadcast_received_count);
            }
            if (self.most_active_non_launch_processes) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        target.appendBytes(AndroidStartupMetric.SystemStateWire.MOST_ACTIVE_NON_LAUNCH_PROCESSES_WIRE, v);
                    } else {
                        target.appendBytesTag(AndroidStartupMetric.SystemStateWire.MOST_ACTIVE_NON_LAUNCH_PROCESSES_WIRE, 0);
                    }
                }
            }
            if (self.installd_dur_ns != 0) {
                target.appendInt64(AndroidStartupMetric.SystemStateWire.INSTALLD_DUR_NS_WIRE, self.installd_dur_ns);
            }
            if (self.dex2oat_dur_ns != 0) {
                target.appendInt64(AndroidStartupMetric.SystemStateWire.DEX2OAT_DUR_NS_WIRE, self.dex2oat_dur_ns);
            }
        }
    };
    pub const SystemStateReader = struct {
        buf: gremlin.Reader,
        _dex2oat_running: bool = false,
        _installd_running: bool = false,
        _broadcast_dispatched_count: i64 = 0,
        _broadcast_received_count: i64 = 0,
        _most_active_non_launch_processes_offset: ?usize = null,
        _most_active_non_launch_processes_last_offset: ?usize = null,
        _most_active_non_launch_processes_cnt: usize = 0,
        _installd_dur_ns: i64 = 0,
        _dex2oat_dur_ns: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidStartupMetric.SystemStateReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidStartupMetric.SystemStateReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidStartupMetric.SystemStateWire.DEX2OAT_RUNNING_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._dex2oat_running = result.value;
                    },
                    AndroidStartupMetric.SystemStateWire.INSTALLD_RUNNING_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._installd_running = result.value;
                    },
                    AndroidStartupMetric.SystemStateWire.BROADCAST_DISPATCHED_COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._broadcast_dispatched_count = result.value;
                    },
                    AndroidStartupMetric.SystemStateWire.BROADCAST_RECEIVED_COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._broadcast_received_count = result.value;
                    },
                    AndroidStartupMetric.SystemStateWire.MOST_ACTIVE_NON_LAUNCH_PROCESSES_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._most_active_non_launch_processes_offset == null) {
                            res._most_active_non_launch_processes_offset = offset - result.size;
                        }
                        res._most_active_non_launch_processes_last_offset = offset;
                        res._most_active_non_launch_processes_cnt += 1;
                    },
                    AndroidStartupMetric.SystemStateWire.INSTALLD_DUR_NS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._installd_dur_ns = result.value;
                    },
                    AndroidStartupMetric.SystemStateWire.DEX2OAT_DUR_NS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._dex2oat_dur_ns = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getDex2oatRunning(self: *const AndroidStartupMetric.SystemStateReader) bool {
            return self._dex2oat_running;
        }
        pub inline fn getInstalldRunning(self: *const AndroidStartupMetric.SystemStateReader) bool {
            return self._installd_running;
        }
        pub inline fn getBroadcastDispatchedCount(self: *const AndroidStartupMetric.SystemStateReader) i64 {
            return self._broadcast_dispatched_count;
        }
        pub inline fn getBroadcastReceivedCount(self: *const AndroidStartupMetric.SystemStateReader) i64 {
            return self._broadcast_received_count;
        }
        pub fn mostActiveNonLaunchProcessesCount(self: *const AndroidStartupMetric.SystemStateReader) usize {
            return self._most_active_non_launch_processes_cnt;
        }
        pub fn mostActiveNonLaunchProcessesNext(self: *AndroidStartupMetric.SystemStateReader) ?[]const u8 {
            if (self._most_active_non_launch_processes_offset == null) return null;
            const current_offset = self._most_active_non_launch_processes_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            if (self._most_active_non_launch_processes_last_offset != null and current_offset >= self._most_active_non_launch_processes_last_offset.?) {
                self._most_active_non_launch_processes_offset = null;
                return result.value;
            }
            if (self._most_active_non_launch_processes_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._most_active_non_launch_processes_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidStartupMetric.SystemStateWire.MOST_ACTIVE_NON_LAUNCH_PROCESSES_WIRE) {
                    self._most_active_non_launch_processes_offset = next_offset;
                    return result.value;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._most_active_non_launch_processes_offset = null;
            return result.value;
        }
        pub inline fn getInstalldDurNs(self: *const AndroidStartupMetric.SystemStateReader) i64 {
            return self._installd_dur_ns;
        }
        pub inline fn getDex2oatDurNs(self: *const AndroidStartupMetric.SystemStateReader) i64 {
            return self._dex2oat_dur_ns;
        }
    };
    const SlowStartReasonDetailedWire = struct {
        const REASON_WIRE: gremlin.ProtoWireNumber = 1;
        const DETAILS_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const SlowStartReasonDetailed = struct {
        // fields
        reason: ?[]const u8 = null,
        details: ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const AndroidStartupMetric.SlowStartReasonDetailed) usize {
            var res: usize = 0;
            if (self.reason) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.SlowStartReasonDetailedWire.REASON_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.details) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.SlowStartReasonDetailedWire.DETAILS_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidStartupMetric.SlowStartReasonDetailed, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidStartupMetric.SlowStartReasonDetailed, target: *gremlin.Writer) void {
            if (self.reason) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidStartupMetric.SlowStartReasonDetailedWire.REASON_WIRE, v);
                }
            }
            if (self.details) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidStartupMetric.SlowStartReasonDetailedWire.DETAILS_WIRE, v);
                }
            }
        }
    };
    pub const SlowStartReasonDetailedReader = struct {
        buf: gremlin.Reader,
        _reason: ?[]const u8 = null,
        _details: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!AndroidStartupMetric.SlowStartReasonDetailedReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidStartupMetric.SlowStartReasonDetailedReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidStartupMetric.SlowStartReasonDetailedWire.REASON_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._reason = result.value;
                    },
                    AndroidStartupMetric.SlowStartReasonDetailedWire.DETAILS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._details = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getReason(self: *const AndroidStartupMetric.SlowStartReasonDetailedReader) []const u8 {
            return self._reason orelse &[_]u8{};
        }
        pub inline fn getDetails(self: *const AndroidStartupMetric.SlowStartReasonDetailedReader) []const u8 {
            return self._details orelse &[_]u8{};
        }
    };
    const SlowStartReasonWire = struct {
        const REASON_ID_WIRE: gremlin.ProtoWireNumber = 1;
        const REASON_WIRE: gremlin.ProtoWireNumber = 2;
        const SEVERITY_WIRE: gremlin.ProtoWireNumber = 10;
        const EXPECTED_VALUE_WIRE: gremlin.ProtoWireNumber = 3;
        const ACTUAL_VALUE_WIRE: gremlin.ProtoWireNumber = 4;
        const LAUNCH_DUR_WIRE: gremlin.ProtoWireNumber = 5;
        const DURATION_WIRE: gremlin.ProtoWireNumber = 6;
        const TRACE_SLICE_SECTIONS_WIRE: gremlin.ProtoWireNumber = 7;
        const TRACE_THREAD_SECTIONS_WIRE: gremlin.ProtoWireNumber = 8;
        const ADDITIONAL_INFO_WIRE: gremlin.ProtoWireNumber = 9;
    };
    pub const SlowStartReason = struct {
        // nested enums
        pub const ReasonId = enum(i32) {
            REASON_ID_UNSPECIFIED = 0,
            NO_BASELINE_OR_CLOUD_PROFILES = 1,
            RUN_FROM_APK = 2,
            UNLOCK_RUNNING = 3,
            APP_IN_DEBUGGABLE_MODE = 4,
            GC_ACTIVITY = 5,
            DEX2_OAT_RUNNING = 6,
            INSTALLD_RUNNING = 7,
            MAIN_THREAD_TIME_SPENT_IN_RUNNABLE = 8,
            MAIN_THREAD_TIME_SPENT_IN_INTERRUPTIBLE_SLEEP = 9,
            MAIN_THREAD_TIME_SPENT_IN_BLOCKING_IO = 10,
            MAIN_THREAD_TIME_SPENT_IN_OPEN_DEX_FILES_FROM_OAT = 11,
            TIME_SPENT_IN_BIND_APPLICATION = 12,
            TIME_SPENT_IN_VIEW_INFLATION = 13,
            TIME_SPENT_IN_RESOURCES_MANAGER_GET_RESOURCES = 14,
            TIME_SPENT_VERIFYING_CLASSES = 15,
            POTENTIAL_CPU_CONTENTION_WITH_ANOTHER_PROCESS = 16,
            JIT_ACTIVITY = 17,
            MAIN_THREAD_LOCK_CONTENTION = 18,
            MAIN_THREAD_MONITOR_CONTENTION = 19,
            JIT_COMPILED_METHODS = 20,
            BROADCAST_DISPATCHED_COUNT = 21,
            BROADCAST_RECEIVED_COUNT = 22,
            STARTUP_RUNNING_CONCURRENT = 23,
            MAIN_THREAD_BINDER_TRANSCATIONS_BLOCKED = 24,
        };
        pub const SeverityLevel = enum(i32) {
            SEVERITY_UNSPECIFIED = 0,
            ERROR = 1,
            WARNING = 2,
            INFO = 3,
        };
        // fields
        reason_id: AndroidStartupMetric.SlowStartReason.ReasonId = @enumFromInt(0),
        reason: ?[]const u8 = null,
        severity: AndroidStartupMetric.SlowStartReason.SeverityLevel = @enumFromInt(0),
        expected_value: ?AndroidStartupMetric.ThresholdValue = null,
        actual_value: ?AndroidStartupMetric.ActualValue = null,
        launch_dur: i64 = 0,
        duration: i64 = 0,
        trace_slice_sections: ?AndroidStartupMetric.TraceSliceSectionInfo = null,
        trace_thread_sections: ?AndroidStartupMetric.TraceThreadSectionInfo = null,
        additional_info: ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const AndroidStartupMetric.SlowStartReason) usize {
            var res: usize = 0;
            if (@intFromEnum(self.reason_id) != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.SlowStartReasonWire.REASON_ID_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.reason_id));
            }
            if (self.reason) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.SlowStartReasonWire.REASON_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (@intFromEnum(self.severity) != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.SlowStartReasonWire.SEVERITY_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.severity));
            }
            if (self.expected_value) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.SlowStartReasonWire.EXPECTED_VALUE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.actual_value) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.SlowStartReasonWire.ACTUAL_VALUE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.launch_dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.SlowStartReasonWire.LAUNCH_DUR_WIRE) + gremlin.sizes.sizeI64(self.launch_dur);
            }
            if (self.duration != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.SlowStartReasonWire.DURATION_WIRE) + gremlin.sizes.sizeI64(self.duration);
            }
            if (self.trace_slice_sections) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.SlowStartReasonWire.TRACE_SLICE_SECTIONS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.trace_thread_sections) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.SlowStartReasonWire.TRACE_THREAD_SECTIONS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.additional_info) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.SlowStartReasonWire.ADDITIONAL_INFO_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidStartupMetric.SlowStartReason, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidStartupMetric.SlowStartReason, target: *gremlin.Writer) void {
            if (@intFromEnum(self.reason_id) != 0) {
                target.appendInt32(AndroidStartupMetric.SlowStartReasonWire.REASON_ID_WIRE, @intFromEnum(self.reason_id));
            }
            if (self.reason) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidStartupMetric.SlowStartReasonWire.REASON_WIRE, v);
                }
            }
            if (@intFromEnum(self.severity) != 0) {
                target.appendInt32(AndroidStartupMetric.SlowStartReasonWire.SEVERITY_WIRE, @intFromEnum(self.severity));
            }
            if (self.expected_value) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidStartupMetric.SlowStartReasonWire.EXPECTED_VALUE_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.actual_value) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidStartupMetric.SlowStartReasonWire.ACTUAL_VALUE_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.launch_dur != 0) {
                target.appendInt64(AndroidStartupMetric.SlowStartReasonWire.LAUNCH_DUR_WIRE, self.launch_dur);
            }
            if (self.duration != 0) {
                target.appendInt64(AndroidStartupMetric.SlowStartReasonWire.DURATION_WIRE, self.duration);
            }
            if (self.trace_slice_sections) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidStartupMetric.SlowStartReasonWire.TRACE_SLICE_SECTIONS_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.trace_thread_sections) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidStartupMetric.SlowStartReasonWire.TRACE_THREAD_SECTIONS_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.additional_info) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidStartupMetric.SlowStartReasonWire.ADDITIONAL_INFO_WIRE, v);
                }
            }
        }
    };
    pub const SlowStartReasonReader = struct {
        buf: gremlin.Reader,
        _reason_id: AndroidStartupMetric.SlowStartReason.ReasonId = @enumFromInt(0),
        _reason: ?[]const u8 = null,
        _severity: AndroidStartupMetric.SlowStartReason.SeverityLevel = @enumFromInt(0),
        _expected_value_buf: ?[]const u8 = null,
        _actual_value_buf: ?[]const u8 = null,
        _launch_dur: i64 = 0,
        _duration: i64 = 0,
        _trace_slice_sections_buf: ?[]const u8 = null,
        _trace_thread_sections_buf: ?[]const u8 = null,
        _additional_info: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!AndroidStartupMetric.SlowStartReasonReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidStartupMetric.SlowStartReasonReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidStartupMetric.SlowStartReasonWire.REASON_ID_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._reason_id = @enumFromInt(result.value);
                    },
                    AndroidStartupMetric.SlowStartReasonWire.REASON_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._reason = result.value;
                    },
                    AndroidStartupMetric.SlowStartReasonWire.SEVERITY_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._severity = @enumFromInt(result.value);
                    },
                    AndroidStartupMetric.SlowStartReasonWire.EXPECTED_VALUE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._expected_value_buf = result.value;
                    },
                    AndroidStartupMetric.SlowStartReasonWire.ACTUAL_VALUE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._actual_value_buf = result.value;
                    },
                    AndroidStartupMetric.SlowStartReasonWire.LAUNCH_DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._launch_dur = result.value;
                    },
                    AndroidStartupMetric.SlowStartReasonWire.DURATION_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._duration = result.value;
                    },
                    AndroidStartupMetric.SlowStartReasonWire.TRACE_SLICE_SECTIONS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._trace_slice_sections_buf = result.value;
                    },
                    AndroidStartupMetric.SlowStartReasonWire.TRACE_THREAD_SECTIONS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._trace_thread_sections_buf = result.value;
                    },
                    AndroidStartupMetric.SlowStartReasonWire.ADDITIONAL_INFO_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._additional_info = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getReasonId(self: *const AndroidStartupMetric.SlowStartReasonReader) AndroidStartupMetric.SlowStartReason.ReasonId {
            return self._reason_id;
        }
        pub inline fn getReason(self: *const AndroidStartupMetric.SlowStartReasonReader) []const u8 {
            return self._reason orelse &[_]u8{};
        }
        pub inline fn getSeverity(self: *const AndroidStartupMetric.SlowStartReasonReader) AndroidStartupMetric.SlowStartReason.SeverityLevel {
            return self._severity;
        }
        pub fn getExpectedValue(self: *const AndroidStartupMetric.SlowStartReasonReader) gremlin.Error!AndroidStartupMetric.ThresholdValueReader {
            if (self._expected_value_buf) |buf| {
                return try AndroidStartupMetric.ThresholdValueReader.init(buf);
            }
            return try AndroidStartupMetric.ThresholdValueReader.init(&[_]u8{});
        }
        pub fn getActualValue(self: *const AndroidStartupMetric.SlowStartReasonReader) gremlin.Error!AndroidStartupMetric.ActualValueReader {
            if (self._actual_value_buf) |buf| {
                return try AndroidStartupMetric.ActualValueReader.init(buf);
            }
            return try AndroidStartupMetric.ActualValueReader.init(&[_]u8{});
        }
        pub inline fn getLaunchDur(self: *const AndroidStartupMetric.SlowStartReasonReader) i64 {
            return self._launch_dur;
        }
        pub inline fn getDuration(self: *const AndroidStartupMetric.SlowStartReasonReader) i64 {
            return self._duration;
        }
        pub fn getTraceSliceSections(self: *const AndroidStartupMetric.SlowStartReasonReader) gremlin.Error!AndroidStartupMetric.TraceSliceSectionInfoReader {
            if (self._trace_slice_sections_buf) |buf| {
                return try AndroidStartupMetric.TraceSliceSectionInfoReader.init(buf);
            }
            return try AndroidStartupMetric.TraceSliceSectionInfoReader.init(&[_]u8{});
        }
        pub fn getTraceThreadSections(self: *const AndroidStartupMetric.SlowStartReasonReader) gremlin.Error!AndroidStartupMetric.TraceThreadSectionInfoReader {
            if (self._trace_thread_sections_buf) |buf| {
                return try AndroidStartupMetric.TraceThreadSectionInfoReader.init(buf);
            }
            return try AndroidStartupMetric.TraceThreadSectionInfoReader.init(&[_]u8{});
        }
        pub inline fn getAdditionalInfo(self: *const AndroidStartupMetric.SlowStartReasonReader) []const u8 {
            return self._additional_info orelse &[_]u8{};
        }
    };
    const ThresholdValueWire = struct {
        const VALUE_WIRE: gremlin.ProtoWireNumber = 1;
        const UNIT_WIRE: gremlin.ProtoWireNumber = 2;
        const HIGHER_EXPECTED_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const ThresholdValue = struct {
        // nested enums
        pub const ThresholdUnit = enum(i32) {
            THRESHOLD_UNIT_UNSPECIFIED = 0,
            NS = 1,
            PERCENTAGE = 2,
            TRUE_OR_FALSE = 3,
            COUNT = 4,
        };
        // fields
        value: i64 = 0,
        unit: AndroidStartupMetric.ThresholdValue.ThresholdUnit = @enumFromInt(0),
        higher_expected: bool = false,
        pub fn calcProtobufSize(self: *const AndroidStartupMetric.ThresholdValue) usize {
            var res: usize = 0;
            if (self.value != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.ThresholdValueWire.VALUE_WIRE) + gremlin.sizes.sizeI64(self.value);
            }
            if (@intFromEnum(self.unit) != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.ThresholdValueWire.UNIT_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.unit));
            }
            if (self.higher_expected != false) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.ThresholdValueWire.HIGHER_EXPECTED_WIRE) + gremlin.sizes.sizeBool(self.higher_expected);
            }
            return res;
        }
        pub fn encode(self: *const AndroidStartupMetric.ThresholdValue, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidStartupMetric.ThresholdValue, target: *gremlin.Writer) void {
            if (self.value != 0) {
                target.appendInt64(AndroidStartupMetric.ThresholdValueWire.VALUE_WIRE, self.value);
            }
            if (@intFromEnum(self.unit) != 0) {
                target.appendInt32(AndroidStartupMetric.ThresholdValueWire.UNIT_WIRE, @intFromEnum(self.unit));
            }
            if (self.higher_expected != false) {
                target.appendBool(AndroidStartupMetric.ThresholdValueWire.HIGHER_EXPECTED_WIRE, self.higher_expected);
            }
        }
    };
    pub const ThresholdValueReader = struct {
        buf: gremlin.Reader,
        _value: i64 = 0,
        _unit: AndroidStartupMetric.ThresholdValue.ThresholdUnit = @enumFromInt(0),
        _higher_expected: bool = false,
        pub fn init(src: []const u8) gremlin.Error!AndroidStartupMetric.ThresholdValueReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidStartupMetric.ThresholdValueReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidStartupMetric.ThresholdValueWire.VALUE_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._value = result.value;
                    },
                    AndroidStartupMetric.ThresholdValueWire.UNIT_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._unit = @enumFromInt(result.value);
                    },
                    AndroidStartupMetric.ThresholdValueWire.HIGHER_EXPECTED_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._higher_expected = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getValue(self: *const AndroidStartupMetric.ThresholdValueReader) i64 {
            return self._value;
        }
        pub inline fn getUnit(self: *const AndroidStartupMetric.ThresholdValueReader) AndroidStartupMetric.ThresholdValue.ThresholdUnit {
            return self._unit;
        }
        pub inline fn getHigherExpected(self: *const AndroidStartupMetric.ThresholdValueReader) bool {
            return self._higher_expected;
        }
    };
    const ActualValueWire = struct {
        const VALUE_WIRE: gremlin.ProtoWireNumber = 1;
        const DUR_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const ActualValue = struct {
        // fields
        value: i64 = 0,
        dur: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidStartupMetric.ActualValue) usize {
            var res: usize = 0;
            if (self.value != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.ActualValueWire.VALUE_WIRE) + gremlin.sizes.sizeI64(self.value);
            }
            if (self.dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.ActualValueWire.DUR_WIRE) + gremlin.sizes.sizeI64(self.dur);
            }
            return res;
        }
        pub fn encode(self: *const AndroidStartupMetric.ActualValue, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidStartupMetric.ActualValue, target: *gremlin.Writer) void {
            if (self.value != 0) {
                target.appendInt64(AndroidStartupMetric.ActualValueWire.VALUE_WIRE, self.value);
            }
            if (self.dur != 0) {
                target.appendInt64(AndroidStartupMetric.ActualValueWire.DUR_WIRE, self.dur);
            }
        }
    };
    pub const ActualValueReader = struct {
        buf: gremlin.Reader,
        _value: i64 = 0,
        _dur: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidStartupMetric.ActualValueReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidStartupMetric.ActualValueReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidStartupMetric.ActualValueWire.VALUE_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._value = result.value;
                    },
                    AndroidStartupMetric.ActualValueWire.DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._dur = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getValue(self: *const AndroidStartupMetric.ActualValueReader) i64 {
            return self._value;
        }
        pub inline fn getDur(self: *const AndroidStartupMetric.ActualValueReader) i64 {
            return self._dur;
        }
    };
    const TraceSliceSectionWire = struct {
        const START_TIMESTAMP_WIRE: gremlin.ProtoWireNumber = 1;
        const END_TIMESTAMP_WIRE: gremlin.ProtoWireNumber = 2;
        const SLICE_ID_WIRE: gremlin.ProtoWireNumber = 3;
        const SLICE_NAME_WIRE: gremlin.ProtoWireNumber = 4;
        const PROCESS_PID_WIRE: gremlin.ProtoWireNumber = 5;
        const THREAD_TID_WIRE: gremlin.ProtoWireNumber = 6;
    };
    pub const TraceSliceSection = struct {
        // fields
        start_timestamp: i64 = 0,
        end_timestamp: i64 = 0,
        slice_id: u32 = 0,
        slice_name: ?[]const u8 = null,
        process_pid: u32 = 0,
        thread_tid: u32 = 0,
        pub fn calcProtobufSize(self: *const AndroidStartupMetric.TraceSliceSection) usize {
            var res: usize = 0;
            if (self.start_timestamp != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.TraceSliceSectionWire.START_TIMESTAMP_WIRE) + gremlin.sizes.sizeI64(self.start_timestamp);
            }
            if (self.end_timestamp != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.TraceSliceSectionWire.END_TIMESTAMP_WIRE) + gremlin.sizes.sizeI64(self.end_timestamp);
            }
            if (self.slice_id != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.TraceSliceSectionWire.SLICE_ID_WIRE) + gremlin.sizes.sizeU32(self.slice_id);
            }
            if (self.slice_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.TraceSliceSectionWire.SLICE_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.process_pid != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.TraceSliceSectionWire.PROCESS_PID_WIRE) + gremlin.sizes.sizeU32(self.process_pid);
            }
            if (self.thread_tid != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.TraceSliceSectionWire.THREAD_TID_WIRE) + gremlin.sizes.sizeU32(self.thread_tid);
            }
            return res;
        }
        pub fn encode(self: *const AndroidStartupMetric.TraceSliceSection, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidStartupMetric.TraceSliceSection, target: *gremlin.Writer) void {
            if (self.start_timestamp != 0) {
                target.appendInt64(AndroidStartupMetric.TraceSliceSectionWire.START_TIMESTAMP_WIRE, self.start_timestamp);
            }
            if (self.end_timestamp != 0) {
                target.appendInt64(AndroidStartupMetric.TraceSliceSectionWire.END_TIMESTAMP_WIRE, self.end_timestamp);
            }
            if (self.slice_id != 0) {
                target.appendUint32(AndroidStartupMetric.TraceSliceSectionWire.SLICE_ID_WIRE, self.slice_id);
            }
            if (self.slice_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidStartupMetric.TraceSliceSectionWire.SLICE_NAME_WIRE, v);
                }
            }
            if (self.process_pid != 0) {
                target.appendUint32(AndroidStartupMetric.TraceSliceSectionWire.PROCESS_PID_WIRE, self.process_pid);
            }
            if (self.thread_tid != 0) {
                target.appendUint32(AndroidStartupMetric.TraceSliceSectionWire.THREAD_TID_WIRE, self.thread_tid);
            }
        }
    };
    pub const TraceSliceSectionReader = struct {
        buf: gremlin.Reader,
        _start_timestamp: i64 = 0,
        _end_timestamp: i64 = 0,
        _slice_id: u32 = 0,
        _slice_name: ?[]const u8 = null,
        _process_pid: u32 = 0,
        _thread_tid: u32 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidStartupMetric.TraceSliceSectionReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidStartupMetric.TraceSliceSectionReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidStartupMetric.TraceSliceSectionWire.START_TIMESTAMP_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._start_timestamp = result.value;
                    },
                    AndroidStartupMetric.TraceSliceSectionWire.END_TIMESTAMP_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._end_timestamp = result.value;
                    },
                    AndroidStartupMetric.TraceSliceSectionWire.SLICE_ID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._slice_id = result.value;
                    },
                    AndroidStartupMetric.TraceSliceSectionWire.SLICE_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._slice_name = result.value;
                    },
                    AndroidStartupMetric.TraceSliceSectionWire.PROCESS_PID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._process_pid = result.value;
                    },
                    AndroidStartupMetric.TraceSliceSectionWire.THREAD_TID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._thread_tid = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getStartTimestamp(self: *const AndroidStartupMetric.TraceSliceSectionReader) i64 {
            return self._start_timestamp;
        }
        pub inline fn getEndTimestamp(self: *const AndroidStartupMetric.TraceSliceSectionReader) i64 {
            return self._end_timestamp;
        }
        pub inline fn getSliceId(self: *const AndroidStartupMetric.TraceSliceSectionReader) u32 {
            return self._slice_id;
        }
        pub inline fn getSliceName(self: *const AndroidStartupMetric.TraceSliceSectionReader) []const u8 {
            return self._slice_name orelse &[_]u8{};
        }
        pub inline fn getProcessPid(self: *const AndroidStartupMetric.TraceSliceSectionReader) u32 {
            return self._process_pid;
        }
        pub inline fn getThreadTid(self: *const AndroidStartupMetric.TraceSliceSectionReader) u32 {
            return self._thread_tid;
        }
    };
    const TraceSliceSectionInfoWire = struct {
        const SLICE_SECTION_WIRE: gremlin.ProtoWireNumber = 1;
        const START_TIMESTAMP_WIRE: gremlin.ProtoWireNumber = 2;
        const END_TIMESTAMP_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const TraceSliceSectionInfo = struct {
        // fields
        slice_section: ?[]const ?AndroidStartupMetric.TraceSliceSection = null,
        start_timestamp: i64 = 0,
        end_timestamp: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidStartupMetric.TraceSliceSectionInfo) usize {
            var res: usize = 0;
            if (self.slice_section) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.TraceSliceSectionInfoWire.SLICE_SECTION_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.start_timestamp != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.TraceSliceSectionInfoWire.START_TIMESTAMP_WIRE) + gremlin.sizes.sizeI64(self.start_timestamp);
            }
            if (self.end_timestamp != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.TraceSliceSectionInfoWire.END_TIMESTAMP_WIRE) + gremlin.sizes.sizeI64(self.end_timestamp);
            }
            return res;
        }
        pub fn encode(self: *const AndroidStartupMetric.TraceSliceSectionInfo, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidStartupMetric.TraceSliceSectionInfo, target: *gremlin.Writer) void {
            if (self.slice_section) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidStartupMetric.TraceSliceSectionInfoWire.SLICE_SECTION_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidStartupMetric.TraceSliceSectionInfoWire.SLICE_SECTION_WIRE, 0);
                    }
                }
            }
            if (self.start_timestamp != 0) {
                target.appendInt64(AndroidStartupMetric.TraceSliceSectionInfoWire.START_TIMESTAMP_WIRE, self.start_timestamp);
            }
            if (self.end_timestamp != 0) {
                target.appendInt64(AndroidStartupMetric.TraceSliceSectionInfoWire.END_TIMESTAMP_WIRE, self.end_timestamp);
            }
        }
    };
    pub const TraceSliceSectionInfoReader = struct {
        buf: gremlin.Reader,
        _slice_section_offset: ?usize = null,
        _slice_section_last_offset: ?usize = null,
        _slice_section_cnt: usize = 0,
        _start_timestamp: i64 = 0,
        _end_timestamp: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidStartupMetric.TraceSliceSectionInfoReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidStartupMetric.TraceSliceSectionInfoReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidStartupMetric.TraceSliceSectionInfoWire.SLICE_SECTION_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._slice_section_offset == null) {
                            res._slice_section_offset = offset - result.size;
                        }
                        res._slice_section_last_offset = offset;
                        res._slice_section_cnt += 1;
                    },
                    AndroidStartupMetric.TraceSliceSectionInfoWire.START_TIMESTAMP_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._start_timestamp = result.value;
                    },
                    AndroidStartupMetric.TraceSliceSectionInfoWire.END_TIMESTAMP_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._end_timestamp = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn sliceSectionCount(self: *const AndroidStartupMetric.TraceSliceSectionInfoReader) usize {
            return self._slice_section_cnt;
        }
        pub fn sliceSectionNext(self: *AndroidStartupMetric.TraceSliceSectionInfoReader) ?AndroidStartupMetric.TraceSliceSectionReader {
            if (self._slice_section_offset == null) return null;
            const current_offset = self._slice_section_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidStartupMetric.TraceSliceSectionReader.init(result.value) catch return null;
            if (self._slice_section_last_offset != null and current_offset >= self._slice_section_last_offset.?) {
                self._slice_section_offset = null;
                return msg;
            }
            if (self._slice_section_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._slice_section_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidStartupMetric.TraceSliceSectionInfoWire.SLICE_SECTION_WIRE) {
                    self._slice_section_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._slice_section_offset = null;
            return msg;
        }
        pub inline fn getStartTimestamp(self: *const AndroidStartupMetric.TraceSliceSectionInfoReader) i64 {
            return self._start_timestamp;
        }
        pub inline fn getEndTimestamp(self: *const AndroidStartupMetric.TraceSliceSectionInfoReader) i64 {
            return self._end_timestamp;
        }
    };
    const TraceThreadSectionWire = struct {
        const START_TIMESTAMP_WIRE: gremlin.ProtoWireNumber = 1;
        const END_TIMESTAMP_WIRE: gremlin.ProtoWireNumber = 2;
        const THREAD_UTID_WIRE: gremlin.ProtoWireNumber = 3;
        const THREAD_NAME_WIRE: gremlin.ProtoWireNumber = 4;
        const PROCESS_PID_WIRE: gremlin.ProtoWireNumber = 5;
        const THREAD_TID_WIRE: gremlin.ProtoWireNumber = 6;
    };
    pub const TraceThreadSection = struct {
        // fields
        start_timestamp: i64 = 0,
        end_timestamp: i64 = 0,
        thread_utid: u32 = 0,
        thread_name: ?[]const u8 = null,
        process_pid: u32 = 0,
        thread_tid: u32 = 0,
        pub fn calcProtobufSize(self: *const AndroidStartupMetric.TraceThreadSection) usize {
            var res: usize = 0;
            if (self.start_timestamp != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.TraceThreadSectionWire.START_TIMESTAMP_WIRE) + gremlin.sizes.sizeI64(self.start_timestamp);
            }
            if (self.end_timestamp != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.TraceThreadSectionWire.END_TIMESTAMP_WIRE) + gremlin.sizes.sizeI64(self.end_timestamp);
            }
            if (self.thread_utid != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.TraceThreadSectionWire.THREAD_UTID_WIRE) + gremlin.sizes.sizeU32(self.thread_utid);
            }
            if (self.thread_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.TraceThreadSectionWire.THREAD_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.process_pid != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.TraceThreadSectionWire.PROCESS_PID_WIRE) + gremlin.sizes.sizeU32(self.process_pid);
            }
            if (self.thread_tid != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.TraceThreadSectionWire.THREAD_TID_WIRE) + gremlin.sizes.sizeU32(self.thread_tid);
            }
            return res;
        }
        pub fn encode(self: *const AndroidStartupMetric.TraceThreadSection, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidStartupMetric.TraceThreadSection, target: *gremlin.Writer) void {
            if (self.start_timestamp != 0) {
                target.appendInt64(AndroidStartupMetric.TraceThreadSectionWire.START_TIMESTAMP_WIRE, self.start_timestamp);
            }
            if (self.end_timestamp != 0) {
                target.appendInt64(AndroidStartupMetric.TraceThreadSectionWire.END_TIMESTAMP_WIRE, self.end_timestamp);
            }
            if (self.thread_utid != 0) {
                target.appendUint32(AndroidStartupMetric.TraceThreadSectionWire.THREAD_UTID_WIRE, self.thread_utid);
            }
            if (self.thread_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidStartupMetric.TraceThreadSectionWire.THREAD_NAME_WIRE, v);
                }
            }
            if (self.process_pid != 0) {
                target.appendUint32(AndroidStartupMetric.TraceThreadSectionWire.PROCESS_PID_WIRE, self.process_pid);
            }
            if (self.thread_tid != 0) {
                target.appendUint32(AndroidStartupMetric.TraceThreadSectionWire.THREAD_TID_WIRE, self.thread_tid);
            }
        }
    };
    pub const TraceThreadSectionReader = struct {
        buf: gremlin.Reader,
        _start_timestamp: i64 = 0,
        _end_timestamp: i64 = 0,
        _thread_utid: u32 = 0,
        _thread_name: ?[]const u8 = null,
        _process_pid: u32 = 0,
        _thread_tid: u32 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidStartupMetric.TraceThreadSectionReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidStartupMetric.TraceThreadSectionReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidStartupMetric.TraceThreadSectionWire.START_TIMESTAMP_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._start_timestamp = result.value;
                    },
                    AndroidStartupMetric.TraceThreadSectionWire.END_TIMESTAMP_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._end_timestamp = result.value;
                    },
                    AndroidStartupMetric.TraceThreadSectionWire.THREAD_UTID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._thread_utid = result.value;
                    },
                    AndroidStartupMetric.TraceThreadSectionWire.THREAD_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._thread_name = result.value;
                    },
                    AndroidStartupMetric.TraceThreadSectionWire.PROCESS_PID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._process_pid = result.value;
                    },
                    AndroidStartupMetric.TraceThreadSectionWire.THREAD_TID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._thread_tid = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getStartTimestamp(self: *const AndroidStartupMetric.TraceThreadSectionReader) i64 {
            return self._start_timestamp;
        }
        pub inline fn getEndTimestamp(self: *const AndroidStartupMetric.TraceThreadSectionReader) i64 {
            return self._end_timestamp;
        }
        pub inline fn getThreadUtid(self: *const AndroidStartupMetric.TraceThreadSectionReader) u32 {
            return self._thread_utid;
        }
        pub inline fn getThreadName(self: *const AndroidStartupMetric.TraceThreadSectionReader) []const u8 {
            return self._thread_name orelse &[_]u8{};
        }
        pub inline fn getProcessPid(self: *const AndroidStartupMetric.TraceThreadSectionReader) u32 {
            return self._process_pid;
        }
        pub inline fn getThreadTid(self: *const AndroidStartupMetric.TraceThreadSectionReader) u32 {
            return self._thread_tid;
        }
    };
    const TraceThreadSectionInfoWire = struct {
        const THREAD_SECTION_WIRE: gremlin.ProtoWireNumber = 1;
        const START_TIMESTAMP_WIRE: gremlin.ProtoWireNumber = 2;
        const END_TIMESTAMP_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const TraceThreadSectionInfo = struct {
        // fields
        thread_section: ?[]const ?AndroidStartupMetric.TraceThreadSection = null,
        start_timestamp: i64 = 0,
        end_timestamp: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidStartupMetric.TraceThreadSectionInfo) usize {
            var res: usize = 0;
            if (self.thread_section) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.TraceThreadSectionInfoWire.THREAD_SECTION_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.start_timestamp != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.TraceThreadSectionInfoWire.START_TIMESTAMP_WIRE) + gremlin.sizes.sizeI64(self.start_timestamp);
            }
            if (self.end_timestamp != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.TraceThreadSectionInfoWire.END_TIMESTAMP_WIRE) + gremlin.sizes.sizeI64(self.end_timestamp);
            }
            return res;
        }
        pub fn encode(self: *const AndroidStartupMetric.TraceThreadSectionInfo, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidStartupMetric.TraceThreadSectionInfo, target: *gremlin.Writer) void {
            if (self.thread_section) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidStartupMetric.TraceThreadSectionInfoWire.THREAD_SECTION_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidStartupMetric.TraceThreadSectionInfoWire.THREAD_SECTION_WIRE, 0);
                    }
                }
            }
            if (self.start_timestamp != 0) {
                target.appendInt64(AndroidStartupMetric.TraceThreadSectionInfoWire.START_TIMESTAMP_WIRE, self.start_timestamp);
            }
            if (self.end_timestamp != 0) {
                target.appendInt64(AndroidStartupMetric.TraceThreadSectionInfoWire.END_TIMESTAMP_WIRE, self.end_timestamp);
            }
        }
    };
    pub const TraceThreadSectionInfoReader = struct {
        buf: gremlin.Reader,
        _thread_section_offset: ?usize = null,
        _thread_section_last_offset: ?usize = null,
        _thread_section_cnt: usize = 0,
        _start_timestamp: i64 = 0,
        _end_timestamp: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidStartupMetric.TraceThreadSectionInfoReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidStartupMetric.TraceThreadSectionInfoReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidStartupMetric.TraceThreadSectionInfoWire.THREAD_SECTION_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._thread_section_offset == null) {
                            res._thread_section_offset = offset - result.size;
                        }
                        res._thread_section_last_offset = offset;
                        res._thread_section_cnt += 1;
                    },
                    AndroidStartupMetric.TraceThreadSectionInfoWire.START_TIMESTAMP_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._start_timestamp = result.value;
                    },
                    AndroidStartupMetric.TraceThreadSectionInfoWire.END_TIMESTAMP_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._end_timestamp = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn threadSectionCount(self: *const AndroidStartupMetric.TraceThreadSectionInfoReader) usize {
            return self._thread_section_cnt;
        }
        pub fn threadSectionNext(self: *AndroidStartupMetric.TraceThreadSectionInfoReader) ?AndroidStartupMetric.TraceThreadSectionReader {
            if (self._thread_section_offset == null) return null;
            const current_offset = self._thread_section_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidStartupMetric.TraceThreadSectionReader.init(result.value) catch return null;
            if (self._thread_section_last_offset != null and current_offset >= self._thread_section_last_offset.?) {
                self._thread_section_offset = null;
                return msg;
            }
            if (self._thread_section_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._thread_section_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidStartupMetric.TraceThreadSectionInfoWire.THREAD_SECTION_WIRE) {
                    self._thread_section_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._thread_section_offset = null;
            return msg;
        }
        pub inline fn getStartTimestamp(self: *const AndroidStartupMetric.TraceThreadSectionInfoReader) i64 {
            return self._start_timestamp;
        }
        pub inline fn getEndTimestamp(self: *const AndroidStartupMetric.TraceThreadSectionInfoReader) i64 {
            return self._end_timestamp;
        }
    };
    const StartupWire = struct {
        const STARTUP_ID_WIRE: gremlin.ProtoWireNumber = 1;
        const STARTUP_TYPE_WIRE: gremlin.ProtoWireNumber = 16;
        const CPU_COUNT_WIRE: gremlin.ProtoWireNumber = 25;
        const PACKAGE_NAME_WIRE: gremlin.ProtoWireNumber = 2;
        const PROCESS_NAME_WIRE: gremlin.ProtoWireNumber = 3;
        const ACTIVITIES_WIRE: gremlin.ProtoWireNumber = 11;
        const LONG_BINDER_TRANSACTIONS_WIRE: gremlin.ProtoWireNumber = 14;
        const ZYGOTE_NEW_PROCESS_WIRE: gremlin.ProtoWireNumber = 4;
        const ACTIVITY_HOSTING_PROCESS_COUNT_WIRE: gremlin.ProtoWireNumber = 6;
        const TIME_TO_INITIAL_DISPLAY_WIRE: gremlin.ProtoWireNumber = 22;
        const TIME_TO_FULL_DISPLAY_WIRE: gremlin.ProtoWireNumber = 23;
        const EVENT_TIMESTAMPS_WIRE: gremlin.ProtoWireNumber = 13;
        const TO_FIRST_FRAME_WIRE: gremlin.ProtoWireNumber = 5;
        const PROCESS_WIRE: gremlin.ProtoWireNumber = 7;
        const HSC_WIRE: gremlin.ProtoWireNumber = 8;
        const REPORT_FULLY_DRAWN_WIRE: gremlin.ProtoWireNumber = 9;
        const OPTIMIZATION_STATUS_WIRE: gremlin.ProtoWireNumber = 12;
        const VERIFY_CLASS_WIRE: gremlin.ProtoWireNumber = 19;
        const DLOPEN_FILE_WIRE: gremlin.ProtoWireNumber = 20;
        const STARTUP_CONCURRENT_TO_LAUNCH_WIRE: gremlin.ProtoWireNumber = 18;
        const SYSTEM_STATE_WIRE: gremlin.ProtoWireNumber = 15;
        const SLOW_START_REASON_WIRE: gremlin.ProtoWireNumber = 17;
        const SLOW_START_REASON_DETAILED_WIRE: gremlin.ProtoWireNumber = 21;
        const SLOW_START_REASON_WITH_DETAILS_WIRE: gremlin.ProtoWireNumber = 24;
    };
    pub const Startup = struct {
        // fields
        startup_id: u32 = 0,
        startup_type: ?[]const u8 = null,
        cpu_count: u32 = 0,
        package_name: ?[]const u8 = null,
        process_name: ?[]const u8 = null,
        activities: ?[]const ?AndroidStartupMetric.Activity = null,
        long_binder_transactions: ?[]const ?AndroidStartupMetric.BinderTransaction = null,
        zygote_new_process: bool = false,
        activity_hosting_process_count: u32 = 0,
        time_to_initial_display: i64 = 0,
        time_to_full_display: i64 = 0,
        event_timestamps: ?AndroidStartupMetric.EventTimestamps = null,
        to_first_frame: ?AndroidStartupMetric.ToFirstFrame = null,
        process: ?AndroidProcessMetadata = null,
        hsc: ?AndroidStartupMetric.HscMetrics = null,
        report_fully_drawn: ?AndroidStartupMetric.Slice = null,
        optimization_status: ?[]const ?AndroidStartupMetric.OptimizationStatus = null,
        verify_class: ?[]const ?AndroidStartupMetric.VerifyClass = null,
        dlopen_file: ?[]const ?[]const u8 = null,
        startup_concurrent_to_launch: ?[]const ?[]const u8 = null,
        system_state: ?AndroidStartupMetric.SystemState = null,
        slow_start_reason: ?[]const ?[]const u8 = null,
        slow_start_reason_detailed: ?[]const ?AndroidStartupMetric.SlowStartReasonDetailed = null,
        slow_start_reason_with_details: ?[]const ?AndroidStartupMetric.SlowStartReason = null,
        pub fn calcProtobufSize(self: *const AndroidStartupMetric.Startup) usize {
            var res: usize = 0;
            if (self.startup_id != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.StartupWire.STARTUP_ID_WIRE) + gremlin.sizes.sizeU32(self.startup_id);
            }
            if (self.startup_type) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.StartupWire.STARTUP_TYPE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.cpu_count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.StartupWire.CPU_COUNT_WIRE) + gremlin.sizes.sizeU32(self.cpu_count);
            }
            if (self.package_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.StartupWire.PACKAGE_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.process_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.StartupWire.PROCESS_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.activities) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.StartupWire.ACTIVITIES_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.long_binder_transactions) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.StartupWire.LONG_BINDER_TRANSACTIONS_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.zygote_new_process != false) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.StartupWire.ZYGOTE_NEW_PROCESS_WIRE) + gremlin.sizes.sizeBool(self.zygote_new_process);
            }
            if (self.activity_hosting_process_count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.StartupWire.ACTIVITY_HOSTING_PROCESS_COUNT_WIRE) + gremlin.sizes.sizeU32(self.activity_hosting_process_count);
            }
            if (self.time_to_initial_display != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.StartupWire.TIME_TO_INITIAL_DISPLAY_WIRE) + gremlin.sizes.sizeI64(self.time_to_initial_display);
            }
            if (self.time_to_full_display != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.StartupWire.TIME_TO_FULL_DISPLAY_WIRE) + gremlin.sizes.sizeI64(self.time_to_full_display);
            }
            if (self.event_timestamps) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.StartupWire.EVENT_TIMESTAMPS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.to_first_frame) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.StartupWire.TO_FIRST_FRAME_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.process) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.StartupWire.PROCESS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.hsc) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.StartupWire.HSC_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.report_fully_drawn) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.StartupWire.REPORT_FULLY_DRAWN_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.optimization_status) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.StartupWire.OPTIMIZATION_STATUS_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.verify_class) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.StartupWire.VERIFY_CLASS_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.dlopen_file) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.StartupWire.DLOPEN_FILE_WIRE);
                    if (maybe_v) |v| {
                        res += gremlin.sizes.sizeUsize(v.len) + v.len;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.startup_concurrent_to_launch) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.StartupWire.STARTUP_CONCURRENT_TO_LAUNCH_WIRE);
                    if (maybe_v) |v| {
                        res += gremlin.sizes.sizeUsize(v.len) + v.len;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.system_state) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.StartupWire.SYSTEM_STATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.slow_start_reason) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.StartupWire.SLOW_START_REASON_WIRE);
                    if (maybe_v) |v| {
                        res += gremlin.sizes.sizeUsize(v.len) + v.len;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.slow_start_reason_detailed) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.StartupWire.SLOW_START_REASON_DETAILED_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.slow_start_reason_with_details) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidStartupMetric.StartupWire.SLOW_START_REASON_WITH_DETAILS_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidStartupMetric.Startup, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidStartupMetric.Startup, target: *gremlin.Writer) void {
            if (self.startup_id != 0) {
                target.appendUint32(AndroidStartupMetric.StartupWire.STARTUP_ID_WIRE, self.startup_id);
            }
            if (self.startup_type) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidStartupMetric.StartupWire.STARTUP_TYPE_WIRE, v);
                }
            }
            if (self.cpu_count != 0) {
                target.appendUint32(AndroidStartupMetric.StartupWire.CPU_COUNT_WIRE, self.cpu_count);
            }
            if (self.package_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidStartupMetric.StartupWire.PACKAGE_NAME_WIRE, v);
                }
            }
            if (self.process_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidStartupMetric.StartupWire.PROCESS_NAME_WIRE, v);
                }
            }
            if (self.activities) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidStartupMetric.StartupWire.ACTIVITIES_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidStartupMetric.StartupWire.ACTIVITIES_WIRE, 0);
                    }
                }
            }
            if (self.long_binder_transactions) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidStartupMetric.StartupWire.LONG_BINDER_TRANSACTIONS_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidStartupMetric.StartupWire.LONG_BINDER_TRANSACTIONS_WIRE, 0);
                    }
                }
            }
            if (self.zygote_new_process != false) {
                target.appendBool(AndroidStartupMetric.StartupWire.ZYGOTE_NEW_PROCESS_WIRE, self.zygote_new_process);
            }
            if (self.activity_hosting_process_count != 0) {
                target.appendUint32(AndroidStartupMetric.StartupWire.ACTIVITY_HOSTING_PROCESS_COUNT_WIRE, self.activity_hosting_process_count);
            }
            if (self.time_to_initial_display != 0) {
                target.appendInt64(AndroidStartupMetric.StartupWire.TIME_TO_INITIAL_DISPLAY_WIRE, self.time_to_initial_display);
            }
            if (self.time_to_full_display != 0) {
                target.appendInt64(AndroidStartupMetric.StartupWire.TIME_TO_FULL_DISPLAY_WIRE, self.time_to_full_display);
            }
            if (self.event_timestamps) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidStartupMetric.StartupWire.EVENT_TIMESTAMPS_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.to_first_frame) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidStartupMetric.StartupWire.TO_FIRST_FRAME_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.process) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidStartupMetric.StartupWire.PROCESS_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.hsc) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidStartupMetric.StartupWire.HSC_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.report_fully_drawn) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidStartupMetric.StartupWire.REPORT_FULLY_DRAWN_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.optimization_status) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidStartupMetric.StartupWire.OPTIMIZATION_STATUS_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidStartupMetric.StartupWire.OPTIMIZATION_STATUS_WIRE, 0);
                    }
                }
            }
            if (self.verify_class) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidStartupMetric.StartupWire.VERIFY_CLASS_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidStartupMetric.StartupWire.VERIFY_CLASS_WIRE, 0);
                    }
                }
            }
            if (self.dlopen_file) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        target.appendBytes(AndroidStartupMetric.StartupWire.DLOPEN_FILE_WIRE, v);
                    } else {
                        target.appendBytesTag(AndroidStartupMetric.StartupWire.DLOPEN_FILE_WIRE, 0);
                    }
                }
            }
            if (self.startup_concurrent_to_launch) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        target.appendBytes(AndroidStartupMetric.StartupWire.STARTUP_CONCURRENT_TO_LAUNCH_WIRE, v);
                    } else {
                        target.appendBytesTag(AndroidStartupMetric.StartupWire.STARTUP_CONCURRENT_TO_LAUNCH_WIRE, 0);
                    }
                }
            }
            if (self.system_state) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidStartupMetric.StartupWire.SYSTEM_STATE_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.slow_start_reason) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        target.appendBytes(AndroidStartupMetric.StartupWire.SLOW_START_REASON_WIRE, v);
                    } else {
                        target.appendBytesTag(AndroidStartupMetric.StartupWire.SLOW_START_REASON_WIRE, 0);
                    }
                }
            }
            if (self.slow_start_reason_detailed) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidStartupMetric.StartupWire.SLOW_START_REASON_DETAILED_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidStartupMetric.StartupWire.SLOW_START_REASON_DETAILED_WIRE, 0);
                    }
                }
            }
            if (self.slow_start_reason_with_details) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidStartupMetric.StartupWire.SLOW_START_REASON_WITH_DETAILS_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidStartupMetric.StartupWire.SLOW_START_REASON_WITH_DETAILS_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const StartupReader = struct {
        buf: gremlin.Reader,
        _startup_id: u32 = 0,
        _startup_type: ?[]const u8 = null,
        _cpu_count: u32 = 0,
        _package_name: ?[]const u8 = null,
        _process_name: ?[]const u8 = null,
        _activities_offset: ?usize = null,
        _activities_last_offset: ?usize = null,
        _activities_cnt: usize = 0,
        _long_binder_transactions_offset: ?usize = null,
        _long_binder_transactions_last_offset: ?usize = null,
        _long_binder_transactions_cnt: usize = 0,
        _zygote_new_process: bool = false,
        _activity_hosting_process_count: u32 = 0,
        _time_to_initial_display: i64 = 0,
        _time_to_full_display: i64 = 0,
        _event_timestamps_buf: ?[]const u8 = null,
        _to_first_frame_buf: ?[]const u8 = null,
        _process_buf: ?[]const u8 = null,
        _hsc_buf: ?[]const u8 = null,
        _report_fully_drawn_buf: ?[]const u8 = null,
        _optimization_status_offset: ?usize = null,
        _optimization_status_last_offset: ?usize = null,
        _optimization_status_cnt: usize = 0,
        _verify_class_offset: ?usize = null,
        _verify_class_last_offset: ?usize = null,
        _verify_class_cnt: usize = 0,
        _dlopen_file_offset: ?usize = null,
        _dlopen_file_last_offset: ?usize = null,
        _dlopen_file_cnt: usize = 0,
        _startup_concurrent_to_launch_offset: ?usize = null,
        _startup_concurrent_to_launch_last_offset: ?usize = null,
        _startup_concurrent_to_launch_cnt: usize = 0,
        _system_state_buf: ?[]const u8 = null,
        _slow_start_reason_offset: ?usize = null,
        _slow_start_reason_last_offset: ?usize = null,
        _slow_start_reason_cnt: usize = 0,
        _slow_start_reason_detailed_offset: ?usize = null,
        _slow_start_reason_detailed_last_offset: ?usize = null,
        _slow_start_reason_detailed_cnt: usize = 0,
        _slow_start_reason_with_details_offset: ?usize = null,
        _slow_start_reason_with_details_last_offset: ?usize = null,
        _slow_start_reason_with_details_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidStartupMetric.StartupReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidStartupMetric.StartupReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidStartupMetric.StartupWire.STARTUP_ID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._startup_id = result.value;
                    },
                    AndroidStartupMetric.StartupWire.STARTUP_TYPE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._startup_type = result.value;
                    },
                    AndroidStartupMetric.StartupWire.CPU_COUNT_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._cpu_count = result.value;
                    },
                    AndroidStartupMetric.StartupWire.PACKAGE_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._package_name = result.value;
                    },
                    AndroidStartupMetric.StartupWire.PROCESS_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._process_name = result.value;
                    },
                    AndroidStartupMetric.StartupWire.ACTIVITIES_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._activities_offset == null) {
                            res._activities_offset = offset - result.size;
                        }
                        res._activities_last_offset = offset;
                        res._activities_cnt += 1;
                    },
                    AndroidStartupMetric.StartupWire.LONG_BINDER_TRANSACTIONS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._long_binder_transactions_offset == null) {
                            res._long_binder_transactions_offset = offset - result.size;
                        }
                        res._long_binder_transactions_last_offset = offset;
                        res._long_binder_transactions_cnt += 1;
                    },
                    AndroidStartupMetric.StartupWire.ZYGOTE_NEW_PROCESS_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._zygote_new_process = result.value;
                    },
                    AndroidStartupMetric.StartupWire.ACTIVITY_HOSTING_PROCESS_COUNT_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._activity_hosting_process_count = result.value;
                    },
                    AndroidStartupMetric.StartupWire.TIME_TO_INITIAL_DISPLAY_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._time_to_initial_display = result.value;
                    },
                    AndroidStartupMetric.StartupWire.TIME_TO_FULL_DISPLAY_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._time_to_full_display = result.value;
                    },
                    AndroidStartupMetric.StartupWire.EVENT_TIMESTAMPS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._event_timestamps_buf = result.value;
                    },
                    AndroidStartupMetric.StartupWire.TO_FIRST_FRAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._to_first_frame_buf = result.value;
                    },
                    AndroidStartupMetric.StartupWire.PROCESS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._process_buf = result.value;
                    },
                    AndroidStartupMetric.StartupWire.HSC_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._hsc_buf = result.value;
                    },
                    AndroidStartupMetric.StartupWire.REPORT_FULLY_DRAWN_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._report_fully_drawn_buf = result.value;
                    },
                    AndroidStartupMetric.StartupWire.OPTIMIZATION_STATUS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._optimization_status_offset == null) {
                            res._optimization_status_offset = offset - result.size;
                        }
                        res._optimization_status_last_offset = offset;
                        res._optimization_status_cnt += 1;
                    },
                    AndroidStartupMetric.StartupWire.VERIFY_CLASS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._verify_class_offset == null) {
                            res._verify_class_offset = offset - result.size;
                        }
                        res._verify_class_last_offset = offset;
                        res._verify_class_cnt += 1;
                    },
                    AndroidStartupMetric.StartupWire.DLOPEN_FILE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._dlopen_file_offset == null) {
                            res._dlopen_file_offset = offset - result.size;
                        }
                        res._dlopen_file_last_offset = offset;
                        res._dlopen_file_cnt += 1;
                    },
                    AndroidStartupMetric.StartupWire.STARTUP_CONCURRENT_TO_LAUNCH_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._startup_concurrent_to_launch_offset == null) {
                            res._startup_concurrent_to_launch_offset = offset - result.size;
                        }
                        res._startup_concurrent_to_launch_last_offset = offset;
                        res._startup_concurrent_to_launch_cnt += 1;
                    },
                    AndroidStartupMetric.StartupWire.SYSTEM_STATE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._system_state_buf = result.value;
                    },
                    AndroidStartupMetric.StartupWire.SLOW_START_REASON_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._slow_start_reason_offset == null) {
                            res._slow_start_reason_offset = offset - result.size;
                        }
                        res._slow_start_reason_last_offset = offset;
                        res._slow_start_reason_cnt += 1;
                    },
                    AndroidStartupMetric.StartupWire.SLOW_START_REASON_DETAILED_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._slow_start_reason_detailed_offset == null) {
                            res._slow_start_reason_detailed_offset = offset - result.size;
                        }
                        res._slow_start_reason_detailed_last_offset = offset;
                        res._slow_start_reason_detailed_cnt += 1;
                    },
                    AndroidStartupMetric.StartupWire.SLOW_START_REASON_WITH_DETAILS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._slow_start_reason_with_details_offset == null) {
                            res._slow_start_reason_with_details_offset = offset - result.size;
                        }
                        res._slow_start_reason_with_details_last_offset = offset;
                        res._slow_start_reason_with_details_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getStartupId(self: *const AndroidStartupMetric.StartupReader) u32 {
            return self._startup_id;
        }
        pub inline fn getStartupType(self: *const AndroidStartupMetric.StartupReader) []const u8 {
            return self._startup_type orelse &[_]u8{};
        }
        pub inline fn getCpuCount(self: *const AndroidStartupMetric.StartupReader) u32 {
            return self._cpu_count;
        }
        pub inline fn getPackageName(self: *const AndroidStartupMetric.StartupReader) []const u8 {
            return self._package_name orelse &[_]u8{};
        }
        pub inline fn getProcessName(self: *const AndroidStartupMetric.StartupReader) []const u8 {
            return self._process_name orelse &[_]u8{};
        }
        pub fn activitiesCount(self: *const AndroidStartupMetric.StartupReader) usize {
            return self._activities_cnt;
        }
        pub fn activitiesNext(self: *AndroidStartupMetric.StartupReader) ?AndroidStartupMetric.ActivityReader {
            if (self._activities_offset == null) return null;
            const current_offset = self._activities_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidStartupMetric.ActivityReader.init(result.value) catch return null;
            if (self._activities_last_offset != null and current_offset >= self._activities_last_offset.?) {
                self._activities_offset = null;
                return msg;
            }
            if (self._activities_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._activities_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidStartupMetric.StartupWire.ACTIVITIES_WIRE) {
                    self._activities_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._activities_offset = null;
            return msg;
        }
        pub fn longBinderTransactionsCount(self: *const AndroidStartupMetric.StartupReader) usize {
            return self._long_binder_transactions_cnt;
        }
        pub fn longBinderTransactionsNext(self: *AndroidStartupMetric.StartupReader) ?AndroidStartupMetric.BinderTransactionReader {
            if (self._long_binder_transactions_offset == null) return null;
            const current_offset = self._long_binder_transactions_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidStartupMetric.BinderTransactionReader.init(result.value) catch return null;
            if (self._long_binder_transactions_last_offset != null and current_offset >= self._long_binder_transactions_last_offset.?) {
                self._long_binder_transactions_offset = null;
                return msg;
            }
            if (self._long_binder_transactions_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._long_binder_transactions_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidStartupMetric.StartupWire.LONG_BINDER_TRANSACTIONS_WIRE) {
                    self._long_binder_transactions_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._long_binder_transactions_offset = null;
            return msg;
        }
        pub inline fn getZygoteNewProcess(self: *const AndroidStartupMetric.StartupReader) bool {
            return self._zygote_new_process;
        }
        pub inline fn getActivityHostingProcessCount(self: *const AndroidStartupMetric.StartupReader) u32 {
            return self._activity_hosting_process_count;
        }
        pub inline fn getTimeToInitialDisplay(self: *const AndroidStartupMetric.StartupReader) i64 {
            return self._time_to_initial_display;
        }
        pub inline fn getTimeToFullDisplay(self: *const AndroidStartupMetric.StartupReader) i64 {
            return self._time_to_full_display;
        }
        pub fn getEventTimestamps(self: *const AndroidStartupMetric.StartupReader) gremlin.Error!AndroidStartupMetric.EventTimestampsReader {
            if (self._event_timestamps_buf) |buf| {
                return try AndroidStartupMetric.EventTimestampsReader.init(buf);
            }
            return try AndroidStartupMetric.EventTimestampsReader.init(&[_]u8{});
        }
        pub fn getToFirstFrame(self: *const AndroidStartupMetric.StartupReader) gremlin.Error!AndroidStartupMetric.ToFirstFrameReader {
            if (self._to_first_frame_buf) |buf| {
                return try AndroidStartupMetric.ToFirstFrameReader.init(buf);
            }
            return try AndroidStartupMetric.ToFirstFrameReader.init(&[_]u8{});
        }
        pub fn getProcess(self: *const AndroidStartupMetric.StartupReader) gremlin.Error!AndroidProcessMetadataReader {
            if (self._process_buf) |buf| {
                return try AndroidProcessMetadataReader.init(buf);
            }
            return try AndroidProcessMetadataReader.init(&[_]u8{});
        }
        pub fn getHsc(self: *const AndroidStartupMetric.StartupReader) gremlin.Error!AndroidStartupMetric.HscMetricsReader {
            if (self._hsc_buf) |buf| {
                return try AndroidStartupMetric.HscMetricsReader.init(buf);
            }
            return try AndroidStartupMetric.HscMetricsReader.init(&[_]u8{});
        }
        pub fn getReportFullyDrawn(self: *const AndroidStartupMetric.StartupReader) gremlin.Error!AndroidStartupMetric.SliceReader {
            if (self._report_fully_drawn_buf) |buf| {
                return try AndroidStartupMetric.SliceReader.init(buf);
            }
            return try AndroidStartupMetric.SliceReader.init(&[_]u8{});
        }
        pub fn optimizationStatusCount(self: *const AndroidStartupMetric.StartupReader) usize {
            return self._optimization_status_cnt;
        }
        pub fn optimizationStatusNext(self: *AndroidStartupMetric.StartupReader) ?AndroidStartupMetric.OptimizationStatusReader {
            if (self._optimization_status_offset == null) return null;
            const current_offset = self._optimization_status_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidStartupMetric.OptimizationStatusReader.init(result.value) catch return null;
            if (self._optimization_status_last_offset != null and current_offset >= self._optimization_status_last_offset.?) {
                self._optimization_status_offset = null;
                return msg;
            }
            if (self._optimization_status_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._optimization_status_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidStartupMetric.StartupWire.OPTIMIZATION_STATUS_WIRE) {
                    self._optimization_status_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._optimization_status_offset = null;
            return msg;
        }
        pub fn verifyClassCount(self: *const AndroidStartupMetric.StartupReader) usize {
            return self._verify_class_cnt;
        }
        pub fn verifyClassNext(self: *AndroidStartupMetric.StartupReader) ?AndroidStartupMetric.VerifyClassReader {
            if (self._verify_class_offset == null) return null;
            const current_offset = self._verify_class_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidStartupMetric.VerifyClassReader.init(result.value) catch return null;
            if (self._verify_class_last_offset != null and current_offset >= self._verify_class_last_offset.?) {
                self._verify_class_offset = null;
                return msg;
            }
            if (self._verify_class_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._verify_class_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidStartupMetric.StartupWire.VERIFY_CLASS_WIRE) {
                    self._verify_class_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._verify_class_offset = null;
            return msg;
        }
        pub fn dlopenFileCount(self: *const AndroidStartupMetric.StartupReader) usize {
            return self._dlopen_file_cnt;
        }
        pub fn dlopenFileNext(self: *AndroidStartupMetric.StartupReader) ?[]const u8 {
            if (self._dlopen_file_offset == null) return null;
            const current_offset = self._dlopen_file_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            if (self._dlopen_file_last_offset != null and current_offset >= self._dlopen_file_last_offset.?) {
                self._dlopen_file_offset = null;
                return result.value;
            }
            if (self._dlopen_file_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._dlopen_file_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidStartupMetric.StartupWire.DLOPEN_FILE_WIRE) {
                    self._dlopen_file_offset = next_offset;
                    return result.value;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._dlopen_file_offset = null;
            return result.value;
        }
        pub fn startupConcurrentToLaunchCount(self: *const AndroidStartupMetric.StartupReader) usize {
            return self._startup_concurrent_to_launch_cnt;
        }
        pub fn startupConcurrentToLaunchNext(self: *AndroidStartupMetric.StartupReader) ?[]const u8 {
            if (self._startup_concurrent_to_launch_offset == null) return null;
            const current_offset = self._startup_concurrent_to_launch_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            if (self._startup_concurrent_to_launch_last_offset != null and current_offset >= self._startup_concurrent_to_launch_last_offset.?) {
                self._startup_concurrent_to_launch_offset = null;
                return result.value;
            }
            if (self._startup_concurrent_to_launch_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._startup_concurrent_to_launch_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidStartupMetric.StartupWire.STARTUP_CONCURRENT_TO_LAUNCH_WIRE) {
                    self._startup_concurrent_to_launch_offset = next_offset;
                    return result.value;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._startup_concurrent_to_launch_offset = null;
            return result.value;
        }
        pub fn getSystemState(self: *const AndroidStartupMetric.StartupReader) gremlin.Error!AndroidStartupMetric.SystemStateReader {
            if (self._system_state_buf) |buf| {
                return try AndroidStartupMetric.SystemStateReader.init(buf);
            }
            return try AndroidStartupMetric.SystemStateReader.init(&[_]u8{});
        }
        pub fn slowStartReasonCount(self: *const AndroidStartupMetric.StartupReader) usize {
            return self._slow_start_reason_cnt;
        }
        pub fn slowStartReasonNext(self: *AndroidStartupMetric.StartupReader) ?[]const u8 {
            if (self._slow_start_reason_offset == null) return null;
            const current_offset = self._slow_start_reason_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            if (self._slow_start_reason_last_offset != null and current_offset >= self._slow_start_reason_last_offset.?) {
                self._slow_start_reason_offset = null;
                return result.value;
            }
            if (self._slow_start_reason_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._slow_start_reason_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidStartupMetric.StartupWire.SLOW_START_REASON_WIRE) {
                    self._slow_start_reason_offset = next_offset;
                    return result.value;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._slow_start_reason_offset = null;
            return result.value;
        }
        pub fn slowStartReasonDetailedCount(self: *const AndroidStartupMetric.StartupReader) usize {
            return self._slow_start_reason_detailed_cnt;
        }
        pub fn slowStartReasonDetailedNext(self: *AndroidStartupMetric.StartupReader) ?AndroidStartupMetric.SlowStartReasonDetailedReader {
            if (self._slow_start_reason_detailed_offset == null) return null;
            const current_offset = self._slow_start_reason_detailed_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidStartupMetric.SlowStartReasonDetailedReader.init(result.value) catch return null;
            if (self._slow_start_reason_detailed_last_offset != null and current_offset >= self._slow_start_reason_detailed_last_offset.?) {
                self._slow_start_reason_detailed_offset = null;
                return msg;
            }
            if (self._slow_start_reason_detailed_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._slow_start_reason_detailed_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidStartupMetric.StartupWire.SLOW_START_REASON_DETAILED_WIRE) {
                    self._slow_start_reason_detailed_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._slow_start_reason_detailed_offset = null;
            return msg;
        }
        pub fn slowStartReasonWithDetailsCount(self: *const AndroidStartupMetric.StartupReader) usize {
            return self._slow_start_reason_with_details_cnt;
        }
        pub fn slowStartReasonWithDetailsNext(self: *AndroidStartupMetric.StartupReader) ?AndroidStartupMetric.SlowStartReasonReader {
            if (self._slow_start_reason_with_details_offset == null) return null;
            const current_offset = self._slow_start_reason_with_details_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidStartupMetric.SlowStartReasonReader.init(result.value) catch return null;
            if (self._slow_start_reason_with_details_last_offset != null and current_offset >= self._slow_start_reason_with_details_last_offset.?) {
                self._slow_start_reason_with_details_offset = null;
                return msg;
            }
            if (self._slow_start_reason_with_details_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._slow_start_reason_with_details_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidStartupMetric.StartupWire.SLOW_START_REASON_WITH_DETAILS_WIRE) {
                    self._slow_start_reason_with_details_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._slow_start_reason_with_details_offset = null;
            return msg;
        }
    };
    // fields
    startup: ?[]const ?AndroidStartupMetric.Startup = null,
    pub fn calcProtobufSize(self: *const AndroidStartupMetric) usize {
        var res: usize = 0;
        if (self.startup) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidStartupMetricWire.STARTUP_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidStartupMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidStartupMetric, target: *gremlin.Writer) void {
        if (self.startup) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidStartupMetricWire.STARTUP_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidStartupMetricWire.STARTUP_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidStartupMetricReader = struct {
    buf: gremlin.Reader,
    _startup_offset: ?usize = null,
    _startup_last_offset: ?usize = null,
    _startup_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidStartupMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidStartupMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidStartupMetricWire.STARTUP_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._startup_offset == null) {
                        res._startup_offset = offset - result.size;
                    }
                    res._startup_last_offset = offset;
                    res._startup_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn startupCount(self: *const AndroidStartupMetricReader) usize {
        return self._startup_cnt;
    }
    pub fn startupNext(self: *AndroidStartupMetricReader) ?AndroidStartupMetric.StartupReader {
        if (self._startup_offset == null) return null;
        const current_offset = self._startup_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidStartupMetric.StartupReader.init(result.value) catch return null;
        if (self._startup_last_offset != null and current_offset >= self._startup_last_offset.?) {
            self._startup_offset = null;
            return msg;
        }
        if (self._startup_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._startup_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidStartupMetricWire.STARTUP_WIRE) {
                self._startup_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._startup_offset = null;
        return msg;
    }
};
const AndroidSurfaceflingerMetricWire = struct {
    const MISSED_FRAMES_WIRE: gremlin.ProtoWireNumber = 1;
    const MISSED_HWC_FRAMES_WIRE: gremlin.ProtoWireNumber = 2;
    const MISSED_GPU_FRAMES_WIRE: gremlin.ProtoWireNumber = 3;
    const MISSED_FRAME_RATE_WIRE: gremlin.ProtoWireNumber = 4;
    const MISSED_HWC_FRAME_RATE_WIRE: gremlin.ProtoWireNumber = 5;
    const MISSED_GPU_FRAME_RATE_WIRE: gremlin.ProtoWireNumber = 6;
    const GPU_INVOCATIONS_WIRE: gremlin.ProtoWireNumber = 7;
    const AVG_GPU_WAITING_DUR_MS_WIRE: gremlin.ProtoWireNumber = 8;
    const TOTAL_NON_EMPTY_GPU_WAITING_DUR_MS_WIRE: gremlin.ProtoWireNumber = 9;
    const METRICS_PER_DISPLAY_WIRE: gremlin.ProtoWireNumber = 10;
};
pub const AndroidSurfaceflingerMetric = struct {
    // nested structs
    const MetricsPerDisplayWire = struct {
        const DISPLAY_ID_WIRE: gremlin.ProtoWireNumber = 1;
        const MISSED_FRAMES_WIRE: gremlin.ProtoWireNumber = 2;
        const MISSED_HWC_FRAMES_WIRE: gremlin.ProtoWireNumber = 3;
        const MISSED_GPU_FRAMES_WIRE: gremlin.ProtoWireNumber = 4;
        const MISSED_FRAME_RATE_WIRE: gremlin.ProtoWireNumber = 5;
        const MISSED_HWC_FRAME_RATE_WIRE: gremlin.ProtoWireNumber = 6;
        const MISSED_GPU_FRAME_RATE_WIRE: gremlin.ProtoWireNumber = 7;
    };
    pub const MetricsPerDisplay = struct {
        // fields
        display_id: ?[]const u8 = null,
        missed_frames: u32 = 0,
        missed_hwc_frames: u32 = 0,
        missed_gpu_frames: u32 = 0,
        missed_frame_rate: f64 = 0.0,
        missed_hwc_frame_rate: f64 = 0.0,
        missed_gpu_frame_rate: f64 = 0.0,
        pub fn calcProtobufSize(self: *const AndroidSurfaceflingerMetric.MetricsPerDisplay) usize {
            var res: usize = 0;
            if (self.display_id) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidSurfaceflingerMetric.MetricsPerDisplayWire.DISPLAY_ID_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.missed_frames != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidSurfaceflingerMetric.MetricsPerDisplayWire.MISSED_FRAMES_WIRE) + gremlin.sizes.sizeU32(self.missed_frames);
            }
            if (self.missed_hwc_frames != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidSurfaceflingerMetric.MetricsPerDisplayWire.MISSED_HWC_FRAMES_WIRE) + gremlin.sizes.sizeU32(self.missed_hwc_frames);
            }
            if (self.missed_gpu_frames != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidSurfaceflingerMetric.MetricsPerDisplayWire.MISSED_GPU_FRAMES_WIRE) + gremlin.sizes.sizeU32(self.missed_gpu_frames);
            }
            if (self.missed_frame_rate != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidSurfaceflingerMetric.MetricsPerDisplayWire.MISSED_FRAME_RATE_WIRE) + gremlin.sizes.sizeDouble(self.missed_frame_rate);
            }
            if (self.missed_hwc_frame_rate != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidSurfaceflingerMetric.MetricsPerDisplayWire.MISSED_HWC_FRAME_RATE_WIRE) + gremlin.sizes.sizeDouble(self.missed_hwc_frame_rate);
            }
            if (self.missed_gpu_frame_rate != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidSurfaceflingerMetric.MetricsPerDisplayWire.MISSED_GPU_FRAME_RATE_WIRE) + gremlin.sizes.sizeDouble(self.missed_gpu_frame_rate);
            }
            return res;
        }
        pub fn encode(self: *const AndroidSurfaceflingerMetric.MetricsPerDisplay, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidSurfaceflingerMetric.MetricsPerDisplay, target: *gremlin.Writer) void {
            if (self.display_id) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidSurfaceflingerMetric.MetricsPerDisplayWire.DISPLAY_ID_WIRE, v);
                }
            }
            if (self.missed_frames != 0) {
                target.appendUint32(AndroidSurfaceflingerMetric.MetricsPerDisplayWire.MISSED_FRAMES_WIRE, self.missed_frames);
            }
            if (self.missed_hwc_frames != 0) {
                target.appendUint32(AndroidSurfaceflingerMetric.MetricsPerDisplayWire.MISSED_HWC_FRAMES_WIRE, self.missed_hwc_frames);
            }
            if (self.missed_gpu_frames != 0) {
                target.appendUint32(AndroidSurfaceflingerMetric.MetricsPerDisplayWire.MISSED_GPU_FRAMES_WIRE, self.missed_gpu_frames);
            }
            if (self.missed_frame_rate != 0.0) {
                target.appendFloat64(AndroidSurfaceflingerMetric.MetricsPerDisplayWire.MISSED_FRAME_RATE_WIRE, self.missed_frame_rate);
            }
            if (self.missed_hwc_frame_rate != 0.0) {
                target.appendFloat64(AndroidSurfaceflingerMetric.MetricsPerDisplayWire.MISSED_HWC_FRAME_RATE_WIRE, self.missed_hwc_frame_rate);
            }
            if (self.missed_gpu_frame_rate != 0.0) {
                target.appendFloat64(AndroidSurfaceflingerMetric.MetricsPerDisplayWire.MISSED_GPU_FRAME_RATE_WIRE, self.missed_gpu_frame_rate);
            }
        }
    };
    pub const MetricsPerDisplayReader = struct {
        buf: gremlin.Reader,
        _display_id: ?[]const u8 = null,
        _missed_frames: u32 = 0,
        _missed_hwc_frames: u32 = 0,
        _missed_gpu_frames: u32 = 0,
        _missed_frame_rate: f64 = 0.0,
        _missed_hwc_frame_rate: f64 = 0.0,
        _missed_gpu_frame_rate: f64 = 0.0,
        pub fn init(src: []const u8) gremlin.Error!AndroidSurfaceflingerMetric.MetricsPerDisplayReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidSurfaceflingerMetric.MetricsPerDisplayReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidSurfaceflingerMetric.MetricsPerDisplayWire.DISPLAY_ID_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._display_id = result.value;
                    },
                    AndroidSurfaceflingerMetric.MetricsPerDisplayWire.MISSED_FRAMES_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._missed_frames = result.value;
                    },
                    AndroidSurfaceflingerMetric.MetricsPerDisplayWire.MISSED_HWC_FRAMES_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._missed_hwc_frames = result.value;
                    },
                    AndroidSurfaceflingerMetric.MetricsPerDisplayWire.MISSED_GPU_FRAMES_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._missed_gpu_frames = result.value;
                    },
                    AndroidSurfaceflingerMetric.MetricsPerDisplayWire.MISSED_FRAME_RATE_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._missed_frame_rate = result.value;
                    },
                    AndroidSurfaceflingerMetric.MetricsPerDisplayWire.MISSED_HWC_FRAME_RATE_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._missed_hwc_frame_rate = result.value;
                    },
                    AndroidSurfaceflingerMetric.MetricsPerDisplayWire.MISSED_GPU_FRAME_RATE_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._missed_gpu_frame_rate = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getDisplayId(self: *const AndroidSurfaceflingerMetric.MetricsPerDisplayReader) []const u8 {
            return self._display_id orelse &[_]u8{};
        }
        pub inline fn getMissedFrames(self: *const AndroidSurfaceflingerMetric.MetricsPerDisplayReader) u32 {
            return self._missed_frames;
        }
        pub inline fn getMissedHwcFrames(self: *const AndroidSurfaceflingerMetric.MetricsPerDisplayReader) u32 {
            return self._missed_hwc_frames;
        }
        pub inline fn getMissedGpuFrames(self: *const AndroidSurfaceflingerMetric.MetricsPerDisplayReader) u32 {
            return self._missed_gpu_frames;
        }
        pub inline fn getMissedFrameRate(self: *const AndroidSurfaceflingerMetric.MetricsPerDisplayReader) f64 {
            return self._missed_frame_rate;
        }
        pub inline fn getMissedHwcFrameRate(self: *const AndroidSurfaceflingerMetric.MetricsPerDisplayReader) f64 {
            return self._missed_hwc_frame_rate;
        }
        pub inline fn getMissedGpuFrameRate(self: *const AndroidSurfaceflingerMetric.MetricsPerDisplayReader) f64 {
            return self._missed_gpu_frame_rate;
        }
    };
    // fields
    missed_frames: u32 = 0,
    missed_hwc_frames: u32 = 0,
    missed_gpu_frames: u32 = 0,
    missed_frame_rate: f64 = 0.0,
    missed_hwc_frame_rate: f64 = 0.0,
    missed_gpu_frame_rate: f64 = 0.0,
    gpu_invocations: u32 = 0,
    avg_gpu_waiting_dur_ms: f64 = 0.0,
    total_non_empty_gpu_waiting_dur_ms: f64 = 0.0,
    metrics_per_display: ?[]const ?AndroidSurfaceflingerMetric.MetricsPerDisplay = null,
    pub fn calcProtobufSize(self: *const AndroidSurfaceflingerMetric) usize {
        var res: usize = 0;
        if (self.missed_frames != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidSurfaceflingerMetricWire.MISSED_FRAMES_WIRE) + gremlin.sizes.sizeU32(self.missed_frames);
        }
        if (self.missed_hwc_frames != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidSurfaceflingerMetricWire.MISSED_HWC_FRAMES_WIRE) + gremlin.sizes.sizeU32(self.missed_hwc_frames);
        }
        if (self.missed_gpu_frames != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidSurfaceflingerMetricWire.MISSED_GPU_FRAMES_WIRE) + gremlin.sizes.sizeU32(self.missed_gpu_frames);
        }
        if (self.missed_frame_rate != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidSurfaceflingerMetricWire.MISSED_FRAME_RATE_WIRE) + gremlin.sizes.sizeDouble(self.missed_frame_rate);
        }
        if (self.missed_hwc_frame_rate != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidSurfaceflingerMetricWire.MISSED_HWC_FRAME_RATE_WIRE) + gremlin.sizes.sizeDouble(self.missed_hwc_frame_rate);
        }
        if (self.missed_gpu_frame_rate != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidSurfaceflingerMetricWire.MISSED_GPU_FRAME_RATE_WIRE) + gremlin.sizes.sizeDouble(self.missed_gpu_frame_rate);
        }
        if (self.gpu_invocations != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidSurfaceflingerMetricWire.GPU_INVOCATIONS_WIRE) + gremlin.sizes.sizeU32(self.gpu_invocations);
        }
        if (self.avg_gpu_waiting_dur_ms != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidSurfaceflingerMetricWire.AVG_GPU_WAITING_DUR_MS_WIRE) + gremlin.sizes.sizeDouble(self.avg_gpu_waiting_dur_ms);
        }
        if (self.total_non_empty_gpu_waiting_dur_ms != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidSurfaceflingerMetricWire.TOTAL_NON_EMPTY_GPU_WAITING_DUR_MS_WIRE) + gremlin.sizes.sizeDouble(self.total_non_empty_gpu_waiting_dur_ms);
        }
        if (self.metrics_per_display) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidSurfaceflingerMetricWire.METRICS_PER_DISPLAY_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidSurfaceflingerMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidSurfaceflingerMetric, target: *gremlin.Writer) void {
        if (self.missed_frames != 0) {
            target.appendUint32(AndroidSurfaceflingerMetricWire.MISSED_FRAMES_WIRE, self.missed_frames);
        }
        if (self.missed_hwc_frames != 0) {
            target.appendUint32(AndroidSurfaceflingerMetricWire.MISSED_HWC_FRAMES_WIRE, self.missed_hwc_frames);
        }
        if (self.missed_gpu_frames != 0) {
            target.appendUint32(AndroidSurfaceflingerMetricWire.MISSED_GPU_FRAMES_WIRE, self.missed_gpu_frames);
        }
        if (self.missed_frame_rate != 0.0) {
            target.appendFloat64(AndroidSurfaceflingerMetricWire.MISSED_FRAME_RATE_WIRE, self.missed_frame_rate);
        }
        if (self.missed_hwc_frame_rate != 0.0) {
            target.appendFloat64(AndroidSurfaceflingerMetricWire.MISSED_HWC_FRAME_RATE_WIRE, self.missed_hwc_frame_rate);
        }
        if (self.missed_gpu_frame_rate != 0.0) {
            target.appendFloat64(AndroidSurfaceflingerMetricWire.MISSED_GPU_FRAME_RATE_WIRE, self.missed_gpu_frame_rate);
        }
        if (self.gpu_invocations != 0) {
            target.appendUint32(AndroidSurfaceflingerMetricWire.GPU_INVOCATIONS_WIRE, self.gpu_invocations);
        }
        if (self.avg_gpu_waiting_dur_ms != 0.0) {
            target.appendFloat64(AndroidSurfaceflingerMetricWire.AVG_GPU_WAITING_DUR_MS_WIRE, self.avg_gpu_waiting_dur_ms);
        }
        if (self.total_non_empty_gpu_waiting_dur_ms != 0.0) {
            target.appendFloat64(AndroidSurfaceflingerMetricWire.TOTAL_NON_EMPTY_GPU_WAITING_DUR_MS_WIRE, self.total_non_empty_gpu_waiting_dur_ms);
        }
        if (self.metrics_per_display) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidSurfaceflingerMetricWire.METRICS_PER_DISPLAY_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidSurfaceflingerMetricWire.METRICS_PER_DISPLAY_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidSurfaceflingerMetricReader = struct {
    buf: gremlin.Reader,
    _missed_frames: u32 = 0,
    _missed_hwc_frames: u32 = 0,
    _missed_gpu_frames: u32 = 0,
    _missed_frame_rate: f64 = 0.0,
    _missed_hwc_frame_rate: f64 = 0.0,
    _missed_gpu_frame_rate: f64 = 0.0,
    _gpu_invocations: u32 = 0,
    _avg_gpu_waiting_dur_ms: f64 = 0.0,
    _total_non_empty_gpu_waiting_dur_ms: f64 = 0.0,
    _metrics_per_display_offset: ?usize = null,
    _metrics_per_display_last_offset: ?usize = null,
    _metrics_per_display_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidSurfaceflingerMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidSurfaceflingerMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidSurfaceflingerMetricWire.MISSED_FRAMES_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._missed_frames = result.value;
                },
                AndroidSurfaceflingerMetricWire.MISSED_HWC_FRAMES_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._missed_hwc_frames = result.value;
                },
                AndroidSurfaceflingerMetricWire.MISSED_GPU_FRAMES_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._missed_gpu_frames = result.value;
                },
                AndroidSurfaceflingerMetricWire.MISSED_FRAME_RATE_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._missed_frame_rate = result.value;
                },
                AndroidSurfaceflingerMetricWire.MISSED_HWC_FRAME_RATE_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._missed_hwc_frame_rate = result.value;
                },
                AndroidSurfaceflingerMetricWire.MISSED_GPU_FRAME_RATE_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._missed_gpu_frame_rate = result.value;
                },
                AndroidSurfaceflingerMetricWire.GPU_INVOCATIONS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._gpu_invocations = result.value;
                },
                AndroidSurfaceflingerMetricWire.AVG_GPU_WAITING_DUR_MS_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._avg_gpu_waiting_dur_ms = result.value;
                },
                AndroidSurfaceflingerMetricWire.TOTAL_NON_EMPTY_GPU_WAITING_DUR_MS_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._total_non_empty_gpu_waiting_dur_ms = result.value;
                },
                AndroidSurfaceflingerMetricWire.METRICS_PER_DISPLAY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._metrics_per_display_offset == null) {
                        res._metrics_per_display_offset = offset - result.size;
                    }
                    res._metrics_per_display_last_offset = offset;
                    res._metrics_per_display_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getMissedFrames(self: *const AndroidSurfaceflingerMetricReader) u32 {
        return self._missed_frames;
    }
    pub inline fn getMissedHwcFrames(self: *const AndroidSurfaceflingerMetricReader) u32 {
        return self._missed_hwc_frames;
    }
    pub inline fn getMissedGpuFrames(self: *const AndroidSurfaceflingerMetricReader) u32 {
        return self._missed_gpu_frames;
    }
    pub inline fn getMissedFrameRate(self: *const AndroidSurfaceflingerMetricReader) f64 {
        return self._missed_frame_rate;
    }
    pub inline fn getMissedHwcFrameRate(self: *const AndroidSurfaceflingerMetricReader) f64 {
        return self._missed_hwc_frame_rate;
    }
    pub inline fn getMissedGpuFrameRate(self: *const AndroidSurfaceflingerMetricReader) f64 {
        return self._missed_gpu_frame_rate;
    }
    pub inline fn getGpuInvocations(self: *const AndroidSurfaceflingerMetricReader) u32 {
        return self._gpu_invocations;
    }
    pub inline fn getAvgGpuWaitingDurMs(self: *const AndroidSurfaceflingerMetricReader) f64 {
        return self._avg_gpu_waiting_dur_ms;
    }
    pub inline fn getTotalNonEmptyGpuWaitingDurMs(self: *const AndroidSurfaceflingerMetricReader) f64 {
        return self._total_non_empty_gpu_waiting_dur_ms;
    }
    pub fn metricsPerDisplayCount(self: *const AndroidSurfaceflingerMetricReader) usize {
        return self._metrics_per_display_cnt;
    }
    pub fn metricsPerDisplayNext(self: *AndroidSurfaceflingerMetricReader) ?AndroidSurfaceflingerMetric.MetricsPerDisplayReader {
        if (self._metrics_per_display_offset == null) return null;
        const current_offset = self._metrics_per_display_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidSurfaceflingerMetric.MetricsPerDisplayReader.init(result.value) catch return null;
        if (self._metrics_per_display_last_offset != null and current_offset >= self._metrics_per_display_last_offset.?) {
            self._metrics_per_display_offset = null;
            return msg;
        }
        if (self._metrics_per_display_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._metrics_per_display_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidSurfaceflingerMetricWire.METRICS_PER_DISPLAY_WIRE) {
                self._metrics_per_display_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._metrics_per_display_offset = null;
        return msg;
    }
};
const SysUiSlicePerformanceStatisticalDataWire = struct {
    const NAME_WIRE: gremlin.ProtoWireNumber = 1;
    const CNT_WIRE: gremlin.ProtoWireNumber = 2;
    const AVG_DUR_MS_WIRE: gremlin.ProtoWireNumber = 3;
    const MAX_DUR_MS_WIRE: gremlin.ProtoWireNumber = 4;
    const AVG_DUR_NS_WIRE: gremlin.ProtoWireNumber = 6;
    const MAX_DUR_NS_WIRE: gremlin.ProtoWireNumber = 7;
};
pub const SysUiSlicePerformanceStatisticalData = struct {
    // fields
    name: ?[]const u8 = null,
    cnt: i64 = 0,
    avg_dur_ms: i64 = 0,
    max_dur_ms: i64 = 0,
    avg_dur_ns: i64 = 0,
    max_dur_ns: i64 = 0,
    pub fn calcProtobufSize(self: *const SysUiSlicePerformanceStatisticalData) usize {
        var res: usize = 0;
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(SysUiSlicePerformanceStatisticalDataWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.cnt != 0) {
            res += gremlin.sizes.sizeWireNumber(SysUiSlicePerformanceStatisticalDataWire.CNT_WIRE) + gremlin.sizes.sizeI64(self.cnt);
        }
        if (self.avg_dur_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(SysUiSlicePerformanceStatisticalDataWire.AVG_DUR_MS_WIRE) + gremlin.sizes.sizeI64(self.avg_dur_ms);
        }
        if (self.max_dur_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(SysUiSlicePerformanceStatisticalDataWire.MAX_DUR_MS_WIRE) + gremlin.sizes.sizeI64(self.max_dur_ms);
        }
        if (self.avg_dur_ns != 0) {
            res += gremlin.sizes.sizeWireNumber(SysUiSlicePerformanceStatisticalDataWire.AVG_DUR_NS_WIRE) + gremlin.sizes.sizeI64(self.avg_dur_ns);
        }
        if (self.max_dur_ns != 0) {
            res += gremlin.sizes.sizeWireNumber(SysUiSlicePerformanceStatisticalDataWire.MAX_DUR_NS_WIRE) + gremlin.sizes.sizeI64(self.max_dur_ns);
        }
        return res;
    }
    pub fn encode(self: *const SysUiSlicePerformanceStatisticalData, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SysUiSlicePerformanceStatisticalData, target: *gremlin.Writer) void {
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(SysUiSlicePerformanceStatisticalDataWire.NAME_WIRE, v);
            }
        }
        if (self.cnt != 0) {
            target.appendInt64(SysUiSlicePerformanceStatisticalDataWire.CNT_WIRE, self.cnt);
        }
        if (self.avg_dur_ms != 0) {
            target.appendInt64(SysUiSlicePerformanceStatisticalDataWire.AVG_DUR_MS_WIRE, self.avg_dur_ms);
        }
        if (self.max_dur_ms != 0) {
            target.appendInt64(SysUiSlicePerformanceStatisticalDataWire.MAX_DUR_MS_WIRE, self.max_dur_ms);
        }
        if (self.avg_dur_ns != 0) {
            target.appendInt64(SysUiSlicePerformanceStatisticalDataWire.AVG_DUR_NS_WIRE, self.avg_dur_ns);
        }
        if (self.max_dur_ns != 0) {
            target.appendInt64(SysUiSlicePerformanceStatisticalDataWire.MAX_DUR_NS_WIRE, self.max_dur_ns);
        }
    }
};
pub const SysUiSlicePerformanceStatisticalDataReader = struct {
    buf: gremlin.Reader,
    _name: ?[]const u8 = null,
    _cnt: i64 = 0,
    _avg_dur_ms: i64 = 0,
    _max_dur_ms: i64 = 0,
    _avg_dur_ns: i64 = 0,
    _max_dur_ns: i64 = 0,
    pub fn init(src: []const u8) gremlin.Error!SysUiSlicePerformanceStatisticalDataReader {
        const buf = gremlin.Reader.init(src);
        var res = SysUiSlicePerformanceStatisticalDataReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SysUiSlicePerformanceStatisticalDataWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                SysUiSlicePerformanceStatisticalDataWire.CNT_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._cnt = result.value;
                },
                SysUiSlicePerformanceStatisticalDataWire.AVG_DUR_MS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._avg_dur_ms = result.value;
                },
                SysUiSlicePerformanceStatisticalDataWire.MAX_DUR_MS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._max_dur_ms = result.value;
                },
                SysUiSlicePerformanceStatisticalDataWire.AVG_DUR_NS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._avg_dur_ns = result.value;
                },
                SysUiSlicePerformanceStatisticalDataWire.MAX_DUR_NS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._max_dur_ns = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getName(self: *const SysUiSlicePerformanceStatisticalDataReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub inline fn getCnt(self: *const SysUiSlicePerformanceStatisticalDataReader) i64 {
        return self._cnt;
    }
    pub inline fn getAvgDurMs(self: *const SysUiSlicePerformanceStatisticalDataReader) i64 {
        return self._avg_dur_ms;
    }
    pub inline fn getMaxDurMs(self: *const SysUiSlicePerformanceStatisticalDataReader) i64 {
        return self._max_dur_ms;
    }
    pub inline fn getAvgDurNs(self: *const SysUiSlicePerformanceStatisticalDataReader) i64 {
        return self._avg_dur_ns;
    }
    pub inline fn getMaxDurNs(self: *const SysUiSlicePerformanceStatisticalDataReader) i64 {
        return self._max_dur_ns;
    }
};
const SysuiNotifShadeListBuilderMetricWire = struct {
    const ALL_SLICES_PERFORMANCE_WIRE: gremlin.ProtoWireNumber = 1;
    const SLICES_WITH_INFLATION_PERFORMANCE_WIRE: gremlin.ProtoWireNumber = 2;
    const SLICES_WITH_MODIFICATION_PERFORMANCE_WIRE: gremlin.ProtoWireNumber = 3;
    const SLICE_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const SysuiNotifShadeListBuilderMetric = struct {
    // nested structs
    const SliceDurationWire = struct {
        const NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const DUR_MS_WIRE: gremlin.ProtoWireNumber = 2;
        const DUR_NS_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const SliceDuration = struct {
        // fields
        name: ?[]const u8 = null,
        dur_ms: i64 = 0,
        dur_ns: i64 = 0,
        pub fn calcProtobufSize(self: *const SysuiNotifShadeListBuilderMetric.SliceDuration) usize {
            var res: usize = 0;
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(SysuiNotifShadeListBuilderMetric.SliceDurationWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.dur_ms != 0) {
                res += gremlin.sizes.sizeWireNumber(SysuiNotifShadeListBuilderMetric.SliceDurationWire.DUR_MS_WIRE) + gremlin.sizes.sizeI64(self.dur_ms);
            }
            if (self.dur_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(SysuiNotifShadeListBuilderMetric.SliceDurationWire.DUR_NS_WIRE) + gremlin.sizes.sizeI64(self.dur_ns);
            }
            return res;
        }
        pub fn encode(self: *const SysuiNotifShadeListBuilderMetric.SliceDuration, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const SysuiNotifShadeListBuilderMetric.SliceDuration, target: *gremlin.Writer) void {
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(SysuiNotifShadeListBuilderMetric.SliceDurationWire.NAME_WIRE, v);
                }
            }
            if (self.dur_ms != 0) {
                target.appendInt64(SysuiNotifShadeListBuilderMetric.SliceDurationWire.DUR_MS_WIRE, self.dur_ms);
            }
            if (self.dur_ns != 0) {
                target.appendInt64(SysuiNotifShadeListBuilderMetric.SliceDurationWire.DUR_NS_WIRE, self.dur_ns);
            }
        }
    };
    pub const SliceDurationReader = struct {
        buf: gremlin.Reader,
        _name: ?[]const u8 = null,
        _dur_ms: i64 = 0,
        _dur_ns: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!SysuiNotifShadeListBuilderMetric.SliceDurationReader {
            const buf = gremlin.Reader.init(src);
            var res = SysuiNotifShadeListBuilderMetric.SliceDurationReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    SysuiNotifShadeListBuilderMetric.SliceDurationWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    SysuiNotifShadeListBuilderMetric.SliceDurationWire.DUR_MS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._dur_ms = result.value;
                    },
                    SysuiNotifShadeListBuilderMetric.SliceDurationWire.DUR_NS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._dur_ns = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getName(self: *const SysuiNotifShadeListBuilderMetric.SliceDurationReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub inline fn getDurMs(self: *const SysuiNotifShadeListBuilderMetric.SliceDurationReader) i64 {
            return self._dur_ms;
        }
        pub inline fn getDurNs(self: *const SysuiNotifShadeListBuilderMetric.SliceDurationReader) i64 {
            return self._dur_ns;
        }
    };
    // fields
    all_slices_performance: ?SysUiSlicePerformanceStatisticalData = null,
    slices_with_inflation_performance: ?SysUiSlicePerformanceStatisticalData = null,
    slices_with_modification_performance: ?SysUiSlicePerformanceStatisticalData = null,
    slice: ?[]const ?SysuiNotifShadeListBuilderMetric.SliceDuration = null,
    pub fn calcProtobufSize(self: *const SysuiNotifShadeListBuilderMetric) usize {
        var res: usize = 0;
        if (self.all_slices_performance) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(SysuiNotifShadeListBuilderMetricWire.ALL_SLICES_PERFORMANCE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.slices_with_inflation_performance) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(SysuiNotifShadeListBuilderMetricWire.SLICES_WITH_INFLATION_PERFORMANCE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.slices_with_modification_performance) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(SysuiNotifShadeListBuilderMetricWire.SLICES_WITH_MODIFICATION_PERFORMANCE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.slice) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(SysuiNotifShadeListBuilderMetricWire.SLICE_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const SysuiNotifShadeListBuilderMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SysuiNotifShadeListBuilderMetric, target: *gremlin.Writer) void {
        if (self.all_slices_performance) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(SysuiNotifShadeListBuilderMetricWire.ALL_SLICES_PERFORMANCE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.slices_with_inflation_performance) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(SysuiNotifShadeListBuilderMetricWire.SLICES_WITH_INFLATION_PERFORMANCE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.slices_with_modification_performance) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(SysuiNotifShadeListBuilderMetricWire.SLICES_WITH_MODIFICATION_PERFORMANCE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.slice) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(SysuiNotifShadeListBuilderMetricWire.SLICE_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(SysuiNotifShadeListBuilderMetricWire.SLICE_WIRE, 0);
                }
            }
        }
    }
};
pub const SysuiNotifShadeListBuilderMetricReader = struct {
    buf: gremlin.Reader,
    _all_slices_performance_buf: ?[]const u8 = null,
    _slices_with_inflation_performance_buf: ?[]const u8 = null,
    _slices_with_modification_performance_buf: ?[]const u8 = null,
    _slice_offset: ?usize = null,
    _slice_last_offset: ?usize = null,
    _slice_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!SysuiNotifShadeListBuilderMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = SysuiNotifShadeListBuilderMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SysuiNotifShadeListBuilderMetricWire.ALL_SLICES_PERFORMANCE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._all_slices_performance_buf = result.value;
                },
                SysuiNotifShadeListBuilderMetricWire.SLICES_WITH_INFLATION_PERFORMANCE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._slices_with_inflation_performance_buf = result.value;
                },
                SysuiNotifShadeListBuilderMetricWire.SLICES_WITH_MODIFICATION_PERFORMANCE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._slices_with_modification_performance_buf = result.value;
                },
                SysuiNotifShadeListBuilderMetricWire.SLICE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._slice_offset == null) {
                        res._slice_offset = offset - result.size;
                    }
                    res._slice_last_offset = offset;
                    res._slice_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getAllSlicesPerformance(self: *const SysuiNotifShadeListBuilderMetricReader) gremlin.Error!SysUiSlicePerformanceStatisticalDataReader {
        if (self._all_slices_performance_buf) |buf| {
            return try SysUiSlicePerformanceStatisticalDataReader.init(buf);
        }
        return try SysUiSlicePerformanceStatisticalDataReader.init(&[_]u8{});
    }
    pub fn getSlicesWithInflationPerformance(self: *const SysuiNotifShadeListBuilderMetricReader) gremlin.Error!SysUiSlicePerformanceStatisticalDataReader {
        if (self._slices_with_inflation_performance_buf) |buf| {
            return try SysUiSlicePerformanceStatisticalDataReader.init(buf);
        }
        return try SysUiSlicePerformanceStatisticalDataReader.init(&[_]u8{});
    }
    pub fn getSlicesWithModificationPerformance(self: *const SysuiNotifShadeListBuilderMetricReader) gremlin.Error!SysUiSlicePerformanceStatisticalDataReader {
        if (self._slices_with_modification_performance_buf) |buf| {
            return try SysUiSlicePerformanceStatisticalDataReader.init(buf);
        }
        return try SysUiSlicePerformanceStatisticalDataReader.init(&[_]u8{});
    }
    pub fn sliceCount(self: *const SysuiNotifShadeListBuilderMetricReader) usize {
        return self._slice_cnt;
    }
    pub fn sliceNext(self: *SysuiNotifShadeListBuilderMetricReader) ?SysuiNotifShadeListBuilderMetric.SliceDurationReader {
        if (self._slice_offset == null) return null;
        const current_offset = self._slice_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = SysuiNotifShadeListBuilderMetric.SliceDurationReader.init(result.value) catch return null;
        if (self._slice_last_offset != null and current_offset >= self._slice_last_offset.?) {
            self._slice_offset = null;
            return msg;
        }
        if (self._slice_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._slice_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == SysuiNotifShadeListBuilderMetricWire.SLICE_WIRE) {
                self._slice_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._slice_offset = null;
        return msg;
    }
};
const SysuiUpdateNotifOnUiModeChangedMetricWire = struct {
    const ALL_SLICES_PERFORMANCE_WIRE: gremlin.ProtoWireNumber = 1;
    const SLICE_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const SysuiUpdateNotifOnUiModeChangedMetric = struct {
    // nested structs
    const SliceDurationWire = struct {
        const NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const DUR_MS_WIRE: gremlin.ProtoWireNumber = 2;
        const DUR_NS_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const SliceDuration = struct {
        // fields
        name: ?[]const u8 = null,
        dur_ms: i64 = 0,
        dur_ns: i64 = 0,
        pub fn calcProtobufSize(self: *const SysuiUpdateNotifOnUiModeChangedMetric.SliceDuration) usize {
            var res: usize = 0;
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(SysuiUpdateNotifOnUiModeChangedMetric.SliceDurationWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.dur_ms != 0) {
                res += gremlin.sizes.sizeWireNumber(SysuiUpdateNotifOnUiModeChangedMetric.SliceDurationWire.DUR_MS_WIRE) + gremlin.sizes.sizeI64(self.dur_ms);
            }
            if (self.dur_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(SysuiUpdateNotifOnUiModeChangedMetric.SliceDurationWire.DUR_NS_WIRE) + gremlin.sizes.sizeI64(self.dur_ns);
            }
            return res;
        }
        pub fn encode(self: *const SysuiUpdateNotifOnUiModeChangedMetric.SliceDuration, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const SysuiUpdateNotifOnUiModeChangedMetric.SliceDuration, target: *gremlin.Writer) void {
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(SysuiUpdateNotifOnUiModeChangedMetric.SliceDurationWire.NAME_WIRE, v);
                }
            }
            if (self.dur_ms != 0) {
                target.appendInt64(SysuiUpdateNotifOnUiModeChangedMetric.SliceDurationWire.DUR_MS_WIRE, self.dur_ms);
            }
            if (self.dur_ns != 0) {
                target.appendInt64(SysuiUpdateNotifOnUiModeChangedMetric.SliceDurationWire.DUR_NS_WIRE, self.dur_ns);
            }
        }
    };
    pub const SliceDurationReader = struct {
        buf: gremlin.Reader,
        _name: ?[]const u8 = null,
        _dur_ms: i64 = 0,
        _dur_ns: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!SysuiUpdateNotifOnUiModeChangedMetric.SliceDurationReader {
            const buf = gremlin.Reader.init(src);
            var res = SysuiUpdateNotifOnUiModeChangedMetric.SliceDurationReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    SysuiUpdateNotifOnUiModeChangedMetric.SliceDurationWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    SysuiUpdateNotifOnUiModeChangedMetric.SliceDurationWire.DUR_MS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._dur_ms = result.value;
                    },
                    SysuiUpdateNotifOnUiModeChangedMetric.SliceDurationWire.DUR_NS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._dur_ns = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getName(self: *const SysuiUpdateNotifOnUiModeChangedMetric.SliceDurationReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub inline fn getDurMs(self: *const SysuiUpdateNotifOnUiModeChangedMetric.SliceDurationReader) i64 {
            return self._dur_ms;
        }
        pub inline fn getDurNs(self: *const SysuiUpdateNotifOnUiModeChangedMetric.SliceDurationReader) i64 {
            return self._dur_ns;
        }
    };
    // fields
    all_slices_performance: ?SysUiSlicePerformanceStatisticalData = null,
    slice: ?[]const ?SysuiUpdateNotifOnUiModeChangedMetric.SliceDuration = null,
    pub fn calcProtobufSize(self: *const SysuiUpdateNotifOnUiModeChangedMetric) usize {
        var res: usize = 0;
        if (self.all_slices_performance) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(SysuiUpdateNotifOnUiModeChangedMetricWire.ALL_SLICES_PERFORMANCE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.slice) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(SysuiUpdateNotifOnUiModeChangedMetricWire.SLICE_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const SysuiUpdateNotifOnUiModeChangedMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SysuiUpdateNotifOnUiModeChangedMetric, target: *gremlin.Writer) void {
        if (self.all_slices_performance) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(SysuiUpdateNotifOnUiModeChangedMetricWire.ALL_SLICES_PERFORMANCE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.slice) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(SysuiUpdateNotifOnUiModeChangedMetricWire.SLICE_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(SysuiUpdateNotifOnUiModeChangedMetricWire.SLICE_WIRE, 0);
                }
            }
        }
    }
};
pub const SysuiUpdateNotifOnUiModeChangedMetricReader = struct {
    buf: gremlin.Reader,
    _all_slices_performance_buf: ?[]const u8 = null,
    _slice_offset: ?usize = null,
    _slice_last_offset: ?usize = null,
    _slice_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!SysuiUpdateNotifOnUiModeChangedMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = SysuiUpdateNotifOnUiModeChangedMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SysuiUpdateNotifOnUiModeChangedMetricWire.ALL_SLICES_PERFORMANCE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._all_slices_performance_buf = result.value;
                },
                SysuiUpdateNotifOnUiModeChangedMetricWire.SLICE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._slice_offset == null) {
                        res._slice_offset = offset - result.size;
                    }
                    res._slice_last_offset = offset;
                    res._slice_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getAllSlicesPerformance(self: *const SysuiUpdateNotifOnUiModeChangedMetricReader) gremlin.Error!SysUiSlicePerformanceStatisticalDataReader {
        if (self._all_slices_performance_buf) |buf| {
            return try SysUiSlicePerformanceStatisticalDataReader.init(buf);
        }
        return try SysUiSlicePerformanceStatisticalDataReader.init(&[_]u8{});
    }
    pub fn sliceCount(self: *const SysuiUpdateNotifOnUiModeChangedMetricReader) usize {
        return self._slice_cnt;
    }
    pub fn sliceNext(self: *SysuiUpdateNotifOnUiModeChangedMetricReader) ?SysuiUpdateNotifOnUiModeChangedMetric.SliceDurationReader {
        if (self._slice_offset == null) return null;
        const current_offset = self._slice_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = SysuiUpdateNotifOnUiModeChangedMetric.SliceDurationReader.init(result.value) catch return null;
        if (self._slice_last_offset != null and current_offset >= self._slice_last_offset.?) {
            self._slice_offset = null;
            return msg;
        }
        if (self._slice_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._slice_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == SysuiUpdateNotifOnUiModeChangedMetricWire.SLICE_WIRE) {
                self._slice_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._slice_offset = null;
        return msg;
    }
};
const AndroidTaskNamesWire = struct {
    const PROCESS_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const AndroidTaskNames = struct {
    // nested structs
    const ProcessWire = struct {
        const PID_WIRE: gremlin.ProtoWireNumber = 1;
        const PROCESS_NAME_WIRE: gremlin.ProtoWireNumber = 2;
        const THREAD_NAME_WIRE: gremlin.ProtoWireNumber = 3;
        const UID_WIRE: gremlin.ProtoWireNumber = 4;
        const UID_PACKAGE_NAME_WIRE: gremlin.ProtoWireNumber = 5;
    };
    pub const Process = struct {
        // fields
        pid: i64 = 0,
        process_name: ?[]const u8 = null,
        thread_name: ?[]const ?[]const u8 = null,
        uid: i64 = 0,
        uid_package_name: ?[]const ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const AndroidTaskNames.Process) usize {
            var res: usize = 0;
            if (self.pid != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidTaskNames.ProcessWire.PID_WIRE) + gremlin.sizes.sizeI64(self.pid);
            }
            if (self.process_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidTaskNames.ProcessWire.PROCESS_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.thread_name) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidTaskNames.ProcessWire.THREAD_NAME_WIRE);
                    if (maybe_v) |v| {
                        res += gremlin.sizes.sizeUsize(v.len) + v.len;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.uid != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidTaskNames.ProcessWire.UID_WIRE) + gremlin.sizes.sizeI64(self.uid);
            }
            if (self.uid_package_name) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidTaskNames.ProcessWire.UID_PACKAGE_NAME_WIRE);
                    if (maybe_v) |v| {
                        res += gremlin.sizes.sizeUsize(v.len) + v.len;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidTaskNames.Process, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidTaskNames.Process, target: *gremlin.Writer) void {
            if (self.pid != 0) {
                target.appendInt64(AndroidTaskNames.ProcessWire.PID_WIRE, self.pid);
            }
            if (self.process_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidTaskNames.ProcessWire.PROCESS_NAME_WIRE, v);
                }
            }
            if (self.thread_name) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        target.appendBytes(AndroidTaskNames.ProcessWire.THREAD_NAME_WIRE, v);
                    } else {
                        target.appendBytesTag(AndroidTaskNames.ProcessWire.THREAD_NAME_WIRE, 0);
                    }
                }
            }
            if (self.uid != 0) {
                target.appendInt64(AndroidTaskNames.ProcessWire.UID_WIRE, self.uid);
            }
            if (self.uid_package_name) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        target.appendBytes(AndroidTaskNames.ProcessWire.UID_PACKAGE_NAME_WIRE, v);
                    } else {
                        target.appendBytesTag(AndroidTaskNames.ProcessWire.UID_PACKAGE_NAME_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const ProcessReader = struct {
        buf: gremlin.Reader,
        _pid: i64 = 0,
        _process_name: ?[]const u8 = null,
        _thread_name_offset: ?usize = null,
        _thread_name_last_offset: ?usize = null,
        _thread_name_cnt: usize = 0,
        _uid: i64 = 0,
        _uid_package_name_offset: ?usize = null,
        _uid_package_name_last_offset: ?usize = null,
        _uid_package_name_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidTaskNames.ProcessReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidTaskNames.ProcessReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidTaskNames.ProcessWire.PID_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._pid = result.value;
                    },
                    AndroidTaskNames.ProcessWire.PROCESS_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._process_name = result.value;
                    },
                    AndroidTaskNames.ProcessWire.THREAD_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._thread_name_offset == null) {
                            res._thread_name_offset = offset - result.size;
                        }
                        res._thread_name_last_offset = offset;
                        res._thread_name_cnt += 1;
                    },
                    AndroidTaskNames.ProcessWire.UID_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._uid = result.value;
                    },
                    AndroidTaskNames.ProcessWire.UID_PACKAGE_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._uid_package_name_offset == null) {
                            res._uid_package_name_offset = offset - result.size;
                        }
                        res._uid_package_name_last_offset = offset;
                        res._uid_package_name_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getPid(self: *const AndroidTaskNames.ProcessReader) i64 {
            return self._pid;
        }
        pub inline fn getProcessName(self: *const AndroidTaskNames.ProcessReader) []const u8 {
            return self._process_name orelse &[_]u8{};
        }
        pub fn threadNameCount(self: *const AndroidTaskNames.ProcessReader) usize {
            return self._thread_name_cnt;
        }
        pub fn threadNameNext(self: *AndroidTaskNames.ProcessReader) ?[]const u8 {
            if (self._thread_name_offset == null) return null;
            const current_offset = self._thread_name_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            if (self._thread_name_last_offset != null and current_offset >= self._thread_name_last_offset.?) {
                self._thread_name_offset = null;
                return result.value;
            }
            if (self._thread_name_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._thread_name_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidTaskNames.ProcessWire.THREAD_NAME_WIRE) {
                    self._thread_name_offset = next_offset;
                    return result.value;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._thread_name_offset = null;
            return result.value;
        }
        pub inline fn getUid(self: *const AndroidTaskNames.ProcessReader) i64 {
            return self._uid;
        }
        pub fn uidPackageNameCount(self: *const AndroidTaskNames.ProcessReader) usize {
            return self._uid_package_name_cnt;
        }
        pub fn uidPackageNameNext(self: *AndroidTaskNames.ProcessReader) ?[]const u8 {
            if (self._uid_package_name_offset == null) return null;
            const current_offset = self._uid_package_name_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            if (self._uid_package_name_last_offset != null and current_offset >= self._uid_package_name_last_offset.?) {
                self._uid_package_name_offset = null;
                return result.value;
            }
            if (self._uid_package_name_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._uid_package_name_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidTaskNames.ProcessWire.UID_PACKAGE_NAME_WIRE) {
                    self._uid_package_name_offset = next_offset;
                    return result.value;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._uid_package_name_offset = null;
            return result.value;
        }
    };
    // fields
    process: ?[]const ?AndroidTaskNames.Process = null,
    pub fn calcProtobufSize(self: *const AndroidTaskNames) usize {
        var res: usize = 0;
        if (self.process) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidTaskNamesWire.PROCESS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidTaskNames, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidTaskNames, target: *gremlin.Writer) void {
        if (self.process) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidTaskNamesWire.PROCESS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidTaskNamesWire.PROCESS_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidTaskNamesReader = struct {
    buf: gremlin.Reader,
    _process_offset: ?usize = null,
    _process_last_offset: ?usize = null,
    _process_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidTaskNamesReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidTaskNamesReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidTaskNamesWire.PROCESS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._process_offset == null) {
                        res._process_offset = offset - result.size;
                    }
                    res._process_last_offset = offset;
                    res._process_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn processCount(self: *const AndroidTaskNamesReader) usize {
        return self._process_cnt;
    }
    pub fn processNext(self: *AndroidTaskNamesReader) ?AndroidTaskNames.ProcessReader {
        if (self._process_offset == null) return null;
        const current_offset = self._process_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidTaskNames.ProcessReader.init(result.value) catch return null;
        if (self._process_last_offset != null and current_offset >= self._process_last_offset.?) {
            self._process_offset = null;
            return msg;
        }
        if (self._process_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._process_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidTaskNamesWire.PROCESS_WIRE) {
                self._process_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._process_offset = null;
        return msg;
    }
};
const AndroidTraceQualityMetricWire = struct {
    const FAILURES_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const AndroidTraceQualityMetric = struct {
    // nested structs
    const FailureWire = struct {
        const NAME_WIRE: gremlin.ProtoWireNumber = 1;
    };
    pub const Failure = struct {
        // fields
        name: ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const AndroidTraceQualityMetric.Failure) usize {
            var res: usize = 0;
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidTraceQualityMetric.FailureWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidTraceQualityMetric.Failure, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidTraceQualityMetric.Failure, target: *gremlin.Writer) void {
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidTraceQualityMetric.FailureWire.NAME_WIRE, v);
                }
            }
        }
    };
    pub const FailureReader = struct {
        buf: gremlin.Reader,
        _name: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!AndroidTraceQualityMetric.FailureReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidTraceQualityMetric.FailureReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidTraceQualityMetric.FailureWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getName(self: *const AndroidTraceQualityMetric.FailureReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
    };
    // fields
    failures: ?[]const ?AndroidTraceQualityMetric.Failure = null,
    pub fn calcProtobufSize(self: *const AndroidTraceQualityMetric) usize {
        var res: usize = 0;
        if (self.failures) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidTraceQualityMetricWire.FAILURES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidTraceQualityMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidTraceQualityMetric, target: *gremlin.Writer) void {
        if (self.failures) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidTraceQualityMetricWire.FAILURES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidTraceQualityMetricWire.FAILURES_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidTraceQualityMetricReader = struct {
    buf: gremlin.Reader,
    _failures_offset: ?usize = null,
    _failures_last_offset: ?usize = null,
    _failures_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidTraceQualityMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidTraceQualityMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidTraceQualityMetricWire.FAILURES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._failures_offset == null) {
                        res._failures_offset = offset - result.size;
                    }
                    res._failures_last_offset = offset;
                    res._failures_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn failuresCount(self: *const AndroidTraceQualityMetricReader) usize {
        return self._failures_cnt;
    }
    pub fn failuresNext(self: *AndroidTraceQualityMetricReader) ?AndroidTraceQualityMetric.FailureReader {
        if (self._failures_offset == null) return null;
        const current_offset = self._failures_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidTraceQualityMetric.FailureReader.init(result.value) catch return null;
        if (self._failures_last_offset != null and current_offset >= self._failures_last_offset.?) {
            self._failures_offset = null;
            return msg;
        }
        if (self._failures_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._failures_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidTraceQualityMetricWire.FAILURES_WIRE) {
                self._failures_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._failures_offset = null;
        return msg;
    }
};
const UnsymbolizedFramesWire = struct {
    const FRAMES_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const UnsymbolizedFrames = struct {
    // nested structs
    const FrameWire = struct {
        const MODULE_WIRE: gremlin.ProtoWireNumber = 1;
        const BUILD_ID_WIRE: gremlin.ProtoWireNumber = 2;
        const ADDRESS_WIRE: gremlin.ProtoWireNumber = 3;
        const GOOGLE_LOOKUP_ID_WIRE: gremlin.ProtoWireNumber = 4;
    };
    pub const Frame = struct {
        // fields
        module: ?[]const u8 = null,
        build_id: ?[]const u8 = null,
        address: i64 = 0,
        google_lookup_id: ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const UnsymbolizedFrames.Frame) usize {
            var res: usize = 0;
            if (self.module) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(UnsymbolizedFrames.FrameWire.MODULE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.build_id) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(UnsymbolizedFrames.FrameWire.BUILD_ID_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.address != 0) {
                res += gremlin.sizes.sizeWireNumber(UnsymbolizedFrames.FrameWire.ADDRESS_WIRE) + gremlin.sizes.sizeI64(self.address);
            }
            if (self.google_lookup_id) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(UnsymbolizedFrames.FrameWire.GOOGLE_LOOKUP_ID_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            return res;
        }
        pub fn encode(self: *const UnsymbolizedFrames.Frame, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const UnsymbolizedFrames.Frame, target: *gremlin.Writer) void {
            if (self.module) |v| {
                if (v.len > 0) {
                    target.appendBytes(UnsymbolizedFrames.FrameWire.MODULE_WIRE, v);
                }
            }
            if (self.build_id) |v| {
                if (v.len > 0) {
                    target.appendBytes(UnsymbolizedFrames.FrameWire.BUILD_ID_WIRE, v);
                }
            }
            if (self.address != 0) {
                target.appendInt64(UnsymbolizedFrames.FrameWire.ADDRESS_WIRE, self.address);
            }
            if (self.google_lookup_id) |v| {
                if (v.len > 0) {
                    target.appendBytes(UnsymbolizedFrames.FrameWire.GOOGLE_LOOKUP_ID_WIRE, v);
                }
            }
        }
    };
    pub const FrameReader = struct {
        buf: gremlin.Reader,
        _module: ?[]const u8 = null,
        _build_id: ?[]const u8 = null,
        _address: i64 = 0,
        _google_lookup_id: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!UnsymbolizedFrames.FrameReader {
            const buf = gremlin.Reader.init(src);
            var res = UnsymbolizedFrames.FrameReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    UnsymbolizedFrames.FrameWire.MODULE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._module = result.value;
                    },
                    UnsymbolizedFrames.FrameWire.BUILD_ID_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._build_id = result.value;
                    },
                    UnsymbolizedFrames.FrameWire.ADDRESS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._address = result.value;
                    },
                    UnsymbolizedFrames.FrameWire.GOOGLE_LOOKUP_ID_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._google_lookup_id = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getModule(self: *const UnsymbolizedFrames.FrameReader) []const u8 {
            return self._module orelse &[_]u8{};
        }
        pub inline fn getBuildId(self: *const UnsymbolizedFrames.FrameReader) []const u8 {
            return self._build_id orelse &[_]u8{};
        }
        pub inline fn getAddress(self: *const UnsymbolizedFrames.FrameReader) i64 {
            return self._address;
        }
        pub inline fn getGoogleLookupId(self: *const UnsymbolizedFrames.FrameReader) []const u8 {
            return self._google_lookup_id orelse &[_]u8{};
        }
    };
    // fields
    frames: ?[]const ?UnsymbolizedFrames.Frame = null,
    pub fn calcProtobufSize(self: *const UnsymbolizedFrames) usize {
        var res: usize = 0;
        if (self.frames) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(UnsymbolizedFramesWire.FRAMES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const UnsymbolizedFrames, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const UnsymbolizedFrames, target: *gremlin.Writer) void {
        if (self.frames) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(UnsymbolizedFramesWire.FRAMES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(UnsymbolizedFramesWire.FRAMES_WIRE, 0);
                }
            }
        }
    }
};
pub const UnsymbolizedFramesReader = struct {
    buf: gremlin.Reader,
    _frames_offset: ?usize = null,
    _frames_last_offset: ?usize = null,
    _frames_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!UnsymbolizedFramesReader {
        const buf = gremlin.Reader.init(src);
        var res = UnsymbolizedFramesReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                UnsymbolizedFramesWire.FRAMES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._frames_offset == null) {
                        res._frames_offset = offset - result.size;
                    }
                    res._frames_last_offset = offset;
                    res._frames_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn framesCount(self: *const UnsymbolizedFramesReader) usize {
        return self._frames_cnt;
    }
    pub fn framesNext(self: *UnsymbolizedFramesReader) ?UnsymbolizedFrames.FrameReader {
        if (self._frames_offset == null) return null;
        const current_offset = self._frames_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = UnsymbolizedFrames.FrameReader.init(result.value) catch return null;
        if (self._frames_last_offset != null and current_offset >= self._frames_last_offset.?) {
            self._frames_offset = null;
            return msg;
        }
        if (self._frames_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._frames_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == UnsymbolizedFramesWire.FRAMES_WIRE) {
                self._frames_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._frames_offset = null;
        return msg;
    }
};
const AndroidWattsonTimePeriodMetricWire = struct {
    const METRIC_VERSION_WIRE: gremlin.ProtoWireNumber = 1;
    const POWER_MODEL_VERSION_WIRE: gremlin.ProtoWireNumber = 2;
    const PERIOD_INFO_WIRE: gremlin.ProtoWireNumber = 3;
    const IS_CRUDE_ESTIMATE_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const AndroidWattsonTimePeriodMetric = struct {
    // fields
    metric_version: i32 = 0,
    power_model_version: i32 = 0,
    period_info: ?[]const ?AndroidWattsonEstimateInfo = null,
    is_crude_estimate: bool = false,
    pub fn calcProtobufSize(self: *const AndroidWattsonTimePeriodMetric) usize {
        var res: usize = 0;
        if (self.metric_version != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonTimePeriodMetricWire.METRIC_VERSION_WIRE) + gremlin.sizes.sizeI32(self.metric_version);
        }
        if (self.power_model_version != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonTimePeriodMetricWire.POWER_MODEL_VERSION_WIRE) + gremlin.sizes.sizeI32(self.power_model_version);
        }
        if (self.period_info) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonTimePeriodMetricWire.PERIOD_INFO_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.is_crude_estimate != false) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonTimePeriodMetricWire.IS_CRUDE_ESTIMATE_WIRE) + gremlin.sizes.sizeBool(self.is_crude_estimate);
        }
        return res;
    }
    pub fn encode(self: *const AndroidWattsonTimePeriodMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidWattsonTimePeriodMetric, target: *gremlin.Writer) void {
        if (self.metric_version != 0) {
            target.appendInt32(AndroidWattsonTimePeriodMetricWire.METRIC_VERSION_WIRE, self.metric_version);
        }
        if (self.power_model_version != 0) {
            target.appendInt32(AndroidWattsonTimePeriodMetricWire.POWER_MODEL_VERSION_WIRE, self.power_model_version);
        }
        if (self.period_info) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidWattsonTimePeriodMetricWire.PERIOD_INFO_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidWattsonTimePeriodMetricWire.PERIOD_INFO_WIRE, 0);
                }
            }
        }
        if (self.is_crude_estimate != false) {
            target.appendBool(AndroidWattsonTimePeriodMetricWire.IS_CRUDE_ESTIMATE_WIRE, self.is_crude_estimate);
        }
    }
};
pub const AndroidWattsonTimePeriodMetricReader = struct {
    buf: gremlin.Reader,
    _metric_version: i32 = 0,
    _power_model_version: i32 = 0,
    _period_info_offset: ?usize = null,
    _period_info_last_offset: ?usize = null,
    _period_info_cnt: usize = 0,
    _is_crude_estimate: bool = false,
    pub fn init(src: []const u8) gremlin.Error!AndroidWattsonTimePeriodMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidWattsonTimePeriodMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidWattsonTimePeriodMetricWire.METRIC_VERSION_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._metric_version = result.value;
                },
                AndroidWattsonTimePeriodMetricWire.POWER_MODEL_VERSION_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._power_model_version = result.value;
                },
                AndroidWattsonTimePeriodMetricWire.PERIOD_INFO_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._period_info_offset == null) {
                        res._period_info_offset = offset - result.size;
                    }
                    res._period_info_last_offset = offset;
                    res._period_info_cnt += 1;
                },
                AndroidWattsonTimePeriodMetricWire.IS_CRUDE_ESTIMATE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_crude_estimate = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getMetricVersion(self: *const AndroidWattsonTimePeriodMetricReader) i32 {
        return self._metric_version;
    }
    pub inline fn getPowerModelVersion(self: *const AndroidWattsonTimePeriodMetricReader) i32 {
        return self._power_model_version;
    }
    pub fn periodInfoCount(self: *const AndroidWattsonTimePeriodMetricReader) usize {
        return self._period_info_cnt;
    }
    pub fn periodInfoNext(self: *AndroidWattsonTimePeriodMetricReader) ?AndroidWattsonEstimateInfoReader {
        if (self._period_info_offset == null) return null;
        const current_offset = self._period_info_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidWattsonEstimateInfoReader.init(result.value) catch return null;
        if (self._period_info_last_offset != null and current_offset >= self._period_info_last_offset.?) {
            self._period_info_offset = null;
            return msg;
        }
        if (self._period_info_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._period_info_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidWattsonTimePeriodMetricWire.PERIOD_INFO_WIRE) {
                self._period_info_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._period_info_offset = null;
        return msg;
    }
    pub inline fn getIsCrudeEstimate(self: *const AndroidWattsonTimePeriodMetricReader) bool {
        return self._is_crude_estimate;
    }
};
const AndroidWattsonEstimateInfoWire = struct {
    const PERIOD_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const PERIOD_NAME_WIRE: gremlin.ProtoWireNumber = 2;
    const PERIOD_DUR_WIRE: gremlin.ProtoWireNumber = 3;
    const CPU_SUBSYSTEM_WIRE: gremlin.ProtoWireNumber = 4;
    const GPU_SUBSYSTEM_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const AndroidWattsonEstimateInfo = struct {
    // fields
    period_id: i32 = 0,
    period_name: ?[]const u8 = null,
    period_dur: i64 = 0,
    cpu_subsystem: ?AndroidWattsonCpuSubsystemEstimate = null,
    gpu_subsystem: ?AndroidWattsonGpuSubsystemEstimate = null,
    pub fn calcProtobufSize(self: *const AndroidWattsonEstimateInfo) usize {
        var res: usize = 0;
        if (self.period_id != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonEstimateInfoWire.PERIOD_ID_WIRE) + gremlin.sizes.sizeI32(self.period_id);
        }
        if (self.period_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonEstimateInfoWire.PERIOD_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.period_dur != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonEstimateInfoWire.PERIOD_DUR_WIRE) + gremlin.sizes.sizeI64(self.period_dur);
        }
        if (self.cpu_subsystem) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonEstimateInfoWire.CPU_SUBSYSTEM_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.gpu_subsystem) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonEstimateInfoWire.GPU_SUBSYSTEM_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidWattsonEstimateInfo, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidWattsonEstimateInfo, target: *gremlin.Writer) void {
        if (self.period_id != 0) {
            target.appendInt32(AndroidWattsonEstimateInfoWire.PERIOD_ID_WIRE, self.period_id);
        }
        if (self.period_name) |v| {
            if (v.len > 0) {
                target.appendBytes(AndroidWattsonEstimateInfoWire.PERIOD_NAME_WIRE, v);
            }
        }
        if (self.period_dur != 0) {
            target.appendInt64(AndroidWattsonEstimateInfoWire.PERIOD_DUR_WIRE, self.period_dur);
        }
        if (self.cpu_subsystem) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidWattsonEstimateInfoWire.CPU_SUBSYSTEM_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.gpu_subsystem) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidWattsonEstimateInfoWire.GPU_SUBSYSTEM_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const AndroidWattsonEstimateInfoReader = struct {
    buf: gremlin.Reader,
    _period_id: i32 = 0,
    _period_name: ?[]const u8 = null,
    _period_dur: i64 = 0,
    _cpu_subsystem_buf: ?[]const u8 = null,
    _gpu_subsystem_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!AndroidWattsonEstimateInfoReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidWattsonEstimateInfoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidWattsonEstimateInfoWire.PERIOD_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._period_id = result.value;
                },
                AndroidWattsonEstimateInfoWire.PERIOD_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._period_name = result.value;
                },
                AndroidWattsonEstimateInfoWire.PERIOD_DUR_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._period_dur = result.value;
                },
                AndroidWattsonEstimateInfoWire.CPU_SUBSYSTEM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cpu_subsystem_buf = result.value;
                },
                AndroidWattsonEstimateInfoWire.GPU_SUBSYSTEM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._gpu_subsystem_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getPeriodId(self: *const AndroidWattsonEstimateInfoReader) i32 {
        return self._period_id;
    }
    pub inline fn getPeriodName(self: *const AndroidWattsonEstimateInfoReader) []const u8 {
        return self._period_name orelse &[_]u8{};
    }
    pub inline fn getPeriodDur(self: *const AndroidWattsonEstimateInfoReader) i64 {
        return self._period_dur;
    }
    pub fn getCpuSubsystem(self: *const AndroidWattsonEstimateInfoReader) gremlin.Error!AndroidWattsonCpuSubsystemEstimateReader {
        if (self._cpu_subsystem_buf) |buf| {
            return try AndroidWattsonCpuSubsystemEstimateReader.init(buf);
        }
        return try AndroidWattsonCpuSubsystemEstimateReader.init(&[_]u8{});
    }
    pub fn getGpuSubsystem(self: *const AndroidWattsonEstimateInfoReader) gremlin.Error!AndroidWattsonGpuSubsystemEstimateReader {
        if (self._gpu_subsystem_buf) |buf| {
            return try AndroidWattsonGpuSubsystemEstimateReader.init(buf);
        }
        return try AndroidWattsonGpuSubsystemEstimateReader.init(&[_]u8{});
    }
};
const AndroidWattsonCpuSubsystemEstimateWire = struct {
    const ESTIMATED_MW_WIRE: gremlin.ProtoWireNumber = 1;
    const ESTIMATED_MWS_WIRE: gremlin.ProtoWireNumber = 2;
    const POLICY0_WIRE: gremlin.ProtoWireNumber = 3;
    const POLICY1_WIRE: gremlin.ProtoWireNumber = 4;
    const POLICY2_WIRE: gremlin.ProtoWireNumber = 5;
    const POLICY3_WIRE: gremlin.ProtoWireNumber = 6;
    const POLICY4_WIRE: gremlin.ProtoWireNumber = 7;
    const POLICY5_WIRE: gremlin.ProtoWireNumber = 8;
    const POLICY6_WIRE: gremlin.ProtoWireNumber = 9;
    const POLICY7_WIRE: gremlin.ProtoWireNumber = 10;
    const DSU_SCU_WIRE: gremlin.ProtoWireNumber = 11;
};
pub const AndroidWattsonCpuSubsystemEstimate = struct {
    // fields
    estimated_mw: f32 = 0.0,
    estimated_mws: f32 = 0.0,
    policy0: ?AndroidWattsonPolicyEstimate = null,
    policy1: ?AndroidWattsonPolicyEstimate = null,
    policy2: ?AndroidWattsonPolicyEstimate = null,
    policy3: ?AndroidWattsonPolicyEstimate = null,
    policy4: ?AndroidWattsonPolicyEstimate = null,
    policy5: ?AndroidWattsonPolicyEstimate = null,
    policy6: ?AndroidWattsonPolicyEstimate = null,
    policy7: ?AndroidWattsonPolicyEstimate = null,
    dsu_scu: ?AndroidWattsonDsuScuEstimate = null,
    pub fn calcProtobufSize(self: *const AndroidWattsonCpuSubsystemEstimate) usize {
        var res: usize = 0;
        if (self.estimated_mw != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonCpuSubsystemEstimateWire.ESTIMATED_MW_WIRE) + gremlin.sizes.sizeFloat(self.estimated_mw);
        }
        if (self.estimated_mws != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonCpuSubsystemEstimateWire.ESTIMATED_MWS_WIRE) + gremlin.sizes.sizeFloat(self.estimated_mws);
        }
        if (self.policy0) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonCpuSubsystemEstimateWire.POLICY0_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.policy1) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonCpuSubsystemEstimateWire.POLICY1_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.policy2) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonCpuSubsystemEstimateWire.POLICY2_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.policy3) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonCpuSubsystemEstimateWire.POLICY3_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.policy4) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonCpuSubsystemEstimateWire.POLICY4_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.policy5) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonCpuSubsystemEstimateWire.POLICY5_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.policy6) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonCpuSubsystemEstimateWire.POLICY6_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.policy7) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonCpuSubsystemEstimateWire.POLICY7_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.dsu_scu) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonCpuSubsystemEstimateWire.DSU_SCU_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidWattsonCpuSubsystemEstimate, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidWattsonCpuSubsystemEstimate, target: *gremlin.Writer) void {
        if (self.estimated_mw != 0.0) {
            target.appendFloat32(AndroidWattsonCpuSubsystemEstimateWire.ESTIMATED_MW_WIRE, self.estimated_mw);
        }
        if (self.estimated_mws != 0.0) {
            target.appendFloat32(AndroidWattsonCpuSubsystemEstimateWire.ESTIMATED_MWS_WIRE, self.estimated_mws);
        }
        if (self.policy0) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidWattsonCpuSubsystemEstimateWire.POLICY0_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.policy1) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidWattsonCpuSubsystemEstimateWire.POLICY1_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.policy2) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidWattsonCpuSubsystemEstimateWire.POLICY2_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.policy3) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidWattsonCpuSubsystemEstimateWire.POLICY3_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.policy4) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidWattsonCpuSubsystemEstimateWire.POLICY4_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.policy5) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidWattsonCpuSubsystemEstimateWire.POLICY5_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.policy6) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidWattsonCpuSubsystemEstimateWire.POLICY6_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.policy7) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidWattsonCpuSubsystemEstimateWire.POLICY7_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.dsu_scu) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidWattsonCpuSubsystemEstimateWire.DSU_SCU_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const AndroidWattsonCpuSubsystemEstimateReader = struct {
    buf: gremlin.Reader,
    _estimated_mw: f32 = 0.0,
    _estimated_mws: f32 = 0.0,
    _policy0_buf: ?[]const u8 = null,
    _policy1_buf: ?[]const u8 = null,
    _policy2_buf: ?[]const u8 = null,
    _policy3_buf: ?[]const u8 = null,
    _policy4_buf: ?[]const u8 = null,
    _policy5_buf: ?[]const u8 = null,
    _policy6_buf: ?[]const u8 = null,
    _policy7_buf: ?[]const u8 = null,
    _dsu_scu_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!AndroidWattsonCpuSubsystemEstimateReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidWattsonCpuSubsystemEstimateReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidWattsonCpuSubsystemEstimateWire.ESTIMATED_MW_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._estimated_mw = result.value;
                },
                AndroidWattsonCpuSubsystemEstimateWire.ESTIMATED_MWS_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._estimated_mws = result.value;
                },
                AndroidWattsonCpuSubsystemEstimateWire.POLICY0_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._policy0_buf = result.value;
                },
                AndroidWattsonCpuSubsystemEstimateWire.POLICY1_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._policy1_buf = result.value;
                },
                AndroidWattsonCpuSubsystemEstimateWire.POLICY2_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._policy2_buf = result.value;
                },
                AndroidWattsonCpuSubsystemEstimateWire.POLICY3_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._policy3_buf = result.value;
                },
                AndroidWattsonCpuSubsystemEstimateWire.POLICY4_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._policy4_buf = result.value;
                },
                AndroidWattsonCpuSubsystemEstimateWire.POLICY5_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._policy5_buf = result.value;
                },
                AndroidWattsonCpuSubsystemEstimateWire.POLICY6_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._policy6_buf = result.value;
                },
                AndroidWattsonCpuSubsystemEstimateWire.POLICY7_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._policy7_buf = result.value;
                },
                AndroidWattsonCpuSubsystemEstimateWire.DSU_SCU_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dsu_scu_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getEstimatedMw(self: *const AndroidWattsonCpuSubsystemEstimateReader) f32 {
        return self._estimated_mw;
    }
    pub inline fn getEstimatedMws(self: *const AndroidWattsonCpuSubsystemEstimateReader) f32 {
        return self._estimated_mws;
    }
    pub fn getPolicy0(self: *const AndroidWattsonCpuSubsystemEstimateReader) gremlin.Error!AndroidWattsonPolicyEstimateReader {
        if (self._policy0_buf) |buf| {
            return try AndroidWattsonPolicyEstimateReader.init(buf);
        }
        return try AndroidWattsonPolicyEstimateReader.init(&[_]u8{});
    }
    pub fn getPolicy1(self: *const AndroidWattsonCpuSubsystemEstimateReader) gremlin.Error!AndroidWattsonPolicyEstimateReader {
        if (self._policy1_buf) |buf| {
            return try AndroidWattsonPolicyEstimateReader.init(buf);
        }
        return try AndroidWattsonPolicyEstimateReader.init(&[_]u8{});
    }
    pub fn getPolicy2(self: *const AndroidWattsonCpuSubsystemEstimateReader) gremlin.Error!AndroidWattsonPolicyEstimateReader {
        if (self._policy2_buf) |buf| {
            return try AndroidWattsonPolicyEstimateReader.init(buf);
        }
        return try AndroidWattsonPolicyEstimateReader.init(&[_]u8{});
    }
    pub fn getPolicy3(self: *const AndroidWattsonCpuSubsystemEstimateReader) gremlin.Error!AndroidWattsonPolicyEstimateReader {
        if (self._policy3_buf) |buf| {
            return try AndroidWattsonPolicyEstimateReader.init(buf);
        }
        return try AndroidWattsonPolicyEstimateReader.init(&[_]u8{});
    }
    pub fn getPolicy4(self: *const AndroidWattsonCpuSubsystemEstimateReader) gremlin.Error!AndroidWattsonPolicyEstimateReader {
        if (self._policy4_buf) |buf| {
            return try AndroidWattsonPolicyEstimateReader.init(buf);
        }
        return try AndroidWattsonPolicyEstimateReader.init(&[_]u8{});
    }
    pub fn getPolicy5(self: *const AndroidWattsonCpuSubsystemEstimateReader) gremlin.Error!AndroidWattsonPolicyEstimateReader {
        if (self._policy5_buf) |buf| {
            return try AndroidWattsonPolicyEstimateReader.init(buf);
        }
        return try AndroidWattsonPolicyEstimateReader.init(&[_]u8{});
    }
    pub fn getPolicy6(self: *const AndroidWattsonCpuSubsystemEstimateReader) gremlin.Error!AndroidWattsonPolicyEstimateReader {
        if (self._policy6_buf) |buf| {
            return try AndroidWattsonPolicyEstimateReader.init(buf);
        }
        return try AndroidWattsonPolicyEstimateReader.init(&[_]u8{});
    }
    pub fn getPolicy7(self: *const AndroidWattsonCpuSubsystemEstimateReader) gremlin.Error!AndroidWattsonPolicyEstimateReader {
        if (self._policy7_buf) |buf| {
            return try AndroidWattsonPolicyEstimateReader.init(buf);
        }
        return try AndroidWattsonPolicyEstimateReader.init(&[_]u8{});
    }
    pub fn getDsuScu(self: *const AndroidWattsonCpuSubsystemEstimateReader) gremlin.Error!AndroidWattsonDsuScuEstimateReader {
        if (self._dsu_scu_buf) |buf| {
            return try AndroidWattsonDsuScuEstimateReader.init(buf);
        }
        return try AndroidWattsonDsuScuEstimateReader.init(&[_]u8{});
    }
};
const AndroidWattsonPolicyEstimateWire = struct {
    const ESTIMATED_MW_WIRE: gremlin.ProtoWireNumber = 1;
    const ESTIMATED_MWS_WIRE: gremlin.ProtoWireNumber = 2;
    const CPU0_WIRE: gremlin.ProtoWireNumber = 3;
    const CPU1_WIRE: gremlin.ProtoWireNumber = 4;
    const CPU2_WIRE: gremlin.ProtoWireNumber = 5;
    const CPU3_WIRE: gremlin.ProtoWireNumber = 6;
    const CPU4_WIRE: gremlin.ProtoWireNumber = 7;
    const CPU5_WIRE: gremlin.ProtoWireNumber = 8;
    const CPU6_WIRE: gremlin.ProtoWireNumber = 9;
    const CPU7_WIRE: gremlin.ProtoWireNumber = 10;
};
pub const AndroidWattsonPolicyEstimate = struct {
    // fields
    estimated_mw: f32 = 0.0,
    estimated_mws: f32 = 0.0,
    cpu0: ?AndroidWattsonCpuEstimate = null,
    cpu1: ?AndroidWattsonCpuEstimate = null,
    cpu2: ?AndroidWattsonCpuEstimate = null,
    cpu3: ?AndroidWattsonCpuEstimate = null,
    cpu4: ?AndroidWattsonCpuEstimate = null,
    cpu5: ?AndroidWattsonCpuEstimate = null,
    cpu6: ?AndroidWattsonCpuEstimate = null,
    cpu7: ?AndroidWattsonCpuEstimate = null,
    pub fn calcProtobufSize(self: *const AndroidWattsonPolicyEstimate) usize {
        var res: usize = 0;
        if (self.estimated_mw != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonPolicyEstimateWire.ESTIMATED_MW_WIRE) + gremlin.sizes.sizeFloat(self.estimated_mw);
        }
        if (self.estimated_mws != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonPolicyEstimateWire.ESTIMATED_MWS_WIRE) + gremlin.sizes.sizeFloat(self.estimated_mws);
        }
        if (self.cpu0) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonPolicyEstimateWire.CPU0_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cpu1) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonPolicyEstimateWire.CPU1_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cpu2) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonPolicyEstimateWire.CPU2_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cpu3) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonPolicyEstimateWire.CPU3_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cpu4) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonPolicyEstimateWire.CPU4_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cpu5) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonPolicyEstimateWire.CPU5_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cpu6) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonPolicyEstimateWire.CPU6_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cpu7) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonPolicyEstimateWire.CPU7_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidWattsonPolicyEstimate, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidWattsonPolicyEstimate, target: *gremlin.Writer) void {
        if (self.estimated_mw != 0.0) {
            target.appendFloat32(AndroidWattsonPolicyEstimateWire.ESTIMATED_MW_WIRE, self.estimated_mw);
        }
        if (self.estimated_mws != 0.0) {
            target.appendFloat32(AndroidWattsonPolicyEstimateWire.ESTIMATED_MWS_WIRE, self.estimated_mws);
        }
        if (self.cpu0) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidWattsonPolicyEstimateWire.CPU0_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cpu1) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidWattsonPolicyEstimateWire.CPU1_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cpu2) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidWattsonPolicyEstimateWire.CPU2_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cpu3) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidWattsonPolicyEstimateWire.CPU3_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cpu4) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidWattsonPolicyEstimateWire.CPU4_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cpu5) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidWattsonPolicyEstimateWire.CPU5_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cpu6) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidWattsonPolicyEstimateWire.CPU6_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cpu7) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidWattsonPolicyEstimateWire.CPU7_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const AndroidWattsonPolicyEstimateReader = struct {
    buf: gremlin.Reader,
    _estimated_mw: f32 = 0.0,
    _estimated_mws: f32 = 0.0,
    _cpu0_buf: ?[]const u8 = null,
    _cpu1_buf: ?[]const u8 = null,
    _cpu2_buf: ?[]const u8 = null,
    _cpu3_buf: ?[]const u8 = null,
    _cpu4_buf: ?[]const u8 = null,
    _cpu5_buf: ?[]const u8 = null,
    _cpu6_buf: ?[]const u8 = null,
    _cpu7_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!AndroidWattsonPolicyEstimateReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidWattsonPolicyEstimateReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidWattsonPolicyEstimateWire.ESTIMATED_MW_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._estimated_mw = result.value;
                },
                AndroidWattsonPolicyEstimateWire.ESTIMATED_MWS_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._estimated_mws = result.value;
                },
                AndroidWattsonPolicyEstimateWire.CPU0_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cpu0_buf = result.value;
                },
                AndroidWattsonPolicyEstimateWire.CPU1_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cpu1_buf = result.value;
                },
                AndroidWattsonPolicyEstimateWire.CPU2_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cpu2_buf = result.value;
                },
                AndroidWattsonPolicyEstimateWire.CPU3_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cpu3_buf = result.value;
                },
                AndroidWattsonPolicyEstimateWire.CPU4_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cpu4_buf = result.value;
                },
                AndroidWattsonPolicyEstimateWire.CPU5_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cpu5_buf = result.value;
                },
                AndroidWattsonPolicyEstimateWire.CPU6_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cpu6_buf = result.value;
                },
                AndroidWattsonPolicyEstimateWire.CPU7_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cpu7_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getEstimatedMw(self: *const AndroidWattsonPolicyEstimateReader) f32 {
        return self._estimated_mw;
    }
    pub inline fn getEstimatedMws(self: *const AndroidWattsonPolicyEstimateReader) f32 {
        return self._estimated_mws;
    }
    pub fn getCpu0(self: *const AndroidWattsonPolicyEstimateReader) gremlin.Error!AndroidWattsonCpuEstimateReader {
        if (self._cpu0_buf) |buf| {
            return try AndroidWattsonCpuEstimateReader.init(buf);
        }
        return try AndroidWattsonCpuEstimateReader.init(&[_]u8{});
    }
    pub fn getCpu1(self: *const AndroidWattsonPolicyEstimateReader) gremlin.Error!AndroidWattsonCpuEstimateReader {
        if (self._cpu1_buf) |buf| {
            return try AndroidWattsonCpuEstimateReader.init(buf);
        }
        return try AndroidWattsonCpuEstimateReader.init(&[_]u8{});
    }
    pub fn getCpu2(self: *const AndroidWattsonPolicyEstimateReader) gremlin.Error!AndroidWattsonCpuEstimateReader {
        if (self._cpu2_buf) |buf| {
            return try AndroidWattsonCpuEstimateReader.init(buf);
        }
        return try AndroidWattsonCpuEstimateReader.init(&[_]u8{});
    }
    pub fn getCpu3(self: *const AndroidWattsonPolicyEstimateReader) gremlin.Error!AndroidWattsonCpuEstimateReader {
        if (self._cpu3_buf) |buf| {
            return try AndroidWattsonCpuEstimateReader.init(buf);
        }
        return try AndroidWattsonCpuEstimateReader.init(&[_]u8{});
    }
    pub fn getCpu4(self: *const AndroidWattsonPolicyEstimateReader) gremlin.Error!AndroidWattsonCpuEstimateReader {
        if (self._cpu4_buf) |buf| {
            return try AndroidWattsonCpuEstimateReader.init(buf);
        }
        return try AndroidWattsonCpuEstimateReader.init(&[_]u8{});
    }
    pub fn getCpu5(self: *const AndroidWattsonPolicyEstimateReader) gremlin.Error!AndroidWattsonCpuEstimateReader {
        if (self._cpu5_buf) |buf| {
            return try AndroidWattsonCpuEstimateReader.init(buf);
        }
        return try AndroidWattsonCpuEstimateReader.init(&[_]u8{});
    }
    pub fn getCpu6(self: *const AndroidWattsonPolicyEstimateReader) gremlin.Error!AndroidWattsonCpuEstimateReader {
        if (self._cpu6_buf) |buf| {
            return try AndroidWattsonCpuEstimateReader.init(buf);
        }
        return try AndroidWattsonCpuEstimateReader.init(&[_]u8{});
    }
    pub fn getCpu7(self: *const AndroidWattsonPolicyEstimateReader) gremlin.Error!AndroidWattsonCpuEstimateReader {
        if (self._cpu7_buf) |buf| {
            return try AndroidWattsonCpuEstimateReader.init(buf);
        }
        return try AndroidWattsonCpuEstimateReader.init(&[_]u8{});
    }
};
const AndroidWattsonCpuEstimateWire = struct {
    const ESTIMATED_MW_WIRE: gremlin.ProtoWireNumber = 1;
    const ESTIMATED_MWS_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const AndroidWattsonCpuEstimate = struct {
    // fields
    estimated_mw: f32 = 0.0,
    estimated_mws: f32 = 0.0,
    pub fn calcProtobufSize(self: *const AndroidWattsonCpuEstimate) usize {
        var res: usize = 0;
        if (self.estimated_mw != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonCpuEstimateWire.ESTIMATED_MW_WIRE) + gremlin.sizes.sizeFloat(self.estimated_mw);
        }
        if (self.estimated_mws != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonCpuEstimateWire.ESTIMATED_MWS_WIRE) + gremlin.sizes.sizeFloat(self.estimated_mws);
        }
        return res;
    }
    pub fn encode(self: *const AndroidWattsonCpuEstimate, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidWattsonCpuEstimate, target: *gremlin.Writer) void {
        if (self.estimated_mw != 0.0) {
            target.appendFloat32(AndroidWattsonCpuEstimateWire.ESTIMATED_MW_WIRE, self.estimated_mw);
        }
        if (self.estimated_mws != 0.0) {
            target.appendFloat32(AndroidWattsonCpuEstimateWire.ESTIMATED_MWS_WIRE, self.estimated_mws);
        }
    }
};
pub const AndroidWattsonCpuEstimateReader = struct {
    buf: gremlin.Reader,
    _estimated_mw: f32 = 0.0,
    _estimated_mws: f32 = 0.0,
    pub fn init(src: []const u8) gremlin.Error!AndroidWattsonCpuEstimateReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidWattsonCpuEstimateReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidWattsonCpuEstimateWire.ESTIMATED_MW_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._estimated_mw = result.value;
                },
                AndroidWattsonCpuEstimateWire.ESTIMATED_MWS_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._estimated_mws = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getEstimatedMw(self: *const AndroidWattsonCpuEstimateReader) f32 {
        return self._estimated_mw;
    }
    pub inline fn getEstimatedMws(self: *const AndroidWattsonCpuEstimateReader) f32 {
        return self._estimated_mws;
    }
};
const AndroidWattsonDsuScuEstimateWire = struct {
    const ESTIMATED_MW_WIRE: gremlin.ProtoWireNumber = 1;
    const ESTIMATED_MWS_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const AndroidWattsonDsuScuEstimate = struct {
    // fields
    estimated_mw: f32 = 0.0,
    estimated_mws: f32 = 0.0,
    pub fn calcProtobufSize(self: *const AndroidWattsonDsuScuEstimate) usize {
        var res: usize = 0;
        if (self.estimated_mw != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonDsuScuEstimateWire.ESTIMATED_MW_WIRE) + gremlin.sizes.sizeFloat(self.estimated_mw);
        }
        if (self.estimated_mws != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonDsuScuEstimateWire.ESTIMATED_MWS_WIRE) + gremlin.sizes.sizeFloat(self.estimated_mws);
        }
        return res;
    }
    pub fn encode(self: *const AndroidWattsonDsuScuEstimate, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidWattsonDsuScuEstimate, target: *gremlin.Writer) void {
        if (self.estimated_mw != 0.0) {
            target.appendFloat32(AndroidWattsonDsuScuEstimateWire.ESTIMATED_MW_WIRE, self.estimated_mw);
        }
        if (self.estimated_mws != 0.0) {
            target.appendFloat32(AndroidWattsonDsuScuEstimateWire.ESTIMATED_MWS_WIRE, self.estimated_mws);
        }
    }
};
pub const AndroidWattsonDsuScuEstimateReader = struct {
    buf: gremlin.Reader,
    _estimated_mw: f32 = 0.0,
    _estimated_mws: f32 = 0.0,
    pub fn init(src: []const u8) gremlin.Error!AndroidWattsonDsuScuEstimateReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidWattsonDsuScuEstimateReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidWattsonDsuScuEstimateWire.ESTIMATED_MW_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._estimated_mw = result.value;
                },
                AndroidWattsonDsuScuEstimateWire.ESTIMATED_MWS_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._estimated_mws = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getEstimatedMw(self: *const AndroidWattsonDsuScuEstimateReader) f32 {
        return self._estimated_mw;
    }
    pub inline fn getEstimatedMws(self: *const AndroidWattsonDsuScuEstimateReader) f32 {
        return self._estimated_mws;
    }
};
const AndroidWattsonGpuSubsystemEstimateWire = struct {
    const ESTIMATED_MW_WIRE: gremlin.ProtoWireNumber = 1;
    const ESTIMATED_MWS_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const AndroidWattsonGpuSubsystemEstimate = struct {
    // fields
    estimated_mw: f32 = 0.0,
    estimated_mws: f32 = 0.0,
    pub fn calcProtobufSize(self: *const AndroidWattsonGpuSubsystemEstimate) usize {
        var res: usize = 0;
        if (self.estimated_mw != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonGpuSubsystemEstimateWire.ESTIMATED_MW_WIRE) + gremlin.sizes.sizeFloat(self.estimated_mw);
        }
        if (self.estimated_mws != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonGpuSubsystemEstimateWire.ESTIMATED_MWS_WIRE) + gremlin.sizes.sizeFloat(self.estimated_mws);
        }
        return res;
    }
    pub fn encode(self: *const AndroidWattsonGpuSubsystemEstimate, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidWattsonGpuSubsystemEstimate, target: *gremlin.Writer) void {
        if (self.estimated_mw != 0.0) {
            target.appendFloat32(AndroidWattsonGpuSubsystemEstimateWire.ESTIMATED_MW_WIRE, self.estimated_mw);
        }
        if (self.estimated_mws != 0.0) {
            target.appendFloat32(AndroidWattsonGpuSubsystemEstimateWire.ESTIMATED_MWS_WIRE, self.estimated_mws);
        }
    }
};
pub const AndroidWattsonGpuSubsystemEstimateReader = struct {
    buf: gremlin.Reader,
    _estimated_mw: f32 = 0.0,
    _estimated_mws: f32 = 0.0,
    pub fn init(src: []const u8) gremlin.Error!AndroidWattsonGpuSubsystemEstimateReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidWattsonGpuSubsystemEstimateReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidWattsonGpuSubsystemEstimateWire.ESTIMATED_MW_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._estimated_mw = result.value;
                },
                AndroidWattsonGpuSubsystemEstimateWire.ESTIMATED_MWS_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._estimated_mws = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getEstimatedMw(self: *const AndroidWattsonGpuSubsystemEstimateReader) f32 {
        return self._estimated_mw;
    }
    pub inline fn getEstimatedMws(self: *const AndroidWattsonGpuSubsystemEstimateReader) f32 {
        return self._estimated_mws;
    }
};
const AndroidWattsonTasksAttributionMetricWire = struct {
    const METRIC_VERSION_WIRE: gremlin.ProtoWireNumber = 1;
    const POWER_MODEL_VERSION_WIRE: gremlin.ProtoWireNumber = 2;
    const PERIOD_INFO_WIRE: gremlin.ProtoWireNumber = 3;
    const IS_CRUDE_ESTIMATE_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const AndroidWattsonTasksAttributionMetric = struct {
    // fields
    metric_version: i32 = 0,
    power_model_version: i32 = 0,
    period_info: ?[]const ?AndroidWattsonTaskPeriodInfo = null,
    is_crude_estimate: bool = false,
    pub fn calcProtobufSize(self: *const AndroidWattsonTasksAttributionMetric) usize {
        var res: usize = 0;
        if (self.metric_version != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonTasksAttributionMetricWire.METRIC_VERSION_WIRE) + gremlin.sizes.sizeI32(self.metric_version);
        }
        if (self.power_model_version != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonTasksAttributionMetricWire.POWER_MODEL_VERSION_WIRE) + gremlin.sizes.sizeI32(self.power_model_version);
        }
        if (self.period_info) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonTasksAttributionMetricWire.PERIOD_INFO_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.is_crude_estimate != false) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonTasksAttributionMetricWire.IS_CRUDE_ESTIMATE_WIRE) + gremlin.sizes.sizeBool(self.is_crude_estimate);
        }
        return res;
    }
    pub fn encode(self: *const AndroidWattsonTasksAttributionMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidWattsonTasksAttributionMetric, target: *gremlin.Writer) void {
        if (self.metric_version != 0) {
            target.appendInt32(AndroidWattsonTasksAttributionMetricWire.METRIC_VERSION_WIRE, self.metric_version);
        }
        if (self.power_model_version != 0) {
            target.appendInt32(AndroidWattsonTasksAttributionMetricWire.POWER_MODEL_VERSION_WIRE, self.power_model_version);
        }
        if (self.period_info) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidWattsonTasksAttributionMetricWire.PERIOD_INFO_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidWattsonTasksAttributionMetricWire.PERIOD_INFO_WIRE, 0);
                }
            }
        }
        if (self.is_crude_estimate != false) {
            target.appendBool(AndroidWattsonTasksAttributionMetricWire.IS_CRUDE_ESTIMATE_WIRE, self.is_crude_estimate);
        }
    }
};
pub const AndroidWattsonTasksAttributionMetricReader = struct {
    buf: gremlin.Reader,
    _metric_version: i32 = 0,
    _power_model_version: i32 = 0,
    _period_info_offset: ?usize = null,
    _period_info_last_offset: ?usize = null,
    _period_info_cnt: usize = 0,
    _is_crude_estimate: bool = false,
    pub fn init(src: []const u8) gremlin.Error!AndroidWattsonTasksAttributionMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidWattsonTasksAttributionMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidWattsonTasksAttributionMetricWire.METRIC_VERSION_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._metric_version = result.value;
                },
                AndroidWattsonTasksAttributionMetricWire.POWER_MODEL_VERSION_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._power_model_version = result.value;
                },
                AndroidWattsonTasksAttributionMetricWire.PERIOD_INFO_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._period_info_offset == null) {
                        res._period_info_offset = offset - result.size;
                    }
                    res._period_info_last_offset = offset;
                    res._period_info_cnt += 1;
                },
                AndroidWattsonTasksAttributionMetricWire.IS_CRUDE_ESTIMATE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_crude_estimate = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getMetricVersion(self: *const AndroidWattsonTasksAttributionMetricReader) i32 {
        return self._metric_version;
    }
    pub inline fn getPowerModelVersion(self: *const AndroidWattsonTasksAttributionMetricReader) i32 {
        return self._power_model_version;
    }
    pub fn periodInfoCount(self: *const AndroidWattsonTasksAttributionMetricReader) usize {
        return self._period_info_cnt;
    }
    pub fn periodInfoNext(self: *AndroidWattsonTasksAttributionMetricReader) ?AndroidWattsonTaskPeriodInfoReader {
        if (self._period_info_offset == null) return null;
        const current_offset = self._period_info_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidWattsonTaskPeriodInfoReader.init(result.value) catch return null;
        if (self._period_info_last_offset != null and current_offset >= self._period_info_last_offset.?) {
            self._period_info_offset = null;
            return msg;
        }
        if (self._period_info_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._period_info_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidWattsonTasksAttributionMetricWire.PERIOD_INFO_WIRE) {
                self._period_info_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._period_info_offset = null;
        return msg;
    }
    pub inline fn getIsCrudeEstimate(self: *const AndroidWattsonTasksAttributionMetricReader) bool {
        return self._is_crude_estimate;
    }
};
const AndroidWattsonTaskPeriodInfoWire = struct {
    const PERIOD_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const PERIOD_NAME_WIRE: gremlin.ProtoWireNumber = 2;
    const TASK_INFO_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const AndroidWattsonTaskPeriodInfo = struct {
    // fields
    period_id: i32 = 0,
    period_name: ?[]const u8 = null,
    task_info: ?[]const ?AndroidWattsonTaskInfo = null,
    pub fn calcProtobufSize(self: *const AndroidWattsonTaskPeriodInfo) usize {
        var res: usize = 0;
        if (self.period_id != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonTaskPeriodInfoWire.PERIOD_ID_WIRE) + gremlin.sizes.sizeI32(self.period_id);
        }
        if (self.period_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonTaskPeriodInfoWire.PERIOD_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.task_info) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonTaskPeriodInfoWire.TASK_INFO_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidWattsonTaskPeriodInfo, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidWattsonTaskPeriodInfo, target: *gremlin.Writer) void {
        if (self.period_id != 0) {
            target.appendInt32(AndroidWattsonTaskPeriodInfoWire.PERIOD_ID_WIRE, self.period_id);
        }
        if (self.period_name) |v| {
            if (v.len > 0) {
                target.appendBytes(AndroidWattsonTaskPeriodInfoWire.PERIOD_NAME_WIRE, v);
            }
        }
        if (self.task_info) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidWattsonTaskPeriodInfoWire.TASK_INFO_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidWattsonTaskPeriodInfoWire.TASK_INFO_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidWattsonTaskPeriodInfoReader = struct {
    buf: gremlin.Reader,
    _period_id: i32 = 0,
    _period_name: ?[]const u8 = null,
    _task_info_offset: ?usize = null,
    _task_info_last_offset: ?usize = null,
    _task_info_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidWattsonTaskPeriodInfoReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidWattsonTaskPeriodInfoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidWattsonTaskPeriodInfoWire.PERIOD_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._period_id = result.value;
                },
                AndroidWattsonTaskPeriodInfoWire.PERIOD_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._period_name = result.value;
                },
                AndroidWattsonTaskPeriodInfoWire.TASK_INFO_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._task_info_offset == null) {
                        res._task_info_offset = offset - result.size;
                    }
                    res._task_info_last_offset = offset;
                    res._task_info_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getPeriodId(self: *const AndroidWattsonTaskPeriodInfoReader) i32 {
        return self._period_id;
    }
    pub inline fn getPeriodName(self: *const AndroidWattsonTaskPeriodInfoReader) []const u8 {
        return self._period_name orelse &[_]u8{};
    }
    pub fn taskInfoCount(self: *const AndroidWattsonTaskPeriodInfoReader) usize {
        return self._task_info_cnt;
    }
    pub fn taskInfoNext(self: *AndroidWattsonTaskPeriodInfoReader) ?AndroidWattsonTaskInfoReader {
        if (self._task_info_offset == null) return null;
        const current_offset = self._task_info_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidWattsonTaskInfoReader.init(result.value) catch return null;
        if (self._task_info_last_offset != null and current_offset >= self._task_info_last_offset.?) {
            self._task_info_offset = null;
            return msg;
        }
        if (self._task_info_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._task_info_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidWattsonTaskPeriodInfoWire.TASK_INFO_WIRE) {
                self._task_info_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._task_info_offset = null;
        return msg;
    }
};
const AndroidWattsonTaskInfoWire = struct {
    const ESTIMATED_MW_WIRE: gremlin.ProtoWireNumber = 1;
    const ESTIMATED_MWS_WIRE: gremlin.ProtoWireNumber = 2;
    const IDLE_TRANSITIONS_MWS_WIRE: gremlin.ProtoWireNumber = 3;
    const TOTAL_MWS_WIRE: gremlin.ProtoWireNumber = 4;
    const THREAD_NAME_WIRE: gremlin.ProtoWireNumber = 5;
    const PROCESS_NAME_WIRE: gremlin.ProtoWireNumber = 6;
    const PACKAGE_NAME_WIRE: gremlin.ProtoWireNumber = 7;
    const THREAD_ID_WIRE: gremlin.ProtoWireNumber = 8;
    const PROCESS_ID_WIRE: gremlin.ProtoWireNumber = 9;
};
pub const AndroidWattsonTaskInfo = struct {
    // fields
    estimated_mw: f32 = 0.0,
    estimated_mws: f32 = 0.0,
    idle_transitions_mws: f32 = 0.0,
    total_mws: f32 = 0.0,
    thread_name: ?[]const u8 = null,
    process_name: ?[]const u8 = null,
    package_name: ?[]const u8 = null,
    thread_id: i32 = 0,
    process_id: i32 = 0,
    pub fn calcProtobufSize(self: *const AndroidWattsonTaskInfo) usize {
        var res: usize = 0;
        if (self.estimated_mw != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonTaskInfoWire.ESTIMATED_MW_WIRE) + gremlin.sizes.sizeFloat(self.estimated_mw);
        }
        if (self.estimated_mws != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonTaskInfoWire.ESTIMATED_MWS_WIRE) + gremlin.sizes.sizeFloat(self.estimated_mws);
        }
        if (self.idle_transitions_mws != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonTaskInfoWire.IDLE_TRANSITIONS_MWS_WIRE) + gremlin.sizes.sizeFloat(self.idle_transitions_mws);
        }
        if (self.total_mws != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonTaskInfoWire.TOTAL_MWS_WIRE) + gremlin.sizes.sizeFloat(self.total_mws);
        }
        if (self.thread_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonTaskInfoWire.THREAD_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.process_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonTaskInfoWire.PROCESS_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.package_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonTaskInfoWire.PACKAGE_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.thread_id != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonTaskInfoWire.THREAD_ID_WIRE) + gremlin.sizes.sizeI32(self.thread_id);
        }
        if (self.process_id != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonTaskInfoWire.PROCESS_ID_WIRE) + gremlin.sizes.sizeI32(self.process_id);
        }
        return res;
    }
    pub fn encode(self: *const AndroidWattsonTaskInfo, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidWattsonTaskInfo, target: *gremlin.Writer) void {
        if (self.estimated_mw != 0.0) {
            target.appendFloat32(AndroidWattsonTaskInfoWire.ESTIMATED_MW_WIRE, self.estimated_mw);
        }
        if (self.estimated_mws != 0.0) {
            target.appendFloat32(AndroidWattsonTaskInfoWire.ESTIMATED_MWS_WIRE, self.estimated_mws);
        }
        if (self.idle_transitions_mws != 0.0) {
            target.appendFloat32(AndroidWattsonTaskInfoWire.IDLE_TRANSITIONS_MWS_WIRE, self.idle_transitions_mws);
        }
        if (self.total_mws != 0.0) {
            target.appendFloat32(AndroidWattsonTaskInfoWire.TOTAL_MWS_WIRE, self.total_mws);
        }
        if (self.thread_name) |v| {
            if (v.len > 0) {
                target.appendBytes(AndroidWattsonTaskInfoWire.THREAD_NAME_WIRE, v);
            }
        }
        if (self.process_name) |v| {
            if (v.len > 0) {
                target.appendBytes(AndroidWattsonTaskInfoWire.PROCESS_NAME_WIRE, v);
            }
        }
        if (self.package_name) |v| {
            if (v.len > 0) {
                target.appendBytes(AndroidWattsonTaskInfoWire.PACKAGE_NAME_WIRE, v);
            }
        }
        if (self.thread_id != 0) {
            target.appendInt32(AndroidWattsonTaskInfoWire.THREAD_ID_WIRE, self.thread_id);
        }
        if (self.process_id != 0) {
            target.appendInt32(AndroidWattsonTaskInfoWire.PROCESS_ID_WIRE, self.process_id);
        }
    }
};
pub const AndroidWattsonTaskInfoReader = struct {
    buf: gremlin.Reader,
    _estimated_mw: f32 = 0.0,
    _estimated_mws: f32 = 0.0,
    _idle_transitions_mws: f32 = 0.0,
    _total_mws: f32 = 0.0,
    _thread_name: ?[]const u8 = null,
    _process_name: ?[]const u8 = null,
    _package_name: ?[]const u8 = null,
    _thread_id: i32 = 0,
    _process_id: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidWattsonTaskInfoReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidWattsonTaskInfoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidWattsonTaskInfoWire.ESTIMATED_MW_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._estimated_mw = result.value;
                },
                AndroidWattsonTaskInfoWire.ESTIMATED_MWS_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._estimated_mws = result.value;
                },
                AndroidWattsonTaskInfoWire.IDLE_TRANSITIONS_MWS_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._idle_transitions_mws = result.value;
                },
                AndroidWattsonTaskInfoWire.TOTAL_MWS_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._total_mws = result.value;
                },
                AndroidWattsonTaskInfoWire.THREAD_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._thread_name = result.value;
                },
                AndroidWattsonTaskInfoWire.PROCESS_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._process_name = result.value;
                },
                AndroidWattsonTaskInfoWire.PACKAGE_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._package_name = result.value;
                },
                AndroidWattsonTaskInfoWire.THREAD_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._thread_id = result.value;
                },
                AndroidWattsonTaskInfoWire.PROCESS_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._process_id = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getEstimatedMw(self: *const AndroidWattsonTaskInfoReader) f32 {
        return self._estimated_mw;
    }
    pub inline fn getEstimatedMws(self: *const AndroidWattsonTaskInfoReader) f32 {
        return self._estimated_mws;
    }
    pub inline fn getIdleTransitionsMws(self: *const AndroidWattsonTaskInfoReader) f32 {
        return self._idle_transitions_mws;
    }
    pub inline fn getTotalMws(self: *const AndroidWattsonTaskInfoReader) f32 {
        return self._total_mws;
    }
    pub inline fn getThreadName(self: *const AndroidWattsonTaskInfoReader) []const u8 {
        return self._thread_name orelse &[_]u8{};
    }
    pub inline fn getProcessName(self: *const AndroidWattsonTaskInfoReader) []const u8 {
        return self._process_name orelse &[_]u8{};
    }
    pub inline fn getPackageName(self: *const AndroidWattsonTaskInfoReader) []const u8 {
        return self._package_name orelse &[_]u8{};
    }
    pub inline fn getThreadId(self: *const AndroidWattsonTaskInfoReader) i32 {
        return self._thread_id;
    }
    pub inline fn getProcessId(self: *const AndroidWattsonTaskInfoReader) i32 {
        return self._process_id;
    }
};
const CloneDurationWire = struct {
    const BY_BUFFER_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const CloneDuration = struct {
    // nested structs
    const ByBufferWire = struct {
        const BUFFER_WIRE: gremlin.ProtoWireNumber = 1;
        const DURATION_NS_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const ByBuffer = struct {
        // fields
        buffer: i32 = 0,
        duration_ns: i64 = 0,
        pub fn calcProtobufSize(self: *const CloneDuration.ByBuffer) usize {
            var res: usize = 0;
            if (self.buffer != 0) {
                res += gremlin.sizes.sizeWireNumber(CloneDuration.ByBufferWire.BUFFER_WIRE) + gremlin.sizes.sizeI32(self.buffer);
            }
            if (self.duration_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(CloneDuration.ByBufferWire.DURATION_NS_WIRE) + gremlin.sizes.sizeI64(self.duration_ns);
            }
            return res;
        }
        pub fn encode(self: *const CloneDuration.ByBuffer, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const CloneDuration.ByBuffer, target: *gremlin.Writer) void {
            if (self.buffer != 0) {
                target.appendInt32(CloneDuration.ByBufferWire.BUFFER_WIRE, self.buffer);
            }
            if (self.duration_ns != 0) {
                target.appendInt64(CloneDuration.ByBufferWire.DURATION_NS_WIRE, self.duration_ns);
            }
        }
    };
    pub const ByBufferReader = struct {
        buf: gremlin.Reader,
        _buffer: i32 = 0,
        _duration_ns: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!CloneDuration.ByBufferReader {
            const buf = gremlin.Reader.init(src);
            var res = CloneDuration.ByBufferReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    CloneDuration.ByBufferWire.BUFFER_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._buffer = result.value;
                    },
                    CloneDuration.ByBufferWire.DURATION_NS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._duration_ns = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getBuffer(self: *const CloneDuration.ByBufferReader) i32 {
            return self._buffer;
        }
        pub inline fn getDurationNs(self: *const CloneDuration.ByBufferReader) i64 {
            return self._duration_ns;
        }
    };
    // fields
    by_buffer: ?[]const ?CloneDuration.ByBuffer = null,
    pub fn calcProtobufSize(self: *const CloneDuration) usize {
        var res: usize = 0;
        if (self.by_buffer) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(CloneDurationWire.BY_BUFFER_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const CloneDuration, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const CloneDuration, target: *gremlin.Writer) void {
        if (self.by_buffer) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(CloneDurationWire.BY_BUFFER_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(CloneDurationWire.BY_BUFFER_WIRE, 0);
                }
            }
        }
    }
};
pub const CloneDurationReader = struct {
    buf: gremlin.Reader,
    _by_buffer_offset: ?usize = null,
    _by_buffer_last_offset: ?usize = null,
    _by_buffer_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!CloneDurationReader {
        const buf = gremlin.Reader.init(src);
        var res = CloneDurationReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                CloneDurationWire.BY_BUFFER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._by_buffer_offset == null) {
                        res._by_buffer_offset = offset - result.size;
                    }
                    res._by_buffer_last_offset = offset;
                    res._by_buffer_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn byBufferCount(self: *const CloneDurationReader) usize {
        return self._by_buffer_cnt;
    }
    pub fn byBufferNext(self: *CloneDurationReader) ?CloneDuration.ByBufferReader {
        if (self._by_buffer_offset == null) return null;
        const current_offset = self._by_buffer_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = CloneDuration.ByBufferReader.init(result.value) catch return null;
        if (self._by_buffer_last_offset != null and current_offset >= self._by_buffer_last_offset.?) {
            self._by_buffer_offset = null;
            return msg;
        }
        if (self._by_buffer_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._by_buffer_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == CloneDurationWire.BY_BUFFER_WIRE) {
                self._by_buffer_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._by_buffer_offset = null;
        return msg;
    }
};
const TraceMetadataWire = struct {
    const TRACE_DURATION_NS_WIRE: gremlin.ProtoWireNumber = 2;
    const TRACE_UUID_WIRE: gremlin.ProtoWireNumber = 3;
    const ANDROID_BUILD_FINGERPRINT_WIRE: gremlin.ProtoWireNumber = 4;
    const ANDROID_DEVICE_MANUFACTURER_WIRE: gremlin.ProtoWireNumber = 16;
    const ANDROID_PROFILE_BOOT_CLASSPATH_WIRE: gremlin.ProtoWireNumber = 18;
    const ANDROID_PROFILE_SYSTEM_SERVER_WIRE: gremlin.ProtoWireNumber = 19;
    const STATSD_TRIGGERING_SUBSCRIPTION_ID_WIRE: gremlin.ProtoWireNumber = 5;
    const TRACE_SIZE_BYTES_WIRE: gremlin.ProtoWireNumber = 6;
    const TRACE_TRIGGER_WIRE: gremlin.ProtoWireNumber = 7;
    const TRACE_CAUSAL_TRIGGER_WIRE: gremlin.ProtoWireNumber = 17;
    const UNIQUE_SESSION_NAME_WIRE: gremlin.ProtoWireNumber = 8;
    const TRACE_CONFIG_PBTXT_WIRE: gremlin.ProtoWireNumber = 9;
    const SCHED_DURATION_NS_WIRE: gremlin.ProtoWireNumber = 10;
    const TRACING_STARTED_NS_WIRE: gremlin.ProtoWireNumber = 11;
    const ANDROID_SDK_VERSION_WIRE: gremlin.ProtoWireNumber = 12;
    const SUSPEND_COUNT_WIRE: gremlin.ProtoWireNumber = 13;
    const DATA_LOSS_COUNT_WIRE: gremlin.ProtoWireNumber = 14;
    const ERROR_COUNT_WIRE: gremlin.ProtoWireNumber = 15;
};
pub const TraceMetadata = struct {
    // fields
    trace_duration_ns: i64 = 0,
    trace_uuid: ?[]const u8 = null,
    android_build_fingerprint: ?[]const u8 = null,
    android_device_manufacturer: ?[]const u8 = null,
    android_profile_boot_classpath: i64 = 0,
    android_profile_system_server: i64 = 0,
    statsd_triggering_subscription_id: i64 = 0,
    trace_size_bytes: i64 = 0,
    trace_trigger: ?[]const ?[]const u8 = null,
    trace_causal_trigger: ?[]const u8 = null,
    unique_session_name: ?[]const u8 = null,
    trace_config_pbtxt: ?[]const u8 = null,
    sched_duration_ns: i64 = 0,
    tracing_started_ns: i64 = 0,
    android_sdk_version: i64 = 0,
    suspend_count: i64 = 0,
    data_loss_count: i64 = 0,
    error_count: i64 = 0,
    pub fn calcProtobufSize(self: *const TraceMetadata) usize {
        var res: usize = 0;
        if (self.trace_duration_ns != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceMetadataWire.TRACE_DURATION_NS_WIRE) + gremlin.sizes.sizeI64(self.trace_duration_ns);
        }
        if (self.trace_uuid) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetadataWire.TRACE_UUID_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.android_build_fingerprint) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetadataWire.ANDROID_BUILD_FINGERPRINT_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.android_device_manufacturer) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetadataWire.ANDROID_DEVICE_MANUFACTURER_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.android_profile_boot_classpath != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceMetadataWire.ANDROID_PROFILE_BOOT_CLASSPATH_WIRE) + gremlin.sizes.sizeI64(self.android_profile_boot_classpath);
        }
        if (self.android_profile_system_server != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceMetadataWire.ANDROID_PROFILE_SYSTEM_SERVER_WIRE) + gremlin.sizes.sizeI64(self.android_profile_system_server);
        }
        if (self.statsd_triggering_subscription_id != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceMetadataWire.STATSD_TRIGGERING_SUBSCRIPTION_ID_WIRE) + gremlin.sizes.sizeI64(self.statsd_triggering_subscription_id);
        }
        if (self.trace_size_bytes != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceMetadataWire.TRACE_SIZE_BYTES_WIRE) + gremlin.sizes.sizeI64(self.trace_size_bytes);
        }
        if (self.trace_trigger) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TraceMetadataWire.TRACE_TRIGGER_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.trace_causal_trigger) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetadataWire.TRACE_CAUSAL_TRIGGER_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.unique_session_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetadataWire.UNIQUE_SESSION_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.trace_config_pbtxt) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetadataWire.TRACE_CONFIG_PBTXT_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.sched_duration_ns != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceMetadataWire.SCHED_DURATION_NS_WIRE) + gremlin.sizes.sizeI64(self.sched_duration_ns);
        }
        if (self.tracing_started_ns != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceMetadataWire.TRACING_STARTED_NS_WIRE) + gremlin.sizes.sizeI64(self.tracing_started_ns);
        }
        if (self.android_sdk_version != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceMetadataWire.ANDROID_SDK_VERSION_WIRE) + gremlin.sizes.sizeI64(self.android_sdk_version);
        }
        if (self.suspend_count != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceMetadataWire.SUSPEND_COUNT_WIRE) + gremlin.sizes.sizeI64(self.suspend_count);
        }
        if (self.data_loss_count != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceMetadataWire.DATA_LOSS_COUNT_WIRE) + gremlin.sizes.sizeI64(self.data_loss_count);
        }
        if (self.error_count != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceMetadataWire.ERROR_COUNT_WIRE) + gremlin.sizes.sizeI64(self.error_count);
        }
        return res;
    }
    pub fn encode(self: *const TraceMetadata, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TraceMetadata, target: *gremlin.Writer) void {
        if (self.trace_duration_ns != 0) {
            target.appendInt64(TraceMetadataWire.TRACE_DURATION_NS_WIRE, self.trace_duration_ns);
        }
        if (self.trace_uuid) |v| {
            if (v.len > 0) {
                target.appendBytes(TraceMetadataWire.TRACE_UUID_WIRE, v);
            }
        }
        if (self.android_build_fingerprint) |v| {
            if (v.len > 0) {
                target.appendBytes(TraceMetadataWire.ANDROID_BUILD_FINGERPRINT_WIRE, v);
            }
        }
        if (self.android_device_manufacturer) |v| {
            if (v.len > 0) {
                target.appendBytes(TraceMetadataWire.ANDROID_DEVICE_MANUFACTURER_WIRE, v);
            }
        }
        if (self.android_profile_boot_classpath != 0) {
            target.appendInt64(TraceMetadataWire.ANDROID_PROFILE_BOOT_CLASSPATH_WIRE, self.android_profile_boot_classpath);
        }
        if (self.android_profile_system_server != 0) {
            target.appendInt64(TraceMetadataWire.ANDROID_PROFILE_SYSTEM_SERVER_WIRE, self.android_profile_system_server);
        }
        if (self.statsd_triggering_subscription_id != 0) {
            target.appendInt64(TraceMetadataWire.STATSD_TRIGGERING_SUBSCRIPTION_ID_WIRE, self.statsd_triggering_subscription_id);
        }
        if (self.trace_size_bytes != 0) {
            target.appendInt64(TraceMetadataWire.TRACE_SIZE_BYTES_WIRE, self.trace_size_bytes);
        }
        if (self.trace_trigger) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(TraceMetadataWire.TRACE_TRIGGER_WIRE, v);
                } else {
                    target.appendBytesTag(TraceMetadataWire.TRACE_TRIGGER_WIRE, 0);
                }
            }
        }
        if (self.trace_causal_trigger) |v| {
            if (v.len > 0) {
                target.appendBytes(TraceMetadataWire.TRACE_CAUSAL_TRIGGER_WIRE, v);
            }
        }
        if (self.unique_session_name) |v| {
            if (v.len > 0) {
                target.appendBytes(TraceMetadataWire.UNIQUE_SESSION_NAME_WIRE, v);
            }
        }
        if (self.trace_config_pbtxt) |v| {
            if (v.len > 0) {
                target.appendBytes(TraceMetadataWire.TRACE_CONFIG_PBTXT_WIRE, v);
            }
        }
        if (self.sched_duration_ns != 0) {
            target.appendInt64(TraceMetadataWire.SCHED_DURATION_NS_WIRE, self.sched_duration_ns);
        }
        if (self.tracing_started_ns != 0) {
            target.appendInt64(TraceMetadataWire.TRACING_STARTED_NS_WIRE, self.tracing_started_ns);
        }
        if (self.android_sdk_version != 0) {
            target.appendInt64(TraceMetadataWire.ANDROID_SDK_VERSION_WIRE, self.android_sdk_version);
        }
        if (self.suspend_count != 0) {
            target.appendInt64(TraceMetadataWire.SUSPEND_COUNT_WIRE, self.suspend_count);
        }
        if (self.data_loss_count != 0) {
            target.appendInt64(TraceMetadataWire.DATA_LOSS_COUNT_WIRE, self.data_loss_count);
        }
        if (self.error_count != 0) {
            target.appendInt64(TraceMetadataWire.ERROR_COUNT_WIRE, self.error_count);
        }
    }
};
pub const TraceMetadataReader = struct {
    buf: gremlin.Reader,
    _trace_duration_ns: i64 = 0,
    _trace_uuid: ?[]const u8 = null,
    _android_build_fingerprint: ?[]const u8 = null,
    _android_device_manufacturer: ?[]const u8 = null,
    _android_profile_boot_classpath: i64 = 0,
    _android_profile_system_server: i64 = 0,
    _statsd_triggering_subscription_id: i64 = 0,
    _trace_size_bytes: i64 = 0,
    _trace_trigger_offset: ?usize = null,
    _trace_trigger_last_offset: ?usize = null,
    _trace_trigger_cnt: usize = 0,
    _trace_causal_trigger: ?[]const u8 = null,
    _unique_session_name: ?[]const u8 = null,
    _trace_config_pbtxt: ?[]const u8 = null,
    _sched_duration_ns: i64 = 0,
    _tracing_started_ns: i64 = 0,
    _android_sdk_version: i64 = 0,
    _suspend_count: i64 = 0,
    _data_loss_count: i64 = 0,
    _error_count: i64 = 0,
    pub fn init(src: []const u8) gremlin.Error!TraceMetadataReader {
        const buf = gremlin.Reader.init(src);
        var res = TraceMetadataReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TraceMetadataWire.TRACE_DURATION_NS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._trace_duration_ns = result.value;
                },
                TraceMetadataWire.TRACE_UUID_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._trace_uuid = result.value;
                },
                TraceMetadataWire.ANDROID_BUILD_FINGERPRINT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_build_fingerprint = result.value;
                },
                TraceMetadataWire.ANDROID_DEVICE_MANUFACTURER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_device_manufacturer = result.value;
                },
                TraceMetadataWire.ANDROID_PROFILE_BOOT_CLASSPATH_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._android_profile_boot_classpath = result.value;
                },
                TraceMetadataWire.ANDROID_PROFILE_SYSTEM_SERVER_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._android_profile_system_server = result.value;
                },
                TraceMetadataWire.STATSD_TRIGGERING_SUBSCRIPTION_ID_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._statsd_triggering_subscription_id = result.value;
                },
                TraceMetadataWire.TRACE_SIZE_BYTES_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._trace_size_bytes = result.value;
                },
                TraceMetadataWire.TRACE_TRIGGER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._trace_trigger_offset == null) {
                        res._trace_trigger_offset = offset - result.size;
                    }
                    res._trace_trigger_last_offset = offset;
                    res._trace_trigger_cnt += 1;
                },
                TraceMetadataWire.TRACE_CAUSAL_TRIGGER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._trace_causal_trigger = result.value;
                },
                TraceMetadataWire.UNIQUE_SESSION_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._unique_session_name = result.value;
                },
                TraceMetadataWire.TRACE_CONFIG_PBTXT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._trace_config_pbtxt = result.value;
                },
                TraceMetadataWire.SCHED_DURATION_NS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._sched_duration_ns = result.value;
                },
                TraceMetadataWire.TRACING_STARTED_NS_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._tracing_started_ns = result.value;
                },
                TraceMetadataWire.ANDROID_SDK_VERSION_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._android_sdk_version = result.value;
                },
                TraceMetadataWire.SUSPEND_COUNT_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._suspend_count = result.value;
                },
                TraceMetadataWire.DATA_LOSS_COUNT_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._data_loss_count = result.value;
                },
                TraceMetadataWire.ERROR_COUNT_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._error_count = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getTraceDurationNs(self: *const TraceMetadataReader) i64 {
        return self._trace_duration_ns;
    }
    pub inline fn getTraceUuid(self: *const TraceMetadataReader) []const u8 {
        return self._trace_uuid orelse &[_]u8{};
    }
    pub inline fn getAndroidBuildFingerprint(self: *const TraceMetadataReader) []const u8 {
        return self._android_build_fingerprint orelse &[_]u8{};
    }
    pub inline fn getAndroidDeviceManufacturer(self: *const TraceMetadataReader) []const u8 {
        return self._android_device_manufacturer orelse &[_]u8{};
    }
    pub inline fn getAndroidProfileBootClasspath(self: *const TraceMetadataReader) i64 {
        return self._android_profile_boot_classpath;
    }
    pub inline fn getAndroidProfileSystemServer(self: *const TraceMetadataReader) i64 {
        return self._android_profile_system_server;
    }
    pub inline fn getStatsdTriggeringSubscriptionId(self: *const TraceMetadataReader) i64 {
        return self._statsd_triggering_subscription_id;
    }
    pub inline fn getTraceSizeBytes(self: *const TraceMetadataReader) i64 {
        return self._trace_size_bytes;
    }
    pub fn traceTriggerCount(self: *const TraceMetadataReader) usize {
        return self._trace_trigger_cnt;
    }
    pub fn traceTriggerNext(self: *TraceMetadataReader) ?[]const u8 {
        if (self._trace_trigger_offset == null) return null;
        const current_offset = self._trace_trigger_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._trace_trigger_last_offset != null and current_offset >= self._trace_trigger_last_offset.?) {
            self._trace_trigger_offset = null;
            return result.value;
        }
        if (self._trace_trigger_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._trace_trigger_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TraceMetadataWire.TRACE_TRIGGER_WIRE) {
                self._trace_trigger_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._trace_trigger_offset = null;
        return result.value;
    }
    pub inline fn getTraceCausalTrigger(self: *const TraceMetadataReader) []const u8 {
        return self._trace_causal_trigger orelse &[_]u8{};
    }
    pub inline fn getUniqueSessionName(self: *const TraceMetadataReader) []const u8 {
        return self._unique_session_name orelse &[_]u8{};
    }
    pub inline fn getTraceConfigPbtxt(self: *const TraceMetadataReader) []const u8 {
        return self._trace_config_pbtxt orelse &[_]u8{};
    }
    pub inline fn getSchedDurationNs(self: *const TraceMetadataReader) i64 {
        return self._sched_duration_ns;
    }
    pub inline fn getTracingStartedNs(self: *const TraceMetadataReader) i64 {
        return self._tracing_started_ns;
    }
    pub inline fn getAndroidSdkVersion(self: *const TraceMetadataReader) i64 {
        return self._android_sdk_version;
    }
    pub inline fn getSuspendCount(self: *const TraceMetadataReader) i64 {
        return self._suspend_count;
    }
    pub inline fn getDataLossCount(self: *const TraceMetadataReader) i64 {
        return self._data_loss_count;
    }
    pub inline fn getErrorCount(self: *const TraceMetadataReader) i64 {
        return self._error_count;
    }
};
const TraceAnalysisStatsWire = struct {
    const STAT_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const TraceAnalysisStats = struct {
    // nested enums
    pub const Severity = enum(i32) {
        SEVERITY_UNKNOWN = 0,
        SEVERITY_INFO = 1,
        SEVERITY_DATA_LOSS = 2,
        SEVERITY_ERROR = 3,
    };
    pub const Source = enum(i32) {
        SOURCE_UNKNOWN = 0,
        SOURCE_TRACE = 1,
        SOURCE_ANALYSIS = 2,
    };
    // nested structs
    const StatWire = struct {
        const NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const IDX_WIRE: gremlin.ProtoWireNumber = 2;
        const SEVERITY_WIRE: gremlin.ProtoWireNumber = 3;
        const SOURCE_WIRE: gremlin.ProtoWireNumber = 4;
        const COUNT_WIRE: gremlin.ProtoWireNumber = 5;
    };
    pub const Stat = struct {
        // fields
        name: ?[]const u8 = null,
        idx: u32 = 0,
        severity: TraceAnalysisStats.Severity = @enumFromInt(0),
        source: TraceAnalysisStats.Source = @enumFromInt(0),
        count: i64 = 0,
        pub fn calcProtobufSize(self: *const TraceAnalysisStats.Stat) usize {
            var res: usize = 0;
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(TraceAnalysisStats.StatWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.idx != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceAnalysisStats.StatWire.IDX_WIRE) + gremlin.sizes.sizeU32(self.idx);
            }
            if (@intFromEnum(self.severity) != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceAnalysisStats.StatWire.SEVERITY_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.severity));
            }
            if (@intFromEnum(self.source) != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceAnalysisStats.StatWire.SOURCE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.source));
            }
            if (self.count != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceAnalysisStats.StatWire.COUNT_WIRE) + gremlin.sizes.sizeI64(self.count);
            }
            return res;
        }
        pub fn encode(self: *const TraceAnalysisStats.Stat, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const TraceAnalysisStats.Stat, target: *gremlin.Writer) void {
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(TraceAnalysisStats.StatWire.NAME_WIRE, v);
                }
            }
            if (self.idx != 0) {
                target.appendUint32(TraceAnalysisStats.StatWire.IDX_WIRE, self.idx);
            }
            if (@intFromEnum(self.severity) != 0) {
                target.appendInt32(TraceAnalysisStats.StatWire.SEVERITY_WIRE, @intFromEnum(self.severity));
            }
            if (@intFromEnum(self.source) != 0) {
                target.appendInt32(TraceAnalysisStats.StatWire.SOURCE_WIRE, @intFromEnum(self.source));
            }
            if (self.count != 0) {
                target.appendInt64(TraceAnalysisStats.StatWire.COUNT_WIRE, self.count);
            }
        }
    };
    pub const StatReader = struct {
        buf: gremlin.Reader,
        _name: ?[]const u8 = null,
        _idx: u32 = 0,
        _severity: TraceAnalysisStats.Severity = @enumFromInt(0),
        _source: TraceAnalysisStats.Source = @enumFromInt(0),
        _count: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!TraceAnalysisStats.StatReader {
            const buf = gremlin.Reader.init(src);
            var res = TraceAnalysisStats.StatReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    TraceAnalysisStats.StatWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    TraceAnalysisStats.StatWire.IDX_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._idx = result.value;
                    },
                    TraceAnalysisStats.StatWire.SEVERITY_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._severity = @enumFromInt(result.value);
                    },
                    TraceAnalysisStats.StatWire.SOURCE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._source = @enumFromInt(result.value);
                    },
                    TraceAnalysisStats.StatWire.COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._count = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getName(self: *const TraceAnalysisStats.StatReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub inline fn getIdx(self: *const TraceAnalysisStats.StatReader) u32 {
            return self._idx;
        }
        pub inline fn getSeverity(self: *const TraceAnalysisStats.StatReader) TraceAnalysisStats.Severity {
            return self._severity;
        }
        pub inline fn getSource(self: *const TraceAnalysisStats.StatReader) TraceAnalysisStats.Source {
            return self._source;
        }
        pub inline fn getCount(self: *const TraceAnalysisStats.StatReader) i64 {
            return self._count;
        }
    };
    // fields
    stat: ?[]const ?TraceAnalysisStats.Stat = null,
    pub fn calcProtobufSize(self: *const TraceAnalysisStats) usize {
        var res: usize = 0;
        if (self.stat) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TraceAnalysisStatsWire.STAT_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const TraceAnalysisStats, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TraceAnalysisStats, target: *gremlin.Writer) void {
        if (self.stat) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(TraceAnalysisStatsWire.STAT_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(TraceAnalysisStatsWire.STAT_WIRE, 0);
                }
            }
        }
    }
};
pub const TraceAnalysisStatsReader = struct {
    buf: gremlin.Reader,
    _stat_offset: ?usize = null,
    _stat_last_offset: ?usize = null,
    _stat_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!TraceAnalysisStatsReader {
        const buf = gremlin.Reader.init(src);
        var res = TraceAnalysisStatsReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TraceAnalysisStatsWire.STAT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._stat_offset == null) {
                        res._stat_offset = offset - result.size;
                    }
                    res._stat_last_offset = offset;
                    res._stat_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn statCount(self: *const TraceAnalysisStatsReader) usize {
        return self._stat_cnt;
    }
    pub fn statNext(self: *TraceAnalysisStatsReader) ?TraceAnalysisStats.StatReader {
        if (self._stat_offset == null) return null;
        const current_offset = self._stat_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = TraceAnalysisStats.StatReader.init(result.value) catch return null;
        if (self._stat_last_offset != null and current_offset >= self._stat_last_offset.?) {
            self._stat_offset = null;
            return msg;
        }
        if (self._stat_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._stat_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TraceAnalysisStatsWire.STAT_WIRE) {
                self._stat_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._stat_offset = null;
        return msg;
    }
};
const TraceMetricsWire = struct {
    const ANDROID_BATT_WIRE: gremlin.ProtoWireNumber = 5;
    const ANDROID_CPU_WIRE: gremlin.ProtoWireNumber = 6;
    const ANDROID_MEM_WIRE: gremlin.ProtoWireNumber = 1;
    const ANDROID_MEM_UNAGG_WIRE: gremlin.ProtoWireNumber = 11;
    const ANDROID_PACKAGE_LIST_WIRE: gremlin.ProtoWireNumber = 12;
    const ANDROID_ION_WIRE: gremlin.ProtoWireNumber = 9;
    const ANDROID_FASTRPC_WIRE: gremlin.ProtoWireNumber = 31;
    const ANDROID_LMK_WIRE: gremlin.ProtoWireNumber = 8;
    const ANDROID_POWRAILS_WIRE: gremlin.ProtoWireNumber = 7;
    const ANDROID_STARTUP_WIRE: gremlin.ProtoWireNumber = 2;
    const TRACE_METADATA_WIRE: gremlin.ProtoWireNumber = 3;
    const TRACE_STATS_WIRE: gremlin.ProtoWireNumber = 33;
    const UNSYMBOLIZED_FRAMES_WIRE: gremlin.ProtoWireNumber = 15;
    const JAVA_HEAP_STATS_WIRE: gremlin.ProtoWireNumber = 17;
    const JAVA_HEAP_HISTOGRAM_WIRE: gremlin.ProtoWireNumber = 21;
    const JAVA_HEAP_CLASS_STATS_WIRE: gremlin.ProtoWireNumber = 67;
    const ANDROID_LMK_REASON_WIRE: gremlin.ProtoWireNumber = 18;
    const ANDROID_HWUI_METRIC_WIRE: gremlin.ProtoWireNumber = 20;
    const DISPLAY_METRICS_WIRE: gremlin.ProtoWireNumber = 22;
    const ANDROID_TASK_NAMES_WIRE: gremlin.ProtoWireNumber = 23;
    const ANDROID_SURFACEFLINGER_WIRE: gremlin.ProtoWireNumber = 25;
    const ANDROID_GPU_WIRE: gremlin.ProtoWireNumber = 26;
    const ANDROID_JANK_CUJ_WIRE: gremlin.ProtoWireNumber = 48;
    const ANDROID_HWCOMPOSER_WIRE: gremlin.ProtoWireNumber = 28;
    const G2D_WIRE: gremlin.ProtoWireNumber = 30;
    const ANDROID_DMA_HEAP_WIRE: gremlin.ProtoWireNumber = 32;
    const ANDROID_TRACE_QUALITY_WIRE: gremlin.ProtoWireNumber = 34;
    const PROFILER_SMAPS_WIRE: gremlin.ProtoWireNumber = 35;
    const ANDROID_MULTIUSER_WIRE: gremlin.ProtoWireNumber = 36;
    const ANDROID_SIMPLEPERF_WIRE: gremlin.ProtoWireNumber = 37;
    const ANDROID_CAMERA_WIRE: gremlin.ProtoWireNumber = 38;
    const ANDROID_DVFS_WIRE: gremlin.ProtoWireNumber = 39;
    const ANDROID_NETPERF_WIRE: gremlin.ProtoWireNumber = 40;
    const ANDROID_CAMERA_UNAGG_WIRE: gremlin.ProtoWireNumber = 41;
    const ANDROID_RT_RUNTIME_WIRE: gremlin.ProtoWireNumber = 42;
    const ANDROID_IRQ_RUNTIME_WIRE: gremlin.ProtoWireNumber = 43;
    const ANDROID_BINDER_WIRE: gremlin.ProtoWireNumber = 46;
    const ANDROID_FRAME_TIMELINE_METRIC_WIRE: gremlin.ProtoWireNumber = 47;
    const ANDROID_BLOCKING_CALLS_CUJ_METRIC_WIRE: gremlin.ProtoWireNumber = 49;
    const ANDROID_MONITOR_CONTENTION_WIRE: gremlin.ProtoWireNumber = 50;
    const ANDROID_SYSUI_NOTIFICATIONS_BLOCKING_CALLS_METRIC_WIRE: gremlin.ProtoWireNumber = 51;
    const CODEC_METRICS_WIRE: gremlin.ProtoWireNumber = 52;
    const ANDROID_IO_WIRE: gremlin.ProtoWireNumber = 53;
    const ANDROID_IO_UNAGG_WIRE: gremlin.ProtoWireNumber = 54;
    const ANDROID_ANR_WIRE: gremlin.ProtoWireNumber = 55;
    const ANDROID_MONITOR_CONTENTION_AGG_WIRE: gremlin.ProtoWireNumber = 56;
    const ANDROID_BOOT_WIRE: gremlin.ProtoWireNumber = 57;
    const AD_SERVICES_METRIC_WIRE: gremlin.ProtoWireNumber = 58;
    const SYSUI_NOTIF_SHADE_LIST_BUILDER_METRIC_WIRE: gremlin.ProtoWireNumber = 59;
    const SYSUI_UPDATE_NOTIF_ON_UI_MODE_CHANGED_METRIC_WIRE: gremlin.ProtoWireNumber = 60;
    const ANDROID_APP_PROCESS_STARTS_WIRE: gremlin.ProtoWireNumber = 61;
    const ANDROID_BOOT_UNAGG_WIRE: gremlin.ProtoWireNumber = 62;
    const ANDROID_GARBAGE_COLLECTION_UNAGG_WIRE: gremlin.ProtoWireNumber = 63;
    const ANDROID_AUTO_MULTIUSER_WIRE: gremlin.ProtoWireNumber = 64;
    const ANDROID_BLOCKING_CALLS_UNAGG_WIRE: gremlin.ProtoWireNumber = 65;
    const ANDROID_OOM_ADJUSTER_WIRE: gremlin.ProtoWireNumber = 66;
    const ANDROID_BROADCASTS_WIRE: gremlin.ProtoWireNumber = 68;
    const WATTSON_APP_STARTUP_RAILS_WIRE: gremlin.ProtoWireNumber = 69;
    const WATTSON_TRACE_RAILS_WIRE: gremlin.ProtoWireNumber = 70;
    const ANDROID_ANOMALY_WIRE: gremlin.ProtoWireNumber = 71;
    const WATTSON_TRACE_THREADS_WIRE: gremlin.ProtoWireNumber = 72;
    const WATTSON_MARKERS_THREADS_WIRE: gremlin.ProtoWireNumber = 73;
    const WATTSON_MARKERS_RAILS_WIRE: gremlin.ProtoWireNumber = 74;
    const WATTSON_ATRACE_APPS_RAILS_WIRE: gremlin.ProtoWireNumber = 75;
    const ANDROID_GARBAGE_COLLECTION_STATS_WIRE: gremlin.ProtoWireNumber = 76;
    const CLONE_DURATION_WIRE: gremlin.ProtoWireNumber = 77;
    const ANDROID_BLOCKING_CALLS_CUJ_PER_FRAME_METRIC_WIRE: gremlin.ProtoWireNumber = 78;
    const WATTSON_APP_STARTUP_THREADS_WIRE: gremlin.ProtoWireNumber = 79;
    const WATTSON_ATRACE_APPS_THREADS_WIRE: gremlin.ProtoWireNumber = 80;
};
pub const TraceMetrics = struct {
    // fields
    android_batt: ?AndroidBatteryMetric = null,
    android_cpu: ?AndroidCpuMetric = null,
    android_mem: ?AndroidMemoryMetric = null,
    android_mem_unagg: ?AndroidMemoryUnaggregatedMetric = null,
    android_package_list: ?AndroidPackageList = null,
    android_ion: ?AndroidIonMetric = null,
    android_fastrpc: ?AndroidFastrpcMetric = null,
    android_lmk: ?AndroidLmkMetric = null,
    android_powrails: ?AndroidPowerRails = null,
    android_startup: ?AndroidStartupMetric = null,
    trace_metadata: ?TraceMetadata = null,
    trace_stats: ?TraceAnalysisStats = null,
    unsymbolized_frames: ?UnsymbolizedFrames = null,
    java_heap_stats: ?JavaHeapStats = null,
    java_heap_histogram: ?JavaHeapHistogram = null,
    java_heap_class_stats: ?JavaHeapClassStats = null,
    android_lmk_reason: ?AndroidLmkReasonMetric = null,
    android_hwui_metric: ?AndroidHwuiMetric = null,
    display_metrics: ?AndroidDisplayMetrics = null,
    android_task_names: ?AndroidTaskNames = null,
    android_surfaceflinger: ?AndroidSurfaceflingerMetric = null,
    android_gpu: ?AndroidGpuMetric = null,
    android_jank_cuj: ?AndroidJankCujMetric = null,
    android_hwcomposer: ?AndroidHwcomposerMetrics = null,
    g2d: ?G2dMetrics = null,
    android_dma_heap: ?AndroidDmaHeapMetric = null,
    android_trace_quality: ?AndroidTraceQualityMetric = null,
    profiler_smaps: ?ProfilerSmaps = null,
    android_multiuser: ?AndroidMultiuserMetric = null,
    android_simpleperf: ?AndroidSimpleperfMetric = null,
    android_camera: ?AndroidCameraMetric = null,
    android_dvfs: ?AndroidDvfsMetric = null,
    android_netperf: ?AndroidNetworkMetric = null,
    android_camera_unagg: ?AndroidCameraUnaggregatedMetric = null,
    android_rt_runtime: ?AndroidRtRuntimeMetric = null,
    android_irq_runtime: ?AndroidIrqRuntimeMetric = null,
    android_binder: ?AndroidBinderMetric = null,
    android_frame_timeline_metric: ?AndroidFrameTimelineMetric = null,
    android_blocking_calls_cuj_metric: ?AndroidBlockingCallsCujMetric = null,
    android_monitor_contention: ?AndroidMonitorContentionMetric = null,
    android_sysui_notifications_blocking_calls_metric: ?AndroidSysUINotificationsBlockingCallsMetric = null,
    codec_metrics: ?AndroidCodecMetrics = null,
    android_io: ?AndroidIo = null,
    android_io_unagg: ?AndroidIoUnaggregated = null,
    android_anr: ?AndroidAnrMetric = null,
    android_monitor_contention_agg: ?AndroidMonitorContentionAggMetric = null,
    android_boot: ?AndroidBootMetric = null,
    ad_services_metric: ?AdServicesMetric = null,
    sysui_notif_shade_list_builder_metric: ?SysuiNotifShadeListBuilderMetric = null,
    sysui_update_notif_on_ui_mode_changed_metric: ?SysuiUpdateNotifOnUiModeChangedMetric = null,
    android_app_process_starts: ?AndroidAppProcessStartsMetric = null,
    android_boot_unagg: ?AndroidBootUnagg = null,
    android_garbage_collection_unagg: ?AndroidGarbageCollectionUnaggMetric = null,
    android_auto_multiuser: ?AndroidAutoMultiuserMetric = null,
    android_blocking_calls_unagg: ?AndroidBlockingCallsUnagg = null,
    android_oom_adjuster: ?AndroidOomAdjusterMetric = null,
    android_broadcasts: ?AndroidBroadcastsMetric = null,
    wattson_app_startup_rails: ?AndroidWattsonTimePeriodMetric = null,
    wattson_trace_rails: ?AndroidWattsonTimePeriodMetric = null,
    android_anomaly: ?AndroidAnomalyMetric = null,
    wattson_trace_threads: ?AndroidWattsonTasksAttributionMetric = null,
    wattson_markers_threads: ?AndroidWattsonTasksAttributionMetric = null,
    wattson_markers_rails: ?AndroidWattsonTimePeriodMetric = null,
    wattson_atrace_apps_rails: ?AndroidWattsonTimePeriodMetric = null,
    android_garbage_collection_stats: ?AndroidGarbageCollectionStats = null,
    clone_duration: ?CloneDuration = null,
    android_blocking_calls_cuj_per_frame_metric: ?AndroidCujBlockingCallsPerFrameMetric = null,
    wattson_app_startup_threads: ?AndroidWattsonTasksAttributionMetric = null,
    wattson_atrace_apps_threads: ?AndroidWattsonTasksAttributionMetric = null,
    pub fn calcProtobufSize(self: *const TraceMetrics) usize {
        var res: usize = 0;
        if (self.android_batt) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_BATT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_cpu) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_CPU_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_mem) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_MEM_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_mem_unagg) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_MEM_UNAGG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_package_list) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_PACKAGE_LIST_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_ion) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_ION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_fastrpc) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_FASTRPC_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_lmk) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_LMK_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_powrails) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_POWRAILS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_startup) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_STARTUP_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.trace_metadata) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.TRACE_METADATA_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.trace_stats) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.TRACE_STATS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.unsymbolized_frames) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.UNSYMBOLIZED_FRAMES_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.java_heap_stats) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.JAVA_HEAP_STATS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.java_heap_histogram) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.JAVA_HEAP_HISTOGRAM_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.java_heap_class_stats) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.JAVA_HEAP_CLASS_STATS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_lmk_reason) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_LMK_REASON_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_hwui_metric) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_HWUI_METRIC_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.display_metrics) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.DISPLAY_METRICS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_task_names) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_TASK_NAMES_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_surfaceflinger) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_SURFACEFLINGER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_gpu) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_GPU_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_jank_cuj) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_JANK_CUJ_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_hwcomposer) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_HWCOMPOSER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.g2d) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.G2D_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_dma_heap) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_DMA_HEAP_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_trace_quality) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_TRACE_QUALITY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.profiler_smaps) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.PROFILER_SMAPS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_multiuser) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_MULTIUSER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_simpleperf) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_SIMPLEPERF_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_camera) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_CAMERA_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_dvfs) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_DVFS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_netperf) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_NETPERF_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_camera_unagg) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_CAMERA_UNAGG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_rt_runtime) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_RT_RUNTIME_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_irq_runtime) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_IRQ_RUNTIME_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_binder) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_BINDER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_frame_timeline_metric) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_FRAME_TIMELINE_METRIC_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_blocking_calls_cuj_metric) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_BLOCKING_CALLS_CUJ_METRIC_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_monitor_contention) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_MONITOR_CONTENTION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_sysui_notifications_blocking_calls_metric) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_SYSUI_NOTIFICATIONS_BLOCKING_CALLS_METRIC_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.codec_metrics) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.CODEC_METRICS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_io) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_IO_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_io_unagg) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_IO_UNAGG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_anr) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_ANR_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_monitor_contention_agg) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_MONITOR_CONTENTION_AGG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_boot) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_BOOT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ad_services_metric) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.AD_SERVICES_METRIC_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.sysui_notif_shade_list_builder_metric) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.SYSUI_NOTIF_SHADE_LIST_BUILDER_METRIC_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.sysui_update_notif_on_ui_mode_changed_metric) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.SYSUI_UPDATE_NOTIF_ON_UI_MODE_CHANGED_METRIC_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_app_process_starts) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_APP_PROCESS_STARTS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_boot_unagg) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_BOOT_UNAGG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_garbage_collection_unagg) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_GARBAGE_COLLECTION_UNAGG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_auto_multiuser) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_AUTO_MULTIUSER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_blocking_calls_unagg) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_BLOCKING_CALLS_UNAGG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_oom_adjuster) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_OOM_ADJUSTER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_broadcasts) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_BROADCASTS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.wattson_app_startup_rails) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.WATTSON_APP_STARTUP_RAILS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.wattson_trace_rails) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.WATTSON_TRACE_RAILS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_anomaly) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_ANOMALY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.wattson_trace_threads) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.WATTSON_TRACE_THREADS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.wattson_markers_threads) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.WATTSON_MARKERS_THREADS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.wattson_markers_rails) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.WATTSON_MARKERS_RAILS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.wattson_atrace_apps_rails) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.WATTSON_ATRACE_APPS_RAILS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_garbage_collection_stats) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_GARBAGE_COLLECTION_STATS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.clone_duration) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.CLONE_DURATION_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_blocking_calls_cuj_per_frame_metric) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.ANDROID_BLOCKING_CALLS_CUJ_PER_FRAME_METRIC_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.wattson_app_startup_threads) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.WATTSON_APP_STARTUP_THREADS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.wattson_atrace_apps_threads) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricsWire.WATTSON_ATRACE_APPS_THREADS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const TraceMetrics, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TraceMetrics, target: *gremlin.Writer) void {
        if (self.android_batt) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_BATT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_cpu) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_CPU_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_mem) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_MEM_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_mem_unagg) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_MEM_UNAGG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_package_list) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_PACKAGE_LIST_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_ion) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_ION_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_fastrpc) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_FASTRPC_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_lmk) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_LMK_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_powrails) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_POWRAILS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_startup) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_STARTUP_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.trace_metadata) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.TRACE_METADATA_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.trace_stats) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.TRACE_STATS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.unsymbolized_frames) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.UNSYMBOLIZED_FRAMES_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.java_heap_stats) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.JAVA_HEAP_STATS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.java_heap_histogram) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.JAVA_HEAP_HISTOGRAM_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.java_heap_class_stats) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.JAVA_HEAP_CLASS_STATS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_lmk_reason) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_LMK_REASON_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_hwui_metric) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_HWUI_METRIC_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.display_metrics) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.DISPLAY_METRICS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_task_names) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_TASK_NAMES_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_surfaceflinger) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_SURFACEFLINGER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_gpu) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_GPU_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_jank_cuj) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_JANK_CUJ_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_hwcomposer) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_HWCOMPOSER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.g2d) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.G2D_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_dma_heap) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_DMA_HEAP_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_trace_quality) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_TRACE_QUALITY_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.profiler_smaps) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.PROFILER_SMAPS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_multiuser) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_MULTIUSER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_simpleperf) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_SIMPLEPERF_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_camera) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_CAMERA_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_dvfs) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_DVFS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_netperf) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_NETPERF_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_camera_unagg) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_CAMERA_UNAGG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_rt_runtime) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_RT_RUNTIME_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_irq_runtime) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_IRQ_RUNTIME_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_binder) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_BINDER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_frame_timeline_metric) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_FRAME_TIMELINE_METRIC_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_blocking_calls_cuj_metric) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_BLOCKING_CALLS_CUJ_METRIC_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_monitor_contention) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_MONITOR_CONTENTION_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_sysui_notifications_blocking_calls_metric) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_SYSUI_NOTIFICATIONS_BLOCKING_CALLS_METRIC_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.codec_metrics) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.CODEC_METRICS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_io) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_IO_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_io_unagg) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_IO_UNAGG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_anr) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_ANR_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_monitor_contention_agg) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_MONITOR_CONTENTION_AGG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_boot) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_BOOT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ad_services_metric) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.AD_SERVICES_METRIC_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.sysui_notif_shade_list_builder_metric) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.SYSUI_NOTIF_SHADE_LIST_BUILDER_METRIC_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.sysui_update_notif_on_ui_mode_changed_metric) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.SYSUI_UPDATE_NOTIF_ON_UI_MODE_CHANGED_METRIC_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_app_process_starts) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_APP_PROCESS_STARTS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_boot_unagg) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_BOOT_UNAGG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_garbage_collection_unagg) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_GARBAGE_COLLECTION_UNAGG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_auto_multiuser) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_AUTO_MULTIUSER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_blocking_calls_unagg) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_BLOCKING_CALLS_UNAGG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_oom_adjuster) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_OOM_ADJUSTER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_broadcasts) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_BROADCASTS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.wattson_app_startup_rails) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.WATTSON_APP_STARTUP_RAILS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.wattson_trace_rails) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.WATTSON_TRACE_RAILS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_anomaly) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_ANOMALY_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.wattson_trace_threads) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.WATTSON_TRACE_THREADS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.wattson_markers_threads) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.WATTSON_MARKERS_THREADS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.wattson_markers_rails) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.WATTSON_MARKERS_RAILS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.wattson_atrace_apps_rails) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.WATTSON_ATRACE_APPS_RAILS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_garbage_collection_stats) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_GARBAGE_COLLECTION_STATS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.clone_duration) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.CLONE_DURATION_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_blocking_calls_cuj_per_frame_metric) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.ANDROID_BLOCKING_CALLS_CUJ_PER_FRAME_METRIC_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.wattson_app_startup_threads) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.WATTSON_APP_STARTUP_THREADS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.wattson_atrace_apps_threads) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricsWire.WATTSON_ATRACE_APPS_THREADS_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const TraceMetricsReader = struct {
    buf: gremlin.Reader,
    _android_batt_buf: ?[]const u8 = null,
    _android_cpu_buf: ?[]const u8 = null,
    _android_mem_buf: ?[]const u8 = null,
    _android_mem_unagg_buf: ?[]const u8 = null,
    _android_package_list_buf: ?[]const u8 = null,
    _android_ion_buf: ?[]const u8 = null,
    _android_fastrpc_buf: ?[]const u8 = null,
    _android_lmk_buf: ?[]const u8 = null,
    _android_powrails_buf: ?[]const u8 = null,
    _android_startup_buf: ?[]const u8 = null,
    _trace_metadata_buf: ?[]const u8 = null,
    _trace_stats_buf: ?[]const u8 = null,
    _unsymbolized_frames_buf: ?[]const u8 = null,
    _java_heap_stats_buf: ?[]const u8 = null,
    _java_heap_histogram_buf: ?[]const u8 = null,
    _java_heap_class_stats_buf: ?[]const u8 = null,
    _android_lmk_reason_buf: ?[]const u8 = null,
    _android_hwui_metric_buf: ?[]const u8 = null,
    _display_metrics_buf: ?[]const u8 = null,
    _android_task_names_buf: ?[]const u8 = null,
    _android_surfaceflinger_buf: ?[]const u8 = null,
    _android_gpu_buf: ?[]const u8 = null,
    _android_jank_cuj_buf: ?[]const u8 = null,
    _android_hwcomposer_buf: ?[]const u8 = null,
    _g2d_buf: ?[]const u8 = null,
    _android_dma_heap_buf: ?[]const u8 = null,
    _android_trace_quality_buf: ?[]const u8 = null,
    _profiler_smaps_buf: ?[]const u8 = null,
    _android_multiuser_buf: ?[]const u8 = null,
    _android_simpleperf_buf: ?[]const u8 = null,
    _android_camera_buf: ?[]const u8 = null,
    _android_dvfs_buf: ?[]const u8 = null,
    _android_netperf_buf: ?[]const u8 = null,
    _android_camera_unagg_buf: ?[]const u8 = null,
    _android_rt_runtime_buf: ?[]const u8 = null,
    _android_irq_runtime_buf: ?[]const u8 = null,
    _android_binder_buf: ?[]const u8 = null,
    _android_frame_timeline_metric_buf: ?[]const u8 = null,
    _android_blocking_calls_cuj_metric_buf: ?[]const u8 = null,
    _android_monitor_contention_buf: ?[]const u8 = null,
    _android_sysui_notifications_blocking_calls_metric_buf: ?[]const u8 = null,
    _codec_metrics_buf: ?[]const u8 = null,
    _android_io_buf: ?[]const u8 = null,
    _android_io_unagg_buf: ?[]const u8 = null,
    _android_anr_buf: ?[]const u8 = null,
    _android_monitor_contention_agg_buf: ?[]const u8 = null,
    _android_boot_buf: ?[]const u8 = null,
    _ad_services_metric_buf: ?[]const u8 = null,
    _sysui_notif_shade_list_builder_metric_buf: ?[]const u8 = null,
    _sysui_update_notif_on_ui_mode_changed_metric_buf: ?[]const u8 = null,
    _android_app_process_starts_buf: ?[]const u8 = null,
    _android_boot_unagg_buf: ?[]const u8 = null,
    _android_garbage_collection_unagg_buf: ?[]const u8 = null,
    _android_auto_multiuser_buf: ?[]const u8 = null,
    _android_blocking_calls_unagg_buf: ?[]const u8 = null,
    _android_oom_adjuster_buf: ?[]const u8 = null,
    _android_broadcasts_buf: ?[]const u8 = null,
    _wattson_app_startup_rails_buf: ?[]const u8 = null,
    _wattson_trace_rails_buf: ?[]const u8 = null,
    _android_anomaly_buf: ?[]const u8 = null,
    _wattson_trace_threads_buf: ?[]const u8 = null,
    _wattson_markers_threads_buf: ?[]const u8 = null,
    _wattson_markers_rails_buf: ?[]const u8 = null,
    _wattson_atrace_apps_rails_buf: ?[]const u8 = null,
    _android_garbage_collection_stats_buf: ?[]const u8 = null,
    _clone_duration_buf: ?[]const u8 = null,
    _android_blocking_calls_cuj_per_frame_metric_buf: ?[]const u8 = null,
    _wattson_app_startup_threads_buf: ?[]const u8 = null,
    _wattson_atrace_apps_threads_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!TraceMetricsReader {
        const buf = gremlin.Reader.init(src);
        var res = TraceMetricsReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TraceMetricsWire.ANDROID_BATT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_batt_buf = result.value;
                },
                TraceMetricsWire.ANDROID_CPU_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_cpu_buf = result.value;
                },
                TraceMetricsWire.ANDROID_MEM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_mem_buf = result.value;
                },
                TraceMetricsWire.ANDROID_MEM_UNAGG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_mem_unagg_buf = result.value;
                },
                TraceMetricsWire.ANDROID_PACKAGE_LIST_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_package_list_buf = result.value;
                },
                TraceMetricsWire.ANDROID_ION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_ion_buf = result.value;
                },
                TraceMetricsWire.ANDROID_FASTRPC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_fastrpc_buf = result.value;
                },
                TraceMetricsWire.ANDROID_LMK_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_lmk_buf = result.value;
                },
                TraceMetricsWire.ANDROID_POWRAILS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_powrails_buf = result.value;
                },
                TraceMetricsWire.ANDROID_STARTUP_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_startup_buf = result.value;
                },
                TraceMetricsWire.TRACE_METADATA_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._trace_metadata_buf = result.value;
                },
                TraceMetricsWire.TRACE_STATS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._trace_stats_buf = result.value;
                },
                TraceMetricsWire.UNSYMBOLIZED_FRAMES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._unsymbolized_frames_buf = result.value;
                },
                TraceMetricsWire.JAVA_HEAP_STATS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._java_heap_stats_buf = result.value;
                },
                TraceMetricsWire.JAVA_HEAP_HISTOGRAM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._java_heap_histogram_buf = result.value;
                },
                TraceMetricsWire.JAVA_HEAP_CLASS_STATS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._java_heap_class_stats_buf = result.value;
                },
                TraceMetricsWire.ANDROID_LMK_REASON_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_lmk_reason_buf = result.value;
                },
                TraceMetricsWire.ANDROID_HWUI_METRIC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_hwui_metric_buf = result.value;
                },
                TraceMetricsWire.DISPLAY_METRICS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._display_metrics_buf = result.value;
                },
                TraceMetricsWire.ANDROID_TASK_NAMES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_task_names_buf = result.value;
                },
                TraceMetricsWire.ANDROID_SURFACEFLINGER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_surfaceflinger_buf = result.value;
                },
                TraceMetricsWire.ANDROID_GPU_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_gpu_buf = result.value;
                },
                TraceMetricsWire.ANDROID_JANK_CUJ_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_jank_cuj_buf = result.value;
                },
                TraceMetricsWire.ANDROID_HWCOMPOSER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_hwcomposer_buf = result.value;
                },
                TraceMetricsWire.G2D_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._g2d_buf = result.value;
                },
                TraceMetricsWire.ANDROID_DMA_HEAP_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_dma_heap_buf = result.value;
                },
                TraceMetricsWire.ANDROID_TRACE_QUALITY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_trace_quality_buf = result.value;
                },
                TraceMetricsWire.PROFILER_SMAPS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._profiler_smaps_buf = result.value;
                },
                TraceMetricsWire.ANDROID_MULTIUSER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_multiuser_buf = result.value;
                },
                TraceMetricsWire.ANDROID_SIMPLEPERF_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_simpleperf_buf = result.value;
                },
                TraceMetricsWire.ANDROID_CAMERA_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_camera_buf = result.value;
                },
                TraceMetricsWire.ANDROID_DVFS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_dvfs_buf = result.value;
                },
                TraceMetricsWire.ANDROID_NETPERF_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_netperf_buf = result.value;
                },
                TraceMetricsWire.ANDROID_CAMERA_UNAGG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_camera_unagg_buf = result.value;
                },
                TraceMetricsWire.ANDROID_RT_RUNTIME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_rt_runtime_buf = result.value;
                },
                TraceMetricsWire.ANDROID_IRQ_RUNTIME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_irq_runtime_buf = result.value;
                },
                TraceMetricsWire.ANDROID_BINDER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_binder_buf = result.value;
                },
                TraceMetricsWire.ANDROID_FRAME_TIMELINE_METRIC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_frame_timeline_metric_buf = result.value;
                },
                TraceMetricsWire.ANDROID_BLOCKING_CALLS_CUJ_METRIC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_blocking_calls_cuj_metric_buf = result.value;
                },
                TraceMetricsWire.ANDROID_MONITOR_CONTENTION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_monitor_contention_buf = result.value;
                },
                TraceMetricsWire.ANDROID_SYSUI_NOTIFICATIONS_BLOCKING_CALLS_METRIC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_sysui_notifications_blocking_calls_metric_buf = result.value;
                },
                TraceMetricsWire.CODEC_METRICS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._codec_metrics_buf = result.value;
                },
                TraceMetricsWire.ANDROID_IO_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_io_buf = result.value;
                },
                TraceMetricsWire.ANDROID_IO_UNAGG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_io_unagg_buf = result.value;
                },
                TraceMetricsWire.ANDROID_ANR_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_anr_buf = result.value;
                },
                TraceMetricsWire.ANDROID_MONITOR_CONTENTION_AGG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_monitor_contention_agg_buf = result.value;
                },
                TraceMetricsWire.ANDROID_BOOT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_boot_buf = result.value;
                },
                TraceMetricsWire.AD_SERVICES_METRIC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ad_services_metric_buf = result.value;
                },
                TraceMetricsWire.SYSUI_NOTIF_SHADE_LIST_BUILDER_METRIC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._sysui_notif_shade_list_builder_metric_buf = result.value;
                },
                TraceMetricsWire.SYSUI_UPDATE_NOTIF_ON_UI_MODE_CHANGED_METRIC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._sysui_update_notif_on_ui_mode_changed_metric_buf = result.value;
                },
                TraceMetricsWire.ANDROID_APP_PROCESS_STARTS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_app_process_starts_buf = result.value;
                },
                TraceMetricsWire.ANDROID_BOOT_UNAGG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_boot_unagg_buf = result.value;
                },
                TraceMetricsWire.ANDROID_GARBAGE_COLLECTION_UNAGG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_garbage_collection_unagg_buf = result.value;
                },
                TraceMetricsWire.ANDROID_AUTO_MULTIUSER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_auto_multiuser_buf = result.value;
                },
                TraceMetricsWire.ANDROID_BLOCKING_CALLS_UNAGG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_blocking_calls_unagg_buf = result.value;
                },
                TraceMetricsWire.ANDROID_OOM_ADJUSTER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_oom_adjuster_buf = result.value;
                },
                TraceMetricsWire.ANDROID_BROADCASTS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_broadcasts_buf = result.value;
                },
                TraceMetricsWire.WATTSON_APP_STARTUP_RAILS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._wattson_app_startup_rails_buf = result.value;
                },
                TraceMetricsWire.WATTSON_TRACE_RAILS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._wattson_trace_rails_buf = result.value;
                },
                TraceMetricsWire.ANDROID_ANOMALY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_anomaly_buf = result.value;
                },
                TraceMetricsWire.WATTSON_TRACE_THREADS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._wattson_trace_threads_buf = result.value;
                },
                TraceMetricsWire.WATTSON_MARKERS_THREADS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._wattson_markers_threads_buf = result.value;
                },
                TraceMetricsWire.WATTSON_MARKERS_RAILS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._wattson_markers_rails_buf = result.value;
                },
                TraceMetricsWire.WATTSON_ATRACE_APPS_RAILS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._wattson_atrace_apps_rails_buf = result.value;
                },
                TraceMetricsWire.ANDROID_GARBAGE_COLLECTION_STATS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_garbage_collection_stats_buf = result.value;
                },
                TraceMetricsWire.CLONE_DURATION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._clone_duration_buf = result.value;
                },
                TraceMetricsWire.ANDROID_BLOCKING_CALLS_CUJ_PER_FRAME_METRIC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_blocking_calls_cuj_per_frame_metric_buf = result.value;
                },
                TraceMetricsWire.WATTSON_APP_STARTUP_THREADS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._wattson_app_startup_threads_buf = result.value;
                },
                TraceMetricsWire.WATTSON_ATRACE_APPS_THREADS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._wattson_atrace_apps_threads_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getAndroidBatt(self: *const TraceMetricsReader) gremlin.Error!AndroidBatteryMetricReader {
        if (self._android_batt_buf) |buf| {
            return try AndroidBatteryMetricReader.init(buf);
        }
        return try AndroidBatteryMetricReader.init(&[_]u8{});
    }
    pub fn getAndroidCpu(self: *const TraceMetricsReader) gremlin.Error!AndroidCpuMetricReader {
        if (self._android_cpu_buf) |buf| {
            return try AndroidCpuMetricReader.init(buf);
        }
        return try AndroidCpuMetricReader.init(&[_]u8{});
    }
    pub fn getAndroidMem(self: *const TraceMetricsReader) gremlin.Error!AndroidMemoryMetricReader {
        if (self._android_mem_buf) |buf| {
            return try AndroidMemoryMetricReader.init(buf);
        }
        return try AndroidMemoryMetricReader.init(&[_]u8{});
    }
    pub fn getAndroidMemUnagg(self: *const TraceMetricsReader) gremlin.Error!AndroidMemoryUnaggregatedMetricReader {
        if (self._android_mem_unagg_buf) |buf| {
            return try AndroidMemoryUnaggregatedMetricReader.init(buf);
        }
        return try AndroidMemoryUnaggregatedMetricReader.init(&[_]u8{});
    }
    pub fn getAndroidPackageList(self: *const TraceMetricsReader) gremlin.Error!AndroidPackageListReader {
        if (self._android_package_list_buf) |buf| {
            return try AndroidPackageListReader.init(buf);
        }
        return try AndroidPackageListReader.init(&[_]u8{});
    }
    pub fn getAndroidIon(self: *const TraceMetricsReader) gremlin.Error!AndroidIonMetricReader {
        if (self._android_ion_buf) |buf| {
            return try AndroidIonMetricReader.init(buf);
        }
        return try AndroidIonMetricReader.init(&[_]u8{});
    }
    pub fn getAndroidFastrpc(self: *const TraceMetricsReader) gremlin.Error!AndroidFastrpcMetricReader {
        if (self._android_fastrpc_buf) |buf| {
            return try AndroidFastrpcMetricReader.init(buf);
        }
        return try AndroidFastrpcMetricReader.init(&[_]u8{});
    }
    pub fn getAndroidLmk(self: *const TraceMetricsReader) gremlin.Error!AndroidLmkMetricReader {
        if (self._android_lmk_buf) |buf| {
            return try AndroidLmkMetricReader.init(buf);
        }
        return try AndroidLmkMetricReader.init(&[_]u8{});
    }
    pub fn getAndroidPowrails(self: *const TraceMetricsReader) gremlin.Error!AndroidPowerRailsReader {
        if (self._android_powrails_buf) |buf| {
            return try AndroidPowerRailsReader.init(buf);
        }
        return try AndroidPowerRailsReader.init(&[_]u8{});
    }
    pub fn getAndroidStartup(self: *const TraceMetricsReader) gremlin.Error!AndroidStartupMetricReader {
        if (self._android_startup_buf) |buf| {
            return try AndroidStartupMetricReader.init(buf);
        }
        return try AndroidStartupMetricReader.init(&[_]u8{});
    }
    pub fn getTraceMetadata(self: *const TraceMetricsReader) gremlin.Error!TraceMetadataReader {
        if (self._trace_metadata_buf) |buf| {
            return try TraceMetadataReader.init(buf);
        }
        return try TraceMetadataReader.init(&[_]u8{});
    }
    pub fn getTraceStats(self: *const TraceMetricsReader) gremlin.Error!TraceAnalysisStatsReader {
        if (self._trace_stats_buf) |buf| {
            return try TraceAnalysisStatsReader.init(buf);
        }
        return try TraceAnalysisStatsReader.init(&[_]u8{});
    }
    pub fn getUnsymbolizedFrames(self: *const TraceMetricsReader) gremlin.Error!UnsymbolizedFramesReader {
        if (self._unsymbolized_frames_buf) |buf| {
            return try UnsymbolizedFramesReader.init(buf);
        }
        return try UnsymbolizedFramesReader.init(&[_]u8{});
    }
    pub fn getJavaHeapStats(self: *const TraceMetricsReader) gremlin.Error!JavaHeapStatsReader {
        if (self._java_heap_stats_buf) |buf| {
            return try JavaHeapStatsReader.init(buf);
        }
        return try JavaHeapStatsReader.init(&[_]u8{});
    }
    pub fn getJavaHeapHistogram(self: *const TraceMetricsReader) gremlin.Error!JavaHeapHistogramReader {
        if (self._java_heap_histogram_buf) |buf| {
            return try JavaHeapHistogramReader.init(buf);
        }
        return try JavaHeapHistogramReader.init(&[_]u8{});
    }
    pub fn getJavaHeapClassStats(self: *const TraceMetricsReader) gremlin.Error!JavaHeapClassStatsReader {
        if (self._java_heap_class_stats_buf) |buf| {
            return try JavaHeapClassStatsReader.init(buf);
        }
        return try JavaHeapClassStatsReader.init(&[_]u8{});
    }
    pub fn getAndroidLmkReason(self: *const TraceMetricsReader) gremlin.Error!AndroidLmkReasonMetricReader {
        if (self._android_lmk_reason_buf) |buf| {
            return try AndroidLmkReasonMetricReader.init(buf);
        }
        return try AndroidLmkReasonMetricReader.init(&[_]u8{});
    }
    pub fn getAndroidHwuiMetric(self: *const TraceMetricsReader) gremlin.Error!AndroidHwuiMetricReader {
        if (self._android_hwui_metric_buf) |buf| {
            return try AndroidHwuiMetricReader.init(buf);
        }
        return try AndroidHwuiMetricReader.init(&[_]u8{});
    }
    pub fn getDisplayMetrics(self: *const TraceMetricsReader) gremlin.Error!AndroidDisplayMetricsReader {
        if (self._display_metrics_buf) |buf| {
            return try AndroidDisplayMetricsReader.init(buf);
        }
        return try AndroidDisplayMetricsReader.init(&[_]u8{});
    }
    pub fn getAndroidTaskNames(self: *const TraceMetricsReader) gremlin.Error!AndroidTaskNamesReader {
        if (self._android_task_names_buf) |buf| {
            return try AndroidTaskNamesReader.init(buf);
        }
        return try AndroidTaskNamesReader.init(&[_]u8{});
    }
    pub fn getAndroidSurfaceflinger(self: *const TraceMetricsReader) gremlin.Error!AndroidSurfaceflingerMetricReader {
        if (self._android_surfaceflinger_buf) |buf| {
            return try AndroidSurfaceflingerMetricReader.init(buf);
        }
        return try AndroidSurfaceflingerMetricReader.init(&[_]u8{});
    }
    pub fn getAndroidGpu(self: *const TraceMetricsReader) gremlin.Error!AndroidGpuMetricReader {
        if (self._android_gpu_buf) |buf| {
            return try AndroidGpuMetricReader.init(buf);
        }
        return try AndroidGpuMetricReader.init(&[_]u8{});
    }
    pub fn getAndroidJankCuj(self: *const TraceMetricsReader) gremlin.Error!AndroidJankCujMetricReader {
        if (self._android_jank_cuj_buf) |buf| {
            return try AndroidJankCujMetricReader.init(buf);
        }
        return try AndroidJankCujMetricReader.init(&[_]u8{});
    }
    pub fn getAndroidHwcomposer(self: *const TraceMetricsReader) gremlin.Error!AndroidHwcomposerMetricsReader {
        if (self._android_hwcomposer_buf) |buf| {
            return try AndroidHwcomposerMetricsReader.init(buf);
        }
        return try AndroidHwcomposerMetricsReader.init(&[_]u8{});
    }
    pub fn getG2d(self: *const TraceMetricsReader) gremlin.Error!G2dMetricsReader {
        if (self._g2d_buf) |buf| {
            return try G2dMetricsReader.init(buf);
        }
        return try G2dMetricsReader.init(&[_]u8{});
    }
    pub fn getAndroidDmaHeap(self: *const TraceMetricsReader) gremlin.Error!AndroidDmaHeapMetricReader {
        if (self._android_dma_heap_buf) |buf| {
            return try AndroidDmaHeapMetricReader.init(buf);
        }
        return try AndroidDmaHeapMetricReader.init(&[_]u8{});
    }
    pub fn getAndroidTraceQuality(self: *const TraceMetricsReader) gremlin.Error!AndroidTraceQualityMetricReader {
        if (self._android_trace_quality_buf) |buf| {
            return try AndroidTraceQualityMetricReader.init(buf);
        }
        return try AndroidTraceQualityMetricReader.init(&[_]u8{});
    }
    pub fn getProfilerSmaps(self: *const TraceMetricsReader) gremlin.Error!ProfilerSmapsReader {
        if (self._profiler_smaps_buf) |buf| {
            return try ProfilerSmapsReader.init(buf);
        }
        return try ProfilerSmapsReader.init(&[_]u8{});
    }
    pub fn getAndroidMultiuser(self: *const TraceMetricsReader) gremlin.Error!AndroidMultiuserMetricReader {
        if (self._android_multiuser_buf) |buf| {
            return try AndroidMultiuserMetricReader.init(buf);
        }
        return try AndroidMultiuserMetricReader.init(&[_]u8{});
    }
    pub fn getAndroidSimpleperf(self: *const TraceMetricsReader) gremlin.Error!AndroidSimpleperfMetricReader {
        if (self._android_simpleperf_buf) |buf| {
            return try AndroidSimpleperfMetricReader.init(buf);
        }
        return try AndroidSimpleperfMetricReader.init(&[_]u8{});
    }
    pub fn getAndroidCamera(self: *const TraceMetricsReader) gremlin.Error!AndroidCameraMetricReader {
        if (self._android_camera_buf) |buf| {
            return try AndroidCameraMetricReader.init(buf);
        }
        return try AndroidCameraMetricReader.init(&[_]u8{});
    }
    pub fn getAndroidDvfs(self: *const TraceMetricsReader) gremlin.Error!AndroidDvfsMetricReader {
        if (self._android_dvfs_buf) |buf| {
            return try AndroidDvfsMetricReader.init(buf);
        }
        return try AndroidDvfsMetricReader.init(&[_]u8{});
    }
    pub fn getAndroidNetperf(self: *const TraceMetricsReader) gremlin.Error!AndroidNetworkMetricReader {
        if (self._android_netperf_buf) |buf| {
            return try AndroidNetworkMetricReader.init(buf);
        }
        return try AndroidNetworkMetricReader.init(&[_]u8{});
    }
    pub fn getAndroidCameraUnagg(self: *const TraceMetricsReader) gremlin.Error!AndroidCameraUnaggregatedMetricReader {
        if (self._android_camera_unagg_buf) |buf| {
            return try AndroidCameraUnaggregatedMetricReader.init(buf);
        }
        return try AndroidCameraUnaggregatedMetricReader.init(&[_]u8{});
    }
    pub fn getAndroidRtRuntime(self: *const TraceMetricsReader) gremlin.Error!AndroidRtRuntimeMetricReader {
        if (self._android_rt_runtime_buf) |buf| {
            return try AndroidRtRuntimeMetricReader.init(buf);
        }
        return try AndroidRtRuntimeMetricReader.init(&[_]u8{});
    }
    pub fn getAndroidIrqRuntime(self: *const TraceMetricsReader) gremlin.Error!AndroidIrqRuntimeMetricReader {
        if (self._android_irq_runtime_buf) |buf| {
            return try AndroidIrqRuntimeMetricReader.init(buf);
        }
        return try AndroidIrqRuntimeMetricReader.init(&[_]u8{});
    }
    pub fn getAndroidBinder(self: *const TraceMetricsReader) gremlin.Error!AndroidBinderMetricReader {
        if (self._android_binder_buf) |buf| {
            return try AndroidBinderMetricReader.init(buf);
        }
        return try AndroidBinderMetricReader.init(&[_]u8{});
    }
    pub fn getAndroidFrameTimelineMetric(self: *const TraceMetricsReader) gremlin.Error!AndroidFrameTimelineMetricReader {
        if (self._android_frame_timeline_metric_buf) |buf| {
            return try AndroidFrameTimelineMetricReader.init(buf);
        }
        return try AndroidFrameTimelineMetricReader.init(&[_]u8{});
    }
    pub fn getAndroidBlockingCallsCujMetric(self: *const TraceMetricsReader) gremlin.Error!AndroidBlockingCallsCujMetricReader {
        if (self._android_blocking_calls_cuj_metric_buf) |buf| {
            return try AndroidBlockingCallsCujMetricReader.init(buf);
        }
        return try AndroidBlockingCallsCujMetricReader.init(&[_]u8{});
    }
    pub fn getAndroidMonitorContention(self: *const TraceMetricsReader) gremlin.Error!AndroidMonitorContentionMetricReader {
        if (self._android_monitor_contention_buf) |buf| {
            return try AndroidMonitorContentionMetricReader.init(buf);
        }
        return try AndroidMonitorContentionMetricReader.init(&[_]u8{});
    }
    pub fn getAndroidSysuiNotificationsBlockingCallsMetric(self: *const TraceMetricsReader) gremlin.Error!AndroidSysUINotificationsBlockingCallsMetricReader {
        if (self._android_sysui_notifications_blocking_calls_metric_buf) |buf| {
            return try AndroidSysUINotificationsBlockingCallsMetricReader.init(buf);
        }
        return try AndroidSysUINotificationsBlockingCallsMetricReader.init(&[_]u8{});
    }
    pub fn getCodecMetrics(self: *const TraceMetricsReader) gremlin.Error!AndroidCodecMetricsReader {
        if (self._codec_metrics_buf) |buf| {
            return try AndroidCodecMetricsReader.init(buf);
        }
        return try AndroidCodecMetricsReader.init(&[_]u8{});
    }
    pub fn getAndroidIo(self: *const TraceMetricsReader) gremlin.Error!AndroidIoReader {
        if (self._android_io_buf) |buf| {
            return try AndroidIoReader.init(buf);
        }
        return try AndroidIoReader.init(&[_]u8{});
    }
    pub fn getAndroidIoUnagg(self: *const TraceMetricsReader) gremlin.Error!AndroidIoUnaggregatedReader {
        if (self._android_io_unagg_buf) |buf| {
            return try AndroidIoUnaggregatedReader.init(buf);
        }
        return try AndroidIoUnaggregatedReader.init(&[_]u8{});
    }
    pub fn getAndroidAnr(self: *const TraceMetricsReader) gremlin.Error!AndroidAnrMetricReader {
        if (self._android_anr_buf) |buf| {
            return try AndroidAnrMetricReader.init(buf);
        }
        return try AndroidAnrMetricReader.init(&[_]u8{});
    }
    pub fn getAndroidMonitorContentionAgg(self: *const TraceMetricsReader) gremlin.Error!AndroidMonitorContentionAggMetricReader {
        if (self._android_monitor_contention_agg_buf) |buf| {
            return try AndroidMonitorContentionAggMetricReader.init(buf);
        }
        return try AndroidMonitorContentionAggMetricReader.init(&[_]u8{});
    }
    pub fn getAndroidBoot(self: *const TraceMetricsReader) gremlin.Error!AndroidBootMetricReader {
        if (self._android_boot_buf) |buf| {
            return try AndroidBootMetricReader.init(buf);
        }
        return try AndroidBootMetricReader.init(&[_]u8{});
    }
    pub fn getAdServicesMetric(self: *const TraceMetricsReader) gremlin.Error!AdServicesMetricReader {
        if (self._ad_services_metric_buf) |buf| {
            return try AdServicesMetricReader.init(buf);
        }
        return try AdServicesMetricReader.init(&[_]u8{});
    }
    pub fn getSysuiNotifShadeListBuilderMetric(self: *const TraceMetricsReader) gremlin.Error!SysuiNotifShadeListBuilderMetricReader {
        if (self._sysui_notif_shade_list_builder_metric_buf) |buf| {
            return try SysuiNotifShadeListBuilderMetricReader.init(buf);
        }
        return try SysuiNotifShadeListBuilderMetricReader.init(&[_]u8{});
    }
    pub fn getSysuiUpdateNotifOnUiModeChangedMetric(self: *const TraceMetricsReader) gremlin.Error!SysuiUpdateNotifOnUiModeChangedMetricReader {
        if (self._sysui_update_notif_on_ui_mode_changed_metric_buf) |buf| {
            return try SysuiUpdateNotifOnUiModeChangedMetricReader.init(buf);
        }
        return try SysuiUpdateNotifOnUiModeChangedMetricReader.init(&[_]u8{});
    }
    pub fn getAndroidAppProcessStarts(self: *const TraceMetricsReader) gremlin.Error!AndroidAppProcessStartsMetricReader {
        if (self._android_app_process_starts_buf) |buf| {
            return try AndroidAppProcessStartsMetricReader.init(buf);
        }
        return try AndroidAppProcessStartsMetricReader.init(&[_]u8{});
    }
    pub fn getAndroidBootUnagg(self: *const TraceMetricsReader) gremlin.Error!AndroidBootUnaggReader {
        if (self._android_boot_unagg_buf) |buf| {
            return try AndroidBootUnaggReader.init(buf);
        }
        return try AndroidBootUnaggReader.init(&[_]u8{});
    }
    pub fn getAndroidGarbageCollectionUnagg(self: *const TraceMetricsReader) gremlin.Error!AndroidGarbageCollectionUnaggMetricReader {
        if (self._android_garbage_collection_unagg_buf) |buf| {
            return try AndroidGarbageCollectionUnaggMetricReader.init(buf);
        }
        return try AndroidGarbageCollectionUnaggMetricReader.init(&[_]u8{});
    }
    pub fn getAndroidAutoMultiuser(self: *const TraceMetricsReader) gremlin.Error!AndroidAutoMultiuserMetricReader {
        if (self._android_auto_multiuser_buf) |buf| {
            return try AndroidAutoMultiuserMetricReader.init(buf);
        }
        return try AndroidAutoMultiuserMetricReader.init(&[_]u8{});
    }
    pub fn getAndroidBlockingCallsUnagg(self: *const TraceMetricsReader) gremlin.Error!AndroidBlockingCallsUnaggReader {
        if (self._android_blocking_calls_unagg_buf) |buf| {
            return try AndroidBlockingCallsUnaggReader.init(buf);
        }
        return try AndroidBlockingCallsUnaggReader.init(&[_]u8{});
    }
    pub fn getAndroidOomAdjuster(self: *const TraceMetricsReader) gremlin.Error!AndroidOomAdjusterMetricReader {
        if (self._android_oom_adjuster_buf) |buf| {
            return try AndroidOomAdjusterMetricReader.init(buf);
        }
        return try AndroidOomAdjusterMetricReader.init(&[_]u8{});
    }
    pub fn getAndroidBroadcasts(self: *const TraceMetricsReader) gremlin.Error!AndroidBroadcastsMetricReader {
        if (self._android_broadcasts_buf) |buf| {
            return try AndroidBroadcastsMetricReader.init(buf);
        }
        return try AndroidBroadcastsMetricReader.init(&[_]u8{});
    }
    pub fn getWattsonAppStartupRails(self: *const TraceMetricsReader) gremlin.Error!AndroidWattsonTimePeriodMetricReader {
        if (self._wattson_app_startup_rails_buf) |buf| {
            return try AndroidWattsonTimePeriodMetricReader.init(buf);
        }
        return try AndroidWattsonTimePeriodMetricReader.init(&[_]u8{});
    }
    pub fn getWattsonTraceRails(self: *const TraceMetricsReader) gremlin.Error!AndroidWattsonTimePeriodMetricReader {
        if (self._wattson_trace_rails_buf) |buf| {
            return try AndroidWattsonTimePeriodMetricReader.init(buf);
        }
        return try AndroidWattsonTimePeriodMetricReader.init(&[_]u8{});
    }
    pub fn getAndroidAnomaly(self: *const TraceMetricsReader) gremlin.Error!AndroidAnomalyMetricReader {
        if (self._android_anomaly_buf) |buf| {
            return try AndroidAnomalyMetricReader.init(buf);
        }
        return try AndroidAnomalyMetricReader.init(&[_]u8{});
    }
    pub fn getWattsonTraceThreads(self: *const TraceMetricsReader) gremlin.Error!AndroidWattsonTasksAttributionMetricReader {
        if (self._wattson_trace_threads_buf) |buf| {
            return try AndroidWattsonTasksAttributionMetricReader.init(buf);
        }
        return try AndroidWattsonTasksAttributionMetricReader.init(&[_]u8{});
    }
    pub fn getWattsonMarkersThreads(self: *const TraceMetricsReader) gremlin.Error!AndroidWattsonTasksAttributionMetricReader {
        if (self._wattson_markers_threads_buf) |buf| {
            return try AndroidWattsonTasksAttributionMetricReader.init(buf);
        }
        return try AndroidWattsonTasksAttributionMetricReader.init(&[_]u8{});
    }
    pub fn getWattsonMarkersRails(self: *const TraceMetricsReader) gremlin.Error!AndroidWattsonTimePeriodMetricReader {
        if (self._wattson_markers_rails_buf) |buf| {
            return try AndroidWattsonTimePeriodMetricReader.init(buf);
        }
        return try AndroidWattsonTimePeriodMetricReader.init(&[_]u8{});
    }
    pub fn getWattsonAtraceAppsRails(self: *const TraceMetricsReader) gremlin.Error!AndroidWattsonTimePeriodMetricReader {
        if (self._wattson_atrace_apps_rails_buf) |buf| {
            return try AndroidWattsonTimePeriodMetricReader.init(buf);
        }
        return try AndroidWattsonTimePeriodMetricReader.init(&[_]u8{});
    }
    pub fn getAndroidGarbageCollectionStats(self: *const TraceMetricsReader) gremlin.Error!AndroidGarbageCollectionStatsReader {
        if (self._android_garbage_collection_stats_buf) |buf| {
            return try AndroidGarbageCollectionStatsReader.init(buf);
        }
        return try AndroidGarbageCollectionStatsReader.init(&[_]u8{});
    }
    pub fn getCloneDuration(self: *const TraceMetricsReader) gremlin.Error!CloneDurationReader {
        if (self._clone_duration_buf) |buf| {
            return try CloneDurationReader.init(buf);
        }
        return try CloneDurationReader.init(&[_]u8{});
    }
    pub fn getAndroidBlockingCallsCujPerFrameMetric(self: *const TraceMetricsReader) gremlin.Error!AndroidCujBlockingCallsPerFrameMetricReader {
        if (self._android_blocking_calls_cuj_per_frame_metric_buf) |buf| {
            return try AndroidCujBlockingCallsPerFrameMetricReader.init(buf);
        }
        return try AndroidCujBlockingCallsPerFrameMetricReader.init(&[_]u8{});
    }
    pub fn getWattsonAppStartupThreads(self: *const TraceMetricsReader) gremlin.Error!AndroidWattsonTasksAttributionMetricReader {
        if (self._wattson_app_startup_threads_buf) |buf| {
            return try AndroidWattsonTasksAttributionMetricReader.init(buf);
        }
        return try AndroidWattsonTasksAttributionMetricReader.init(&[_]u8{});
    }
    pub fn getWattsonAtraceAppsThreads(self: *const TraceMetricsReader) gremlin.Error!AndroidWattsonTasksAttributionMetricReader {
        if (self._wattson_atrace_apps_threads_buf) |buf| {
            return try AndroidWattsonTasksAttributionMetricReader.init(buf);
        }
        return try AndroidWattsonTasksAttributionMetricReader.init(&[_]u8{});
    }
};
