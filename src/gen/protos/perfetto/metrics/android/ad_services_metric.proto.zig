// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const AdServicesUiMetricWire = struct {
    const COMMON_SERVICE_INITIALIZATION_LATENCY_WIRE: gremlin.ProtoWireNumber = 1;
    const COMMON_SERVICE_PERMISSION_CHECK_LATENCY_WIRE: gremlin.ProtoWireNumber = 2;
    const COMMON_SERVICE_UX_ENGINE_FLOW_LATENCY_WIRE: gremlin.ProtoWireNumber = 3;
    const MAIN_ACTIVITY_CREATION_LATENCY_WIRE: gremlin.ProtoWireNumber = 4;
    const CONSENT_MANAGER_INITIALIZATION_LATENCY_WIRE: gremlin.ProtoWireNumber = 5;
    const CONSENT_MANAGER_READ_LATENCY_WIRE: gremlin.ProtoWireNumber = 6;
    const CONSENT_MANAGER_WRITE_LATENCY_WIRE: gremlin.ProtoWireNumber = 7;
};
pub const AdServicesUiMetric = struct {
    // fields
    common_service_initialization_latency: f64 = 0.0,
    common_service_permission_check_latency: f64 = 0.0,
    common_service_ux_engine_flow_latency: f64 = 0.0,
    main_activity_creation_latency: f64 = 0.0,
    consent_manager_initialization_latency: f64 = 0.0,
    consent_manager_read_latency: f64 = 0.0,
    consent_manager_write_latency: f64 = 0.0,
    pub fn calcProtobufSize(self: *const AdServicesUiMetric) usize {
        var res: usize = 0;
        if (self.common_service_initialization_latency != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AdServicesUiMetricWire.COMMON_SERVICE_INITIALIZATION_LATENCY_WIRE) + gremlin.sizes.sizeDouble(self.common_service_initialization_latency);
        }
        if (self.common_service_permission_check_latency != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AdServicesUiMetricWire.COMMON_SERVICE_PERMISSION_CHECK_LATENCY_WIRE) + gremlin.sizes.sizeDouble(self.common_service_permission_check_latency);
        }
        if (self.common_service_ux_engine_flow_latency != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AdServicesUiMetricWire.COMMON_SERVICE_UX_ENGINE_FLOW_LATENCY_WIRE) + gremlin.sizes.sizeDouble(self.common_service_ux_engine_flow_latency);
        }
        if (self.main_activity_creation_latency != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AdServicesUiMetricWire.MAIN_ACTIVITY_CREATION_LATENCY_WIRE) + gremlin.sizes.sizeDouble(self.main_activity_creation_latency);
        }
        if (self.consent_manager_initialization_latency != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AdServicesUiMetricWire.CONSENT_MANAGER_INITIALIZATION_LATENCY_WIRE) + gremlin.sizes.sizeDouble(self.consent_manager_initialization_latency);
        }
        if (self.consent_manager_read_latency != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AdServicesUiMetricWire.CONSENT_MANAGER_READ_LATENCY_WIRE) + gremlin.sizes.sizeDouble(self.consent_manager_read_latency);
        }
        if (self.consent_manager_write_latency != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AdServicesUiMetricWire.CONSENT_MANAGER_WRITE_LATENCY_WIRE) + gremlin.sizes.sizeDouble(self.consent_manager_write_latency);
        }
        return res;
    }
    pub fn encode(self: *const AdServicesUiMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AdServicesUiMetric, target: *gremlin.Writer) void {
        if (self.common_service_initialization_latency != 0.0) {
            target.appendFloat64(AdServicesUiMetricWire.COMMON_SERVICE_INITIALIZATION_LATENCY_WIRE, self.common_service_initialization_latency);
        }
        if (self.common_service_permission_check_latency != 0.0) {
            target.appendFloat64(AdServicesUiMetricWire.COMMON_SERVICE_PERMISSION_CHECK_LATENCY_WIRE, self.common_service_permission_check_latency);
        }
        if (self.common_service_ux_engine_flow_latency != 0.0) {
            target.appendFloat64(AdServicesUiMetricWire.COMMON_SERVICE_UX_ENGINE_FLOW_LATENCY_WIRE, self.common_service_ux_engine_flow_latency);
        }
        if (self.main_activity_creation_latency != 0.0) {
            target.appendFloat64(AdServicesUiMetricWire.MAIN_ACTIVITY_CREATION_LATENCY_WIRE, self.main_activity_creation_latency);
        }
        if (self.consent_manager_initialization_latency != 0.0) {
            target.appendFloat64(AdServicesUiMetricWire.CONSENT_MANAGER_INITIALIZATION_LATENCY_WIRE, self.consent_manager_initialization_latency);
        }
        if (self.consent_manager_read_latency != 0.0) {
            target.appendFloat64(AdServicesUiMetricWire.CONSENT_MANAGER_READ_LATENCY_WIRE, self.consent_manager_read_latency);
        }
        if (self.consent_manager_write_latency != 0.0) {
            target.appendFloat64(AdServicesUiMetricWire.CONSENT_MANAGER_WRITE_LATENCY_WIRE, self.consent_manager_write_latency);
        }
    }
};
pub const AdServicesUiMetricReader = struct {
    buf: gremlin.Reader,
    _common_service_initialization_latency: f64 = 0.0,
    _common_service_permission_check_latency: f64 = 0.0,
    _common_service_ux_engine_flow_latency: f64 = 0.0,
    _main_activity_creation_latency: f64 = 0.0,
    _consent_manager_initialization_latency: f64 = 0.0,
    _consent_manager_read_latency: f64 = 0.0,
    _consent_manager_write_latency: f64 = 0.0,
    pub fn init(src: []const u8) gremlin.Error!AdServicesUiMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AdServicesUiMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AdServicesUiMetricWire.COMMON_SERVICE_INITIALIZATION_LATENCY_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._common_service_initialization_latency = result.value;
                },
                AdServicesUiMetricWire.COMMON_SERVICE_PERMISSION_CHECK_LATENCY_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._common_service_permission_check_latency = result.value;
                },
                AdServicesUiMetricWire.COMMON_SERVICE_UX_ENGINE_FLOW_LATENCY_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._common_service_ux_engine_flow_latency = result.value;
                },
                AdServicesUiMetricWire.MAIN_ACTIVITY_CREATION_LATENCY_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._main_activity_creation_latency = result.value;
                },
                AdServicesUiMetricWire.CONSENT_MANAGER_INITIALIZATION_LATENCY_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._consent_manager_initialization_latency = result.value;
                },
                AdServicesUiMetricWire.CONSENT_MANAGER_READ_LATENCY_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._consent_manager_read_latency = result.value;
                },
                AdServicesUiMetricWire.CONSENT_MANAGER_WRITE_LATENCY_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._consent_manager_write_latency = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getCommonServiceInitializationLatency(self: *const AdServicesUiMetricReader) f64 {
        return self._common_service_initialization_latency;
    }
    pub inline fn getCommonServicePermissionCheckLatency(self: *const AdServicesUiMetricReader) f64 {
        return self._common_service_permission_check_latency;
    }
    pub inline fn getCommonServiceUxEngineFlowLatency(self: *const AdServicesUiMetricReader) f64 {
        return self._common_service_ux_engine_flow_latency;
    }
    pub inline fn getMainActivityCreationLatency(self: *const AdServicesUiMetricReader) f64 {
        return self._main_activity_creation_latency;
    }
    pub inline fn getConsentManagerInitializationLatency(self: *const AdServicesUiMetricReader) f64 {
        return self._consent_manager_initialization_latency;
    }
    pub inline fn getConsentManagerReadLatency(self: *const AdServicesUiMetricReader) f64 {
        return self._consent_manager_read_latency;
    }
    pub inline fn getConsentManagerWriteLatency(self: *const AdServicesUiMetricReader) f64 {
        return self._consent_manager_write_latency;
    }
};
const AdServicesAdIdMetricWire = struct {
    const LATENCY_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const AdServicesAdIdMetric = struct {
    // fields
    latency: f64 = 0.0,
    pub fn calcProtobufSize(self: *const AdServicesAdIdMetric) usize {
        var res: usize = 0;
        if (self.latency != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AdServicesAdIdMetricWire.LATENCY_WIRE) + gremlin.sizes.sizeDouble(self.latency);
        }
        return res;
    }
    pub fn encode(self: *const AdServicesAdIdMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AdServicesAdIdMetric, target: *gremlin.Writer) void {
        if (self.latency != 0.0) {
            target.appendFloat64(AdServicesAdIdMetricWire.LATENCY_WIRE, self.latency);
        }
    }
};
pub const AdServicesAdIdMetricReader = struct {
    buf: gremlin.Reader,
    _latency: f64 = 0.0,
    pub fn init(src: []const u8) gremlin.Error!AdServicesAdIdMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AdServicesAdIdMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AdServicesAdIdMetricWire.LATENCY_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._latency = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getLatency(self: *const AdServicesAdIdMetricReader) f64 {
        return self._latency;
    }
};
const AdServicesAppSetIdMetricWire = struct {
    const LATENCY_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const AdServicesAppSetIdMetric = struct {
    // fields
    latency: f64 = 0.0,
    pub fn calcProtobufSize(self: *const AdServicesAppSetIdMetric) usize {
        var res: usize = 0;
        if (self.latency != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AdServicesAppSetIdMetricWire.LATENCY_WIRE) + gremlin.sizes.sizeDouble(self.latency);
        }
        return res;
    }
    pub fn encode(self: *const AdServicesAppSetIdMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AdServicesAppSetIdMetric, target: *gremlin.Writer) void {
        if (self.latency != 0.0) {
            target.appendFloat64(AdServicesAppSetIdMetricWire.LATENCY_WIRE, self.latency);
        }
    }
};
pub const AdServicesAppSetIdMetricReader = struct {
    buf: gremlin.Reader,
    _latency: f64 = 0.0,
    pub fn init(src: []const u8) gremlin.Error!AdServicesAppSetIdMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AdServicesAppSetIdMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AdServicesAppSetIdMetricWire.LATENCY_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._latency = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getLatency(self: *const AdServicesAppSetIdMetricReader) f64 {
        return self._latency;
    }
};
const OnDevicePersonalizationMetricWire = struct {
    const MANAGING_SERVICE_INITIALIZATION_LATENCY_WIRE: gremlin.ProtoWireNumber = 1;
    const SERVICE_DELEGATE_EXECUTE_FLOW_LATENCY_WIRE: gremlin.ProtoWireNumber = 2;
    const SERVICE_DELEGATE_REQUEST_SURFACE_PACKAGE_LATENCY_WIRE: gremlin.ProtoWireNumber = 3;
    const SERVICE_DELEGATE_REGISTER_WEB_TRIGGER_LATENCY_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const OnDevicePersonalizationMetric = struct {
    // fields
    managing_service_initialization_latency: f64 = 0.0,
    service_delegate_execute_flow_latency: f64 = 0.0,
    service_delegate_request_surface_package_latency: f64 = 0.0,
    service_delegate_register_web_trigger_latency: f64 = 0.0,
    pub fn calcProtobufSize(self: *const OnDevicePersonalizationMetric) usize {
        var res: usize = 0;
        if (self.managing_service_initialization_latency != 0.0) {
            res += gremlin.sizes.sizeWireNumber(OnDevicePersonalizationMetricWire.MANAGING_SERVICE_INITIALIZATION_LATENCY_WIRE) + gremlin.sizes.sizeDouble(self.managing_service_initialization_latency);
        }
        if (self.service_delegate_execute_flow_latency != 0.0) {
            res += gremlin.sizes.sizeWireNumber(OnDevicePersonalizationMetricWire.SERVICE_DELEGATE_EXECUTE_FLOW_LATENCY_WIRE) + gremlin.sizes.sizeDouble(self.service_delegate_execute_flow_latency);
        }
        if (self.service_delegate_request_surface_package_latency != 0.0) {
            res += gremlin.sizes.sizeWireNumber(OnDevicePersonalizationMetricWire.SERVICE_DELEGATE_REQUEST_SURFACE_PACKAGE_LATENCY_WIRE) + gremlin.sizes.sizeDouble(self.service_delegate_request_surface_package_latency);
        }
        if (self.service_delegate_register_web_trigger_latency != 0.0) {
            res += gremlin.sizes.sizeWireNumber(OnDevicePersonalizationMetricWire.SERVICE_DELEGATE_REGISTER_WEB_TRIGGER_LATENCY_WIRE) + gremlin.sizes.sizeDouble(self.service_delegate_register_web_trigger_latency);
        }
        return res;
    }
    pub fn encode(self: *const OnDevicePersonalizationMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const OnDevicePersonalizationMetric, target: *gremlin.Writer) void {
        if (self.managing_service_initialization_latency != 0.0) {
            target.appendFloat64(OnDevicePersonalizationMetricWire.MANAGING_SERVICE_INITIALIZATION_LATENCY_WIRE, self.managing_service_initialization_latency);
        }
        if (self.service_delegate_execute_flow_latency != 0.0) {
            target.appendFloat64(OnDevicePersonalizationMetricWire.SERVICE_DELEGATE_EXECUTE_FLOW_LATENCY_WIRE, self.service_delegate_execute_flow_latency);
        }
        if (self.service_delegate_request_surface_package_latency != 0.0) {
            target.appendFloat64(OnDevicePersonalizationMetricWire.SERVICE_DELEGATE_REQUEST_SURFACE_PACKAGE_LATENCY_WIRE, self.service_delegate_request_surface_package_latency);
        }
        if (self.service_delegate_register_web_trigger_latency != 0.0) {
            target.appendFloat64(OnDevicePersonalizationMetricWire.SERVICE_DELEGATE_REGISTER_WEB_TRIGGER_LATENCY_WIRE, self.service_delegate_register_web_trigger_latency);
        }
    }
};
pub const OnDevicePersonalizationMetricReader = struct {
    buf: gremlin.Reader,
    _managing_service_initialization_latency: f64 = 0.0,
    _service_delegate_execute_flow_latency: f64 = 0.0,
    _service_delegate_request_surface_package_latency: f64 = 0.0,
    _service_delegate_register_web_trigger_latency: f64 = 0.0,
    pub fn init(src: []const u8) gremlin.Error!OnDevicePersonalizationMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = OnDevicePersonalizationMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                OnDevicePersonalizationMetricWire.MANAGING_SERVICE_INITIALIZATION_LATENCY_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._managing_service_initialization_latency = result.value;
                },
                OnDevicePersonalizationMetricWire.SERVICE_DELEGATE_EXECUTE_FLOW_LATENCY_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._service_delegate_execute_flow_latency = result.value;
                },
                OnDevicePersonalizationMetricWire.SERVICE_DELEGATE_REQUEST_SURFACE_PACKAGE_LATENCY_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._service_delegate_request_surface_package_latency = result.value;
                },
                OnDevicePersonalizationMetricWire.SERVICE_DELEGATE_REGISTER_WEB_TRIGGER_LATENCY_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._service_delegate_register_web_trigger_latency = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getManagingServiceInitializationLatency(self: *const OnDevicePersonalizationMetricReader) f64 {
        return self._managing_service_initialization_latency;
    }
    pub inline fn getServiceDelegateExecuteFlowLatency(self: *const OnDevicePersonalizationMetricReader) f64 {
        return self._service_delegate_execute_flow_latency;
    }
    pub inline fn getServiceDelegateRequestSurfacePackageLatency(self: *const OnDevicePersonalizationMetricReader) f64 {
        return self._service_delegate_request_surface_package_latency;
    }
    pub inline fn getServiceDelegateRegisterWebTriggerLatency(self: *const OnDevicePersonalizationMetricReader) f64 {
        return self._service_delegate_register_web_trigger_latency;
    }
};
const AdServicesMetricWire = struct {
    const UI_METRIC_WIRE: gremlin.ProtoWireNumber = 1;
    const AD_ID_METRIC_WIRE: gremlin.ProtoWireNumber = 2;
    const APP_SET_ID_METRIC_WIRE: gremlin.ProtoWireNumber = 3;
    const ODP_METRIC_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const AdServicesMetric = struct {
    // fields
    ui_metric: ?[]const ?AdServicesUiMetric = null,
    ad_id_metric: ?[]const ?AdServicesAdIdMetric = null,
    app_set_id_metric: ?[]const ?AdServicesAppSetIdMetric = null,
    odp_metric: ?[]const ?OnDevicePersonalizationMetric = null,
    pub fn calcProtobufSize(self: *const AdServicesMetric) usize {
        var res: usize = 0;
        if (self.ui_metric) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AdServicesMetricWire.UI_METRIC_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.ad_id_metric) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AdServicesMetricWire.AD_ID_METRIC_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.app_set_id_metric) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AdServicesMetricWire.APP_SET_ID_METRIC_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.odp_metric) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AdServicesMetricWire.ODP_METRIC_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AdServicesMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AdServicesMetric, target: *gremlin.Writer) void {
        if (self.ui_metric) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AdServicesMetricWire.UI_METRIC_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AdServicesMetricWire.UI_METRIC_WIRE, 0);
                }
            }
        }
        if (self.ad_id_metric) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AdServicesMetricWire.AD_ID_METRIC_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AdServicesMetricWire.AD_ID_METRIC_WIRE, 0);
                }
            }
        }
        if (self.app_set_id_metric) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AdServicesMetricWire.APP_SET_ID_METRIC_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AdServicesMetricWire.APP_SET_ID_METRIC_WIRE, 0);
                }
            }
        }
        if (self.odp_metric) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AdServicesMetricWire.ODP_METRIC_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AdServicesMetricWire.ODP_METRIC_WIRE, 0);
                }
            }
        }
    }
};
pub const AdServicesMetricReader = struct {
    buf: gremlin.Reader,
    _ui_metric_offset: ?usize = null,
    _ui_metric_last_offset: ?usize = null,
    _ui_metric_cnt: usize = 0,
    _ad_id_metric_offset: ?usize = null,
    _ad_id_metric_last_offset: ?usize = null,
    _ad_id_metric_cnt: usize = 0,
    _app_set_id_metric_offset: ?usize = null,
    _app_set_id_metric_last_offset: ?usize = null,
    _app_set_id_metric_cnt: usize = 0,
    _odp_metric_offset: ?usize = null,
    _odp_metric_last_offset: ?usize = null,
    _odp_metric_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AdServicesMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AdServicesMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AdServicesMetricWire.UI_METRIC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._ui_metric_offset == null) {
                        res._ui_metric_offset = offset - result.size;
                    }
                    res._ui_metric_last_offset = offset;
                    res._ui_metric_cnt += 1;
                },
                AdServicesMetricWire.AD_ID_METRIC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._ad_id_metric_offset == null) {
                        res._ad_id_metric_offset = offset - result.size;
                    }
                    res._ad_id_metric_last_offset = offset;
                    res._ad_id_metric_cnt += 1;
                },
                AdServicesMetricWire.APP_SET_ID_METRIC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._app_set_id_metric_offset == null) {
                        res._app_set_id_metric_offset = offset - result.size;
                    }
                    res._app_set_id_metric_last_offset = offset;
                    res._app_set_id_metric_cnt += 1;
                },
                AdServicesMetricWire.ODP_METRIC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._odp_metric_offset == null) {
                        res._odp_metric_offset = offset - result.size;
                    }
                    res._odp_metric_last_offset = offset;
                    res._odp_metric_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn uiMetricCount(self: *const AdServicesMetricReader) usize {
        return self._ui_metric_cnt;
    }
    pub fn uiMetricNext(self: *AdServicesMetricReader) ?AdServicesUiMetricReader {
        if (self._ui_metric_offset == null) return null;
        const current_offset = self._ui_metric_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AdServicesUiMetricReader.init(result.value) catch return null;
        if (self._ui_metric_last_offset != null and current_offset >= self._ui_metric_last_offset.?) {
            self._ui_metric_offset = null;
            return msg;
        }
        if (self._ui_metric_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._ui_metric_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AdServicesMetricWire.UI_METRIC_WIRE) {
                self._ui_metric_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._ui_metric_offset = null;
        return msg;
    }
    pub fn adIdMetricCount(self: *const AdServicesMetricReader) usize {
        return self._ad_id_metric_cnt;
    }
    pub fn adIdMetricNext(self: *AdServicesMetricReader) ?AdServicesAdIdMetricReader {
        if (self._ad_id_metric_offset == null) return null;
        const current_offset = self._ad_id_metric_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AdServicesAdIdMetricReader.init(result.value) catch return null;
        if (self._ad_id_metric_last_offset != null and current_offset >= self._ad_id_metric_last_offset.?) {
            self._ad_id_metric_offset = null;
            return msg;
        }
        if (self._ad_id_metric_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._ad_id_metric_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AdServicesMetricWire.AD_ID_METRIC_WIRE) {
                self._ad_id_metric_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._ad_id_metric_offset = null;
        return msg;
    }
    pub fn appSetIdMetricCount(self: *const AdServicesMetricReader) usize {
        return self._app_set_id_metric_cnt;
    }
    pub fn appSetIdMetricNext(self: *AdServicesMetricReader) ?AdServicesAppSetIdMetricReader {
        if (self._app_set_id_metric_offset == null) return null;
        const current_offset = self._app_set_id_metric_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AdServicesAppSetIdMetricReader.init(result.value) catch return null;
        if (self._app_set_id_metric_last_offset != null and current_offset >= self._app_set_id_metric_last_offset.?) {
            self._app_set_id_metric_offset = null;
            return msg;
        }
        if (self._app_set_id_metric_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._app_set_id_metric_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AdServicesMetricWire.APP_SET_ID_METRIC_WIRE) {
                self._app_set_id_metric_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._app_set_id_metric_offset = null;
        return msg;
    }
    pub fn odpMetricCount(self: *const AdServicesMetricReader) usize {
        return self._odp_metric_cnt;
    }
    pub fn odpMetricNext(self: *AdServicesMetricReader) ?OnDevicePersonalizationMetricReader {
        if (self._odp_metric_offset == null) return null;
        const current_offset = self._odp_metric_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = OnDevicePersonalizationMetricReader.init(result.value) catch return null;
        if (self._odp_metric_last_offset != null and current_offset >= self._odp_metric_last_offset.?) {
            self._odp_metric_offset = null;
            return msg;
        }
        if (self._odp_metric_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._odp_metric_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AdServicesMetricWire.ODP_METRIC_WIRE) {
                self._odp_metric_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._odp_metric_offset = null;
        return msg;
    }
};
