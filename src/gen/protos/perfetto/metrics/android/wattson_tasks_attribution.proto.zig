// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const AndroidWattsonTasksAttributionMetricWire = struct {
    const METRIC_VERSION_WIRE: gremlin.ProtoWireNumber = 1;
    const POWER_MODEL_VERSION_WIRE: gremlin.ProtoWireNumber = 2;
    const PERIOD_INFO_WIRE: gremlin.ProtoWireNumber = 3;
    const IS_CRUDE_ESTIMATE_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const AndroidWattsonTasksAttributionMetric = struct {
    // fields
    metric_version: i32 = 0,
    power_model_version: i32 = 0,
    period_info: ?[]const ?AndroidWattsonTaskPeriodInfo = null,
    is_crude_estimate: bool = false,
    pub fn calcProtobufSize(self: *const AndroidWattsonTasksAttributionMetric) usize {
        var res: usize = 0;
        if (self.metric_version != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonTasksAttributionMetricWire.METRIC_VERSION_WIRE) + gremlin.sizes.sizeI32(self.metric_version);
        }
        if (self.power_model_version != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonTasksAttributionMetricWire.POWER_MODEL_VERSION_WIRE) + gremlin.sizes.sizeI32(self.power_model_version);
        }
        if (self.period_info) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonTasksAttributionMetricWire.PERIOD_INFO_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.is_crude_estimate != false) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonTasksAttributionMetricWire.IS_CRUDE_ESTIMATE_WIRE) + gremlin.sizes.sizeBool(self.is_crude_estimate);
        }
        return res;
    }
    pub fn encode(self: *const AndroidWattsonTasksAttributionMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidWattsonTasksAttributionMetric, target: *gremlin.Writer) void {
        if (self.metric_version != 0) {
            target.appendInt32(AndroidWattsonTasksAttributionMetricWire.METRIC_VERSION_WIRE, self.metric_version);
        }
        if (self.power_model_version != 0) {
            target.appendInt32(AndroidWattsonTasksAttributionMetricWire.POWER_MODEL_VERSION_WIRE, self.power_model_version);
        }
        if (self.period_info) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidWattsonTasksAttributionMetricWire.PERIOD_INFO_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidWattsonTasksAttributionMetricWire.PERIOD_INFO_WIRE, 0);
                }
            }
        }
        if (self.is_crude_estimate != false) {
            target.appendBool(AndroidWattsonTasksAttributionMetricWire.IS_CRUDE_ESTIMATE_WIRE, self.is_crude_estimate);
        }
    }
};
pub const AndroidWattsonTasksAttributionMetricReader = struct {
    buf: gremlin.Reader,
    _metric_version: i32 = 0,
    _power_model_version: i32 = 0,
    _period_info_offset: ?usize = null,
    _period_info_last_offset: ?usize = null,
    _period_info_cnt: usize = 0,
    _is_crude_estimate: bool = false,
    pub fn init(src: []const u8) gremlin.Error!AndroidWattsonTasksAttributionMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidWattsonTasksAttributionMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidWattsonTasksAttributionMetricWire.METRIC_VERSION_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._metric_version = result.value;
                },
                AndroidWattsonTasksAttributionMetricWire.POWER_MODEL_VERSION_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._power_model_version = result.value;
                },
                AndroidWattsonTasksAttributionMetricWire.PERIOD_INFO_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._period_info_offset == null) {
                        res._period_info_offset = offset - result.size;
                    }
                    res._period_info_last_offset = offset;
                    res._period_info_cnt += 1;
                },
                AndroidWattsonTasksAttributionMetricWire.IS_CRUDE_ESTIMATE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_crude_estimate = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getMetricVersion(self: *const AndroidWattsonTasksAttributionMetricReader) i32 {
        return self._metric_version;
    }
    pub inline fn getPowerModelVersion(self: *const AndroidWattsonTasksAttributionMetricReader) i32 {
        return self._power_model_version;
    }
    pub fn periodInfoCount(self: *const AndroidWattsonTasksAttributionMetricReader) usize {
        return self._period_info_cnt;
    }
    pub fn periodInfoNext(self: *AndroidWattsonTasksAttributionMetricReader) ?AndroidWattsonTaskPeriodInfoReader {
        if (self._period_info_offset == null) return null;
        const current_offset = self._period_info_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidWattsonTaskPeriodInfoReader.init(result.value) catch return null;
        if (self._period_info_last_offset != null and current_offset >= self._period_info_last_offset.?) {
            self._period_info_offset = null;
            return msg;
        }
        if (self._period_info_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._period_info_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidWattsonTasksAttributionMetricWire.PERIOD_INFO_WIRE) {
                self._period_info_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._period_info_offset = null;
        return msg;
    }
    pub inline fn getIsCrudeEstimate(self: *const AndroidWattsonTasksAttributionMetricReader) bool {
        return self._is_crude_estimate;
    }
};
const AndroidWattsonTaskPeriodInfoWire = struct {
    const PERIOD_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const PERIOD_NAME_WIRE: gremlin.ProtoWireNumber = 2;
    const TASK_INFO_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const AndroidWattsonTaskPeriodInfo = struct {
    // fields
    period_id: i32 = 0,
    period_name: ?[]const u8 = null,
    task_info: ?[]const ?AndroidWattsonTaskInfo = null,
    pub fn calcProtobufSize(self: *const AndroidWattsonTaskPeriodInfo) usize {
        var res: usize = 0;
        if (self.period_id != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonTaskPeriodInfoWire.PERIOD_ID_WIRE) + gremlin.sizes.sizeI32(self.period_id);
        }
        if (self.period_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonTaskPeriodInfoWire.PERIOD_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.task_info) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonTaskPeriodInfoWire.TASK_INFO_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidWattsonTaskPeriodInfo, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidWattsonTaskPeriodInfo, target: *gremlin.Writer) void {
        if (self.period_id != 0) {
            target.appendInt32(AndroidWattsonTaskPeriodInfoWire.PERIOD_ID_WIRE, self.period_id);
        }
        if (self.period_name) |v| {
            if (v.len > 0) {
                target.appendBytes(AndroidWattsonTaskPeriodInfoWire.PERIOD_NAME_WIRE, v);
            }
        }
        if (self.task_info) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidWattsonTaskPeriodInfoWire.TASK_INFO_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidWattsonTaskPeriodInfoWire.TASK_INFO_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidWattsonTaskPeriodInfoReader = struct {
    buf: gremlin.Reader,
    _period_id: i32 = 0,
    _period_name: ?[]const u8 = null,
    _task_info_offset: ?usize = null,
    _task_info_last_offset: ?usize = null,
    _task_info_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidWattsonTaskPeriodInfoReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidWattsonTaskPeriodInfoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidWattsonTaskPeriodInfoWire.PERIOD_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._period_id = result.value;
                },
                AndroidWattsonTaskPeriodInfoWire.PERIOD_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._period_name = result.value;
                },
                AndroidWattsonTaskPeriodInfoWire.TASK_INFO_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._task_info_offset == null) {
                        res._task_info_offset = offset - result.size;
                    }
                    res._task_info_last_offset = offset;
                    res._task_info_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getPeriodId(self: *const AndroidWattsonTaskPeriodInfoReader) i32 {
        return self._period_id;
    }
    pub inline fn getPeriodName(self: *const AndroidWattsonTaskPeriodInfoReader) []const u8 {
        return self._period_name orelse &[_]u8{};
    }
    pub fn taskInfoCount(self: *const AndroidWattsonTaskPeriodInfoReader) usize {
        return self._task_info_cnt;
    }
    pub fn taskInfoNext(self: *AndroidWattsonTaskPeriodInfoReader) ?AndroidWattsonTaskInfoReader {
        if (self._task_info_offset == null) return null;
        const current_offset = self._task_info_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidWattsonTaskInfoReader.init(result.value) catch return null;
        if (self._task_info_last_offset != null and current_offset >= self._task_info_last_offset.?) {
            self._task_info_offset = null;
            return msg;
        }
        if (self._task_info_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._task_info_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidWattsonTaskPeriodInfoWire.TASK_INFO_WIRE) {
                self._task_info_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._task_info_offset = null;
        return msg;
    }
};
const AndroidWattsonTaskInfoWire = struct {
    const ESTIMATED_MW_WIRE: gremlin.ProtoWireNumber = 1;
    const ESTIMATED_MWS_WIRE: gremlin.ProtoWireNumber = 2;
    const IDLE_TRANSITIONS_MWS_WIRE: gremlin.ProtoWireNumber = 3;
    const TOTAL_MWS_WIRE: gremlin.ProtoWireNumber = 4;
    const THREAD_NAME_WIRE: gremlin.ProtoWireNumber = 5;
    const PROCESS_NAME_WIRE: gremlin.ProtoWireNumber = 6;
    const PACKAGE_NAME_WIRE: gremlin.ProtoWireNumber = 7;
    const THREAD_ID_WIRE: gremlin.ProtoWireNumber = 8;
    const PROCESS_ID_WIRE: gremlin.ProtoWireNumber = 9;
};
pub const AndroidWattsonTaskInfo = struct {
    // fields
    estimated_mw: f32 = 0.0,
    estimated_mws: f32 = 0.0,
    idle_transitions_mws: f32 = 0.0,
    total_mws: f32 = 0.0,
    thread_name: ?[]const u8 = null,
    process_name: ?[]const u8 = null,
    package_name: ?[]const u8 = null,
    thread_id: i32 = 0,
    process_id: i32 = 0,
    pub fn calcProtobufSize(self: *const AndroidWattsonTaskInfo) usize {
        var res: usize = 0;
        if (self.estimated_mw != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonTaskInfoWire.ESTIMATED_MW_WIRE) + gremlin.sizes.sizeFloat(self.estimated_mw);
        }
        if (self.estimated_mws != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonTaskInfoWire.ESTIMATED_MWS_WIRE) + gremlin.sizes.sizeFloat(self.estimated_mws);
        }
        if (self.idle_transitions_mws != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonTaskInfoWire.IDLE_TRANSITIONS_MWS_WIRE) + gremlin.sizes.sizeFloat(self.idle_transitions_mws);
        }
        if (self.total_mws != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonTaskInfoWire.TOTAL_MWS_WIRE) + gremlin.sizes.sizeFloat(self.total_mws);
        }
        if (self.thread_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonTaskInfoWire.THREAD_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.process_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonTaskInfoWire.PROCESS_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.package_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonTaskInfoWire.PACKAGE_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.thread_id != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonTaskInfoWire.THREAD_ID_WIRE) + gremlin.sizes.sizeI32(self.thread_id);
        }
        if (self.process_id != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonTaskInfoWire.PROCESS_ID_WIRE) + gremlin.sizes.sizeI32(self.process_id);
        }
        return res;
    }
    pub fn encode(self: *const AndroidWattsonTaskInfo, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidWattsonTaskInfo, target: *gremlin.Writer) void {
        if (self.estimated_mw != 0.0) {
            target.appendFloat32(AndroidWattsonTaskInfoWire.ESTIMATED_MW_WIRE, self.estimated_mw);
        }
        if (self.estimated_mws != 0.0) {
            target.appendFloat32(AndroidWattsonTaskInfoWire.ESTIMATED_MWS_WIRE, self.estimated_mws);
        }
        if (self.idle_transitions_mws != 0.0) {
            target.appendFloat32(AndroidWattsonTaskInfoWire.IDLE_TRANSITIONS_MWS_WIRE, self.idle_transitions_mws);
        }
        if (self.total_mws != 0.0) {
            target.appendFloat32(AndroidWattsonTaskInfoWire.TOTAL_MWS_WIRE, self.total_mws);
        }
        if (self.thread_name) |v| {
            if (v.len > 0) {
                target.appendBytes(AndroidWattsonTaskInfoWire.THREAD_NAME_WIRE, v);
            }
        }
        if (self.process_name) |v| {
            if (v.len > 0) {
                target.appendBytes(AndroidWattsonTaskInfoWire.PROCESS_NAME_WIRE, v);
            }
        }
        if (self.package_name) |v| {
            if (v.len > 0) {
                target.appendBytes(AndroidWattsonTaskInfoWire.PACKAGE_NAME_WIRE, v);
            }
        }
        if (self.thread_id != 0) {
            target.appendInt32(AndroidWattsonTaskInfoWire.THREAD_ID_WIRE, self.thread_id);
        }
        if (self.process_id != 0) {
            target.appendInt32(AndroidWattsonTaskInfoWire.PROCESS_ID_WIRE, self.process_id);
        }
    }
};
pub const AndroidWattsonTaskInfoReader = struct {
    buf: gremlin.Reader,
    _estimated_mw: f32 = 0.0,
    _estimated_mws: f32 = 0.0,
    _idle_transitions_mws: f32 = 0.0,
    _total_mws: f32 = 0.0,
    _thread_name: ?[]const u8 = null,
    _process_name: ?[]const u8 = null,
    _package_name: ?[]const u8 = null,
    _thread_id: i32 = 0,
    _process_id: i32 = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidWattsonTaskInfoReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidWattsonTaskInfoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidWattsonTaskInfoWire.ESTIMATED_MW_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._estimated_mw = result.value;
                },
                AndroidWattsonTaskInfoWire.ESTIMATED_MWS_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._estimated_mws = result.value;
                },
                AndroidWattsonTaskInfoWire.IDLE_TRANSITIONS_MWS_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._idle_transitions_mws = result.value;
                },
                AndroidWattsonTaskInfoWire.TOTAL_MWS_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._total_mws = result.value;
                },
                AndroidWattsonTaskInfoWire.THREAD_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._thread_name = result.value;
                },
                AndroidWattsonTaskInfoWire.PROCESS_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._process_name = result.value;
                },
                AndroidWattsonTaskInfoWire.PACKAGE_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._package_name = result.value;
                },
                AndroidWattsonTaskInfoWire.THREAD_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._thread_id = result.value;
                },
                AndroidWattsonTaskInfoWire.PROCESS_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._process_id = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getEstimatedMw(self: *const AndroidWattsonTaskInfoReader) f32 {
        return self._estimated_mw;
    }
    pub inline fn getEstimatedMws(self: *const AndroidWattsonTaskInfoReader) f32 {
        return self._estimated_mws;
    }
    pub inline fn getIdleTransitionsMws(self: *const AndroidWattsonTaskInfoReader) f32 {
        return self._idle_transitions_mws;
    }
    pub inline fn getTotalMws(self: *const AndroidWattsonTaskInfoReader) f32 {
        return self._total_mws;
    }
    pub inline fn getThreadName(self: *const AndroidWattsonTaskInfoReader) []const u8 {
        return self._thread_name orelse &[_]u8{};
    }
    pub inline fn getProcessName(self: *const AndroidWattsonTaskInfoReader) []const u8 {
        return self._process_name orelse &[_]u8{};
    }
    pub inline fn getPackageName(self: *const AndroidWattsonTaskInfoReader) []const u8 {
        return self._package_name orelse &[_]u8{};
    }
    pub inline fn getThreadId(self: *const AndroidWattsonTaskInfoReader) i32 {
        return self._thread_id;
    }
    pub inline fn getProcessId(self: *const AndroidWattsonTaskInfoReader) i32 {
        return self._process_id;
    }
};
