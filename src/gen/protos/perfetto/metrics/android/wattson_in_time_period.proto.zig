// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const AndroidWattsonTimePeriodMetricWire = struct {
    const METRIC_VERSION_WIRE: gremlin.ProtoWireNumber = 1;
    const POWER_MODEL_VERSION_WIRE: gremlin.ProtoWireNumber = 2;
    const PERIOD_INFO_WIRE: gremlin.ProtoWireNumber = 3;
    const IS_CRUDE_ESTIMATE_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const AndroidWattsonTimePeriodMetric = struct {
    // fields
    metric_version: i32 = 0,
    power_model_version: i32 = 0,
    period_info: ?[]const ?AndroidWattsonEstimateInfo = null,
    is_crude_estimate: bool = false,
    pub fn calcProtobufSize(self: *const AndroidWattsonTimePeriodMetric) usize {
        var res: usize = 0;
        if (self.metric_version != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonTimePeriodMetricWire.METRIC_VERSION_WIRE) + gremlin.sizes.sizeI32(self.metric_version);
        }
        if (self.power_model_version != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonTimePeriodMetricWire.POWER_MODEL_VERSION_WIRE) + gremlin.sizes.sizeI32(self.power_model_version);
        }
        if (self.period_info) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonTimePeriodMetricWire.PERIOD_INFO_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.is_crude_estimate != false) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonTimePeriodMetricWire.IS_CRUDE_ESTIMATE_WIRE) + gremlin.sizes.sizeBool(self.is_crude_estimate);
        }
        return res;
    }
    pub fn encode(self: *const AndroidWattsonTimePeriodMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidWattsonTimePeriodMetric, target: *gremlin.Writer) void {
        if (self.metric_version != 0) {
            target.appendInt32(AndroidWattsonTimePeriodMetricWire.METRIC_VERSION_WIRE, self.metric_version);
        }
        if (self.power_model_version != 0) {
            target.appendInt32(AndroidWattsonTimePeriodMetricWire.POWER_MODEL_VERSION_WIRE, self.power_model_version);
        }
        if (self.period_info) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidWattsonTimePeriodMetricWire.PERIOD_INFO_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidWattsonTimePeriodMetricWire.PERIOD_INFO_WIRE, 0);
                }
            }
        }
        if (self.is_crude_estimate != false) {
            target.appendBool(AndroidWattsonTimePeriodMetricWire.IS_CRUDE_ESTIMATE_WIRE, self.is_crude_estimate);
        }
    }
};
pub const AndroidWattsonTimePeriodMetricReader = struct {
    buf: gremlin.Reader,
    _metric_version: i32 = 0,
    _power_model_version: i32 = 0,
    _period_info_offset: ?usize = null,
    _period_info_last_offset: ?usize = null,
    _period_info_cnt: usize = 0,
    _is_crude_estimate: bool = false,
    pub fn init(src: []const u8) gremlin.Error!AndroidWattsonTimePeriodMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidWattsonTimePeriodMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidWattsonTimePeriodMetricWire.METRIC_VERSION_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._metric_version = result.value;
                },
                AndroidWattsonTimePeriodMetricWire.POWER_MODEL_VERSION_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._power_model_version = result.value;
                },
                AndroidWattsonTimePeriodMetricWire.PERIOD_INFO_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._period_info_offset == null) {
                        res._period_info_offset = offset - result.size;
                    }
                    res._period_info_last_offset = offset;
                    res._period_info_cnt += 1;
                },
                AndroidWattsonTimePeriodMetricWire.IS_CRUDE_ESTIMATE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._is_crude_estimate = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getMetricVersion(self: *const AndroidWattsonTimePeriodMetricReader) i32 {
        return self._metric_version;
    }
    pub inline fn getPowerModelVersion(self: *const AndroidWattsonTimePeriodMetricReader) i32 {
        return self._power_model_version;
    }
    pub fn periodInfoCount(self: *const AndroidWattsonTimePeriodMetricReader) usize {
        return self._period_info_cnt;
    }
    pub fn periodInfoNext(self: *AndroidWattsonTimePeriodMetricReader) ?AndroidWattsonEstimateInfoReader {
        if (self._period_info_offset == null) return null;
        const current_offset = self._period_info_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidWattsonEstimateInfoReader.init(result.value) catch return null;
        if (self._period_info_last_offset != null and current_offset >= self._period_info_last_offset.?) {
            self._period_info_offset = null;
            return msg;
        }
        if (self._period_info_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._period_info_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidWattsonTimePeriodMetricWire.PERIOD_INFO_WIRE) {
                self._period_info_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._period_info_offset = null;
        return msg;
    }
    pub inline fn getIsCrudeEstimate(self: *const AndroidWattsonTimePeriodMetricReader) bool {
        return self._is_crude_estimate;
    }
};
const AndroidWattsonEstimateInfoWire = struct {
    const PERIOD_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const PERIOD_NAME_WIRE: gremlin.ProtoWireNumber = 2;
    const PERIOD_DUR_WIRE: gremlin.ProtoWireNumber = 3;
    const CPU_SUBSYSTEM_WIRE: gremlin.ProtoWireNumber = 4;
    const GPU_SUBSYSTEM_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const AndroidWattsonEstimateInfo = struct {
    // fields
    period_id: i32 = 0,
    period_name: ?[]const u8 = null,
    period_dur: i64 = 0,
    cpu_subsystem: ?AndroidWattsonCpuSubsystemEstimate = null,
    gpu_subsystem: ?AndroidWattsonGpuSubsystemEstimate = null,
    pub fn calcProtobufSize(self: *const AndroidWattsonEstimateInfo) usize {
        var res: usize = 0;
        if (self.period_id != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonEstimateInfoWire.PERIOD_ID_WIRE) + gremlin.sizes.sizeI32(self.period_id);
        }
        if (self.period_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonEstimateInfoWire.PERIOD_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.period_dur != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonEstimateInfoWire.PERIOD_DUR_WIRE) + gremlin.sizes.sizeI64(self.period_dur);
        }
        if (self.cpu_subsystem) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonEstimateInfoWire.CPU_SUBSYSTEM_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.gpu_subsystem) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonEstimateInfoWire.GPU_SUBSYSTEM_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidWattsonEstimateInfo, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidWattsonEstimateInfo, target: *gremlin.Writer) void {
        if (self.period_id != 0) {
            target.appendInt32(AndroidWattsonEstimateInfoWire.PERIOD_ID_WIRE, self.period_id);
        }
        if (self.period_name) |v| {
            if (v.len > 0) {
                target.appendBytes(AndroidWattsonEstimateInfoWire.PERIOD_NAME_WIRE, v);
            }
        }
        if (self.period_dur != 0) {
            target.appendInt64(AndroidWattsonEstimateInfoWire.PERIOD_DUR_WIRE, self.period_dur);
        }
        if (self.cpu_subsystem) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidWattsonEstimateInfoWire.CPU_SUBSYSTEM_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.gpu_subsystem) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidWattsonEstimateInfoWire.GPU_SUBSYSTEM_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const AndroidWattsonEstimateInfoReader = struct {
    buf: gremlin.Reader,
    _period_id: i32 = 0,
    _period_name: ?[]const u8 = null,
    _period_dur: i64 = 0,
    _cpu_subsystem_buf: ?[]const u8 = null,
    _gpu_subsystem_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!AndroidWattsonEstimateInfoReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidWattsonEstimateInfoReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidWattsonEstimateInfoWire.PERIOD_ID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._period_id = result.value;
                },
                AndroidWattsonEstimateInfoWire.PERIOD_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._period_name = result.value;
                },
                AndroidWattsonEstimateInfoWire.PERIOD_DUR_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._period_dur = result.value;
                },
                AndroidWattsonEstimateInfoWire.CPU_SUBSYSTEM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cpu_subsystem_buf = result.value;
                },
                AndroidWattsonEstimateInfoWire.GPU_SUBSYSTEM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._gpu_subsystem_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getPeriodId(self: *const AndroidWattsonEstimateInfoReader) i32 {
        return self._period_id;
    }
    pub inline fn getPeriodName(self: *const AndroidWattsonEstimateInfoReader) []const u8 {
        return self._period_name orelse &[_]u8{};
    }
    pub inline fn getPeriodDur(self: *const AndroidWattsonEstimateInfoReader) i64 {
        return self._period_dur;
    }
    pub fn getCpuSubsystem(self: *const AndroidWattsonEstimateInfoReader) gremlin.Error!AndroidWattsonCpuSubsystemEstimateReader {
        if (self._cpu_subsystem_buf) |buf| {
            return try AndroidWattsonCpuSubsystemEstimateReader.init(buf);
        }
        return try AndroidWattsonCpuSubsystemEstimateReader.init(&[_]u8{});
    }
    pub fn getGpuSubsystem(self: *const AndroidWattsonEstimateInfoReader) gremlin.Error!AndroidWattsonGpuSubsystemEstimateReader {
        if (self._gpu_subsystem_buf) |buf| {
            return try AndroidWattsonGpuSubsystemEstimateReader.init(buf);
        }
        return try AndroidWattsonGpuSubsystemEstimateReader.init(&[_]u8{});
    }
};
const AndroidWattsonCpuSubsystemEstimateWire = struct {
    const ESTIMATED_MW_WIRE: gremlin.ProtoWireNumber = 1;
    const ESTIMATED_MWS_WIRE: gremlin.ProtoWireNumber = 2;
    const POLICY0_WIRE: gremlin.ProtoWireNumber = 3;
    const POLICY1_WIRE: gremlin.ProtoWireNumber = 4;
    const POLICY2_WIRE: gremlin.ProtoWireNumber = 5;
    const POLICY3_WIRE: gremlin.ProtoWireNumber = 6;
    const POLICY4_WIRE: gremlin.ProtoWireNumber = 7;
    const POLICY5_WIRE: gremlin.ProtoWireNumber = 8;
    const POLICY6_WIRE: gremlin.ProtoWireNumber = 9;
    const POLICY7_WIRE: gremlin.ProtoWireNumber = 10;
    const DSU_SCU_WIRE: gremlin.ProtoWireNumber = 11;
};
pub const AndroidWattsonCpuSubsystemEstimate = struct {
    // fields
    estimated_mw: f32 = 0.0,
    estimated_mws: f32 = 0.0,
    policy0: ?AndroidWattsonPolicyEstimate = null,
    policy1: ?AndroidWattsonPolicyEstimate = null,
    policy2: ?AndroidWattsonPolicyEstimate = null,
    policy3: ?AndroidWattsonPolicyEstimate = null,
    policy4: ?AndroidWattsonPolicyEstimate = null,
    policy5: ?AndroidWattsonPolicyEstimate = null,
    policy6: ?AndroidWattsonPolicyEstimate = null,
    policy7: ?AndroidWattsonPolicyEstimate = null,
    dsu_scu: ?AndroidWattsonDsuScuEstimate = null,
    pub fn calcProtobufSize(self: *const AndroidWattsonCpuSubsystemEstimate) usize {
        var res: usize = 0;
        if (self.estimated_mw != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonCpuSubsystemEstimateWire.ESTIMATED_MW_WIRE) + gremlin.sizes.sizeFloat(self.estimated_mw);
        }
        if (self.estimated_mws != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonCpuSubsystemEstimateWire.ESTIMATED_MWS_WIRE) + gremlin.sizes.sizeFloat(self.estimated_mws);
        }
        if (self.policy0) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonCpuSubsystemEstimateWire.POLICY0_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.policy1) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonCpuSubsystemEstimateWire.POLICY1_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.policy2) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonCpuSubsystemEstimateWire.POLICY2_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.policy3) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonCpuSubsystemEstimateWire.POLICY3_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.policy4) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonCpuSubsystemEstimateWire.POLICY4_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.policy5) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonCpuSubsystemEstimateWire.POLICY5_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.policy6) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonCpuSubsystemEstimateWire.POLICY6_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.policy7) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonCpuSubsystemEstimateWire.POLICY7_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.dsu_scu) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonCpuSubsystemEstimateWire.DSU_SCU_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidWattsonCpuSubsystemEstimate, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidWattsonCpuSubsystemEstimate, target: *gremlin.Writer) void {
        if (self.estimated_mw != 0.0) {
            target.appendFloat32(AndroidWattsonCpuSubsystemEstimateWire.ESTIMATED_MW_WIRE, self.estimated_mw);
        }
        if (self.estimated_mws != 0.0) {
            target.appendFloat32(AndroidWattsonCpuSubsystemEstimateWire.ESTIMATED_MWS_WIRE, self.estimated_mws);
        }
        if (self.policy0) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidWattsonCpuSubsystemEstimateWire.POLICY0_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.policy1) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidWattsonCpuSubsystemEstimateWire.POLICY1_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.policy2) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidWattsonCpuSubsystemEstimateWire.POLICY2_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.policy3) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidWattsonCpuSubsystemEstimateWire.POLICY3_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.policy4) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidWattsonCpuSubsystemEstimateWire.POLICY4_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.policy5) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidWattsonCpuSubsystemEstimateWire.POLICY5_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.policy6) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidWattsonCpuSubsystemEstimateWire.POLICY6_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.policy7) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidWattsonCpuSubsystemEstimateWire.POLICY7_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.dsu_scu) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidWattsonCpuSubsystemEstimateWire.DSU_SCU_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const AndroidWattsonCpuSubsystemEstimateReader = struct {
    buf: gremlin.Reader,
    _estimated_mw: f32 = 0.0,
    _estimated_mws: f32 = 0.0,
    _policy0_buf: ?[]const u8 = null,
    _policy1_buf: ?[]const u8 = null,
    _policy2_buf: ?[]const u8 = null,
    _policy3_buf: ?[]const u8 = null,
    _policy4_buf: ?[]const u8 = null,
    _policy5_buf: ?[]const u8 = null,
    _policy6_buf: ?[]const u8 = null,
    _policy7_buf: ?[]const u8 = null,
    _dsu_scu_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!AndroidWattsonCpuSubsystemEstimateReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidWattsonCpuSubsystemEstimateReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidWattsonCpuSubsystemEstimateWire.ESTIMATED_MW_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._estimated_mw = result.value;
                },
                AndroidWattsonCpuSubsystemEstimateWire.ESTIMATED_MWS_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._estimated_mws = result.value;
                },
                AndroidWattsonCpuSubsystemEstimateWire.POLICY0_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._policy0_buf = result.value;
                },
                AndroidWattsonCpuSubsystemEstimateWire.POLICY1_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._policy1_buf = result.value;
                },
                AndroidWattsonCpuSubsystemEstimateWire.POLICY2_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._policy2_buf = result.value;
                },
                AndroidWattsonCpuSubsystemEstimateWire.POLICY3_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._policy3_buf = result.value;
                },
                AndroidWattsonCpuSubsystemEstimateWire.POLICY4_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._policy4_buf = result.value;
                },
                AndroidWattsonCpuSubsystemEstimateWire.POLICY5_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._policy5_buf = result.value;
                },
                AndroidWattsonCpuSubsystemEstimateWire.POLICY6_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._policy6_buf = result.value;
                },
                AndroidWattsonCpuSubsystemEstimateWire.POLICY7_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._policy7_buf = result.value;
                },
                AndroidWattsonCpuSubsystemEstimateWire.DSU_SCU_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dsu_scu_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getEstimatedMw(self: *const AndroidWattsonCpuSubsystemEstimateReader) f32 {
        return self._estimated_mw;
    }
    pub inline fn getEstimatedMws(self: *const AndroidWattsonCpuSubsystemEstimateReader) f32 {
        return self._estimated_mws;
    }
    pub fn getPolicy0(self: *const AndroidWattsonCpuSubsystemEstimateReader) gremlin.Error!AndroidWattsonPolicyEstimateReader {
        if (self._policy0_buf) |buf| {
            return try AndroidWattsonPolicyEstimateReader.init(buf);
        }
        return try AndroidWattsonPolicyEstimateReader.init(&[_]u8{});
    }
    pub fn getPolicy1(self: *const AndroidWattsonCpuSubsystemEstimateReader) gremlin.Error!AndroidWattsonPolicyEstimateReader {
        if (self._policy1_buf) |buf| {
            return try AndroidWattsonPolicyEstimateReader.init(buf);
        }
        return try AndroidWattsonPolicyEstimateReader.init(&[_]u8{});
    }
    pub fn getPolicy2(self: *const AndroidWattsonCpuSubsystemEstimateReader) gremlin.Error!AndroidWattsonPolicyEstimateReader {
        if (self._policy2_buf) |buf| {
            return try AndroidWattsonPolicyEstimateReader.init(buf);
        }
        return try AndroidWattsonPolicyEstimateReader.init(&[_]u8{});
    }
    pub fn getPolicy3(self: *const AndroidWattsonCpuSubsystemEstimateReader) gremlin.Error!AndroidWattsonPolicyEstimateReader {
        if (self._policy3_buf) |buf| {
            return try AndroidWattsonPolicyEstimateReader.init(buf);
        }
        return try AndroidWattsonPolicyEstimateReader.init(&[_]u8{});
    }
    pub fn getPolicy4(self: *const AndroidWattsonCpuSubsystemEstimateReader) gremlin.Error!AndroidWattsonPolicyEstimateReader {
        if (self._policy4_buf) |buf| {
            return try AndroidWattsonPolicyEstimateReader.init(buf);
        }
        return try AndroidWattsonPolicyEstimateReader.init(&[_]u8{});
    }
    pub fn getPolicy5(self: *const AndroidWattsonCpuSubsystemEstimateReader) gremlin.Error!AndroidWattsonPolicyEstimateReader {
        if (self._policy5_buf) |buf| {
            return try AndroidWattsonPolicyEstimateReader.init(buf);
        }
        return try AndroidWattsonPolicyEstimateReader.init(&[_]u8{});
    }
    pub fn getPolicy6(self: *const AndroidWattsonCpuSubsystemEstimateReader) gremlin.Error!AndroidWattsonPolicyEstimateReader {
        if (self._policy6_buf) |buf| {
            return try AndroidWattsonPolicyEstimateReader.init(buf);
        }
        return try AndroidWattsonPolicyEstimateReader.init(&[_]u8{});
    }
    pub fn getPolicy7(self: *const AndroidWattsonCpuSubsystemEstimateReader) gremlin.Error!AndroidWattsonPolicyEstimateReader {
        if (self._policy7_buf) |buf| {
            return try AndroidWattsonPolicyEstimateReader.init(buf);
        }
        return try AndroidWattsonPolicyEstimateReader.init(&[_]u8{});
    }
    pub fn getDsuScu(self: *const AndroidWattsonCpuSubsystemEstimateReader) gremlin.Error!AndroidWattsonDsuScuEstimateReader {
        if (self._dsu_scu_buf) |buf| {
            return try AndroidWattsonDsuScuEstimateReader.init(buf);
        }
        return try AndroidWattsonDsuScuEstimateReader.init(&[_]u8{});
    }
};
const AndroidWattsonPolicyEstimateWire = struct {
    const ESTIMATED_MW_WIRE: gremlin.ProtoWireNumber = 1;
    const ESTIMATED_MWS_WIRE: gremlin.ProtoWireNumber = 2;
    const CPU0_WIRE: gremlin.ProtoWireNumber = 3;
    const CPU1_WIRE: gremlin.ProtoWireNumber = 4;
    const CPU2_WIRE: gremlin.ProtoWireNumber = 5;
    const CPU3_WIRE: gremlin.ProtoWireNumber = 6;
    const CPU4_WIRE: gremlin.ProtoWireNumber = 7;
    const CPU5_WIRE: gremlin.ProtoWireNumber = 8;
    const CPU6_WIRE: gremlin.ProtoWireNumber = 9;
    const CPU7_WIRE: gremlin.ProtoWireNumber = 10;
};
pub const AndroidWattsonPolicyEstimate = struct {
    // fields
    estimated_mw: f32 = 0.0,
    estimated_mws: f32 = 0.0,
    cpu0: ?AndroidWattsonCpuEstimate = null,
    cpu1: ?AndroidWattsonCpuEstimate = null,
    cpu2: ?AndroidWattsonCpuEstimate = null,
    cpu3: ?AndroidWattsonCpuEstimate = null,
    cpu4: ?AndroidWattsonCpuEstimate = null,
    cpu5: ?AndroidWattsonCpuEstimate = null,
    cpu6: ?AndroidWattsonCpuEstimate = null,
    cpu7: ?AndroidWattsonCpuEstimate = null,
    pub fn calcProtobufSize(self: *const AndroidWattsonPolicyEstimate) usize {
        var res: usize = 0;
        if (self.estimated_mw != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonPolicyEstimateWire.ESTIMATED_MW_WIRE) + gremlin.sizes.sizeFloat(self.estimated_mw);
        }
        if (self.estimated_mws != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonPolicyEstimateWire.ESTIMATED_MWS_WIRE) + gremlin.sizes.sizeFloat(self.estimated_mws);
        }
        if (self.cpu0) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonPolicyEstimateWire.CPU0_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cpu1) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonPolicyEstimateWire.CPU1_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cpu2) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonPolicyEstimateWire.CPU2_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cpu3) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonPolicyEstimateWire.CPU3_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cpu4) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonPolicyEstimateWire.CPU4_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cpu5) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonPolicyEstimateWire.CPU5_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cpu6) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonPolicyEstimateWire.CPU6_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cpu7) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidWattsonPolicyEstimateWire.CPU7_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidWattsonPolicyEstimate, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidWattsonPolicyEstimate, target: *gremlin.Writer) void {
        if (self.estimated_mw != 0.0) {
            target.appendFloat32(AndroidWattsonPolicyEstimateWire.ESTIMATED_MW_WIRE, self.estimated_mw);
        }
        if (self.estimated_mws != 0.0) {
            target.appendFloat32(AndroidWattsonPolicyEstimateWire.ESTIMATED_MWS_WIRE, self.estimated_mws);
        }
        if (self.cpu0) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidWattsonPolicyEstimateWire.CPU0_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cpu1) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidWattsonPolicyEstimateWire.CPU1_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cpu2) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidWattsonPolicyEstimateWire.CPU2_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cpu3) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidWattsonPolicyEstimateWire.CPU3_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cpu4) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidWattsonPolicyEstimateWire.CPU4_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cpu5) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidWattsonPolicyEstimateWire.CPU5_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cpu6) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidWattsonPolicyEstimateWire.CPU6_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cpu7) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidWattsonPolicyEstimateWire.CPU7_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const AndroidWattsonPolicyEstimateReader = struct {
    buf: gremlin.Reader,
    _estimated_mw: f32 = 0.0,
    _estimated_mws: f32 = 0.0,
    _cpu0_buf: ?[]const u8 = null,
    _cpu1_buf: ?[]const u8 = null,
    _cpu2_buf: ?[]const u8 = null,
    _cpu3_buf: ?[]const u8 = null,
    _cpu4_buf: ?[]const u8 = null,
    _cpu5_buf: ?[]const u8 = null,
    _cpu6_buf: ?[]const u8 = null,
    _cpu7_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!AndroidWattsonPolicyEstimateReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidWattsonPolicyEstimateReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidWattsonPolicyEstimateWire.ESTIMATED_MW_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._estimated_mw = result.value;
                },
                AndroidWattsonPolicyEstimateWire.ESTIMATED_MWS_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._estimated_mws = result.value;
                },
                AndroidWattsonPolicyEstimateWire.CPU0_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cpu0_buf = result.value;
                },
                AndroidWattsonPolicyEstimateWire.CPU1_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cpu1_buf = result.value;
                },
                AndroidWattsonPolicyEstimateWire.CPU2_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cpu2_buf = result.value;
                },
                AndroidWattsonPolicyEstimateWire.CPU3_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cpu3_buf = result.value;
                },
                AndroidWattsonPolicyEstimateWire.CPU4_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cpu4_buf = result.value;
                },
                AndroidWattsonPolicyEstimateWire.CPU5_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cpu5_buf = result.value;
                },
                AndroidWattsonPolicyEstimateWire.CPU6_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cpu6_buf = result.value;
                },
                AndroidWattsonPolicyEstimateWire.CPU7_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cpu7_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getEstimatedMw(self: *const AndroidWattsonPolicyEstimateReader) f32 {
        return self._estimated_mw;
    }
    pub inline fn getEstimatedMws(self: *const AndroidWattsonPolicyEstimateReader) f32 {
        return self._estimated_mws;
    }
    pub fn getCpu0(self: *const AndroidWattsonPolicyEstimateReader) gremlin.Error!AndroidWattsonCpuEstimateReader {
        if (self._cpu0_buf) |buf| {
            return try AndroidWattsonCpuEstimateReader.init(buf);
        }
        return try AndroidWattsonCpuEstimateReader.init(&[_]u8{});
    }
    pub fn getCpu1(self: *const AndroidWattsonPolicyEstimateReader) gremlin.Error!AndroidWattsonCpuEstimateReader {
        if (self._cpu1_buf) |buf| {
            return try AndroidWattsonCpuEstimateReader.init(buf);
        }
        return try AndroidWattsonCpuEstimateReader.init(&[_]u8{});
    }
    pub fn getCpu2(self: *const AndroidWattsonPolicyEstimateReader) gremlin.Error!AndroidWattsonCpuEstimateReader {
        if (self._cpu2_buf) |buf| {
            return try AndroidWattsonCpuEstimateReader.init(buf);
        }
        return try AndroidWattsonCpuEstimateReader.init(&[_]u8{});
    }
    pub fn getCpu3(self: *const AndroidWattsonPolicyEstimateReader) gremlin.Error!AndroidWattsonCpuEstimateReader {
        if (self._cpu3_buf) |buf| {
            return try AndroidWattsonCpuEstimateReader.init(buf);
        }
        return try AndroidWattsonCpuEstimateReader.init(&[_]u8{});
    }
    pub fn getCpu4(self: *const AndroidWattsonPolicyEstimateReader) gremlin.Error!AndroidWattsonCpuEstimateReader {
        if (self._cpu4_buf) |buf| {
            return try AndroidWattsonCpuEstimateReader.init(buf);
        }
        return try AndroidWattsonCpuEstimateReader.init(&[_]u8{});
    }
    pub fn getCpu5(self: *const AndroidWattsonPolicyEstimateReader) gremlin.Error!AndroidWattsonCpuEstimateReader {
        if (self._cpu5_buf) |buf| {
            return try AndroidWattsonCpuEstimateReader.init(buf);
        }
        return try AndroidWattsonCpuEstimateReader.init(&[_]u8{});
    }
    pub fn getCpu6(self: *const AndroidWattsonPolicyEstimateReader) gremlin.Error!AndroidWattsonCpuEstimateReader {
        if (self._cpu6_buf) |buf| {
            return try AndroidWattsonCpuEstimateReader.init(buf);
        }
        return try AndroidWattsonCpuEstimateReader.init(&[_]u8{});
    }
    pub fn getCpu7(self: *const AndroidWattsonPolicyEstimateReader) gremlin.Error!AndroidWattsonCpuEstimateReader {
        if (self._cpu7_buf) |buf| {
            return try AndroidWattsonCpuEstimateReader.init(buf);
        }
        return try AndroidWattsonCpuEstimateReader.init(&[_]u8{});
    }
};
const AndroidWattsonCpuEstimateWire = struct {
    const ESTIMATED_MW_WIRE: gremlin.ProtoWireNumber = 1;
    const ESTIMATED_MWS_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const AndroidWattsonCpuEstimate = struct {
    // fields
    estimated_mw: f32 = 0.0,
    estimated_mws: f32 = 0.0,
    pub fn calcProtobufSize(self: *const AndroidWattsonCpuEstimate) usize {
        var res: usize = 0;
        if (self.estimated_mw != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonCpuEstimateWire.ESTIMATED_MW_WIRE) + gremlin.sizes.sizeFloat(self.estimated_mw);
        }
        if (self.estimated_mws != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonCpuEstimateWire.ESTIMATED_MWS_WIRE) + gremlin.sizes.sizeFloat(self.estimated_mws);
        }
        return res;
    }
    pub fn encode(self: *const AndroidWattsonCpuEstimate, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidWattsonCpuEstimate, target: *gremlin.Writer) void {
        if (self.estimated_mw != 0.0) {
            target.appendFloat32(AndroidWattsonCpuEstimateWire.ESTIMATED_MW_WIRE, self.estimated_mw);
        }
        if (self.estimated_mws != 0.0) {
            target.appendFloat32(AndroidWattsonCpuEstimateWire.ESTIMATED_MWS_WIRE, self.estimated_mws);
        }
    }
};
pub const AndroidWattsonCpuEstimateReader = struct {
    buf: gremlin.Reader,
    _estimated_mw: f32 = 0.0,
    _estimated_mws: f32 = 0.0,
    pub fn init(src: []const u8) gremlin.Error!AndroidWattsonCpuEstimateReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidWattsonCpuEstimateReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidWattsonCpuEstimateWire.ESTIMATED_MW_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._estimated_mw = result.value;
                },
                AndroidWattsonCpuEstimateWire.ESTIMATED_MWS_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._estimated_mws = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getEstimatedMw(self: *const AndroidWattsonCpuEstimateReader) f32 {
        return self._estimated_mw;
    }
    pub inline fn getEstimatedMws(self: *const AndroidWattsonCpuEstimateReader) f32 {
        return self._estimated_mws;
    }
};
const AndroidWattsonDsuScuEstimateWire = struct {
    const ESTIMATED_MW_WIRE: gremlin.ProtoWireNumber = 1;
    const ESTIMATED_MWS_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const AndroidWattsonDsuScuEstimate = struct {
    // fields
    estimated_mw: f32 = 0.0,
    estimated_mws: f32 = 0.0,
    pub fn calcProtobufSize(self: *const AndroidWattsonDsuScuEstimate) usize {
        var res: usize = 0;
        if (self.estimated_mw != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonDsuScuEstimateWire.ESTIMATED_MW_WIRE) + gremlin.sizes.sizeFloat(self.estimated_mw);
        }
        if (self.estimated_mws != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonDsuScuEstimateWire.ESTIMATED_MWS_WIRE) + gremlin.sizes.sizeFloat(self.estimated_mws);
        }
        return res;
    }
    pub fn encode(self: *const AndroidWattsonDsuScuEstimate, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidWattsonDsuScuEstimate, target: *gremlin.Writer) void {
        if (self.estimated_mw != 0.0) {
            target.appendFloat32(AndroidWattsonDsuScuEstimateWire.ESTIMATED_MW_WIRE, self.estimated_mw);
        }
        if (self.estimated_mws != 0.0) {
            target.appendFloat32(AndroidWattsonDsuScuEstimateWire.ESTIMATED_MWS_WIRE, self.estimated_mws);
        }
    }
};
pub const AndroidWattsonDsuScuEstimateReader = struct {
    buf: gremlin.Reader,
    _estimated_mw: f32 = 0.0,
    _estimated_mws: f32 = 0.0,
    pub fn init(src: []const u8) gremlin.Error!AndroidWattsonDsuScuEstimateReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidWattsonDsuScuEstimateReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidWattsonDsuScuEstimateWire.ESTIMATED_MW_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._estimated_mw = result.value;
                },
                AndroidWattsonDsuScuEstimateWire.ESTIMATED_MWS_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._estimated_mws = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getEstimatedMw(self: *const AndroidWattsonDsuScuEstimateReader) f32 {
        return self._estimated_mw;
    }
    pub inline fn getEstimatedMws(self: *const AndroidWattsonDsuScuEstimateReader) f32 {
        return self._estimated_mws;
    }
};
const AndroidWattsonGpuSubsystemEstimateWire = struct {
    const ESTIMATED_MW_WIRE: gremlin.ProtoWireNumber = 1;
    const ESTIMATED_MWS_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const AndroidWattsonGpuSubsystemEstimate = struct {
    // fields
    estimated_mw: f32 = 0.0,
    estimated_mws: f32 = 0.0,
    pub fn calcProtobufSize(self: *const AndroidWattsonGpuSubsystemEstimate) usize {
        var res: usize = 0;
        if (self.estimated_mw != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonGpuSubsystemEstimateWire.ESTIMATED_MW_WIRE) + gremlin.sizes.sizeFloat(self.estimated_mw);
        }
        if (self.estimated_mws != 0.0) {
            res += gremlin.sizes.sizeWireNumber(AndroidWattsonGpuSubsystemEstimateWire.ESTIMATED_MWS_WIRE) + gremlin.sizes.sizeFloat(self.estimated_mws);
        }
        return res;
    }
    pub fn encode(self: *const AndroidWattsonGpuSubsystemEstimate, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidWattsonGpuSubsystemEstimate, target: *gremlin.Writer) void {
        if (self.estimated_mw != 0.0) {
            target.appendFloat32(AndroidWattsonGpuSubsystemEstimateWire.ESTIMATED_MW_WIRE, self.estimated_mw);
        }
        if (self.estimated_mws != 0.0) {
            target.appendFloat32(AndroidWattsonGpuSubsystemEstimateWire.ESTIMATED_MWS_WIRE, self.estimated_mws);
        }
    }
};
pub const AndroidWattsonGpuSubsystemEstimateReader = struct {
    buf: gremlin.Reader,
    _estimated_mw: f32 = 0.0,
    _estimated_mws: f32 = 0.0,
    pub fn init(src: []const u8) gremlin.Error!AndroidWattsonGpuSubsystemEstimateReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidWattsonGpuSubsystemEstimateReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidWattsonGpuSubsystemEstimateWire.ESTIMATED_MW_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._estimated_mw = result.value;
                },
                AndroidWattsonGpuSubsystemEstimateWire.ESTIMATED_MWS_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._estimated_mws = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getEstimatedMw(self: *const AndroidWattsonGpuSubsystemEstimateReader) f32 {
        return self._estimated_mw;
    }
    pub inline fn getEstimatedMws(self: *const AndroidWattsonGpuSubsystemEstimateReader) f32 {
        return self._estimated_mws;
    }
};
