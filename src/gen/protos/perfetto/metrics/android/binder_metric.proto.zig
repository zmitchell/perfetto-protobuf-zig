// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const AndroidBinderMetricWire = struct {
    const PROCESS_BREAKDOWN_WIRE: gremlin.ProtoWireNumber = 1;
    const UNAGGREGATED_TXN_BREAKDOWN_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const AndroidBinderMetric = struct {
    // nested structs
    const PerProcessBreakdownWire = struct {
        const PROCESS_NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const PID_WIRE: gremlin.ProtoWireNumber = 2;
        const SLICE_NAME_WIRE: gremlin.ProtoWireNumber = 3;
        const COUNT_WIRE: gremlin.ProtoWireNumber = 4;
    };
    pub const PerProcessBreakdown = struct {
        // fields
        process_name: ?[]const u8 = null,
        pid: u32 = 0,
        slice_name: ?[]const u8 = null,
        count: u32 = 0,
        pub fn calcProtobufSize(self: *const AndroidBinderMetric.PerProcessBreakdown) usize {
            var res: usize = 0;
            if (self.process_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.PerProcessBreakdownWire.PROCESS_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.pid != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.PerProcessBreakdownWire.PID_WIRE) + gremlin.sizes.sizeU32(self.pid);
            }
            if (self.slice_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.PerProcessBreakdownWire.SLICE_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.PerProcessBreakdownWire.COUNT_WIRE) + gremlin.sizes.sizeU32(self.count);
            }
            return res;
        }
        pub fn encode(self: *const AndroidBinderMetric.PerProcessBreakdown, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidBinderMetric.PerProcessBreakdown, target: *gremlin.Writer) void {
            if (self.process_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidBinderMetric.PerProcessBreakdownWire.PROCESS_NAME_WIRE, v);
                }
            }
            if (self.pid != 0) {
                target.appendUint32(AndroidBinderMetric.PerProcessBreakdownWire.PID_WIRE, self.pid);
            }
            if (self.slice_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidBinderMetric.PerProcessBreakdownWire.SLICE_NAME_WIRE, v);
                }
            }
            if (self.count != 0) {
                target.appendUint32(AndroidBinderMetric.PerProcessBreakdownWire.COUNT_WIRE, self.count);
            }
        }
    };
    pub const PerProcessBreakdownReader = struct {
        buf: gremlin.Reader,
        _process_name: ?[]const u8 = null,
        _pid: u32 = 0,
        _slice_name: ?[]const u8 = null,
        _count: u32 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidBinderMetric.PerProcessBreakdownReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidBinderMetric.PerProcessBreakdownReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidBinderMetric.PerProcessBreakdownWire.PROCESS_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._process_name = result.value;
                    },
                    AndroidBinderMetric.PerProcessBreakdownWire.PID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._pid = result.value;
                    },
                    AndroidBinderMetric.PerProcessBreakdownWire.SLICE_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._slice_name = result.value;
                    },
                    AndroidBinderMetric.PerProcessBreakdownWire.COUNT_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._count = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getProcessName(self: *const AndroidBinderMetric.PerProcessBreakdownReader) []const u8 {
            return self._process_name orelse &[_]u8{};
        }
        pub inline fn getPid(self: *const AndroidBinderMetric.PerProcessBreakdownReader) u32 {
            return self._pid;
        }
        pub inline fn getSliceName(self: *const AndroidBinderMetric.PerProcessBreakdownReader) []const u8 {
            return self._slice_name orelse &[_]u8{};
        }
        pub inline fn getCount(self: *const AndroidBinderMetric.PerProcessBreakdownReader) u32 {
            return self._count;
        }
    };
    const UnaggregatedTxnBreakdownWire = struct {
        const AIDL_NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const AIDL_TS_WIRE: gremlin.ProtoWireNumber = 22;
        const AIDL_DUR_WIRE: gremlin.ProtoWireNumber = 23;
        const IS_SYNC_WIRE: gremlin.ProtoWireNumber = 21;
        const CLIENT_PROCESS_WIRE: gremlin.ProtoWireNumber = 3;
        const CLIENT_THREAD_WIRE: gremlin.ProtoWireNumber = 4;
        const IS_MAIN_THREAD_WIRE: gremlin.ProtoWireNumber = 5;
        const CLIENT_TS_WIRE: gremlin.ProtoWireNumber = 6;
        const CLIENT_DUR_WIRE: gremlin.ProtoWireNumber = 7;
        const CLIENT_MONOTONIC_DUR_WIRE: gremlin.ProtoWireNumber = 28;
        const CLIENT_OOM_SCORE_WIRE: gremlin.ProtoWireNumber = 19;
        const CLIENT_PACKAGE_VERSION_CODE_WIRE: gremlin.ProtoWireNumber = 24;
        const IS_CLIENT_PACKAGE_DEBUGGABLE_WIRE: gremlin.ProtoWireNumber = 25;
        const SERVER_PROCESS_WIRE: gremlin.ProtoWireNumber = 9;
        const SERVER_THREAD_WIRE: gremlin.ProtoWireNumber = 10;
        const SERVER_TS_WIRE: gremlin.ProtoWireNumber = 11;
        const SERVER_DUR_WIRE: gremlin.ProtoWireNumber = 12;
        const SERVER_MONOTONIC_DUR_WIRE: gremlin.ProtoWireNumber = 29;
        const SERVER_OOM_SCORE_WIRE: gremlin.ProtoWireNumber = 20;
        const SERVER_PACKAGE_VERSION_CODE_WIRE: gremlin.ProtoWireNumber = 26;
        const IS_SERVER_PACKAGE_DEBUGGABLE_WIRE: gremlin.ProtoWireNumber = 27;
        const THREAD_STATES_WIRE: gremlin.ProtoWireNumber = 13;
        const BLOCKED_FUNCTIONS_WIRE: gremlin.ProtoWireNumber = 14;
        const LOGICAL_REASONS_WIRE: gremlin.ProtoWireNumber = 31;
        const CLIENT_TID_WIRE: gremlin.ProtoWireNumber = 15;
        const SERVER_TID_WIRE: gremlin.ProtoWireNumber = 16;
        const CLIENT_PID_WIRE: gremlin.ProtoWireNumber = 17;
        const SERVER_PID_WIRE: gremlin.ProtoWireNumber = 18;
    };
    pub const UnaggregatedTxnBreakdown = struct {
        // fields
        aidl_name: ?[]const u8 = null,
        aidl_ts: i64 = 0,
        aidl_dur: i64 = 0,
        is_sync: bool = false,
        client_process: ?[]const u8 = null,
        client_thread: ?[]const u8 = null,
        is_main_thread: bool = false,
        client_ts: i64 = 0,
        client_dur: i64 = 0,
        client_monotonic_dur: i64 = 0,
        client_oom_score: i64 = 0,
        client_package_version_code: i64 = 0,
        is_client_package_debuggable: bool = false,
        server_process: ?[]const u8 = null,
        server_thread: ?[]const u8 = null,
        server_ts: i64 = 0,
        server_dur: i64 = 0,
        server_monotonic_dur: i64 = 0,
        server_oom_score: i64 = 0,
        server_package_version_code: i64 = 0,
        is_server_package_debuggable: bool = false,
        thread_states: ?[]const ?AndroidBinderMetric.ThreadStateBreakdown = null,
        blocked_functions: ?[]const ?AndroidBinderMetric.BlockedFunctionBreakdown = null,
        logical_reasons: ?[]const ?AndroidBinderMetric.LogicalReasonBreakdown = null,
        client_tid: u32 = 0,
        server_tid: u32 = 0,
        client_pid: u32 = 0,
        server_pid: u32 = 0,
        pub fn calcProtobufSize(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdown) usize {
            var res: usize = 0;
            if (self.aidl_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.AIDL_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.aidl_ts != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.AIDL_TS_WIRE) + gremlin.sizes.sizeI64(self.aidl_ts);
            }
            if (self.aidl_dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.AIDL_DUR_WIRE) + gremlin.sizes.sizeI64(self.aidl_dur);
            }
            if (self.is_sync != false) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.IS_SYNC_WIRE) + gremlin.sizes.sizeBool(self.is_sync);
            }
            if (self.client_process) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_PROCESS_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.client_thread) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_THREAD_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.is_main_thread != false) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.IS_MAIN_THREAD_WIRE) + gremlin.sizes.sizeBool(self.is_main_thread);
            }
            if (self.client_ts != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_TS_WIRE) + gremlin.sizes.sizeI64(self.client_ts);
            }
            if (self.client_dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_DUR_WIRE) + gremlin.sizes.sizeI64(self.client_dur);
            }
            if (self.client_monotonic_dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_MONOTONIC_DUR_WIRE) + gremlin.sizes.sizeI64(self.client_monotonic_dur);
            }
            if (self.client_oom_score != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_OOM_SCORE_WIRE) + gremlin.sizes.sizeI64(self.client_oom_score);
            }
            if (self.client_package_version_code != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_PACKAGE_VERSION_CODE_WIRE) + gremlin.sizes.sizeI64(self.client_package_version_code);
            }
            if (self.is_client_package_debuggable != false) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.IS_CLIENT_PACKAGE_DEBUGGABLE_WIRE) + gremlin.sizes.sizeBool(self.is_client_package_debuggable);
            }
            if (self.server_process) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_PROCESS_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.server_thread) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_THREAD_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.server_ts != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_TS_WIRE) + gremlin.sizes.sizeI64(self.server_ts);
            }
            if (self.server_dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_DUR_WIRE) + gremlin.sizes.sizeI64(self.server_dur);
            }
            if (self.server_monotonic_dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_MONOTONIC_DUR_WIRE) + gremlin.sizes.sizeI64(self.server_monotonic_dur);
            }
            if (self.server_oom_score != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_OOM_SCORE_WIRE) + gremlin.sizes.sizeI64(self.server_oom_score);
            }
            if (self.server_package_version_code != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_PACKAGE_VERSION_CODE_WIRE) + gremlin.sizes.sizeI64(self.server_package_version_code);
            }
            if (self.is_server_package_debuggable != false) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.IS_SERVER_PACKAGE_DEBUGGABLE_WIRE) + gremlin.sizes.sizeBool(self.is_server_package_debuggable);
            }
            if (self.thread_states) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.THREAD_STATES_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.blocked_functions) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.BLOCKED_FUNCTIONS_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.logical_reasons) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.LOGICAL_REASONS_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.client_tid != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_TID_WIRE) + gremlin.sizes.sizeU32(self.client_tid);
            }
            if (self.server_tid != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_TID_WIRE) + gremlin.sizes.sizeU32(self.server_tid);
            }
            if (self.client_pid != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_PID_WIRE) + gremlin.sizes.sizeU32(self.client_pid);
            }
            if (self.server_pid != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_PID_WIRE) + gremlin.sizes.sizeU32(self.server_pid);
            }
            return res;
        }
        pub fn encode(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdown, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdown, target: *gremlin.Writer) void {
            if (self.aidl_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.AIDL_NAME_WIRE, v);
                }
            }
            if (self.aidl_ts != 0) {
                target.appendInt64(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.AIDL_TS_WIRE, self.aidl_ts);
            }
            if (self.aidl_dur != 0) {
                target.appendInt64(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.AIDL_DUR_WIRE, self.aidl_dur);
            }
            if (self.is_sync != false) {
                target.appendBool(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.IS_SYNC_WIRE, self.is_sync);
            }
            if (self.client_process) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_PROCESS_WIRE, v);
                }
            }
            if (self.client_thread) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_THREAD_WIRE, v);
                }
            }
            if (self.is_main_thread != false) {
                target.appendBool(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.IS_MAIN_THREAD_WIRE, self.is_main_thread);
            }
            if (self.client_ts != 0) {
                target.appendInt64(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_TS_WIRE, self.client_ts);
            }
            if (self.client_dur != 0) {
                target.appendInt64(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_DUR_WIRE, self.client_dur);
            }
            if (self.client_monotonic_dur != 0) {
                target.appendInt64(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_MONOTONIC_DUR_WIRE, self.client_monotonic_dur);
            }
            if (self.client_oom_score != 0) {
                target.appendInt64(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_OOM_SCORE_WIRE, self.client_oom_score);
            }
            if (self.client_package_version_code != 0) {
                target.appendInt64(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_PACKAGE_VERSION_CODE_WIRE, self.client_package_version_code);
            }
            if (self.is_client_package_debuggable != false) {
                target.appendBool(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.IS_CLIENT_PACKAGE_DEBUGGABLE_WIRE, self.is_client_package_debuggable);
            }
            if (self.server_process) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_PROCESS_WIRE, v);
                }
            }
            if (self.server_thread) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_THREAD_WIRE, v);
                }
            }
            if (self.server_ts != 0) {
                target.appendInt64(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_TS_WIRE, self.server_ts);
            }
            if (self.server_dur != 0) {
                target.appendInt64(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_DUR_WIRE, self.server_dur);
            }
            if (self.server_monotonic_dur != 0) {
                target.appendInt64(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_MONOTONIC_DUR_WIRE, self.server_monotonic_dur);
            }
            if (self.server_oom_score != 0) {
                target.appendInt64(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_OOM_SCORE_WIRE, self.server_oom_score);
            }
            if (self.server_package_version_code != 0) {
                target.appendInt64(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_PACKAGE_VERSION_CODE_WIRE, self.server_package_version_code);
            }
            if (self.is_server_package_debuggable != false) {
                target.appendBool(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.IS_SERVER_PACKAGE_DEBUGGABLE_WIRE, self.is_server_package_debuggable);
            }
            if (self.thread_states) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.THREAD_STATES_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.THREAD_STATES_WIRE, 0);
                    }
                }
            }
            if (self.blocked_functions) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.BLOCKED_FUNCTIONS_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.BLOCKED_FUNCTIONS_WIRE, 0);
                    }
                }
            }
            if (self.logical_reasons) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.LOGICAL_REASONS_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.LOGICAL_REASONS_WIRE, 0);
                    }
                }
            }
            if (self.client_tid != 0) {
                target.appendUint32(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_TID_WIRE, self.client_tid);
            }
            if (self.server_tid != 0) {
                target.appendUint32(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_TID_WIRE, self.server_tid);
            }
            if (self.client_pid != 0) {
                target.appendUint32(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_PID_WIRE, self.client_pid);
            }
            if (self.server_pid != 0) {
                target.appendUint32(AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_PID_WIRE, self.server_pid);
            }
        }
    };
    pub const UnaggregatedTxnBreakdownReader = struct {
        buf: gremlin.Reader,
        _aidl_name: ?[]const u8 = null,
        _aidl_ts: i64 = 0,
        _aidl_dur: i64 = 0,
        _is_sync: bool = false,
        _client_process: ?[]const u8 = null,
        _client_thread: ?[]const u8 = null,
        _is_main_thread: bool = false,
        _client_ts: i64 = 0,
        _client_dur: i64 = 0,
        _client_monotonic_dur: i64 = 0,
        _client_oom_score: i64 = 0,
        _client_package_version_code: i64 = 0,
        _is_client_package_debuggable: bool = false,
        _server_process: ?[]const u8 = null,
        _server_thread: ?[]const u8 = null,
        _server_ts: i64 = 0,
        _server_dur: i64 = 0,
        _server_monotonic_dur: i64 = 0,
        _server_oom_score: i64 = 0,
        _server_package_version_code: i64 = 0,
        _is_server_package_debuggable: bool = false,
        _thread_states_offset: ?usize = null,
        _thread_states_last_offset: ?usize = null,
        _thread_states_cnt: usize = 0,
        _blocked_functions_offset: ?usize = null,
        _blocked_functions_last_offset: ?usize = null,
        _blocked_functions_cnt: usize = 0,
        _logical_reasons_offset: ?usize = null,
        _logical_reasons_last_offset: ?usize = null,
        _logical_reasons_cnt: usize = 0,
        _client_tid: u32 = 0,
        _server_tid: u32 = 0,
        _client_pid: u32 = 0,
        _server_pid: u32 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidBinderMetric.UnaggregatedTxnBreakdownReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidBinderMetric.UnaggregatedTxnBreakdownReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.AIDL_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._aidl_name = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.AIDL_TS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._aidl_ts = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.AIDL_DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._aidl_dur = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.IS_SYNC_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._is_sync = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_PROCESS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._client_process = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_THREAD_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._client_thread = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.IS_MAIN_THREAD_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._is_main_thread = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_TS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._client_ts = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._client_dur = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_MONOTONIC_DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._client_monotonic_dur = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_OOM_SCORE_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._client_oom_score = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_PACKAGE_VERSION_CODE_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._client_package_version_code = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.IS_CLIENT_PACKAGE_DEBUGGABLE_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._is_client_package_debuggable = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_PROCESS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._server_process = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_THREAD_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._server_thread = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_TS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._server_ts = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._server_dur = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_MONOTONIC_DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._server_monotonic_dur = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_OOM_SCORE_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._server_oom_score = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_PACKAGE_VERSION_CODE_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._server_package_version_code = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.IS_SERVER_PACKAGE_DEBUGGABLE_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._is_server_package_debuggable = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.THREAD_STATES_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._thread_states_offset == null) {
                            res._thread_states_offset = offset - result.size;
                        }
                        res._thread_states_last_offset = offset;
                        res._thread_states_cnt += 1;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.BLOCKED_FUNCTIONS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._blocked_functions_offset == null) {
                            res._blocked_functions_offset = offset - result.size;
                        }
                        res._blocked_functions_last_offset = offset;
                        res._blocked_functions_cnt += 1;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.LOGICAL_REASONS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._logical_reasons_offset == null) {
                            res._logical_reasons_offset = offset - result.size;
                        }
                        res._logical_reasons_last_offset = offset;
                        res._logical_reasons_cnt += 1;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_TID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._client_tid = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_TID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._server_tid = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.CLIENT_PID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._client_pid = result.value;
                    },
                    AndroidBinderMetric.UnaggregatedTxnBreakdownWire.SERVER_PID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._server_pid = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getAidlName(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) []const u8 {
            return self._aidl_name orelse &[_]u8{};
        }
        pub inline fn getAidlTs(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) i64 {
            return self._aidl_ts;
        }
        pub inline fn getAidlDur(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) i64 {
            return self._aidl_dur;
        }
        pub inline fn getIsSync(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) bool {
            return self._is_sync;
        }
        pub inline fn getClientProcess(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) []const u8 {
            return self._client_process orelse &[_]u8{};
        }
        pub inline fn getClientThread(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) []const u8 {
            return self._client_thread orelse &[_]u8{};
        }
        pub inline fn getIsMainThread(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) bool {
            return self._is_main_thread;
        }
        pub inline fn getClientTs(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) i64 {
            return self._client_ts;
        }
        pub inline fn getClientDur(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) i64 {
            return self._client_dur;
        }
        pub inline fn getClientMonotonicDur(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) i64 {
            return self._client_monotonic_dur;
        }
        pub inline fn getClientOomScore(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) i64 {
            return self._client_oom_score;
        }
        pub inline fn getClientPackageVersionCode(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) i64 {
            return self._client_package_version_code;
        }
        pub inline fn getIsClientPackageDebuggable(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) bool {
            return self._is_client_package_debuggable;
        }
        pub inline fn getServerProcess(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) []const u8 {
            return self._server_process orelse &[_]u8{};
        }
        pub inline fn getServerThread(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) []const u8 {
            return self._server_thread orelse &[_]u8{};
        }
        pub inline fn getServerTs(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) i64 {
            return self._server_ts;
        }
        pub inline fn getServerDur(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) i64 {
            return self._server_dur;
        }
        pub inline fn getServerMonotonicDur(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) i64 {
            return self._server_monotonic_dur;
        }
        pub inline fn getServerOomScore(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) i64 {
            return self._server_oom_score;
        }
        pub inline fn getServerPackageVersionCode(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) i64 {
            return self._server_package_version_code;
        }
        pub inline fn getIsServerPackageDebuggable(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) bool {
            return self._is_server_package_debuggable;
        }
        pub fn threadStatesCount(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) usize {
            return self._thread_states_cnt;
        }
        pub fn threadStatesNext(self: *AndroidBinderMetric.UnaggregatedTxnBreakdownReader) ?AndroidBinderMetric.ThreadStateBreakdownReader {
            if (self._thread_states_offset == null) return null;
            const current_offset = self._thread_states_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidBinderMetric.ThreadStateBreakdownReader.init(result.value) catch return null;
            if (self._thread_states_last_offset != null and current_offset >= self._thread_states_last_offset.?) {
                self._thread_states_offset = null;
                return msg;
            }
            if (self._thread_states_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._thread_states_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidBinderMetric.UnaggregatedTxnBreakdownWire.THREAD_STATES_WIRE) {
                    self._thread_states_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._thread_states_offset = null;
            return msg;
        }
        pub fn blockedFunctionsCount(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) usize {
            return self._blocked_functions_cnt;
        }
        pub fn blockedFunctionsNext(self: *AndroidBinderMetric.UnaggregatedTxnBreakdownReader) ?AndroidBinderMetric.BlockedFunctionBreakdownReader {
            if (self._blocked_functions_offset == null) return null;
            const current_offset = self._blocked_functions_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidBinderMetric.BlockedFunctionBreakdownReader.init(result.value) catch return null;
            if (self._blocked_functions_last_offset != null and current_offset >= self._blocked_functions_last_offset.?) {
                self._blocked_functions_offset = null;
                return msg;
            }
            if (self._blocked_functions_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._blocked_functions_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidBinderMetric.UnaggregatedTxnBreakdownWire.BLOCKED_FUNCTIONS_WIRE) {
                    self._blocked_functions_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._blocked_functions_offset = null;
            return msg;
        }
        pub fn logicalReasonsCount(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) usize {
            return self._logical_reasons_cnt;
        }
        pub fn logicalReasonsNext(self: *AndroidBinderMetric.UnaggregatedTxnBreakdownReader) ?AndroidBinderMetric.LogicalReasonBreakdownReader {
            if (self._logical_reasons_offset == null) return null;
            const current_offset = self._logical_reasons_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidBinderMetric.LogicalReasonBreakdownReader.init(result.value) catch return null;
            if (self._logical_reasons_last_offset != null and current_offset >= self._logical_reasons_last_offset.?) {
                self._logical_reasons_offset = null;
                return msg;
            }
            if (self._logical_reasons_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._logical_reasons_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidBinderMetric.UnaggregatedTxnBreakdownWire.LOGICAL_REASONS_WIRE) {
                    self._logical_reasons_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._logical_reasons_offset = null;
            return msg;
        }
        pub inline fn getClientTid(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) u32 {
            return self._client_tid;
        }
        pub inline fn getServerTid(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) u32 {
            return self._server_tid;
        }
        pub inline fn getClientPid(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) u32 {
            return self._client_pid;
        }
        pub inline fn getServerPid(self: *const AndroidBinderMetric.UnaggregatedTxnBreakdownReader) u32 {
            return self._server_pid;
        }
    };
    const ThreadStateBreakdownWire = struct {
        const THREAD_STATE_TYPE_WIRE: gremlin.ProtoWireNumber = 1;
        const THREAD_STATE_WIRE: gremlin.ProtoWireNumber = 2;
        const THREAD_STATE_DUR_WIRE: gremlin.ProtoWireNumber = 3;
        const THREAD_STATE_COUNT_WIRE: gremlin.ProtoWireNumber = 4;
    };
    pub const ThreadStateBreakdown = struct {
        // fields
        thread_state_type: ?[]const u8 = null,
        thread_state: ?[]const u8 = null,
        thread_state_dur: i64 = 0,
        thread_state_count: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidBinderMetric.ThreadStateBreakdown) usize {
            var res: usize = 0;
            if (self.thread_state_type) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.ThreadStateBreakdownWire.THREAD_STATE_TYPE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.thread_state) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.ThreadStateBreakdownWire.THREAD_STATE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.thread_state_dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.ThreadStateBreakdownWire.THREAD_STATE_DUR_WIRE) + gremlin.sizes.sizeI64(self.thread_state_dur);
            }
            if (self.thread_state_count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.ThreadStateBreakdownWire.THREAD_STATE_COUNT_WIRE) + gremlin.sizes.sizeI64(self.thread_state_count);
            }
            return res;
        }
        pub fn encode(self: *const AndroidBinderMetric.ThreadStateBreakdown, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidBinderMetric.ThreadStateBreakdown, target: *gremlin.Writer) void {
            if (self.thread_state_type) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidBinderMetric.ThreadStateBreakdownWire.THREAD_STATE_TYPE_WIRE, v);
                }
            }
            if (self.thread_state) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidBinderMetric.ThreadStateBreakdownWire.THREAD_STATE_WIRE, v);
                }
            }
            if (self.thread_state_dur != 0) {
                target.appendInt64(AndroidBinderMetric.ThreadStateBreakdownWire.THREAD_STATE_DUR_WIRE, self.thread_state_dur);
            }
            if (self.thread_state_count != 0) {
                target.appendInt64(AndroidBinderMetric.ThreadStateBreakdownWire.THREAD_STATE_COUNT_WIRE, self.thread_state_count);
            }
        }
    };
    pub const ThreadStateBreakdownReader = struct {
        buf: gremlin.Reader,
        _thread_state_type: ?[]const u8 = null,
        _thread_state: ?[]const u8 = null,
        _thread_state_dur: i64 = 0,
        _thread_state_count: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidBinderMetric.ThreadStateBreakdownReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidBinderMetric.ThreadStateBreakdownReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidBinderMetric.ThreadStateBreakdownWire.THREAD_STATE_TYPE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._thread_state_type = result.value;
                    },
                    AndroidBinderMetric.ThreadStateBreakdownWire.THREAD_STATE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._thread_state = result.value;
                    },
                    AndroidBinderMetric.ThreadStateBreakdownWire.THREAD_STATE_DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._thread_state_dur = result.value;
                    },
                    AndroidBinderMetric.ThreadStateBreakdownWire.THREAD_STATE_COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._thread_state_count = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getThreadStateType(self: *const AndroidBinderMetric.ThreadStateBreakdownReader) []const u8 {
            return self._thread_state_type orelse &[_]u8{};
        }
        pub inline fn getThreadState(self: *const AndroidBinderMetric.ThreadStateBreakdownReader) []const u8 {
            return self._thread_state orelse &[_]u8{};
        }
        pub inline fn getThreadStateDur(self: *const AndroidBinderMetric.ThreadStateBreakdownReader) i64 {
            return self._thread_state_dur;
        }
        pub inline fn getThreadStateCount(self: *const AndroidBinderMetric.ThreadStateBreakdownReader) i64 {
            return self._thread_state_count;
        }
    };
    const BlockedFunctionBreakdownWire = struct {
        const THREAD_STATE_TYPE_WIRE: gremlin.ProtoWireNumber = 1;
        const BLOCKED_FUNCTION_WIRE: gremlin.ProtoWireNumber = 2;
        const BLOCKED_FUNCTION_DUR_WIRE: gremlin.ProtoWireNumber = 3;
        const BLOCKED_FUNCTION_COUNT_WIRE: gremlin.ProtoWireNumber = 4;
    };
    pub const BlockedFunctionBreakdown = struct {
        // fields
        thread_state_type: ?[]const u8 = null,
        blocked_function: ?[]const u8 = null,
        blocked_function_dur: i64 = 0,
        blocked_function_count: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidBinderMetric.BlockedFunctionBreakdown) usize {
            var res: usize = 0;
            if (self.thread_state_type) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.BlockedFunctionBreakdownWire.THREAD_STATE_TYPE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.blocked_function) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.BlockedFunctionBreakdownWire.BLOCKED_FUNCTION_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.blocked_function_dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.BlockedFunctionBreakdownWire.BLOCKED_FUNCTION_DUR_WIRE) + gremlin.sizes.sizeI64(self.blocked_function_dur);
            }
            if (self.blocked_function_count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.BlockedFunctionBreakdownWire.BLOCKED_FUNCTION_COUNT_WIRE) + gremlin.sizes.sizeI64(self.blocked_function_count);
            }
            return res;
        }
        pub fn encode(self: *const AndroidBinderMetric.BlockedFunctionBreakdown, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidBinderMetric.BlockedFunctionBreakdown, target: *gremlin.Writer) void {
            if (self.thread_state_type) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidBinderMetric.BlockedFunctionBreakdownWire.THREAD_STATE_TYPE_WIRE, v);
                }
            }
            if (self.blocked_function) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidBinderMetric.BlockedFunctionBreakdownWire.BLOCKED_FUNCTION_WIRE, v);
                }
            }
            if (self.blocked_function_dur != 0) {
                target.appendInt64(AndroidBinderMetric.BlockedFunctionBreakdownWire.BLOCKED_FUNCTION_DUR_WIRE, self.blocked_function_dur);
            }
            if (self.blocked_function_count != 0) {
                target.appendInt64(AndroidBinderMetric.BlockedFunctionBreakdownWire.BLOCKED_FUNCTION_COUNT_WIRE, self.blocked_function_count);
            }
        }
    };
    pub const BlockedFunctionBreakdownReader = struct {
        buf: gremlin.Reader,
        _thread_state_type: ?[]const u8 = null,
        _blocked_function: ?[]const u8 = null,
        _blocked_function_dur: i64 = 0,
        _blocked_function_count: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidBinderMetric.BlockedFunctionBreakdownReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidBinderMetric.BlockedFunctionBreakdownReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidBinderMetric.BlockedFunctionBreakdownWire.THREAD_STATE_TYPE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._thread_state_type = result.value;
                    },
                    AndroidBinderMetric.BlockedFunctionBreakdownWire.BLOCKED_FUNCTION_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._blocked_function = result.value;
                    },
                    AndroidBinderMetric.BlockedFunctionBreakdownWire.BLOCKED_FUNCTION_DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._blocked_function_dur = result.value;
                    },
                    AndroidBinderMetric.BlockedFunctionBreakdownWire.BLOCKED_FUNCTION_COUNT_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._blocked_function_count = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getThreadStateType(self: *const AndroidBinderMetric.BlockedFunctionBreakdownReader) []const u8 {
            return self._thread_state_type orelse &[_]u8{};
        }
        pub inline fn getBlockedFunction(self: *const AndroidBinderMetric.BlockedFunctionBreakdownReader) []const u8 {
            return self._blocked_function orelse &[_]u8{};
        }
        pub inline fn getBlockedFunctionDur(self: *const AndroidBinderMetric.BlockedFunctionBreakdownReader) i64 {
            return self._blocked_function_dur;
        }
        pub inline fn getBlockedFunctionCount(self: *const AndroidBinderMetric.BlockedFunctionBreakdownReader) i64 {
            return self._blocked_function_count;
        }
    };
    const LogicalReasonBreakdownWire = struct {
        const THREAD_STATE_TYPE_WIRE: gremlin.ProtoWireNumber = 1;
        const REASON_WIRE: gremlin.ProtoWireNumber = 2;
        const REASON_DUR_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const LogicalReasonBreakdown = struct {
        // fields
        thread_state_type: ?[]const u8 = null,
        reason: ?[]const u8 = null,
        reason_dur: i64 = 0,
        pub fn calcProtobufSize(self: *const AndroidBinderMetric.LogicalReasonBreakdown) usize {
            var res: usize = 0;
            if (self.thread_state_type) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.LogicalReasonBreakdownWire.THREAD_STATE_TYPE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.reason) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.LogicalReasonBreakdownWire.REASON_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.reason_dur != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetric.LogicalReasonBreakdownWire.REASON_DUR_WIRE) + gremlin.sizes.sizeI64(self.reason_dur);
            }
            return res;
        }
        pub fn encode(self: *const AndroidBinderMetric.LogicalReasonBreakdown, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidBinderMetric.LogicalReasonBreakdown, target: *gremlin.Writer) void {
            if (self.thread_state_type) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidBinderMetric.LogicalReasonBreakdownWire.THREAD_STATE_TYPE_WIRE, v);
                }
            }
            if (self.reason) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidBinderMetric.LogicalReasonBreakdownWire.REASON_WIRE, v);
                }
            }
            if (self.reason_dur != 0) {
                target.appendInt64(AndroidBinderMetric.LogicalReasonBreakdownWire.REASON_DUR_WIRE, self.reason_dur);
            }
        }
    };
    pub const LogicalReasonBreakdownReader = struct {
        buf: gremlin.Reader,
        _thread_state_type: ?[]const u8 = null,
        _reason: ?[]const u8 = null,
        _reason_dur: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidBinderMetric.LogicalReasonBreakdownReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidBinderMetric.LogicalReasonBreakdownReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidBinderMetric.LogicalReasonBreakdownWire.THREAD_STATE_TYPE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._thread_state_type = result.value;
                    },
                    AndroidBinderMetric.LogicalReasonBreakdownWire.REASON_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._reason = result.value;
                    },
                    AndroidBinderMetric.LogicalReasonBreakdownWire.REASON_DUR_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._reason_dur = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getThreadStateType(self: *const AndroidBinderMetric.LogicalReasonBreakdownReader) []const u8 {
            return self._thread_state_type orelse &[_]u8{};
        }
        pub inline fn getReason(self: *const AndroidBinderMetric.LogicalReasonBreakdownReader) []const u8 {
            return self._reason orelse &[_]u8{};
        }
        pub inline fn getReasonDur(self: *const AndroidBinderMetric.LogicalReasonBreakdownReader) i64 {
            return self._reason_dur;
        }
    };
    // fields
    process_breakdown: ?[]const ?AndroidBinderMetric.PerProcessBreakdown = null,
    unaggregated_txn_breakdown: ?[]const ?AndroidBinderMetric.UnaggregatedTxnBreakdown = null,
    pub fn calcProtobufSize(self: *const AndroidBinderMetric) usize {
        var res: usize = 0;
        if (self.process_breakdown) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetricWire.PROCESS_BREAKDOWN_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.unaggregated_txn_breakdown) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidBinderMetricWire.UNAGGREGATED_TXN_BREAKDOWN_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidBinderMetric, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidBinderMetric, target: *gremlin.Writer) void {
        if (self.process_breakdown) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidBinderMetricWire.PROCESS_BREAKDOWN_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidBinderMetricWire.PROCESS_BREAKDOWN_WIRE, 0);
                }
            }
        }
        if (self.unaggregated_txn_breakdown) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidBinderMetricWire.UNAGGREGATED_TXN_BREAKDOWN_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidBinderMetricWire.UNAGGREGATED_TXN_BREAKDOWN_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidBinderMetricReader = struct {
    buf: gremlin.Reader,
    _process_breakdown_offset: ?usize = null,
    _process_breakdown_last_offset: ?usize = null,
    _process_breakdown_cnt: usize = 0,
    _unaggregated_txn_breakdown_offset: ?usize = null,
    _unaggregated_txn_breakdown_last_offset: ?usize = null,
    _unaggregated_txn_breakdown_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidBinderMetricReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidBinderMetricReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidBinderMetricWire.PROCESS_BREAKDOWN_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._process_breakdown_offset == null) {
                        res._process_breakdown_offset = offset - result.size;
                    }
                    res._process_breakdown_last_offset = offset;
                    res._process_breakdown_cnt += 1;
                },
                AndroidBinderMetricWire.UNAGGREGATED_TXN_BREAKDOWN_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._unaggregated_txn_breakdown_offset == null) {
                        res._unaggregated_txn_breakdown_offset = offset - result.size;
                    }
                    res._unaggregated_txn_breakdown_last_offset = offset;
                    res._unaggregated_txn_breakdown_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn processBreakdownCount(self: *const AndroidBinderMetricReader) usize {
        return self._process_breakdown_cnt;
    }
    pub fn processBreakdownNext(self: *AndroidBinderMetricReader) ?AndroidBinderMetric.PerProcessBreakdownReader {
        if (self._process_breakdown_offset == null) return null;
        const current_offset = self._process_breakdown_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidBinderMetric.PerProcessBreakdownReader.init(result.value) catch return null;
        if (self._process_breakdown_last_offset != null and current_offset >= self._process_breakdown_last_offset.?) {
            self._process_breakdown_offset = null;
            return msg;
        }
        if (self._process_breakdown_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._process_breakdown_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidBinderMetricWire.PROCESS_BREAKDOWN_WIRE) {
                self._process_breakdown_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._process_breakdown_offset = null;
        return msg;
    }
    pub fn unaggregatedTxnBreakdownCount(self: *const AndroidBinderMetricReader) usize {
        return self._unaggregated_txn_breakdown_cnt;
    }
    pub fn unaggregatedTxnBreakdownNext(self: *AndroidBinderMetricReader) ?AndroidBinderMetric.UnaggregatedTxnBreakdownReader {
        if (self._unaggregated_txn_breakdown_offset == null) return null;
        const current_offset = self._unaggregated_txn_breakdown_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidBinderMetric.UnaggregatedTxnBreakdownReader.init(result.value) catch return null;
        if (self._unaggregated_txn_breakdown_last_offset != null and current_offset >= self._unaggregated_txn_breakdown_last_offset.?) {
            self._unaggregated_txn_breakdown_offset = null;
            return msg;
        }
        if (self._unaggregated_txn_breakdown_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._unaggregated_txn_breakdown_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidBinderMetricWire.UNAGGREGATED_TXN_BREAKDOWN_WIRE) {
                self._unaggregated_txn_breakdown_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._unaggregated_txn_breakdown_offset = null;
        return msg;
    }
};
