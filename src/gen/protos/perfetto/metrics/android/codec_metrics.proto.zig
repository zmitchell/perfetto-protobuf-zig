// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
const cpu_metric = @import("cpu_metric.proto.zig");
// structs
const AndroidCodecMetricsWire = struct {
    const CPU_USAGE_WIRE: gremlin.ProtoWireNumber = 1;
    const CODEC_FUNCTION_WIRE: gremlin.ProtoWireNumber = 2;
    const ENERGY_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const AndroidCodecMetrics = struct {
    // nested structs
    const DetailWire = struct {
        const TOTAL_CPU_NS_WIRE: gremlin.ProtoWireNumber = 2;
        const RUNNING_CPU_NS_WIRE: gremlin.ProtoWireNumber = 3;
        const AVG_RUNNING_CPU_NS_WIRE: gremlin.ProtoWireNumber = 9;
        const TOTAL_CPU_CYCLES_WIRE: gremlin.ProtoWireNumber = 4;
        const AVG_CPU_CYCLES_WIRE: gremlin.ProtoWireNumber = 8;
        const AVG_TIME_NS_WIRE: gremlin.ProtoWireNumber = 5;
        const COUNT_WIRE: gremlin.ProtoWireNumber = 6;
        const SELF_WIRE: gremlin.ProtoWireNumber = 7;
    };
    pub const Detail = struct {
        // nested structs
        const LatencyWire = struct {
            const MAX_US_WIRE: gremlin.ProtoWireNumber = 1;
            const MIN_US_WIRE: gremlin.ProtoWireNumber = 2;
            const AVG_US_WIRE: gremlin.ProtoWireNumber = 3;
            const AGG_US_WIRE: gremlin.ProtoWireNumber = 4;
            const COUNT_WIRE: gremlin.ProtoWireNumber = 5;
        };
        pub const Latency = struct {
            // fields
            max_us: i64 = 0,
            min_us: i64 = 0,
            avg_us: i64 = 0,
            agg_us: i64 = 0,
            count: u32 = 0,
            pub fn calcProtobufSize(self: *const AndroidCodecMetrics.Detail.Latency) usize {
                var res: usize = 0;
                if (self.max_us != 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.Detail.LatencyWire.MAX_US_WIRE) + gremlin.sizes.sizeI64(self.max_us);
                }
                if (self.min_us != 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.Detail.LatencyWire.MIN_US_WIRE) + gremlin.sizes.sizeI64(self.min_us);
                }
                if (self.avg_us != 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.Detail.LatencyWire.AVG_US_WIRE) + gremlin.sizes.sizeI64(self.avg_us);
                }
                if (self.agg_us != 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.Detail.LatencyWire.AGG_US_WIRE) + gremlin.sizes.sizeI64(self.agg_us);
                }
                if (self.count != 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.Detail.LatencyWire.COUNT_WIRE) + gremlin.sizes.sizeU32(self.count);
                }
                return res;
            }
            pub fn encode(self: *const AndroidCodecMetrics.Detail.Latency, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const AndroidCodecMetrics.Detail.Latency, target: *gremlin.Writer) void {
                if (self.max_us != 0) {
                    target.appendInt64(AndroidCodecMetrics.Detail.LatencyWire.MAX_US_WIRE, self.max_us);
                }
                if (self.min_us != 0) {
                    target.appendInt64(AndroidCodecMetrics.Detail.LatencyWire.MIN_US_WIRE, self.min_us);
                }
                if (self.avg_us != 0) {
                    target.appendInt64(AndroidCodecMetrics.Detail.LatencyWire.AVG_US_WIRE, self.avg_us);
                }
                if (self.agg_us != 0) {
                    target.appendInt64(AndroidCodecMetrics.Detail.LatencyWire.AGG_US_WIRE, self.agg_us);
                }
                if (self.count != 0) {
                    target.appendUint32(AndroidCodecMetrics.Detail.LatencyWire.COUNT_WIRE, self.count);
                }
            }
        };
        pub const LatencyReader = struct {
            buf: gremlin.Reader,
            _max_us: i64 = 0,
            _min_us: i64 = 0,
            _avg_us: i64 = 0,
            _agg_us: i64 = 0,
            _count: u32 = 0,
            pub fn init(src: []const u8) gremlin.Error!AndroidCodecMetrics.Detail.LatencyReader {
                const buf = gremlin.Reader.init(src);
                var res = AndroidCodecMetrics.Detail.LatencyReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        AndroidCodecMetrics.Detail.LatencyWire.MAX_US_WIRE => {
                            const result = try buf.readInt64(offset);
                            offset += result.size;
                            res._max_us = result.value;
                        },
                        AndroidCodecMetrics.Detail.LatencyWire.MIN_US_WIRE => {
                            const result = try buf.readInt64(offset);
                            offset += result.size;
                            res._min_us = result.value;
                        },
                        AndroidCodecMetrics.Detail.LatencyWire.AVG_US_WIRE => {
                            const result = try buf.readInt64(offset);
                            offset += result.size;
                            res._avg_us = result.value;
                        },
                        AndroidCodecMetrics.Detail.LatencyWire.AGG_US_WIRE => {
                            const result = try buf.readInt64(offset);
                            offset += result.size;
                            res._agg_us = result.value;
                        },
                        AndroidCodecMetrics.Detail.LatencyWire.COUNT_WIRE => {
                            const result = try buf.readUInt32(offset);
                            offset += result.size;
                            res._count = result.value;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub inline fn getMaxUs(self: *const AndroidCodecMetrics.Detail.LatencyReader) i64 {
                return self._max_us;
            }
            pub inline fn getMinUs(self: *const AndroidCodecMetrics.Detail.LatencyReader) i64 {
                return self._min_us;
            }
            pub inline fn getAvgUs(self: *const AndroidCodecMetrics.Detail.LatencyReader) i64 {
                return self._avg_us;
            }
            pub inline fn getAggUs(self: *const AndroidCodecMetrics.Detail.LatencyReader) i64 {
                return self._agg_us;
            }
            pub inline fn getCount(self: *const AndroidCodecMetrics.Detail.LatencyReader) u32 {
                return self._count;
            }
        };
        // fields
        total_cpu_ns: i64 = 0,
        running_cpu_ns: i64 = 0,
        avg_running_cpu_ns: i64 = 0,
        total_cpu_cycles: i64 = 0,
        avg_cpu_cycles: i64 = 0,
        avg_time_ns: i64 = 0,
        count: i32 = 0,
        self: ?AndroidCodecMetrics.Detail.Latency = null,
        pub fn calcProtobufSize(self: *const AndroidCodecMetrics.Detail) usize {
            var res: usize = 0;
            if (self.total_cpu_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.DetailWire.TOTAL_CPU_NS_WIRE) + gremlin.sizes.sizeI64(self.total_cpu_ns);
            }
            if (self.running_cpu_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.DetailWire.RUNNING_CPU_NS_WIRE) + gremlin.sizes.sizeI64(self.running_cpu_ns);
            }
            if (self.avg_running_cpu_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.DetailWire.AVG_RUNNING_CPU_NS_WIRE) + gremlin.sizes.sizeI64(self.avg_running_cpu_ns);
            }
            if (self.total_cpu_cycles != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.DetailWire.TOTAL_CPU_CYCLES_WIRE) + gremlin.sizes.sizeI64(self.total_cpu_cycles);
            }
            if (self.avg_cpu_cycles != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.DetailWire.AVG_CPU_CYCLES_WIRE) + gremlin.sizes.sizeI64(self.avg_cpu_cycles);
            }
            if (self.avg_time_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.DetailWire.AVG_TIME_NS_WIRE) + gremlin.sizes.sizeI64(self.avg_time_ns);
            }
            if (self.count != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.DetailWire.COUNT_WIRE) + gremlin.sizes.sizeI32(self.count);
            }
            if (self.self) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.DetailWire.SELF_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidCodecMetrics.Detail, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidCodecMetrics.Detail, target: *gremlin.Writer) void {
            if (self.total_cpu_ns != 0) {
                target.appendInt64(AndroidCodecMetrics.DetailWire.TOTAL_CPU_NS_WIRE, self.total_cpu_ns);
            }
            if (self.running_cpu_ns != 0) {
                target.appendInt64(AndroidCodecMetrics.DetailWire.RUNNING_CPU_NS_WIRE, self.running_cpu_ns);
            }
            if (self.avg_running_cpu_ns != 0) {
                target.appendInt64(AndroidCodecMetrics.DetailWire.AVG_RUNNING_CPU_NS_WIRE, self.avg_running_cpu_ns);
            }
            if (self.total_cpu_cycles != 0) {
                target.appendInt64(AndroidCodecMetrics.DetailWire.TOTAL_CPU_CYCLES_WIRE, self.total_cpu_cycles);
            }
            if (self.avg_cpu_cycles != 0) {
                target.appendInt64(AndroidCodecMetrics.DetailWire.AVG_CPU_CYCLES_WIRE, self.avg_cpu_cycles);
            }
            if (self.avg_time_ns != 0) {
                target.appendInt64(AndroidCodecMetrics.DetailWire.AVG_TIME_NS_WIRE, self.avg_time_ns);
            }
            if (self.count != 0) {
                target.appendInt32(AndroidCodecMetrics.DetailWire.COUNT_WIRE, self.count);
            }
            if (self.self) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidCodecMetrics.DetailWire.SELF_WIRE, size);
                    v.encodeTo(target);
                }
            }
        }
    };
    pub const DetailReader = struct {
        buf: gremlin.Reader,
        _total_cpu_ns: i64 = 0,
        _running_cpu_ns: i64 = 0,
        _avg_running_cpu_ns: i64 = 0,
        _total_cpu_cycles: i64 = 0,
        _avg_cpu_cycles: i64 = 0,
        _avg_time_ns: i64 = 0,
        _count: i32 = 0,
        _self_buf: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!AndroidCodecMetrics.DetailReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidCodecMetrics.DetailReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidCodecMetrics.DetailWire.TOTAL_CPU_NS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._total_cpu_ns = result.value;
                    },
                    AndroidCodecMetrics.DetailWire.RUNNING_CPU_NS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._running_cpu_ns = result.value;
                    },
                    AndroidCodecMetrics.DetailWire.AVG_RUNNING_CPU_NS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._avg_running_cpu_ns = result.value;
                    },
                    AndroidCodecMetrics.DetailWire.TOTAL_CPU_CYCLES_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._total_cpu_cycles = result.value;
                    },
                    AndroidCodecMetrics.DetailWire.AVG_CPU_CYCLES_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._avg_cpu_cycles = result.value;
                    },
                    AndroidCodecMetrics.DetailWire.AVG_TIME_NS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._avg_time_ns = result.value;
                    },
                    AndroidCodecMetrics.DetailWire.COUNT_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._count = result.value;
                    },
                    AndroidCodecMetrics.DetailWire.SELF_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._self_buf = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getTotalCpuNs(self: *const AndroidCodecMetrics.DetailReader) i64 {
            return self._total_cpu_ns;
        }
        pub inline fn getRunningCpuNs(self: *const AndroidCodecMetrics.DetailReader) i64 {
            return self._running_cpu_ns;
        }
        pub inline fn getAvgRunningCpuNs(self: *const AndroidCodecMetrics.DetailReader) i64 {
            return self._avg_running_cpu_ns;
        }
        pub inline fn getTotalCpuCycles(self: *const AndroidCodecMetrics.DetailReader) i64 {
            return self._total_cpu_cycles;
        }
        pub inline fn getAvgCpuCycles(self: *const AndroidCodecMetrics.DetailReader) i64 {
            return self._avg_cpu_cycles;
        }
        pub inline fn getAvgTimeNs(self: *const AndroidCodecMetrics.DetailReader) i64 {
            return self._avg_time_ns;
        }
        pub inline fn getCount(self: *const AndroidCodecMetrics.DetailReader) i32 {
            return self._count;
        }
        pub fn getSelf(self: *const AndroidCodecMetrics.DetailReader) gremlin.Error!AndroidCodecMetrics.Detail.LatencyReader {
            if (self._self_buf) |buf| {
                return try AndroidCodecMetrics.Detail.LatencyReader.init(buf);
            }
            return try AndroidCodecMetrics.Detail.LatencyReader.init(&[_]u8{});
        }
    };
    const CodecFunctionWire = struct {
        const CODEC_STRING_WIRE: gremlin.ProtoWireNumber = 1;
        const PROCESS_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const CodecFunction = struct {
        // nested structs
        const ProcessWire = struct {
            const NAME_WIRE: gremlin.ProtoWireNumber = 1;
            const THREAD_WIRE: gremlin.ProtoWireNumber = 2;
        };
        pub const Process = struct {
            // nested structs
            const ThreadWire = struct {
                const NAME_WIRE: gremlin.ProtoWireNumber = 1;
                const DETAIL_WIRE: gremlin.ProtoWireNumber = 2;
            };
            pub const Thread = struct {
                // fields
                name: ?[]const u8 = null,
                detail: ?AndroidCodecMetrics.Detail = null,
                pub fn calcProtobufSize(self: *const AndroidCodecMetrics.CodecFunction.Process.Thread) usize {
                    var res: usize = 0;
                    if (self.name) |v| {
                        if (v.len > 0) {
                            res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.CodecFunction.Process.ThreadWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                        }
                    }
                    if (self.detail) |v| {
                        const size = v.calcProtobufSize();
                        if (size > 0) {
                            res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.CodecFunction.Process.ThreadWire.DETAIL_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                        }
                    }
                    return res;
                }
                pub fn encode(self: *const AndroidCodecMetrics.CodecFunction.Process.Thread, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                    const size = self.calcProtobufSize();
                    if (size == 0) {
                        return &[_]u8{};
                    }
                    const buf = try allocator.alloc(u8, self.calcProtobufSize());
                    var writer = gremlin.Writer.init(buf);
                    self.encodeTo(&writer);
                    return buf;
                }
                pub fn encodeTo(self: *const AndroidCodecMetrics.CodecFunction.Process.Thread, target: *gremlin.Writer) void {
                    if (self.name) |v| {
                        if (v.len > 0) {
                            target.appendBytes(AndroidCodecMetrics.CodecFunction.Process.ThreadWire.NAME_WIRE, v);
                        }
                    }
                    if (self.detail) |v| {
                        const size = v.calcProtobufSize();
                        if (size > 0) {
                            target.appendBytesTag(AndroidCodecMetrics.CodecFunction.Process.ThreadWire.DETAIL_WIRE, size);
                            v.encodeTo(target);
                        }
                    }
                }
            };
            pub const ThreadReader = struct {
                buf: gremlin.Reader,
                _name: ?[]const u8 = null,
                _detail_buf: ?[]const u8 = null,
                pub fn init(src: []const u8) gremlin.Error!AndroidCodecMetrics.CodecFunction.Process.ThreadReader {
                    const buf = gremlin.Reader.init(src);
                    var res = AndroidCodecMetrics.CodecFunction.Process.ThreadReader{ .buf = buf };
                    if (buf.buf.len == 0) {
                        return res;
                    }
                    var offset: usize = 0;
                    while (buf.hasNext(offset, 0)) {
                        const tag = try buf.readTagAt(offset);
                        offset += tag.size;
                        switch (tag.number) {
                            AndroidCodecMetrics.CodecFunction.Process.ThreadWire.NAME_WIRE => {
                                const result = try buf.readBytes(offset);
                                offset += result.size;
                                res._name = result.value;
                            },
                            AndroidCodecMetrics.CodecFunction.Process.ThreadWire.DETAIL_WIRE => {
                                const result = try buf.readBytes(offset);
                                offset += result.size;
                                res._detail_buf = result.value;
                            },
                            else => {
                                offset = try buf.skipData(offset, tag.wire);
                            },
                        }
                    }
                    return res;
                }
                pub fn sourceBytes(self: *const @This()) []const u8 {
                    return self.buf.buf;
                }
                pub inline fn getName(self: *const AndroidCodecMetrics.CodecFunction.Process.ThreadReader) []const u8 {
                    return self._name orelse &[_]u8{};
                }
                pub fn getDetail(self: *const AndroidCodecMetrics.CodecFunction.Process.ThreadReader) gremlin.Error!AndroidCodecMetrics.DetailReader {
                    if (self._detail_buf) |buf| {
                        return try AndroidCodecMetrics.DetailReader.init(buf);
                    }
                    return try AndroidCodecMetrics.DetailReader.init(&[_]u8{});
                }
            };
            // fields
            name: ?[]const u8 = null,
            thread: ?AndroidCodecMetrics.CodecFunction.Process.Thread = null,
            pub fn calcProtobufSize(self: *const AndroidCodecMetrics.CodecFunction.Process) usize {
                var res: usize = 0;
                if (self.name) |v| {
                    if (v.len > 0) {
                        res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.CodecFunction.ProcessWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                    }
                }
                if (self.thread) |v| {
                    const size = v.calcProtobufSize();
                    if (size > 0) {
                        res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.CodecFunction.ProcessWire.THREAD_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                    }
                }
                return res;
            }
            pub fn encode(self: *const AndroidCodecMetrics.CodecFunction.Process, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const AndroidCodecMetrics.CodecFunction.Process, target: *gremlin.Writer) void {
                if (self.name) |v| {
                    if (v.len > 0) {
                        target.appendBytes(AndroidCodecMetrics.CodecFunction.ProcessWire.NAME_WIRE, v);
                    }
                }
                if (self.thread) |v| {
                    const size = v.calcProtobufSize();
                    if (size > 0) {
                        target.appendBytesTag(AndroidCodecMetrics.CodecFunction.ProcessWire.THREAD_WIRE, size);
                        v.encodeTo(target);
                    }
                }
            }
        };
        pub const ProcessReader = struct {
            buf: gremlin.Reader,
            _name: ?[]const u8 = null,
            _thread_buf: ?[]const u8 = null,
            pub fn init(src: []const u8) gremlin.Error!AndroidCodecMetrics.CodecFunction.ProcessReader {
                const buf = gremlin.Reader.init(src);
                var res = AndroidCodecMetrics.CodecFunction.ProcessReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        AndroidCodecMetrics.CodecFunction.ProcessWire.NAME_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._name = result.value;
                        },
                        AndroidCodecMetrics.CodecFunction.ProcessWire.THREAD_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._thread_buf = result.value;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub inline fn getName(self: *const AndroidCodecMetrics.CodecFunction.ProcessReader) []const u8 {
                return self._name orelse &[_]u8{};
            }
            pub fn getThread(self: *const AndroidCodecMetrics.CodecFunction.ProcessReader) gremlin.Error!AndroidCodecMetrics.CodecFunction.Process.ThreadReader {
                if (self._thread_buf) |buf| {
                    return try AndroidCodecMetrics.CodecFunction.Process.ThreadReader.init(buf);
                }
                return try AndroidCodecMetrics.CodecFunction.Process.ThreadReader.init(&[_]u8{});
            }
        };
        // fields
        codec_string: ?[]const u8 = null,
        process: ?AndroidCodecMetrics.CodecFunction.Process = null,
        pub fn calcProtobufSize(self: *const AndroidCodecMetrics.CodecFunction) usize {
            var res: usize = 0;
            if (self.codec_string) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.CodecFunctionWire.CODEC_STRING_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.process) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.CodecFunctionWire.PROCESS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidCodecMetrics.CodecFunction, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidCodecMetrics.CodecFunction, target: *gremlin.Writer) void {
            if (self.codec_string) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidCodecMetrics.CodecFunctionWire.CODEC_STRING_WIRE, v);
                }
            }
            if (self.process) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidCodecMetrics.CodecFunctionWire.PROCESS_WIRE, size);
                    v.encodeTo(target);
                }
            }
        }
    };
    pub const CodecFunctionReader = struct {
        buf: gremlin.Reader,
        _codec_string: ?[]const u8 = null,
        _process_buf: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!AndroidCodecMetrics.CodecFunctionReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidCodecMetrics.CodecFunctionReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidCodecMetrics.CodecFunctionWire.CODEC_STRING_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._codec_string = result.value;
                    },
                    AndroidCodecMetrics.CodecFunctionWire.PROCESS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._process_buf = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getCodecString(self: *const AndroidCodecMetrics.CodecFunctionReader) []const u8 {
            return self._codec_string orelse &[_]u8{};
        }
        pub fn getProcess(self: *const AndroidCodecMetrics.CodecFunctionReader) gremlin.Error!AndroidCodecMetrics.CodecFunction.ProcessReader {
            if (self._process_buf) |buf| {
                return try AndroidCodecMetrics.CodecFunction.ProcessReader.init(buf);
            }
            return try AndroidCodecMetrics.CodecFunction.ProcessReader.init(&[_]u8{});
        }
    };
    const CpuUsageWire = struct {
        const PROCESS_NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const THREAD_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const CpuUsage = struct {
        // nested structs
        const ThreadInfoWire = struct {
            const NAME_WIRE: gremlin.ProtoWireNumber = 1;
            const INFO_WIRE: gremlin.ProtoWireNumber = 2;
        };
        pub const ThreadInfo = struct {
            // nested structs
            const DetailsWire = struct {
                const THREAD_CPU_NS_WIRE: gremlin.ProtoWireNumber = 1;
                const NUM_THREADS_WIRE: gremlin.ProtoWireNumber = 2;
                const CORE_DATA_WIRE: gremlin.ProtoWireNumber = 3;
            };
            pub const Details = struct {
                // fields
                thread_cpu_ns: i64 = 0,
                num_threads: u32 = 0,
                core_data: ?[]const ?cpu_metric.AndroidCpuMetric.CoreTypeData = null,
                pub fn calcProtobufSize(self: *const AndroidCodecMetrics.CpuUsage.ThreadInfo.Details) usize {
                    var res: usize = 0;
                    if (self.thread_cpu_ns != 0) {
                        res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.CpuUsage.ThreadInfo.DetailsWire.THREAD_CPU_NS_WIRE) + gremlin.sizes.sizeI64(self.thread_cpu_ns);
                    }
                    if (self.num_threads != 0) {
                        res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.CpuUsage.ThreadInfo.DetailsWire.NUM_THREADS_WIRE) + gremlin.sizes.sizeU32(self.num_threads);
                    }
                    if (self.core_data) |arr| {
                        for (arr) |maybe_v| {
                            res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.CpuUsage.ThreadInfo.DetailsWire.CORE_DATA_WIRE);
                            if (maybe_v) |v| {
                                const size = v.calcProtobufSize();
                                res += gremlin.sizes.sizeUsize(size) + size;
                            } else {
                                res += gremlin.sizes.sizeUsize(0);
                            }
                        }
                    }
                    return res;
                }
                pub fn encode(self: *const AndroidCodecMetrics.CpuUsage.ThreadInfo.Details, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                    const size = self.calcProtobufSize();
                    if (size == 0) {
                        return &[_]u8{};
                    }
                    const buf = try allocator.alloc(u8, self.calcProtobufSize());
                    var writer = gremlin.Writer.init(buf);
                    self.encodeTo(&writer);
                    return buf;
                }
                pub fn encodeTo(self: *const AndroidCodecMetrics.CpuUsage.ThreadInfo.Details, target: *gremlin.Writer) void {
                    if (self.thread_cpu_ns != 0) {
                        target.appendInt64(AndroidCodecMetrics.CpuUsage.ThreadInfo.DetailsWire.THREAD_CPU_NS_WIRE, self.thread_cpu_ns);
                    }
                    if (self.num_threads != 0) {
                        target.appendUint32(AndroidCodecMetrics.CpuUsage.ThreadInfo.DetailsWire.NUM_THREADS_WIRE, self.num_threads);
                    }
                    if (self.core_data) |arr| {
                        for (arr) |maybe_v| {
                            if (maybe_v) |v| {
                                const size = v.calcProtobufSize();
                                target.appendBytesTag(AndroidCodecMetrics.CpuUsage.ThreadInfo.DetailsWire.CORE_DATA_WIRE, size);
                                v.encodeTo(target);
                            } else {
                                target.appendBytesTag(AndroidCodecMetrics.CpuUsage.ThreadInfo.DetailsWire.CORE_DATA_WIRE, 0);
                            }
                        }
                    }
                }
            };
            pub const DetailsReader = struct {
                buf: gremlin.Reader,
                _thread_cpu_ns: i64 = 0,
                _num_threads: u32 = 0,
                _core_data_offset: ?usize = null,
                _core_data_last_offset: ?usize = null,
                _core_data_cnt: usize = 0,
                pub fn init(src: []const u8) gremlin.Error!AndroidCodecMetrics.CpuUsage.ThreadInfo.DetailsReader {
                    const buf = gremlin.Reader.init(src);
                    var res = AndroidCodecMetrics.CpuUsage.ThreadInfo.DetailsReader{ .buf = buf };
                    if (buf.buf.len == 0) {
                        return res;
                    }
                    var offset: usize = 0;
                    while (buf.hasNext(offset, 0)) {
                        const tag = try buf.readTagAt(offset);
                        offset += tag.size;
                        switch (tag.number) {
                            AndroidCodecMetrics.CpuUsage.ThreadInfo.DetailsWire.THREAD_CPU_NS_WIRE => {
                                const result = try buf.readInt64(offset);
                                offset += result.size;
                                res._thread_cpu_ns = result.value;
                            },
                            AndroidCodecMetrics.CpuUsage.ThreadInfo.DetailsWire.NUM_THREADS_WIRE => {
                                const result = try buf.readUInt32(offset);
                                offset += result.size;
                                res._num_threads = result.value;
                            },
                            AndroidCodecMetrics.CpuUsage.ThreadInfo.DetailsWire.CORE_DATA_WIRE => {
                                const result = try buf.readBytes(offset);
                                offset += result.size;
                                if (res._core_data_offset == null) {
                                    res._core_data_offset = offset - result.size;
                                }
                                res._core_data_last_offset = offset;
                                res._core_data_cnt += 1;
                            },
                            else => {
                                offset = try buf.skipData(offset, tag.wire);
                            },
                        }
                    }
                    return res;
                }
                pub fn sourceBytes(self: *const @This()) []const u8 {
                    return self.buf.buf;
                }
                pub inline fn getThreadCpuNs(self: *const AndroidCodecMetrics.CpuUsage.ThreadInfo.DetailsReader) i64 {
                    return self._thread_cpu_ns;
                }
                pub inline fn getNumThreads(self: *const AndroidCodecMetrics.CpuUsage.ThreadInfo.DetailsReader) u32 {
                    return self._num_threads;
                }
                pub fn coreDataCount(self: *const AndroidCodecMetrics.CpuUsage.ThreadInfo.DetailsReader) usize {
                    return self._core_data_cnt;
                }
                pub fn coreDataNext(self: *AndroidCodecMetrics.CpuUsage.ThreadInfo.DetailsReader) ?cpu_metric.AndroidCpuMetric.CoreTypeDataReader {
                    if (self._core_data_offset == null) return null;
                    const current_offset = self._core_data_offset.?;
                    const result = self.buf.readBytes(current_offset) catch return null;
                    const msg = cpu_metric.AndroidCpuMetric.CoreTypeDataReader.init(result.value) catch return null;
                    if (self._core_data_last_offset != null and current_offset >= self._core_data_last_offset.?) {
                        self._core_data_offset = null;
                        return msg;
                    }
                    if (self._core_data_last_offset == null) unreachable;
                    var next_offset = current_offset + result.size;
                    const max_offset = self._core_data_last_offset.?;
                    while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                        const tag = self.buf.readTagAt(next_offset) catch break;
                        next_offset += tag.size;
                        if (tag.number == AndroidCodecMetrics.CpuUsage.ThreadInfo.DetailsWire.CORE_DATA_WIRE) {
                            self._core_data_offset = next_offset;
                            return msg;
                        } else {
                            next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                        }
                    }
                    self._core_data_offset = null;
                    return msg;
                }
            };
            // fields
            name: ?[]const u8 = null,
            info: ?AndroidCodecMetrics.CpuUsage.ThreadInfo.Details = null,
            pub fn calcProtobufSize(self: *const AndroidCodecMetrics.CpuUsage.ThreadInfo) usize {
                var res: usize = 0;
                if (self.name) |v| {
                    if (v.len > 0) {
                        res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.CpuUsage.ThreadInfoWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                    }
                }
                if (self.info) |v| {
                    const size = v.calcProtobufSize();
                    if (size > 0) {
                        res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.CpuUsage.ThreadInfoWire.INFO_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                    }
                }
                return res;
            }
            pub fn encode(self: *const AndroidCodecMetrics.CpuUsage.ThreadInfo, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const AndroidCodecMetrics.CpuUsage.ThreadInfo, target: *gremlin.Writer) void {
                if (self.name) |v| {
                    if (v.len > 0) {
                        target.appendBytes(AndroidCodecMetrics.CpuUsage.ThreadInfoWire.NAME_WIRE, v);
                    }
                }
                if (self.info) |v| {
                    const size = v.calcProtobufSize();
                    if (size > 0) {
                        target.appendBytesTag(AndroidCodecMetrics.CpuUsage.ThreadInfoWire.INFO_WIRE, size);
                        v.encodeTo(target);
                    }
                }
            }
        };
        pub const ThreadInfoReader = struct {
            buf: gremlin.Reader,
            _name: ?[]const u8 = null,
            _info_buf: ?[]const u8 = null,
            pub fn init(src: []const u8) gremlin.Error!AndroidCodecMetrics.CpuUsage.ThreadInfoReader {
                const buf = gremlin.Reader.init(src);
                var res = AndroidCodecMetrics.CpuUsage.ThreadInfoReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        AndroidCodecMetrics.CpuUsage.ThreadInfoWire.NAME_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._name = result.value;
                        },
                        AndroidCodecMetrics.CpuUsage.ThreadInfoWire.INFO_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._info_buf = result.value;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub inline fn getName(self: *const AndroidCodecMetrics.CpuUsage.ThreadInfoReader) []const u8 {
                return self._name orelse &[_]u8{};
            }
            pub fn getInfo(self: *const AndroidCodecMetrics.CpuUsage.ThreadInfoReader) gremlin.Error!AndroidCodecMetrics.CpuUsage.ThreadInfo.DetailsReader {
                if (self._info_buf) |buf| {
                    return try AndroidCodecMetrics.CpuUsage.ThreadInfo.DetailsReader.init(buf);
                }
                return try AndroidCodecMetrics.CpuUsage.ThreadInfo.DetailsReader.init(&[_]u8{});
            }
        };
        // fields
        process_name: ?[]const u8 = null,
        thread: ?AndroidCodecMetrics.CpuUsage.ThreadInfo = null,
        pub fn calcProtobufSize(self: *const AndroidCodecMetrics.CpuUsage) usize {
            var res: usize = 0;
            if (self.process_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.CpuUsageWire.PROCESS_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.thread) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.CpuUsageWire.THREAD_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidCodecMetrics.CpuUsage, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidCodecMetrics.CpuUsage, target: *gremlin.Writer) void {
            if (self.process_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidCodecMetrics.CpuUsageWire.PROCESS_NAME_WIRE, v);
                }
            }
            if (self.thread) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidCodecMetrics.CpuUsageWire.THREAD_WIRE, size);
                    v.encodeTo(target);
                }
            }
        }
    };
    pub const CpuUsageReader = struct {
        buf: gremlin.Reader,
        _process_name: ?[]const u8 = null,
        _thread_buf: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!AndroidCodecMetrics.CpuUsageReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidCodecMetrics.CpuUsageReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidCodecMetrics.CpuUsageWire.PROCESS_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._process_name = result.value;
                    },
                    AndroidCodecMetrics.CpuUsageWire.THREAD_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._thread_buf = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getProcessName(self: *const AndroidCodecMetrics.CpuUsageReader) []const u8 {
            return self._process_name orelse &[_]u8{};
        }
        pub fn getThread(self: *const AndroidCodecMetrics.CpuUsageReader) gremlin.Error!AndroidCodecMetrics.CpuUsage.ThreadInfoReader {
            if (self._thread_buf) |buf| {
                return try AndroidCodecMetrics.CpuUsage.ThreadInfoReader.init(buf);
            }
            return try AndroidCodecMetrics.CpuUsage.ThreadInfoReader.init(&[_]u8{});
        }
    };
    const RailWire = struct {
        const NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const INFO_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const Rail = struct {
        // nested structs
        const InfoWire = struct {
            const ENERGY_WIRE: gremlin.ProtoWireNumber = 1;
            const POWER_MW_WIRE: gremlin.ProtoWireNumber = 2;
        };
        pub const Info = struct {
            // fields
            energy: f64 = 0.0,
            power_mw: f64 = 0.0,
            pub fn calcProtobufSize(self: *const AndroidCodecMetrics.Rail.Info) usize {
                var res: usize = 0;
                if (self.energy != 0.0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.Rail.InfoWire.ENERGY_WIRE) + gremlin.sizes.sizeDouble(self.energy);
                }
                if (self.power_mw != 0.0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.Rail.InfoWire.POWER_MW_WIRE) + gremlin.sizes.sizeDouble(self.power_mw);
                }
                return res;
            }
            pub fn encode(self: *const AndroidCodecMetrics.Rail.Info, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const AndroidCodecMetrics.Rail.Info, target: *gremlin.Writer) void {
                if (self.energy != 0.0) {
                    target.appendFloat64(AndroidCodecMetrics.Rail.InfoWire.ENERGY_WIRE, self.energy);
                }
                if (self.power_mw != 0.0) {
                    target.appendFloat64(AndroidCodecMetrics.Rail.InfoWire.POWER_MW_WIRE, self.power_mw);
                }
            }
        };
        pub const InfoReader = struct {
            buf: gremlin.Reader,
            _energy: f64 = 0.0,
            _power_mw: f64 = 0.0,
            pub fn init(src: []const u8) gremlin.Error!AndroidCodecMetrics.Rail.InfoReader {
                const buf = gremlin.Reader.init(src);
                var res = AndroidCodecMetrics.Rail.InfoReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        AndroidCodecMetrics.Rail.InfoWire.ENERGY_WIRE => {
                            const result = try buf.readFloat64(offset);
                            offset += result.size;
                            res._energy = result.value;
                        },
                        AndroidCodecMetrics.Rail.InfoWire.POWER_MW_WIRE => {
                            const result = try buf.readFloat64(offset);
                            offset += result.size;
                            res._power_mw = result.value;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub inline fn getEnergy(self: *const AndroidCodecMetrics.Rail.InfoReader) f64 {
                return self._energy;
            }
            pub inline fn getPowerMw(self: *const AndroidCodecMetrics.Rail.InfoReader) f64 {
                return self._power_mw;
            }
        };
        // fields
        name: ?[]const u8 = null,
        info: ?AndroidCodecMetrics.Rail.Info = null,
        pub fn calcProtobufSize(self: *const AndroidCodecMetrics.Rail) usize {
            var res: usize = 0;
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.RailWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.info) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.RailWire.INFO_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidCodecMetrics.Rail, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidCodecMetrics.Rail, target: *gremlin.Writer) void {
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(AndroidCodecMetrics.RailWire.NAME_WIRE, v);
                }
            }
            if (self.info) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(AndroidCodecMetrics.RailWire.INFO_WIRE, size);
                    v.encodeTo(target);
                }
            }
        }
    };
    pub const RailReader = struct {
        buf: gremlin.Reader,
        _name: ?[]const u8 = null,
        _info_buf: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!AndroidCodecMetrics.RailReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidCodecMetrics.RailReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidCodecMetrics.RailWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    AndroidCodecMetrics.RailWire.INFO_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._info_buf = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getName(self: *const AndroidCodecMetrics.RailReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub fn getInfo(self: *const AndroidCodecMetrics.RailReader) gremlin.Error!AndroidCodecMetrics.Rail.InfoReader {
            if (self._info_buf) |buf| {
                return try AndroidCodecMetrics.Rail.InfoReader.init(buf);
            }
            return try AndroidCodecMetrics.Rail.InfoReader.init(&[_]u8{});
        }
    };
    const EnergyWire = struct {
        const TOTAL_ENERGY_WIRE: gremlin.ProtoWireNumber = 1;
        const DURATION_WIRE: gremlin.ProtoWireNumber = 2;
        const POWER_MW_WIRE: gremlin.ProtoWireNumber = 3;
        const RAIL_WIRE: gremlin.ProtoWireNumber = 4;
    };
    pub const Energy = struct {
        // fields
        total_energy: f64 = 0.0,
        duration: i64 = 0,
        power_mw: f64 = 0.0,
        rail: ?[]const ?AndroidCodecMetrics.Rail = null,
        pub fn calcProtobufSize(self: *const AndroidCodecMetrics.Energy) usize {
            var res: usize = 0;
            if (self.total_energy != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.EnergyWire.TOTAL_ENERGY_WIRE) + gremlin.sizes.sizeDouble(self.total_energy);
            }
            if (self.duration != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.EnergyWire.DURATION_WIRE) + gremlin.sizes.sizeI64(self.duration);
            }
            if (self.power_mw != 0.0) {
                res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.EnergyWire.POWER_MW_WIRE) + gremlin.sizes.sizeDouble(self.power_mw);
            }
            if (self.rail) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidCodecMetrics.EnergyWire.RAIL_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const AndroidCodecMetrics.Energy, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidCodecMetrics.Energy, target: *gremlin.Writer) void {
            if (self.total_energy != 0.0) {
                target.appendFloat64(AndroidCodecMetrics.EnergyWire.TOTAL_ENERGY_WIRE, self.total_energy);
            }
            if (self.duration != 0) {
                target.appendInt64(AndroidCodecMetrics.EnergyWire.DURATION_WIRE, self.duration);
            }
            if (self.power_mw != 0.0) {
                target.appendFloat64(AndroidCodecMetrics.EnergyWire.POWER_MW_WIRE, self.power_mw);
            }
            if (self.rail) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(AndroidCodecMetrics.EnergyWire.RAIL_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(AndroidCodecMetrics.EnergyWire.RAIL_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const EnergyReader = struct {
        buf: gremlin.Reader,
        _total_energy: f64 = 0.0,
        _duration: i64 = 0,
        _power_mw: f64 = 0.0,
        _rail_offset: ?usize = null,
        _rail_last_offset: ?usize = null,
        _rail_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!AndroidCodecMetrics.EnergyReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidCodecMetrics.EnergyReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidCodecMetrics.EnergyWire.TOTAL_ENERGY_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._total_energy = result.value;
                    },
                    AndroidCodecMetrics.EnergyWire.DURATION_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._duration = result.value;
                    },
                    AndroidCodecMetrics.EnergyWire.POWER_MW_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._power_mw = result.value;
                    },
                    AndroidCodecMetrics.EnergyWire.RAIL_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._rail_offset == null) {
                            res._rail_offset = offset - result.size;
                        }
                        res._rail_last_offset = offset;
                        res._rail_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getTotalEnergy(self: *const AndroidCodecMetrics.EnergyReader) f64 {
            return self._total_energy;
        }
        pub inline fn getDuration(self: *const AndroidCodecMetrics.EnergyReader) i64 {
            return self._duration;
        }
        pub inline fn getPowerMw(self: *const AndroidCodecMetrics.EnergyReader) f64 {
            return self._power_mw;
        }
        pub fn railCount(self: *const AndroidCodecMetrics.EnergyReader) usize {
            return self._rail_cnt;
        }
        pub fn railNext(self: *AndroidCodecMetrics.EnergyReader) ?AndroidCodecMetrics.RailReader {
            if (self._rail_offset == null) return null;
            const current_offset = self._rail_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = AndroidCodecMetrics.RailReader.init(result.value) catch return null;
            if (self._rail_last_offset != null and current_offset >= self._rail_last_offset.?) {
                self._rail_offset = null;
                return msg;
            }
            if (self._rail_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._rail_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidCodecMetrics.EnergyWire.RAIL_WIRE) {
                    self._rail_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._rail_offset = null;
            return msg;
        }
    };
    // fields
    cpu_usage: ?[]const ?AndroidCodecMetrics.CpuUsage = null,
    codec_function: ?[]const ?AndroidCodecMetrics.CodecFunction = null,
    energy: ?AndroidCodecMetrics.Energy = null,
    pub fn calcProtobufSize(self: *const AndroidCodecMetrics) usize {
        var res: usize = 0;
        if (self.cpu_usage) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidCodecMetricsWire.CPU_USAGE_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.codec_function) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidCodecMetricsWire.CODEC_FUNCTION_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.energy) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidCodecMetricsWire.ENERGY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidCodecMetrics, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidCodecMetrics, target: *gremlin.Writer) void {
        if (self.cpu_usage) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidCodecMetricsWire.CPU_USAGE_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidCodecMetricsWire.CPU_USAGE_WIRE, 0);
                }
            }
        }
        if (self.codec_function) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidCodecMetricsWire.CODEC_FUNCTION_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidCodecMetricsWire.CODEC_FUNCTION_WIRE, 0);
                }
            }
        }
        if (self.energy) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AndroidCodecMetricsWire.ENERGY_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const AndroidCodecMetricsReader = struct {
    buf: gremlin.Reader,
    _cpu_usage_offset: ?usize = null,
    _cpu_usage_last_offset: ?usize = null,
    _cpu_usage_cnt: usize = 0,
    _codec_function_offset: ?usize = null,
    _codec_function_last_offset: ?usize = null,
    _codec_function_cnt: usize = 0,
    _energy_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!AndroidCodecMetricsReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidCodecMetricsReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidCodecMetricsWire.CPU_USAGE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._cpu_usage_offset == null) {
                        res._cpu_usage_offset = offset - result.size;
                    }
                    res._cpu_usage_last_offset = offset;
                    res._cpu_usage_cnt += 1;
                },
                AndroidCodecMetricsWire.CODEC_FUNCTION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._codec_function_offset == null) {
                        res._codec_function_offset = offset - result.size;
                    }
                    res._codec_function_last_offset = offset;
                    res._codec_function_cnt += 1;
                },
                AndroidCodecMetricsWire.ENERGY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._energy_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn cpuUsageCount(self: *const AndroidCodecMetricsReader) usize {
        return self._cpu_usage_cnt;
    }
    pub fn cpuUsageNext(self: *AndroidCodecMetricsReader) ?AndroidCodecMetrics.CpuUsageReader {
        if (self._cpu_usage_offset == null) return null;
        const current_offset = self._cpu_usage_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidCodecMetrics.CpuUsageReader.init(result.value) catch return null;
        if (self._cpu_usage_last_offset != null and current_offset >= self._cpu_usage_last_offset.?) {
            self._cpu_usage_offset = null;
            return msg;
        }
        if (self._cpu_usage_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._cpu_usage_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidCodecMetricsWire.CPU_USAGE_WIRE) {
                self._cpu_usage_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._cpu_usage_offset = null;
        return msg;
    }
    pub fn codecFunctionCount(self: *const AndroidCodecMetricsReader) usize {
        return self._codec_function_cnt;
    }
    pub fn codecFunctionNext(self: *AndroidCodecMetricsReader) ?AndroidCodecMetrics.CodecFunctionReader {
        if (self._codec_function_offset == null) return null;
        const current_offset = self._codec_function_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidCodecMetrics.CodecFunctionReader.init(result.value) catch return null;
        if (self._codec_function_last_offset != null and current_offset >= self._codec_function_last_offset.?) {
            self._codec_function_offset = null;
            return msg;
        }
        if (self._codec_function_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._codec_function_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidCodecMetricsWire.CODEC_FUNCTION_WIRE) {
                self._codec_function_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._codec_function_offset = null;
        return msg;
    }
    pub fn getEnergy(self: *const AndroidCodecMetricsReader) gremlin.Error!AndroidCodecMetrics.EnergyReader {
        if (self._energy_buf) |buf| {
            return try AndroidCodecMetrics.EnergyReader.init(buf);
        }
        return try AndroidCodecMetrics.EnergyReader.init(&[_]u8{});
    }
};
