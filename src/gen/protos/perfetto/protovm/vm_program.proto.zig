// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// enums
pub const VmCursorEnum = enum(i32) {
    VM_CURSOR_UNSPECIFIED = 0,
    VM_CURSOR_SRC = 1,
    VM_CURSOR_DST = 2,
    VM_CURSOR_BOTH = 3,
};
// structs
const VmProgramWire = struct {
    const VERSION_WIRE: gremlin.ProtoWireNumber = 1;
    const INSTRUCTIONS_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const VmProgram = struct {
    // fields
    version: u32 = 0,
    instructions: ?[]const ?VmInstruction = null,
    pub fn calcProtobufSize(self: *const VmProgram) usize {
        var res: usize = 0;
        if (self.version != 0) {
            res += gremlin.sizes.sizeWireNumber(VmProgramWire.VERSION_WIRE) + gremlin.sizes.sizeU32(self.version);
        }
        if (self.instructions) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(VmProgramWire.INSTRUCTIONS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const VmProgram, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const VmProgram, target: *gremlin.Writer) void {
        if (self.version != 0) {
            target.appendUint32(VmProgramWire.VERSION_WIRE, self.version);
        }
        if (self.instructions) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(VmProgramWire.INSTRUCTIONS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(VmProgramWire.INSTRUCTIONS_WIRE, 0);
                }
            }
        }
    }
};
pub const VmProgramReader = struct {
    buf: gremlin.Reader,
    _version: u32 = 0,
    _instructions_offset: ?usize = null,
    _instructions_last_offset: ?usize = null,
    _instructions_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!VmProgramReader {
        const buf = gremlin.Reader.init(src);
        var res = VmProgramReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                VmProgramWire.VERSION_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._version = result.value;
                },
                VmProgramWire.INSTRUCTIONS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._instructions_offset == null) {
                        res._instructions_offset = offset - result.size;
                    }
                    res._instructions_last_offset = offset;
                    res._instructions_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getVersion(self: *const VmProgramReader) u32 {
        return self._version;
    }
    pub fn instructionsCount(self: *const VmProgramReader) usize {
        return self._instructions_cnt;
    }
    pub fn instructionsNext(self: *VmProgramReader) ?VmInstructionReader {
        if (self._instructions_offset == null) return null;
        const current_offset = self._instructions_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = VmInstructionReader.init(result.value) catch return null;
        if (self._instructions_last_offset != null and current_offset >= self._instructions_last_offset.?) {
            self._instructions_offset = null;
            return msg;
        }
        if (self._instructions_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._instructions_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == VmProgramWire.INSTRUCTIONS_WIRE) {
                self._instructions_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._instructions_offset = null;
        return msg;
    }
};
const VmInstructionWire = struct {
    const ABORT_LEVEL_WIRE: gremlin.ProtoWireNumber = 6;
    const NESTED_INSTRUCTIONS_WIRE: gremlin.ProtoWireNumber = 7;
    const SELECT_WIRE: gremlin.ProtoWireNumber = 1;
    const REG_LOAD_WIRE: gremlin.ProtoWireNumber = 2;
    const MERGE_WIRE: gremlin.ProtoWireNumber = 3;
    const SET_WIRE: gremlin.ProtoWireNumber = 4;
    const DEL_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const VmInstruction = struct {
    // nested enums
    pub const AbortLevel = enum(i32) {
        SKIP_CURRENT_INSTRUCTION = 1,
        SKIP_CURRENT_INSTRUCTION_AND_BREAK_OUTER = 2,
        ABORT = 3,
        _PROTOBUF_UNKNOWN = 0,
    };
    // fields
    abort_level: VmInstruction.AbortLevel = @enumFromInt(0),
    nested_instructions: ?[]const ?VmInstruction = null,
    select: ?VmOpSelect = null,
    reg_load: ?VmOpRegLoad = null,
    merge: ?VmOpMerge = null,
    set: ?VmOpSet = null,
    del: ?VmOpDel = null,
    pub fn calcProtobufSize(self: *const VmInstruction) usize {
        var res: usize = 0;
        if (@intFromEnum(self.abort_level) != 0) {
            res += gremlin.sizes.sizeWireNumber(VmInstructionWire.ABORT_LEVEL_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.abort_level));
        }
        if (self.nested_instructions) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(VmInstructionWire.NESTED_INSTRUCTIONS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.select) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(VmInstructionWire.SELECT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.reg_load) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(VmInstructionWire.REG_LOAD_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.merge) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(VmInstructionWire.MERGE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.set) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(VmInstructionWire.SET_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.del) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(VmInstructionWire.DEL_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const VmInstruction, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const VmInstruction, target: *gremlin.Writer) void {
        if (@intFromEnum(self.abort_level) != 0) {
            target.appendInt32(VmInstructionWire.ABORT_LEVEL_WIRE, @intFromEnum(self.abort_level));
        }
        if (self.nested_instructions) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(VmInstructionWire.NESTED_INSTRUCTIONS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(VmInstructionWire.NESTED_INSTRUCTIONS_WIRE, 0);
                }
            }
        }
        if (self.select) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(VmInstructionWire.SELECT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.reg_load) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(VmInstructionWire.REG_LOAD_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.merge) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(VmInstructionWire.MERGE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.set) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(VmInstructionWire.SET_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.del) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(VmInstructionWire.DEL_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const VmInstructionReader = struct {
    buf: gremlin.Reader,
    _abort_level: VmInstruction.AbortLevel = @enumFromInt(0),
    _nested_instructions_offset: ?usize = null,
    _nested_instructions_last_offset: ?usize = null,
    _nested_instructions_cnt: usize = 0,
    _select_buf: ?[]const u8 = null,
    _reg_load_buf: ?[]const u8 = null,
    _merge_buf: ?[]const u8 = null,
    _set_buf: ?[]const u8 = null,
    _del_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!VmInstructionReader {
        const buf = gremlin.Reader.init(src);
        var res = VmInstructionReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                VmInstructionWire.ABORT_LEVEL_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._abort_level = @enumFromInt(result.value);
                },
                VmInstructionWire.NESTED_INSTRUCTIONS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._nested_instructions_offset == null) {
                        res._nested_instructions_offset = offset - result.size;
                    }
                    res._nested_instructions_last_offset = offset;
                    res._nested_instructions_cnt += 1;
                },
                VmInstructionWire.SELECT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._select_buf = result.value;
                },
                VmInstructionWire.REG_LOAD_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._reg_load_buf = result.value;
                },
                VmInstructionWire.MERGE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._merge_buf = result.value;
                },
                VmInstructionWire.SET_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._set_buf = result.value;
                },
                VmInstructionWire.DEL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._del_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getAbortLevel(self: *const VmInstructionReader) VmInstruction.AbortLevel {
        return self._abort_level;
    }
    pub fn nestedInstructionsCount(self: *const VmInstructionReader) usize {
        return self._nested_instructions_cnt;
    }
    pub fn nestedInstructionsNext(self: *VmInstructionReader) ?VmInstructionReader {
        if (self._nested_instructions_offset == null) return null;
        const current_offset = self._nested_instructions_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = VmInstructionReader.init(result.value) catch return null;
        if (self._nested_instructions_last_offset != null and current_offset >= self._nested_instructions_last_offset.?) {
            self._nested_instructions_offset = null;
            return msg;
        }
        if (self._nested_instructions_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._nested_instructions_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == VmInstructionWire.NESTED_INSTRUCTIONS_WIRE) {
                self._nested_instructions_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._nested_instructions_offset = null;
        return msg;
    }
    pub fn getSelect(self: *const VmInstructionReader) gremlin.Error!VmOpSelectReader {
        if (self._select_buf) |buf| {
            return try VmOpSelectReader.init(buf);
        }
        return try VmOpSelectReader.init(&[_]u8{});
    }
    pub fn getRegLoad(self: *const VmInstructionReader) gremlin.Error!VmOpRegLoadReader {
        if (self._reg_load_buf) |buf| {
            return try VmOpRegLoadReader.init(buf);
        }
        return try VmOpRegLoadReader.init(&[_]u8{});
    }
    pub fn getMerge(self: *const VmInstructionReader) gremlin.Error!VmOpMergeReader {
        if (self._merge_buf) |buf| {
            return try VmOpMergeReader.init(buf);
        }
        return try VmOpMergeReader.init(&[_]u8{});
    }
    pub fn getSet(self: *const VmInstructionReader) gremlin.Error!VmOpSetReader {
        if (self._set_buf) |buf| {
            return try VmOpSetReader.init(buf);
        }
        return try VmOpSetReader.init(&[_]u8{});
    }
    pub fn getDel(self: *const VmInstructionReader) gremlin.Error!VmOpDelReader {
        if (self._del_buf) |buf| {
            return try VmOpDelReader.init(buf);
        }
        return try VmOpDelReader.init(&[_]u8{});
    }
};
const VmOpSelectWire = struct {
    const CURSOR_WIRE: gremlin.ProtoWireNumber = 1;
    const RELATIVE_PATH_WIRE: gremlin.ProtoWireNumber = 2;
    const CREATE_IF_NOT_EXIST_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const VmOpSelect = struct {
    // nested structs
    const PathComponentWire = struct {
        const IS_REPEATED_WIRE: gremlin.ProtoWireNumber = 5;
        const REGISTER_TO_MATCH_WIRE: gremlin.ProtoWireNumber = 6;
        const STORE_FOREACH_INDEX_INTO_REGISTER_WIRE: gremlin.ProtoWireNumber = 7;
        const FIELD_ID_WIRE: gremlin.ProtoWireNumber = 1;
        const ARRAY_INDEX_WIRE: gremlin.ProtoWireNumber = 2;
        const MAP_KEY_FIELD_ID_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const PathComponent = struct {
        // fields
        is_repeated: bool = false,
        register_to_match: u32 = 0,
        store_foreach_index_into_register: u32 = 0,
        field_id: u32 = 0,
        array_index: u32 = 0,
        map_key_field_id: u32 = 0,
        pub fn calcProtobufSize(self: *const VmOpSelect.PathComponent) usize {
            var res: usize = 0;
            if (self.is_repeated != false) {
                res += gremlin.sizes.sizeWireNumber(VmOpSelect.PathComponentWire.IS_REPEATED_WIRE) + gremlin.sizes.sizeBool(self.is_repeated);
            }
            if (self.register_to_match != 0) {
                res += gremlin.sizes.sizeWireNumber(VmOpSelect.PathComponentWire.REGISTER_TO_MATCH_WIRE) + gremlin.sizes.sizeU32(self.register_to_match);
            }
            if (self.store_foreach_index_into_register != 0) {
                res += gremlin.sizes.sizeWireNumber(VmOpSelect.PathComponentWire.STORE_FOREACH_INDEX_INTO_REGISTER_WIRE) + gremlin.sizes.sizeU32(self.store_foreach_index_into_register);
            }
            if (self.field_id != 0) {
                res += gremlin.sizes.sizeWireNumber(VmOpSelect.PathComponentWire.FIELD_ID_WIRE) + gremlin.sizes.sizeU32(self.field_id);
            }
            if (self.array_index != 0) {
                res += gremlin.sizes.sizeWireNumber(VmOpSelect.PathComponentWire.ARRAY_INDEX_WIRE) + gremlin.sizes.sizeU32(self.array_index);
            }
            if (self.map_key_field_id != 0) {
                res += gremlin.sizes.sizeWireNumber(VmOpSelect.PathComponentWire.MAP_KEY_FIELD_ID_WIRE) + gremlin.sizes.sizeU32(self.map_key_field_id);
            }
            return res;
        }
        pub fn encode(self: *const VmOpSelect.PathComponent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const VmOpSelect.PathComponent, target: *gremlin.Writer) void {
            if (self.is_repeated != false) {
                target.appendBool(VmOpSelect.PathComponentWire.IS_REPEATED_WIRE, self.is_repeated);
            }
            if (self.register_to_match != 0) {
                target.appendUint32(VmOpSelect.PathComponentWire.REGISTER_TO_MATCH_WIRE, self.register_to_match);
            }
            if (self.store_foreach_index_into_register != 0) {
                target.appendUint32(VmOpSelect.PathComponentWire.STORE_FOREACH_INDEX_INTO_REGISTER_WIRE, self.store_foreach_index_into_register);
            }
            if (self.field_id != 0) {
                target.appendUint32(VmOpSelect.PathComponentWire.FIELD_ID_WIRE, self.field_id);
            }
            if (self.array_index != 0) {
                target.appendUint32(VmOpSelect.PathComponentWire.ARRAY_INDEX_WIRE, self.array_index);
            }
            if (self.map_key_field_id != 0) {
                target.appendUint32(VmOpSelect.PathComponentWire.MAP_KEY_FIELD_ID_WIRE, self.map_key_field_id);
            }
        }
    };
    pub const PathComponentReader = struct {
        buf: gremlin.Reader,
        _is_repeated: bool = false,
        _register_to_match: u32 = 0,
        _store_foreach_index_into_register: u32 = 0,
        _field_id: u32 = 0,
        _array_index: u32 = 0,
        _map_key_field_id: u32 = 0,
        pub fn init(src: []const u8) gremlin.Error!VmOpSelect.PathComponentReader {
            const buf = gremlin.Reader.init(src);
            var res = VmOpSelect.PathComponentReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    VmOpSelect.PathComponentWire.IS_REPEATED_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._is_repeated = result.value;
                    },
                    VmOpSelect.PathComponentWire.REGISTER_TO_MATCH_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._register_to_match = result.value;
                    },
                    VmOpSelect.PathComponentWire.STORE_FOREACH_INDEX_INTO_REGISTER_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._store_foreach_index_into_register = result.value;
                    },
                    VmOpSelect.PathComponentWire.FIELD_ID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._field_id = result.value;
                    },
                    VmOpSelect.PathComponentWire.ARRAY_INDEX_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._array_index = result.value;
                    },
                    VmOpSelect.PathComponentWire.MAP_KEY_FIELD_ID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._map_key_field_id = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getIsRepeated(self: *const VmOpSelect.PathComponentReader) bool {
            return self._is_repeated;
        }
        pub inline fn getRegisterToMatch(self: *const VmOpSelect.PathComponentReader) u32 {
            return self._register_to_match;
        }
        pub inline fn getStoreForeachIndexIntoRegister(self: *const VmOpSelect.PathComponentReader) u32 {
            return self._store_foreach_index_into_register;
        }
        pub inline fn getFieldId(self: *const VmOpSelect.PathComponentReader) u32 {
            return self._field_id;
        }
        pub inline fn getArrayIndex(self: *const VmOpSelect.PathComponentReader) u32 {
            return self._array_index;
        }
        pub inline fn getMapKeyFieldId(self: *const VmOpSelect.PathComponentReader) u32 {
            return self._map_key_field_id;
        }
    };
    // fields
    cursor: VmCursorEnum = @enumFromInt(0),
    relative_path: ?[]const ?VmOpSelect.PathComponent = null,
    create_if_not_exist: bool = false,
    pub fn calcProtobufSize(self: *const VmOpSelect) usize {
        var res: usize = 0;
        if (@intFromEnum(self.cursor) != 0) {
            res += gremlin.sizes.sizeWireNumber(VmOpSelectWire.CURSOR_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.cursor));
        }
        if (self.relative_path) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(VmOpSelectWire.RELATIVE_PATH_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.create_if_not_exist != false) {
            res += gremlin.sizes.sizeWireNumber(VmOpSelectWire.CREATE_IF_NOT_EXIST_WIRE) + gremlin.sizes.sizeBool(self.create_if_not_exist);
        }
        return res;
    }
    pub fn encode(self: *const VmOpSelect, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const VmOpSelect, target: *gremlin.Writer) void {
        if (@intFromEnum(self.cursor) != 0) {
            target.appendInt32(VmOpSelectWire.CURSOR_WIRE, @intFromEnum(self.cursor));
        }
        if (self.relative_path) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(VmOpSelectWire.RELATIVE_PATH_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(VmOpSelectWire.RELATIVE_PATH_WIRE, 0);
                }
            }
        }
        if (self.create_if_not_exist != false) {
            target.appendBool(VmOpSelectWire.CREATE_IF_NOT_EXIST_WIRE, self.create_if_not_exist);
        }
    }
};
pub const VmOpSelectReader = struct {
    buf: gremlin.Reader,
    _cursor: VmCursorEnum = @enumFromInt(0),
    _relative_path_offset: ?usize = null,
    _relative_path_last_offset: ?usize = null,
    _relative_path_cnt: usize = 0,
    _create_if_not_exist: bool = false,
    pub fn init(src: []const u8) gremlin.Error!VmOpSelectReader {
        const buf = gremlin.Reader.init(src);
        var res = VmOpSelectReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                VmOpSelectWire.CURSOR_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._cursor = @enumFromInt(result.value);
                },
                VmOpSelectWire.RELATIVE_PATH_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._relative_path_offset == null) {
                        res._relative_path_offset = offset - result.size;
                    }
                    res._relative_path_last_offset = offset;
                    res._relative_path_cnt += 1;
                },
                VmOpSelectWire.CREATE_IF_NOT_EXIST_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._create_if_not_exist = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getCursor(self: *const VmOpSelectReader) VmCursorEnum {
        return self._cursor;
    }
    pub fn relativePathCount(self: *const VmOpSelectReader) usize {
        return self._relative_path_cnt;
    }
    pub fn relativePathNext(self: *VmOpSelectReader) ?VmOpSelect.PathComponentReader {
        if (self._relative_path_offset == null) return null;
        const current_offset = self._relative_path_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = VmOpSelect.PathComponentReader.init(result.value) catch return null;
        if (self._relative_path_last_offset != null and current_offset >= self._relative_path_last_offset.?) {
            self._relative_path_offset = null;
            return msg;
        }
        if (self._relative_path_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._relative_path_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == VmOpSelectWire.RELATIVE_PATH_WIRE) {
                self._relative_path_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._relative_path_offset = null;
        return msg;
    }
    pub inline fn getCreateIfNotExist(self: *const VmOpSelectReader) bool {
        return self._create_if_not_exist;
    }
};
const VmOpRegLoadWire = struct {
    const CURSOR_WIRE: gremlin.ProtoWireNumber = 1;
    const DST_REGISTER_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const VmOpRegLoad = struct {
    // fields
    cursor: VmCursorEnum = @enumFromInt(0),
    dst_register: u32 = 0,
    pub fn calcProtobufSize(self: *const VmOpRegLoad) usize {
        var res: usize = 0;
        if (@intFromEnum(self.cursor) != 0) {
            res += gremlin.sizes.sizeWireNumber(VmOpRegLoadWire.CURSOR_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.cursor));
        }
        if (self.dst_register != 0) {
            res += gremlin.sizes.sizeWireNumber(VmOpRegLoadWire.DST_REGISTER_WIRE) + gremlin.sizes.sizeU32(self.dst_register);
        }
        return res;
    }
    pub fn encode(self: *const VmOpRegLoad, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const VmOpRegLoad, target: *gremlin.Writer) void {
        if (@intFromEnum(self.cursor) != 0) {
            target.appendInt32(VmOpRegLoadWire.CURSOR_WIRE, @intFromEnum(self.cursor));
        }
        if (self.dst_register != 0) {
            target.appendUint32(VmOpRegLoadWire.DST_REGISTER_WIRE, self.dst_register);
        }
    }
};
pub const VmOpRegLoadReader = struct {
    buf: gremlin.Reader,
    _cursor: VmCursorEnum = @enumFromInt(0),
    _dst_register: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!VmOpRegLoadReader {
        const buf = gremlin.Reader.init(src);
        var res = VmOpRegLoadReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                VmOpRegLoadWire.CURSOR_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._cursor = @enumFromInt(result.value);
                },
                VmOpRegLoadWire.DST_REGISTER_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._dst_register = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getCursor(self: *const VmOpRegLoadReader) VmCursorEnum {
        return self._cursor;
    }
    pub inline fn getDstRegister(self: *const VmOpRegLoadReader) u32 {
        return self._dst_register;
    }
};
pub const VmOpMerge = struct {
    pub fn calcProtobufSize(_: *const VmOpMerge) usize {
        return 0;
    }
    pub fn encode(self: *const VmOpMerge, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(_: *const VmOpMerge, _: *gremlin.Writer) void {}
};
pub const VmOpMergeReader = struct {
    buf: gremlin.Reader,
    pub fn init(src: []const u8) gremlin.Error!VmOpMergeReader {
        const buf = gremlin.Reader.init(src);
        return VmOpMergeReader{ .buf = buf };
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
};
pub const VmOpSet = struct {
    pub fn calcProtobufSize(_: *const VmOpSet) usize {
        return 0;
    }
    pub fn encode(self: *const VmOpSet, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(_: *const VmOpSet, _: *gremlin.Writer) void {}
};
pub const VmOpSetReader = struct {
    buf: gremlin.Reader,
    pub fn init(src: []const u8) gremlin.Error!VmOpSetReader {
        const buf = gremlin.Reader.init(src);
        return VmOpSetReader{ .buf = buf };
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
};
pub const VmOpDel = struct {
    pub fn calcProtobufSize(_: *const VmOpDel) usize {
        return 0;
    }
    pub fn encode(self: *const VmOpDel, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(_: *const VmOpDel, _: *gremlin.Writer) void {}
};
pub const VmOpDelReader = struct {
    buf: gremlin.Reader,
    pub fn init(src: []const u8) gremlin.Error!VmOpDelReader {
        const buf = gremlin.Reader.init(src);
        return VmOpDelReader{ .buf = buf };
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
};
