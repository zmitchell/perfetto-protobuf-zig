// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
const trace_config = @import("trace_config.proto.zig");
// structs
const StressTestConfigWire = struct {
    const TRACE_CONFIG_WIRE: gremlin.ProtoWireNumber = 1;
    const SHMEM_SIZE_KB_WIRE: gremlin.ProtoWireNumber = 2;
    const SHMEM_PAGE_SIZE_KB_WIRE: gremlin.ProtoWireNumber = 3;
    const NUM_PROCESSES_WIRE: gremlin.ProtoWireNumber = 4;
    const NUM_THREADS_WIRE: gremlin.ProtoWireNumber = 5;
    const MAX_EVENTS_WIRE: gremlin.ProtoWireNumber = 6;
    const NESTING_WIRE: gremlin.ProtoWireNumber = 7;
    const STEADY_STATE_TIMINGS_WIRE: gremlin.ProtoWireNumber = 8;
    const BURST_PERIOD_MS_WIRE: gremlin.ProtoWireNumber = 9;
    const BURST_DURATION_MS_WIRE: gremlin.ProtoWireNumber = 10;
    const BURST_TIMINGS_WIRE: gremlin.ProtoWireNumber = 11;
};
pub const StressTestConfig = struct {
    // nested structs
    const WriterTimingWire = struct {
        const PAYLOAD_MEAN_WIRE: gremlin.ProtoWireNumber = 1;
        const PAYLOAD_STDDEV_WIRE: gremlin.ProtoWireNumber = 2;
        const RATE_MEAN_WIRE: gremlin.ProtoWireNumber = 3;
        const RATE_STDDEV_WIRE: gremlin.ProtoWireNumber = 4;
        const PAYLOAD_WRITE_TIME_MS_WIRE: gremlin.ProtoWireNumber = 5;
    };
    pub const WriterTiming = struct {
        // fields
        payload_mean: f64 = 0.0,
        payload_stddev: f64 = 0.0,
        rate_mean: f64 = 0.0,
        rate_stddev: f64 = 0.0,
        payload_write_time_ms: u32 = 0,
        pub fn calcProtobufSize(self: *const StressTestConfig.WriterTiming) usize {
            var res: usize = 0;
            if (self.payload_mean != 0.0) {
                res += gremlin.sizes.sizeWireNumber(StressTestConfig.WriterTimingWire.PAYLOAD_MEAN_WIRE) + gremlin.sizes.sizeDouble(self.payload_mean);
            }
            if (self.payload_stddev != 0.0) {
                res += gremlin.sizes.sizeWireNumber(StressTestConfig.WriterTimingWire.PAYLOAD_STDDEV_WIRE) + gremlin.sizes.sizeDouble(self.payload_stddev);
            }
            if (self.rate_mean != 0.0) {
                res += gremlin.sizes.sizeWireNumber(StressTestConfig.WriterTimingWire.RATE_MEAN_WIRE) + gremlin.sizes.sizeDouble(self.rate_mean);
            }
            if (self.rate_stddev != 0.0) {
                res += gremlin.sizes.sizeWireNumber(StressTestConfig.WriterTimingWire.RATE_STDDEV_WIRE) + gremlin.sizes.sizeDouble(self.rate_stddev);
            }
            if (self.payload_write_time_ms != 0) {
                res += gremlin.sizes.sizeWireNumber(StressTestConfig.WriterTimingWire.PAYLOAD_WRITE_TIME_MS_WIRE) + gremlin.sizes.sizeU32(self.payload_write_time_ms);
            }
            return res;
        }
        pub fn encode(self: *const StressTestConfig.WriterTiming, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const StressTestConfig.WriterTiming, target: *gremlin.Writer) void {
            if (self.payload_mean != 0.0) {
                target.appendFloat64(StressTestConfig.WriterTimingWire.PAYLOAD_MEAN_WIRE, self.payload_mean);
            }
            if (self.payload_stddev != 0.0) {
                target.appendFloat64(StressTestConfig.WriterTimingWire.PAYLOAD_STDDEV_WIRE, self.payload_stddev);
            }
            if (self.rate_mean != 0.0) {
                target.appendFloat64(StressTestConfig.WriterTimingWire.RATE_MEAN_WIRE, self.rate_mean);
            }
            if (self.rate_stddev != 0.0) {
                target.appendFloat64(StressTestConfig.WriterTimingWire.RATE_STDDEV_WIRE, self.rate_stddev);
            }
            if (self.payload_write_time_ms != 0) {
                target.appendUint32(StressTestConfig.WriterTimingWire.PAYLOAD_WRITE_TIME_MS_WIRE, self.payload_write_time_ms);
            }
        }
    };
    pub const WriterTimingReader = struct {
        buf: gremlin.Reader,
        _payload_mean: f64 = 0.0,
        _payload_stddev: f64 = 0.0,
        _rate_mean: f64 = 0.0,
        _rate_stddev: f64 = 0.0,
        _payload_write_time_ms: u32 = 0,
        pub fn init(src: []const u8) gremlin.Error!StressTestConfig.WriterTimingReader {
            const buf = gremlin.Reader.init(src);
            var res = StressTestConfig.WriterTimingReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    StressTestConfig.WriterTimingWire.PAYLOAD_MEAN_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._payload_mean = result.value;
                    },
                    StressTestConfig.WriterTimingWire.PAYLOAD_STDDEV_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._payload_stddev = result.value;
                    },
                    StressTestConfig.WriterTimingWire.RATE_MEAN_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._rate_mean = result.value;
                    },
                    StressTestConfig.WriterTimingWire.RATE_STDDEV_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._rate_stddev = result.value;
                    },
                    StressTestConfig.WriterTimingWire.PAYLOAD_WRITE_TIME_MS_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._payload_write_time_ms = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getPayloadMean(self: *const StressTestConfig.WriterTimingReader) f64 {
            return self._payload_mean;
        }
        pub inline fn getPayloadStddev(self: *const StressTestConfig.WriterTimingReader) f64 {
            return self._payload_stddev;
        }
        pub inline fn getRateMean(self: *const StressTestConfig.WriterTimingReader) f64 {
            return self._rate_mean;
        }
        pub inline fn getRateStddev(self: *const StressTestConfig.WriterTimingReader) f64 {
            return self._rate_stddev;
        }
        pub inline fn getPayloadWriteTimeMs(self: *const StressTestConfig.WriterTimingReader) u32 {
            return self._payload_write_time_ms;
        }
    };
    // fields
    trace_config: ?trace_config.TraceConfig = null,
    shmem_size_kb: u32 = 0,
    shmem_page_size_kb: u32 = 0,
    num_processes: u32 = 0,
    num_threads: u32 = 0,
    max_events: u32 = 0,
    nesting: u32 = 0,
    steady_state_timings: ?StressTestConfig.WriterTiming = null,
    burst_period_ms: u32 = 0,
    burst_duration_ms: u32 = 0,
    burst_timings: ?StressTestConfig.WriterTiming = null,
    pub fn calcProtobufSize(self: *const StressTestConfig) usize {
        var res: usize = 0;
        if (self.trace_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(StressTestConfigWire.TRACE_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.shmem_size_kb != 0) {
            res += gremlin.sizes.sizeWireNumber(StressTestConfigWire.SHMEM_SIZE_KB_WIRE) + gremlin.sizes.sizeU32(self.shmem_size_kb);
        }
        if (self.shmem_page_size_kb != 0) {
            res += gremlin.sizes.sizeWireNumber(StressTestConfigWire.SHMEM_PAGE_SIZE_KB_WIRE) + gremlin.sizes.sizeU32(self.shmem_page_size_kb);
        }
        if (self.num_processes != 0) {
            res += gremlin.sizes.sizeWireNumber(StressTestConfigWire.NUM_PROCESSES_WIRE) + gremlin.sizes.sizeU32(self.num_processes);
        }
        if (self.num_threads != 0) {
            res += gremlin.sizes.sizeWireNumber(StressTestConfigWire.NUM_THREADS_WIRE) + gremlin.sizes.sizeU32(self.num_threads);
        }
        if (self.max_events != 0) {
            res += gremlin.sizes.sizeWireNumber(StressTestConfigWire.MAX_EVENTS_WIRE) + gremlin.sizes.sizeU32(self.max_events);
        }
        if (self.nesting != 0) {
            res += gremlin.sizes.sizeWireNumber(StressTestConfigWire.NESTING_WIRE) + gremlin.sizes.sizeU32(self.nesting);
        }
        if (self.steady_state_timings) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(StressTestConfigWire.STEADY_STATE_TIMINGS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.burst_period_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(StressTestConfigWire.BURST_PERIOD_MS_WIRE) + gremlin.sizes.sizeU32(self.burst_period_ms);
        }
        if (self.burst_duration_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(StressTestConfigWire.BURST_DURATION_MS_WIRE) + gremlin.sizes.sizeU32(self.burst_duration_ms);
        }
        if (self.burst_timings) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(StressTestConfigWire.BURST_TIMINGS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const StressTestConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const StressTestConfig, target: *gremlin.Writer) void {
        if (self.trace_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(StressTestConfigWire.TRACE_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.shmem_size_kb != 0) {
            target.appendUint32(StressTestConfigWire.SHMEM_SIZE_KB_WIRE, self.shmem_size_kb);
        }
        if (self.shmem_page_size_kb != 0) {
            target.appendUint32(StressTestConfigWire.SHMEM_PAGE_SIZE_KB_WIRE, self.shmem_page_size_kb);
        }
        if (self.num_processes != 0) {
            target.appendUint32(StressTestConfigWire.NUM_PROCESSES_WIRE, self.num_processes);
        }
        if (self.num_threads != 0) {
            target.appendUint32(StressTestConfigWire.NUM_THREADS_WIRE, self.num_threads);
        }
        if (self.max_events != 0) {
            target.appendUint32(StressTestConfigWire.MAX_EVENTS_WIRE, self.max_events);
        }
        if (self.nesting != 0) {
            target.appendUint32(StressTestConfigWire.NESTING_WIRE, self.nesting);
        }
        if (self.steady_state_timings) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(StressTestConfigWire.STEADY_STATE_TIMINGS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.burst_period_ms != 0) {
            target.appendUint32(StressTestConfigWire.BURST_PERIOD_MS_WIRE, self.burst_period_ms);
        }
        if (self.burst_duration_ms != 0) {
            target.appendUint32(StressTestConfigWire.BURST_DURATION_MS_WIRE, self.burst_duration_ms);
        }
        if (self.burst_timings) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(StressTestConfigWire.BURST_TIMINGS_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const StressTestConfigReader = struct {
    buf: gremlin.Reader,
    _trace_config_buf: ?[]const u8 = null,
    _shmem_size_kb: u32 = 0,
    _shmem_page_size_kb: u32 = 0,
    _num_processes: u32 = 0,
    _num_threads: u32 = 0,
    _max_events: u32 = 0,
    _nesting: u32 = 0,
    _steady_state_timings_buf: ?[]const u8 = null,
    _burst_period_ms: u32 = 0,
    _burst_duration_ms: u32 = 0,
    _burst_timings_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!StressTestConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = StressTestConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                StressTestConfigWire.TRACE_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._trace_config_buf = result.value;
                },
                StressTestConfigWire.SHMEM_SIZE_KB_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._shmem_size_kb = result.value;
                },
                StressTestConfigWire.SHMEM_PAGE_SIZE_KB_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._shmem_page_size_kb = result.value;
                },
                StressTestConfigWire.NUM_PROCESSES_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._num_processes = result.value;
                },
                StressTestConfigWire.NUM_THREADS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._num_threads = result.value;
                },
                StressTestConfigWire.MAX_EVENTS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._max_events = result.value;
                },
                StressTestConfigWire.NESTING_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._nesting = result.value;
                },
                StressTestConfigWire.STEADY_STATE_TIMINGS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._steady_state_timings_buf = result.value;
                },
                StressTestConfigWire.BURST_PERIOD_MS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._burst_period_ms = result.value;
                },
                StressTestConfigWire.BURST_DURATION_MS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._burst_duration_ms = result.value;
                },
                StressTestConfigWire.BURST_TIMINGS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._burst_timings_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getTraceConfig(self: *const StressTestConfigReader) gremlin.Error!trace_config.TraceConfigReader {
        if (self._trace_config_buf) |buf| {
            return try trace_config.TraceConfigReader.init(buf);
        }
        return try trace_config.TraceConfigReader.init(&[_]u8{});
    }
    pub inline fn getShmemSizeKb(self: *const StressTestConfigReader) u32 {
        return self._shmem_size_kb;
    }
    pub inline fn getShmemPageSizeKb(self: *const StressTestConfigReader) u32 {
        return self._shmem_page_size_kb;
    }
    pub inline fn getNumProcesses(self: *const StressTestConfigReader) u32 {
        return self._num_processes;
    }
    pub inline fn getNumThreads(self: *const StressTestConfigReader) u32 {
        return self._num_threads;
    }
    pub inline fn getMaxEvents(self: *const StressTestConfigReader) u32 {
        return self._max_events;
    }
    pub inline fn getNesting(self: *const StressTestConfigReader) u32 {
        return self._nesting;
    }
    pub fn getSteadyStateTimings(self: *const StressTestConfigReader) gremlin.Error!StressTestConfig.WriterTimingReader {
        if (self._steady_state_timings_buf) |buf| {
            return try StressTestConfig.WriterTimingReader.init(buf);
        }
        return try StressTestConfig.WriterTimingReader.init(&[_]u8{});
    }
    pub inline fn getBurstPeriodMs(self: *const StressTestConfigReader) u32 {
        return self._burst_period_ms;
    }
    pub inline fn getBurstDurationMs(self: *const StressTestConfigReader) u32 {
        return self._burst_duration_ms;
    }
    pub fn getBurstTimings(self: *const StressTestConfigReader) gremlin.Error!StressTestConfig.WriterTimingReader {
        if (self._burst_timings_buf) |buf| {
            return try StressTestConfig.WriterTimingReader.init(buf);
        }
        return try StressTestConfig.WriterTimingReader.init(&[_]u8{});
    }
};
