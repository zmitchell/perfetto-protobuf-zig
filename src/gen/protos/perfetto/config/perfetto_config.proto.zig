// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// enums
pub const BuiltinClock = enum(i32) {
    BUILTIN_CLOCK_UNKNOWN = 0,
    BUILTIN_CLOCK_REALTIME = 1,
    BUILTIN_CLOCK_REALTIME_COARSE = 2,
    BUILTIN_CLOCK_MONOTONIC = 3,
    BUILTIN_CLOCK_MONOTONIC_COARSE = 4,
    BUILTIN_CLOCK_MONOTONIC_RAW = 5,
    BUILTIN_CLOCK_BOOTTIME = 6,
    BUILTIN_CLOCK_TSC = 9,
    BUILTIN_CLOCK_PERF = 10,
    BUILTIN_CLOCK_MAX_ID = 63,
};
pub const AndroidLogId = enum(i32) {
    LID_DEFAULT = 0,
    LID_RADIO = 1,
    LID_EVENTS = 2,
    LID_SYSTEM = 3,
    LID_CRASH = 4,
    LID_STATS = 5,
    LID_SECURITY = 6,
    LID_KERNEL = 7,
};
pub const AndroidLogPriority = enum(i32) {
    PRIO_UNSPECIFIED = 0,
    PRIO_UNUSED = 1,
    PRIO_VERBOSE = 2,
    PRIO_DEBUG = 3,
    PRIO_INFO = 4,
    PRIO_WARN = 5,
    PRIO_ERROR = 6,
    PRIO_FATAL = 7,
};
pub const ProtoLogLevel = enum(i32) {
    PROTOLOG_LEVEL_UNDEFINED = 0,
    PROTOLOG_LEVEL_DEBUG = 1,
    PROTOLOG_LEVEL_VERBOSE = 2,
    PROTOLOG_LEVEL_INFO = 3,
    PROTOLOG_LEVEL_WARN = 4,
    PROTOLOG_LEVEL_ERROR = 5,
    PROTOLOG_LEVEL_WTF = 6,
};
pub const AtomId = enum(i32) {
    ATOM_UNSPECIFIED = 0,
    ATOM_BLE_SCAN_STATE_CHANGED = 2,
    ATOM_PROCESS_STATE_CHANGED = 3,
    ATOM_BLE_SCAN_RESULT_RECEIVED = 4,
    ATOM_SENSOR_STATE_CHANGED = 5,
    ATOM_GPS_SCAN_STATE_CHANGED = 6,
    ATOM_SYNC_STATE_CHANGED = 7,
    ATOM_SCHEDULED_JOB_STATE_CHANGED = 8,
    ATOM_SCREEN_BRIGHTNESS_CHANGED = 9,
    ATOM_WAKELOCK_STATE_CHANGED = 10,
    ATOM_LONG_PARTIAL_WAKELOCK_STATE_CHANGED = 11,
    ATOM_MOBILE_RADIO_POWER_STATE_CHANGED = 12,
    ATOM_WIFI_RADIO_POWER_STATE_CHANGED = 13,
    ATOM_ACTIVITY_MANAGER_SLEEP_STATE_CHANGED = 14,
    ATOM_MEMORY_FACTOR_STATE_CHANGED = 15,
    ATOM_EXCESSIVE_CPU_USAGE_REPORTED = 16,
    ATOM_CACHED_KILL_REPORTED = 17,
    ATOM_PROCESS_MEMORY_STAT_REPORTED = 18,
    ATOM_LAUNCHER_EVENT = 19,
    ATOM_BATTERY_SAVER_MODE_STATE_CHANGED = 20,
    ATOM_DEVICE_IDLE_MODE_STATE_CHANGED = 21,
    ATOM_DEVICE_IDLING_MODE_STATE_CHANGED = 22,
    ATOM_AUDIO_STATE_CHANGED = 23,
    ATOM_MEDIA_CODEC_STATE_CHANGED = 24,
    ATOM_CAMERA_STATE_CHANGED = 25,
    ATOM_FLASHLIGHT_STATE_CHANGED = 26,
    ATOM_UID_PROCESS_STATE_CHANGED = 27,
    ATOM_PROCESS_LIFE_CYCLE_STATE_CHANGED = 28,
    ATOM_SCREEN_STATE_CHANGED = 29,
    ATOM_BATTERY_LEVEL_CHANGED = 30,
    ATOM_CHARGING_STATE_CHANGED = 31,
    ATOM_PLUGGED_STATE_CHANGED = 32,
    ATOM_INTERACTIVE_STATE_CHANGED = 33,
    ATOM_TOUCH_EVENT_REPORTED = 34,
    ATOM_WAKEUP_ALARM_OCCURRED = 35,
    ATOM_KERNEL_WAKEUP_REPORTED = 36,
    ATOM_WIFI_LOCK_STATE_CHANGED = 37,
    ATOM_WIFI_SIGNAL_STRENGTH_CHANGED = 38,
    ATOM_WIFI_SCAN_STATE_CHANGED = 39,
    ATOM_PHONE_SIGNAL_STRENGTH_CHANGED = 40,
    ATOM_SETTING_CHANGED = 41,
    ATOM_ACTIVITY_FOREGROUND_STATE_CHANGED = 42,
    ATOM_ISOLATED_UID_CHANGED = 43,
    ATOM_PACKET_WAKEUP_OCCURRED = 44,
    ATOM_WALL_CLOCK_TIME_SHIFTED = 45,
    ATOM_ANOMALY_DETECTED = 46,
    ATOM_APP_BREADCRUMB_REPORTED = 47,
    ATOM_APP_START_OCCURRED = 48,
    ATOM_APP_START_CANCELED = 49,
    ATOM_APP_START_FULLY_DRAWN = 50,
    ATOM_LMK_KILL_OCCURRED = 51,
    ATOM_PICTURE_IN_PICTURE_STATE_CHANGED = 52,
    ATOM_WIFI_MULTICAST_LOCK_STATE_CHANGED = 53,
    ATOM_APP_START_MEMORY_STATE_CAPTURED = 55,
    ATOM_SHUTDOWN_SEQUENCE_REPORTED = 56,
    ATOM_BOOT_SEQUENCE_REPORTED = 57,
    ATOM_OVERLAY_STATE_CHANGED = 59,
    ATOM_FOREGROUND_SERVICE_STATE_CHANGED = 60,
    ATOM_CALL_STATE_CHANGED = 61,
    ATOM_KEYGUARD_STATE_CHANGED = 62,
    ATOM_KEYGUARD_BOUNCER_STATE_CHANGED = 63,
    ATOM_KEYGUARD_BOUNCER_PASSWORD_ENTERED = 64,
    ATOM_APP_DIED = 65,
    ATOM_RESOURCE_CONFIGURATION_CHANGED = 66,
    ATOM_BLUETOOTH_ENABLED_STATE_CHANGED = 67,
    ATOM_BLUETOOTH_CONNECTION_STATE_CHANGED = 68,
    ATOM_GPS_SIGNAL_QUALITY_CHANGED = 69,
    ATOM_USB_CONNECTOR_STATE_CHANGED = 70,
    ATOM_SPEAKER_IMPEDANCE_REPORTED = 71,
    ATOM_HARDWARE_FAILED = 72,
    ATOM_PHYSICAL_DROP_DETECTED = 73,
    ATOM_CHARGE_CYCLES_REPORTED = 74,
    ATOM_MOBILE_CONNECTION_STATE_CHANGED = 75,
    ATOM_MOBILE_RADIO_TECHNOLOGY_CHANGED = 76,
    ATOM_USB_DEVICE_ATTACHED = 77,
    ATOM_APP_CRASH_OCCURRED = 78,
    ATOM_ANR_OCCURRED = 79,
    ATOM_WTF_OCCURRED = 80,
    ATOM_LOW_MEM_REPORTED = 81,
    ATOM_GENERIC_ATOM = 82,
    ATOM_VIBRATOR_STATE_CHANGED = 84,
    ATOM_DEFERRED_JOB_STATS_REPORTED = 85,
    ATOM_THERMAL_THROTTLING = 86,
    ATOM_BIOMETRIC_ACQUIRED = 87,
    ATOM_BIOMETRIC_AUTHENTICATED = 88,
    ATOM_BIOMETRIC_ERROR_OCCURRED = 89,
    ATOM_UI_EVENT_REPORTED = 90,
    ATOM_BATTERY_HEALTH_SNAPSHOT = 91,
    ATOM_SLOW_IO = 92,
    ATOM_BATTERY_CAUSED_SHUTDOWN = 93,
    ATOM_PHONE_SERVICE_STATE_CHANGED = 94,
    ATOM_PHONE_STATE_CHANGED = 95,
    ATOM_USER_RESTRICTION_CHANGED = 96,
    ATOM_SETTINGS_UI_CHANGED = 97,
    ATOM_CONNECTIVITY_STATE_CHANGED = 98,
    ATOM_SERVICE_STATE_CHANGED = 99,
    ATOM_SERVICE_LAUNCH_REPORTED = 100,
    ATOM_FLAG_FLIP_UPDATE_OCCURRED = 101,
    ATOM_BINARY_PUSH_STATE_CHANGED = 102,
    ATOM_DEVICE_POLICY_EVENT = 103,
    ATOM_DOCS_UI_FILE_OP_CANCELED = 104,
    ATOM_DOCS_UI_FILE_OP_COPY_MOVE_MODE_REPORTED = 105,
    ATOM_DOCS_UI_FILE_OP_FAILURE = 106,
    ATOM_DOCS_UI_PROVIDER_FILE_OP = 107,
    ATOM_DOCS_UI_INVALID_SCOPED_ACCESS_REQUEST = 108,
    ATOM_DOCS_UI_LAUNCH_REPORTED = 109,
    ATOM_DOCS_UI_ROOT_VISITED = 110,
    ATOM_DOCS_UI_STARTUP_MS = 111,
    ATOM_DOCS_UI_USER_ACTION_REPORTED = 112,
    ATOM_WIFI_ENABLED_STATE_CHANGED = 113,
    ATOM_WIFI_RUNNING_STATE_CHANGED = 114,
    ATOM_APP_COMPACTED = 115,
    ATOM_NETWORK_DNS_EVENT_REPORTED = 116,
    ATOM_DOCS_UI_PICKER_LAUNCHED_FROM_REPORTED = 117,
    ATOM_DOCS_UI_PICK_RESULT_REPORTED = 118,
    ATOM_DOCS_UI_SEARCH_MODE_REPORTED = 119,
    ATOM_DOCS_UI_SEARCH_TYPE_REPORTED = 120,
    ATOM_DATA_STALL_EVENT = 121,
    ATOM_RESCUE_PARTY_RESET_REPORTED = 122,
    ATOM_SIGNED_CONFIG_REPORTED = 123,
    ATOM_GNSS_NI_EVENT_REPORTED = 124,
    ATOM_BLUETOOTH_LINK_LAYER_CONNECTION_EVENT = 125,
    ATOM_BLUETOOTH_ACL_CONNECTION_STATE_CHANGED = 126,
    ATOM_BLUETOOTH_SCO_CONNECTION_STATE_CHANGED = 127,
    ATOM_APP_DOWNGRADED = 128,
    ATOM_APP_OPTIMIZED_AFTER_DOWNGRADED = 129,
    ATOM_LOW_STORAGE_STATE_CHANGED = 130,
    ATOM_GNSS_NFW_NOTIFICATION_REPORTED = 131,
    ATOM_GNSS_CONFIGURATION_REPORTED = 132,
    ATOM_USB_PORT_OVERHEAT_EVENT_REPORTED = 133,
    ATOM_NFC_ERROR_OCCURRED = 134,
    ATOM_NFC_STATE_CHANGED = 135,
    ATOM_NFC_BEAM_OCCURRED = 136,
    ATOM_NFC_CARDEMULATION_OCCURRED = 137,
    ATOM_NFC_TAG_OCCURRED = 138,
    ATOM_NFC_HCE_TRANSACTION_OCCURRED = 139,
    ATOM_SE_STATE_CHANGED = 140,
    ATOM_SE_OMAPI_REPORTED = 141,
    ATOM_BROADCAST_DISPATCH_LATENCY_REPORTED = 142,
    ATOM_ATTENTION_MANAGER_SERVICE_RESULT_REPORTED = 143,
    ATOM_ADB_CONNECTION_CHANGED = 144,
    ATOM_SPEECH_DSP_STAT_REPORTED = 145,
    ATOM_USB_CONTAMINANT_REPORTED = 146,
    ATOM_WATCHDOG_ROLLBACK_OCCURRED = 147,
    ATOM_BIOMETRIC_SYSTEM_HEALTH_ISSUE_DETECTED = 148,
    ATOM_BUBBLE_UI_CHANGED = 149,
    ATOM_SCHEDULED_JOB_CONSTRAINT_CHANGED = 150,
    ATOM_BLUETOOTH_ACTIVE_DEVICE_CHANGED = 151,
    ATOM_BLUETOOTH_A2_DP_PLAYBACK_STATE_CHANGED = 152,
    ATOM_BLUETOOTH_A2_DP_CODEC_CONFIG_CHANGED = 153,
    ATOM_BLUETOOTH_A2_DP_CODEC_CAPABILITY_CHANGED = 154,
    ATOM_BLUETOOTH_A2_DP_AUDIO_UNDERRUN_REPORTED = 155,
    ATOM_BLUETOOTH_A2_DP_AUDIO_OVERRUN_REPORTED = 156,
    ATOM_BLUETOOTH_DEVICE_RSSI_REPORTED = 157,
    ATOM_BLUETOOTH_DEVICE_FAILED_CONTACT_COUNTER_REPORTED = 158,
    ATOM_BLUETOOTH_DEVICE_TX_POWER_LEVEL_REPORTED = 159,
    ATOM_BLUETOOTH_HCI_TIMEOUT_REPORTED = 160,
    ATOM_BLUETOOTH_QUALITY_REPORT_REPORTED = 161,
    ATOM_BLUETOOTH_DEVICE_INFO_REPORTED = 162,
    ATOM_BLUETOOTH_REMOTE_VERSION_INFO_REPORTED = 163,
    ATOM_BLUETOOTH_SDP_ATTRIBUTE_REPORTED = 164,
    ATOM_BLUETOOTH_BOND_STATE_CHANGED = 165,
    ATOM_BLUETOOTH_CLASSIC_PAIRING_EVENT_REPORTED = 166,
    ATOM_BLUETOOTH_SMP_PAIRING_EVENT_REPORTED = 167,
    ATOM_SCREEN_TIMEOUT_EXTENSION_REPORTED = 168,
    ATOM_PROCESS_START_TIME = 169,
    ATOM_PERMISSION_GRANT_REQUEST_RESULT_REPORTED = 170,
    ATOM_BLUETOOTH_SOCKET_CONNECTION_STATE_CHANGED = 171,
    ATOM_DEVICE_IDENTIFIER_ACCESS_DENIED = 172,
    ATOM_BUBBLE_DEVELOPER_ERROR_REPORTED = 173,
    ATOM_ASSIST_GESTURE_STAGE_REPORTED = 174,
    ATOM_ASSIST_GESTURE_FEEDBACK_REPORTED = 175,
    ATOM_ASSIST_GESTURE_PROGRESS_REPORTED = 176,
    ATOM_TOUCH_GESTURE_CLASSIFIED = 177,
    ATOM_HIDDEN_API_USED = 178,
    ATOM_STYLE_UI_CHANGED = 179,
    ATOM_PRIVACY_INDICATORS_INTERACTED = 180,
    ATOM_APP_INSTALL_ON_EXTERNAL_STORAGE_REPORTED = 181,
    ATOM_NETWORK_STACK_REPORTED = 182,
    ATOM_APP_MOVED_STORAGE_REPORTED = 183,
    ATOM_BIOMETRIC_ENROLLED = 184,
    ATOM_SYSTEM_SERVER_WATCHDOG_OCCURRED = 185,
    ATOM_TOMB_STONE_OCCURRED = 186,
    ATOM_BLUETOOTH_CLASS_OF_DEVICE_REPORTED = 187,
    ATOM_INTELLIGENCE_EVENT_REPORTED = 188,
    ATOM_THERMAL_THROTTLING_SEVERITY_STATE_CHANGED = 189,
    ATOM_ROLE_REQUEST_RESULT_REPORTED = 190,
    ATOM_MEDIAMETRICS_AUDIOPOLICY_REPORTED = 191,
    ATOM_MEDIAMETRICS_AUDIORECORD_REPORTED = 192,
    ATOM_MEDIAMETRICS_AUDIOTHREAD_REPORTED = 193,
    ATOM_MEDIAMETRICS_AUDIOTRACK_REPORTED = 194,
    ATOM_MEDIAMETRICS_CODEC_REPORTED = 195,
    ATOM_MEDIAMETRICS_DRM_WIDEVINE_REPORTED = 196,
    ATOM_MEDIAMETRICS_EXTRACTOR_REPORTED = 197,
    ATOM_MEDIAMETRICS_MEDIADRM_REPORTED = 198,
    ATOM_MEDIAMETRICS_NUPLAYER_REPORTED = 199,
    ATOM_MEDIAMETRICS_RECORDER_REPORTED = 200,
    ATOM_MEDIAMETRICS_DRMMANAGER_REPORTED = 201,
    ATOM_CAR_POWER_STATE_CHANGED = 203,
    ATOM_GARAGE_MODE_INFO = 204,
    ATOM_TEST_ATOM_REPORTED = 205,
    ATOM_CONTENT_CAPTURE_CALLER_MISMATCH_REPORTED = 206,
    ATOM_CONTENT_CAPTURE_SERVICE_EVENTS = 207,
    ATOM_CONTENT_CAPTURE_SESSION_EVENTS = 208,
    ATOM_CONTENT_CAPTURE_FLUSHED = 209,
    ATOM_LOCATION_MANAGER_API_USAGE_REPORTED = 210,
    ATOM_REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED = 211,
    ATOM_RUNTIME_PERMISSIONS_UPGRADE_RESULT = 212,
    ATOM_GRANT_PERMISSIONS_ACTIVITY_BUTTON_ACTIONS = 213,
    ATOM_LOCATION_ACCESS_CHECK_NOTIFICATION_ACTION = 214,
    ATOM_APP_PERMISSION_FRAGMENT_ACTION_REPORTED = 215,
    ATOM_APP_PERMISSION_FRAGMENT_VIEWED = 216,
    ATOM_APP_PERMISSIONS_FRAGMENT_VIEWED = 217,
    ATOM_PERMISSION_APPS_FRAGMENT_VIEWED = 218,
    ATOM_TEXT_SELECTION_EVENT = 219,
    ATOM_TEXT_LINKIFY_EVENT = 220,
    ATOM_CONVERSATION_ACTIONS_EVENT = 221,
    ATOM_LANGUAGE_DETECTION_EVENT = 222,
    ATOM_EXCLUSION_RECT_STATE_CHANGED = 223,
    ATOM_BACK_GESTURE_REPORTED_REPORTED = 224,
    ATOM_UPDATE_ENGINE_UPDATE_ATTEMPT_REPORTED = 225,
    ATOM_UPDATE_ENGINE_SUCCESSFUL_UPDATE_REPORTED = 226,
    ATOM_CAMERA_ACTION_EVENT = 227,
    ATOM_APP_COMPATIBILITY_CHANGE_REPORTED = 228,
    ATOM_PERFETTO_UPLOADED = 229,
    ATOM_VMS_CLIENT_CONNECTION_STATE_CHANGED = 230,
    ATOM_MEDIA_PROVIDER_SCAN_OCCURRED = 233,
    ATOM_MEDIA_CONTENT_DELETED = 234,
    ATOM_MEDIA_PROVIDER_PERMISSION_REQUESTED = 235,
    ATOM_MEDIA_PROVIDER_SCHEMA_CHANGED = 236,
    ATOM_MEDIA_PROVIDER_IDLE_MAINTENANCE_FINISHED = 237,
    ATOM_REBOOT_ESCROW_RECOVERY_REPORTED = 238,
    ATOM_BOOT_TIME_EVENT_DURATION_REPORTED = 239,
    ATOM_BOOT_TIME_EVENT_ELAPSED_TIME_REPORTED = 240,
    ATOM_BOOT_TIME_EVENT_UTC_TIME_REPORTED = 241,
    ATOM_BOOT_TIME_EVENT_ERROR_CODE_REPORTED = 242,
    ATOM_USERSPACE_REBOOT_REPORTED = 243,
    ATOM_NOTIFICATION_REPORTED = 244,
    ATOM_NOTIFICATION_PANEL_REPORTED = 245,
    ATOM_NOTIFICATION_CHANNEL_MODIFIED = 246,
    ATOM_INTEGRITY_CHECK_RESULT_REPORTED = 247,
    ATOM_INTEGRITY_RULES_PUSHED = 248,
    ATOM_CB_MESSAGE_REPORTED = 249,
    ATOM_CB_MESSAGE_ERROR = 250,
    ATOM_WIFI_HEALTH_STAT_REPORTED = 251,
    ATOM_WIFI_FAILURE_STAT_REPORTED = 252,
    ATOM_WIFI_CONNECTION_RESULT_REPORTED = 253,
    ATOM_APP_FREEZE_CHANGED = 254,
    ATOM_SNAPSHOT_MERGE_REPORTED = 255,
    ATOM_FOREGROUND_SERVICE_APP_OP_SESSION_ENDED = 256,
    ATOM_DISPLAY_JANK_REPORTED = 257,
    ATOM_APP_STANDBY_BUCKET_CHANGED = 258,
    ATOM_SHARESHEET_STARTED = 259,
    ATOM_RANKING_SELECTED = 260,
    ATOM_TVSETTINGS_UI_INTERACTED = 261,
    ATOM_LAUNCHER_SNAPSHOT = 262,
    ATOM_PACKAGE_INSTALLER_V2_REPORTED = 263,
    ATOM_USER_LIFECYCLE_JOURNEY_REPORTED = 264,
    ATOM_USER_LIFECYCLE_EVENT_OCCURRED = 265,
    ATOM_ACCESSIBILITY_SHORTCUT_REPORTED = 266,
    ATOM_ACCESSIBILITY_SERVICE_REPORTED = 267,
    ATOM_DOCS_UI_DRAG_AND_DROP_REPORTED = 268,
    ATOM_APP_USAGE_EVENT_OCCURRED = 269,
    ATOM_AUTO_REVOKE_NOTIFICATION_CLICKED = 270,
    ATOM_AUTO_REVOKE_FRAGMENT_APP_VIEWED = 271,
    ATOM_AUTO_REVOKED_APP_INTERACTION = 272,
    ATOM_APP_PERMISSION_GROUPS_FRAGMENT_AUTO_REVOKE_ACTION = 273,
    ATOM_EVS_USAGE_STATS_REPORTED = 274,
    ATOM_AUDIO_POWER_USAGE_DATA_REPORTED = 275,
    ATOM_TV_TUNER_STATE_CHANGED = 276,
    ATOM_MEDIAOUTPUT_OP_SWITCH_REPORTED = 277,
    ATOM_CB_MESSAGE_FILTERED = 278,
    ATOM_TV_TUNER_DVR_STATUS = 279,
    ATOM_TV_CAS_SESSION_OPEN_STATUS = 280,
    ATOM_ASSISTANT_INVOCATION_REPORTED = 281,
    ATOM_DISPLAY_WAKE_REPORTED = 282,
    ATOM_CAR_USER_HAL_MODIFY_USER_REQUEST_REPORTED = 283,
    ATOM_CAR_USER_HAL_MODIFY_USER_RESPONSE_REPORTED = 284,
    ATOM_CAR_USER_HAL_POST_SWITCH_RESPONSE_REPORTED = 285,
    ATOM_CAR_USER_HAL_INITIAL_USER_INFO_REQUEST_REPORTED = 286,
    ATOM_CAR_USER_HAL_INITIAL_USER_INFO_RESPONSE_REPORTED = 287,
    ATOM_CAR_USER_HAL_USER_ASSOCIATION_REQUEST_REPORTED = 288,
    ATOM_CAR_USER_HAL_SET_USER_ASSOCIATION_RESPONSE_REPORTED = 289,
    ATOM_NETWORK_IP_PROVISIONING_REPORTED = 290,
    ATOM_NETWORK_DHCP_RENEW_REPORTED = 291,
    ATOM_NETWORK_VALIDATION_REPORTED = 292,
    ATOM_NETWORK_STACK_QUIRK_REPORTED = 293,
    ATOM_MEDIAMETRICS_AUDIORECORDDEVICEUSAGE_REPORTED = 294,
    ATOM_MEDIAMETRICS_AUDIOTHREADDEVICEUSAGE_REPORTED = 295,
    ATOM_MEDIAMETRICS_AUDIOTRACKDEVICEUSAGE_REPORTED = 296,
    ATOM_MEDIAMETRICS_AUDIODEVICECONNECTION_REPORTED = 297,
    ATOM_BLOB_COMMITTED = 298,
    ATOM_BLOB_LEASED = 299,
    ATOM_BLOB_OPENED = 300,
    ATOM_CONTACTS_PROVIDER_STATUS_REPORTED = 301,
    ATOM_KEYSTORE_KEY_EVENT_REPORTED = 302,
    ATOM_NETWORK_TETHERING_REPORTED = 303,
    ATOM_IME_TOUCH_REPORTED = 304,
    ATOM_UI_INTERACTION_FRAME_INFO_REPORTED = 305,
    ATOM_UI_ACTION_LATENCY_REPORTED = 306,
    ATOM_WIFI_DISCONNECT_REPORTED = 307,
    ATOM_WIFI_CONNECTION_STATE_CHANGED = 308,
    ATOM_HDMI_CEC_ACTIVE_SOURCE_CHANGED = 309,
    ATOM_HDMI_CEC_MESSAGE_REPORTED = 310,
    ATOM_AIRPLANE_MODE = 311,
    ATOM_MODEM_RESTART = 312,
    ATOM_CARRIER_ID_MISMATCH_REPORTED = 313,
    ATOM_CARRIER_ID_TABLE_UPDATED = 314,
    ATOM_DATA_STALL_RECOVERY_REPORTED = 315,
    ATOM_MEDIAMETRICS_MEDIAPARSER_REPORTED = 316,
    ATOM_TLS_HANDSHAKE_REPORTED = 317,
    ATOM_TEXT_CLASSIFIER_API_USAGE_REPORTED = 318,
    ATOM_CAR_WATCHDOG_KILL_STATS_REPORTED = 319,
    ATOM_MEDIAMETRICS_PLAYBACK_REPORTED = 320,
    ATOM_MEDIA_NETWORK_INFO_CHANGED = 321,
    ATOM_MEDIA_PLAYBACK_STATE_CHANGED = 322,
    ATOM_MEDIA_PLAYBACK_ERROR_REPORTED = 323,
    ATOM_MEDIA_PLAYBACK_TRACK_CHANGED = 324,
    ATOM_WIFI_SCAN_REPORTED = 325,
    ATOM_WIFI_PNO_SCAN_REPORTED = 326,
    ATOM_TIF_TUNE_CHANGED = 327,
    ATOM_AUTO_ROTATE_REPORTED = 328,
    ATOM_PERFETTO_TRIGGER = 329,
    ATOM_TRANSCODING_DATA = 330,
    ATOM_IMS_SERVICE_ENTITLEMENT_UPDATED = 331,
    ATOM_DEVICE_ROTATED = 333,
    ATOM_SIM_SPECIFIC_SETTINGS_RESTORED = 334,
    ATOM_TEXT_CLASSIFIER_DOWNLOAD_REPORTED = 335,
    ATOM_PIN_STORAGE_EVENT = 336,
    ATOM_FACE_DOWN_REPORTED = 337,
    ATOM_BLUETOOTH_HAL_CRASH_REASON_REPORTED = 338,
    ATOM_REBOOT_ESCROW_PREPARATION_REPORTED = 339,
    ATOM_REBOOT_ESCROW_LSKF_CAPTURE_REPORTED = 340,
    ATOM_REBOOT_ESCROW_REBOOT_REPORTED = 341,
    ATOM_BINDER_LATENCY_REPORTED = 342,
    ATOM_MEDIAMETRICS_AAUDIOSTREAM_REPORTED = 343,
    ATOM_MEDIA_TRANSCODING_SESSION_ENDED = 344,
    ATOM_MAGNIFICATION_USAGE_REPORTED = 345,
    ATOM_MAGNIFICATION_MODE_WITH_IME_ON_REPORTED = 346,
    ATOM_APP_SEARCH_CALL_STATS_REPORTED = 347,
    ATOM_APP_SEARCH_PUT_DOCUMENT_STATS_REPORTED = 348,
    ATOM_DEVICE_CONTROL_CHANGED = 349,
    ATOM_DEVICE_STATE_CHANGED = 350,
    ATOM_INPUTDEVICE_REGISTERED = 351,
    ATOM_SMARTSPACE_CARD_REPORTED = 352,
    ATOM_AUTH_PROMPT_AUTHENTICATE_INVOKED = 353,
    ATOM_AUTH_MANAGER_CAN_AUTHENTICATE_INVOKED = 354,
    ATOM_AUTH_ENROLL_ACTION_INVOKED = 355,
    ATOM_AUTH_DEPRECATED_API_USED = 356,
    ATOM_UNATTENDED_REBOOT_OCCURRED = 357,
    ATOM_LONG_REBOOT_BLOCKING_REPORTED = 358,
    ATOM_LOCATION_TIME_ZONE_PROVIDER_STATE_CHANGED = 359,
    ATOM_FDTRACK_EVENT_OCCURRED = 364,
    ATOM_TIMEOUT_AUTO_EXTENDED_REPORTED = 365,
    ATOM_ALARM_BATCH_DELIVERED = 367,
    ATOM_ALARM_SCHEDULED = 368,
    ATOM_CAR_WATCHDOG_IO_OVERUSE_STATS_REPORTED = 369,
    ATOM_USER_LEVEL_HIBERNATION_STATE_CHANGED = 370,
    ATOM_APP_SEARCH_INITIALIZE_STATS_REPORTED = 371,
    ATOM_APP_SEARCH_QUERY_STATS_REPORTED = 372,
    ATOM_APP_PROCESS_DIED = 373,
    ATOM_NETWORK_IP_REACHABILITY_MONITOR_REPORTED = 374,
    ATOM_SLOW_INPUT_EVENT_REPORTED = 375,
    ATOM_ANR_OCCURRED_PROCESSING_STARTED = 376,
    ATOM_APP_SEARCH_REMOVE_STATS_REPORTED = 377,
    ATOM_MEDIA_CODEC_REPORTED = 378,
    ATOM_PERMISSION_USAGE_FRAGMENT_INTERACTION = 379,
    ATOM_PERMISSION_DETAILS_INTERACTION = 380,
    ATOM_PRIVACY_SENSOR_TOGGLE_INTERACTION = 381,
    ATOM_PRIVACY_TOGGLE_DIALOG_INTERACTION = 382,
    ATOM_APP_SEARCH_OPTIMIZE_STATS_REPORTED = 383,
    ATOM_NON_A11_Y_TOOL_SERVICE_WARNING_REPORT = 384,
    ATOM_APP_COMPAT_STATE_CHANGED = 386,
    ATOM_SIZE_COMPAT_RESTART_BUTTON_EVENT_REPORTED = 387,
    ATOM_SPLITSCREEN_UI_CHANGED = 388,
    ATOM_NETWORK_DNS_HANDSHAKE_REPORTED = 389,
    ATOM_BLUETOOTH_CODE_PATH_COUNTER = 390,
    ATOM_BLUETOOTH_LE_BATCH_SCAN_REPORT_DELAY = 392,
    ATOM_ACCESSIBILITY_FLOATING_MENU_UI_CHANGED = 393,
    ATOM_NEURALNETWORKS_COMPILATION_COMPLETED = 394,
    ATOM_NEURALNETWORKS_EXECUTION_COMPLETED = 395,
    ATOM_NEURALNETWORKS_COMPILATION_FAILED = 396,
    ATOM_NEURALNETWORKS_EXECUTION_FAILED = 397,
    ATOM_CONTEXT_HUB_BOOTED = 398,
    ATOM_CONTEXT_HUB_RESTARTED = 399,
    ATOM_CONTEXT_HUB_LOADED_NANOAPP_SNAPSHOT_REPORTED = 400,
    ATOM_CHRE_CODE_DOWNLOAD_TRANSACTED = 401,
    ATOM_UWB_SESSION_INITED = 402,
    ATOM_UWB_SESSION_CLOSED = 403,
    ATOM_UWB_FIRST_RANGING_RECEIVED = 404,
    ATOM_UWB_RANGING_MEASUREMENT_RECEIVED = 405,
    ATOM_TEXT_CLASSIFIER_DOWNLOAD_WORK_SCHEDULED = 406,
    ATOM_TEXT_CLASSIFIER_DOWNLOAD_WORK_COMPLETED = 407,
    ATOM_CLIPBOARD_CLEARED = 408,
    ATOM_VM_CREATION_REQUESTED = 409,
    ATOM_NEARBY_DEVICE_SCAN_STATE_CHANGED = 410,
    ATOM_APPLICATION_LOCALES_CHANGED = 412,
    ATOM_MEDIAMETRICS_AUDIOTRACKSTATUS_REPORTED = 413,
    ATOM_FOLD_STATE_DURATION_REPORTED = 414,
    ATOM_LOCATION_TIME_ZONE_PROVIDER_CONTROLLER_STATE_CHANGED = 415,
    ATOM_DISPLAY_HBM_STATE_CHANGED = 416,
    ATOM_DISPLAY_HBM_BRIGHTNESS_CHANGED = 417,
    ATOM_PERSISTENT_URI_PERMISSIONS_FLUSHED = 418,
    ATOM_EARLY_BOOT_COMP_OS_ARTIFACTS_CHECK_REPORTED = 419,
    ATOM_VBMETA_DIGEST_REPORTED = 420,
    ATOM_APEX_INFO_GATHERED = 421,
    ATOM_PVM_INFO_GATHERED = 422,
    ATOM_WEAR_SETTINGS_UI_INTERACTED = 423,
    ATOM_TRACING_SERVICE_REPORT_EVENT = 424,
    ATOM_MEDIAMETRICS_AUDIORECORDSTATUS_REPORTED = 425,
    ATOM_LAUNCHER_LATENCY = 426,
    ATOM_DROPBOX_ENTRY_DROPPED = 427,
    ATOM_WIFI_P2_P_CONNECTION_REPORTED = 428,
    ATOM_GAME_STATE_CHANGED = 429,
    ATOM_HOTWORD_DETECTOR_CREATE_REQUESTED = 430,
    ATOM_HOTWORD_DETECTION_SERVICE_INIT_RESULT_REPORTED = 431,
    ATOM_HOTWORD_DETECTION_SERVICE_RESTARTED = 432,
    ATOM_HOTWORD_DETECTOR_KEYPHRASE_TRIGGERED = 433,
    ATOM_HOTWORD_DETECTOR_EVENTS = 434,
    ATOM_BOOT_COMPLETED_BROADCAST_COMPLETION_LATENCY_REPORTED = 437,
    ATOM_CONTACTS_INDEXER_UPDATE_STATS_REPORTED = 440,
    ATOM_APP_BACKGROUND_RESTRICTIONS_INFO = 441,
    ATOM_MMS_SMS_PROVIDER_GET_THREAD_ID_FAILED = 442,
    ATOM_MMS_SMS_DATABASE_HELPER_ON_UPGRADE_FAILED = 443,
    ATOM_PERMISSION_REMINDER_NOTIFICATION_INTERACTED = 444,
    ATOM_RECENT_PERMISSION_DECISIONS_INTERACTED = 445,
    ATOM_GNSS_PSDS_DOWNLOAD_REPORTED = 446,
    ATOM_LE_AUDIO_CONNECTION_SESSION_REPORTED = 447,
    ATOM_LE_AUDIO_BROADCAST_SESSION_REPORTED = 448,
    ATOM_DREAM_UI_EVENT_REPORTED = 449,
    ATOM_TASK_MANAGER_EVENT_REPORTED = 450,
    ATOM_CDM_ASSOCIATION_ACTION = 451,
    ATOM_MAGNIFICATION_TRIPLE_TAP_AND_HOLD_ACTIVATED_SESSION_REPORTED = 452,
    ATOM_MAGNIFICATION_FOLLOW_TYPING_FOCUS_ACTIVATED_SESSION_REPORTED = 453,
    ATOM_ACCESSIBILITY_TEXT_READING_OPTIONS_CHANGED = 454,
    ATOM_WIFI_SETUP_FAILURE_CRASH_REPORTED = 455,
    ATOM_UWB_DEVICE_ERROR_REPORTED = 456,
    ATOM_ISOLATED_COMPILATION_SCHEDULED = 457,
    ATOM_ISOLATED_COMPILATION_ENDED = 458,
    ATOM_ONS_OPPORTUNISTIC_ESIM_PROVISIONING_COMPLETE = 459,
    ATOM_SYSTEM_SERVER_PRE_WATCHDOG_OCCURRED = 460,
    ATOM_TELEPHONY_ANOMALY_DETECTED = 461,
    ATOM_LETTERBOX_POSITION_CHANGED = 462,
    ATOM_REMOTE_KEY_PROVISIONING_ATTEMPT = 463,
    ATOM_REMOTE_KEY_PROVISIONING_NETWORK_INFO = 464,
    ATOM_REMOTE_KEY_PROVISIONING_TIMING = 465,
    ATOM_MEDIAOUTPUT_OP_INTERACTION_REPORT = 466,
    ATOM_SYNC_EXEMPTION_OCCURRED = 468,
    ATOM_AUTOFILL_PRESENTATION_EVENT_REPORTED = 469,
    ATOM_DOCK_STATE_CHANGED = 470,
    ATOM_SAFETY_SOURCE_STATE_COLLECTED = 471,
    ATOM_SAFETY_CENTER_SYSTEM_EVENT_REPORTED = 472,
    ATOM_SAFETY_CENTER_INTERACTION_REPORTED = 473,
    ATOM_SETTINGS_PROVIDER_SETTING_CHANGED = 474,
    ATOM_BROADCAST_DELIVERY_EVENT_REPORTED = 475,
    ATOM_SERVICE_REQUEST_EVENT_REPORTED = 476,
    ATOM_PROVIDER_ACQUISITION_EVENT_REPORTED = 477,
    ATOM_BLUETOOTH_DEVICE_NAME_REPORTED = 478,
    ATOM_CB_CONFIG_UPDATED = 479,
    ATOM_CB_MODULE_ERROR_REPORTED = 480,
    ATOM_CB_SERVICE_FEATURE_CHANGED = 481,
    ATOM_CB_RECEIVER_FEATURE_CHANGED = 482,
    ATOM_PRIVACY_SIGNAL_NOTIFICATION_INTERACTION = 484,
    ATOM_PRIVACY_SIGNAL_ISSUE_CARD_INTERACTION = 485,
    ATOM_PRIVACY_SIGNALS_JOB_FAILURE = 486,
    ATOM_VIBRATION_REPORTED = 487,
    ATOM_UWB_RANGING_START = 489,
    ATOM_APP_COMPACTED_V2 = 491,
    ATOM_DISPLAY_BRIGHTNESS_CHANGED = 494,
    ATOM_ACTIVITY_ACTION_BLOCKED = 495,
    ATOM_NETWORK_DNS_SERVER_SUPPORT_REPORTED = 504,
    ATOM_VM_BOOTED = 505,
    ATOM_VM_EXITED = 506,
    ATOM_AMBIENT_BRIGHTNESS_STATS_REPORTED = 507,
    ATOM_MEDIAMETRICS_SPATIALIZERCAPABILITIES_REPORTED = 508,
    ATOM_MEDIAMETRICS_SPATIALIZERDEVICEENABLED_REPORTED = 509,
    ATOM_MEDIAMETRICS_HEADTRACKERDEVICEENABLED_REPORTED = 510,
    ATOM_MEDIAMETRICS_HEADTRACKERDEVICESUPPORTED_REPORTED = 511,
    ATOM_HEARING_AID_INFO_REPORTED = 513,
    ATOM_DEVICE_WIDE_JOB_CONSTRAINT_CHANGED = 514,
    ATOM_AMBIENT_MODE_CHANGED = 515,
    ATOM_ANR_LATENCY_REPORTED = 516,
    ATOM_RESOURCE_API_INFO = 517,
    ATOM_SYSTEM_DEFAULT_NETWORK_CHANGED = 518,
    ATOM_IWLAN_SETUP_DATA_CALL_RESULT_REPORTED = 519,
    ATOM_IWLAN_PDN_DISCONNECTED_REASON_REPORTED = 520,
    ATOM_AIRPLANE_MODE_SESSION_REPORTED = 521,
    ATOM_VM_CPU_STATUS_REPORTED = 522,
    ATOM_VM_MEM_STATUS_REPORTED = 523,
    ATOM_PACKAGE_INSTALLATION_SESSION_REPORTED = 524,
    ATOM_DEFAULT_NETWORK_REMATCH_INFO = 525,
    ATOM_NETWORK_SELECTION_PERFORMANCE = 526,
    ATOM_NETWORK_NSD_REPORTED = 527,
    ATOM_BLUETOOTH_DISCONNECTION_REASON_REPORTED = 529,
    ATOM_BLUETOOTH_LOCAL_VERSIONS_REPORTED = 530,
    ATOM_BLUETOOTH_REMOTE_SUPPORTED_FEATURES_REPORTED = 531,
    ATOM_BLUETOOTH_LOCAL_SUPPORTED_FEATURES_REPORTED = 532,
    ATOM_BLUETOOTH_GATT_APP_INFO = 533,
    ATOM_BRIGHTNESS_CONFIGURATION_UPDATED = 534,
    ATOM_WEAR_MEDIA_OUTPUT_SWITCHER_LAUNCHED = 538,
    ATOM_WEAR_MEDIA_OUTPUT_SWITCHER_FINISHED = 539,
    ATOM_WEAR_MEDIA_OUTPUT_SWITCHER_CONNECTION_REPORTED = 540,
    ATOM_WEAR_MEDIA_OUTPUT_SWITCHER_DEVICE_SCAN_TRIGGERED = 541,
    ATOM_WEAR_MEDIA_OUTPUT_SWITCHER_FIRST_DEVICE_SCAN_LATENCY = 542,
    ATOM_WEAR_MEDIA_OUTPUT_SWITCHER_CONNECT_DEVICE_LATENCY = 543,
    ATOM_PACKAGE_MANAGER_SNAPSHOT_REPORTED = 544,
    ATOM_PACKAGE_MANAGER_APPS_FILTER_CACHE_BUILD_REPORTED = 545,
    ATOM_PACKAGE_MANAGER_APPS_FILTER_CACHE_UPDATE_REPORTED = 546,
    ATOM_LAUNCHER_IMPRESSION_EVENT = 547,
    ATOM_WEAR_MEDIA_OUTPUT_SWITCHER_ALL_DEVICES_SCAN_LATENCY = 549,
    ATOM_WS_WATCH_FACE_EDITED = 551,
    ATOM_WS_WATCH_FACE_FAVORITE_ACTION_REPORTED = 552,
    ATOM_WS_WATCH_FACE_SET_ACTION_REPORTED = 553,
    ATOM_PACKAGE_UNINSTALLATION_REPORTED = 554,
    ATOM_GAME_MODE_CHANGED = 555,
    ATOM_GAME_MODE_CONFIGURATION_CHANGED = 556,
    ATOM_BEDTIME_MODE_STATE_CHANGED = 557,
    ATOM_NETWORK_SLICE_SESSION_ENDED = 558,
    ATOM_NETWORK_SLICE_DAILY_DATA_USAGE_REPORTED = 559,
    ATOM_NFC_TAG_TYPE_OCCURRED = 560,
    ATOM_NFC_AID_CONFLICT_OCCURRED = 561,
    ATOM_NFC_READER_CONFLICT_OCCURRED = 562,
    ATOM_WS_TILE_LIST_CHANGED = 563,
    ATOM_GET_TYPE_ACCESSED_WITHOUT_PERMISSION = 564,
    ATOM_MOBILE_BUNDLED_APP_INFO_GATHERED = 566,
    ATOM_WS_WATCH_FACE_COMPLICATION_SET_CHANGED = 567,
    ATOM_MEDIA_DRM_CREATED = 568,
    ATOM_MEDIA_DRM_ERRORED = 569,
    ATOM_MEDIA_DRM_SESSION_OPENED = 570,
    ATOM_MEDIA_DRM_SESSION_CLOSED = 571,
    ATOM_USER_SELECTED_RESOLUTION = 572,
    ATOM_UNSAFE_INTENT_EVENT_REPORTED = 573,
    ATOM_PERFORMANCE_HINT_SESSION_REPORTED = 574,
    ATOM_MEDIAMETRICS_MIDI_DEVICE_CLOSE_REPORTED = 576,
    ATOM_BIOMETRIC_TOUCH_REPORTED = 577,
    ATOM_HOTWORD_AUDIO_EGRESS_EVENT_REPORTED = 578,
    ATOM_LOCATION_ENABLED_STATE_CHANGED = 580,
    ATOM_IME_REQUEST_FINISHED = 581,
    ATOM_USB_COMPLIANCE_WARNINGS_REPORTED = 582,
    ATOM_APP_SUPPORTED_LOCALES_CHANGED = 583,
    ATOM_MEDIA_PROVIDER_VOLUME_RECOVERY_REPORTED = 586,
    ATOM_BIOMETRIC_PROPERTIES_COLLECTED = 587,
    ATOM_KERNEL_WAKEUP_ATTRIBUTED = 588,
    ATOM_SCREEN_STATE_CHANGED_V2 = 589,
    ATOM_WS_BACKUP_ACTION_REPORTED = 590,
    ATOM_WS_RESTORE_ACTION_REPORTED = 591,
    ATOM_DEVICE_LOG_ACCESS_EVENT_REPORTED = 592,
    ATOM_MEDIA_SESSION_UPDATED = 594,
    ATOM_WEAR_OOBE_STATE_CHANGED = 595,
    ATOM_WS_NOTIFICATION_UPDATED = 596,
    ATOM_NETWORK_VALIDATION_FAILURE_STATS_DAILY_REPORTED = 601,
    ATOM_WS_COMPLICATION_TAPPED = 602,
    ATOM_WS_NOTIFICATION_BLOCKING = 780,
    ATOM_WS_NOTIFICATION_BRIDGEMODE_UPDATED = 822,
    ATOM_WS_NOTIFICATION_DISMISSAL_ACTIONED = 823,
    ATOM_WS_NOTIFICATION_ACTIONED = 824,
    ATOM_WS_NOTIFICATION_LATENCY = 880,
    ATOM_WIFI_BYTES_TRANSFER = 10000,
    ATOM_WIFI_BYTES_TRANSFER_BY_FG_BG = 10001,
    ATOM_MOBILE_BYTES_TRANSFER = 10002,
    ATOM_MOBILE_BYTES_TRANSFER_BY_FG_BG = 10003,
    ATOM_BLUETOOTH_BYTES_TRANSFER = 10006,
    ATOM_KERNEL_WAKELOCK = 10004,
    ATOM_SUBSYSTEM_SLEEP_STATE = 10005,
    ATOM_CPU_TIME_PER_UID = 10009,
    ATOM_CPU_TIME_PER_UID_FREQ = 10010,
    ATOM_WIFI_ACTIVITY_INFO = 10011,
    ATOM_MODEM_ACTIVITY_INFO = 10012,
    ATOM_BLUETOOTH_ACTIVITY_INFO = 10007,
    ATOM_PROCESS_MEMORY_STATE = 10013,
    ATOM_SYSTEM_ELAPSED_REALTIME = 10014,
    ATOM_SYSTEM_UPTIME = 10015,
    ATOM_CPU_ACTIVE_TIME = 10016,
    ATOM_CPU_CLUSTER_TIME = 10017,
    ATOM_DISK_SPACE = 10018,
    ATOM_REMAINING_BATTERY_CAPACITY = 10019,
    ATOM_FULL_BATTERY_CAPACITY = 10020,
    ATOM_TEMPERATURE = 10021,
    ATOM_BINDER_CALLS = 10022,
    ATOM_BINDER_CALLS_EXCEPTIONS = 10023,
    ATOM_LOOPER_STATS = 10024,
    ATOM_DISK_STATS = 10025,
    ATOM_DIRECTORY_USAGE = 10026,
    ATOM_APP_SIZE = 10027,
    ATOM_CATEGORY_SIZE = 10028,
    ATOM_PROC_STATS = 10029,
    ATOM_BATTERY_VOLTAGE = 10030,
    ATOM_NUM_FINGERPRINTS_ENROLLED = 10031,
    ATOM_DISK_IO = 10032,
    ATOM_POWER_PROFILE = 10033,
    ATOM_PROC_STATS_PKG_PROC = 10034,
    ATOM_PROCESS_CPU_TIME = 10035,
    ATOM_CPU_TIME_PER_THREAD_FREQ = 10037,
    ATOM_ON_DEVICE_POWER_MEASUREMENT = 10038,
    ATOM_DEVICE_CALCULATED_POWER_USE = 10039,
    ATOM_PROCESS_MEMORY_HIGH_WATER_MARK = 10042,
    ATOM_BATTERY_LEVEL = 10043,
    ATOM_BUILD_INFORMATION = 10044,
    ATOM_BATTERY_CYCLE_COUNT = 10045,
    ATOM_DEBUG_ELAPSED_CLOCK = 10046,
    ATOM_DEBUG_FAILING_ELAPSED_CLOCK = 10047,
    ATOM_NUM_FACES_ENROLLED = 10048,
    ATOM_ROLE_HOLDER = 10049,
    ATOM_DANGEROUS_PERMISSION_STATE = 10050,
    ATOM_TRAIN_INFO = 10051,
    ATOM_TIME_ZONE_DATA_INFO = 10052,
    ATOM_EXTERNAL_STORAGE_INFO = 10053,
    ATOM_GPU_STATS_GLOBAL_INFO = 10054,
    ATOM_GPU_STATS_APP_INFO = 10055,
    ATOM_SYSTEM_ION_HEAP_SIZE = 10056,
    ATOM_APPS_ON_EXTERNAL_STORAGE_INFO = 10057,
    ATOM_FACE_SETTINGS = 10058,
    ATOM_COOLING_DEVICE = 10059,
    ATOM_APP_OPS = 10060,
    ATOM_PROCESS_SYSTEM_ION_HEAP_SIZE = 10061,
    ATOM_SURFACEFLINGER_STATS_GLOBAL_INFO = 10062,
    ATOM_SURFACEFLINGER_STATS_LAYER_INFO = 10063,
    ATOM_PROCESS_MEMORY_SNAPSHOT = 10064,
    ATOM_VMS_CLIENT_STATS = 10065,
    ATOM_NOTIFICATION_REMOTE_VIEWS = 10066,
    ATOM_DANGEROUS_PERMISSION_STATE_SAMPLED = 10067,
    ATOM_GRAPHICS_STATS = 10068,
    ATOM_RUNTIME_APP_OP_ACCESS = 10069,
    ATOM_ION_HEAP_SIZE = 10070,
    ATOM_PACKAGE_NOTIFICATION_PREFERENCES = 10071,
    ATOM_PACKAGE_NOTIFICATION_CHANNEL_PREFERENCES = 10072,
    ATOM_PACKAGE_NOTIFICATION_CHANNEL_GROUP_PREFERENCES = 10073,
    ATOM_GNSS_STATS = 10074,
    ATOM_ATTRIBUTED_APP_OPS = 10075,
    ATOM_VOICE_CALL_SESSION = 10076,
    ATOM_VOICE_CALL_RAT_USAGE = 10077,
    ATOM_SIM_SLOT_STATE = 10078,
    ATOM_SUPPORTED_RADIO_ACCESS_FAMILY = 10079,
    ATOM_SETTING_SNAPSHOT = 10080,
    ATOM_BLOB_INFO = 10081,
    ATOM_DATA_USAGE_BYTES_TRANSFER = 10082,
    ATOM_BYTES_TRANSFER_BY_TAG_AND_METERED = 10083,
    ATOM_DND_MODE_RULE = 10084,
    ATOM_GENERAL_EXTERNAL_STORAGE_ACCESS_STATS = 10085,
    ATOM_INCOMING_SMS = 10086,
    ATOM_OUTGOING_SMS = 10087,
    ATOM_CARRIER_ID_TABLE_VERSION = 10088,
    ATOM_DATA_CALL_SESSION = 10089,
    ATOM_CELLULAR_SERVICE_STATE = 10090,
    ATOM_CELLULAR_DATA_SERVICE_SWITCH = 10091,
    ATOM_SYSTEM_MEMORY = 10092,
    ATOM_IMS_REGISTRATION_TERMINATION = 10093,
    ATOM_IMS_REGISTRATION_STATS = 10094,
    ATOM_CPU_TIME_PER_CLUSTER_FREQ = 10095,
    ATOM_CPU_CYCLES_PER_UID_CLUSTER = 10096,
    ATOM_DEVICE_ROTATED_DATA = 10097,
    ATOM_CPU_CYCLES_PER_THREAD_GROUP_CLUSTER = 10098,
    ATOM_MEDIA_DRM_ACTIVITY_INFO = 10099,
    ATOM_OEM_MANAGED_BYTES_TRANSFER = 10100,
    ATOM_GNSS_POWER_STATS = 10101,
    ATOM_TIME_ZONE_DETECTOR_STATE = 10102,
    ATOM_KEYSTORE2_STORAGE_STATS = 10103,
    ATOM_RKP_POOL_STATS = 10104,
    ATOM_PROCESS_DMABUF_MEMORY = 10105,
    ATOM_PENDING_ALARM_INFO = 10106,
    ATOM_USER_LEVEL_HIBERNATED_APPS = 10107,
    ATOM_LAUNCHER_LAYOUT_SNAPSHOT = 10108,
    ATOM_GLOBAL_HIBERNATED_APPS = 10109,
    ATOM_INPUT_EVENT_LATENCY_SKETCH = 10110,
    ATOM_BATTERY_USAGE_STATS_BEFORE_RESET = 10111,
    ATOM_BATTERY_USAGE_STATS_SINCE_RESET = 10112,
    ATOM_BATTERY_USAGE_STATS_SINCE_RESET_USING_POWER_PROFILE_MODEL = 10113,
    ATOM_INSTALLED_INCREMENTAL_PACKAGE = 10114,
    ATOM_TELEPHONY_NETWORK_REQUESTS = 10115,
    ATOM_APP_SEARCH_STORAGE_INFO = 10116,
    ATOM_VMSTAT = 10117,
    ATOM_KEYSTORE2_KEY_CREATION_WITH_GENERAL_INFO = 10118,
    ATOM_KEYSTORE2_KEY_CREATION_WITH_AUTH_INFO = 10119,
    ATOM_KEYSTORE2_KEY_CREATION_WITH_PURPOSE_AND_MODES_INFO = 10120,
    ATOM_KEYSTORE2_ATOM_WITH_OVERFLOW = 10121,
    ATOM_KEYSTORE2_KEY_OPERATION_WITH_PURPOSE_AND_MODES_INFO = 10122,
    ATOM_KEYSTORE2_KEY_OPERATION_WITH_GENERAL_INFO = 10123,
    ATOM_RKP_ERROR_STATS = 10124,
    ATOM_KEYSTORE2_CRASH_STATS = 10125,
    ATOM_VENDOR_APEX_INFO = 10126,
    ATOM_ACCESSIBILITY_SHORTCUT_STATS = 10127,
    ATOM_ACCESSIBILITY_FLOATING_MENU_STATS = 10128,
    ATOM_DATA_USAGE_BYTES_TRANSFER_V2 = 10129,
    ATOM_MEDIA_CAPABILITIES = 10130,
    ATOM_CAR_WATCHDOG_SYSTEM_IO_USAGE_SUMMARY = 10131,
    ATOM_CAR_WATCHDOG_UID_IO_USAGE_SUMMARY = 10132,
    ATOM_IMS_REGISTRATION_FEATURE_TAG_STATS = 10133,
    ATOM_RCS_CLIENT_PROVISIONING_STATS = 10134,
    ATOM_RCS_ACS_PROVISIONING_STATS = 10135,
    ATOM_SIP_DELEGATE_STATS = 10136,
    ATOM_SIP_TRANSPORT_FEATURE_TAG_STATS = 10137,
    ATOM_SIP_MESSAGE_RESPONSE = 10138,
    ATOM_SIP_TRANSPORT_SESSION = 10139,
    ATOM_IMS_DEDICATED_BEARER_LISTENER_EVENT = 10140,
    ATOM_IMS_DEDICATED_BEARER_EVENT = 10141,
    ATOM_IMS_REGISTRATION_SERVICE_DESC_STATS = 10142,
    ATOM_UCE_EVENT_STATS = 10143,
    ATOM_PRESENCE_NOTIFY_EVENT = 10144,
    ATOM_GBA_EVENT = 10145,
    ATOM_PER_SIM_STATUS = 10146,
    ATOM_GPU_WORK_PER_UID = 10147,
    ATOM_PERSISTENT_URI_PERMISSIONS_AMOUNT_PER_PACKAGE = 10148,
    ATOM_SIGNED_PARTITION_INFO = 10149,
    ATOM_PINNED_FILE_SIZES_PER_PACKAGE = 10150,
    ATOM_PENDING_INTENTS_PER_PACKAGE = 10151,
    ATOM_USER_INFO = 10152,
    ATOM_TELEPHONY_NETWORK_REQUESTS_V2 = 10153,
    ATOM_DEVICE_TELEPHONY_PROPERTIES = 10154,
    ATOM_REMOTE_KEY_PROVISIONING_ERROR_COUNTS = 10155,
    ATOM_SAFETY_STATE = 10156,
    ATOM_INCOMING_MMS = 10157,
    ATOM_OUTGOING_MMS = 10158,
    ATOM_MULTI_USER_INFO = 10160,
    ATOM_NETWORK_BPF_MAP_INFO = 10161,
    ATOM_OUTGOING_SHORT_CODE_SMS = 10162,
    ATOM_CONNECTIVITY_STATE_SAMPLE = 10163,
    ATOM_NETWORK_SELECTION_REMATCH_REASONS_INFO = 10164,
    ATOM_GAME_MODE_INFO = 10165,
    ATOM_GAME_MODE_CONFIGURATION = 10166,
    ATOM_GAME_MODE_LISTENER = 10167,
    ATOM_NETWORK_SLICE_REQUEST_COUNT = 10168,
    ATOM_WS_TILE_SNAPSHOT = 10169,
    ATOM_WS_ACTIVE_WATCH_FACE_COMPLICATION_SET_SNAPSHOT = 10170,
    ATOM_PROCESS_STATE = 10171,
    ATOM_PROCESS_ASSOCIATION = 10172,
    ATOM_ADPF_SYSTEM_COMPONENT_INFO = 10173,
    ATOM_NOTIFICATION_MEMORY_USE = 10174,
    ATOM_HDR_CAPABILITIES = 10175,
    ATOM_WS_FAVOURITE_WATCH_FACE_LIST_SNAPSHOT = 10176,
    ATOM_ACCESSIBILITY_CHECK_RESULT_REPORTED = 910,
    ATOM_ADAPTIVE_AUTH_UNLOCK_AFTER_LOCK_REPORTED = 820,
    ATOM_THERMAL_STATUS_CALLED = 772,
    ATOM_THERMAL_HEADROOM_CALLED = 773,
    ATOM_THERMAL_HEADROOM_THRESHOLDS_CALLED = 774,
    ATOM_ADPF_HINT_SESSION_TID_CLEANUP = 839,
    ATOM_THERMAL_HEADROOM_THRESHOLDS = 10201,
    ATOM_ADPF_SESSION_SNAPSHOT = 10218,
    ATOM_JSSCRIPTENGINE_LATENCY_REPORTED = 483,
    ATOM_AD_SERVICES_API_CALLED = 435,
    ATOM_AD_SERVICES_MESUREMENT_REPORTS_UPLOADED = 436,
    ATOM_MOBILE_DATA_DOWNLOAD_FILE_GROUP_STATUS_REPORTED = 490,
    ATOM_MOBILE_DATA_DOWNLOAD_DOWNLOAD_RESULT_REPORTED = 502,
    ATOM_AD_SERVICES_SETTINGS_USAGE_REPORTED = 493,
    ATOM_BACKGROUND_FETCH_PROCESS_REPORTED = 496,
    ATOM_UPDATE_CUSTOM_AUDIENCE_PROCESS_REPORTED = 497,
    ATOM_RUN_AD_BIDDING_PROCESS_REPORTED = 498,
    ATOM_RUN_AD_SCORING_PROCESS_REPORTED = 499,
    ATOM_RUN_AD_SELECTION_PROCESS_REPORTED = 500,
    ATOM_RUN_AD_BIDDING_PER_CA_PROCESS_REPORTED = 501,
    ATOM_MOBILE_DATA_DOWNLOAD_FILE_GROUP_STORAGE_STATS_REPORTED = 503,
    ATOM_AD_SERVICES_MEASUREMENT_REGISTRATIONS = 512,
    ATOM_AD_SERVICES_GET_TOPICS_REPORTED = 535,
    ATOM_AD_SERVICES_EPOCH_COMPUTATION_GET_TOP_TOPICS_REPORTED = 536,
    ATOM_AD_SERVICES_EPOCH_COMPUTATION_CLASSIFIER_REPORTED = 537,
    ATOM_AD_SERVICES_BACK_COMPAT_GET_TOPICS_REPORTED = 598,
    ATOM_AD_SERVICES_BACK_COMPAT_EPOCH_COMPUTATION_CLASSIFIER_REPORTED = 599,
    ATOM_AD_SERVICES_MEASUREMENT_DEBUG_KEYS = 640,
    ATOM_AD_SERVICES_ERROR_REPORTED = 662,
    ATOM_AD_SERVICES_BACKGROUND_JOBS_EXECUTION_REPORTED = 663,
    ATOM_AD_SERVICES_MEASUREMENT_DELAYED_SOURCE_REGISTRATION = 673,
    ATOM_AD_SERVICES_MEASUREMENT_ATTRIBUTION = 674,
    ATOM_AD_SERVICES_MEASUREMENT_JOBS = 675,
    ATOM_AD_SERVICES_MEASUREMENT_WIPEOUT = 676,
    ATOM_AD_SERVICES_MEASUREMENT_AD_ID_MATCH_FOR_DEBUG_KEYS = 695,
    ATOM_AD_SERVICES_ENROLLMENT_DATA_STORED = 697,
    ATOM_AD_SERVICES_ENROLLMENT_FILE_DOWNLOADED = 698,
    ATOM_AD_SERVICES_ENROLLMENT_MATCHED = 699,
    ATOM_AD_SERVICES_CONSENT_MIGRATED = 702,
    ATOM_AD_SERVICES_ENROLLMENT_FAILED = 714,
    ATOM_AD_SERVICES_MEASUREMENT_CLICK_VERIFICATION = 756,
    ATOM_AD_SERVICES_ENCRYPTION_KEY_FETCHED = 765,
    ATOM_AD_SERVICES_ENCRYPTION_KEY_DB_TRANSACTION_ENDED = 766,
    ATOM_DESTINATION_REGISTERED_BEACONS = 767,
    ATOM_REPORT_INTERACTION_API_CALLED = 768,
    ATOM_INTERACTION_REPORTING_TABLE_CLEARED = 769,
    ATOM_APP_MANIFEST_CONFIG_HELPER_CALLED = 788,
    ATOM_AD_FILTERING_PROCESS_JOIN_CA_REPORTED = 793,
    ATOM_AD_FILTERING_PROCESS_AD_SELECTION_REPORTED = 794,
    ATOM_AD_COUNTER_HISTOGRAM_UPDATER_REPORTED = 795,
    ATOM_SIGNATURE_VERIFICATION = 807,
    ATOM_K_ANON_IMMEDIATE_SIGN_JOIN_STATUS_REPORTED = 808,
    ATOM_K_ANON_BACKGROUND_JOB_STATUS_REPORTED = 809,
    ATOM_K_ANON_INITIALIZE_STATUS_REPORTED = 810,
    ATOM_K_ANON_SIGN_STATUS_REPORTED = 811,
    ATOM_K_ANON_JOIN_STATUS_REPORTED = 812,
    ATOM_K_ANON_KEY_ATTESTATION_STATUS_REPORTED = 813,
    ATOM_GET_AD_SELECTION_DATA_API_CALLED = 814,
    ATOM_GET_AD_SELECTION_DATA_BUYER_INPUT_GENERATED = 815,
    ATOM_BACKGROUND_JOB_SCHEDULING_REPORTED = 834,
    ATOM_TOPICS_ENCRYPTION_EPOCH_COMPUTATION_REPORTED = 840,
    ATOM_TOPICS_ENCRYPTION_GET_TOPICS_REPORTED = 841,
    ATOM_ADSERVICES_SHELL_COMMAND_CALLED = 842,
    ATOM_UPDATE_SIGNALS_API_CALLED = 843,
    ATOM_ENCODING_JOB_RUN = 844,
    ATOM_ENCODING_JS_FETCH = 845,
    ATOM_ENCODING_JS_EXECUTION = 846,
    ATOM_PERSIST_AD_SELECTION_RESULT_CALLED = 847,
    ATOM_SERVER_AUCTION_KEY_FETCH_CALLED = 848,
    ATOM_SERVER_AUCTION_BACKGROUND_KEY_FETCH_ENABLED = 849,
    ATOM_AD_SERVICES_MEASUREMENT_PROCESS_ODP_REGISTRATION = 864,
    ATOM_AD_SERVICES_MEASUREMENT_NOTIFY_REGISTRATION_TO_ODP = 865,
    ATOM_SELECT_ADS_FROM_OUTCOMES_API_CALLED = 876,
    ATOM_REPORT_IMPRESSION_API_CALLED = 877,
    ATOM_AD_SERVICES_ENROLLMENT_TRANSACTION_STATS = 885,
    ATOM_AD_SERVICES_COBALT_LOGGER_EVENT_REPORTED = 902,
    ATOM_AD_SERVICES_COBALT_PERIODIC_JOB_EVENT_REPORTED = 903,
    ATOM_UPDATE_SIGNALS_PROCESS_REPORTED = 905,
    ATOM_TOPICS_SCHEDULE_EPOCH_JOB_SETTING_REPORTED = 930,
    ATOM_AI_WALLPAPERS_BUTTON_PRESSED = 706,
    ATOM_AI_WALLPAPERS_TEMPLATE_SELECTED = 707,
    ATOM_AI_WALLPAPERS_TERM_SELECTED = 708,
    ATOM_AI_WALLPAPERS_WALLPAPER_SET = 709,
    ATOM_AI_WALLPAPERS_SESSION_SUMMARY = 710,
    ATOM_APEX_INSTALLATION_REQUESTED = 732,
    ATOM_APEX_INSTALLATION_STAGED = 733,
    ATOM_APEX_INSTALLATION_ENDED = 734,
    ATOM_APP_SEARCH_SET_SCHEMA_STATS_REPORTED = 385,
    ATOM_APP_SEARCH_SCHEMA_MIGRATION_STATS_REPORTED = 579,
    ATOM_APP_SEARCH_USAGE_SEARCH_INTENT_STATS_REPORTED = 825,
    ATOM_APP_SEARCH_USAGE_SEARCH_INTENT_RAW_QUERY_STATS_REPORTED = 826,
    ATOM_APP_SEARCH_APPS_INDEXER_STATS_REPORTED = 909,
    ATOM_ART_DATUM_REPORTED = 332,
    ATOM_ART_DEVICE_DATUM_REPORTED = 550,
    ATOM_ART_DATUM_DELTA_REPORTED = 565,
    ATOM_ART_DEX2_OAT_REPORTED = 929,
    ATOM_ART_DEVICE_STATUS = 10205,
    ATOM_BACKGROUND_DEXOPT_JOB_ENDED = 467,
    ATOM_PREREBOOT_DEXOPT_JOB_ENDED = 883,
    ATOM_ODREFRESH_REPORTED = 366,
    ATOM_ODSIGN_REPORTED = 548,
    ATOM_AUTOFILL_UI_EVENT_REPORTED = 603,
    ATOM_AUTOFILL_FILL_REQUEST_REPORTED = 604,
    ATOM_AUTOFILL_FILL_RESPONSE_REPORTED = 605,
    ATOM_AUTOFILL_SAVE_EVENT_REPORTED = 606,
    ATOM_AUTOFILL_SESSION_COMMITTED = 607,
    ATOM_AUTOFILL_FIELD_CLASSIFICATION_EVENT_REPORTED = 659,
    ATOM_CAR_RECENTS_EVENT_REPORTED = 770,
    ATOM_CAR_CALM_MODE_EVENT_REPORTED = 797,
    ATOM_CAR_WAKEUP_FROM_SUSPEND_REPORTED = 852,
    ATOM_PLUGIN_INITIALIZED = 655,
    ATOM_BLUETOOTH_HASHED_DEVICE_NAME_REPORTED = 613,
    ATOM_BLUETOOTH_L2_CAP_COC_CLIENT_CONNECTION = 614,
    ATOM_BLUETOOTH_L2_CAP_COC_SERVER_CONNECTION = 615,
    ATOM_BLUETOOTH_LE_SESSION_CONNECTED = 656,
    ATOM_RESTRICTED_BLUETOOTH_DEVICE_NAME_REPORTED = 666,
    ATOM_BLUETOOTH_PROFILE_CONNECTION_ATTEMPTED = 696,
    ATOM_BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED = 781,
    ATOM_BLUETOOTH_RFCOMM_CONNECTION_ATTEMPTED = 782,
    ATOM_REMOTE_DEVICE_INFORMATION_WITH_METRIC_ID = 862,
    ATOM_LE_APP_SCAN_STATE_CHANGED = 870,
    ATOM_LE_RADIO_SCAN_STOPPED = 871,
    ATOM_LE_SCAN_RESULT_RECEIVED = 872,
    ATOM_LE_SCAN_ABUSED = 873,
    ATOM_LE_ADV_STATE_CHANGED = 874,
    ATOM_LE_ADV_ERROR_REPORTED = 875,
    ATOM_A2_DP_SESSION_REPORTED = 904,
    ATOM_BLUETOOTH_CROSS_LAYER_EVENT_REPORTED = 916,
    ATOM_BROADCAST_AUDIO_SESSION_REPORTED = 927,
    ATOM_BROADCAST_AUDIO_SYNC_REPORTED = 928,
    ATOM_BLUETOOTH_RFCOMM_CONNECTION_REPORTED_AT_CLOSE = 982,
    ATOM_BLUETOOTH_LE_CONNECTION = 988,
    ATOM_BROADCAST_SENT = 922,
    ATOM_CAMERA_FEATURE_COMBINATION_QUERY_EVENT = 900,
    ATOM_CERTIFICATE_TRANSPARENCY_LOG_LIST_STATE_CHANGED = 934,
    ATOM_CERTIFICATE_TRANSPARENCY_LOG_LIST_UPDATE_FAILED = 972,
    ATOM_DAILY_KEEPALIVE_INFO_REPORTED = 650,
    ATOM_NETWORK_REQUEST_STATE_CHANGED = 779,
    ATOM_TETHERING_ACTIVE_SESSIONS_REPORTED = 925,
    ATOM_NETWORK_STATS_RECORDER_FILE_OPERATED = 783,
    ATOM_CORE_NETWORKING_TERRIBLE_ERROR_OCCURRED = 979,
    ATOM_APF_SESSION_INFO_REPORTED = 777,
    ATOM_IP_CLIENT_RA_INFO_REPORTED = 778,
    ATOM_VPN_CONNECTION_STATE_CHANGED = 850,
    ATOM_VPN_CONNECTION_REPORTED = 851,
    ATOM_CPU_POLICY = 10199,
    ATOM_CREDENTIAL_MANAGER_API_CALLED = 585,
    ATOM_CREDENTIAL_MANAGER_INIT_PHASE_REPORTED = 651,
    ATOM_CREDENTIAL_MANAGER_CANDIDATE_PHASE_REPORTED = 652,
    ATOM_CREDENTIAL_MANAGER_FINAL_PHASE_REPORTED = 653,
    ATOM_CREDENTIAL_MANAGER_TOTAL_REPORTED = 667,
    ATOM_CREDENTIAL_MANAGER_FINALNOUID_REPORTED = 668,
    ATOM_CREDENTIAL_MANAGER_GET_REPORTED = 669,
    ATOM_CREDENTIAL_MANAGER_AUTH_CLICK_REPORTED = 670,
    ATOM_CREDENTIAL_MANAGER_APIV2_CALLED = 671,
    ATOM_CRONET_ENGINE_CREATED = 703,
    ATOM_CRONET_TRAFFIC_REPORTED = 704,
    ATOM_CRONET_ENGINE_BUILDER_INITIALIZED = 762,
    ATOM_CRONET_HTTP_FLAGS_INITIALIZED = 763,
    ATOM_CRONET_INITIALIZED = 764,
    ATOM_DESKTOP_MODE_UI_CHANGED = 818,
    ATOM_DESKTOP_MODE_SESSION_TASK_UPDATE = 819,
    ATOM_DESKTOP_MODE_TASK_SIZE_UPDATED = 935,
    ATOM_DEVICE_LOCK_CHECK_IN_REQUEST_REPORTED = 726,
    ATOM_DEVICE_LOCK_PROVISIONING_COMPLETE_REPORTED = 727,
    ATOM_DEVICE_LOCK_KIOSK_APP_REQUEST_REPORTED = 728,
    ATOM_DEVICE_LOCK_CHECK_IN_RETRY_REPORTED = 789,
    ATOM_DEVICE_LOCK_PROVISION_FAILURE_REPORTED = 790,
    ATOM_DEVICE_LOCK_LOCK_UNLOCK_DEVICE_FAILURE_REPORTED = 791,
    ATOM_DEVICE_POLICY_MANAGEMENT_MODE = 10216,
    ATOM_DEVICE_POLICY_STATE = 10217,
    ATOM_DISPLAY_MODE_DIRECTOR_VOTE_CHANGED = 792,
    ATOM_EXTERNAL_DISPLAY_STATE_CHANGED = 806,
    ATOM_DND_STATE_CHANGED = 657,
    ATOM_DREAM_SETTING_CHANGED = 705,
    ATOM_DREAM_SETTING_SNAPSHOT = 10192,
    ATOM_EXPRESS_EVENT_REPORTED = 528,
    ATOM_EXPRESS_HISTOGRAM_SAMPLE_REPORTED = 593,
    ATOM_EXPRESS_UID_EVENT_REPORTED = 644,
    ATOM_EXPRESS_UID_HISTOGRAM_SAMPLE_REPORTED = 658,
    ATOM_FEDERATED_COMPUTE_API_CALLED = 712,
    ATOM_FEDERATED_COMPUTE_TRAINING_EVENT_REPORTED = 771,
    ATOM_EXAMPLE_ITERATOR_NEXT_LATENCY_REPORTED = 838,
    ATOM_FULL_SCREEN_INTENT_LAUNCHED = 631,
    ATOM_BAL_ALLOWED = 632,
    ATOM_IN_TASK_ACTIVITY_STARTED = 685,
    ATOM_DEVICE_ORIENTATION_CHANGED = 906,
    ATOM_CACHED_APPS_HIGH_WATERMARK = 10189,
    ATOM_STYLUS_PREDICTION_METRICS_REPORTED = 718,
    ATOM_USER_RISK_EVENT_REPORTED = 725,
    ATOM_MEDIA_PROJECTION_STATE_CHANGED = 729,
    ATOM_MEDIA_PROJECTION_TARGET_CHANGED = 730,
    ATOM_EXCESSIVE_BINDER_PROXY_COUNT_REPORTED = 853,
    ATOM_PROXY_BYTES_TRANSFER_BY_FG_BG = 10200,
    ATOM_MOBILE_BYTES_TRANSFER_BY_PROC_STATE = 10204,
    ATOM_BIOMETRIC_FRR_NOTIFICATION = 817,
    ATOM_SENSITIVE_CONTENT_MEDIA_PROJECTION_SESSION = 830,
    ATOM_SENSITIVE_NOTIFICATION_APP_PROTECTION_SESSION = 831,
    ATOM_SENSITIVE_NOTIFICATION_APP_PROTECTION_APPLIED = 832,
    ATOM_SENSITIVE_NOTIFICATION_REDACTION = 833,
    ATOM_SENSITIVE_CONTENT_APP_PROTECTION = 835,
    ATOM_APP_RESTRICTION_STATE_CHANGED = 866,
    ATOM_BATTERY_USAGE_STATS_PER_UID = 10209,
    ATOM_POSTGC_MEMORY_SNAPSHOT = 924,
    ATOM_POWER_SAVE_TEMP_ALLOWLIST_CHANGED = 926,
    ATOM_APP_OP_ACCESS_TRACKED = 931,
    ATOM_CONTENT_OR_FILE_URI_EVENT_REPORTED = 933,
    ATOM_APPLICATION_GRAMMATICAL_INFLECTION_CHANGED = 584,
    ATOM_SYSTEM_GRAMMATICAL_INFLECTION_CHANGED = 816,
    ATOM_BATTERY_HEALTH = 10220,
    ATOM_HDMI_EARC_STATUS_REPORTED = 701,
    ATOM_HDMI_SOUNDBAR_MODE_STATUS_REPORTED = 724,
    ATOM_HEALTH_CONNECT_API_CALLED = 616,
    ATOM_HEALTH_CONNECT_USAGE_STATS = 617,
    ATOM_HEALTH_CONNECT_STORAGE_STATS = 618,
    ATOM_HEALTH_CONNECT_API_INVOKED = 643,
    ATOM_EXERCISE_ROUTE_API_CALLED = 654,
    ATOM_HEALTH_CONNECT_EXPORT_INVOKED = 907,
    ATOM_HEALTH_CONNECT_IMPORT_INVOKED = 918,
    ATOM_HEALTH_CONNECT_EXPORT_IMPORT_STATS_REPORTED = 919,
    ATOM_HEALTH_CONNECT_UI_IMPRESSION = 623,
    ATOM_HEALTH_CONNECT_UI_INTERACTION = 624,
    ATOM_HEALTH_CONNECT_APP_OPENED_REPORTED = 625,
    ATOM_HOTWORD_EGRESS_SIZE_ATOM_REPORTED = 761,
    ATOM_IKE_SESSION_TERMINATED = 678,
    ATOM_IKE_LIVENESS_CHECK_SESSION_VALIDATED = 760,
    ATOM_NEGOTIATED_SECURITY_ASSOCIATION = 821,
    ATOM_KEYBOARD_CONFIGURED = 682,
    ATOM_KEYBOARD_SYSTEMS_EVENT_REPORTED = 683,
    ATOM_INPUTDEVICE_USAGE_REPORTED = 686,
    ATOM_INPUT_EVENT_LATENCY_REPORTED = 932,
    ATOM_TOUCHPAD_USAGE = 10191,
    ATOM_KERNEL_OOM_KILL_OCCURRED = 754,
    ATOM_EMERGENCY_STATE_CHANGED = 633,
    ATOM_CHRE_SIGNIFICANT_MOTION_STATE_CHANGED = 868,
    ATOM_POPULATION_DENSITY_PROVIDER_LOADING_REPORTED = 1002,
    ATOM_DENSITY_BASED_COARSE_LOCATIONS_USAGE_REPORTED = 1003,
    ATOM_DENSITY_BASED_COARSE_LOCATIONS_PROVIDER_QUERY_REPORTED = 1004,
    ATOM_MEDIA_CODEC_RECLAIM_REQUEST_COMPLETED = 600,
    ATOM_MEDIA_CODEC_STARTED = 641,
    ATOM_MEDIA_CODEC_STOPPED = 642,
    ATOM_MEDIA_CODEC_RENDERED = 684,
    ATOM_MEDIA_EDITING_ENDED_REPORTED = 798,
    ATOM_MTE_STATE = 10181,
    ATOM_MICROXR_DEVICE_BOOT_COMPLETE_REPORTED = 901,
    ATOM_NFC_OBSERVE_MODE_STATE_CHANGED = 855,
    ATOM_NFC_FIELD_CHANGED = 856,
    ATOM_NFC_POLLING_LOOP_NOTIFICATION_REPORTED = 857,
    ATOM_NFC_PROPRIETARY_CAPABILITIES_REPORTED = 858,
    ATOM_ONDEVICEPERSONALIZATION_API_CALLED = 711,
    ATOM_COMPONENT_STATE_CHANGED_REPORTED = 863,
    ATOM_PDF_LOAD_REPORTED = 859,
    ATOM_PDF_API_USAGE_REPORTED = 860,
    ATOM_PDF_SEARCH_REPORTED = 861,
    ATOM_PRESSURE_STALL_INFORMATION = 10229,
    ATOM_PERMISSION_RATIONALE_DIALOG_VIEWED = 645,
    ATOM_PERMISSION_RATIONALE_DIALOG_ACTION_REPORTED = 646,
    ATOM_APP_DATA_SHARING_UPDATES_NOTIFICATION_INTERACTION = 647,
    ATOM_APP_DATA_SHARING_UPDATES_FRAGMENT_VIEWED = 648,
    ATOM_APP_DATA_SHARING_UPDATES_FRAGMENT_ACTION_REPORTED = 649,
    ATOM_ENHANCED_CONFIRMATION_DIALOG_RESULT_REPORTED = 827,
    ATOM_ENHANCED_CONFIRMATION_RESTRICTION_CLEARED = 828,
    ATOM_PHOTOPICKER_SESSION_INFO_REPORTED = 886,
    ATOM_PHOTOPICKER_API_INFO_REPORTED = 887,
    ATOM_PHOTOPICKER_UI_EVENT_LOGGED = 888,
    ATOM_PHOTOPICKER_MEDIA_ITEM_STATUS_REPORTED = 889,
    ATOM_PHOTOPICKER_PREVIEW_INFO_LOGGED = 890,
    ATOM_PHOTOPICKER_MENU_INTERACTION_LOGGED = 891,
    ATOM_PHOTOPICKER_BANNER_INTERACTION_LOGGED = 892,
    ATOM_PHOTOPICKER_MEDIA_LIBRARY_INFO_LOGGED = 893,
    ATOM_PHOTOPICKER_PAGE_INFO_LOGGED = 894,
    ATOM_PHOTOPICKER_MEDIA_GRID_SYNC_INFO_REPORTED = 895,
    ATOM_PHOTOPICKER_ALBUM_SYNC_INFO_REPORTED = 896,
    ATOM_PHOTOPICKER_SEARCH_INFO_REPORTED = 897,
    ATOM_SEARCH_DATA_EXTRACTION_DETAILS_REPORTED = 898,
    ATOM_EMBEDDED_PHOTOPICKER_INFO_REPORTED = 899,
    ATOM_ATOM_9999 = 9999,
    ATOM_ATOM_99999 = 99999,
    ATOM_SCREEN_OFF_REPORTED = 776,
    ATOM_SCREEN_TIMEOUT_OVERRIDE_REPORTED = 836,
    ATOM_SCREEN_INTERACTIVE_SESSION_REPORTED = 837,
    ATOM_SCREEN_DIM_REPORTED = 867,
    ATOM_MEDIA_PROVIDER_DATABASE_ROLLBACK_REPORTED = 784,
    ATOM_BACKUP_SETUP_STATUS_REPORTED = 785,
    ATOM_RANGING_SESSION_CONFIGURED = 993,
    ATOM_RANGING_SESSION_STARTED = 994,
    ATOM_RANGING_SESSION_CLOSED = 995,
    ATOM_RANGING_TECHNOLOGY_STARTED = 996,
    ATOM_RANGING_TECHNOLOGY_STOPPED = 997,
    ATOM_RKPD_POOL_STATS = 664,
    ATOM_RKPD_CLIENT_OPERATION = 665,
    ATOM_SANDBOX_API_CALLED = 488,
    ATOM_SANDBOX_ACTIVITY_EVENT_OCCURRED = 735,
    ATOM_SDK_SANDBOX_RESTRICTED_ACCESS_IN_SESSION = 796,
    ATOM_SANDBOX_SDK_STORAGE = 10159,
    ATOM_SELINUX_AUDIT_LOG = 799,
    ATOM_SETTINGS_SPA_REPORTED = 622,
    ATOM_TEST_EXTENSION_ATOM_REPORTED = 660,
    ATOM_TEST_RESTRICTED_ATOM_REPORTED = 672,
    ATOM_STATS_SOCKET_LOSS_REPORTED = 752,
    ATOM_LOCKSCREEN_SHORTCUT_SELECTED = 611,
    ATOM_LOCKSCREEN_SHORTCUT_TRIGGERED = 612,
    ATOM_LAUNCHER_IMPRESSION_EVENT_V2 = 716,
    ATOM_DISPLAY_SWITCH_LATENCY_TRACKED = 753,
    ATOM_NOTIFICATION_LISTENER_SERVICE = 829,
    ATOM_NAV_HANDLE_TOUCH_POINTS = 869,
    ATOM_COMMUNAL_HUB_WIDGET_EVENT_REPORTED = 908,
    ATOM_COMMUNAL_HUB_SNAPSHOT = 10226,
    ATOM_EMERGENCY_NUMBER_DIALED = 637,
    ATOM_CALL_STATS = 10221,
    ATOM_CALL_AUDIO_ROUTE_STATS = 10222,
    ATOM_TELECOM_API_STATS = 10223,
    ATOM_TELECOM_ERROR_STATS = 10224,
    ATOM_CELLULAR_RADIO_POWER_STATE_CHANGED = 713,
    ATOM_EMERGENCY_NUMBERS_INFO = 10180,
    ATOM_DATA_NETWORK_VALIDATION = 10207,
    ATOM_DATA_RAT_STATE_CHANGED = 854,
    ATOM_CONNECTED_CHANNEL_CHANGED = 882,
    ATOM_IWLAN_UNDERLYING_NETWORK_VALIDATION_RESULT_REPORTED = 923,
    ATOM_QUALIFIED_RAT_LIST_CHANGED = 634,
    ATOM_QNS_IMS_CALL_DROP_STATS = 635,
    ATOM_QNS_FALLBACK_RESTRICTION_CHANGED = 636,
    ATOM_QNS_RAT_PREFERENCE_MISMATCH_INFO = 10177,
    ATOM_QNS_HANDOVER_TIME_MILLIS = 10178,
    ATOM_QNS_HANDOVER_PINGPONG = 10179,
    ATOM_SATELLITE_CONTROLLER = 10182,
    ATOM_SATELLITE_SESSION = 10183,
    ATOM_SATELLITE_INCOMING_DATAGRAM = 10184,
    ATOM_SATELLITE_OUTGOING_DATAGRAM = 10185,
    ATOM_SATELLITE_PROVISION = 10186,
    ATOM_SATELLITE_SOS_MESSAGE_RECOMMENDER = 10187,
    ATOM_CARRIER_ROAMING_SATELLITE_SESSION = 10211,
    ATOM_CARRIER_ROAMING_SATELLITE_CONTROLLER_STATS = 10212,
    ATOM_CONTROLLER_STATS_PER_PACKAGE = 10213,
    ATOM_SATELLITE_ENTITLEMENT = 10214,
    ATOM_SATELLITE_CONFIG_UPDATER = 10215,
    ATOM_SATELLITE_ACCESS_CONTROLLER = 10219,
    ATOM_CELLULAR_IDENTIFIER_DISCLOSED = 800,
    ATOM_THREADNETWORK_TELEMETRY_DATA_REPORTED = 738,
    ATOM_THREADNETWORK_TOPO_ENTRY_REPEATED = 739,
    ATOM_THREADNETWORK_DEVICE_INFO_REPORTED = 740,
    ATOM_BOOT_INTEGRITY_INFO_REPORTED = 775,
    ATOM_TV_LOW_POWER_STANDBY_POLICY = 679,
    ATOM_EXTERNAL_TV_INPUT_EVENT = 717,
    ATOM_TEST_UPROBESTATS_ATOM_REPORTED = 915,
    ATOM_UWB_ACTIVITY_INFO = 10188,
    ATOM_MEDIATOR_UPDATED = 721,
    ATOM_SYSPROXY_BLUETOOTH_BYTES_TRANSFER = 10196,
    ATOM_SYSPROXY_CONNECTION_UPDATED = 786,
    ATOM_WEAR_COMPANION_CONNECTION_STATE = 921,
    ATOM_MEDIA_ACTION_REPORTED = 608,
    ATOM_MEDIA_CONTROLS_LAUNCHED = 609,
    ATOM_MEDIA_SESSION_STATE_CHANGED = 677,
    ATOM_WEAR_MEDIA_OUTPUT_SWITCHER_DEVICE_SCAN_API_LATENCY = 757,
    ATOM_WEAR_MEDIA_OUTPUT_SWITCHER_SASS_DEVICE_UNAVAILABLE = 758,
    ATOM_WEAR_MEDIA_OUTPUT_SWITCHER_FASTPAIR_API_TIMEOUT = 759,
    ATOM_WEAR_MODE_STATE_CHANGED = 715,
    ATOM_RENDERER_INITIALIZED = 736,
    ATOM_SCHEMA_VERSION_RECEIVED = 737,
    ATOM_LAYOUT_INSPECTED = 741,
    ATOM_LAYOUT_EXPRESSION_INSPECTED = 742,
    ATOM_LAYOUT_ANIMATIONS_INSPECTED = 743,
    ATOM_MATERIAL_COMPONENTS_INSPECTED = 744,
    ATOM_TILE_REQUESTED = 745,
    ATOM_STATE_RESPONSE_RECEIVED = 746,
    ATOM_TILE_RESPONSE_RECEIVED = 747,
    ATOM_INFLATION_FINISHED = 748,
    ATOM_INFLATION_FAILED = 749,
    ATOM_IGNORED_INFLATION_FAILURES_REPORTED = 750,
    ATOM_DRAWABLE_RENDERED = 751,
    ATOM_WEAR_TIME_SYNC_REQUESTED = 911,
    ATOM_WEAR_TIME_UPDATE_STARTED = 912,
    ATOM_WEAR_TIME_SYNC_ATTEMPT_COMPLETED = 913,
    ATOM_WEAR_TIME_CHANGED = 914,
    ATOM_WEAR_ADAPTIVE_SUSPEND_STATS_REPORTED = 619,
    ATOM_WEAR_POWER_ANOMALY_SERVICE_OPERATIONAL_STATS_REPORTED = 620,
    ATOM_WEAR_POWER_ANOMALY_SERVICE_EVENT_STATS_REPORTED = 621,
    ATOM_WS_WEAR_TIME_SESSION = 610,
    ATOM_WS_INCOMING_CALL_ACTION_REPORTED = 626,
    ATOM_WS_CALL_DISCONNECTION_REPORTED = 627,
    ATOM_WS_CALL_DURATION_REPORTED = 628,
    ATOM_WS_CALL_USER_EXPERIENCE_LATENCY_REPORTED = 629,
    ATOM_WS_CALL_INTERACTION_REPORTED = 630,
    ATOM_WS_ON_BODY_STATE_CHANGED = 787,
    ATOM_WS_WATCH_FACE_RESTRICTED_COMPLICATIONS_IMPACTED = 802,
    ATOM_WS_WATCH_FACE_DEFAULT_RESTRICTED_COMPLICATIONS_REMOVED = 803,
    ATOM_WS_COMPLICATIONS_IMPACTED_NOTIFICATION_EVENT_REPORTED = 804,
    ATOM_WS_REMOTE_EVENT_USAGE_REPORTED = 920,
    ATOM_WS_BUGREPORT_REQUESTED = 936,
    ATOM_WS_BUGREPORT_TRIGGERED = 937,
    ATOM_WS_BUGREPORT_FINISHED = 938,
    ATOM_WS_BUGREPORT_RESULT_RECEIVED = 939,
    ATOM_WS_STANDALONE_MODE_SNAPSHOT = 10197,
    ATOM_WS_FAVORITE_WATCH_FACE_SNAPSHOT = 10206,
    ATOM_WS_PHOTOS_WATCH_FACE_FEATURE_SNAPSHOT = 10225,
    ATOM_WS_WATCH_FACE_CUSTOMIZATION_SNAPSHOT = 10227,
    ATOM_WEAR_POWER_MENU_OPENED = 731,
    ATOM_WEAR_ASSISTANT_OPENED = 755,
    ATOM_FIRST_OVERLAY_STATE_CHANGED = 917,
    ATOM_WIFI_AWARE_NDP_REPORTED = 638,
    ATOM_WIFI_AWARE_ATTACH_REPORTED = 639,
    ATOM_WIFI_SELF_RECOVERY_TRIGGERED = 661,
    ATOM_SOFT_AP_STARTED = 680,
    ATOM_SOFT_AP_STOPPED = 681,
    ATOM_WIFI_LOCK_RELEASED = 687,
    ATOM_WIFI_LOCK_DEACTIVATED = 688,
    ATOM_WIFI_CONFIG_SAVED = 689,
    ATOM_WIFI_AWARE_RESOURCE_USING_CHANGED = 690,
    ATOM_WIFI_AWARE_HAL_API_CALLED = 691,
    ATOM_WIFI_LOCAL_ONLY_REQUEST_RECEIVED = 692,
    ATOM_WIFI_LOCAL_ONLY_REQUEST_SCAN_TRIGGERED = 693,
    ATOM_WIFI_THREAD_TASK_EXECUTED = 694,
    ATOM_WIFI_STATE_CHANGED = 700,
    ATOM_PNO_SCAN_STARTED = 719,
    ATOM_PNO_SCAN_STOPPED = 720,
    ATOM_WIFI_IS_UNUSABLE_REPORTED = 722,
    ATOM_WIFI_AP_CAPABILITIES_REPORTED = 723,
    ATOM_SOFT_AP_STATE_CHANGED = 805,
    ATOM_SCORER_PREDICTION_RESULT_REPORTED = 884,
    ATOM_WIFI_AWARE_CAPABILITIES = 10190,
    ATOM_WIFI_MODULE_INFO = 10193,
    ATOM_WIFI_SETTING_INFO = 10194,
    ATOM_WIFI_COMPLEX_SETTING_INFO = 10195,
    ATOM_WIFI_CONFIGURED_NETWORK_INFO = 10198,
};
pub const MeminfoCounters = enum(i32) {
    MEMINFO_UNSPECIFIED = 0,
    MEMINFO_MEM_TOTAL = 1,
    MEMINFO_MEM_FREE = 2,
    MEMINFO_MEM_AVAILABLE = 3,
    MEMINFO_BUFFERS = 4,
    MEMINFO_CACHED = 5,
    MEMINFO_SWAP_CACHED = 6,
    MEMINFO_ACTIVE = 7,
    MEMINFO_INACTIVE = 8,
    MEMINFO_ACTIVE_ANON = 9,
    MEMINFO_INACTIVE_ANON = 10,
    MEMINFO_ACTIVE_FILE = 11,
    MEMINFO_INACTIVE_FILE = 12,
    MEMINFO_UNEVICTABLE = 13,
    MEMINFO_MLOCKED = 14,
    MEMINFO_SWAP_TOTAL = 15,
    MEMINFO_SWAP_FREE = 16,
    MEMINFO_DIRTY = 17,
    MEMINFO_WRITEBACK = 18,
    MEMINFO_ANON_PAGES = 19,
    MEMINFO_MAPPED = 20,
    MEMINFO_SHMEM = 21,
    MEMINFO_SLAB = 22,
    MEMINFO_SLAB_RECLAIMABLE = 23,
    MEMINFO_SLAB_UNRECLAIMABLE = 24,
    MEMINFO_KERNEL_STACK = 25,
    MEMINFO_PAGE_TABLES = 26,
    MEMINFO_COMMIT_LIMIT = 27,
    MEMINFO_COMMITED_AS = 28,
    MEMINFO_VMALLOC_TOTAL = 29,
    MEMINFO_VMALLOC_USED = 30,
    MEMINFO_VMALLOC_CHUNK = 31,
    MEMINFO_CMA_TOTAL = 32,
    MEMINFO_CMA_FREE = 33,
    MEMINFO_GPU = 34,
    MEMINFO_ZRAM = 35,
    MEMINFO_MISC = 36,
    MEMINFO_ION_HEAP = 37,
    MEMINFO_ION_HEAP_POOL = 38,
};
pub const VmstatCounters = enum(i32) {
    VMSTAT_UNSPECIFIED = 0,
    VMSTAT_NR_FREE_PAGES = 1,
    VMSTAT_NR_ALLOC_BATCH = 2,
    VMSTAT_NR_INACTIVE_ANON = 3,
    VMSTAT_NR_ACTIVE_ANON = 4,
    VMSTAT_NR_INACTIVE_FILE = 5,
    VMSTAT_NR_ACTIVE_FILE = 6,
    VMSTAT_NR_UNEVICTABLE = 7,
    VMSTAT_NR_MLOCK = 8,
    VMSTAT_NR_ANON_PAGES = 9,
    VMSTAT_NR_MAPPED = 10,
    VMSTAT_NR_FILE_PAGES = 11,
    VMSTAT_NR_DIRTY = 12,
    VMSTAT_NR_WRITEBACK = 13,
    VMSTAT_NR_SLAB_RECLAIMABLE = 14,
    VMSTAT_NR_SLAB_UNRECLAIMABLE = 15,
    VMSTAT_NR_PAGE_TABLE_PAGES = 16,
    VMSTAT_NR_KERNEL_STACK = 17,
    VMSTAT_NR_OVERHEAD = 18,
    VMSTAT_NR_UNSTABLE = 19,
    VMSTAT_NR_BOUNCE = 20,
    VMSTAT_NR_VMSCAN_WRITE = 21,
    VMSTAT_NR_VMSCAN_IMMEDIATE_RECLAIM = 22,
    VMSTAT_NR_WRITEBACK_TEMP = 23,
    VMSTAT_NR_ISOLATED_ANON = 24,
    VMSTAT_NR_ISOLATED_FILE = 25,
    VMSTAT_NR_SHMEM = 26,
    VMSTAT_NR_DIRTIED = 27,
    VMSTAT_NR_WRITTEN = 28,
    VMSTAT_NR_PAGES_SCANNED = 29,
    VMSTAT_WORKINGSET_REFAULT = 30,
    VMSTAT_WORKINGSET_ACTIVATE = 31,
    VMSTAT_WORKINGSET_NODERECLAIM = 32,
    VMSTAT_NR_ANON_TRANSPARENT_HUGEPAGES = 33,
    VMSTAT_NR_FREE_CMA = 34,
    VMSTAT_NR_SWAPCACHE = 35,
    VMSTAT_NR_DIRTY_THRESHOLD = 36,
    VMSTAT_NR_DIRTY_BACKGROUND_THRESHOLD = 37,
    VMSTAT_PGPGIN = 38,
    VMSTAT_PGPGOUT = 39,
    VMSTAT_PGPGOUTCLEAN = 40,
    VMSTAT_PSWPIN = 41,
    VMSTAT_PSWPOUT = 42,
    VMSTAT_PGALLOC_DMA = 43,
    VMSTAT_PGALLOC_NORMAL = 44,
    VMSTAT_PGALLOC_MOVABLE = 45,
    VMSTAT_PGFREE = 46,
    VMSTAT_PGACTIVATE = 47,
    VMSTAT_PGDEACTIVATE = 48,
    VMSTAT_PGFAULT = 49,
    VMSTAT_PGMAJFAULT = 50,
    VMSTAT_PGREFILL_DMA = 51,
    VMSTAT_PGREFILL_NORMAL = 52,
    VMSTAT_PGREFILL_MOVABLE = 53,
    VMSTAT_PGSTEAL_KSWAPD_DMA = 54,
    VMSTAT_PGSTEAL_KSWAPD_NORMAL = 55,
    VMSTAT_PGSTEAL_KSWAPD_MOVABLE = 56,
    VMSTAT_PGSTEAL_DIRECT_DMA = 57,
    VMSTAT_PGSTEAL_DIRECT_NORMAL = 58,
    VMSTAT_PGSTEAL_DIRECT_MOVABLE = 59,
    VMSTAT_PGSCAN_KSWAPD_DMA = 60,
    VMSTAT_PGSCAN_KSWAPD_NORMAL = 61,
    VMSTAT_PGSCAN_KSWAPD_MOVABLE = 62,
    VMSTAT_PGSCAN_DIRECT_DMA = 63,
    VMSTAT_PGSCAN_DIRECT_NORMAL = 64,
    VMSTAT_PGSCAN_DIRECT_MOVABLE = 65,
    VMSTAT_PGSCAN_DIRECT_THROTTLE = 66,
    VMSTAT_PGINODESTEAL = 67,
    VMSTAT_SLABS_SCANNED = 68,
    VMSTAT_KSWAPD_INODESTEAL = 69,
    VMSTAT_KSWAPD_LOW_WMARK_HIT_QUICKLY = 70,
    VMSTAT_KSWAPD_HIGH_WMARK_HIT_QUICKLY = 71,
    VMSTAT_PAGEOUTRUN = 72,
    VMSTAT_ALLOCSTALL = 73,
    VMSTAT_PGROTATED = 74,
    VMSTAT_DROP_PAGECACHE = 75,
    VMSTAT_DROP_SLAB = 76,
    VMSTAT_PGMIGRATE_SUCCESS = 77,
    VMSTAT_PGMIGRATE_FAIL = 78,
    VMSTAT_COMPACT_MIGRATE_SCANNED = 79,
    VMSTAT_COMPACT_FREE_SCANNED = 80,
    VMSTAT_COMPACT_ISOLATED = 81,
    VMSTAT_COMPACT_STALL = 82,
    VMSTAT_COMPACT_FAIL = 83,
    VMSTAT_COMPACT_SUCCESS = 84,
    VMSTAT_COMPACT_DAEMON_WAKE = 85,
    VMSTAT_UNEVICTABLE_PGS_CULLED = 86,
    VMSTAT_UNEVICTABLE_PGS_SCANNED = 87,
    VMSTAT_UNEVICTABLE_PGS_RESCUED = 88,
    VMSTAT_UNEVICTABLE_PGS_MLOCKED = 89,
    VMSTAT_UNEVICTABLE_PGS_MUNLOCKED = 90,
    VMSTAT_UNEVICTABLE_PGS_CLEARED = 91,
    VMSTAT_UNEVICTABLE_PGS_STRANDED = 92,
    VMSTAT_NR_ZSPAGES = 93,
    VMSTAT_NR_ION_HEAP = 94,
    VMSTAT_NR_GPU_HEAP = 95,
    VMSTAT_ALLOCSTALL_DMA = 96,
    VMSTAT_ALLOCSTALL_MOVABLE = 97,
    VMSTAT_ALLOCSTALL_NORMAL = 98,
    VMSTAT_COMPACT_DAEMON_FREE_SCANNED = 99,
    VMSTAT_COMPACT_DAEMON_MIGRATE_SCANNED = 100,
    VMSTAT_NR_FASTRPC = 101,
    VMSTAT_NR_INDIRECTLY_RECLAIMABLE = 102,
    VMSTAT_NR_ION_HEAP_POOL = 103,
    VMSTAT_NR_KERNEL_MISC_RECLAIMABLE = 104,
    VMSTAT_NR_SHADOW_CALL_STACK_BYTES = 105,
    VMSTAT_NR_SHMEM_HUGEPAGES = 106,
    VMSTAT_NR_SHMEM_PMDMAPPED = 107,
    VMSTAT_NR_UNRECLAIMABLE_PAGES = 108,
    VMSTAT_NR_ZONE_ACTIVE_ANON = 109,
    VMSTAT_NR_ZONE_ACTIVE_FILE = 110,
    VMSTAT_NR_ZONE_INACTIVE_ANON = 111,
    VMSTAT_NR_ZONE_INACTIVE_FILE = 112,
    VMSTAT_NR_ZONE_UNEVICTABLE = 113,
    VMSTAT_NR_ZONE_WRITE_PENDING = 114,
    VMSTAT_OOM_KILL = 115,
    VMSTAT_PGLAZYFREE = 116,
    VMSTAT_PGLAZYFREED = 117,
    VMSTAT_PGREFILL = 118,
    VMSTAT_PGSCAN_DIRECT = 119,
    VMSTAT_PGSCAN_KSWAPD = 120,
    VMSTAT_PGSKIP_DMA = 121,
    VMSTAT_PGSKIP_MOVABLE = 122,
    VMSTAT_PGSKIP_NORMAL = 123,
    VMSTAT_PGSTEAL_DIRECT = 124,
    VMSTAT_PGSTEAL_KSWAPD = 125,
    VMSTAT_SWAP_RA = 126,
    VMSTAT_SWAP_RA_HIT = 127,
    VMSTAT_WORKINGSET_RESTORE = 128,
    VMSTAT_ALLOCSTALL_DEVICE = 129,
    VMSTAT_ALLOCSTALL_DMA32 = 130,
    VMSTAT_BALLOON_DEFLATE = 131,
    VMSTAT_BALLOON_INFLATE = 132,
    VMSTAT_BALLOON_MIGRATE = 133,
    VMSTAT_CMA_ALLOC_FAIL = 134,
    VMSTAT_CMA_ALLOC_SUCCESS = 135,
    VMSTAT_NR_FILE_HUGEPAGES = 136,
    VMSTAT_NR_FILE_PMDMAPPED = 137,
    VMSTAT_NR_FOLL_PIN_ACQUIRED = 138,
    VMSTAT_NR_FOLL_PIN_RELEASED = 139,
    VMSTAT_NR_SEC_PAGE_TABLE_PAGES = 140,
    VMSTAT_NR_SHADOW_CALL_STACK = 141,
    VMSTAT_NR_SWAPCACHED = 142,
    VMSTAT_NR_THROTTLED_WRITTEN = 143,
    VMSTAT_PGALLOC_DEVICE = 144,
    VMSTAT_PGALLOC_DMA32 = 145,
    VMSTAT_PGDEMOTE_DIRECT = 146,
    VMSTAT_PGDEMOTE_KSWAPD = 147,
    VMSTAT_PGREUSE = 148,
    VMSTAT_PGSCAN_ANON = 149,
    VMSTAT_PGSCAN_FILE = 150,
    VMSTAT_PGSKIP_DEVICE = 151,
    VMSTAT_PGSKIP_DMA32 = 152,
    VMSTAT_PGSTEAL_ANON = 153,
    VMSTAT_PGSTEAL_FILE = 154,
    VMSTAT_THP_COLLAPSE_ALLOC = 155,
    VMSTAT_THP_COLLAPSE_ALLOC_FAILED = 156,
    VMSTAT_THP_DEFERRED_SPLIT_PAGE = 157,
    VMSTAT_THP_FAULT_ALLOC = 158,
    VMSTAT_THP_FAULT_FALLBACK = 159,
    VMSTAT_THP_FAULT_FALLBACK_CHARGE = 160,
    VMSTAT_THP_FILE_ALLOC = 161,
    VMSTAT_THP_FILE_FALLBACK = 162,
    VMSTAT_THP_FILE_FALLBACK_CHARGE = 163,
    VMSTAT_THP_FILE_MAPPED = 164,
    VMSTAT_THP_MIGRATION_FAIL = 165,
    VMSTAT_THP_MIGRATION_SPLIT = 166,
    VMSTAT_THP_MIGRATION_SUCCESS = 167,
    VMSTAT_THP_SCAN_EXCEED_NONE_PTE = 168,
    VMSTAT_THP_SCAN_EXCEED_SHARE_PTE = 169,
    VMSTAT_THP_SCAN_EXCEED_SWAP_PTE = 170,
    VMSTAT_THP_SPLIT_PAGE = 171,
    VMSTAT_THP_SPLIT_PAGE_FAILED = 172,
    VMSTAT_THP_SPLIT_PMD = 173,
    VMSTAT_THP_SWPOUT = 174,
    VMSTAT_THP_SWPOUT_FALLBACK = 175,
    VMSTAT_THP_ZERO_PAGE_ALLOC = 176,
    VMSTAT_THP_ZERO_PAGE_ALLOC_FAILED = 177,
    VMSTAT_VMA_LOCK_ABORT = 178,
    VMSTAT_VMA_LOCK_MISS = 179,
    VMSTAT_VMA_LOCK_RETRY = 180,
    VMSTAT_VMA_LOCK_SUCCESS = 181,
    VMSTAT_WORKINGSET_ACTIVATE_ANON = 182,
    VMSTAT_WORKINGSET_ACTIVATE_FILE = 183,
    VMSTAT_WORKINGSET_NODES = 184,
    VMSTAT_WORKINGSET_REFAULT_ANON = 185,
    VMSTAT_WORKINGSET_REFAULT_FILE = 186,
    VMSTAT_WORKINGSET_RESTORE_ANON = 187,
    VMSTAT_WORKINGSET_RESTORE_FILE = 188,
};
// structs
const FtraceDescriptorWire = struct {
    const ATRACE_CATEGORIES_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const FtraceDescriptor = struct {
    // nested structs
    const AtraceCategoryWire = struct {
        const NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const DESCRIPTION_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const AtraceCategory = struct {
        // fields
        name: ?[]const u8 = null,
        description: ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const FtraceDescriptor.AtraceCategory) usize {
            var res: usize = 0;
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(FtraceDescriptor.AtraceCategoryWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.description) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(FtraceDescriptor.AtraceCategoryWire.DESCRIPTION_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            return res;
        }
        pub fn encode(self: *const FtraceDescriptor.AtraceCategory, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const FtraceDescriptor.AtraceCategory, target: *gremlin.Writer) void {
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(FtraceDescriptor.AtraceCategoryWire.NAME_WIRE, v);
                }
            }
            if (self.description) |v| {
                if (v.len > 0) {
                    target.appendBytes(FtraceDescriptor.AtraceCategoryWire.DESCRIPTION_WIRE, v);
                }
            }
        }
    };
    pub const AtraceCategoryReader = struct {
        buf: gremlin.Reader,
        _name: ?[]const u8 = null,
        _description: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!FtraceDescriptor.AtraceCategoryReader {
            const buf = gremlin.Reader.init(src);
            var res = FtraceDescriptor.AtraceCategoryReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    FtraceDescriptor.AtraceCategoryWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    FtraceDescriptor.AtraceCategoryWire.DESCRIPTION_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._description = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getName(self: *const FtraceDescriptor.AtraceCategoryReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub inline fn getDescription(self: *const FtraceDescriptor.AtraceCategoryReader) []const u8 {
            return self._description orelse &[_]u8{};
        }
    };
    // fields
    atrace_categories: ?[]const ?FtraceDescriptor.AtraceCategory = null,
    pub fn calcProtobufSize(self: *const FtraceDescriptor) usize {
        var res: usize = 0;
        if (self.atrace_categories) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(FtraceDescriptorWire.ATRACE_CATEGORIES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const FtraceDescriptor, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const FtraceDescriptor, target: *gremlin.Writer) void {
        if (self.atrace_categories) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(FtraceDescriptorWire.ATRACE_CATEGORIES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(FtraceDescriptorWire.ATRACE_CATEGORIES_WIRE, 0);
                }
            }
        }
    }
};
pub const FtraceDescriptorReader = struct {
    buf: gremlin.Reader,
    _atrace_categories_offset: ?usize = null,
    _atrace_categories_last_offset: ?usize = null,
    _atrace_categories_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!FtraceDescriptorReader {
        const buf = gremlin.Reader.init(src);
        var res = FtraceDescriptorReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                FtraceDescriptorWire.ATRACE_CATEGORIES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._atrace_categories_offset == null) {
                        res._atrace_categories_offset = offset - result.size;
                    }
                    res._atrace_categories_last_offset = offset;
                    res._atrace_categories_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn atraceCategoriesCount(self: *const FtraceDescriptorReader) usize {
        return self._atrace_categories_cnt;
    }
    pub fn atraceCategoriesNext(self: *FtraceDescriptorReader) ?FtraceDescriptor.AtraceCategoryReader {
        if (self._atrace_categories_offset == null) return null;
        const current_offset = self._atrace_categories_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = FtraceDescriptor.AtraceCategoryReader.init(result.value) catch return null;
        if (self._atrace_categories_last_offset != null and current_offset >= self._atrace_categories_last_offset.?) {
            self._atrace_categories_offset = null;
            return msg;
        }
        if (self._atrace_categories_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._atrace_categories_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == FtraceDescriptorWire.ATRACE_CATEGORIES_WIRE) {
                self._atrace_categories_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._atrace_categories_offset = null;
        return msg;
    }
};
const GpuCounterDescriptorWire = struct {
    const SPECS_WIRE: gremlin.ProtoWireNumber = 1;
    const BLOCKS_WIRE: gremlin.ProtoWireNumber = 2;
    const MIN_SAMPLING_PERIOD_NS_WIRE: gremlin.ProtoWireNumber = 3;
    const MAX_SAMPLING_PERIOD_NS_WIRE: gremlin.ProtoWireNumber = 4;
    const SUPPORTS_INSTRUMENTED_SAMPLING_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const GpuCounterDescriptor = struct {
    // nested enums
    pub const GpuCounterGroup = enum(i32) {
        UNCLASSIFIED = 0,
        SYSTEM = 1,
        VERTICES = 2,
        FRAGMENTS = 3,
        PRIMITIVES = 4,
        MEMORY = 5,
        COMPUTE = 6,
        RAY_TRACING = 7,
    };
    pub const MeasureUnit = enum(i32) {
        NONE = 0,
        BIT = 1,
        KILOBIT = 2,
        MEGABIT = 3,
        GIGABIT = 4,
        TERABIT = 5,
        PETABIT = 6,
        BYTE = 7,
        KILOBYTE = 8,
        MEGABYTE = 9,
        GIGABYTE = 10,
        TERABYTE = 11,
        PETABYTE = 12,
        HERTZ = 13,
        KILOHERTZ = 14,
        MEGAHERTZ = 15,
        GIGAHERTZ = 16,
        TERAHERTZ = 17,
        PETAHERTZ = 18,
        NANOSECOND = 19,
        MICROSECOND = 20,
        MILLISECOND = 21,
        SECOND = 22,
        MINUTE = 23,
        HOUR = 24,
        VERTEX = 25,
        PIXEL = 26,
        TRIANGLE = 27,
        PRIMITIVE = 38,
        FRAGMENT = 39,
        MILLIWATT = 28,
        WATT = 29,
        KILOWATT = 30,
        JOULE = 31,
        VOLT = 32,
        AMPERE = 33,
        CELSIUS = 34,
        FAHRENHEIT = 35,
        KELVIN = 36,
        PERCENT = 37,
        INSTRUCTION = 40,
    };
    // nested structs
    const GpuCounterSpecWire = struct {
        const COUNTER_ID_WIRE: gremlin.ProtoWireNumber = 1;
        const NAME_WIRE: gremlin.ProtoWireNumber = 2;
        const DESCRIPTION_WIRE: gremlin.ProtoWireNumber = 3;
        const NUMERATOR_UNITS_WIRE: gremlin.ProtoWireNumber = 7;
        const DENOMINATOR_UNITS_WIRE: gremlin.ProtoWireNumber = 8;
        const SELECT_BY_DEFAULT_WIRE: gremlin.ProtoWireNumber = 9;
        const GROUPS_WIRE: gremlin.ProtoWireNumber = 10;
        const INT_PEAK_VALUE_WIRE: gremlin.ProtoWireNumber = 5;
        const DOUBLE_PEAK_VALUE_WIRE: gremlin.ProtoWireNumber = 6;
    };
    pub const GpuCounterSpec = struct {
        // fields
        counter_id: u32 = 0,
        name: ?[]const u8 = null,
        description: ?[]const u8 = null,
        numerator_units: ?[]const GpuCounterDescriptor.MeasureUnit = null,
        denominator_units: ?[]const GpuCounterDescriptor.MeasureUnit = null,
        select_by_default: bool = false,
        groups: ?[]const GpuCounterDescriptor.GpuCounterGroup = null,
        int_peak_value: i64 = 0,
        double_peak_value: f64 = 0.0,
        pub fn calcProtobufSize(self: *const GpuCounterDescriptor.GpuCounterSpec) usize {
            var res: usize = 0;
            if (self.counter_id != 0) {
                res += gremlin.sizes.sizeWireNumber(GpuCounterDescriptor.GpuCounterSpecWire.COUNTER_ID_WIRE) + gremlin.sizes.sizeU32(self.counter_id);
            }
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(GpuCounterDescriptor.GpuCounterSpecWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.description) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(GpuCounterDescriptor.GpuCounterSpecWire.DESCRIPTION_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.numerator_units) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    res += gremlin.sizes.sizeWireNumber(GpuCounterDescriptor.GpuCounterSpecWire.NUMERATOR_UNITS_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(arr[0]));
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeI32(@intFromEnum(v));
                    }
                    res += gremlin.sizes.sizeWireNumber(GpuCounterDescriptor.GpuCounterSpecWire.NUMERATOR_UNITS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
                }
            }
            if (self.denominator_units) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    res += gremlin.sizes.sizeWireNumber(GpuCounterDescriptor.GpuCounterSpecWire.DENOMINATOR_UNITS_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(arr[0]));
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeI32(@intFromEnum(v));
                    }
                    res += gremlin.sizes.sizeWireNumber(GpuCounterDescriptor.GpuCounterSpecWire.DENOMINATOR_UNITS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
                }
            }
            if (self.select_by_default != false) {
                res += gremlin.sizes.sizeWireNumber(GpuCounterDescriptor.GpuCounterSpecWire.SELECT_BY_DEFAULT_WIRE) + gremlin.sizes.sizeBool(self.select_by_default);
            }
            if (self.groups) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    res += gremlin.sizes.sizeWireNumber(GpuCounterDescriptor.GpuCounterSpecWire.GROUPS_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(arr[0]));
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeI32(@intFromEnum(v));
                    }
                    res += gremlin.sizes.sizeWireNumber(GpuCounterDescriptor.GpuCounterSpecWire.GROUPS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
                }
            }
            if (self.int_peak_value != 0) {
                res += gremlin.sizes.sizeWireNumber(GpuCounterDescriptor.GpuCounterSpecWire.INT_PEAK_VALUE_WIRE) + gremlin.sizes.sizeI64(self.int_peak_value);
            }
            if (self.double_peak_value != 0.0) {
                res += gremlin.sizes.sizeWireNumber(GpuCounterDescriptor.GpuCounterSpecWire.DOUBLE_PEAK_VALUE_WIRE) + gremlin.sizes.sizeDouble(self.double_peak_value);
            }
            return res;
        }
        pub fn encode(self: *const GpuCounterDescriptor.GpuCounterSpec, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const GpuCounterDescriptor.GpuCounterSpec, target: *gremlin.Writer) void {
            if (self.counter_id != 0) {
                target.appendUint32(GpuCounterDescriptor.GpuCounterSpecWire.COUNTER_ID_WIRE, self.counter_id);
            }
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(GpuCounterDescriptor.GpuCounterSpecWire.NAME_WIRE, v);
                }
            }
            if (self.description) |v| {
                if (v.len > 0) {
                    target.appendBytes(GpuCounterDescriptor.GpuCounterSpecWire.DESCRIPTION_WIRE, v);
                }
            }
            if (self.numerator_units) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    target.appendInt32(GpuCounterDescriptor.GpuCounterSpecWire.NUMERATOR_UNITS_WIRE, @intFromEnum(arr[0]));
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeI32(@intFromEnum(v));
                    }
                    target.appendBytesTag(GpuCounterDescriptor.GpuCounterSpecWire.NUMERATOR_UNITS_WIRE, packed_size);
                    for (arr) |v| {
                        target.appendInt32WithoutTag(@intFromEnum(v));
                    }
                }
            }
            if (self.denominator_units) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    target.appendInt32(GpuCounterDescriptor.GpuCounterSpecWire.DENOMINATOR_UNITS_WIRE, @intFromEnum(arr[0]));
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeI32(@intFromEnum(v));
                    }
                    target.appendBytesTag(GpuCounterDescriptor.GpuCounterSpecWire.DENOMINATOR_UNITS_WIRE, packed_size);
                    for (arr) |v| {
                        target.appendInt32WithoutTag(@intFromEnum(v));
                    }
                }
            }
            if (self.select_by_default != false) {
                target.appendBool(GpuCounterDescriptor.GpuCounterSpecWire.SELECT_BY_DEFAULT_WIRE, self.select_by_default);
            }
            if (self.groups) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    target.appendInt32(GpuCounterDescriptor.GpuCounterSpecWire.GROUPS_WIRE, @intFromEnum(arr[0]));
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeI32(@intFromEnum(v));
                    }
                    target.appendBytesTag(GpuCounterDescriptor.GpuCounterSpecWire.GROUPS_WIRE, packed_size);
                    for (arr) |v| {
                        target.appendInt32WithoutTag(@intFromEnum(v));
                    }
                }
            }
            if (self.int_peak_value != 0) {
                target.appendInt64(GpuCounterDescriptor.GpuCounterSpecWire.INT_PEAK_VALUE_WIRE, self.int_peak_value);
            }
            if (self.double_peak_value != 0.0) {
                target.appendFloat64(GpuCounterDescriptor.GpuCounterSpecWire.DOUBLE_PEAK_VALUE_WIRE, self.double_peak_value);
            }
        }
    };
    pub const GpuCounterSpecReader = struct {
        buf: gremlin.Reader,
        _counter_id: u32 = 0,
        _name: ?[]const u8 = null,
        _description: ?[]const u8 = null,
        _numerator_units_offset: ?usize = null,
        _numerator_units_last_offset: ?usize = null,
        _numerator_units_packed: bool = false,
        _denominator_units_offset: ?usize = null,
        _denominator_units_last_offset: ?usize = null,
        _denominator_units_packed: bool = false,
        _select_by_default: bool = false,
        _groups_offset: ?usize = null,
        _groups_last_offset: ?usize = null,
        _groups_packed: bool = false,
        _int_peak_value: i64 = 0,
        _double_peak_value: f64 = 0.0,
        pub fn init(src: []const u8) gremlin.Error!GpuCounterDescriptor.GpuCounterSpecReader {
            const buf = gremlin.Reader.init(src);
            var res = GpuCounterDescriptor.GpuCounterSpecReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    GpuCounterDescriptor.GpuCounterSpecWire.COUNTER_ID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._counter_id = result.value;
                    },
                    GpuCounterDescriptor.GpuCounterSpecWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    GpuCounterDescriptor.GpuCounterSpecWire.DESCRIPTION_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._description = result.value;
                    },
                    GpuCounterDescriptor.GpuCounterSpecWire.NUMERATOR_UNITS_WIRE => {
                        if (res._numerator_units_offset == null) {
                            res._numerator_units_offset = offset;
                        }
                        if (tag.wire == gremlin.ProtoWireType.bytes) {
                            res._numerator_units_packed = true;
                            const length_result = try buf.readVarInt(offset);
                            res._numerator_units_offset = offset + length_result.size;
                            res._numerator_units_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                            offset = res._numerator_units_last_offset.?;
                        } else {
                            const result = try buf.readInt32(offset);
                            offset += result.size;
                            res._numerator_units_last_offset = offset;
                        }
                    },
                    GpuCounterDescriptor.GpuCounterSpecWire.DENOMINATOR_UNITS_WIRE => {
                        if (res._denominator_units_offset == null) {
                            res._denominator_units_offset = offset;
                        }
                        if (tag.wire == gremlin.ProtoWireType.bytes) {
                            res._denominator_units_packed = true;
                            const length_result = try buf.readVarInt(offset);
                            res._denominator_units_offset = offset + length_result.size;
                            res._denominator_units_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                            offset = res._denominator_units_last_offset.?;
                        } else {
                            const result = try buf.readInt32(offset);
                            offset += result.size;
                            res._denominator_units_last_offset = offset;
                        }
                    },
                    GpuCounterDescriptor.GpuCounterSpecWire.SELECT_BY_DEFAULT_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._select_by_default = result.value;
                    },
                    GpuCounterDescriptor.GpuCounterSpecWire.GROUPS_WIRE => {
                        if (res._groups_offset == null) {
                            res._groups_offset = offset;
                        }
                        if (tag.wire == gremlin.ProtoWireType.bytes) {
                            res._groups_packed = true;
                            const length_result = try buf.readVarInt(offset);
                            res._groups_offset = offset + length_result.size;
                            res._groups_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                            offset = res._groups_last_offset.?;
                        } else {
                            const result = try buf.readInt32(offset);
                            offset += result.size;
                            res._groups_last_offset = offset;
                        }
                    },
                    GpuCounterDescriptor.GpuCounterSpecWire.INT_PEAK_VALUE_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._int_peak_value = result.value;
                    },
                    GpuCounterDescriptor.GpuCounterSpecWire.DOUBLE_PEAK_VALUE_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._double_peak_value = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getCounterId(self: *const GpuCounterDescriptor.GpuCounterSpecReader) u32 {
            return self._counter_id;
        }
        pub inline fn getName(self: *const GpuCounterDescriptor.GpuCounterSpecReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub inline fn getDescription(self: *const GpuCounterDescriptor.GpuCounterSpecReader) []const u8 {
            return self._description orelse &[_]u8{};
        }
        pub fn numeratorUnitsNext(self: *GpuCounterDescriptor.GpuCounterSpecReader) gremlin.Error!?GpuCounterDescriptor.MeasureUnit {
            if (self._numerator_units_offset == null) return null;
            const current_offset = self._numerator_units_offset.?;
            if (current_offset >= self._numerator_units_last_offset.?) {
                self._numerator_units_offset = null;
                return null;
            }
            if (self._numerator_units_packed) {
                const value_result = try self.buf.readInt32(current_offset);
                self._numerator_units_offset = current_offset + value_result.size;
                if (self._numerator_units_offset.? >= self._numerator_units_last_offset.?) {
                    self._numerator_units_offset = null;
                }
                return @enumFromInt(value_result.value);
            } else {
                const value_result = try self.buf.readInt32(current_offset);
                var next_offset = current_offset + value_result.size;
                const max_offset = self._numerator_units_last_offset.?;
                // Search for the next occurrence of this field
                while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                    const next_tag = try self.buf.readTagAt(next_offset);
                    next_offset += next_tag.size;
                    if (next_tag.number == GpuCounterDescriptor.GpuCounterSpecWire.NUMERATOR_UNITS_WIRE) {
                        self._numerator_units_offset = next_offset;
                        return @enumFromInt(value_result.value);
                    } else {
                        next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                    }
                }
                self._numerator_units_offset = null;
                return @enumFromInt(value_result.value);
            }
        }
        pub fn denominatorUnitsNext(self: *GpuCounterDescriptor.GpuCounterSpecReader) gremlin.Error!?GpuCounterDescriptor.MeasureUnit {
            if (self._denominator_units_offset == null) return null;
            const current_offset = self._denominator_units_offset.?;
            if (current_offset >= self._denominator_units_last_offset.?) {
                self._denominator_units_offset = null;
                return null;
            }
            if (self._denominator_units_packed) {
                const value_result = try self.buf.readInt32(current_offset);
                self._denominator_units_offset = current_offset + value_result.size;
                if (self._denominator_units_offset.? >= self._denominator_units_last_offset.?) {
                    self._denominator_units_offset = null;
                }
                return @enumFromInt(value_result.value);
            } else {
                const value_result = try self.buf.readInt32(current_offset);
                var next_offset = current_offset + value_result.size;
                const max_offset = self._denominator_units_last_offset.?;
                // Search for the next occurrence of this field
                while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                    const next_tag = try self.buf.readTagAt(next_offset);
                    next_offset += next_tag.size;
                    if (next_tag.number == GpuCounterDescriptor.GpuCounterSpecWire.DENOMINATOR_UNITS_WIRE) {
                        self._denominator_units_offset = next_offset;
                        return @enumFromInt(value_result.value);
                    } else {
                        next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                    }
                }
                self._denominator_units_offset = null;
                return @enumFromInt(value_result.value);
            }
        }
        pub inline fn getSelectByDefault(self: *const GpuCounterDescriptor.GpuCounterSpecReader) bool {
            return self._select_by_default;
        }
        pub fn groupsNext(self: *GpuCounterDescriptor.GpuCounterSpecReader) gremlin.Error!?GpuCounterDescriptor.GpuCounterGroup {
            if (self._groups_offset == null) return null;
            const current_offset = self._groups_offset.?;
            if (current_offset >= self._groups_last_offset.?) {
                self._groups_offset = null;
                return null;
            }
            if (self._groups_packed) {
                const value_result = try self.buf.readInt32(current_offset);
                self._groups_offset = current_offset + value_result.size;
                if (self._groups_offset.? >= self._groups_last_offset.?) {
                    self._groups_offset = null;
                }
                return @enumFromInt(value_result.value);
            } else {
                const value_result = try self.buf.readInt32(current_offset);
                var next_offset = current_offset + value_result.size;
                const max_offset = self._groups_last_offset.?;
                // Search for the next occurrence of this field
                while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                    const next_tag = try self.buf.readTagAt(next_offset);
                    next_offset += next_tag.size;
                    if (next_tag.number == GpuCounterDescriptor.GpuCounterSpecWire.GROUPS_WIRE) {
                        self._groups_offset = next_offset;
                        return @enumFromInt(value_result.value);
                    } else {
                        next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                    }
                }
                self._groups_offset = null;
                return @enumFromInt(value_result.value);
            }
        }
        pub inline fn getIntPeakValue(self: *const GpuCounterDescriptor.GpuCounterSpecReader) i64 {
            return self._int_peak_value;
        }
        pub inline fn getDoublePeakValue(self: *const GpuCounterDescriptor.GpuCounterSpecReader) f64 {
            return self._double_peak_value;
        }
    };
    const GpuCounterBlockWire = struct {
        const BLOCK_ID_WIRE: gremlin.ProtoWireNumber = 1;
        const BLOCK_CAPACITY_WIRE: gremlin.ProtoWireNumber = 2;
        const NAME_WIRE: gremlin.ProtoWireNumber = 3;
        const DESCRIPTION_WIRE: gremlin.ProtoWireNumber = 4;
        const COUNTER_IDS_WIRE: gremlin.ProtoWireNumber = 5;
    };
    pub const GpuCounterBlock = struct {
        // fields
        block_id: u32 = 0,
        block_capacity: u32 = 0,
        name: ?[]const u8 = null,
        description: ?[]const u8 = null,
        counter_ids: ?[]const u32 = null,
        pub fn calcProtobufSize(self: *const GpuCounterDescriptor.GpuCounterBlock) usize {
            var res: usize = 0;
            if (self.block_id != 0) {
                res += gremlin.sizes.sizeWireNumber(GpuCounterDescriptor.GpuCounterBlockWire.BLOCK_ID_WIRE) + gremlin.sizes.sizeU32(self.block_id);
            }
            if (self.block_capacity != 0) {
                res += gremlin.sizes.sizeWireNumber(GpuCounterDescriptor.GpuCounterBlockWire.BLOCK_CAPACITY_WIRE) + gremlin.sizes.sizeU32(self.block_capacity);
            }
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(GpuCounterDescriptor.GpuCounterBlockWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.description) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(GpuCounterDescriptor.GpuCounterBlockWire.DESCRIPTION_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.counter_ids) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    res += gremlin.sizes.sizeWireNumber(GpuCounterDescriptor.GpuCounterBlockWire.COUNTER_IDS_WIRE) + gremlin.sizes.sizeU32(arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeU32(v);
                    }
                    res += gremlin.sizes.sizeWireNumber(GpuCounterDescriptor.GpuCounterBlockWire.COUNTER_IDS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
                }
            }
            return res;
        }
        pub fn encode(self: *const GpuCounterDescriptor.GpuCounterBlock, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const GpuCounterDescriptor.GpuCounterBlock, target: *gremlin.Writer) void {
            if (self.block_id != 0) {
                target.appendUint32(GpuCounterDescriptor.GpuCounterBlockWire.BLOCK_ID_WIRE, self.block_id);
            }
            if (self.block_capacity != 0) {
                target.appendUint32(GpuCounterDescriptor.GpuCounterBlockWire.BLOCK_CAPACITY_WIRE, self.block_capacity);
            }
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(GpuCounterDescriptor.GpuCounterBlockWire.NAME_WIRE, v);
                }
            }
            if (self.description) |v| {
                if (v.len > 0) {
                    target.appendBytes(GpuCounterDescriptor.GpuCounterBlockWire.DESCRIPTION_WIRE, v);
                }
            }
            if (self.counter_ids) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    target.appendUint32(GpuCounterDescriptor.GpuCounterBlockWire.COUNTER_IDS_WIRE, arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeU32(v);
                    }
                    target.appendBytesTag(GpuCounterDescriptor.GpuCounterBlockWire.COUNTER_IDS_WIRE, packed_size);
                    for (arr) |v| {
                        target.appendUint32WithoutTag(v);
                    }
                }
            }
        }
    };
    pub const GpuCounterBlockReader = struct {
        buf: gremlin.Reader,
        _block_id: u32 = 0,
        _block_capacity: u32 = 0,
        _name: ?[]const u8 = null,
        _description: ?[]const u8 = null,
        _counter_ids_offset: ?usize = null,
        _counter_ids_last_offset: ?usize = null,
        _counter_ids_packed: bool = false,
        pub fn init(src: []const u8) gremlin.Error!GpuCounterDescriptor.GpuCounterBlockReader {
            const buf = gremlin.Reader.init(src);
            var res = GpuCounterDescriptor.GpuCounterBlockReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    GpuCounterDescriptor.GpuCounterBlockWire.BLOCK_ID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._block_id = result.value;
                    },
                    GpuCounterDescriptor.GpuCounterBlockWire.BLOCK_CAPACITY_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._block_capacity = result.value;
                    },
                    GpuCounterDescriptor.GpuCounterBlockWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    GpuCounterDescriptor.GpuCounterBlockWire.DESCRIPTION_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._description = result.value;
                    },
                    GpuCounterDescriptor.GpuCounterBlockWire.COUNTER_IDS_WIRE => {
                        if (res._counter_ids_offset == null) {
                            res._counter_ids_offset = offset;
                        }
                        if (tag.wire == gremlin.ProtoWireType.bytes) {
                            res._counter_ids_packed = true;
                            const length_result = try buf.readVarInt(offset);
                            res._counter_ids_offset = offset + length_result.size;
                            res._counter_ids_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                            offset = res._counter_ids_last_offset.?;
                        } else {
                            const result = try buf.readUInt32(offset);
                            offset += result.size;
                            res._counter_ids_last_offset = offset;
                        }
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getBlockId(self: *const GpuCounterDescriptor.GpuCounterBlockReader) u32 {
            return self._block_id;
        }
        pub inline fn getBlockCapacity(self: *const GpuCounterDescriptor.GpuCounterBlockReader) u32 {
            return self._block_capacity;
        }
        pub inline fn getName(self: *const GpuCounterDescriptor.GpuCounterBlockReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub inline fn getDescription(self: *const GpuCounterDescriptor.GpuCounterBlockReader) []const u8 {
            return self._description orelse &[_]u8{};
        }
        pub fn counterIdsNext(self: *GpuCounterDescriptor.GpuCounterBlockReader) gremlin.Error!?u32 {
            if (self._counter_ids_offset == null) return null;
            const current_offset = self._counter_ids_offset.?;
            if (current_offset >= self._counter_ids_last_offset.?) {
                self._counter_ids_offset = null;
                return null;
            }
            if (self._counter_ids_packed) {
                const value_result = try self.buf.readUInt32(current_offset);
                self._counter_ids_offset = current_offset + value_result.size;
                if (self._counter_ids_offset.? >= self._counter_ids_last_offset.?) {
                    self._counter_ids_offset = null;
                }
                return value_result.value;
            } else {
                const value_result = try self.buf.readUInt32(current_offset);
                var next_offset = current_offset + value_result.size;
                const max_offset = self._counter_ids_last_offset.?;
                // Search for the next occurrence of this field
                while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                    const next_tag = try self.buf.readTagAt(next_offset);
                    next_offset += next_tag.size;
                    if (next_tag.number == GpuCounterDescriptor.GpuCounterBlockWire.COUNTER_IDS_WIRE) {
                        self._counter_ids_offset = next_offset;
                        return value_result.value;
                    } else {
                        next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                    }
                }
                self._counter_ids_offset = null;
                return value_result.value;
            }
        }
    };
    // fields
    specs: ?[]const ?GpuCounterDescriptor.GpuCounterSpec = null,
    blocks: ?[]const ?GpuCounterDescriptor.GpuCounterBlock = null,
    min_sampling_period_ns: u64 = 0,
    max_sampling_period_ns: u64 = 0,
    supports_instrumented_sampling: bool = false,
    pub fn calcProtobufSize(self: *const GpuCounterDescriptor) usize {
        var res: usize = 0;
        if (self.specs) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(GpuCounterDescriptorWire.SPECS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.blocks) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(GpuCounterDescriptorWire.BLOCKS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.min_sampling_period_ns != 0) {
            res += gremlin.sizes.sizeWireNumber(GpuCounterDescriptorWire.MIN_SAMPLING_PERIOD_NS_WIRE) + gremlin.sizes.sizeU64(self.min_sampling_period_ns);
        }
        if (self.max_sampling_period_ns != 0) {
            res += gremlin.sizes.sizeWireNumber(GpuCounterDescriptorWire.MAX_SAMPLING_PERIOD_NS_WIRE) + gremlin.sizes.sizeU64(self.max_sampling_period_ns);
        }
        if (self.supports_instrumented_sampling != false) {
            res += gremlin.sizes.sizeWireNumber(GpuCounterDescriptorWire.SUPPORTS_INSTRUMENTED_SAMPLING_WIRE) + gremlin.sizes.sizeBool(self.supports_instrumented_sampling);
        }
        return res;
    }
    pub fn encode(self: *const GpuCounterDescriptor, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const GpuCounterDescriptor, target: *gremlin.Writer) void {
        if (self.specs) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(GpuCounterDescriptorWire.SPECS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(GpuCounterDescriptorWire.SPECS_WIRE, 0);
                }
            }
        }
        if (self.blocks) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(GpuCounterDescriptorWire.BLOCKS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(GpuCounterDescriptorWire.BLOCKS_WIRE, 0);
                }
            }
        }
        if (self.min_sampling_period_ns != 0) {
            target.appendUint64(GpuCounterDescriptorWire.MIN_SAMPLING_PERIOD_NS_WIRE, self.min_sampling_period_ns);
        }
        if (self.max_sampling_period_ns != 0) {
            target.appendUint64(GpuCounterDescriptorWire.MAX_SAMPLING_PERIOD_NS_WIRE, self.max_sampling_period_ns);
        }
        if (self.supports_instrumented_sampling != false) {
            target.appendBool(GpuCounterDescriptorWire.SUPPORTS_INSTRUMENTED_SAMPLING_WIRE, self.supports_instrumented_sampling);
        }
    }
};
pub const GpuCounterDescriptorReader = struct {
    buf: gremlin.Reader,
    _specs_offset: ?usize = null,
    _specs_last_offset: ?usize = null,
    _specs_cnt: usize = 0,
    _blocks_offset: ?usize = null,
    _blocks_last_offset: ?usize = null,
    _blocks_cnt: usize = 0,
    _min_sampling_period_ns: u64 = 0,
    _max_sampling_period_ns: u64 = 0,
    _supports_instrumented_sampling: bool = false,
    pub fn init(src: []const u8) gremlin.Error!GpuCounterDescriptorReader {
        const buf = gremlin.Reader.init(src);
        var res = GpuCounterDescriptorReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                GpuCounterDescriptorWire.SPECS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._specs_offset == null) {
                        res._specs_offset = offset - result.size;
                    }
                    res._specs_last_offset = offset;
                    res._specs_cnt += 1;
                },
                GpuCounterDescriptorWire.BLOCKS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._blocks_offset == null) {
                        res._blocks_offset = offset - result.size;
                    }
                    res._blocks_last_offset = offset;
                    res._blocks_cnt += 1;
                },
                GpuCounterDescriptorWire.MIN_SAMPLING_PERIOD_NS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._min_sampling_period_ns = result.value;
                },
                GpuCounterDescriptorWire.MAX_SAMPLING_PERIOD_NS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._max_sampling_period_ns = result.value;
                },
                GpuCounterDescriptorWire.SUPPORTS_INSTRUMENTED_SAMPLING_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._supports_instrumented_sampling = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn specsCount(self: *const GpuCounterDescriptorReader) usize {
        return self._specs_cnt;
    }
    pub fn specsNext(self: *GpuCounterDescriptorReader) ?GpuCounterDescriptor.GpuCounterSpecReader {
        if (self._specs_offset == null) return null;
        const current_offset = self._specs_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = GpuCounterDescriptor.GpuCounterSpecReader.init(result.value) catch return null;
        if (self._specs_last_offset != null and current_offset >= self._specs_last_offset.?) {
            self._specs_offset = null;
            return msg;
        }
        if (self._specs_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._specs_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == GpuCounterDescriptorWire.SPECS_WIRE) {
                self._specs_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._specs_offset = null;
        return msg;
    }
    pub fn blocksCount(self: *const GpuCounterDescriptorReader) usize {
        return self._blocks_cnt;
    }
    pub fn blocksNext(self: *GpuCounterDescriptorReader) ?GpuCounterDescriptor.GpuCounterBlockReader {
        if (self._blocks_offset == null) return null;
        const current_offset = self._blocks_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = GpuCounterDescriptor.GpuCounterBlockReader.init(result.value) catch return null;
        if (self._blocks_last_offset != null and current_offset >= self._blocks_last_offset.?) {
            self._blocks_offset = null;
            return msg;
        }
        if (self._blocks_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._blocks_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == GpuCounterDescriptorWire.BLOCKS_WIRE) {
                self._blocks_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._blocks_offset = null;
        return msg;
    }
    pub inline fn getMinSamplingPeriodNs(self: *const GpuCounterDescriptorReader) u64 {
        return self._min_sampling_period_ns;
    }
    pub inline fn getMaxSamplingPeriodNs(self: *const GpuCounterDescriptorReader) u64 {
        return self._max_sampling_period_ns;
    }
    pub inline fn getSupportsInstrumentedSampling(self: *const GpuCounterDescriptorReader) bool {
        return self._supports_instrumented_sampling;
    }
};
const TrackEventCategoryWire = struct {
    const NAME_WIRE: gremlin.ProtoWireNumber = 1;
    const DESCRIPTION_WIRE: gremlin.ProtoWireNumber = 2;
    const TAGS_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const TrackEventCategory = struct {
    // fields
    name: ?[]const u8 = null,
    description: ?[]const u8 = null,
    tags: ?[]const ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const TrackEventCategory) usize {
        var res: usize = 0;
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TrackEventCategoryWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.description) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TrackEventCategoryWire.DESCRIPTION_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.tags) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TrackEventCategoryWire.TAGS_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const TrackEventCategory, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TrackEventCategory, target: *gremlin.Writer) void {
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(TrackEventCategoryWire.NAME_WIRE, v);
            }
        }
        if (self.description) |v| {
            if (v.len > 0) {
                target.appendBytes(TrackEventCategoryWire.DESCRIPTION_WIRE, v);
            }
        }
        if (self.tags) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(TrackEventCategoryWire.TAGS_WIRE, v);
                } else {
                    target.appendBytesTag(TrackEventCategoryWire.TAGS_WIRE, 0);
                }
            }
        }
    }
};
pub const TrackEventCategoryReader = struct {
    buf: gremlin.Reader,
    _name: ?[]const u8 = null,
    _description: ?[]const u8 = null,
    _tags_offset: ?usize = null,
    _tags_last_offset: ?usize = null,
    _tags_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!TrackEventCategoryReader {
        const buf = gremlin.Reader.init(src);
        var res = TrackEventCategoryReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TrackEventCategoryWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                TrackEventCategoryWire.DESCRIPTION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._description = result.value;
                },
                TrackEventCategoryWire.TAGS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._tags_offset == null) {
                        res._tags_offset = offset - result.size;
                    }
                    res._tags_last_offset = offset;
                    res._tags_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getName(self: *const TrackEventCategoryReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub inline fn getDescription(self: *const TrackEventCategoryReader) []const u8 {
        return self._description orelse &[_]u8{};
    }
    pub fn tagsCount(self: *const TrackEventCategoryReader) usize {
        return self._tags_cnt;
    }
    pub fn tagsNext(self: *TrackEventCategoryReader) ?[]const u8 {
        if (self._tags_offset == null) return null;
        const current_offset = self._tags_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._tags_last_offset != null and current_offset >= self._tags_last_offset.?) {
            self._tags_offset = null;
            return result.value;
        }
        if (self._tags_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._tags_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TrackEventCategoryWire.TAGS_WIRE) {
                self._tags_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._tags_offset = null;
        return result.value;
    }
};
const TrackEventDescriptorWire = struct {
    const AVAILABLE_CATEGORIES_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const TrackEventDescriptor = struct {
    // fields
    available_categories: ?[]const ?TrackEventCategory = null,
    pub fn calcProtobufSize(self: *const TrackEventDescriptor) usize {
        var res: usize = 0;
        if (self.available_categories) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TrackEventDescriptorWire.AVAILABLE_CATEGORIES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const TrackEventDescriptor, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TrackEventDescriptor, target: *gremlin.Writer) void {
        if (self.available_categories) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(TrackEventDescriptorWire.AVAILABLE_CATEGORIES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(TrackEventDescriptorWire.AVAILABLE_CATEGORIES_WIRE, 0);
                }
            }
        }
    }
};
pub const TrackEventDescriptorReader = struct {
    buf: gremlin.Reader,
    _available_categories_offset: ?usize = null,
    _available_categories_last_offset: ?usize = null,
    _available_categories_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!TrackEventDescriptorReader {
        const buf = gremlin.Reader.init(src);
        var res = TrackEventDescriptorReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TrackEventDescriptorWire.AVAILABLE_CATEGORIES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._available_categories_offset == null) {
                        res._available_categories_offset = offset - result.size;
                    }
                    res._available_categories_last_offset = offset;
                    res._available_categories_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn availableCategoriesCount(self: *const TrackEventDescriptorReader) usize {
        return self._available_categories_cnt;
    }
    pub fn availableCategoriesNext(self: *TrackEventDescriptorReader) ?TrackEventCategoryReader {
        if (self._available_categories_offset == null) return null;
        const current_offset = self._available_categories_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = TrackEventCategoryReader.init(result.value) catch return null;
        if (self._available_categories_last_offset != null and current_offset >= self._available_categories_last_offset.?) {
            self._available_categories_offset = null;
            return msg;
        }
        if (self._available_categories_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._available_categories_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TrackEventDescriptorWire.AVAILABLE_CATEGORIES_WIRE) {
                self._available_categories_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._available_categories_offset = null;
        return msg;
    }
};
const DataSourceDescriptorWire = struct {
    const NAME_WIRE: gremlin.ProtoWireNumber = 1;
    const ID_WIRE: gremlin.ProtoWireNumber = 7;
    const WILL_NOTIFY_ON_STOP_WIRE: gremlin.ProtoWireNumber = 2;
    const WILL_NOTIFY_ON_START_WIRE: gremlin.ProtoWireNumber = 3;
    const HANDLES_INCREMENTAL_STATE_CLEAR_WIRE: gremlin.ProtoWireNumber = 4;
    const NO_FLUSH_WIRE: gremlin.ProtoWireNumber = 9;
    const GPU_COUNTER_DESCRIPTOR_WIRE: gremlin.ProtoWireNumber = 5;
    const TRACK_EVENT_DESCRIPTOR_WIRE: gremlin.ProtoWireNumber = 6;
    const FTRACE_DESCRIPTOR_WIRE: gremlin.ProtoWireNumber = 8;
};
pub const DataSourceDescriptor = struct {
    // fields
    name: ?[]const u8 = null,
    id: u64 = 0,
    will_notify_on_stop: bool = false,
    will_notify_on_start: bool = false,
    handles_incremental_state_clear: bool = false,
    no_flush: bool = false,
    gpu_counter_descriptor: ?GpuCounterDescriptor = null,
    track_event_descriptor: ?TrackEventDescriptor = null,
    ftrace_descriptor: ?FtraceDescriptor = null,
    pub fn calcProtobufSize(self: *const DataSourceDescriptor) usize {
        var res: usize = 0;
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceDescriptorWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.id != 0) {
            res += gremlin.sizes.sizeWireNumber(DataSourceDescriptorWire.ID_WIRE) + gremlin.sizes.sizeU64(self.id);
        }
        if (self.will_notify_on_stop != false) {
            res += gremlin.sizes.sizeWireNumber(DataSourceDescriptorWire.WILL_NOTIFY_ON_STOP_WIRE) + gremlin.sizes.sizeBool(self.will_notify_on_stop);
        }
        if (self.will_notify_on_start != false) {
            res += gremlin.sizes.sizeWireNumber(DataSourceDescriptorWire.WILL_NOTIFY_ON_START_WIRE) + gremlin.sizes.sizeBool(self.will_notify_on_start);
        }
        if (self.handles_incremental_state_clear != false) {
            res += gremlin.sizes.sizeWireNumber(DataSourceDescriptorWire.HANDLES_INCREMENTAL_STATE_CLEAR_WIRE) + gremlin.sizes.sizeBool(self.handles_incremental_state_clear);
        }
        if (self.no_flush != false) {
            res += gremlin.sizes.sizeWireNumber(DataSourceDescriptorWire.NO_FLUSH_WIRE) + gremlin.sizes.sizeBool(self.no_flush);
        }
        if (self.gpu_counter_descriptor) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceDescriptorWire.GPU_COUNTER_DESCRIPTOR_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.track_event_descriptor) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceDescriptorWire.TRACK_EVENT_DESCRIPTOR_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ftrace_descriptor) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceDescriptorWire.FTRACE_DESCRIPTOR_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const DataSourceDescriptor, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const DataSourceDescriptor, target: *gremlin.Writer) void {
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(DataSourceDescriptorWire.NAME_WIRE, v);
            }
        }
        if (self.id != 0) {
            target.appendUint64(DataSourceDescriptorWire.ID_WIRE, self.id);
        }
        if (self.will_notify_on_stop != false) {
            target.appendBool(DataSourceDescriptorWire.WILL_NOTIFY_ON_STOP_WIRE, self.will_notify_on_stop);
        }
        if (self.will_notify_on_start != false) {
            target.appendBool(DataSourceDescriptorWire.WILL_NOTIFY_ON_START_WIRE, self.will_notify_on_start);
        }
        if (self.handles_incremental_state_clear != false) {
            target.appendBool(DataSourceDescriptorWire.HANDLES_INCREMENTAL_STATE_CLEAR_WIRE, self.handles_incremental_state_clear);
        }
        if (self.no_flush != false) {
            target.appendBool(DataSourceDescriptorWire.NO_FLUSH_WIRE, self.no_flush);
        }
        if (self.gpu_counter_descriptor) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DataSourceDescriptorWire.GPU_COUNTER_DESCRIPTOR_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.track_event_descriptor) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DataSourceDescriptorWire.TRACK_EVENT_DESCRIPTOR_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ftrace_descriptor) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DataSourceDescriptorWire.FTRACE_DESCRIPTOR_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const DataSourceDescriptorReader = struct {
    buf: gremlin.Reader,
    _name: ?[]const u8 = null,
    _id: u64 = 0,
    _will_notify_on_stop: bool = false,
    _will_notify_on_start: bool = false,
    _handles_incremental_state_clear: bool = false,
    _no_flush: bool = false,
    _gpu_counter_descriptor_buf: ?[]const u8 = null,
    _track_event_descriptor_buf: ?[]const u8 = null,
    _ftrace_descriptor_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!DataSourceDescriptorReader {
        const buf = gremlin.Reader.init(src);
        var res = DataSourceDescriptorReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                DataSourceDescriptorWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                DataSourceDescriptorWire.ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._id = result.value;
                },
                DataSourceDescriptorWire.WILL_NOTIFY_ON_STOP_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._will_notify_on_stop = result.value;
                },
                DataSourceDescriptorWire.WILL_NOTIFY_ON_START_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._will_notify_on_start = result.value;
                },
                DataSourceDescriptorWire.HANDLES_INCREMENTAL_STATE_CLEAR_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._handles_incremental_state_clear = result.value;
                },
                DataSourceDescriptorWire.NO_FLUSH_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._no_flush = result.value;
                },
                DataSourceDescriptorWire.GPU_COUNTER_DESCRIPTOR_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._gpu_counter_descriptor_buf = result.value;
                },
                DataSourceDescriptorWire.TRACK_EVENT_DESCRIPTOR_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._track_event_descriptor_buf = result.value;
                },
                DataSourceDescriptorWire.FTRACE_DESCRIPTOR_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ftrace_descriptor_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getName(self: *const DataSourceDescriptorReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub inline fn getId(self: *const DataSourceDescriptorReader) u64 {
        return self._id;
    }
    pub inline fn getWillNotifyOnStop(self: *const DataSourceDescriptorReader) bool {
        return self._will_notify_on_stop;
    }
    pub inline fn getWillNotifyOnStart(self: *const DataSourceDescriptorReader) bool {
        return self._will_notify_on_start;
    }
    pub inline fn getHandlesIncrementalStateClear(self: *const DataSourceDescriptorReader) bool {
        return self._handles_incremental_state_clear;
    }
    pub inline fn getNoFlush(self: *const DataSourceDescriptorReader) bool {
        return self._no_flush;
    }
    pub fn getGpuCounterDescriptor(self: *const DataSourceDescriptorReader) gremlin.Error!GpuCounterDescriptorReader {
        if (self._gpu_counter_descriptor_buf) |buf| {
            return try GpuCounterDescriptorReader.init(buf);
        }
        return try GpuCounterDescriptorReader.init(&[_]u8{});
    }
    pub fn getTrackEventDescriptor(self: *const DataSourceDescriptorReader) gremlin.Error!TrackEventDescriptorReader {
        if (self._track_event_descriptor_buf) |buf| {
            return try TrackEventDescriptorReader.init(buf);
        }
        return try TrackEventDescriptorReader.init(&[_]u8{});
    }
    pub fn getFtraceDescriptor(self: *const DataSourceDescriptorReader) gremlin.Error!FtraceDescriptorReader {
        if (self._ftrace_descriptor_buf) |buf| {
            return try FtraceDescriptorReader.init(buf);
        }
        return try FtraceDescriptorReader.init(&[_]u8{});
    }
};
const TracingServiceStateWire = struct {
    const PRODUCERS_WIRE: gremlin.ProtoWireNumber = 1;
    const DATA_SOURCES_WIRE: gremlin.ProtoWireNumber = 2;
    const TRACING_SESSIONS_WIRE: gremlin.ProtoWireNumber = 6;
    const SUPPORTS_TRACING_SESSIONS_WIRE: gremlin.ProtoWireNumber = 7;
    const NUM_SESSIONS_WIRE: gremlin.ProtoWireNumber = 3;
    const NUM_SESSIONS_STARTED_WIRE: gremlin.ProtoWireNumber = 4;
    const TRACING_SERVICE_VERSION_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const TracingServiceState = struct {
    // nested structs
    const ProducerWire = struct {
        const ID_WIRE: gremlin.ProtoWireNumber = 1;
        const NAME_WIRE: gremlin.ProtoWireNumber = 2;
        const PID_WIRE: gremlin.ProtoWireNumber = 5;
        const UID_WIRE: gremlin.ProtoWireNumber = 3;
        const SDK_VERSION_WIRE: gremlin.ProtoWireNumber = 4;
        const FROZEN_WIRE: gremlin.ProtoWireNumber = 6;
    };
    pub const Producer = struct {
        // fields
        id: i32 = 0,
        name: ?[]const u8 = null,
        pid: i32 = 0,
        uid: i32 = 0,
        sdk_version: ?[]const u8 = null,
        frozen: bool = false,
        pub fn calcProtobufSize(self: *const TracingServiceState.Producer) usize {
            var res: usize = 0;
            if (self.id != 0) {
                res += gremlin.sizes.sizeWireNumber(TracingServiceState.ProducerWire.ID_WIRE) + gremlin.sizes.sizeI32(self.id);
            }
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(TracingServiceState.ProducerWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.pid != 0) {
                res += gremlin.sizes.sizeWireNumber(TracingServiceState.ProducerWire.PID_WIRE) + gremlin.sizes.sizeI32(self.pid);
            }
            if (self.uid != 0) {
                res += gremlin.sizes.sizeWireNumber(TracingServiceState.ProducerWire.UID_WIRE) + gremlin.sizes.sizeI32(self.uid);
            }
            if (self.sdk_version) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(TracingServiceState.ProducerWire.SDK_VERSION_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.frozen != false) {
                res += gremlin.sizes.sizeWireNumber(TracingServiceState.ProducerWire.FROZEN_WIRE) + gremlin.sizes.sizeBool(self.frozen);
            }
            return res;
        }
        pub fn encode(self: *const TracingServiceState.Producer, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const TracingServiceState.Producer, target: *gremlin.Writer) void {
            if (self.id != 0) {
                target.appendInt32(TracingServiceState.ProducerWire.ID_WIRE, self.id);
            }
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(TracingServiceState.ProducerWire.NAME_WIRE, v);
                }
            }
            if (self.pid != 0) {
                target.appendInt32(TracingServiceState.ProducerWire.PID_WIRE, self.pid);
            }
            if (self.uid != 0) {
                target.appendInt32(TracingServiceState.ProducerWire.UID_WIRE, self.uid);
            }
            if (self.sdk_version) |v| {
                if (v.len > 0) {
                    target.appendBytes(TracingServiceState.ProducerWire.SDK_VERSION_WIRE, v);
                }
            }
            if (self.frozen != false) {
                target.appendBool(TracingServiceState.ProducerWire.FROZEN_WIRE, self.frozen);
            }
        }
    };
    pub const ProducerReader = struct {
        buf: gremlin.Reader,
        _id: i32 = 0,
        _name: ?[]const u8 = null,
        _pid: i32 = 0,
        _uid: i32 = 0,
        _sdk_version: ?[]const u8 = null,
        _frozen: bool = false,
        pub fn init(src: []const u8) gremlin.Error!TracingServiceState.ProducerReader {
            const buf = gremlin.Reader.init(src);
            var res = TracingServiceState.ProducerReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    TracingServiceState.ProducerWire.ID_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._id = result.value;
                    },
                    TracingServiceState.ProducerWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    TracingServiceState.ProducerWire.PID_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._pid = result.value;
                    },
                    TracingServiceState.ProducerWire.UID_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._uid = result.value;
                    },
                    TracingServiceState.ProducerWire.SDK_VERSION_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._sdk_version = result.value;
                    },
                    TracingServiceState.ProducerWire.FROZEN_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._frozen = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getId(self: *const TracingServiceState.ProducerReader) i32 {
            return self._id;
        }
        pub inline fn getName(self: *const TracingServiceState.ProducerReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub inline fn getPid(self: *const TracingServiceState.ProducerReader) i32 {
            return self._pid;
        }
        pub inline fn getUid(self: *const TracingServiceState.ProducerReader) i32 {
            return self._uid;
        }
        pub inline fn getSdkVersion(self: *const TracingServiceState.ProducerReader) []const u8 {
            return self._sdk_version orelse &[_]u8{};
        }
        pub inline fn getFrozen(self: *const TracingServiceState.ProducerReader) bool {
            return self._frozen;
        }
    };
    const DataSourceWire = struct {
        const DS_DESCRIPTOR_WIRE: gremlin.ProtoWireNumber = 1;
        const PRODUCER_ID_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const DataSource = struct {
        // fields
        ds_descriptor: ?DataSourceDescriptor = null,
        producer_id: i32 = 0,
        pub fn calcProtobufSize(self: *const TracingServiceState.DataSource) usize {
            var res: usize = 0;
            if (self.ds_descriptor) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(TracingServiceState.DataSourceWire.DS_DESCRIPTOR_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.producer_id != 0) {
                res += gremlin.sizes.sizeWireNumber(TracingServiceState.DataSourceWire.PRODUCER_ID_WIRE) + gremlin.sizes.sizeI32(self.producer_id);
            }
            return res;
        }
        pub fn encode(self: *const TracingServiceState.DataSource, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const TracingServiceState.DataSource, target: *gremlin.Writer) void {
            if (self.ds_descriptor) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(TracingServiceState.DataSourceWire.DS_DESCRIPTOR_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.producer_id != 0) {
                target.appendInt32(TracingServiceState.DataSourceWire.PRODUCER_ID_WIRE, self.producer_id);
            }
        }
    };
    pub const DataSourceReader = struct {
        buf: gremlin.Reader,
        _ds_descriptor_buf: ?[]const u8 = null,
        _producer_id: i32 = 0,
        pub fn init(src: []const u8) gremlin.Error!TracingServiceState.DataSourceReader {
            const buf = gremlin.Reader.init(src);
            var res = TracingServiceState.DataSourceReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    TracingServiceState.DataSourceWire.DS_DESCRIPTOR_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._ds_descriptor_buf = result.value;
                    },
                    TracingServiceState.DataSourceWire.PRODUCER_ID_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._producer_id = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn getDsDescriptor(self: *const TracingServiceState.DataSourceReader) gremlin.Error!DataSourceDescriptorReader {
            if (self._ds_descriptor_buf) |buf| {
                return try DataSourceDescriptorReader.init(buf);
            }
            return try DataSourceDescriptorReader.init(&[_]u8{});
        }
        pub inline fn getProducerId(self: *const TracingServiceState.DataSourceReader) i32 {
            return self._producer_id;
        }
    };
    const TracingSessionWire = struct {
        const ID_WIRE: gremlin.ProtoWireNumber = 1;
        const CONSUMER_UID_WIRE: gremlin.ProtoWireNumber = 2;
        const STATE_WIRE: gremlin.ProtoWireNumber = 3;
        const UNIQUE_SESSION_NAME_WIRE: gremlin.ProtoWireNumber = 4;
        const BUFFER_SIZE_KB_WIRE: gremlin.ProtoWireNumber = 5;
        const DURATION_MS_WIRE: gremlin.ProtoWireNumber = 6;
        const NUM_DATA_SOURCES_WIRE: gremlin.ProtoWireNumber = 7;
        const START_REALTIME_NS_WIRE: gremlin.ProtoWireNumber = 8;
        const BUGREPORT_SCORE_WIRE: gremlin.ProtoWireNumber = 9;
        const BUGREPORT_FILENAME_WIRE: gremlin.ProtoWireNumber = 10;
        const IS_STARTED_WIRE: gremlin.ProtoWireNumber = 11;
    };
    pub const TracingSession = struct {
        // fields
        id: u64 = 0,
        consumer_uid: i32 = 0,
        state: ?[]const u8 = null,
        unique_session_name: ?[]const u8 = null,
        buffer_size_kb: ?[]const u32 = null,
        duration_ms: u32 = 0,
        num_data_sources: u32 = 0,
        start_realtime_ns: i64 = 0,
        bugreport_score: i32 = 0,
        bugreport_filename: ?[]const u8 = null,
        is_started: bool = false,
        pub fn calcProtobufSize(self: *const TracingServiceState.TracingSession) usize {
            var res: usize = 0;
            if (self.id != 0) {
                res += gremlin.sizes.sizeWireNumber(TracingServiceState.TracingSessionWire.ID_WIRE) + gremlin.sizes.sizeU64(self.id);
            }
            if (self.consumer_uid != 0) {
                res += gremlin.sizes.sizeWireNumber(TracingServiceState.TracingSessionWire.CONSUMER_UID_WIRE) + gremlin.sizes.sizeI32(self.consumer_uid);
            }
            if (self.state) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(TracingServiceState.TracingSessionWire.STATE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.unique_session_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(TracingServiceState.TracingSessionWire.UNIQUE_SESSION_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.buffer_size_kb) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    res += gremlin.sizes.sizeWireNumber(TracingServiceState.TracingSessionWire.BUFFER_SIZE_KB_WIRE) + gremlin.sizes.sizeU32(arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeU32(v);
                    }
                    res += gremlin.sizes.sizeWireNumber(TracingServiceState.TracingSessionWire.BUFFER_SIZE_KB_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
                }
            }
            if (self.duration_ms != 0) {
                res += gremlin.sizes.sizeWireNumber(TracingServiceState.TracingSessionWire.DURATION_MS_WIRE) + gremlin.sizes.sizeU32(self.duration_ms);
            }
            if (self.num_data_sources != 0) {
                res += gremlin.sizes.sizeWireNumber(TracingServiceState.TracingSessionWire.NUM_DATA_SOURCES_WIRE) + gremlin.sizes.sizeU32(self.num_data_sources);
            }
            if (self.start_realtime_ns != 0) {
                res += gremlin.sizes.sizeWireNumber(TracingServiceState.TracingSessionWire.START_REALTIME_NS_WIRE) + gremlin.sizes.sizeI64(self.start_realtime_ns);
            }
            if (self.bugreport_score != 0) {
                res += gremlin.sizes.sizeWireNumber(TracingServiceState.TracingSessionWire.BUGREPORT_SCORE_WIRE) + gremlin.sizes.sizeI32(self.bugreport_score);
            }
            if (self.bugreport_filename) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(TracingServiceState.TracingSessionWire.BUGREPORT_FILENAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.is_started != false) {
                res += gremlin.sizes.sizeWireNumber(TracingServiceState.TracingSessionWire.IS_STARTED_WIRE) + gremlin.sizes.sizeBool(self.is_started);
            }
            return res;
        }
        pub fn encode(self: *const TracingServiceState.TracingSession, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const TracingServiceState.TracingSession, target: *gremlin.Writer) void {
            if (self.id != 0) {
                target.appendUint64(TracingServiceState.TracingSessionWire.ID_WIRE, self.id);
            }
            if (self.consumer_uid != 0) {
                target.appendInt32(TracingServiceState.TracingSessionWire.CONSUMER_UID_WIRE, self.consumer_uid);
            }
            if (self.state) |v| {
                if (v.len > 0) {
                    target.appendBytes(TracingServiceState.TracingSessionWire.STATE_WIRE, v);
                }
            }
            if (self.unique_session_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(TracingServiceState.TracingSessionWire.UNIQUE_SESSION_NAME_WIRE, v);
                }
            }
            if (self.buffer_size_kb) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    target.appendUint32(TracingServiceState.TracingSessionWire.BUFFER_SIZE_KB_WIRE, arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeU32(v);
                    }
                    target.appendBytesTag(TracingServiceState.TracingSessionWire.BUFFER_SIZE_KB_WIRE, packed_size);
                    for (arr) |v| {
                        target.appendUint32WithoutTag(v);
                    }
                }
            }
            if (self.duration_ms != 0) {
                target.appendUint32(TracingServiceState.TracingSessionWire.DURATION_MS_WIRE, self.duration_ms);
            }
            if (self.num_data_sources != 0) {
                target.appendUint32(TracingServiceState.TracingSessionWire.NUM_DATA_SOURCES_WIRE, self.num_data_sources);
            }
            if (self.start_realtime_ns != 0) {
                target.appendInt64(TracingServiceState.TracingSessionWire.START_REALTIME_NS_WIRE, self.start_realtime_ns);
            }
            if (self.bugreport_score != 0) {
                target.appendInt32(TracingServiceState.TracingSessionWire.BUGREPORT_SCORE_WIRE, self.bugreport_score);
            }
            if (self.bugreport_filename) |v| {
                if (v.len > 0) {
                    target.appendBytes(TracingServiceState.TracingSessionWire.BUGREPORT_FILENAME_WIRE, v);
                }
            }
            if (self.is_started != false) {
                target.appendBool(TracingServiceState.TracingSessionWire.IS_STARTED_WIRE, self.is_started);
            }
        }
    };
    pub const TracingSessionReader = struct {
        buf: gremlin.Reader,
        _id: u64 = 0,
        _consumer_uid: i32 = 0,
        _state: ?[]const u8 = null,
        _unique_session_name: ?[]const u8 = null,
        _buffer_size_kb_offset: ?usize = null,
        _buffer_size_kb_last_offset: ?usize = null,
        _buffer_size_kb_packed: bool = false,
        _duration_ms: u32 = 0,
        _num_data_sources: u32 = 0,
        _start_realtime_ns: i64 = 0,
        _bugreport_score: i32 = 0,
        _bugreport_filename: ?[]const u8 = null,
        _is_started: bool = false,
        pub fn init(src: []const u8) gremlin.Error!TracingServiceState.TracingSessionReader {
            const buf = gremlin.Reader.init(src);
            var res = TracingServiceState.TracingSessionReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    TracingServiceState.TracingSessionWire.ID_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._id = result.value;
                    },
                    TracingServiceState.TracingSessionWire.CONSUMER_UID_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._consumer_uid = result.value;
                    },
                    TracingServiceState.TracingSessionWire.STATE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._state = result.value;
                    },
                    TracingServiceState.TracingSessionWire.UNIQUE_SESSION_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._unique_session_name = result.value;
                    },
                    TracingServiceState.TracingSessionWire.BUFFER_SIZE_KB_WIRE => {
                        if (res._buffer_size_kb_offset == null) {
                            res._buffer_size_kb_offset = offset;
                        }
                        if (tag.wire == gremlin.ProtoWireType.bytes) {
                            res._buffer_size_kb_packed = true;
                            const length_result = try buf.readVarInt(offset);
                            res._buffer_size_kb_offset = offset + length_result.size;
                            res._buffer_size_kb_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                            offset = res._buffer_size_kb_last_offset.?;
                        } else {
                            const result = try buf.readUInt32(offset);
                            offset += result.size;
                            res._buffer_size_kb_last_offset = offset;
                        }
                    },
                    TracingServiceState.TracingSessionWire.DURATION_MS_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._duration_ms = result.value;
                    },
                    TracingServiceState.TracingSessionWire.NUM_DATA_SOURCES_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._num_data_sources = result.value;
                    },
                    TracingServiceState.TracingSessionWire.START_REALTIME_NS_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._start_realtime_ns = result.value;
                    },
                    TracingServiceState.TracingSessionWire.BUGREPORT_SCORE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._bugreport_score = result.value;
                    },
                    TracingServiceState.TracingSessionWire.BUGREPORT_FILENAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._bugreport_filename = result.value;
                    },
                    TracingServiceState.TracingSessionWire.IS_STARTED_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._is_started = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getId(self: *const TracingServiceState.TracingSessionReader) u64 {
            return self._id;
        }
        pub inline fn getConsumerUid(self: *const TracingServiceState.TracingSessionReader) i32 {
            return self._consumer_uid;
        }
        pub inline fn getState(self: *const TracingServiceState.TracingSessionReader) []const u8 {
            return self._state orelse &[_]u8{};
        }
        pub inline fn getUniqueSessionName(self: *const TracingServiceState.TracingSessionReader) []const u8 {
            return self._unique_session_name orelse &[_]u8{};
        }
        pub fn bufferSizeKbNext(self: *TracingServiceState.TracingSessionReader) gremlin.Error!?u32 {
            if (self._buffer_size_kb_offset == null) return null;
            const current_offset = self._buffer_size_kb_offset.?;
            if (current_offset >= self._buffer_size_kb_last_offset.?) {
                self._buffer_size_kb_offset = null;
                return null;
            }
            if (self._buffer_size_kb_packed) {
                const value_result = try self.buf.readUInt32(current_offset);
                self._buffer_size_kb_offset = current_offset + value_result.size;
                if (self._buffer_size_kb_offset.? >= self._buffer_size_kb_last_offset.?) {
                    self._buffer_size_kb_offset = null;
                }
                return value_result.value;
            } else {
                const value_result = try self.buf.readUInt32(current_offset);
                var next_offset = current_offset + value_result.size;
                const max_offset = self._buffer_size_kb_last_offset.?;
                // Search for the next occurrence of this field
                while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                    const next_tag = try self.buf.readTagAt(next_offset);
                    next_offset += next_tag.size;
                    if (next_tag.number == TracingServiceState.TracingSessionWire.BUFFER_SIZE_KB_WIRE) {
                        self._buffer_size_kb_offset = next_offset;
                        return value_result.value;
                    } else {
                        next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                    }
                }
                self._buffer_size_kb_offset = null;
                return value_result.value;
            }
        }
        pub inline fn getDurationMs(self: *const TracingServiceState.TracingSessionReader) u32 {
            return self._duration_ms;
        }
        pub inline fn getNumDataSources(self: *const TracingServiceState.TracingSessionReader) u32 {
            return self._num_data_sources;
        }
        pub inline fn getStartRealtimeNs(self: *const TracingServiceState.TracingSessionReader) i64 {
            return self._start_realtime_ns;
        }
        pub inline fn getBugreportScore(self: *const TracingServiceState.TracingSessionReader) i32 {
            return self._bugreport_score;
        }
        pub inline fn getBugreportFilename(self: *const TracingServiceState.TracingSessionReader) []const u8 {
            return self._bugreport_filename orelse &[_]u8{};
        }
        pub inline fn getIsStarted(self: *const TracingServiceState.TracingSessionReader) bool {
            return self._is_started;
        }
    };
    // fields
    producers: ?[]const ?TracingServiceState.Producer = null,
    data_sources: ?[]const ?TracingServiceState.DataSource = null,
    tracing_sessions: ?[]const ?TracingServiceState.TracingSession = null,
    supports_tracing_sessions: bool = false,
    num_sessions: i32 = 0,
    num_sessions_started: i32 = 0,
    tracing_service_version: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const TracingServiceState) usize {
        var res: usize = 0;
        if (self.producers) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TracingServiceStateWire.PRODUCERS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.data_sources) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TracingServiceStateWire.DATA_SOURCES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.tracing_sessions) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TracingServiceStateWire.TRACING_SESSIONS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.supports_tracing_sessions != false) {
            res += gremlin.sizes.sizeWireNumber(TracingServiceStateWire.SUPPORTS_TRACING_SESSIONS_WIRE) + gremlin.sizes.sizeBool(self.supports_tracing_sessions);
        }
        if (self.num_sessions != 0) {
            res += gremlin.sizes.sizeWireNumber(TracingServiceStateWire.NUM_SESSIONS_WIRE) + gremlin.sizes.sizeI32(self.num_sessions);
        }
        if (self.num_sessions_started != 0) {
            res += gremlin.sizes.sizeWireNumber(TracingServiceStateWire.NUM_SESSIONS_STARTED_WIRE) + gremlin.sizes.sizeI32(self.num_sessions_started);
        }
        if (self.tracing_service_version) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TracingServiceStateWire.TRACING_SERVICE_VERSION_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const TracingServiceState, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TracingServiceState, target: *gremlin.Writer) void {
        if (self.producers) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(TracingServiceStateWire.PRODUCERS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(TracingServiceStateWire.PRODUCERS_WIRE, 0);
                }
            }
        }
        if (self.data_sources) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(TracingServiceStateWire.DATA_SOURCES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(TracingServiceStateWire.DATA_SOURCES_WIRE, 0);
                }
            }
        }
        if (self.tracing_sessions) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(TracingServiceStateWire.TRACING_SESSIONS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(TracingServiceStateWire.TRACING_SESSIONS_WIRE, 0);
                }
            }
        }
        if (self.supports_tracing_sessions != false) {
            target.appendBool(TracingServiceStateWire.SUPPORTS_TRACING_SESSIONS_WIRE, self.supports_tracing_sessions);
        }
        if (self.num_sessions != 0) {
            target.appendInt32(TracingServiceStateWire.NUM_SESSIONS_WIRE, self.num_sessions);
        }
        if (self.num_sessions_started != 0) {
            target.appendInt32(TracingServiceStateWire.NUM_SESSIONS_STARTED_WIRE, self.num_sessions_started);
        }
        if (self.tracing_service_version) |v| {
            if (v.len > 0) {
                target.appendBytes(TracingServiceStateWire.TRACING_SERVICE_VERSION_WIRE, v);
            }
        }
    }
};
pub const TracingServiceStateReader = struct {
    buf: gremlin.Reader,
    _producers_offset: ?usize = null,
    _producers_last_offset: ?usize = null,
    _producers_cnt: usize = 0,
    _data_sources_offset: ?usize = null,
    _data_sources_last_offset: ?usize = null,
    _data_sources_cnt: usize = 0,
    _tracing_sessions_offset: ?usize = null,
    _tracing_sessions_last_offset: ?usize = null,
    _tracing_sessions_cnt: usize = 0,
    _supports_tracing_sessions: bool = false,
    _num_sessions: i32 = 0,
    _num_sessions_started: i32 = 0,
    _tracing_service_version: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!TracingServiceStateReader {
        const buf = gremlin.Reader.init(src);
        var res = TracingServiceStateReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TracingServiceStateWire.PRODUCERS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._producers_offset == null) {
                        res._producers_offset = offset - result.size;
                    }
                    res._producers_last_offset = offset;
                    res._producers_cnt += 1;
                },
                TracingServiceStateWire.DATA_SOURCES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._data_sources_offset == null) {
                        res._data_sources_offset = offset - result.size;
                    }
                    res._data_sources_last_offset = offset;
                    res._data_sources_cnt += 1;
                },
                TracingServiceStateWire.TRACING_SESSIONS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._tracing_sessions_offset == null) {
                        res._tracing_sessions_offset = offset - result.size;
                    }
                    res._tracing_sessions_last_offset = offset;
                    res._tracing_sessions_cnt += 1;
                },
                TracingServiceStateWire.SUPPORTS_TRACING_SESSIONS_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._supports_tracing_sessions = result.value;
                },
                TracingServiceStateWire.NUM_SESSIONS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._num_sessions = result.value;
                },
                TracingServiceStateWire.NUM_SESSIONS_STARTED_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._num_sessions_started = result.value;
                },
                TracingServiceStateWire.TRACING_SERVICE_VERSION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._tracing_service_version = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn producersCount(self: *const TracingServiceStateReader) usize {
        return self._producers_cnt;
    }
    pub fn producersNext(self: *TracingServiceStateReader) ?TracingServiceState.ProducerReader {
        if (self._producers_offset == null) return null;
        const current_offset = self._producers_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = TracingServiceState.ProducerReader.init(result.value) catch return null;
        if (self._producers_last_offset != null and current_offset >= self._producers_last_offset.?) {
            self._producers_offset = null;
            return msg;
        }
        if (self._producers_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._producers_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TracingServiceStateWire.PRODUCERS_WIRE) {
                self._producers_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._producers_offset = null;
        return msg;
    }
    pub fn dataSourcesCount(self: *const TracingServiceStateReader) usize {
        return self._data_sources_cnt;
    }
    pub fn dataSourcesNext(self: *TracingServiceStateReader) ?TracingServiceState.DataSourceReader {
        if (self._data_sources_offset == null) return null;
        const current_offset = self._data_sources_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = TracingServiceState.DataSourceReader.init(result.value) catch return null;
        if (self._data_sources_last_offset != null and current_offset >= self._data_sources_last_offset.?) {
            self._data_sources_offset = null;
            return msg;
        }
        if (self._data_sources_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._data_sources_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TracingServiceStateWire.DATA_SOURCES_WIRE) {
                self._data_sources_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._data_sources_offset = null;
        return msg;
    }
    pub fn tracingSessionsCount(self: *const TracingServiceStateReader) usize {
        return self._tracing_sessions_cnt;
    }
    pub fn tracingSessionsNext(self: *TracingServiceStateReader) ?TracingServiceState.TracingSessionReader {
        if (self._tracing_sessions_offset == null) return null;
        const current_offset = self._tracing_sessions_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = TracingServiceState.TracingSessionReader.init(result.value) catch return null;
        if (self._tracing_sessions_last_offset != null and current_offset >= self._tracing_sessions_last_offset.?) {
            self._tracing_sessions_offset = null;
            return msg;
        }
        if (self._tracing_sessions_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._tracing_sessions_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TracingServiceStateWire.TRACING_SESSIONS_WIRE) {
                self._tracing_sessions_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._tracing_sessions_offset = null;
        return msg;
    }
    pub inline fn getSupportsTracingSessions(self: *const TracingServiceStateReader) bool {
        return self._supports_tracing_sessions;
    }
    pub inline fn getNumSessions(self: *const TracingServiceStateReader) i32 {
        return self._num_sessions;
    }
    pub inline fn getNumSessionsStarted(self: *const TracingServiceStateReader) i32 {
        return self._num_sessions_started;
    }
    pub inline fn getTracingServiceVersion(self: *const TracingServiceStateReader) []const u8 {
        return self._tracing_service_version orelse &[_]u8{};
    }
};
const AndroidGameInterventionListConfigWire = struct {
    const PACKAGE_NAME_FILTER_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const AndroidGameInterventionListConfig = struct {
    // fields
    package_name_filter: ?[]const ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const AndroidGameInterventionListConfig) usize {
        var res: usize = 0;
        if (self.package_name_filter) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidGameInterventionListConfigWire.PACKAGE_NAME_FILTER_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidGameInterventionListConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidGameInterventionListConfig, target: *gremlin.Writer) void {
        if (self.package_name_filter) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(AndroidGameInterventionListConfigWire.PACKAGE_NAME_FILTER_WIRE, v);
                } else {
                    target.appendBytesTag(AndroidGameInterventionListConfigWire.PACKAGE_NAME_FILTER_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidGameInterventionListConfigReader = struct {
    buf: gremlin.Reader,
    _package_name_filter_offset: ?usize = null,
    _package_name_filter_last_offset: ?usize = null,
    _package_name_filter_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidGameInterventionListConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidGameInterventionListConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidGameInterventionListConfigWire.PACKAGE_NAME_FILTER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._package_name_filter_offset == null) {
                        res._package_name_filter_offset = offset - result.size;
                    }
                    res._package_name_filter_last_offset = offset;
                    res._package_name_filter_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn packageNameFilterCount(self: *const AndroidGameInterventionListConfigReader) usize {
        return self._package_name_filter_cnt;
    }
    pub fn packageNameFilterNext(self: *AndroidGameInterventionListConfigReader) ?[]const u8 {
        if (self._package_name_filter_offset == null) return null;
        const current_offset = self._package_name_filter_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._package_name_filter_last_offset != null and current_offset >= self._package_name_filter_last_offset.?) {
            self._package_name_filter_offset = null;
            return result.value;
        }
        if (self._package_name_filter_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._package_name_filter_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidGameInterventionListConfigWire.PACKAGE_NAME_FILTER_WIRE) {
                self._package_name_filter_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._package_name_filter_offset = null;
        return result.value;
    }
};
const AndroidInputEventConfigWire = struct {
    const MODE_WIRE: gremlin.ProtoWireNumber = 1;
    const RULES_WIRE: gremlin.ProtoWireNumber = 2;
    const TRACE_DISPATCHER_INPUT_EVENTS_WIRE: gremlin.ProtoWireNumber = 3;
    const TRACE_DISPATCHER_WINDOW_DISPATCH_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const AndroidInputEventConfig = struct {
    // nested enums
    pub const TraceMode = enum(i32) {
        TRACE_MODE_TRACE_ALL = 0,
        TRACE_MODE_USE_RULES = 1,
    };
    pub const TraceLevel = enum(i32) {
        TRACE_LEVEL_NONE = 0,
        TRACE_LEVEL_REDACTED = 1,
        TRACE_LEVEL_COMPLETE = 2,
    };
    // nested structs
    const TraceRuleWire = struct {
        const TRACE_LEVEL_WIRE: gremlin.ProtoWireNumber = 1;
        const MATCH_ALL_PACKAGES_WIRE: gremlin.ProtoWireNumber = 2;
        const MATCH_ANY_PACKAGES_WIRE: gremlin.ProtoWireNumber = 3;
        const MATCH_SECURE_WIRE: gremlin.ProtoWireNumber = 4;
        const MATCH_IME_CONNECTION_ACTIVE_WIRE: gremlin.ProtoWireNumber = 5;
    };
    pub const TraceRule = struct {
        // fields
        trace_level: AndroidInputEventConfig.TraceLevel = @enumFromInt(0),
        match_all_packages: ?[]const ?[]const u8 = null,
        match_any_packages: ?[]const ?[]const u8 = null,
        match_secure: bool = false,
        match_ime_connection_active: bool = false,
        pub fn calcProtobufSize(self: *const AndroidInputEventConfig.TraceRule) usize {
            var res: usize = 0;
            if (@intFromEnum(self.trace_level) != 0) {
                res += gremlin.sizes.sizeWireNumber(AndroidInputEventConfig.TraceRuleWire.TRACE_LEVEL_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.trace_level));
            }
            if (self.match_all_packages) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidInputEventConfig.TraceRuleWire.MATCH_ALL_PACKAGES_WIRE);
                    if (maybe_v) |v| {
                        res += gremlin.sizes.sizeUsize(v.len) + v.len;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.match_any_packages) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AndroidInputEventConfig.TraceRuleWire.MATCH_ANY_PACKAGES_WIRE);
                    if (maybe_v) |v| {
                        res += gremlin.sizes.sizeUsize(v.len) + v.len;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.match_secure != false) {
                res += gremlin.sizes.sizeWireNumber(AndroidInputEventConfig.TraceRuleWire.MATCH_SECURE_WIRE) + gremlin.sizes.sizeBool(self.match_secure);
            }
            if (self.match_ime_connection_active != false) {
                res += gremlin.sizes.sizeWireNumber(AndroidInputEventConfig.TraceRuleWire.MATCH_IME_CONNECTION_ACTIVE_WIRE) + gremlin.sizes.sizeBool(self.match_ime_connection_active);
            }
            return res;
        }
        pub fn encode(self: *const AndroidInputEventConfig.TraceRule, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AndroidInputEventConfig.TraceRule, target: *gremlin.Writer) void {
            if (@intFromEnum(self.trace_level) != 0) {
                target.appendInt32(AndroidInputEventConfig.TraceRuleWire.TRACE_LEVEL_WIRE, @intFromEnum(self.trace_level));
            }
            if (self.match_all_packages) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        target.appendBytes(AndroidInputEventConfig.TraceRuleWire.MATCH_ALL_PACKAGES_WIRE, v);
                    } else {
                        target.appendBytesTag(AndroidInputEventConfig.TraceRuleWire.MATCH_ALL_PACKAGES_WIRE, 0);
                    }
                }
            }
            if (self.match_any_packages) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        target.appendBytes(AndroidInputEventConfig.TraceRuleWire.MATCH_ANY_PACKAGES_WIRE, v);
                    } else {
                        target.appendBytesTag(AndroidInputEventConfig.TraceRuleWire.MATCH_ANY_PACKAGES_WIRE, 0);
                    }
                }
            }
            if (self.match_secure != false) {
                target.appendBool(AndroidInputEventConfig.TraceRuleWire.MATCH_SECURE_WIRE, self.match_secure);
            }
            if (self.match_ime_connection_active != false) {
                target.appendBool(AndroidInputEventConfig.TraceRuleWire.MATCH_IME_CONNECTION_ACTIVE_WIRE, self.match_ime_connection_active);
            }
        }
    };
    pub const TraceRuleReader = struct {
        buf: gremlin.Reader,
        _trace_level: AndroidInputEventConfig.TraceLevel = @enumFromInt(0),
        _match_all_packages_offset: ?usize = null,
        _match_all_packages_last_offset: ?usize = null,
        _match_all_packages_cnt: usize = 0,
        _match_any_packages_offset: ?usize = null,
        _match_any_packages_last_offset: ?usize = null,
        _match_any_packages_cnt: usize = 0,
        _match_secure: bool = false,
        _match_ime_connection_active: bool = false,
        pub fn init(src: []const u8) gremlin.Error!AndroidInputEventConfig.TraceRuleReader {
            const buf = gremlin.Reader.init(src);
            var res = AndroidInputEventConfig.TraceRuleReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AndroidInputEventConfig.TraceRuleWire.TRACE_LEVEL_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._trace_level = @enumFromInt(result.value);
                    },
                    AndroidInputEventConfig.TraceRuleWire.MATCH_ALL_PACKAGES_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._match_all_packages_offset == null) {
                            res._match_all_packages_offset = offset - result.size;
                        }
                        res._match_all_packages_last_offset = offset;
                        res._match_all_packages_cnt += 1;
                    },
                    AndroidInputEventConfig.TraceRuleWire.MATCH_ANY_PACKAGES_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._match_any_packages_offset == null) {
                            res._match_any_packages_offset = offset - result.size;
                        }
                        res._match_any_packages_last_offset = offset;
                        res._match_any_packages_cnt += 1;
                    },
                    AndroidInputEventConfig.TraceRuleWire.MATCH_SECURE_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._match_secure = result.value;
                    },
                    AndroidInputEventConfig.TraceRuleWire.MATCH_IME_CONNECTION_ACTIVE_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._match_ime_connection_active = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getTraceLevel(self: *const AndroidInputEventConfig.TraceRuleReader) AndroidInputEventConfig.TraceLevel {
            return self._trace_level;
        }
        pub fn matchAllPackagesCount(self: *const AndroidInputEventConfig.TraceRuleReader) usize {
            return self._match_all_packages_cnt;
        }
        pub fn matchAllPackagesNext(self: *AndroidInputEventConfig.TraceRuleReader) ?[]const u8 {
            if (self._match_all_packages_offset == null) return null;
            const current_offset = self._match_all_packages_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            if (self._match_all_packages_last_offset != null and current_offset >= self._match_all_packages_last_offset.?) {
                self._match_all_packages_offset = null;
                return result.value;
            }
            if (self._match_all_packages_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._match_all_packages_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidInputEventConfig.TraceRuleWire.MATCH_ALL_PACKAGES_WIRE) {
                    self._match_all_packages_offset = next_offset;
                    return result.value;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._match_all_packages_offset = null;
            return result.value;
        }
        pub fn matchAnyPackagesCount(self: *const AndroidInputEventConfig.TraceRuleReader) usize {
            return self._match_any_packages_cnt;
        }
        pub fn matchAnyPackagesNext(self: *AndroidInputEventConfig.TraceRuleReader) ?[]const u8 {
            if (self._match_any_packages_offset == null) return null;
            const current_offset = self._match_any_packages_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            if (self._match_any_packages_last_offset != null and current_offset >= self._match_any_packages_last_offset.?) {
                self._match_any_packages_offset = null;
                return result.value;
            }
            if (self._match_any_packages_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._match_any_packages_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AndroidInputEventConfig.TraceRuleWire.MATCH_ANY_PACKAGES_WIRE) {
                    self._match_any_packages_offset = next_offset;
                    return result.value;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._match_any_packages_offset = null;
            return result.value;
        }
        pub inline fn getMatchSecure(self: *const AndroidInputEventConfig.TraceRuleReader) bool {
            return self._match_secure;
        }
        pub inline fn getMatchImeConnectionActive(self: *const AndroidInputEventConfig.TraceRuleReader) bool {
            return self._match_ime_connection_active;
        }
    };
    // fields
    mode: AndroidInputEventConfig.TraceMode = @enumFromInt(0),
    rules: ?[]const ?AndroidInputEventConfig.TraceRule = null,
    trace_dispatcher_input_events: bool = false,
    trace_dispatcher_window_dispatch: bool = false,
    pub fn calcProtobufSize(self: *const AndroidInputEventConfig) usize {
        var res: usize = 0;
        if (@intFromEnum(self.mode) != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidInputEventConfigWire.MODE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.mode));
        }
        if (self.rules) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidInputEventConfigWire.RULES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.trace_dispatcher_input_events != false) {
            res += gremlin.sizes.sizeWireNumber(AndroidInputEventConfigWire.TRACE_DISPATCHER_INPUT_EVENTS_WIRE) + gremlin.sizes.sizeBool(self.trace_dispatcher_input_events);
        }
        if (self.trace_dispatcher_window_dispatch != false) {
            res += gremlin.sizes.sizeWireNumber(AndroidInputEventConfigWire.TRACE_DISPATCHER_WINDOW_DISPATCH_WIRE) + gremlin.sizes.sizeBool(self.trace_dispatcher_window_dispatch);
        }
        return res;
    }
    pub fn encode(self: *const AndroidInputEventConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidInputEventConfig, target: *gremlin.Writer) void {
        if (@intFromEnum(self.mode) != 0) {
            target.appendInt32(AndroidInputEventConfigWire.MODE_WIRE, @intFromEnum(self.mode));
        }
        if (self.rules) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AndroidInputEventConfigWire.RULES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AndroidInputEventConfigWire.RULES_WIRE, 0);
                }
            }
        }
        if (self.trace_dispatcher_input_events != false) {
            target.appendBool(AndroidInputEventConfigWire.TRACE_DISPATCHER_INPUT_EVENTS_WIRE, self.trace_dispatcher_input_events);
        }
        if (self.trace_dispatcher_window_dispatch != false) {
            target.appendBool(AndroidInputEventConfigWire.TRACE_DISPATCHER_WINDOW_DISPATCH_WIRE, self.trace_dispatcher_window_dispatch);
        }
    }
};
pub const AndroidInputEventConfigReader = struct {
    buf: gremlin.Reader,
    _mode: AndroidInputEventConfig.TraceMode = @enumFromInt(0),
    _rules_offset: ?usize = null,
    _rules_last_offset: ?usize = null,
    _rules_cnt: usize = 0,
    _trace_dispatcher_input_events: bool = false,
    _trace_dispatcher_window_dispatch: bool = false,
    pub fn init(src: []const u8) gremlin.Error!AndroidInputEventConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidInputEventConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidInputEventConfigWire.MODE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._mode = @enumFromInt(result.value);
                },
                AndroidInputEventConfigWire.RULES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._rules_offset == null) {
                        res._rules_offset = offset - result.size;
                    }
                    res._rules_last_offset = offset;
                    res._rules_cnt += 1;
                },
                AndroidInputEventConfigWire.TRACE_DISPATCHER_INPUT_EVENTS_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._trace_dispatcher_input_events = result.value;
                },
                AndroidInputEventConfigWire.TRACE_DISPATCHER_WINDOW_DISPATCH_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._trace_dispatcher_window_dispatch = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getMode(self: *const AndroidInputEventConfigReader) AndroidInputEventConfig.TraceMode {
        return self._mode;
    }
    pub fn rulesCount(self: *const AndroidInputEventConfigReader) usize {
        return self._rules_cnt;
    }
    pub fn rulesNext(self: *AndroidInputEventConfigReader) ?AndroidInputEventConfig.TraceRuleReader {
        if (self._rules_offset == null) return null;
        const current_offset = self._rules_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AndroidInputEventConfig.TraceRuleReader.init(result.value) catch return null;
        if (self._rules_last_offset != null and current_offset >= self._rules_last_offset.?) {
            self._rules_offset = null;
            return msg;
        }
        if (self._rules_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._rules_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidInputEventConfigWire.RULES_WIRE) {
                self._rules_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._rules_offset = null;
        return msg;
    }
    pub inline fn getTraceDispatcherInputEvents(self: *const AndroidInputEventConfigReader) bool {
        return self._trace_dispatcher_input_events;
    }
    pub inline fn getTraceDispatcherWindowDispatch(self: *const AndroidInputEventConfigReader) bool {
        return self._trace_dispatcher_window_dispatch;
    }
};
const AndroidLogConfigWire = struct {
    const LOG_IDS_WIRE: gremlin.ProtoWireNumber = 1;
    const MIN_PRIO_WIRE: gremlin.ProtoWireNumber = 3;
    const FILTER_TAGS_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const AndroidLogConfig = struct {
    // fields
    log_ids: ?[]const AndroidLogId = null,
    min_prio: AndroidLogPriority = @enumFromInt(0),
    filter_tags: ?[]const ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const AndroidLogConfig) usize {
        var res: usize = 0;
        if (self.log_ids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(AndroidLogConfigWire.LOG_IDS_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(arr[0]));
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(@intFromEnum(v));
                }
                res += gremlin.sizes.sizeWireNumber(AndroidLogConfigWire.LOG_IDS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (@intFromEnum(self.min_prio) != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidLogConfigWire.MIN_PRIO_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.min_prio));
        }
        if (self.filter_tags) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidLogConfigWire.FILTER_TAGS_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidLogConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidLogConfig, target: *gremlin.Writer) void {
        if (self.log_ids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt32(AndroidLogConfigWire.LOG_IDS_WIRE, @intFromEnum(arr[0]));
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(@intFromEnum(v));
                }
                target.appendBytesTag(AndroidLogConfigWire.LOG_IDS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt32WithoutTag(@intFromEnum(v));
                }
            }
        }
        if (@intFromEnum(self.min_prio) != 0) {
            target.appendInt32(AndroidLogConfigWire.MIN_PRIO_WIRE, @intFromEnum(self.min_prio));
        }
        if (self.filter_tags) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(AndroidLogConfigWire.FILTER_TAGS_WIRE, v);
                } else {
                    target.appendBytesTag(AndroidLogConfigWire.FILTER_TAGS_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidLogConfigReader = struct {
    buf: gremlin.Reader,
    _log_ids_offset: ?usize = null,
    _log_ids_last_offset: ?usize = null,
    _log_ids_packed: bool = false,
    _min_prio: AndroidLogPriority = @enumFromInt(0),
    _filter_tags_offset: ?usize = null,
    _filter_tags_last_offset: ?usize = null,
    _filter_tags_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidLogConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidLogConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidLogConfigWire.LOG_IDS_WIRE => {
                    if (res._log_ids_offset == null) {
                        res._log_ids_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._log_ids_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._log_ids_offset = offset + length_result.size;
                        res._log_ids_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._log_ids_last_offset.?;
                    } else {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._log_ids_last_offset = offset;
                    }
                },
                AndroidLogConfigWire.MIN_PRIO_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._min_prio = @enumFromInt(result.value);
                },
                AndroidLogConfigWire.FILTER_TAGS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._filter_tags_offset == null) {
                        res._filter_tags_offset = offset - result.size;
                    }
                    res._filter_tags_last_offset = offset;
                    res._filter_tags_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn logIdsNext(self: *AndroidLogConfigReader) gremlin.Error!?AndroidLogId {
        if (self._log_ids_offset == null) return null;
        const current_offset = self._log_ids_offset.?;
        if (current_offset >= self._log_ids_last_offset.?) {
            self._log_ids_offset = null;
            return null;
        }
        if (self._log_ids_packed) {
            const value_result = try self.buf.readInt32(current_offset);
            self._log_ids_offset = current_offset + value_result.size;
            if (self._log_ids_offset.? >= self._log_ids_last_offset.?) {
                self._log_ids_offset = null;
            }
            return @enumFromInt(value_result.value);
        } else {
            const value_result = try self.buf.readInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._log_ids_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == AndroidLogConfigWire.LOG_IDS_WIRE) {
                    self._log_ids_offset = next_offset;
                    return @enumFromInt(value_result.value);
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._log_ids_offset = null;
            return @enumFromInt(value_result.value);
        }
    }
    pub inline fn getMinPrio(self: *const AndroidLogConfigReader) AndroidLogPriority {
        return self._min_prio;
    }
    pub fn filterTagsCount(self: *const AndroidLogConfigReader) usize {
        return self._filter_tags_cnt;
    }
    pub fn filterTagsNext(self: *AndroidLogConfigReader) ?[]const u8 {
        if (self._filter_tags_offset == null) return null;
        const current_offset = self._filter_tags_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._filter_tags_last_offset != null and current_offset >= self._filter_tags_last_offset.?) {
            self._filter_tags_offset = null;
            return result.value;
        }
        if (self._filter_tags_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._filter_tags_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidLogConfigWire.FILTER_TAGS_WIRE) {
                self._filter_tags_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._filter_tags_offset = null;
        return result.value;
    }
};
const AndroidPolledStateConfigWire = struct {
    const POLL_MS_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const AndroidPolledStateConfig = struct {
    // fields
    poll_ms: u32 = 0,
    pub fn calcProtobufSize(self: *const AndroidPolledStateConfig) usize {
        var res: usize = 0;
        if (self.poll_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidPolledStateConfigWire.POLL_MS_WIRE) + gremlin.sizes.sizeU32(self.poll_ms);
        }
        return res;
    }
    pub fn encode(self: *const AndroidPolledStateConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidPolledStateConfig, target: *gremlin.Writer) void {
        if (self.poll_ms != 0) {
            target.appendUint32(AndroidPolledStateConfigWire.POLL_MS_WIRE, self.poll_ms);
        }
    }
};
pub const AndroidPolledStateConfigReader = struct {
    buf: gremlin.Reader,
    _poll_ms: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidPolledStateConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidPolledStateConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidPolledStateConfigWire.POLL_MS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._poll_ms = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getPollMs(self: *const AndroidPolledStateConfigReader) u32 {
        return self._poll_ms;
    }
};
const AndroidSdkSyspropGuardConfigWire = struct {
    const SURFACEFLINGER_SKIA_TRACK_EVENTS_WIRE: gremlin.ProtoWireNumber = 1;
    const HWUI_SKIA_TRACK_EVENTS_WIRE: gremlin.ProtoWireNumber = 2;
    const HWUI_PACKAGE_NAME_FILTER_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const AndroidSdkSyspropGuardConfig = struct {
    // fields
    surfaceflinger_skia_track_events: bool = false,
    hwui_skia_track_events: bool = false,
    hwui_package_name_filter: ?[]const ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const AndroidSdkSyspropGuardConfig) usize {
        var res: usize = 0;
        if (self.surfaceflinger_skia_track_events != false) {
            res += gremlin.sizes.sizeWireNumber(AndroidSdkSyspropGuardConfigWire.SURFACEFLINGER_SKIA_TRACK_EVENTS_WIRE) + gremlin.sizes.sizeBool(self.surfaceflinger_skia_track_events);
        }
        if (self.hwui_skia_track_events != false) {
            res += gremlin.sizes.sizeWireNumber(AndroidSdkSyspropGuardConfigWire.HWUI_SKIA_TRACK_EVENTS_WIRE) + gremlin.sizes.sizeBool(self.hwui_skia_track_events);
        }
        if (self.hwui_package_name_filter) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidSdkSyspropGuardConfigWire.HWUI_PACKAGE_NAME_FILTER_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidSdkSyspropGuardConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidSdkSyspropGuardConfig, target: *gremlin.Writer) void {
        if (self.surfaceflinger_skia_track_events != false) {
            target.appendBool(AndroidSdkSyspropGuardConfigWire.SURFACEFLINGER_SKIA_TRACK_EVENTS_WIRE, self.surfaceflinger_skia_track_events);
        }
        if (self.hwui_skia_track_events != false) {
            target.appendBool(AndroidSdkSyspropGuardConfigWire.HWUI_SKIA_TRACK_EVENTS_WIRE, self.hwui_skia_track_events);
        }
        if (self.hwui_package_name_filter) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(AndroidSdkSyspropGuardConfigWire.HWUI_PACKAGE_NAME_FILTER_WIRE, v);
                } else {
                    target.appendBytesTag(AndroidSdkSyspropGuardConfigWire.HWUI_PACKAGE_NAME_FILTER_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidSdkSyspropGuardConfigReader = struct {
    buf: gremlin.Reader,
    _surfaceflinger_skia_track_events: bool = false,
    _hwui_skia_track_events: bool = false,
    _hwui_package_name_filter_offset: ?usize = null,
    _hwui_package_name_filter_last_offset: ?usize = null,
    _hwui_package_name_filter_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidSdkSyspropGuardConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidSdkSyspropGuardConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidSdkSyspropGuardConfigWire.SURFACEFLINGER_SKIA_TRACK_EVENTS_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._surfaceflinger_skia_track_events = result.value;
                },
                AndroidSdkSyspropGuardConfigWire.HWUI_SKIA_TRACK_EVENTS_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._hwui_skia_track_events = result.value;
                },
                AndroidSdkSyspropGuardConfigWire.HWUI_PACKAGE_NAME_FILTER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._hwui_package_name_filter_offset == null) {
                        res._hwui_package_name_filter_offset = offset - result.size;
                    }
                    res._hwui_package_name_filter_last_offset = offset;
                    res._hwui_package_name_filter_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getSurfaceflingerSkiaTrackEvents(self: *const AndroidSdkSyspropGuardConfigReader) bool {
        return self._surfaceflinger_skia_track_events;
    }
    pub inline fn getHwuiSkiaTrackEvents(self: *const AndroidSdkSyspropGuardConfigReader) bool {
        return self._hwui_skia_track_events;
    }
    pub fn hwuiPackageNameFilterCount(self: *const AndroidSdkSyspropGuardConfigReader) usize {
        return self._hwui_package_name_filter_cnt;
    }
    pub fn hwuiPackageNameFilterNext(self: *AndroidSdkSyspropGuardConfigReader) ?[]const u8 {
        if (self._hwui_package_name_filter_offset == null) return null;
        const current_offset = self._hwui_package_name_filter_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._hwui_package_name_filter_last_offset != null and current_offset >= self._hwui_package_name_filter_last_offset.?) {
            self._hwui_package_name_filter_offset = null;
            return result.value;
        }
        if (self._hwui_package_name_filter_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._hwui_package_name_filter_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidSdkSyspropGuardConfigWire.HWUI_PACKAGE_NAME_FILTER_WIRE) {
                self._hwui_package_name_filter_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._hwui_package_name_filter_offset = null;
        return result.value;
    }
};
const AndroidSystemPropertyConfigWire = struct {
    const POLL_MS_WIRE: gremlin.ProtoWireNumber = 1;
    const PROPERTY_NAME_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const AndroidSystemPropertyConfig = struct {
    // fields
    poll_ms: u32 = 0,
    property_name: ?[]const ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const AndroidSystemPropertyConfig) usize {
        var res: usize = 0;
        if (self.poll_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidSystemPropertyConfigWire.POLL_MS_WIRE) + gremlin.sizes.sizeU32(self.poll_ms);
        }
        if (self.property_name) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AndroidSystemPropertyConfigWire.PROPERTY_NAME_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AndroidSystemPropertyConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidSystemPropertyConfig, target: *gremlin.Writer) void {
        if (self.poll_ms != 0) {
            target.appendUint32(AndroidSystemPropertyConfigWire.POLL_MS_WIRE, self.poll_ms);
        }
        if (self.property_name) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(AndroidSystemPropertyConfigWire.PROPERTY_NAME_WIRE, v);
                } else {
                    target.appendBytesTag(AndroidSystemPropertyConfigWire.PROPERTY_NAME_WIRE, 0);
                }
            }
        }
    }
};
pub const AndroidSystemPropertyConfigReader = struct {
    buf: gremlin.Reader,
    _poll_ms: u32 = 0,
    _property_name_offset: ?usize = null,
    _property_name_last_offset: ?usize = null,
    _property_name_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AndroidSystemPropertyConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidSystemPropertyConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidSystemPropertyConfigWire.POLL_MS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._poll_ms = result.value;
                },
                AndroidSystemPropertyConfigWire.PROPERTY_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._property_name_offset == null) {
                        res._property_name_offset = offset - result.size;
                    }
                    res._property_name_last_offset = offset;
                    res._property_name_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getPollMs(self: *const AndroidSystemPropertyConfigReader) u32 {
        return self._poll_ms;
    }
    pub fn propertyNameCount(self: *const AndroidSystemPropertyConfigReader) usize {
        return self._property_name_cnt;
    }
    pub fn propertyNameNext(self: *AndroidSystemPropertyConfigReader) ?[]const u8 {
        if (self._property_name_offset == null) return null;
        const current_offset = self._property_name_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._property_name_last_offset != null and current_offset >= self._property_name_last_offset.?) {
            self._property_name_offset = null;
            return result.value;
        }
        if (self._property_name_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._property_name_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AndroidSystemPropertyConfigWire.PROPERTY_NAME_WIRE) {
                self._property_name_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._property_name_offset = null;
        return result.value;
    }
};
const AppWakelocksConfigWire = struct {
    const WRITE_DELAY_MS_WIRE: gremlin.ProtoWireNumber = 1;
    const FILTER_DURATION_BELOW_MS_WIRE: gremlin.ProtoWireNumber = 2;
    const DROP_OWNER_PID_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const AppWakelocksConfig = struct {
    // fields
    write_delay_ms: i32 = 0,
    filter_duration_below_ms: i32 = 0,
    drop_owner_pid: bool = false,
    pub fn calcProtobufSize(self: *const AppWakelocksConfig) usize {
        var res: usize = 0;
        if (self.write_delay_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(AppWakelocksConfigWire.WRITE_DELAY_MS_WIRE) + gremlin.sizes.sizeI32(self.write_delay_ms);
        }
        if (self.filter_duration_below_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(AppWakelocksConfigWire.FILTER_DURATION_BELOW_MS_WIRE) + gremlin.sizes.sizeI32(self.filter_duration_below_ms);
        }
        if (self.drop_owner_pid != false) {
            res += gremlin.sizes.sizeWireNumber(AppWakelocksConfigWire.DROP_OWNER_PID_WIRE) + gremlin.sizes.sizeBool(self.drop_owner_pid);
        }
        return res;
    }
    pub fn encode(self: *const AppWakelocksConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AppWakelocksConfig, target: *gremlin.Writer) void {
        if (self.write_delay_ms != 0) {
            target.appendInt32(AppWakelocksConfigWire.WRITE_DELAY_MS_WIRE, self.write_delay_ms);
        }
        if (self.filter_duration_below_ms != 0) {
            target.appendInt32(AppWakelocksConfigWire.FILTER_DURATION_BELOW_MS_WIRE, self.filter_duration_below_ms);
        }
        if (self.drop_owner_pid != false) {
            target.appendBool(AppWakelocksConfigWire.DROP_OWNER_PID_WIRE, self.drop_owner_pid);
        }
    }
};
pub const AppWakelocksConfigReader = struct {
    buf: gremlin.Reader,
    _write_delay_ms: i32 = 0,
    _filter_duration_below_ms: i32 = 0,
    _drop_owner_pid: bool = false,
    pub fn init(src: []const u8) gremlin.Error!AppWakelocksConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = AppWakelocksConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AppWakelocksConfigWire.WRITE_DELAY_MS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._write_delay_ms = result.value;
                },
                AppWakelocksConfigWire.FILTER_DURATION_BELOW_MS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._filter_duration_below_ms = result.value;
                },
                AppWakelocksConfigWire.DROP_OWNER_PID_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._drop_owner_pid = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getWriteDelayMs(self: *const AppWakelocksConfigReader) i32 {
        return self._write_delay_ms;
    }
    pub inline fn getFilterDurationBelowMs(self: *const AppWakelocksConfigReader) i32 {
        return self._filter_duration_below_ms;
    }
    pub inline fn getDropOwnerPid(self: *const AppWakelocksConfigReader) bool {
        return self._drop_owner_pid;
    }
};
const CpuPerUidConfigWire = struct {
    const POLL_MS_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const CpuPerUidConfig = struct {
    // fields
    poll_ms: u32 = 0,
    pub fn calcProtobufSize(self: *const CpuPerUidConfig) usize {
        var res: usize = 0;
        if (self.poll_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(CpuPerUidConfigWire.POLL_MS_WIRE) + gremlin.sizes.sizeU32(self.poll_ms);
        }
        return res;
    }
    pub fn encode(self: *const CpuPerUidConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const CpuPerUidConfig, target: *gremlin.Writer) void {
        if (self.poll_ms != 0) {
            target.appendUint32(CpuPerUidConfigWire.POLL_MS_WIRE, self.poll_ms);
        }
    }
};
pub const CpuPerUidConfigReader = struct {
    buf: gremlin.Reader,
    _poll_ms: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!CpuPerUidConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = CpuPerUidConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                CpuPerUidConfigWire.POLL_MS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._poll_ms = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getPollMs(self: *const CpuPerUidConfigReader) u32 {
        return self._poll_ms;
    }
};
const KernelWakelocksConfigWire = struct {
    const POLL_MS_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const KernelWakelocksConfig = struct {
    // fields
    poll_ms: u32 = 0,
    pub fn calcProtobufSize(self: *const KernelWakelocksConfig) usize {
        var res: usize = 0;
        if (self.poll_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(KernelWakelocksConfigWire.POLL_MS_WIRE) + gremlin.sizes.sizeU32(self.poll_ms);
        }
        return res;
    }
    pub fn encode(self: *const KernelWakelocksConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const KernelWakelocksConfig, target: *gremlin.Writer) void {
        if (self.poll_ms != 0) {
            target.appendUint32(KernelWakelocksConfigWire.POLL_MS_WIRE, self.poll_ms);
        }
    }
};
pub const KernelWakelocksConfigReader = struct {
    buf: gremlin.Reader,
    _poll_ms: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!KernelWakelocksConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = KernelWakelocksConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                KernelWakelocksConfigWire.POLL_MS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._poll_ms = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getPollMs(self: *const KernelWakelocksConfigReader) u32 {
        return self._poll_ms;
    }
};
const NetworkPacketTraceConfigWire = struct {
    const POLL_MS_WIRE: gremlin.ProtoWireNumber = 1;
    const AGGREGATION_THRESHOLD_WIRE: gremlin.ProtoWireNumber = 2;
    const INTERN_LIMIT_WIRE: gremlin.ProtoWireNumber = 3;
    const DROP_LOCAL_PORT_WIRE: gremlin.ProtoWireNumber = 4;
    const DROP_REMOTE_PORT_WIRE: gremlin.ProtoWireNumber = 5;
    const DROP_TCP_FLAGS_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const NetworkPacketTraceConfig = struct {
    // fields
    poll_ms: u32 = 0,
    aggregation_threshold: u32 = 0,
    intern_limit: u32 = 0,
    drop_local_port: bool = false,
    drop_remote_port: bool = false,
    drop_tcp_flags: bool = false,
    pub fn calcProtobufSize(self: *const NetworkPacketTraceConfig) usize {
        var res: usize = 0;
        if (self.poll_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(NetworkPacketTraceConfigWire.POLL_MS_WIRE) + gremlin.sizes.sizeU32(self.poll_ms);
        }
        if (self.aggregation_threshold != 0) {
            res += gremlin.sizes.sizeWireNumber(NetworkPacketTraceConfigWire.AGGREGATION_THRESHOLD_WIRE) + gremlin.sizes.sizeU32(self.aggregation_threshold);
        }
        if (self.intern_limit != 0) {
            res += gremlin.sizes.sizeWireNumber(NetworkPacketTraceConfigWire.INTERN_LIMIT_WIRE) + gremlin.sizes.sizeU32(self.intern_limit);
        }
        if (self.drop_local_port != false) {
            res += gremlin.sizes.sizeWireNumber(NetworkPacketTraceConfigWire.DROP_LOCAL_PORT_WIRE) + gremlin.sizes.sizeBool(self.drop_local_port);
        }
        if (self.drop_remote_port != false) {
            res += gremlin.sizes.sizeWireNumber(NetworkPacketTraceConfigWire.DROP_REMOTE_PORT_WIRE) + gremlin.sizes.sizeBool(self.drop_remote_port);
        }
        if (self.drop_tcp_flags != false) {
            res += gremlin.sizes.sizeWireNumber(NetworkPacketTraceConfigWire.DROP_TCP_FLAGS_WIRE) + gremlin.sizes.sizeBool(self.drop_tcp_flags);
        }
        return res;
    }
    pub fn encode(self: *const NetworkPacketTraceConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const NetworkPacketTraceConfig, target: *gremlin.Writer) void {
        if (self.poll_ms != 0) {
            target.appendUint32(NetworkPacketTraceConfigWire.POLL_MS_WIRE, self.poll_ms);
        }
        if (self.aggregation_threshold != 0) {
            target.appendUint32(NetworkPacketTraceConfigWire.AGGREGATION_THRESHOLD_WIRE, self.aggregation_threshold);
        }
        if (self.intern_limit != 0) {
            target.appendUint32(NetworkPacketTraceConfigWire.INTERN_LIMIT_WIRE, self.intern_limit);
        }
        if (self.drop_local_port != false) {
            target.appendBool(NetworkPacketTraceConfigWire.DROP_LOCAL_PORT_WIRE, self.drop_local_port);
        }
        if (self.drop_remote_port != false) {
            target.appendBool(NetworkPacketTraceConfigWire.DROP_REMOTE_PORT_WIRE, self.drop_remote_port);
        }
        if (self.drop_tcp_flags != false) {
            target.appendBool(NetworkPacketTraceConfigWire.DROP_TCP_FLAGS_WIRE, self.drop_tcp_flags);
        }
    }
};
pub const NetworkPacketTraceConfigReader = struct {
    buf: gremlin.Reader,
    _poll_ms: u32 = 0,
    _aggregation_threshold: u32 = 0,
    _intern_limit: u32 = 0,
    _drop_local_port: bool = false,
    _drop_remote_port: bool = false,
    _drop_tcp_flags: bool = false,
    pub fn init(src: []const u8) gremlin.Error!NetworkPacketTraceConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = NetworkPacketTraceConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                NetworkPacketTraceConfigWire.POLL_MS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._poll_ms = result.value;
                },
                NetworkPacketTraceConfigWire.AGGREGATION_THRESHOLD_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._aggregation_threshold = result.value;
                },
                NetworkPacketTraceConfigWire.INTERN_LIMIT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._intern_limit = result.value;
                },
                NetworkPacketTraceConfigWire.DROP_LOCAL_PORT_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._drop_local_port = result.value;
                },
                NetworkPacketTraceConfigWire.DROP_REMOTE_PORT_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._drop_remote_port = result.value;
                },
                NetworkPacketTraceConfigWire.DROP_TCP_FLAGS_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._drop_tcp_flags = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getPollMs(self: *const NetworkPacketTraceConfigReader) u32 {
        return self._poll_ms;
    }
    pub inline fn getAggregationThreshold(self: *const NetworkPacketTraceConfigReader) u32 {
        return self._aggregation_threshold;
    }
    pub inline fn getInternLimit(self: *const NetworkPacketTraceConfigReader) u32 {
        return self._intern_limit;
    }
    pub inline fn getDropLocalPort(self: *const NetworkPacketTraceConfigReader) bool {
        return self._drop_local_port;
    }
    pub inline fn getDropRemotePort(self: *const NetworkPacketTraceConfigReader) bool {
        return self._drop_remote_port;
    }
    pub inline fn getDropTcpFlags(self: *const NetworkPacketTraceConfigReader) bool {
        return self._drop_tcp_flags;
    }
};
const PackagesListConfigWire = struct {
    const PACKAGE_NAME_FILTER_WIRE: gremlin.ProtoWireNumber = 1;
    const ONLY_WRITE_ON_CPU_USE_EVERY_MS_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const PackagesListConfig = struct {
    // fields
    package_name_filter: ?[]const ?[]const u8 = null,
    only_write_on_cpu_use_every_ms: u32 = 0,
    pub fn calcProtobufSize(self: *const PackagesListConfig) usize {
        var res: usize = 0;
        if (self.package_name_filter) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(PackagesListConfigWire.PACKAGE_NAME_FILTER_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.only_write_on_cpu_use_every_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(PackagesListConfigWire.ONLY_WRITE_ON_CPU_USE_EVERY_MS_WIRE) + gremlin.sizes.sizeU32(self.only_write_on_cpu_use_every_ms);
        }
        return res;
    }
    pub fn encode(self: *const PackagesListConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const PackagesListConfig, target: *gremlin.Writer) void {
        if (self.package_name_filter) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(PackagesListConfigWire.PACKAGE_NAME_FILTER_WIRE, v);
                } else {
                    target.appendBytesTag(PackagesListConfigWire.PACKAGE_NAME_FILTER_WIRE, 0);
                }
            }
        }
        if (self.only_write_on_cpu_use_every_ms != 0) {
            target.appendUint32(PackagesListConfigWire.ONLY_WRITE_ON_CPU_USE_EVERY_MS_WIRE, self.only_write_on_cpu_use_every_ms);
        }
    }
};
pub const PackagesListConfigReader = struct {
    buf: gremlin.Reader,
    _package_name_filter_offset: ?usize = null,
    _package_name_filter_last_offset: ?usize = null,
    _package_name_filter_cnt: usize = 0,
    _only_write_on_cpu_use_every_ms: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!PackagesListConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = PackagesListConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                PackagesListConfigWire.PACKAGE_NAME_FILTER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._package_name_filter_offset == null) {
                        res._package_name_filter_offset = offset - result.size;
                    }
                    res._package_name_filter_last_offset = offset;
                    res._package_name_filter_cnt += 1;
                },
                PackagesListConfigWire.ONLY_WRITE_ON_CPU_USE_EVERY_MS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._only_write_on_cpu_use_every_ms = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn packageNameFilterCount(self: *const PackagesListConfigReader) usize {
        return self._package_name_filter_cnt;
    }
    pub fn packageNameFilterNext(self: *PackagesListConfigReader) ?[]const u8 {
        if (self._package_name_filter_offset == null) return null;
        const current_offset = self._package_name_filter_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._package_name_filter_last_offset != null and current_offset >= self._package_name_filter_last_offset.?) {
            self._package_name_filter_offset = null;
            return result.value;
        }
        if (self._package_name_filter_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._package_name_filter_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == PackagesListConfigWire.PACKAGE_NAME_FILTER_WIRE) {
                self._package_name_filter_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._package_name_filter_offset = null;
        return result.value;
    }
    pub inline fn getOnlyWriteOnCpuUseEveryMs(self: *const PackagesListConfigReader) u32 {
        return self._only_write_on_cpu_use_every_ms;
    }
};
const PixelModemConfigWire = struct {
    const EVENT_GROUP_WIRE: gremlin.ProtoWireNumber = 1;
    const PIGWEED_HASH_ALLOW_LIST_WIRE: gremlin.ProtoWireNumber = 2;
    const PIGWEED_HASH_DENY_LIST_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const PixelModemConfig = struct {
    // nested enums
    pub const EventGroup = enum(i32) {
        EVENT_GROUP_UNKNOWN = 0,
        EVENT_GROUP_LOW_BANDWIDTH = 1,
        EVENT_GROUP_HIGH_AND_LOW_BANDWIDTH = 2,
    };
    // fields
    event_group: PixelModemConfig.EventGroup = @enumFromInt(0),
    pigweed_hash_allow_list: ?[]const i64 = null,
    pigweed_hash_deny_list: ?[]const i64 = null,
    pub fn calcProtobufSize(self: *const PixelModemConfig) usize {
        var res: usize = 0;
        if (@intFromEnum(self.event_group) != 0) {
            res += gremlin.sizes.sizeWireNumber(PixelModemConfigWire.EVENT_GROUP_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.event_group));
        }
        if (self.pigweed_hash_allow_list) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(PixelModemConfigWire.PIGWEED_HASH_ALLOW_LIST_WIRE) + gremlin.sizes.sizeI64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI64(v);
                }
                res += gremlin.sizes.sizeWireNumber(PixelModemConfigWire.PIGWEED_HASH_ALLOW_LIST_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.pigweed_hash_deny_list) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(PixelModemConfigWire.PIGWEED_HASH_DENY_LIST_WIRE) + gremlin.sizes.sizeI64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI64(v);
                }
                res += gremlin.sizes.sizeWireNumber(PixelModemConfigWire.PIGWEED_HASH_DENY_LIST_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        return res;
    }
    pub fn encode(self: *const PixelModemConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const PixelModemConfig, target: *gremlin.Writer) void {
        if (@intFromEnum(self.event_group) != 0) {
            target.appendInt32(PixelModemConfigWire.EVENT_GROUP_WIRE, @intFromEnum(self.event_group));
        }
        if (self.pigweed_hash_allow_list) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt64(PixelModemConfigWire.PIGWEED_HASH_ALLOW_LIST_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI64(v);
                }
                target.appendBytesTag(PixelModemConfigWire.PIGWEED_HASH_ALLOW_LIST_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt64WithoutTag(v);
                }
            }
        }
        if (self.pigweed_hash_deny_list) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt64(PixelModemConfigWire.PIGWEED_HASH_DENY_LIST_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI64(v);
                }
                target.appendBytesTag(PixelModemConfigWire.PIGWEED_HASH_DENY_LIST_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt64WithoutTag(v);
                }
            }
        }
    }
};
pub const PixelModemConfigReader = struct {
    buf: gremlin.Reader,
    _event_group: PixelModemConfig.EventGroup = @enumFromInt(0),
    _pigweed_hash_allow_list_offset: ?usize = null,
    _pigweed_hash_allow_list_last_offset: ?usize = null,
    _pigweed_hash_allow_list_packed: bool = false,
    _pigweed_hash_deny_list_offset: ?usize = null,
    _pigweed_hash_deny_list_last_offset: ?usize = null,
    _pigweed_hash_deny_list_packed: bool = false,
    pub fn init(src: []const u8) gremlin.Error!PixelModemConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = PixelModemConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                PixelModemConfigWire.EVENT_GROUP_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._event_group = @enumFromInt(result.value);
                },
                PixelModemConfigWire.PIGWEED_HASH_ALLOW_LIST_WIRE => {
                    if (res._pigweed_hash_allow_list_offset == null) {
                        res._pigweed_hash_allow_list_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._pigweed_hash_allow_list_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._pigweed_hash_allow_list_offset = offset + length_result.size;
                        res._pigweed_hash_allow_list_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._pigweed_hash_allow_list_last_offset.?;
                    } else {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._pigweed_hash_allow_list_last_offset = offset;
                    }
                },
                PixelModemConfigWire.PIGWEED_HASH_DENY_LIST_WIRE => {
                    if (res._pigweed_hash_deny_list_offset == null) {
                        res._pigweed_hash_deny_list_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._pigweed_hash_deny_list_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._pigweed_hash_deny_list_offset = offset + length_result.size;
                        res._pigweed_hash_deny_list_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._pigweed_hash_deny_list_last_offset.?;
                    } else {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._pigweed_hash_deny_list_last_offset = offset;
                    }
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getEventGroup(self: *const PixelModemConfigReader) PixelModemConfig.EventGroup {
        return self._event_group;
    }
    pub fn pigweedHashAllowListNext(self: *PixelModemConfigReader) gremlin.Error!?i64 {
        if (self._pigweed_hash_allow_list_offset == null) return null;
        const current_offset = self._pigweed_hash_allow_list_offset.?;
        if (current_offset >= self._pigweed_hash_allow_list_last_offset.?) {
            self._pigweed_hash_allow_list_offset = null;
            return null;
        }
        if (self._pigweed_hash_allow_list_packed) {
            const value_result = try self.buf.readInt64(current_offset);
            self._pigweed_hash_allow_list_offset = current_offset + value_result.size;
            if (self._pigweed_hash_allow_list_offset.? >= self._pigweed_hash_allow_list_last_offset.?) {
                self._pigweed_hash_allow_list_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._pigweed_hash_allow_list_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == PixelModemConfigWire.PIGWEED_HASH_ALLOW_LIST_WIRE) {
                    self._pigweed_hash_allow_list_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._pigweed_hash_allow_list_offset = null;
            return value_result.value;
        }
    }
    pub fn pigweedHashDenyListNext(self: *PixelModemConfigReader) gremlin.Error!?i64 {
        if (self._pigweed_hash_deny_list_offset == null) return null;
        const current_offset = self._pigweed_hash_deny_list_offset.?;
        if (current_offset >= self._pigweed_hash_deny_list_last_offset.?) {
            self._pigweed_hash_deny_list_offset = null;
            return null;
        }
        if (self._pigweed_hash_deny_list_packed) {
            const value_result = try self.buf.readInt64(current_offset);
            self._pigweed_hash_deny_list_offset = current_offset + value_result.size;
            if (self._pigweed_hash_deny_list_offset.? >= self._pigweed_hash_deny_list_last_offset.?) {
                self._pigweed_hash_deny_list_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._pigweed_hash_deny_list_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == PixelModemConfigWire.PIGWEED_HASH_DENY_LIST_WIRE) {
                    self._pigweed_hash_deny_list_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._pigweed_hash_deny_list_offset = null;
            return value_result.value;
        }
    }
};
const ProtoLogConfigWire = struct {
    const GROUP_OVERRIDES_WIRE: gremlin.ProtoWireNumber = 1;
    const TRACING_MODE_WIRE: gremlin.ProtoWireNumber = 2;
    const DEFAULT_LOG_FROM_LEVEL_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const ProtoLogConfig = struct {
    // nested enums
    pub const TracingMode = enum(i32) {
        DEFAULT = 0,
        ENABLE_ALL = 1,
    };
    // fields
    group_overrides: ?[]const ?ProtoLogGroup = null,
    tracing_mode: ProtoLogConfig.TracingMode = @enumFromInt(0),
    default_log_from_level: ProtoLogLevel = @enumFromInt(0),
    pub fn calcProtobufSize(self: *const ProtoLogConfig) usize {
        var res: usize = 0;
        if (self.group_overrides) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ProtoLogConfigWire.GROUP_OVERRIDES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (@intFromEnum(self.tracing_mode) != 0) {
            res += gremlin.sizes.sizeWireNumber(ProtoLogConfigWire.TRACING_MODE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.tracing_mode));
        }
        if (@intFromEnum(self.default_log_from_level) != 0) {
            res += gremlin.sizes.sizeWireNumber(ProtoLogConfigWire.DEFAULT_LOG_FROM_LEVEL_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.default_log_from_level));
        }
        return res;
    }
    pub fn encode(self: *const ProtoLogConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ProtoLogConfig, target: *gremlin.Writer) void {
        if (self.group_overrides) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(ProtoLogConfigWire.GROUP_OVERRIDES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(ProtoLogConfigWire.GROUP_OVERRIDES_WIRE, 0);
                }
            }
        }
        if (@intFromEnum(self.tracing_mode) != 0) {
            target.appendInt32(ProtoLogConfigWire.TRACING_MODE_WIRE, @intFromEnum(self.tracing_mode));
        }
        if (@intFromEnum(self.default_log_from_level) != 0) {
            target.appendInt32(ProtoLogConfigWire.DEFAULT_LOG_FROM_LEVEL_WIRE, @intFromEnum(self.default_log_from_level));
        }
    }
};
pub const ProtoLogConfigReader = struct {
    buf: gremlin.Reader,
    _group_overrides_offset: ?usize = null,
    _group_overrides_last_offset: ?usize = null,
    _group_overrides_cnt: usize = 0,
    _tracing_mode: ProtoLogConfig.TracingMode = @enumFromInt(0),
    _default_log_from_level: ProtoLogLevel = @enumFromInt(0),
    pub fn init(src: []const u8) gremlin.Error!ProtoLogConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = ProtoLogConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ProtoLogConfigWire.GROUP_OVERRIDES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._group_overrides_offset == null) {
                        res._group_overrides_offset = offset - result.size;
                    }
                    res._group_overrides_last_offset = offset;
                    res._group_overrides_cnt += 1;
                },
                ProtoLogConfigWire.TRACING_MODE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._tracing_mode = @enumFromInt(result.value);
                },
                ProtoLogConfigWire.DEFAULT_LOG_FROM_LEVEL_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._default_log_from_level = @enumFromInt(result.value);
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn groupOverridesCount(self: *const ProtoLogConfigReader) usize {
        return self._group_overrides_cnt;
    }
    pub fn groupOverridesNext(self: *ProtoLogConfigReader) ?ProtoLogGroupReader {
        if (self._group_overrides_offset == null) return null;
        const current_offset = self._group_overrides_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = ProtoLogGroupReader.init(result.value) catch return null;
        if (self._group_overrides_last_offset != null and current_offset >= self._group_overrides_last_offset.?) {
            self._group_overrides_offset = null;
            return msg;
        }
        if (self._group_overrides_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._group_overrides_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ProtoLogConfigWire.GROUP_OVERRIDES_WIRE) {
                self._group_overrides_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._group_overrides_offset = null;
        return msg;
    }
    pub inline fn getTracingMode(self: *const ProtoLogConfigReader) ProtoLogConfig.TracingMode {
        return self._tracing_mode;
    }
    pub inline fn getDefaultLogFromLevel(self: *const ProtoLogConfigReader) ProtoLogLevel {
        return self._default_log_from_level;
    }
};
const ProtoLogGroupWire = struct {
    const GROUP_NAME_WIRE: gremlin.ProtoWireNumber = 1;
    const LOG_FROM_WIRE: gremlin.ProtoWireNumber = 2;
    const COLLECT_STACKTRACE_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const ProtoLogGroup = struct {
    // fields
    group_name: ?[]const u8 = null,
    log_from: ProtoLogLevel = @enumFromInt(0),
    collect_stacktrace: bool = false,
    pub fn calcProtobufSize(self: *const ProtoLogGroup) usize {
        var res: usize = 0;
        if (self.group_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(ProtoLogGroupWire.GROUP_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (@intFromEnum(self.log_from) != 0) {
            res += gremlin.sizes.sizeWireNumber(ProtoLogGroupWire.LOG_FROM_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.log_from));
        }
        if (self.collect_stacktrace != false) {
            res += gremlin.sizes.sizeWireNumber(ProtoLogGroupWire.COLLECT_STACKTRACE_WIRE) + gremlin.sizes.sizeBool(self.collect_stacktrace);
        }
        return res;
    }
    pub fn encode(self: *const ProtoLogGroup, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ProtoLogGroup, target: *gremlin.Writer) void {
        if (self.group_name) |v| {
            if (v.len > 0) {
                target.appendBytes(ProtoLogGroupWire.GROUP_NAME_WIRE, v);
            }
        }
        if (@intFromEnum(self.log_from) != 0) {
            target.appendInt32(ProtoLogGroupWire.LOG_FROM_WIRE, @intFromEnum(self.log_from));
        }
        if (self.collect_stacktrace != false) {
            target.appendBool(ProtoLogGroupWire.COLLECT_STACKTRACE_WIRE, self.collect_stacktrace);
        }
    }
};
pub const ProtoLogGroupReader = struct {
    buf: gremlin.Reader,
    _group_name: ?[]const u8 = null,
    _log_from: ProtoLogLevel = @enumFromInt(0),
    _collect_stacktrace: bool = false,
    pub fn init(src: []const u8) gremlin.Error!ProtoLogGroupReader {
        const buf = gremlin.Reader.init(src);
        var res = ProtoLogGroupReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ProtoLogGroupWire.GROUP_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._group_name = result.value;
                },
                ProtoLogGroupWire.LOG_FROM_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._log_from = @enumFromInt(result.value);
                },
                ProtoLogGroupWire.COLLECT_STACKTRACE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._collect_stacktrace = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getGroupName(self: *const ProtoLogGroupReader) []const u8 {
        return self._group_name orelse &[_]u8{};
    }
    pub inline fn getLogFrom(self: *const ProtoLogGroupReader) ProtoLogLevel {
        return self._log_from;
    }
    pub inline fn getCollectStacktrace(self: *const ProtoLogGroupReader) bool {
        return self._collect_stacktrace;
    }
};
const SurfaceFlingerLayersConfigWire = struct {
    const MODE_WIRE: gremlin.ProtoWireNumber = 1;
    const TRACE_FLAGS_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const SurfaceFlingerLayersConfig = struct {
    // nested enums
    pub const Mode = enum(i32) {
        MODE_UNSPECIFIED = 0,
        MODE_ACTIVE = 1,
        MODE_GENERATED = 2,
        MODE_DUMP = 3,
        MODE_GENERATED_BUGREPORT_ONLY = 4,
    };
    pub const TraceFlag = enum(i32) {
        TRACE_FLAG_UNSPECIFIED = 0,
        TRACE_FLAG_INPUT = 2,
        TRACE_FLAG_COMPOSITION = 4,
        TRACE_FLAG_EXTRA = 8,
        TRACE_FLAG_HWC = 16,
        TRACE_FLAG_BUFFERS = 32,
        TRACE_FLAG_VIRTUAL_DISPLAYS = 64,
        TRACE_FLAG_ALL = 14,
    };
    // fields
    mode: SurfaceFlingerLayersConfig.Mode = @enumFromInt(0),
    trace_flags: ?[]const SurfaceFlingerLayersConfig.TraceFlag = null,
    pub fn calcProtobufSize(self: *const SurfaceFlingerLayersConfig) usize {
        var res: usize = 0;
        if (@intFromEnum(self.mode) != 0) {
            res += gremlin.sizes.sizeWireNumber(SurfaceFlingerLayersConfigWire.MODE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.mode));
        }
        if (self.trace_flags) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(SurfaceFlingerLayersConfigWire.TRACE_FLAGS_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(arr[0]));
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(@intFromEnum(v));
                }
                res += gremlin.sizes.sizeWireNumber(SurfaceFlingerLayersConfigWire.TRACE_FLAGS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        return res;
    }
    pub fn encode(self: *const SurfaceFlingerLayersConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SurfaceFlingerLayersConfig, target: *gremlin.Writer) void {
        if (@intFromEnum(self.mode) != 0) {
            target.appendInt32(SurfaceFlingerLayersConfigWire.MODE_WIRE, @intFromEnum(self.mode));
        }
        if (self.trace_flags) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt32(SurfaceFlingerLayersConfigWire.TRACE_FLAGS_WIRE, @intFromEnum(arr[0]));
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(@intFromEnum(v));
                }
                target.appendBytesTag(SurfaceFlingerLayersConfigWire.TRACE_FLAGS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt32WithoutTag(@intFromEnum(v));
                }
            }
        }
    }
};
pub const SurfaceFlingerLayersConfigReader = struct {
    buf: gremlin.Reader,
    _mode: SurfaceFlingerLayersConfig.Mode = @enumFromInt(0),
    _trace_flags_offset: ?usize = null,
    _trace_flags_last_offset: ?usize = null,
    _trace_flags_packed: bool = false,
    pub fn init(src: []const u8) gremlin.Error!SurfaceFlingerLayersConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = SurfaceFlingerLayersConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SurfaceFlingerLayersConfigWire.MODE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._mode = @enumFromInt(result.value);
                },
                SurfaceFlingerLayersConfigWire.TRACE_FLAGS_WIRE => {
                    if (res._trace_flags_offset == null) {
                        res._trace_flags_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._trace_flags_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._trace_flags_offset = offset + length_result.size;
                        res._trace_flags_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._trace_flags_last_offset.?;
                    } else {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._trace_flags_last_offset = offset;
                    }
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getMode(self: *const SurfaceFlingerLayersConfigReader) SurfaceFlingerLayersConfig.Mode {
        return self._mode;
    }
    pub fn traceFlagsNext(self: *SurfaceFlingerLayersConfigReader) gremlin.Error!?SurfaceFlingerLayersConfig.TraceFlag {
        if (self._trace_flags_offset == null) return null;
        const current_offset = self._trace_flags_offset.?;
        if (current_offset >= self._trace_flags_last_offset.?) {
            self._trace_flags_offset = null;
            return null;
        }
        if (self._trace_flags_packed) {
            const value_result = try self.buf.readInt32(current_offset);
            self._trace_flags_offset = current_offset + value_result.size;
            if (self._trace_flags_offset.? >= self._trace_flags_last_offset.?) {
                self._trace_flags_offset = null;
            }
            return @enumFromInt(value_result.value);
        } else {
            const value_result = try self.buf.readInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._trace_flags_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == SurfaceFlingerLayersConfigWire.TRACE_FLAGS_WIRE) {
                    self._trace_flags_offset = next_offset;
                    return @enumFromInt(value_result.value);
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._trace_flags_offset = null;
            return @enumFromInt(value_result.value);
        }
    }
};
const SurfaceFlingerTransactionsConfigWire = struct {
    const MODE_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const SurfaceFlingerTransactionsConfig = struct {
    // nested enums
    pub const Mode = enum(i32) {
        MODE_UNSPECIFIED = 0,
        MODE_CONTINUOUS = 1,
        MODE_ACTIVE = 2,
    };
    // fields
    mode: SurfaceFlingerTransactionsConfig.Mode = @enumFromInt(0),
    pub fn calcProtobufSize(self: *const SurfaceFlingerTransactionsConfig) usize {
        var res: usize = 0;
        if (@intFromEnum(self.mode) != 0) {
            res += gremlin.sizes.sizeWireNumber(SurfaceFlingerTransactionsConfigWire.MODE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.mode));
        }
        return res;
    }
    pub fn encode(self: *const SurfaceFlingerTransactionsConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SurfaceFlingerTransactionsConfig, target: *gremlin.Writer) void {
        if (@intFromEnum(self.mode) != 0) {
            target.appendInt32(SurfaceFlingerTransactionsConfigWire.MODE_WIRE, @intFromEnum(self.mode));
        }
    }
};
pub const SurfaceFlingerTransactionsConfigReader = struct {
    buf: gremlin.Reader,
    _mode: SurfaceFlingerTransactionsConfig.Mode = @enumFromInt(0),
    pub fn init(src: []const u8) gremlin.Error!SurfaceFlingerTransactionsConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = SurfaceFlingerTransactionsConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SurfaceFlingerTransactionsConfigWire.MODE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._mode = @enumFromInt(result.value);
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getMode(self: *const SurfaceFlingerTransactionsConfigReader) SurfaceFlingerTransactionsConfig.Mode {
        return self._mode;
    }
};
const WindowManagerConfigWire = struct {
    const LOG_FREQUENCY_WIRE: gremlin.ProtoWireNumber = 1;
    const LOG_LEVEL_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const WindowManagerConfig = struct {
    // nested enums
    pub const LogFrequency = enum(i32) {
        LOG_FREQUENCY_UNSPECIFIED = 0,
        LOG_FREQUENCY_FRAME = 1,
        LOG_FREQUENCY_TRANSACTION = 2,
        LOG_FREQUENCY_SINGLE_DUMP = 3,
    };
    pub const LogLevel = enum(i32) {
        LOG_LEVEL_UNSPECIFIED = 0,
        LOG_LEVEL_VERBOSE = 1,
        LOG_LEVEL_DEBUG = 2,
        LOG_LEVEL_CRITICAL = 3,
    };
    // fields
    log_frequency: WindowManagerConfig.LogFrequency = @enumFromInt(0),
    log_level: WindowManagerConfig.LogLevel = @enumFromInt(0),
    pub fn calcProtobufSize(self: *const WindowManagerConfig) usize {
        var res: usize = 0;
        if (@intFromEnum(self.log_frequency) != 0) {
            res += gremlin.sizes.sizeWireNumber(WindowManagerConfigWire.LOG_FREQUENCY_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.log_frequency));
        }
        if (@intFromEnum(self.log_level) != 0) {
            res += gremlin.sizes.sizeWireNumber(WindowManagerConfigWire.LOG_LEVEL_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.log_level));
        }
        return res;
    }
    pub fn encode(self: *const WindowManagerConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const WindowManagerConfig, target: *gremlin.Writer) void {
        if (@intFromEnum(self.log_frequency) != 0) {
            target.appendInt32(WindowManagerConfigWire.LOG_FREQUENCY_WIRE, @intFromEnum(self.log_frequency));
        }
        if (@intFromEnum(self.log_level) != 0) {
            target.appendInt32(WindowManagerConfigWire.LOG_LEVEL_WIRE, @intFromEnum(self.log_level));
        }
    }
};
pub const WindowManagerConfigReader = struct {
    buf: gremlin.Reader,
    _log_frequency: WindowManagerConfig.LogFrequency = @enumFromInt(0),
    _log_level: WindowManagerConfig.LogLevel = @enumFromInt(0),
    pub fn init(src: []const u8) gremlin.Error!WindowManagerConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = WindowManagerConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                WindowManagerConfigWire.LOG_FREQUENCY_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._log_frequency = @enumFromInt(result.value);
                },
                WindowManagerConfigWire.LOG_LEVEL_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._log_level = @enumFromInt(result.value);
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getLogFrequency(self: *const WindowManagerConfigReader) WindowManagerConfig.LogFrequency {
        return self._log_frequency;
    }
    pub inline fn getLogLevel(self: *const WindowManagerConfigReader) WindowManagerConfig.LogLevel {
        return self._log_level;
    }
};
const ChromeConfigWire = struct {
    const TRACE_CONFIG_WIRE: gremlin.ProtoWireNumber = 1;
    const PRIVACY_FILTERING_ENABLED_WIRE: gremlin.ProtoWireNumber = 2;
    const CONVERT_TO_LEGACY_JSON_WIRE: gremlin.ProtoWireNumber = 3;
    const CLIENT_PRIORITY_WIRE: gremlin.ProtoWireNumber = 4;
    const JSON_AGENT_LABEL_FILTER_WIRE: gremlin.ProtoWireNumber = 5;
    const EVENT_PACKAGE_NAME_FILTER_ENABLED_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const ChromeConfig = struct {
    // nested enums
    pub const ClientPriority = enum(i32) {
        UNKNOWN = 0,
        BACKGROUND = 1,
        USER_INITIATED = 2,
    };
    // fields
    trace_config: ?[]const u8 = null,
    privacy_filtering_enabled: bool = false,
    convert_to_legacy_json: bool = false,
    client_priority: ChromeConfig.ClientPriority = @enumFromInt(0),
    json_agent_label_filter: ?[]const u8 = null,
    event_package_name_filter_enabled: bool = false,
    pub fn calcProtobufSize(self: *const ChromeConfig) usize {
        var res: usize = 0;
        if (self.trace_config) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeConfigWire.TRACE_CONFIG_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.privacy_filtering_enabled != false) {
            res += gremlin.sizes.sizeWireNumber(ChromeConfigWire.PRIVACY_FILTERING_ENABLED_WIRE) + gremlin.sizes.sizeBool(self.privacy_filtering_enabled);
        }
        if (self.convert_to_legacy_json != false) {
            res += gremlin.sizes.sizeWireNumber(ChromeConfigWire.CONVERT_TO_LEGACY_JSON_WIRE) + gremlin.sizes.sizeBool(self.convert_to_legacy_json);
        }
        if (@intFromEnum(self.client_priority) != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromeConfigWire.CLIENT_PRIORITY_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.client_priority));
        }
        if (self.json_agent_label_filter) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(ChromeConfigWire.JSON_AGENT_LABEL_FILTER_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.event_package_name_filter_enabled != false) {
            res += gremlin.sizes.sizeWireNumber(ChromeConfigWire.EVENT_PACKAGE_NAME_FILTER_ENABLED_WIRE) + gremlin.sizes.sizeBool(self.event_package_name_filter_enabled);
        }
        return res;
    }
    pub fn encode(self: *const ChromeConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ChromeConfig, target: *gremlin.Writer) void {
        if (self.trace_config) |v| {
            if (v.len > 0) {
                target.appendBytes(ChromeConfigWire.TRACE_CONFIG_WIRE, v);
            }
        }
        if (self.privacy_filtering_enabled != false) {
            target.appendBool(ChromeConfigWire.PRIVACY_FILTERING_ENABLED_WIRE, self.privacy_filtering_enabled);
        }
        if (self.convert_to_legacy_json != false) {
            target.appendBool(ChromeConfigWire.CONVERT_TO_LEGACY_JSON_WIRE, self.convert_to_legacy_json);
        }
        if (@intFromEnum(self.client_priority) != 0) {
            target.appendInt32(ChromeConfigWire.CLIENT_PRIORITY_WIRE, @intFromEnum(self.client_priority));
        }
        if (self.json_agent_label_filter) |v| {
            if (v.len > 0) {
                target.appendBytes(ChromeConfigWire.JSON_AGENT_LABEL_FILTER_WIRE, v);
            }
        }
        if (self.event_package_name_filter_enabled != false) {
            target.appendBool(ChromeConfigWire.EVENT_PACKAGE_NAME_FILTER_ENABLED_WIRE, self.event_package_name_filter_enabled);
        }
    }
};
pub const ChromeConfigReader = struct {
    buf: gremlin.Reader,
    _trace_config: ?[]const u8 = null,
    _privacy_filtering_enabled: bool = false,
    _convert_to_legacy_json: bool = false,
    _client_priority: ChromeConfig.ClientPriority = @enumFromInt(0),
    _json_agent_label_filter: ?[]const u8 = null,
    _event_package_name_filter_enabled: bool = false,
    pub fn init(src: []const u8) gremlin.Error!ChromeConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = ChromeConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ChromeConfigWire.TRACE_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._trace_config = result.value;
                },
                ChromeConfigWire.PRIVACY_FILTERING_ENABLED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._privacy_filtering_enabled = result.value;
                },
                ChromeConfigWire.CONVERT_TO_LEGACY_JSON_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._convert_to_legacy_json = result.value;
                },
                ChromeConfigWire.CLIENT_PRIORITY_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._client_priority = @enumFromInt(result.value);
                },
                ChromeConfigWire.JSON_AGENT_LABEL_FILTER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._json_agent_label_filter = result.value;
                },
                ChromeConfigWire.EVENT_PACKAGE_NAME_FILTER_ENABLED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._event_package_name_filter_enabled = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getTraceConfig(self: *const ChromeConfigReader) []const u8 {
        return self._trace_config orelse &[_]u8{};
    }
    pub inline fn getPrivacyFilteringEnabled(self: *const ChromeConfigReader) bool {
        return self._privacy_filtering_enabled;
    }
    pub inline fn getConvertToLegacyJson(self: *const ChromeConfigReader) bool {
        return self._convert_to_legacy_json;
    }
    pub inline fn getClientPriority(self: *const ChromeConfigReader) ChromeConfig.ClientPriority {
        return self._client_priority;
    }
    pub inline fn getJsonAgentLabelFilter(self: *const ChromeConfigReader) []const u8 {
        return self._json_agent_label_filter orelse &[_]u8{};
    }
    pub inline fn getEventPackageNameFilterEnabled(self: *const ChromeConfigReader) bool {
        return self._event_package_name_filter_enabled;
    }
};
const ChromiumHistogramSamplesConfigWire = struct {
    const HISTOGRAMS_WIRE: gremlin.ProtoWireNumber = 1;
    const FILTER_HISTOGRAM_NAMES_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const ChromiumHistogramSamplesConfig = struct {
    // nested structs
    const HistogramSampleWire = struct {
        const HISTOGRAM_NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const MIN_VALUE_WIRE: gremlin.ProtoWireNumber = 2;
        const MAX_VALUE_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const HistogramSample = struct {
        // fields
        histogram_name: ?[]const u8 = null,
        min_value: i64 = 0,
        max_value: i64 = 0,
        pub fn calcProtobufSize(self: *const ChromiumHistogramSamplesConfig.HistogramSample) usize {
            var res: usize = 0;
            if (self.histogram_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(ChromiumHistogramSamplesConfig.HistogramSampleWire.HISTOGRAM_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.min_value != 0) {
                res += gremlin.sizes.sizeWireNumber(ChromiumHistogramSamplesConfig.HistogramSampleWire.MIN_VALUE_WIRE) + gremlin.sizes.sizeI64(self.min_value);
            }
            if (self.max_value != 0) {
                res += gremlin.sizes.sizeWireNumber(ChromiumHistogramSamplesConfig.HistogramSampleWire.MAX_VALUE_WIRE) + gremlin.sizes.sizeI64(self.max_value);
            }
            return res;
        }
        pub fn encode(self: *const ChromiumHistogramSamplesConfig.HistogramSample, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const ChromiumHistogramSamplesConfig.HistogramSample, target: *gremlin.Writer) void {
            if (self.histogram_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(ChromiumHistogramSamplesConfig.HistogramSampleWire.HISTOGRAM_NAME_WIRE, v);
                }
            }
            if (self.min_value != 0) {
                target.appendInt64(ChromiumHistogramSamplesConfig.HistogramSampleWire.MIN_VALUE_WIRE, self.min_value);
            }
            if (self.max_value != 0) {
                target.appendInt64(ChromiumHistogramSamplesConfig.HistogramSampleWire.MAX_VALUE_WIRE, self.max_value);
            }
        }
    };
    pub const HistogramSampleReader = struct {
        buf: gremlin.Reader,
        _histogram_name: ?[]const u8 = null,
        _min_value: i64 = 0,
        _max_value: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!ChromiumHistogramSamplesConfig.HistogramSampleReader {
            const buf = gremlin.Reader.init(src);
            var res = ChromiumHistogramSamplesConfig.HistogramSampleReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    ChromiumHistogramSamplesConfig.HistogramSampleWire.HISTOGRAM_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._histogram_name = result.value;
                    },
                    ChromiumHistogramSamplesConfig.HistogramSampleWire.MIN_VALUE_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._min_value = result.value;
                    },
                    ChromiumHistogramSamplesConfig.HistogramSampleWire.MAX_VALUE_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._max_value = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getHistogramName(self: *const ChromiumHistogramSamplesConfig.HistogramSampleReader) []const u8 {
            return self._histogram_name orelse &[_]u8{};
        }
        pub inline fn getMinValue(self: *const ChromiumHistogramSamplesConfig.HistogramSampleReader) i64 {
            return self._min_value;
        }
        pub inline fn getMaxValue(self: *const ChromiumHistogramSamplesConfig.HistogramSampleReader) i64 {
            return self._max_value;
        }
    };
    // fields
    histograms: ?[]const ?ChromiumHistogramSamplesConfig.HistogramSample = null,
    filter_histogram_names: bool = false,
    pub fn calcProtobufSize(self: *const ChromiumHistogramSamplesConfig) usize {
        var res: usize = 0;
        if (self.histograms) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ChromiumHistogramSamplesConfigWire.HISTOGRAMS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.filter_histogram_names != false) {
            res += gremlin.sizes.sizeWireNumber(ChromiumHistogramSamplesConfigWire.FILTER_HISTOGRAM_NAMES_WIRE) + gremlin.sizes.sizeBool(self.filter_histogram_names);
        }
        return res;
    }
    pub fn encode(self: *const ChromiumHistogramSamplesConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ChromiumHistogramSamplesConfig, target: *gremlin.Writer) void {
        if (self.histograms) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(ChromiumHistogramSamplesConfigWire.HISTOGRAMS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(ChromiumHistogramSamplesConfigWire.HISTOGRAMS_WIRE, 0);
                }
            }
        }
        if (self.filter_histogram_names != false) {
            target.appendBool(ChromiumHistogramSamplesConfigWire.FILTER_HISTOGRAM_NAMES_WIRE, self.filter_histogram_names);
        }
    }
};
pub const ChromiumHistogramSamplesConfigReader = struct {
    buf: gremlin.Reader,
    _histograms_offset: ?usize = null,
    _histograms_last_offset: ?usize = null,
    _histograms_cnt: usize = 0,
    _filter_histogram_names: bool = false,
    pub fn init(src: []const u8) gremlin.Error!ChromiumHistogramSamplesConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = ChromiumHistogramSamplesConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ChromiumHistogramSamplesConfigWire.HISTOGRAMS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._histograms_offset == null) {
                        res._histograms_offset = offset - result.size;
                    }
                    res._histograms_last_offset = offset;
                    res._histograms_cnt += 1;
                },
                ChromiumHistogramSamplesConfigWire.FILTER_HISTOGRAM_NAMES_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._filter_histogram_names = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn histogramsCount(self: *const ChromiumHistogramSamplesConfigReader) usize {
        return self._histograms_cnt;
    }
    pub fn histogramsNext(self: *ChromiumHistogramSamplesConfigReader) ?ChromiumHistogramSamplesConfig.HistogramSampleReader {
        if (self._histograms_offset == null) return null;
        const current_offset = self._histograms_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = ChromiumHistogramSamplesConfig.HistogramSampleReader.init(result.value) catch return null;
        if (self._histograms_last_offset != null and current_offset >= self._histograms_last_offset.?) {
            self._histograms_offset = null;
            return msg;
        }
        if (self._histograms_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._histograms_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ChromiumHistogramSamplesConfigWire.HISTOGRAMS_WIRE) {
                self._histograms_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._histograms_offset = null;
        return msg;
    }
    pub inline fn getFilterHistogramNames(self: *const ChromiumHistogramSamplesConfigReader) bool {
        return self._filter_histogram_names;
    }
};
const ChromiumSystemMetricsConfigWire = struct {
    const SAMPLING_INTERVAL_MS_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const ChromiumSystemMetricsConfig = struct {
    // fields
    sampling_interval_ms: u32 = 0,
    pub fn calcProtobufSize(self: *const ChromiumSystemMetricsConfig) usize {
        var res: usize = 0;
        if (self.sampling_interval_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(ChromiumSystemMetricsConfigWire.SAMPLING_INTERVAL_MS_WIRE) + gremlin.sizes.sizeU32(self.sampling_interval_ms);
        }
        return res;
    }
    pub fn encode(self: *const ChromiumSystemMetricsConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ChromiumSystemMetricsConfig, target: *gremlin.Writer) void {
        if (self.sampling_interval_ms != 0) {
            target.appendUint32(ChromiumSystemMetricsConfigWire.SAMPLING_INTERVAL_MS_WIRE, self.sampling_interval_ms);
        }
    }
};
pub const ChromiumSystemMetricsConfigReader = struct {
    buf: gremlin.Reader,
    _sampling_interval_ms: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!ChromiumSystemMetricsConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = ChromiumSystemMetricsConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ChromiumSystemMetricsConfigWire.SAMPLING_INTERVAL_MS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._sampling_interval_ms = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getSamplingIntervalMs(self: *const ChromiumSystemMetricsConfigReader) u32 {
        return self._sampling_interval_ms;
    }
};
const V8ConfigWire = struct {
    const LOG_SCRIPT_SOURCES_WIRE: gremlin.ProtoWireNumber = 1;
    const LOG_INSTRUCTIONS_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const V8Config = struct {
    // fields
    log_script_sources: bool = false,
    log_instructions: bool = false,
    pub fn calcProtobufSize(self: *const V8Config) usize {
        var res: usize = 0;
        if (self.log_script_sources != false) {
            res += gremlin.sizes.sizeWireNumber(V8ConfigWire.LOG_SCRIPT_SOURCES_WIRE) + gremlin.sizes.sizeBool(self.log_script_sources);
        }
        if (self.log_instructions != false) {
            res += gremlin.sizes.sizeWireNumber(V8ConfigWire.LOG_INSTRUCTIONS_WIRE) + gremlin.sizes.sizeBool(self.log_instructions);
        }
        return res;
    }
    pub fn encode(self: *const V8Config, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const V8Config, target: *gremlin.Writer) void {
        if (self.log_script_sources != false) {
            target.appendBool(V8ConfigWire.LOG_SCRIPT_SOURCES_WIRE, self.log_script_sources);
        }
        if (self.log_instructions != false) {
            target.appendBool(V8ConfigWire.LOG_INSTRUCTIONS_WIRE, self.log_instructions);
        }
    }
};
pub const V8ConfigReader = struct {
    buf: gremlin.Reader,
    _log_script_sources: bool = false,
    _log_instructions: bool = false,
    pub fn init(src: []const u8) gremlin.Error!V8ConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = V8ConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                V8ConfigWire.LOG_SCRIPT_SOURCES_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._log_script_sources = result.value;
                },
                V8ConfigWire.LOG_INSTRUCTIONS_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._log_instructions = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getLogScriptSources(self: *const V8ConfigReader) bool {
        return self._log_script_sources;
    }
    pub inline fn getLogInstructions(self: *const V8ConfigReader) bool {
        return self._log_instructions;
    }
};
const EtwConfigWire = struct {
    const KERNEL_FLAGS_WIRE: gremlin.ProtoWireNumber = 1;
    const SCHEDULER_PROVIDER_EVENTS_WIRE: gremlin.ProtoWireNumber = 2;
    const MEMORY_PROVIDER_EVENTS_WIRE: gremlin.ProtoWireNumber = 3;
    const FILE_PROVIDER_EVENTS_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const EtwConfig = struct {
    // nested enums
    pub const KernelFlag = enum(i32) {
        CSWITCH = 0,
        DISPATCHER = 1,
    };
    // fields
    kernel_flags: ?[]const EtwConfig.KernelFlag = null,
    scheduler_provider_events: ?[]const ?[]const u8 = null,
    memory_provider_events: ?[]const ?[]const u8 = null,
    file_provider_events: ?[]const ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const EtwConfig) usize {
        var res: usize = 0;
        if (self.kernel_flags) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(EtwConfigWire.KERNEL_FLAGS_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(arr[0]));
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(@intFromEnum(v));
                }
                res += gremlin.sizes.sizeWireNumber(EtwConfigWire.KERNEL_FLAGS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.scheduler_provider_events) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(EtwConfigWire.SCHEDULER_PROVIDER_EVENTS_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.memory_provider_events) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(EtwConfigWire.MEMORY_PROVIDER_EVENTS_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.file_provider_events) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(EtwConfigWire.FILE_PROVIDER_EVENTS_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const EtwConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const EtwConfig, target: *gremlin.Writer) void {
        if (self.kernel_flags) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt32(EtwConfigWire.KERNEL_FLAGS_WIRE, @intFromEnum(arr[0]));
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(@intFromEnum(v));
                }
                target.appendBytesTag(EtwConfigWire.KERNEL_FLAGS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt32WithoutTag(@intFromEnum(v));
                }
            }
        }
        if (self.scheduler_provider_events) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(EtwConfigWire.SCHEDULER_PROVIDER_EVENTS_WIRE, v);
                } else {
                    target.appendBytesTag(EtwConfigWire.SCHEDULER_PROVIDER_EVENTS_WIRE, 0);
                }
            }
        }
        if (self.memory_provider_events) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(EtwConfigWire.MEMORY_PROVIDER_EVENTS_WIRE, v);
                } else {
                    target.appendBytesTag(EtwConfigWire.MEMORY_PROVIDER_EVENTS_WIRE, 0);
                }
            }
        }
        if (self.file_provider_events) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(EtwConfigWire.FILE_PROVIDER_EVENTS_WIRE, v);
                } else {
                    target.appendBytesTag(EtwConfigWire.FILE_PROVIDER_EVENTS_WIRE, 0);
                }
            }
        }
    }
};
pub const EtwConfigReader = struct {
    buf: gremlin.Reader,
    _kernel_flags_offset: ?usize = null,
    _kernel_flags_last_offset: ?usize = null,
    _kernel_flags_packed: bool = false,
    _scheduler_provider_events_offset: ?usize = null,
    _scheduler_provider_events_last_offset: ?usize = null,
    _scheduler_provider_events_cnt: usize = 0,
    _memory_provider_events_offset: ?usize = null,
    _memory_provider_events_last_offset: ?usize = null,
    _memory_provider_events_cnt: usize = 0,
    _file_provider_events_offset: ?usize = null,
    _file_provider_events_last_offset: ?usize = null,
    _file_provider_events_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!EtwConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = EtwConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                EtwConfigWire.KERNEL_FLAGS_WIRE => {
                    if (res._kernel_flags_offset == null) {
                        res._kernel_flags_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._kernel_flags_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._kernel_flags_offset = offset + length_result.size;
                        res._kernel_flags_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._kernel_flags_last_offset.?;
                    } else {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._kernel_flags_last_offset = offset;
                    }
                },
                EtwConfigWire.SCHEDULER_PROVIDER_EVENTS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._scheduler_provider_events_offset == null) {
                        res._scheduler_provider_events_offset = offset - result.size;
                    }
                    res._scheduler_provider_events_last_offset = offset;
                    res._scheduler_provider_events_cnt += 1;
                },
                EtwConfigWire.MEMORY_PROVIDER_EVENTS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._memory_provider_events_offset == null) {
                        res._memory_provider_events_offset = offset - result.size;
                    }
                    res._memory_provider_events_last_offset = offset;
                    res._memory_provider_events_cnt += 1;
                },
                EtwConfigWire.FILE_PROVIDER_EVENTS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._file_provider_events_offset == null) {
                        res._file_provider_events_offset = offset - result.size;
                    }
                    res._file_provider_events_last_offset = offset;
                    res._file_provider_events_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn kernelFlagsNext(self: *EtwConfigReader) gremlin.Error!?EtwConfig.KernelFlag {
        if (self._kernel_flags_offset == null) return null;
        const current_offset = self._kernel_flags_offset.?;
        if (current_offset >= self._kernel_flags_last_offset.?) {
            self._kernel_flags_offset = null;
            return null;
        }
        if (self._kernel_flags_packed) {
            const value_result = try self.buf.readInt32(current_offset);
            self._kernel_flags_offset = current_offset + value_result.size;
            if (self._kernel_flags_offset.? >= self._kernel_flags_last_offset.?) {
                self._kernel_flags_offset = null;
            }
            return @enumFromInt(value_result.value);
        } else {
            const value_result = try self.buf.readInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._kernel_flags_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == EtwConfigWire.KERNEL_FLAGS_WIRE) {
                    self._kernel_flags_offset = next_offset;
                    return @enumFromInt(value_result.value);
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._kernel_flags_offset = null;
            return @enumFromInt(value_result.value);
        }
    }
    pub fn schedulerProviderEventsCount(self: *const EtwConfigReader) usize {
        return self._scheduler_provider_events_cnt;
    }
    pub fn schedulerProviderEventsNext(self: *EtwConfigReader) ?[]const u8 {
        if (self._scheduler_provider_events_offset == null) return null;
        const current_offset = self._scheduler_provider_events_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._scheduler_provider_events_last_offset != null and current_offset >= self._scheduler_provider_events_last_offset.?) {
            self._scheduler_provider_events_offset = null;
            return result.value;
        }
        if (self._scheduler_provider_events_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._scheduler_provider_events_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == EtwConfigWire.SCHEDULER_PROVIDER_EVENTS_WIRE) {
                self._scheduler_provider_events_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._scheduler_provider_events_offset = null;
        return result.value;
    }
    pub fn memoryProviderEventsCount(self: *const EtwConfigReader) usize {
        return self._memory_provider_events_cnt;
    }
    pub fn memoryProviderEventsNext(self: *EtwConfigReader) ?[]const u8 {
        if (self._memory_provider_events_offset == null) return null;
        const current_offset = self._memory_provider_events_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._memory_provider_events_last_offset != null and current_offset >= self._memory_provider_events_last_offset.?) {
            self._memory_provider_events_offset = null;
            return result.value;
        }
        if (self._memory_provider_events_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._memory_provider_events_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == EtwConfigWire.MEMORY_PROVIDER_EVENTS_WIRE) {
                self._memory_provider_events_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._memory_provider_events_offset = null;
        return result.value;
    }
    pub fn fileProviderEventsCount(self: *const EtwConfigReader) usize {
        return self._file_provider_events_cnt;
    }
    pub fn fileProviderEventsNext(self: *EtwConfigReader) ?[]const u8 {
        if (self._file_provider_events_offset == null) return null;
        const current_offset = self._file_provider_events_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._file_provider_events_last_offset != null and current_offset >= self._file_provider_events_last_offset.?) {
            self._file_provider_events_offset = null;
            return result.value;
        }
        if (self._file_provider_events_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._file_provider_events_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == EtwConfigWire.FILE_PROVIDER_EVENTS_WIRE) {
                self._file_provider_events_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._file_provider_events_offset = null;
        return result.value;
    }
};
const FrozenFtraceConfigWire = struct {
    const INSTANCE_NAME_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const FrozenFtraceConfig = struct {
    // fields
    instance_name: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const FrozenFtraceConfig) usize {
        var res: usize = 0;
        if (self.instance_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(FrozenFtraceConfigWire.INSTANCE_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const FrozenFtraceConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const FrozenFtraceConfig, target: *gremlin.Writer) void {
        if (self.instance_name) |v| {
            if (v.len > 0) {
                target.appendBytes(FrozenFtraceConfigWire.INSTANCE_NAME_WIRE, v);
            }
        }
    }
};
pub const FrozenFtraceConfigReader = struct {
    buf: gremlin.Reader,
    _instance_name: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!FrozenFtraceConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = FrozenFtraceConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                FrozenFtraceConfigWire.INSTANCE_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._instance_name = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getInstanceName(self: *const FrozenFtraceConfigReader) []const u8 {
        return self._instance_name orelse &[_]u8{};
    }
};
const FtraceConfigWire = struct {
    const FTRACE_EVENTS_WIRE: gremlin.ProtoWireNumber = 1;
    const ATRACE_CATEGORIES_WIRE: gremlin.ProtoWireNumber = 2;
    const ATRACE_APPS_WIRE: gremlin.ProtoWireNumber = 3;
    const ATRACE_CATEGORIES_PREFER_SDK_WIRE: gremlin.ProtoWireNumber = 28;
    const ATRACE_USERSPACE_ONLY_WIRE: gremlin.ProtoWireNumber = 34;
    const BUFFER_SIZE_KB_WIRE: gremlin.ProtoWireNumber = 10;
    const BUFFER_SIZE_LOWER_BOUND_WIRE: gremlin.ProtoWireNumber = 27;
    const DRAIN_PERIOD_MS_WIRE: gremlin.ProtoWireNumber = 11;
    const DRAIN_BUFFER_PERCENT_WIRE: gremlin.ProtoWireNumber = 29;
    const COMPACT_SCHED_WIRE: gremlin.ProtoWireNumber = 12;
    const PRINT_FILTER_WIRE: gremlin.ProtoWireNumber = 22;
    const SYMBOLIZE_KSYMS_WIRE: gremlin.ProtoWireNumber = 13;
    const KSYMS_MEM_POLICY_WIRE: gremlin.ProtoWireNumber = 17;
    const THROTTLE_RSS_STAT_WIRE: gremlin.ProtoWireNumber = 15;
    const DENSER_GENERIC_EVENT_ENCODING_WIRE: gremlin.ProtoWireNumber = 32;
    const DISABLE_GENERIC_EVENTS_WIRE: gremlin.ProtoWireNumber = 16;
    const SYSCALL_EVENTS_WIRE: gremlin.ProtoWireNumber = 18;
    const ENABLE_FUNCTION_GRAPH_WIRE: gremlin.ProtoWireNumber = 19;
    const FUNCTION_FILTERS_WIRE: gremlin.ProtoWireNumber = 20;
    const FUNCTION_GRAPH_ROOTS_WIRE: gremlin.ProtoWireNumber = 21;
    const FUNCTION_GRAPH_MAX_DEPTH_WIRE: gremlin.ProtoWireNumber = 33;
    const KPROBE_EVENTS_WIRE: gremlin.ProtoWireNumber = 30;
    const PRESERVE_FTRACE_BUFFER_WIRE: gremlin.ProtoWireNumber = 23;
    const USE_MONOTONIC_RAW_CLOCK_WIRE: gremlin.ProtoWireNumber = 24;
    const INSTANCE_NAME_WIRE: gremlin.ProtoWireNumber = 25;
    const DEBUG_FTRACE_ABI_WIRE: gremlin.ProtoWireNumber = 31;
    const TIDS_TO_TRACE_WIRE: gremlin.ProtoWireNumber = 35;
    const TRACEFS_OPTIONS_WIRE: gremlin.ProtoWireNumber = 36;
    const TRACING_CPUMASK_WIRE: gremlin.ProtoWireNumber = 37;
    const INITIALIZE_KSYMS_SYNCHRONOUSLY_FOR_TESTING_WIRE: gremlin.ProtoWireNumber = 14;
};
pub const FtraceConfig = struct {
    // nested enums
    pub const KsymsMemPolicy = enum(i32) {
        KSYMS_UNSPECIFIED = 0,
        KSYMS_CLEANUP_ON_STOP = 1,
        KSYMS_RETAIN = 2,
    };
    // nested structs
    const CompactSchedConfigWire = struct {
        const ENABLED_WIRE: gremlin.ProtoWireNumber = 1;
    };
    pub const CompactSchedConfig = struct {
        // fields
        enabled: bool = false,
        pub fn calcProtobufSize(self: *const FtraceConfig.CompactSchedConfig) usize {
            var res: usize = 0;
            if (self.enabled != false) {
                res += gremlin.sizes.sizeWireNumber(FtraceConfig.CompactSchedConfigWire.ENABLED_WIRE) + gremlin.sizes.sizeBool(self.enabled);
            }
            return res;
        }
        pub fn encode(self: *const FtraceConfig.CompactSchedConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const FtraceConfig.CompactSchedConfig, target: *gremlin.Writer) void {
            if (self.enabled != false) {
                target.appendBool(FtraceConfig.CompactSchedConfigWire.ENABLED_WIRE, self.enabled);
            }
        }
    };
    pub const CompactSchedConfigReader = struct {
        buf: gremlin.Reader,
        _enabled: bool = false,
        pub fn init(src: []const u8) gremlin.Error!FtraceConfig.CompactSchedConfigReader {
            const buf = gremlin.Reader.init(src);
            var res = FtraceConfig.CompactSchedConfigReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    FtraceConfig.CompactSchedConfigWire.ENABLED_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._enabled = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getEnabled(self: *const FtraceConfig.CompactSchedConfigReader) bool {
            return self._enabled;
        }
    };
    const PrintFilterWire = struct {
        const RULES_WIRE: gremlin.ProtoWireNumber = 1;
    };
    pub const PrintFilter = struct {
        // nested structs
        const RuleWire = struct {
            const ALLOW_WIRE: gremlin.ProtoWireNumber = 2;
            const PREFIX_WIRE: gremlin.ProtoWireNumber = 1;
            const ATRACE_MSG_WIRE: gremlin.ProtoWireNumber = 3;
        };
        pub const Rule = struct {
            // nested structs
            const AtraceMessageWire = struct {
                const TYPE_WIRE: gremlin.ProtoWireNumber = 1;
                const PREFIX_WIRE: gremlin.ProtoWireNumber = 2;
            };
            pub const AtraceMessage = struct {
                // fields
                type: ?[]const u8 = null,
                prefix: ?[]const u8 = null,
                pub fn calcProtobufSize(self: *const FtraceConfig.PrintFilter.Rule.AtraceMessage) usize {
                    var res: usize = 0;
                    if (self.type) |v| {
                        if (v.len > 0) {
                            res += gremlin.sizes.sizeWireNumber(FtraceConfig.PrintFilter.Rule.AtraceMessageWire.TYPE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                        }
                    }
                    if (self.prefix) |v| {
                        if (v.len > 0) {
                            res += gremlin.sizes.sizeWireNumber(FtraceConfig.PrintFilter.Rule.AtraceMessageWire.PREFIX_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                        }
                    }
                    return res;
                }
                pub fn encode(self: *const FtraceConfig.PrintFilter.Rule.AtraceMessage, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                    const size = self.calcProtobufSize();
                    if (size == 0) {
                        return &[_]u8{};
                    }
                    const buf = try allocator.alloc(u8, self.calcProtobufSize());
                    var writer = gremlin.Writer.init(buf);
                    self.encodeTo(&writer);
                    return buf;
                }
                pub fn encodeTo(self: *const FtraceConfig.PrintFilter.Rule.AtraceMessage, target: *gremlin.Writer) void {
                    if (self.type) |v| {
                        if (v.len > 0) {
                            target.appendBytes(FtraceConfig.PrintFilter.Rule.AtraceMessageWire.TYPE_WIRE, v);
                        }
                    }
                    if (self.prefix) |v| {
                        if (v.len > 0) {
                            target.appendBytes(FtraceConfig.PrintFilter.Rule.AtraceMessageWire.PREFIX_WIRE, v);
                        }
                    }
                }
            };
            pub const AtraceMessageReader = struct {
                buf: gremlin.Reader,
                _type: ?[]const u8 = null,
                _prefix: ?[]const u8 = null,
                pub fn init(src: []const u8) gremlin.Error!FtraceConfig.PrintFilter.Rule.AtraceMessageReader {
                    const buf = gremlin.Reader.init(src);
                    var res = FtraceConfig.PrintFilter.Rule.AtraceMessageReader{ .buf = buf };
                    if (buf.buf.len == 0) {
                        return res;
                    }
                    var offset: usize = 0;
                    while (buf.hasNext(offset, 0)) {
                        const tag = try buf.readTagAt(offset);
                        offset += tag.size;
                        switch (tag.number) {
                            FtraceConfig.PrintFilter.Rule.AtraceMessageWire.TYPE_WIRE => {
                                const result = try buf.readBytes(offset);
                                offset += result.size;
                                res._type = result.value;
                            },
                            FtraceConfig.PrintFilter.Rule.AtraceMessageWire.PREFIX_WIRE => {
                                const result = try buf.readBytes(offset);
                                offset += result.size;
                                res._prefix = result.value;
                            },
                            else => {
                                offset = try buf.skipData(offset, tag.wire);
                            },
                        }
                    }
                    return res;
                }
                pub fn sourceBytes(self: *const @This()) []const u8 {
                    return self.buf.buf;
                }
                pub inline fn getType(self: *const FtraceConfig.PrintFilter.Rule.AtraceMessageReader) []const u8 {
                    return self._type orelse &[_]u8{};
                }
                pub inline fn getPrefix(self: *const FtraceConfig.PrintFilter.Rule.AtraceMessageReader) []const u8 {
                    return self._prefix orelse &[_]u8{};
                }
            };
            // fields
            allow: bool = false,
            prefix: ?[]const u8 = null,
            atrace_msg: ?FtraceConfig.PrintFilter.Rule.AtraceMessage = null,
            pub fn calcProtobufSize(self: *const FtraceConfig.PrintFilter.Rule) usize {
                var res: usize = 0;
                if (self.allow != false) {
                    res += gremlin.sizes.sizeWireNumber(FtraceConfig.PrintFilter.RuleWire.ALLOW_WIRE) + gremlin.sizes.sizeBool(self.allow);
                }
                if (self.prefix) |v| {
                    if (v.len > 0) {
                        res += gremlin.sizes.sizeWireNumber(FtraceConfig.PrintFilter.RuleWire.PREFIX_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                    }
                }
                if (self.atrace_msg) |v| {
                    const size = v.calcProtobufSize();
                    if (size > 0) {
                        res += gremlin.sizes.sizeWireNumber(FtraceConfig.PrintFilter.RuleWire.ATRACE_MSG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                    }
                }
                return res;
            }
            pub fn encode(self: *const FtraceConfig.PrintFilter.Rule, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const FtraceConfig.PrintFilter.Rule, target: *gremlin.Writer) void {
                if (self.allow != false) {
                    target.appendBool(FtraceConfig.PrintFilter.RuleWire.ALLOW_WIRE, self.allow);
                }
                if (self.prefix) |v| {
                    if (v.len > 0) {
                        target.appendBytes(FtraceConfig.PrintFilter.RuleWire.PREFIX_WIRE, v);
                    }
                }
                if (self.atrace_msg) |v| {
                    const size = v.calcProtobufSize();
                    if (size > 0) {
                        target.appendBytesTag(FtraceConfig.PrintFilter.RuleWire.ATRACE_MSG_WIRE, size);
                        v.encodeTo(target);
                    }
                }
            }
        };
        pub const RuleReader = struct {
            buf: gremlin.Reader,
            _allow: bool = false,
            _prefix: ?[]const u8 = null,
            _atrace_msg_buf: ?[]const u8 = null,
            pub fn init(src: []const u8) gremlin.Error!FtraceConfig.PrintFilter.RuleReader {
                const buf = gremlin.Reader.init(src);
                var res = FtraceConfig.PrintFilter.RuleReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        FtraceConfig.PrintFilter.RuleWire.ALLOW_WIRE => {
                            const result = try buf.readBool(offset);
                            offset += result.size;
                            res._allow = result.value;
                        },
                        FtraceConfig.PrintFilter.RuleWire.PREFIX_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._prefix = result.value;
                        },
                        FtraceConfig.PrintFilter.RuleWire.ATRACE_MSG_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._atrace_msg_buf = result.value;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub inline fn getAllow(self: *const FtraceConfig.PrintFilter.RuleReader) bool {
                return self._allow;
            }
            pub inline fn getPrefix(self: *const FtraceConfig.PrintFilter.RuleReader) []const u8 {
                return self._prefix orelse &[_]u8{};
            }
            pub fn getAtraceMsg(self: *const FtraceConfig.PrintFilter.RuleReader) gremlin.Error!FtraceConfig.PrintFilter.Rule.AtraceMessageReader {
                if (self._atrace_msg_buf) |buf| {
                    return try FtraceConfig.PrintFilter.Rule.AtraceMessageReader.init(buf);
                }
                return try FtraceConfig.PrintFilter.Rule.AtraceMessageReader.init(&[_]u8{});
            }
        };
        // fields
        rules: ?[]const ?FtraceConfig.PrintFilter.Rule = null,
        pub fn calcProtobufSize(self: *const FtraceConfig.PrintFilter) usize {
            var res: usize = 0;
            if (self.rules) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(FtraceConfig.PrintFilterWire.RULES_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const FtraceConfig.PrintFilter, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const FtraceConfig.PrintFilter, target: *gremlin.Writer) void {
            if (self.rules) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(FtraceConfig.PrintFilterWire.RULES_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(FtraceConfig.PrintFilterWire.RULES_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const PrintFilterReader = struct {
        buf: gremlin.Reader,
        _rules_offset: ?usize = null,
        _rules_last_offset: ?usize = null,
        _rules_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!FtraceConfig.PrintFilterReader {
            const buf = gremlin.Reader.init(src);
            var res = FtraceConfig.PrintFilterReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    FtraceConfig.PrintFilterWire.RULES_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._rules_offset == null) {
                            res._rules_offset = offset - result.size;
                        }
                        res._rules_last_offset = offset;
                        res._rules_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn rulesCount(self: *const FtraceConfig.PrintFilterReader) usize {
            return self._rules_cnt;
        }
        pub fn rulesNext(self: *FtraceConfig.PrintFilterReader) ?FtraceConfig.PrintFilter.RuleReader {
            if (self._rules_offset == null) return null;
            const current_offset = self._rules_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = FtraceConfig.PrintFilter.RuleReader.init(result.value) catch return null;
            if (self._rules_last_offset != null and current_offset >= self._rules_last_offset.?) {
                self._rules_offset = null;
                return msg;
            }
            if (self._rules_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._rules_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == FtraceConfig.PrintFilterWire.RULES_WIRE) {
                    self._rules_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._rules_offset = null;
            return msg;
        }
    };
    const KprobeEventWire = struct {
        const PROBE_WIRE: gremlin.ProtoWireNumber = 1;
        const TYPE_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const KprobeEvent = struct {
        // nested enums
        pub const KprobeType = enum(i32) {
            KPROBE_TYPE_UNKNOWN = 0,
            KPROBE_TYPE_KPROBE = 1,
            KPROBE_TYPE_KRETPROBE = 2,
            KPROBE_TYPE_BOTH = 3,
        };
        // fields
        probe: ?[]const u8 = null,
        type: FtraceConfig.KprobeEvent.KprobeType = @enumFromInt(0),
        pub fn calcProtobufSize(self: *const FtraceConfig.KprobeEvent) usize {
            var res: usize = 0;
            if (self.probe) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(FtraceConfig.KprobeEventWire.PROBE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (@intFromEnum(self.type) != 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceConfig.KprobeEventWire.TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.type));
            }
            return res;
        }
        pub fn encode(self: *const FtraceConfig.KprobeEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const FtraceConfig.KprobeEvent, target: *gremlin.Writer) void {
            if (self.probe) |v| {
                if (v.len > 0) {
                    target.appendBytes(FtraceConfig.KprobeEventWire.PROBE_WIRE, v);
                }
            }
            if (@intFromEnum(self.type) != 0) {
                target.appendInt32(FtraceConfig.KprobeEventWire.TYPE_WIRE, @intFromEnum(self.type));
            }
        }
    };
    pub const KprobeEventReader = struct {
        buf: gremlin.Reader,
        _probe: ?[]const u8 = null,
        _type: FtraceConfig.KprobeEvent.KprobeType = @enumFromInt(0),
        pub fn init(src: []const u8) gremlin.Error!FtraceConfig.KprobeEventReader {
            const buf = gremlin.Reader.init(src);
            var res = FtraceConfig.KprobeEventReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    FtraceConfig.KprobeEventWire.PROBE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._probe = result.value;
                    },
                    FtraceConfig.KprobeEventWire.TYPE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._type = @enumFromInt(result.value);
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getProbe(self: *const FtraceConfig.KprobeEventReader) []const u8 {
            return self._probe orelse &[_]u8{};
        }
        pub inline fn getType(self: *const FtraceConfig.KprobeEventReader) FtraceConfig.KprobeEvent.KprobeType {
            return self._type;
        }
    };
    const TracefsOptionWire = struct {
        const NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const STATE_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const TracefsOption = struct {
        // nested enums
        pub const State = enum(i32) {
            STATE_UNKNOWN = 0,
            STATE_ENABLED = 1,
            STATE_DISABLED = 2,
        };
        // fields
        name: ?[]const u8 = null,
        state: FtraceConfig.TracefsOption.State = @enumFromInt(0),
        pub fn calcProtobufSize(self: *const FtraceConfig.TracefsOption) usize {
            var res: usize = 0;
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(FtraceConfig.TracefsOptionWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (@intFromEnum(self.state) != 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceConfig.TracefsOptionWire.STATE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.state));
            }
            return res;
        }
        pub fn encode(self: *const FtraceConfig.TracefsOption, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const FtraceConfig.TracefsOption, target: *gremlin.Writer) void {
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(FtraceConfig.TracefsOptionWire.NAME_WIRE, v);
                }
            }
            if (@intFromEnum(self.state) != 0) {
                target.appendInt32(FtraceConfig.TracefsOptionWire.STATE_WIRE, @intFromEnum(self.state));
            }
        }
    };
    pub const TracefsOptionReader = struct {
        buf: gremlin.Reader,
        _name: ?[]const u8 = null,
        _state: FtraceConfig.TracefsOption.State = @enumFromInt(0),
        pub fn init(src: []const u8) gremlin.Error!FtraceConfig.TracefsOptionReader {
            const buf = gremlin.Reader.init(src);
            var res = FtraceConfig.TracefsOptionReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    FtraceConfig.TracefsOptionWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    FtraceConfig.TracefsOptionWire.STATE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._state = @enumFromInt(result.value);
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getName(self: *const FtraceConfig.TracefsOptionReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub inline fn getState(self: *const FtraceConfig.TracefsOptionReader) FtraceConfig.TracefsOption.State {
            return self._state;
        }
    };
    // fields
    ftrace_events: ?[]const ?[]const u8 = null,
    atrace_categories: ?[]const ?[]const u8 = null,
    atrace_apps: ?[]const ?[]const u8 = null,
    atrace_categories_prefer_sdk: ?[]const ?[]const u8 = null,
    atrace_userspace_only: bool = false,
    buffer_size_kb: u32 = 0,
    buffer_size_lower_bound: bool = false,
    drain_period_ms: u32 = 0,
    drain_buffer_percent: u32 = 0,
    compact_sched: ?FtraceConfig.CompactSchedConfig = null,
    print_filter: ?FtraceConfig.PrintFilter = null,
    symbolize_ksyms: bool = false,
    ksyms_mem_policy: FtraceConfig.KsymsMemPolicy = @enumFromInt(0),
    throttle_rss_stat: bool = false,
    denser_generic_event_encoding: bool = false,
    disable_generic_events: bool = false,
    syscall_events: ?[]const ?[]const u8 = null,
    enable_function_graph: bool = false,
    function_filters: ?[]const ?[]const u8 = null,
    function_graph_roots: ?[]const ?[]const u8 = null,
    function_graph_max_depth: u32 = 0,
    kprobe_events: ?[]const ?FtraceConfig.KprobeEvent = null,
    preserve_ftrace_buffer: bool = false,
    use_monotonic_raw_clock: bool = false,
    instance_name: ?[]const u8 = null,
    debug_ftrace_abi: bool = false,
    tids_to_trace: ?[]const u32 = null,
    tracefs_options: ?[]const ?FtraceConfig.TracefsOption = null,
    tracing_cpumask: ?[]const u8 = null,
    initialize_ksyms_synchronously_for_testing: bool = false,
    pub fn calcProtobufSize(self: *const FtraceConfig) usize {
        var res: usize = 0;
        if (self.ftrace_events) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.FTRACE_EVENTS_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.atrace_categories) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.ATRACE_CATEGORIES_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.atrace_apps) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.ATRACE_APPS_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.atrace_categories_prefer_sdk) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.ATRACE_CATEGORIES_PREFER_SDK_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.atrace_userspace_only != false) {
            res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.ATRACE_USERSPACE_ONLY_WIRE) + gremlin.sizes.sizeBool(self.atrace_userspace_only);
        }
        if (self.buffer_size_kb != 0) {
            res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.BUFFER_SIZE_KB_WIRE) + gremlin.sizes.sizeU32(self.buffer_size_kb);
        }
        if (self.buffer_size_lower_bound != false) {
            res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.BUFFER_SIZE_LOWER_BOUND_WIRE) + gremlin.sizes.sizeBool(self.buffer_size_lower_bound);
        }
        if (self.drain_period_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.DRAIN_PERIOD_MS_WIRE) + gremlin.sizes.sizeU32(self.drain_period_ms);
        }
        if (self.drain_buffer_percent != 0) {
            res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.DRAIN_BUFFER_PERCENT_WIRE) + gremlin.sizes.sizeU32(self.drain_buffer_percent);
        }
        if (self.compact_sched) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.COMPACT_SCHED_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.print_filter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.PRINT_FILTER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.symbolize_ksyms != false) {
            res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.SYMBOLIZE_KSYMS_WIRE) + gremlin.sizes.sizeBool(self.symbolize_ksyms);
        }
        if (@intFromEnum(self.ksyms_mem_policy) != 0) {
            res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.KSYMS_MEM_POLICY_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.ksyms_mem_policy));
        }
        if (self.throttle_rss_stat != false) {
            res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.THROTTLE_RSS_STAT_WIRE) + gremlin.sizes.sizeBool(self.throttle_rss_stat);
        }
        if (self.denser_generic_event_encoding != false) {
            res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.DENSER_GENERIC_EVENT_ENCODING_WIRE) + gremlin.sizes.sizeBool(self.denser_generic_event_encoding);
        }
        if (self.disable_generic_events != false) {
            res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.DISABLE_GENERIC_EVENTS_WIRE) + gremlin.sizes.sizeBool(self.disable_generic_events);
        }
        if (self.syscall_events) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.SYSCALL_EVENTS_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.enable_function_graph != false) {
            res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.ENABLE_FUNCTION_GRAPH_WIRE) + gremlin.sizes.sizeBool(self.enable_function_graph);
        }
        if (self.function_filters) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.FUNCTION_FILTERS_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.function_graph_roots) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.FUNCTION_GRAPH_ROOTS_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.function_graph_max_depth != 0) {
            res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.FUNCTION_GRAPH_MAX_DEPTH_WIRE) + gremlin.sizes.sizeU32(self.function_graph_max_depth);
        }
        if (self.kprobe_events) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.KPROBE_EVENTS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.preserve_ftrace_buffer != false) {
            res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.PRESERVE_FTRACE_BUFFER_WIRE) + gremlin.sizes.sizeBool(self.preserve_ftrace_buffer);
        }
        if (self.use_monotonic_raw_clock != false) {
            res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.USE_MONOTONIC_RAW_CLOCK_WIRE) + gremlin.sizes.sizeBool(self.use_monotonic_raw_clock);
        }
        if (self.instance_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.INSTANCE_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.debug_ftrace_abi != false) {
            res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.DEBUG_FTRACE_ABI_WIRE) + gremlin.sizes.sizeBool(self.debug_ftrace_abi);
        }
        if (self.tids_to_trace) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.TIDS_TO_TRACE_WIRE) + gremlin.sizes.sizeU32(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU32(v);
                }
                res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.TIDS_TO_TRACE_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.tracefs_options) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.TRACEFS_OPTIONS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.tracing_cpumask) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.TRACING_CPUMASK_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.initialize_ksyms_synchronously_for_testing != false) {
            res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.INITIALIZE_KSYMS_SYNCHRONOUSLY_FOR_TESTING_WIRE) + gremlin.sizes.sizeBool(self.initialize_ksyms_synchronously_for_testing);
        }
        return res;
    }
    pub fn encode(self: *const FtraceConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const FtraceConfig, target: *gremlin.Writer) void {
        if (self.ftrace_events) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(FtraceConfigWire.FTRACE_EVENTS_WIRE, v);
                } else {
                    target.appendBytesTag(FtraceConfigWire.FTRACE_EVENTS_WIRE, 0);
                }
            }
        }
        if (self.atrace_categories) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(FtraceConfigWire.ATRACE_CATEGORIES_WIRE, v);
                } else {
                    target.appendBytesTag(FtraceConfigWire.ATRACE_CATEGORIES_WIRE, 0);
                }
            }
        }
        if (self.atrace_apps) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(FtraceConfigWire.ATRACE_APPS_WIRE, v);
                } else {
                    target.appendBytesTag(FtraceConfigWire.ATRACE_APPS_WIRE, 0);
                }
            }
        }
        if (self.atrace_categories_prefer_sdk) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(FtraceConfigWire.ATRACE_CATEGORIES_PREFER_SDK_WIRE, v);
                } else {
                    target.appendBytesTag(FtraceConfigWire.ATRACE_CATEGORIES_PREFER_SDK_WIRE, 0);
                }
            }
        }
        if (self.atrace_userspace_only != false) {
            target.appendBool(FtraceConfigWire.ATRACE_USERSPACE_ONLY_WIRE, self.atrace_userspace_only);
        }
        if (self.buffer_size_kb != 0) {
            target.appendUint32(FtraceConfigWire.BUFFER_SIZE_KB_WIRE, self.buffer_size_kb);
        }
        if (self.buffer_size_lower_bound != false) {
            target.appendBool(FtraceConfigWire.BUFFER_SIZE_LOWER_BOUND_WIRE, self.buffer_size_lower_bound);
        }
        if (self.drain_period_ms != 0) {
            target.appendUint32(FtraceConfigWire.DRAIN_PERIOD_MS_WIRE, self.drain_period_ms);
        }
        if (self.drain_buffer_percent != 0) {
            target.appendUint32(FtraceConfigWire.DRAIN_BUFFER_PERCENT_WIRE, self.drain_buffer_percent);
        }
        if (self.compact_sched) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceConfigWire.COMPACT_SCHED_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.print_filter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceConfigWire.PRINT_FILTER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.symbolize_ksyms != false) {
            target.appendBool(FtraceConfigWire.SYMBOLIZE_KSYMS_WIRE, self.symbolize_ksyms);
        }
        if (@intFromEnum(self.ksyms_mem_policy) != 0) {
            target.appendInt32(FtraceConfigWire.KSYMS_MEM_POLICY_WIRE, @intFromEnum(self.ksyms_mem_policy));
        }
        if (self.throttle_rss_stat != false) {
            target.appendBool(FtraceConfigWire.THROTTLE_RSS_STAT_WIRE, self.throttle_rss_stat);
        }
        if (self.denser_generic_event_encoding != false) {
            target.appendBool(FtraceConfigWire.DENSER_GENERIC_EVENT_ENCODING_WIRE, self.denser_generic_event_encoding);
        }
        if (self.disable_generic_events != false) {
            target.appendBool(FtraceConfigWire.DISABLE_GENERIC_EVENTS_WIRE, self.disable_generic_events);
        }
        if (self.syscall_events) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(FtraceConfigWire.SYSCALL_EVENTS_WIRE, v);
                } else {
                    target.appendBytesTag(FtraceConfigWire.SYSCALL_EVENTS_WIRE, 0);
                }
            }
        }
        if (self.enable_function_graph != false) {
            target.appendBool(FtraceConfigWire.ENABLE_FUNCTION_GRAPH_WIRE, self.enable_function_graph);
        }
        if (self.function_filters) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(FtraceConfigWire.FUNCTION_FILTERS_WIRE, v);
                } else {
                    target.appendBytesTag(FtraceConfigWire.FUNCTION_FILTERS_WIRE, 0);
                }
            }
        }
        if (self.function_graph_roots) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(FtraceConfigWire.FUNCTION_GRAPH_ROOTS_WIRE, v);
                } else {
                    target.appendBytesTag(FtraceConfigWire.FUNCTION_GRAPH_ROOTS_WIRE, 0);
                }
            }
        }
        if (self.function_graph_max_depth != 0) {
            target.appendUint32(FtraceConfigWire.FUNCTION_GRAPH_MAX_DEPTH_WIRE, self.function_graph_max_depth);
        }
        if (self.kprobe_events) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(FtraceConfigWire.KPROBE_EVENTS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(FtraceConfigWire.KPROBE_EVENTS_WIRE, 0);
                }
            }
        }
        if (self.preserve_ftrace_buffer != false) {
            target.appendBool(FtraceConfigWire.PRESERVE_FTRACE_BUFFER_WIRE, self.preserve_ftrace_buffer);
        }
        if (self.use_monotonic_raw_clock != false) {
            target.appendBool(FtraceConfigWire.USE_MONOTONIC_RAW_CLOCK_WIRE, self.use_monotonic_raw_clock);
        }
        if (self.instance_name) |v| {
            if (v.len > 0) {
                target.appendBytes(FtraceConfigWire.INSTANCE_NAME_WIRE, v);
            }
        }
        if (self.debug_ftrace_abi != false) {
            target.appendBool(FtraceConfigWire.DEBUG_FTRACE_ABI_WIRE, self.debug_ftrace_abi);
        }
        if (self.tids_to_trace) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint32(FtraceConfigWire.TIDS_TO_TRACE_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU32(v);
                }
                target.appendBytesTag(FtraceConfigWire.TIDS_TO_TRACE_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint32WithoutTag(v);
                }
            }
        }
        if (self.tracefs_options) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(FtraceConfigWire.TRACEFS_OPTIONS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(FtraceConfigWire.TRACEFS_OPTIONS_WIRE, 0);
                }
            }
        }
        if (self.tracing_cpumask) |v| {
            if (v.len > 0) {
                target.appendBytes(FtraceConfigWire.TRACING_CPUMASK_WIRE, v);
            }
        }
        if (self.initialize_ksyms_synchronously_for_testing != false) {
            target.appendBool(FtraceConfigWire.INITIALIZE_KSYMS_SYNCHRONOUSLY_FOR_TESTING_WIRE, self.initialize_ksyms_synchronously_for_testing);
        }
    }
};
pub const FtraceConfigReader = struct {
    buf: gremlin.Reader,
    _ftrace_events_offset: ?usize = null,
    _ftrace_events_last_offset: ?usize = null,
    _ftrace_events_cnt: usize = 0,
    _atrace_categories_offset: ?usize = null,
    _atrace_categories_last_offset: ?usize = null,
    _atrace_categories_cnt: usize = 0,
    _atrace_apps_offset: ?usize = null,
    _atrace_apps_last_offset: ?usize = null,
    _atrace_apps_cnt: usize = 0,
    _atrace_categories_prefer_sdk_offset: ?usize = null,
    _atrace_categories_prefer_sdk_last_offset: ?usize = null,
    _atrace_categories_prefer_sdk_cnt: usize = 0,
    _atrace_userspace_only: bool = false,
    _buffer_size_kb: u32 = 0,
    _buffer_size_lower_bound: bool = false,
    _drain_period_ms: u32 = 0,
    _drain_buffer_percent: u32 = 0,
    _compact_sched_buf: ?[]const u8 = null,
    _print_filter_buf: ?[]const u8 = null,
    _symbolize_ksyms: bool = false,
    _ksyms_mem_policy: FtraceConfig.KsymsMemPolicy = @enumFromInt(0),
    _throttle_rss_stat: bool = false,
    _denser_generic_event_encoding: bool = false,
    _disable_generic_events: bool = false,
    _syscall_events_offset: ?usize = null,
    _syscall_events_last_offset: ?usize = null,
    _syscall_events_cnt: usize = 0,
    _enable_function_graph: bool = false,
    _function_filters_offset: ?usize = null,
    _function_filters_last_offset: ?usize = null,
    _function_filters_cnt: usize = 0,
    _function_graph_roots_offset: ?usize = null,
    _function_graph_roots_last_offset: ?usize = null,
    _function_graph_roots_cnt: usize = 0,
    _function_graph_max_depth: u32 = 0,
    _kprobe_events_offset: ?usize = null,
    _kprobe_events_last_offset: ?usize = null,
    _kprobe_events_cnt: usize = 0,
    _preserve_ftrace_buffer: bool = false,
    _use_monotonic_raw_clock: bool = false,
    _instance_name: ?[]const u8 = null,
    _debug_ftrace_abi: bool = false,
    _tids_to_trace_offset: ?usize = null,
    _tids_to_trace_last_offset: ?usize = null,
    _tids_to_trace_packed: bool = false,
    _tracefs_options_offset: ?usize = null,
    _tracefs_options_last_offset: ?usize = null,
    _tracefs_options_cnt: usize = 0,
    _tracing_cpumask: ?[]const u8 = null,
    _initialize_ksyms_synchronously_for_testing: bool = false,
    pub fn init(src: []const u8) gremlin.Error!FtraceConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = FtraceConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                FtraceConfigWire.FTRACE_EVENTS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._ftrace_events_offset == null) {
                        res._ftrace_events_offset = offset - result.size;
                    }
                    res._ftrace_events_last_offset = offset;
                    res._ftrace_events_cnt += 1;
                },
                FtraceConfigWire.ATRACE_CATEGORIES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._atrace_categories_offset == null) {
                        res._atrace_categories_offset = offset - result.size;
                    }
                    res._atrace_categories_last_offset = offset;
                    res._atrace_categories_cnt += 1;
                },
                FtraceConfigWire.ATRACE_APPS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._atrace_apps_offset == null) {
                        res._atrace_apps_offset = offset - result.size;
                    }
                    res._atrace_apps_last_offset = offset;
                    res._atrace_apps_cnt += 1;
                },
                FtraceConfigWire.ATRACE_CATEGORIES_PREFER_SDK_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._atrace_categories_prefer_sdk_offset == null) {
                        res._atrace_categories_prefer_sdk_offset = offset - result.size;
                    }
                    res._atrace_categories_prefer_sdk_last_offset = offset;
                    res._atrace_categories_prefer_sdk_cnt += 1;
                },
                FtraceConfigWire.ATRACE_USERSPACE_ONLY_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._atrace_userspace_only = result.value;
                },
                FtraceConfigWire.BUFFER_SIZE_KB_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._buffer_size_kb = result.value;
                },
                FtraceConfigWire.BUFFER_SIZE_LOWER_BOUND_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._buffer_size_lower_bound = result.value;
                },
                FtraceConfigWire.DRAIN_PERIOD_MS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._drain_period_ms = result.value;
                },
                FtraceConfigWire.DRAIN_BUFFER_PERCENT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._drain_buffer_percent = result.value;
                },
                FtraceConfigWire.COMPACT_SCHED_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._compact_sched_buf = result.value;
                },
                FtraceConfigWire.PRINT_FILTER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._print_filter_buf = result.value;
                },
                FtraceConfigWire.SYMBOLIZE_KSYMS_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._symbolize_ksyms = result.value;
                },
                FtraceConfigWire.KSYMS_MEM_POLICY_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._ksyms_mem_policy = @enumFromInt(result.value);
                },
                FtraceConfigWire.THROTTLE_RSS_STAT_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._throttle_rss_stat = result.value;
                },
                FtraceConfigWire.DENSER_GENERIC_EVENT_ENCODING_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._denser_generic_event_encoding = result.value;
                },
                FtraceConfigWire.DISABLE_GENERIC_EVENTS_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._disable_generic_events = result.value;
                },
                FtraceConfigWire.SYSCALL_EVENTS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._syscall_events_offset == null) {
                        res._syscall_events_offset = offset - result.size;
                    }
                    res._syscall_events_last_offset = offset;
                    res._syscall_events_cnt += 1;
                },
                FtraceConfigWire.ENABLE_FUNCTION_GRAPH_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._enable_function_graph = result.value;
                },
                FtraceConfigWire.FUNCTION_FILTERS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._function_filters_offset == null) {
                        res._function_filters_offset = offset - result.size;
                    }
                    res._function_filters_last_offset = offset;
                    res._function_filters_cnt += 1;
                },
                FtraceConfigWire.FUNCTION_GRAPH_ROOTS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._function_graph_roots_offset == null) {
                        res._function_graph_roots_offset = offset - result.size;
                    }
                    res._function_graph_roots_last_offset = offset;
                    res._function_graph_roots_cnt += 1;
                },
                FtraceConfigWire.FUNCTION_GRAPH_MAX_DEPTH_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._function_graph_max_depth = result.value;
                },
                FtraceConfigWire.KPROBE_EVENTS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._kprobe_events_offset == null) {
                        res._kprobe_events_offset = offset - result.size;
                    }
                    res._kprobe_events_last_offset = offset;
                    res._kprobe_events_cnt += 1;
                },
                FtraceConfigWire.PRESERVE_FTRACE_BUFFER_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._preserve_ftrace_buffer = result.value;
                },
                FtraceConfigWire.USE_MONOTONIC_RAW_CLOCK_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._use_monotonic_raw_clock = result.value;
                },
                FtraceConfigWire.INSTANCE_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._instance_name = result.value;
                },
                FtraceConfigWire.DEBUG_FTRACE_ABI_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._debug_ftrace_abi = result.value;
                },
                FtraceConfigWire.TIDS_TO_TRACE_WIRE => {
                    if (res._tids_to_trace_offset == null) {
                        res._tids_to_trace_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._tids_to_trace_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._tids_to_trace_offset = offset + length_result.size;
                        res._tids_to_trace_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._tids_to_trace_last_offset.?;
                    } else {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._tids_to_trace_last_offset = offset;
                    }
                },
                FtraceConfigWire.TRACEFS_OPTIONS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._tracefs_options_offset == null) {
                        res._tracefs_options_offset = offset - result.size;
                    }
                    res._tracefs_options_last_offset = offset;
                    res._tracefs_options_cnt += 1;
                },
                FtraceConfigWire.TRACING_CPUMASK_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._tracing_cpumask = result.value;
                },
                FtraceConfigWire.INITIALIZE_KSYMS_SYNCHRONOUSLY_FOR_TESTING_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._initialize_ksyms_synchronously_for_testing = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn ftraceEventsCount(self: *const FtraceConfigReader) usize {
        return self._ftrace_events_cnt;
    }
    pub fn ftraceEventsNext(self: *FtraceConfigReader) ?[]const u8 {
        if (self._ftrace_events_offset == null) return null;
        const current_offset = self._ftrace_events_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._ftrace_events_last_offset != null and current_offset >= self._ftrace_events_last_offset.?) {
            self._ftrace_events_offset = null;
            return result.value;
        }
        if (self._ftrace_events_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._ftrace_events_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == FtraceConfigWire.FTRACE_EVENTS_WIRE) {
                self._ftrace_events_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._ftrace_events_offset = null;
        return result.value;
    }
    pub fn atraceCategoriesCount(self: *const FtraceConfigReader) usize {
        return self._atrace_categories_cnt;
    }
    pub fn atraceCategoriesNext(self: *FtraceConfigReader) ?[]const u8 {
        if (self._atrace_categories_offset == null) return null;
        const current_offset = self._atrace_categories_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._atrace_categories_last_offset != null and current_offset >= self._atrace_categories_last_offset.?) {
            self._atrace_categories_offset = null;
            return result.value;
        }
        if (self._atrace_categories_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._atrace_categories_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == FtraceConfigWire.ATRACE_CATEGORIES_WIRE) {
                self._atrace_categories_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._atrace_categories_offset = null;
        return result.value;
    }
    pub fn atraceAppsCount(self: *const FtraceConfigReader) usize {
        return self._atrace_apps_cnt;
    }
    pub fn atraceAppsNext(self: *FtraceConfigReader) ?[]const u8 {
        if (self._atrace_apps_offset == null) return null;
        const current_offset = self._atrace_apps_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._atrace_apps_last_offset != null and current_offset >= self._atrace_apps_last_offset.?) {
            self._atrace_apps_offset = null;
            return result.value;
        }
        if (self._atrace_apps_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._atrace_apps_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == FtraceConfigWire.ATRACE_APPS_WIRE) {
                self._atrace_apps_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._atrace_apps_offset = null;
        return result.value;
    }
    pub fn atraceCategoriesPreferSdkCount(self: *const FtraceConfigReader) usize {
        return self._atrace_categories_prefer_sdk_cnt;
    }
    pub fn atraceCategoriesPreferSdkNext(self: *FtraceConfigReader) ?[]const u8 {
        if (self._atrace_categories_prefer_sdk_offset == null) return null;
        const current_offset = self._atrace_categories_prefer_sdk_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._atrace_categories_prefer_sdk_last_offset != null and current_offset >= self._atrace_categories_prefer_sdk_last_offset.?) {
            self._atrace_categories_prefer_sdk_offset = null;
            return result.value;
        }
        if (self._atrace_categories_prefer_sdk_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._atrace_categories_prefer_sdk_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == FtraceConfigWire.ATRACE_CATEGORIES_PREFER_SDK_WIRE) {
                self._atrace_categories_prefer_sdk_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._atrace_categories_prefer_sdk_offset = null;
        return result.value;
    }
    pub inline fn getAtraceUserspaceOnly(self: *const FtraceConfigReader) bool {
        return self._atrace_userspace_only;
    }
    pub inline fn getBufferSizeKb(self: *const FtraceConfigReader) u32 {
        return self._buffer_size_kb;
    }
    pub inline fn getBufferSizeLowerBound(self: *const FtraceConfigReader) bool {
        return self._buffer_size_lower_bound;
    }
    pub inline fn getDrainPeriodMs(self: *const FtraceConfigReader) u32 {
        return self._drain_period_ms;
    }
    pub inline fn getDrainBufferPercent(self: *const FtraceConfigReader) u32 {
        return self._drain_buffer_percent;
    }
    pub fn getCompactSched(self: *const FtraceConfigReader) gremlin.Error!FtraceConfig.CompactSchedConfigReader {
        if (self._compact_sched_buf) |buf| {
            return try FtraceConfig.CompactSchedConfigReader.init(buf);
        }
        return try FtraceConfig.CompactSchedConfigReader.init(&[_]u8{});
    }
    pub fn getPrintFilter(self: *const FtraceConfigReader) gremlin.Error!FtraceConfig.PrintFilterReader {
        if (self._print_filter_buf) |buf| {
            return try FtraceConfig.PrintFilterReader.init(buf);
        }
        return try FtraceConfig.PrintFilterReader.init(&[_]u8{});
    }
    pub inline fn getSymbolizeKsyms(self: *const FtraceConfigReader) bool {
        return self._symbolize_ksyms;
    }
    pub inline fn getKsymsMemPolicy(self: *const FtraceConfigReader) FtraceConfig.KsymsMemPolicy {
        return self._ksyms_mem_policy;
    }
    pub inline fn getThrottleRssStat(self: *const FtraceConfigReader) bool {
        return self._throttle_rss_stat;
    }
    pub inline fn getDenserGenericEventEncoding(self: *const FtraceConfigReader) bool {
        return self._denser_generic_event_encoding;
    }
    pub inline fn getDisableGenericEvents(self: *const FtraceConfigReader) bool {
        return self._disable_generic_events;
    }
    pub fn syscallEventsCount(self: *const FtraceConfigReader) usize {
        return self._syscall_events_cnt;
    }
    pub fn syscallEventsNext(self: *FtraceConfigReader) ?[]const u8 {
        if (self._syscall_events_offset == null) return null;
        const current_offset = self._syscall_events_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._syscall_events_last_offset != null and current_offset >= self._syscall_events_last_offset.?) {
            self._syscall_events_offset = null;
            return result.value;
        }
        if (self._syscall_events_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._syscall_events_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == FtraceConfigWire.SYSCALL_EVENTS_WIRE) {
                self._syscall_events_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._syscall_events_offset = null;
        return result.value;
    }
    pub inline fn getEnableFunctionGraph(self: *const FtraceConfigReader) bool {
        return self._enable_function_graph;
    }
    pub fn functionFiltersCount(self: *const FtraceConfigReader) usize {
        return self._function_filters_cnt;
    }
    pub fn functionFiltersNext(self: *FtraceConfigReader) ?[]const u8 {
        if (self._function_filters_offset == null) return null;
        const current_offset = self._function_filters_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._function_filters_last_offset != null and current_offset >= self._function_filters_last_offset.?) {
            self._function_filters_offset = null;
            return result.value;
        }
        if (self._function_filters_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._function_filters_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == FtraceConfigWire.FUNCTION_FILTERS_WIRE) {
                self._function_filters_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._function_filters_offset = null;
        return result.value;
    }
    pub fn functionGraphRootsCount(self: *const FtraceConfigReader) usize {
        return self._function_graph_roots_cnt;
    }
    pub fn functionGraphRootsNext(self: *FtraceConfigReader) ?[]const u8 {
        if (self._function_graph_roots_offset == null) return null;
        const current_offset = self._function_graph_roots_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._function_graph_roots_last_offset != null and current_offset >= self._function_graph_roots_last_offset.?) {
            self._function_graph_roots_offset = null;
            return result.value;
        }
        if (self._function_graph_roots_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._function_graph_roots_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == FtraceConfigWire.FUNCTION_GRAPH_ROOTS_WIRE) {
                self._function_graph_roots_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._function_graph_roots_offset = null;
        return result.value;
    }
    pub inline fn getFunctionGraphMaxDepth(self: *const FtraceConfigReader) u32 {
        return self._function_graph_max_depth;
    }
    pub fn kprobeEventsCount(self: *const FtraceConfigReader) usize {
        return self._kprobe_events_cnt;
    }
    pub fn kprobeEventsNext(self: *FtraceConfigReader) ?FtraceConfig.KprobeEventReader {
        if (self._kprobe_events_offset == null) return null;
        const current_offset = self._kprobe_events_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = FtraceConfig.KprobeEventReader.init(result.value) catch return null;
        if (self._kprobe_events_last_offset != null and current_offset >= self._kprobe_events_last_offset.?) {
            self._kprobe_events_offset = null;
            return msg;
        }
        if (self._kprobe_events_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._kprobe_events_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == FtraceConfigWire.KPROBE_EVENTS_WIRE) {
                self._kprobe_events_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._kprobe_events_offset = null;
        return msg;
    }
    pub inline fn getPreserveFtraceBuffer(self: *const FtraceConfigReader) bool {
        return self._preserve_ftrace_buffer;
    }
    pub inline fn getUseMonotonicRawClock(self: *const FtraceConfigReader) bool {
        return self._use_monotonic_raw_clock;
    }
    pub inline fn getInstanceName(self: *const FtraceConfigReader) []const u8 {
        return self._instance_name orelse &[_]u8{};
    }
    pub inline fn getDebugFtraceAbi(self: *const FtraceConfigReader) bool {
        return self._debug_ftrace_abi;
    }
    pub fn tidsToTraceNext(self: *FtraceConfigReader) gremlin.Error!?u32 {
        if (self._tids_to_trace_offset == null) return null;
        const current_offset = self._tids_to_trace_offset.?;
        if (current_offset >= self._tids_to_trace_last_offset.?) {
            self._tids_to_trace_offset = null;
            return null;
        }
        if (self._tids_to_trace_packed) {
            const value_result = try self.buf.readUInt32(current_offset);
            self._tids_to_trace_offset = current_offset + value_result.size;
            if (self._tids_to_trace_offset.? >= self._tids_to_trace_last_offset.?) {
                self._tids_to_trace_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._tids_to_trace_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == FtraceConfigWire.TIDS_TO_TRACE_WIRE) {
                    self._tids_to_trace_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._tids_to_trace_offset = null;
            return value_result.value;
        }
    }
    pub fn tracefsOptionsCount(self: *const FtraceConfigReader) usize {
        return self._tracefs_options_cnt;
    }
    pub fn tracefsOptionsNext(self: *FtraceConfigReader) ?FtraceConfig.TracefsOptionReader {
        if (self._tracefs_options_offset == null) return null;
        const current_offset = self._tracefs_options_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = FtraceConfig.TracefsOptionReader.init(result.value) catch return null;
        if (self._tracefs_options_last_offset != null and current_offset >= self._tracefs_options_last_offset.?) {
            self._tracefs_options_offset = null;
            return msg;
        }
        if (self._tracefs_options_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._tracefs_options_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == FtraceConfigWire.TRACEFS_OPTIONS_WIRE) {
                self._tracefs_options_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._tracefs_options_offset = null;
        return msg;
    }
    pub inline fn getTracingCpumask(self: *const FtraceConfigReader) []const u8 {
        return self._tracing_cpumask orelse &[_]u8{};
    }
    pub inline fn getInitializeKsymsSynchronouslyForTesting(self: *const FtraceConfigReader) bool {
        return self._initialize_ksyms_synchronously_for_testing;
    }
};
const GpuCounterConfigWire = struct {
    const COUNTER_PERIOD_NS_WIRE: gremlin.ProtoWireNumber = 1;
    const COUNTER_IDS_WIRE: gremlin.ProtoWireNumber = 2;
    const INSTRUMENTED_SAMPLING_WIRE: gremlin.ProtoWireNumber = 3;
    const FIX_GPU_CLOCK_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const GpuCounterConfig = struct {
    // fields
    counter_period_ns: u64 = 0,
    counter_ids: ?[]const u32 = null,
    instrumented_sampling: bool = false,
    fix_gpu_clock: bool = false,
    pub fn calcProtobufSize(self: *const GpuCounterConfig) usize {
        var res: usize = 0;
        if (self.counter_period_ns != 0) {
            res += gremlin.sizes.sizeWireNumber(GpuCounterConfigWire.COUNTER_PERIOD_NS_WIRE) + gremlin.sizes.sizeU64(self.counter_period_ns);
        }
        if (self.counter_ids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(GpuCounterConfigWire.COUNTER_IDS_WIRE) + gremlin.sizes.sizeU32(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU32(v);
                }
                res += gremlin.sizes.sizeWireNumber(GpuCounterConfigWire.COUNTER_IDS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.instrumented_sampling != false) {
            res += gremlin.sizes.sizeWireNumber(GpuCounterConfigWire.INSTRUMENTED_SAMPLING_WIRE) + gremlin.sizes.sizeBool(self.instrumented_sampling);
        }
        if (self.fix_gpu_clock != false) {
            res += gremlin.sizes.sizeWireNumber(GpuCounterConfigWire.FIX_GPU_CLOCK_WIRE) + gremlin.sizes.sizeBool(self.fix_gpu_clock);
        }
        return res;
    }
    pub fn encode(self: *const GpuCounterConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const GpuCounterConfig, target: *gremlin.Writer) void {
        if (self.counter_period_ns != 0) {
            target.appendUint64(GpuCounterConfigWire.COUNTER_PERIOD_NS_WIRE, self.counter_period_ns);
        }
        if (self.counter_ids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint32(GpuCounterConfigWire.COUNTER_IDS_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU32(v);
                }
                target.appendBytesTag(GpuCounterConfigWire.COUNTER_IDS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint32WithoutTag(v);
                }
            }
        }
        if (self.instrumented_sampling != false) {
            target.appendBool(GpuCounterConfigWire.INSTRUMENTED_SAMPLING_WIRE, self.instrumented_sampling);
        }
        if (self.fix_gpu_clock != false) {
            target.appendBool(GpuCounterConfigWire.FIX_GPU_CLOCK_WIRE, self.fix_gpu_clock);
        }
    }
};
pub const GpuCounterConfigReader = struct {
    buf: gremlin.Reader,
    _counter_period_ns: u64 = 0,
    _counter_ids_offset: ?usize = null,
    _counter_ids_last_offset: ?usize = null,
    _counter_ids_packed: bool = false,
    _instrumented_sampling: bool = false,
    _fix_gpu_clock: bool = false,
    pub fn init(src: []const u8) gremlin.Error!GpuCounterConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = GpuCounterConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                GpuCounterConfigWire.COUNTER_PERIOD_NS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._counter_period_ns = result.value;
                },
                GpuCounterConfigWire.COUNTER_IDS_WIRE => {
                    if (res._counter_ids_offset == null) {
                        res._counter_ids_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._counter_ids_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._counter_ids_offset = offset + length_result.size;
                        res._counter_ids_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._counter_ids_last_offset.?;
                    } else {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._counter_ids_last_offset = offset;
                    }
                },
                GpuCounterConfigWire.INSTRUMENTED_SAMPLING_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._instrumented_sampling = result.value;
                },
                GpuCounterConfigWire.FIX_GPU_CLOCK_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._fix_gpu_clock = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getCounterPeriodNs(self: *const GpuCounterConfigReader) u64 {
        return self._counter_period_ns;
    }
    pub fn counterIdsNext(self: *GpuCounterConfigReader) gremlin.Error!?u32 {
        if (self._counter_ids_offset == null) return null;
        const current_offset = self._counter_ids_offset.?;
        if (current_offset >= self._counter_ids_last_offset.?) {
            self._counter_ids_offset = null;
            return null;
        }
        if (self._counter_ids_packed) {
            const value_result = try self.buf.readUInt32(current_offset);
            self._counter_ids_offset = current_offset + value_result.size;
            if (self._counter_ids_offset.? >= self._counter_ids_last_offset.?) {
                self._counter_ids_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._counter_ids_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == GpuCounterConfigWire.COUNTER_IDS_WIRE) {
                    self._counter_ids_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._counter_ids_offset = null;
            return value_result.value;
        }
    }
    pub inline fn getInstrumentedSampling(self: *const GpuCounterConfigReader) bool {
        return self._instrumented_sampling;
    }
    pub inline fn getFixGpuClock(self: *const GpuCounterConfigReader) bool {
        return self._fix_gpu_clock;
    }
};
const GpuRenderStagesConfigWire = struct {
    const FULL_LOADSTORE_WIRE: gremlin.ProtoWireNumber = 1;
    const LOW_OVERHEAD_WIRE: gremlin.ProtoWireNumber = 2;
    const TRACE_METRICS_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const GpuRenderStagesConfig = struct {
    // fields
    full_loadstore: bool = false,
    low_overhead: bool = false,
    trace_metrics: ?[]const ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const GpuRenderStagesConfig) usize {
        var res: usize = 0;
        if (self.full_loadstore != false) {
            res += gremlin.sizes.sizeWireNumber(GpuRenderStagesConfigWire.FULL_LOADSTORE_WIRE) + gremlin.sizes.sizeBool(self.full_loadstore);
        }
        if (self.low_overhead != false) {
            res += gremlin.sizes.sizeWireNumber(GpuRenderStagesConfigWire.LOW_OVERHEAD_WIRE) + gremlin.sizes.sizeBool(self.low_overhead);
        }
        if (self.trace_metrics) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(GpuRenderStagesConfigWire.TRACE_METRICS_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const GpuRenderStagesConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const GpuRenderStagesConfig, target: *gremlin.Writer) void {
        if (self.full_loadstore != false) {
            target.appendBool(GpuRenderStagesConfigWire.FULL_LOADSTORE_WIRE, self.full_loadstore);
        }
        if (self.low_overhead != false) {
            target.appendBool(GpuRenderStagesConfigWire.LOW_OVERHEAD_WIRE, self.low_overhead);
        }
        if (self.trace_metrics) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(GpuRenderStagesConfigWire.TRACE_METRICS_WIRE, v);
                } else {
                    target.appendBytesTag(GpuRenderStagesConfigWire.TRACE_METRICS_WIRE, 0);
                }
            }
        }
    }
};
pub const GpuRenderStagesConfigReader = struct {
    buf: gremlin.Reader,
    _full_loadstore: bool = false,
    _low_overhead: bool = false,
    _trace_metrics_offset: ?usize = null,
    _trace_metrics_last_offset: ?usize = null,
    _trace_metrics_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!GpuRenderStagesConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = GpuRenderStagesConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                GpuRenderStagesConfigWire.FULL_LOADSTORE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._full_loadstore = result.value;
                },
                GpuRenderStagesConfigWire.LOW_OVERHEAD_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._low_overhead = result.value;
                },
                GpuRenderStagesConfigWire.TRACE_METRICS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._trace_metrics_offset == null) {
                        res._trace_metrics_offset = offset - result.size;
                    }
                    res._trace_metrics_last_offset = offset;
                    res._trace_metrics_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getFullLoadstore(self: *const GpuRenderStagesConfigReader) bool {
        return self._full_loadstore;
    }
    pub inline fn getLowOverhead(self: *const GpuRenderStagesConfigReader) bool {
        return self._low_overhead;
    }
    pub fn traceMetricsCount(self: *const GpuRenderStagesConfigReader) usize {
        return self._trace_metrics_cnt;
    }
    pub fn traceMetricsNext(self: *GpuRenderStagesConfigReader) ?[]const u8 {
        if (self._trace_metrics_offset == null) return null;
        const current_offset = self._trace_metrics_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._trace_metrics_last_offset != null and current_offset >= self._trace_metrics_last_offset.?) {
            self._trace_metrics_offset = null;
            return result.value;
        }
        if (self._trace_metrics_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._trace_metrics_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == GpuRenderStagesConfigWire.TRACE_METRICS_WIRE) {
                self._trace_metrics_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._trace_metrics_offset = null;
        return result.value;
    }
};
const VulkanMemoryConfigWire = struct {
    const TRACK_DRIVER_MEMORY_USAGE_WIRE: gremlin.ProtoWireNumber = 1;
    const TRACK_DEVICE_MEMORY_USAGE_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const VulkanMemoryConfig = struct {
    // fields
    track_driver_memory_usage: bool = false,
    track_device_memory_usage: bool = false,
    pub fn calcProtobufSize(self: *const VulkanMemoryConfig) usize {
        var res: usize = 0;
        if (self.track_driver_memory_usage != false) {
            res += gremlin.sizes.sizeWireNumber(VulkanMemoryConfigWire.TRACK_DRIVER_MEMORY_USAGE_WIRE) + gremlin.sizes.sizeBool(self.track_driver_memory_usage);
        }
        if (self.track_device_memory_usage != false) {
            res += gremlin.sizes.sizeWireNumber(VulkanMemoryConfigWire.TRACK_DEVICE_MEMORY_USAGE_WIRE) + gremlin.sizes.sizeBool(self.track_device_memory_usage);
        }
        return res;
    }
    pub fn encode(self: *const VulkanMemoryConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const VulkanMemoryConfig, target: *gremlin.Writer) void {
        if (self.track_driver_memory_usage != false) {
            target.appendBool(VulkanMemoryConfigWire.TRACK_DRIVER_MEMORY_USAGE_WIRE, self.track_driver_memory_usage);
        }
        if (self.track_device_memory_usage != false) {
            target.appendBool(VulkanMemoryConfigWire.TRACK_DEVICE_MEMORY_USAGE_WIRE, self.track_device_memory_usage);
        }
    }
};
pub const VulkanMemoryConfigReader = struct {
    buf: gremlin.Reader,
    _track_driver_memory_usage: bool = false,
    _track_device_memory_usage: bool = false,
    pub fn init(src: []const u8) gremlin.Error!VulkanMemoryConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = VulkanMemoryConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                VulkanMemoryConfigWire.TRACK_DRIVER_MEMORY_USAGE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._track_driver_memory_usage = result.value;
                },
                VulkanMemoryConfigWire.TRACK_DEVICE_MEMORY_USAGE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._track_device_memory_usage = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getTrackDriverMemoryUsage(self: *const VulkanMemoryConfigReader) bool {
        return self._track_driver_memory_usage;
    }
    pub inline fn getTrackDeviceMemoryUsage(self: *const VulkanMemoryConfigReader) bool {
        return self._track_device_memory_usage;
    }
};
const InodeFileConfigWire = struct {
    const SCAN_INTERVAL_MS_WIRE: gremlin.ProtoWireNumber = 1;
    const SCAN_DELAY_MS_WIRE: gremlin.ProtoWireNumber = 2;
    const SCAN_BATCH_SIZE_WIRE: gremlin.ProtoWireNumber = 3;
    const DO_NOT_SCAN_WIRE: gremlin.ProtoWireNumber = 4;
    const SCAN_MOUNT_POINTS_WIRE: gremlin.ProtoWireNumber = 5;
    const MOUNT_POINT_MAPPING_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const InodeFileConfig = struct {
    // nested structs
    const MountPointMappingEntryWire = struct {
        const MOUNTPOINT_WIRE: gremlin.ProtoWireNumber = 1;
        const SCAN_ROOTS_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const MountPointMappingEntry = struct {
        // fields
        mountpoint: ?[]const u8 = null,
        scan_roots: ?[]const ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const InodeFileConfig.MountPointMappingEntry) usize {
            var res: usize = 0;
            if (self.mountpoint) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(InodeFileConfig.MountPointMappingEntryWire.MOUNTPOINT_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.scan_roots) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(InodeFileConfig.MountPointMappingEntryWire.SCAN_ROOTS_WIRE);
                    if (maybe_v) |v| {
                        res += gremlin.sizes.sizeUsize(v.len) + v.len;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const InodeFileConfig.MountPointMappingEntry, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const InodeFileConfig.MountPointMappingEntry, target: *gremlin.Writer) void {
            if (self.mountpoint) |v| {
                if (v.len > 0) {
                    target.appendBytes(InodeFileConfig.MountPointMappingEntryWire.MOUNTPOINT_WIRE, v);
                }
            }
            if (self.scan_roots) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        target.appendBytes(InodeFileConfig.MountPointMappingEntryWire.SCAN_ROOTS_WIRE, v);
                    } else {
                        target.appendBytesTag(InodeFileConfig.MountPointMappingEntryWire.SCAN_ROOTS_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const MountPointMappingEntryReader = struct {
        buf: gremlin.Reader,
        _mountpoint: ?[]const u8 = null,
        _scan_roots_offset: ?usize = null,
        _scan_roots_last_offset: ?usize = null,
        _scan_roots_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!InodeFileConfig.MountPointMappingEntryReader {
            const buf = gremlin.Reader.init(src);
            var res = InodeFileConfig.MountPointMappingEntryReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    InodeFileConfig.MountPointMappingEntryWire.MOUNTPOINT_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._mountpoint = result.value;
                    },
                    InodeFileConfig.MountPointMappingEntryWire.SCAN_ROOTS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._scan_roots_offset == null) {
                            res._scan_roots_offset = offset - result.size;
                        }
                        res._scan_roots_last_offset = offset;
                        res._scan_roots_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getMountpoint(self: *const InodeFileConfig.MountPointMappingEntryReader) []const u8 {
            return self._mountpoint orelse &[_]u8{};
        }
        pub fn scanRootsCount(self: *const InodeFileConfig.MountPointMappingEntryReader) usize {
            return self._scan_roots_cnt;
        }
        pub fn scanRootsNext(self: *InodeFileConfig.MountPointMappingEntryReader) ?[]const u8 {
            if (self._scan_roots_offset == null) return null;
            const current_offset = self._scan_roots_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            if (self._scan_roots_last_offset != null and current_offset >= self._scan_roots_last_offset.?) {
                self._scan_roots_offset = null;
                return result.value;
            }
            if (self._scan_roots_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._scan_roots_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == InodeFileConfig.MountPointMappingEntryWire.SCAN_ROOTS_WIRE) {
                    self._scan_roots_offset = next_offset;
                    return result.value;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._scan_roots_offset = null;
            return result.value;
        }
    };
    // fields
    scan_interval_ms: u32 = 0,
    scan_delay_ms: u32 = 0,
    scan_batch_size: u32 = 0,
    do_not_scan: bool = false,
    scan_mount_points: ?[]const ?[]const u8 = null,
    mount_point_mapping: ?[]const ?InodeFileConfig.MountPointMappingEntry = null,
    pub fn calcProtobufSize(self: *const InodeFileConfig) usize {
        var res: usize = 0;
        if (self.scan_interval_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(InodeFileConfigWire.SCAN_INTERVAL_MS_WIRE) + gremlin.sizes.sizeU32(self.scan_interval_ms);
        }
        if (self.scan_delay_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(InodeFileConfigWire.SCAN_DELAY_MS_WIRE) + gremlin.sizes.sizeU32(self.scan_delay_ms);
        }
        if (self.scan_batch_size != 0) {
            res += gremlin.sizes.sizeWireNumber(InodeFileConfigWire.SCAN_BATCH_SIZE_WIRE) + gremlin.sizes.sizeU32(self.scan_batch_size);
        }
        if (self.do_not_scan != false) {
            res += gremlin.sizes.sizeWireNumber(InodeFileConfigWire.DO_NOT_SCAN_WIRE) + gremlin.sizes.sizeBool(self.do_not_scan);
        }
        if (self.scan_mount_points) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(InodeFileConfigWire.SCAN_MOUNT_POINTS_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.mount_point_mapping) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(InodeFileConfigWire.MOUNT_POINT_MAPPING_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const InodeFileConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const InodeFileConfig, target: *gremlin.Writer) void {
        if (self.scan_interval_ms != 0) {
            target.appendUint32(InodeFileConfigWire.SCAN_INTERVAL_MS_WIRE, self.scan_interval_ms);
        }
        if (self.scan_delay_ms != 0) {
            target.appendUint32(InodeFileConfigWire.SCAN_DELAY_MS_WIRE, self.scan_delay_ms);
        }
        if (self.scan_batch_size != 0) {
            target.appendUint32(InodeFileConfigWire.SCAN_BATCH_SIZE_WIRE, self.scan_batch_size);
        }
        if (self.do_not_scan != false) {
            target.appendBool(InodeFileConfigWire.DO_NOT_SCAN_WIRE, self.do_not_scan);
        }
        if (self.scan_mount_points) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(InodeFileConfigWire.SCAN_MOUNT_POINTS_WIRE, v);
                } else {
                    target.appendBytesTag(InodeFileConfigWire.SCAN_MOUNT_POINTS_WIRE, 0);
                }
            }
        }
        if (self.mount_point_mapping) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(InodeFileConfigWire.MOUNT_POINT_MAPPING_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(InodeFileConfigWire.MOUNT_POINT_MAPPING_WIRE, 0);
                }
            }
        }
    }
};
pub const InodeFileConfigReader = struct {
    buf: gremlin.Reader,
    _scan_interval_ms: u32 = 0,
    _scan_delay_ms: u32 = 0,
    _scan_batch_size: u32 = 0,
    _do_not_scan: bool = false,
    _scan_mount_points_offset: ?usize = null,
    _scan_mount_points_last_offset: ?usize = null,
    _scan_mount_points_cnt: usize = 0,
    _mount_point_mapping_offset: ?usize = null,
    _mount_point_mapping_last_offset: ?usize = null,
    _mount_point_mapping_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!InodeFileConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = InodeFileConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                InodeFileConfigWire.SCAN_INTERVAL_MS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._scan_interval_ms = result.value;
                },
                InodeFileConfigWire.SCAN_DELAY_MS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._scan_delay_ms = result.value;
                },
                InodeFileConfigWire.SCAN_BATCH_SIZE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._scan_batch_size = result.value;
                },
                InodeFileConfigWire.DO_NOT_SCAN_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._do_not_scan = result.value;
                },
                InodeFileConfigWire.SCAN_MOUNT_POINTS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._scan_mount_points_offset == null) {
                        res._scan_mount_points_offset = offset - result.size;
                    }
                    res._scan_mount_points_last_offset = offset;
                    res._scan_mount_points_cnt += 1;
                },
                InodeFileConfigWire.MOUNT_POINT_MAPPING_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._mount_point_mapping_offset == null) {
                        res._mount_point_mapping_offset = offset - result.size;
                    }
                    res._mount_point_mapping_last_offset = offset;
                    res._mount_point_mapping_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getScanIntervalMs(self: *const InodeFileConfigReader) u32 {
        return self._scan_interval_ms;
    }
    pub inline fn getScanDelayMs(self: *const InodeFileConfigReader) u32 {
        return self._scan_delay_ms;
    }
    pub inline fn getScanBatchSize(self: *const InodeFileConfigReader) u32 {
        return self._scan_batch_size;
    }
    pub inline fn getDoNotScan(self: *const InodeFileConfigReader) bool {
        return self._do_not_scan;
    }
    pub fn scanMountPointsCount(self: *const InodeFileConfigReader) usize {
        return self._scan_mount_points_cnt;
    }
    pub fn scanMountPointsNext(self: *InodeFileConfigReader) ?[]const u8 {
        if (self._scan_mount_points_offset == null) return null;
        const current_offset = self._scan_mount_points_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._scan_mount_points_last_offset != null and current_offset >= self._scan_mount_points_last_offset.?) {
            self._scan_mount_points_offset = null;
            return result.value;
        }
        if (self._scan_mount_points_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._scan_mount_points_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == InodeFileConfigWire.SCAN_MOUNT_POINTS_WIRE) {
                self._scan_mount_points_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._scan_mount_points_offset = null;
        return result.value;
    }
    pub fn mountPointMappingCount(self: *const InodeFileConfigReader) usize {
        return self._mount_point_mapping_cnt;
    }
    pub fn mountPointMappingNext(self: *InodeFileConfigReader) ?InodeFileConfig.MountPointMappingEntryReader {
        if (self._mount_point_mapping_offset == null) return null;
        const current_offset = self._mount_point_mapping_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = InodeFileConfig.MountPointMappingEntryReader.init(result.value) catch return null;
        if (self._mount_point_mapping_last_offset != null and current_offset >= self._mount_point_mapping_last_offset.?) {
            self._mount_point_mapping_offset = null;
            return msg;
        }
        if (self._mount_point_mapping_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._mount_point_mapping_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == InodeFileConfigWire.MOUNT_POINT_MAPPING_WIRE) {
                self._mount_point_mapping_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._mount_point_mapping_offset = null;
        return msg;
    }
};
const ConsoleConfigWire = struct {
    const OUTPUT_WIRE: gremlin.ProtoWireNumber = 1;
    const ENABLE_COLORS_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const ConsoleConfig = struct {
    // nested enums
    pub const Output = enum(i32) {
        OUTPUT_UNSPECIFIED = 0,
        OUTPUT_STDOUT = 1,
        OUTPUT_STDERR = 2,
    };
    // fields
    output: ConsoleConfig.Output = @enumFromInt(0),
    enable_colors: bool = false,
    pub fn calcProtobufSize(self: *const ConsoleConfig) usize {
        var res: usize = 0;
        if (@intFromEnum(self.output) != 0) {
            res += gremlin.sizes.sizeWireNumber(ConsoleConfigWire.OUTPUT_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.output));
        }
        if (self.enable_colors != false) {
            res += gremlin.sizes.sizeWireNumber(ConsoleConfigWire.ENABLE_COLORS_WIRE) + gremlin.sizes.sizeBool(self.enable_colors);
        }
        return res;
    }
    pub fn encode(self: *const ConsoleConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ConsoleConfig, target: *gremlin.Writer) void {
        if (@intFromEnum(self.output) != 0) {
            target.appendInt32(ConsoleConfigWire.OUTPUT_WIRE, @intFromEnum(self.output));
        }
        if (self.enable_colors != false) {
            target.appendBool(ConsoleConfigWire.ENABLE_COLORS_WIRE, self.enable_colors);
        }
    }
};
pub const ConsoleConfigReader = struct {
    buf: gremlin.Reader,
    _output: ConsoleConfig.Output = @enumFromInt(0),
    _enable_colors: bool = false,
    pub fn init(src: []const u8) gremlin.Error!ConsoleConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = ConsoleConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ConsoleConfigWire.OUTPUT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._output = @enumFromInt(result.value);
                },
                ConsoleConfigWire.ENABLE_COLORS_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._enable_colors = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getOutput(self: *const ConsoleConfigReader) ConsoleConfig.Output {
        return self._output;
    }
    pub inline fn getEnableColors(self: *const ConsoleConfigReader) bool {
        return self._enable_colors;
    }
};
const InterceptorConfigWire = struct {
    const NAME_WIRE: gremlin.ProtoWireNumber = 1;
    const CONSOLE_CONFIG_WIRE: gremlin.ProtoWireNumber = 100;
};
pub const InterceptorConfig = struct {
    // fields
    name: ?[]const u8 = null,
    console_config: ?ConsoleConfig = null,
    pub fn calcProtobufSize(self: *const InterceptorConfig) usize {
        var res: usize = 0;
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(InterceptorConfigWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.console_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(InterceptorConfigWire.CONSOLE_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const InterceptorConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const InterceptorConfig, target: *gremlin.Writer) void {
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(InterceptorConfigWire.NAME_WIRE, v);
            }
        }
        if (self.console_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(InterceptorConfigWire.CONSOLE_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const InterceptorConfigReader = struct {
    buf: gremlin.Reader,
    _name: ?[]const u8 = null,
    _console_config_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!InterceptorConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = InterceptorConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                InterceptorConfigWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                InterceptorConfigWire.CONSOLE_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._console_config_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getName(self: *const InterceptorConfigReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub fn getConsoleConfig(self: *const InterceptorConfigReader) gremlin.Error!ConsoleConfigReader {
        if (self._console_config_buf) |buf| {
            return try ConsoleConfigReader.init(buf);
        }
        return try ConsoleConfigReader.init(&[_]u8{});
    }
};
const AndroidPowerConfigWire = struct {
    const BATTERY_POLL_MS_WIRE: gremlin.ProtoWireNumber = 1;
    const BATTERY_COUNTERS_WIRE: gremlin.ProtoWireNumber = 2;
    const COLLECT_POWER_RAILS_WIRE: gremlin.ProtoWireNumber = 3;
    const COLLECT_ENERGY_ESTIMATION_BREAKDOWN_WIRE: gremlin.ProtoWireNumber = 4;
    const COLLECT_ENTITY_STATE_RESIDENCY_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const AndroidPowerConfig = struct {
    // nested enums
    pub const BatteryCounters = enum(i32) {
        BATTERY_COUNTER_UNSPECIFIED = 0,
        BATTERY_COUNTER_CHARGE = 1,
        BATTERY_COUNTER_CAPACITY_PERCENT = 2,
        BATTERY_COUNTER_CURRENT = 3,
        BATTERY_COUNTER_CURRENT_AVG = 4,
        BATTERY_COUNTER_VOLTAGE = 5,
    };
    // fields
    battery_poll_ms: u32 = 0,
    battery_counters: ?[]const AndroidPowerConfig.BatteryCounters = null,
    collect_power_rails: bool = false,
    collect_energy_estimation_breakdown: bool = false,
    collect_entity_state_residency: bool = false,
    pub fn calcProtobufSize(self: *const AndroidPowerConfig) usize {
        var res: usize = 0;
        if (self.battery_poll_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(AndroidPowerConfigWire.BATTERY_POLL_MS_WIRE) + gremlin.sizes.sizeU32(self.battery_poll_ms);
        }
        if (self.battery_counters) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(AndroidPowerConfigWire.BATTERY_COUNTERS_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(arr[0]));
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(@intFromEnum(v));
                }
                res += gremlin.sizes.sizeWireNumber(AndroidPowerConfigWire.BATTERY_COUNTERS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.collect_power_rails != false) {
            res += gremlin.sizes.sizeWireNumber(AndroidPowerConfigWire.COLLECT_POWER_RAILS_WIRE) + gremlin.sizes.sizeBool(self.collect_power_rails);
        }
        if (self.collect_energy_estimation_breakdown != false) {
            res += gremlin.sizes.sizeWireNumber(AndroidPowerConfigWire.COLLECT_ENERGY_ESTIMATION_BREAKDOWN_WIRE) + gremlin.sizes.sizeBool(self.collect_energy_estimation_breakdown);
        }
        if (self.collect_entity_state_residency != false) {
            res += gremlin.sizes.sizeWireNumber(AndroidPowerConfigWire.COLLECT_ENTITY_STATE_RESIDENCY_WIRE) + gremlin.sizes.sizeBool(self.collect_entity_state_residency);
        }
        return res;
    }
    pub fn encode(self: *const AndroidPowerConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AndroidPowerConfig, target: *gremlin.Writer) void {
        if (self.battery_poll_ms != 0) {
            target.appendUint32(AndroidPowerConfigWire.BATTERY_POLL_MS_WIRE, self.battery_poll_ms);
        }
        if (self.battery_counters) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt32(AndroidPowerConfigWire.BATTERY_COUNTERS_WIRE, @intFromEnum(arr[0]));
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(@intFromEnum(v));
                }
                target.appendBytesTag(AndroidPowerConfigWire.BATTERY_COUNTERS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt32WithoutTag(@intFromEnum(v));
                }
            }
        }
        if (self.collect_power_rails != false) {
            target.appendBool(AndroidPowerConfigWire.COLLECT_POWER_RAILS_WIRE, self.collect_power_rails);
        }
        if (self.collect_energy_estimation_breakdown != false) {
            target.appendBool(AndroidPowerConfigWire.COLLECT_ENERGY_ESTIMATION_BREAKDOWN_WIRE, self.collect_energy_estimation_breakdown);
        }
        if (self.collect_entity_state_residency != false) {
            target.appendBool(AndroidPowerConfigWire.COLLECT_ENTITY_STATE_RESIDENCY_WIRE, self.collect_entity_state_residency);
        }
    }
};
pub const AndroidPowerConfigReader = struct {
    buf: gremlin.Reader,
    _battery_poll_ms: u32 = 0,
    _battery_counters_offset: ?usize = null,
    _battery_counters_last_offset: ?usize = null,
    _battery_counters_packed: bool = false,
    _collect_power_rails: bool = false,
    _collect_energy_estimation_breakdown: bool = false,
    _collect_entity_state_residency: bool = false,
    pub fn init(src: []const u8) gremlin.Error!AndroidPowerConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = AndroidPowerConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AndroidPowerConfigWire.BATTERY_POLL_MS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._battery_poll_ms = result.value;
                },
                AndroidPowerConfigWire.BATTERY_COUNTERS_WIRE => {
                    if (res._battery_counters_offset == null) {
                        res._battery_counters_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._battery_counters_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._battery_counters_offset = offset + length_result.size;
                        res._battery_counters_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._battery_counters_last_offset.?;
                    } else {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._battery_counters_last_offset = offset;
                    }
                },
                AndroidPowerConfigWire.COLLECT_POWER_RAILS_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._collect_power_rails = result.value;
                },
                AndroidPowerConfigWire.COLLECT_ENERGY_ESTIMATION_BREAKDOWN_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._collect_energy_estimation_breakdown = result.value;
                },
                AndroidPowerConfigWire.COLLECT_ENTITY_STATE_RESIDENCY_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._collect_entity_state_residency = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getBatteryPollMs(self: *const AndroidPowerConfigReader) u32 {
        return self._battery_poll_ms;
    }
    pub fn batteryCountersNext(self: *AndroidPowerConfigReader) gremlin.Error!?AndroidPowerConfig.BatteryCounters {
        if (self._battery_counters_offset == null) return null;
        const current_offset = self._battery_counters_offset.?;
        if (current_offset >= self._battery_counters_last_offset.?) {
            self._battery_counters_offset = null;
            return null;
        }
        if (self._battery_counters_packed) {
            const value_result = try self.buf.readInt32(current_offset);
            self._battery_counters_offset = current_offset + value_result.size;
            if (self._battery_counters_offset.? >= self._battery_counters_last_offset.?) {
                self._battery_counters_offset = null;
            }
            return @enumFromInt(value_result.value);
        } else {
            const value_result = try self.buf.readInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._battery_counters_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == AndroidPowerConfigWire.BATTERY_COUNTERS_WIRE) {
                    self._battery_counters_offset = next_offset;
                    return @enumFromInt(value_result.value);
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._battery_counters_offset = null;
            return @enumFromInt(value_result.value);
        }
    }
    pub inline fn getCollectPowerRails(self: *const AndroidPowerConfigReader) bool {
        return self._collect_power_rails;
    }
    pub inline fn getCollectEnergyEstimationBreakdown(self: *const AndroidPowerConfigReader) bool {
        return self._collect_energy_estimation_breakdown;
    }
    pub inline fn getCollectEntityStateResidency(self: *const AndroidPowerConfigReader) bool {
        return self._collect_entity_state_residency;
    }
};
const PriorityBoostConfigWire = struct {
    const POLICY_WIRE: gremlin.ProtoWireNumber = 1;
    const PRIORITY_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const PriorityBoostConfig = struct {
    // nested enums
    pub const BoostPolicy = enum(i32) {
        POLICY_UNSPECIFIED = 0,
        POLICY_SCHED_OTHER = 1,
        POLICY_SCHED_FIFO = 2,
    };
    // fields
    policy: PriorityBoostConfig.BoostPolicy = @enumFromInt(0),
    priority: u32 = 0,
    pub fn calcProtobufSize(self: *const PriorityBoostConfig) usize {
        var res: usize = 0;
        if (@intFromEnum(self.policy) != 0) {
            res += gremlin.sizes.sizeWireNumber(PriorityBoostConfigWire.POLICY_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.policy));
        }
        if (self.priority != 0) {
            res += gremlin.sizes.sizeWireNumber(PriorityBoostConfigWire.PRIORITY_WIRE) + gremlin.sizes.sizeU32(self.priority);
        }
        return res;
    }
    pub fn encode(self: *const PriorityBoostConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const PriorityBoostConfig, target: *gremlin.Writer) void {
        if (@intFromEnum(self.policy) != 0) {
            target.appendInt32(PriorityBoostConfigWire.POLICY_WIRE, @intFromEnum(self.policy));
        }
        if (self.priority != 0) {
            target.appendUint32(PriorityBoostConfigWire.PRIORITY_WIRE, self.priority);
        }
    }
};
pub const PriorityBoostConfigReader = struct {
    buf: gremlin.Reader,
    _policy: PriorityBoostConfig.BoostPolicy = @enumFromInt(0),
    _priority: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!PriorityBoostConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = PriorityBoostConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                PriorityBoostConfigWire.POLICY_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._policy = @enumFromInt(result.value);
                },
                PriorityBoostConfigWire.PRIORITY_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._priority = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getPolicy(self: *const PriorityBoostConfigReader) PriorityBoostConfig.BoostPolicy {
        return self._policy;
    }
    pub inline fn getPriority(self: *const PriorityBoostConfigReader) u32 {
        return self._priority;
    }
};
const ProcessStatsConfigWire = struct {
    const QUIRKS_WIRE: gremlin.ProtoWireNumber = 1;
    const SCAN_ALL_PROCESSES_ON_START_WIRE: gremlin.ProtoWireNumber = 2;
    const RECORD_THREAD_NAMES_WIRE: gremlin.ProtoWireNumber = 3;
    const PROC_STATS_POLL_MS_WIRE: gremlin.ProtoWireNumber = 4;
    const PROC_STATS_CACHE_TTL_MS_WIRE: gremlin.ProtoWireNumber = 6;
    const SCAN_SMAPS_ROLLUP_WIRE: gremlin.ProtoWireNumber = 10;
    const RECORD_PROCESS_AGE_WIRE: gremlin.ProtoWireNumber = 11;
    const RECORD_PROCESS_RUNTIME_WIRE: gremlin.ProtoWireNumber = 12;
    const RECORD_PROCESS_DMABUF_RSS_WIRE: gremlin.ProtoWireNumber = 13;
    const RESOLVE_PROCESS_FDS_WIRE: gremlin.ProtoWireNumber = 9;
};
pub const ProcessStatsConfig = struct {
    // nested enums
    pub const Quirks = enum(i32) {
        QUIRKS_UNSPECIFIED = 0,
        DISABLE_INITIAL_DUMP = 1,
        DISABLE_ON_DEMAND = 2,
    };
    // fields
    quirks: ?[]const ProcessStatsConfig.Quirks = null,
    scan_all_processes_on_start: bool = false,
    record_thread_names: bool = false,
    proc_stats_poll_ms: u32 = 0,
    proc_stats_cache_ttl_ms: u32 = 0,
    scan_smaps_rollup: bool = false,
    record_process_age: bool = false,
    record_process_runtime: bool = false,
    record_process_dmabuf_rss: bool = false,
    resolve_process_fds: bool = false,
    pub fn calcProtobufSize(self: *const ProcessStatsConfig) usize {
        var res: usize = 0;
        if (self.quirks) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(ProcessStatsConfigWire.QUIRKS_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(arr[0]));
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(@intFromEnum(v));
                }
                res += gremlin.sizes.sizeWireNumber(ProcessStatsConfigWire.QUIRKS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.scan_all_processes_on_start != false) {
            res += gremlin.sizes.sizeWireNumber(ProcessStatsConfigWire.SCAN_ALL_PROCESSES_ON_START_WIRE) + gremlin.sizes.sizeBool(self.scan_all_processes_on_start);
        }
        if (self.record_thread_names != false) {
            res += gremlin.sizes.sizeWireNumber(ProcessStatsConfigWire.RECORD_THREAD_NAMES_WIRE) + gremlin.sizes.sizeBool(self.record_thread_names);
        }
        if (self.proc_stats_poll_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(ProcessStatsConfigWire.PROC_STATS_POLL_MS_WIRE) + gremlin.sizes.sizeU32(self.proc_stats_poll_ms);
        }
        if (self.proc_stats_cache_ttl_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(ProcessStatsConfigWire.PROC_STATS_CACHE_TTL_MS_WIRE) + gremlin.sizes.sizeU32(self.proc_stats_cache_ttl_ms);
        }
        if (self.scan_smaps_rollup != false) {
            res += gremlin.sizes.sizeWireNumber(ProcessStatsConfigWire.SCAN_SMAPS_ROLLUP_WIRE) + gremlin.sizes.sizeBool(self.scan_smaps_rollup);
        }
        if (self.record_process_age != false) {
            res += gremlin.sizes.sizeWireNumber(ProcessStatsConfigWire.RECORD_PROCESS_AGE_WIRE) + gremlin.sizes.sizeBool(self.record_process_age);
        }
        if (self.record_process_runtime != false) {
            res += gremlin.sizes.sizeWireNumber(ProcessStatsConfigWire.RECORD_PROCESS_RUNTIME_WIRE) + gremlin.sizes.sizeBool(self.record_process_runtime);
        }
        if (self.record_process_dmabuf_rss != false) {
            res += gremlin.sizes.sizeWireNumber(ProcessStatsConfigWire.RECORD_PROCESS_DMABUF_RSS_WIRE) + gremlin.sizes.sizeBool(self.record_process_dmabuf_rss);
        }
        if (self.resolve_process_fds != false) {
            res += gremlin.sizes.sizeWireNumber(ProcessStatsConfigWire.RESOLVE_PROCESS_FDS_WIRE) + gremlin.sizes.sizeBool(self.resolve_process_fds);
        }
        return res;
    }
    pub fn encode(self: *const ProcessStatsConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ProcessStatsConfig, target: *gremlin.Writer) void {
        if (self.quirks) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt32(ProcessStatsConfigWire.QUIRKS_WIRE, @intFromEnum(arr[0]));
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(@intFromEnum(v));
                }
                target.appendBytesTag(ProcessStatsConfigWire.QUIRKS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt32WithoutTag(@intFromEnum(v));
                }
            }
        }
        if (self.scan_all_processes_on_start != false) {
            target.appendBool(ProcessStatsConfigWire.SCAN_ALL_PROCESSES_ON_START_WIRE, self.scan_all_processes_on_start);
        }
        if (self.record_thread_names != false) {
            target.appendBool(ProcessStatsConfigWire.RECORD_THREAD_NAMES_WIRE, self.record_thread_names);
        }
        if (self.proc_stats_poll_ms != 0) {
            target.appendUint32(ProcessStatsConfigWire.PROC_STATS_POLL_MS_WIRE, self.proc_stats_poll_ms);
        }
        if (self.proc_stats_cache_ttl_ms != 0) {
            target.appendUint32(ProcessStatsConfigWire.PROC_STATS_CACHE_TTL_MS_WIRE, self.proc_stats_cache_ttl_ms);
        }
        if (self.scan_smaps_rollup != false) {
            target.appendBool(ProcessStatsConfigWire.SCAN_SMAPS_ROLLUP_WIRE, self.scan_smaps_rollup);
        }
        if (self.record_process_age != false) {
            target.appendBool(ProcessStatsConfigWire.RECORD_PROCESS_AGE_WIRE, self.record_process_age);
        }
        if (self.record_process_runtime != false) {
            target.appendBool(ProcessStatsConfigWire.RECORD_PROCESS_RUNTIME_WIRE, self.record_process_runtime);
        }
        if (self.record_process_dmabuf_rss != false) {
            target.appendBool(ProcessStatsConfigWire.RECORD_PROCESS_DMABUF_RSS_WIRE, self.record_process_dmabuf_rss);
        }
        if (self.resolve_process_fds != false) {
            target.appendBool(ProcessStatsConfigWire.RESOLVE_PROCESS_FDS_WIRE, self.resolve_process_fds);
        }
    }
};
pub const ProcessStatsConfigReader = struct {
    buf: gremlin.Reader,
    _quirks_offset: ?usize = null,
    _quirks_last_offset: ?usize = null,
    _quirks_packed: bool = false,
    _scan_all_processes_on_start: bool = false,
    _record_thread_names: bool = false,
    _proc_stats_poll_ms: u32 = 0,
    _proc_stats_cache_ttl_ms: u32 = 0,
    _scan_smaps_rollup: bool = false,
    _record_process_age: bool = false,
    _record_process_runtime: bool = false,
    _record_process_dmabuf_rss: bool = false,
    _resolve_process_fds: bool = false,
    pub fn init(src: []const u8) gremlin.Error!ProcessStatsConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = ProcessStatsConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ProcessStatsConfigWire.QUIRKS_WIRE => {
                    if (res._quirks_offset == null) {
                        res._quirks_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._quirks_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._quirks_offset = offset + length_result.size;
                        res._quirks_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._quirks_last_offset.?;
                    } else {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._quirks_last_offset = offset;
                    }
                },
                ProcessStatsConfigWire.SCAN_ALL_PROCESSES_ON_START_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._scan_all_processes_on_start = result.value;
                },
                ProcessStatsConfigWire.RECORD_THREAD_NAMES_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._record_thread_names = result.value;
                },
                ProcessStatsConfigWire.PROC_STATS_POLL_MS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._proc_stats_poll_ms = result.value;
                },
                ProcessStatsConfigWire.PROC_STATS_CACHE_TTL_MS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._proc_stats_cache_ttl_ms = result.value;
                },
                ProcessStatsConfigWire.SCAN_SMAPS_ROLLUP_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._scan_smaps_rollup = result.value;
                },
                ProcessStatsConfigWire.RECORD_PROCESS_AGE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._record_process_age = result.value;
                },
                ProcessStatsConfigWire.RECORD_PROCESS_RUNTIME_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._record_process_runtime = result.value;
                },
                ProcessStatsConfigWire.RECORD_PROCESS_DMABUF_RSS_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._record_process_dmabuf_rss = result.value;
                },
                ProcessStatsConfigWire.RESOLVE_PROCESS_FDS_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._resolve_process_fds = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn quirksNext(self: *ProcessStatsConfigReader) gremlin.Error!?ProcessStatsConfig.Quirks {
        if (self._quirks_offset == null) return null;
        const current_offset = self._quirks_offset.?;
        if (current_offset >= self._quirks_last_offset.?) {
            self._quirks_offset = null;
            return null;
        }
        if (self._quirks_packed) {
            const value_result = try self.buf.readInt32(current_offset);
            self._quirks_offset = current_offset + value_result.size;
            if (self._quirks_offset.? >= self._quirks_last_offset.?) {
                self._quirks_offset = null;
            }
            return @enumFromInt(value_result.value);
        } else {
            const value_result = try self.buf.readInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._quirks_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == ProcessStatsConfigWire.QUIRKS_WIRE) {
                    self._quirks_offset = next_offset;
                    return @enumFromInt(value_result.value);
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._quirks_offset = null;
            return @enumFromInt(value_result.value);
        }
    }
    pub inline fn getScanAllProcessesOnStart(self: *const ProcessStatsConfigReader) bool {
        return self._scan_all_processes_on_start;
    }
    pub inline fn getRecordThreadNames(self: *const ProcessStatsConfigReader) bool {
        return self._record_thread_names;
    }
    pub inline fn getProcStatsPollMs(self: *const ProcessStatsConfigReader) u32 {
        return self._proc_stats_poll_ms;
    }
    pub inline fn getProcStatsCacheTtlMs(self: *const ProcessStatsConfigReader) u32 {
        return self._proc_stats_cache_ttl_ms;
    }
    pub inline fn getScanSmapsRollup(self: *const ProcessStatsConfigReader) bool {
        return self._scan_smaps_rollup;
    }
    pub inline fn getRecordProcessAge(self: *const ProcessStatsConfigReader) bool {
        return self._record_process_age;
    }
    pub inline fn getRecordProcessRuntime(self: *const ProcessStatsConfigReader) bool {
        return self._record_process_runtime;
    }
    pub inline fn getRecordProcessDmabufRss(self: *const ProcessStatsConfigReader) bool {
        return self._record_process_dmabuf_rss;
    }
    pub inline fn getResolveProcessFds(self: *const ProcessStatsConfigReader) bool {
        return self._resolve_process_fds;
    }
};
const HeapprofdConfigWire = struct {
    const SAMPLING_INTERVAL_BYTES_WIRE: gremlin.ProtoWireNumber = 1;
    const ADAPTIVE_SAMPLING_SHMEM_THRESHOLD_WIRE: gremlin.ProtoWireNumber = 24;
    const ADAPTIVE_SAMPLING_MAX_SAMPLING_INTERVAL_BYTES_WIRE: gremlin.ProtoWireNumber = 25;
    const PROCESS_CMDLINE_WIRE: gremlin.ProtoWireNumber = 2;
    const PID_WIRE: gremlin.ProtoWireNumber = 4;
    const TARGET_INSTALLED_BY_WIRE: gremlin.ProtoWireNumber = 26;
    const HEAPS_WIRE: gremlin.ProtoWireNumber = 20;
    const EXCLUDE_HEAPS_WIRE: gremlin.ProtoWireNumber = 27;
    const STREAM_ALLOCATIONS_WIRE: gremlin.ProtoWireNumber = 23;
    const HEAP_SAMPLING_INTERVALS_WIRE: gremlin.ProtoWireNumber = 22;
    const ALL_HEAPS_WIRE: gremlin.ProtoWireNumber = 21;
    const ALL_WIRE: gremlin.ProtoWireNumber = 5;
    const MIN_ANONYMOUS_MEMORY_KB_WIRE: gremlin.ProtoWireNumber = 15;
    const MAX_HEAPPROFD_MEMORY_KB_WIRE: gremlin.ProtoWireNumber = 16;
    const MAX_HEAPPROFD_CPU_SECS_WIRE: gremlin.ProtoWireNumber = 17;
    const SKIP_SYMBOL_PREFIX_WIRE: gremlin.ProtoWireNumber = 7;
    const CONTINUOUS_DUMP_CONFIG_WIRE: gremlin.ProtoWireNumber = 6;
    const SHMEM_SIZE_BYTES_WIRE: gremlin.ProtoWireNumber = 8;
    const BLOCK_CLIENT_WIRE: gremlin.ProtoWireNumber = 9;
    const BLOCK_CLIENT_TIMEOUT_US_WIRE: gremlin.ProtoWireNumber = 14;
    const NO_STARTUP_WIRE: gremlin.ProtoWireNumber = 10;
    const NO_RUNNING_WIRE: gremlin.ProtoWireNumber = 11;
    const DUMP_AT_MAX_WIRE: gremlin.ProtoWireNumber = 13;
    const DISABLE_FORK_TEARDOWN_WIRE: gremlin.ProtoWireNumber = 18;
    const DISABLE_VFORK_DETECTION_WIRE: gremlin.ProtoWireNumber = 19;
};
pub const HeapprofdConfig = struct {
    // nested structs
    const ContinuousDumpConfigWire = struct {
        const DUMP_PHASE_MS_WIRE: gremlin.ProtoWireNumber = 5;
        const DUMP_INTERVAL_MS_WIRE: gremlin.ProtoWireNumber = 6;
    };
    pub const ContinuousDumpConfig = struct {
        // fields
        dump_phase_ms: u32 = 0,
        dump_interval_ms: u32 = 0,
        pub fn calcProtobufSize(self: *const HeapprofdConfig.ContinuousDumpConfig) usize {
            var res: usize = 0;
            if (self.dump_phase_ms != 0) {
                res += gremlin.sizes.sizeWireNumber(HeapprofdConfig.ContinuousDumpConfigWire.DUMP_PHASE_MS_WIRE) + gremlin.sizes.sizeU32(self.dump_phase_ms);
            }
            if (self.dump_interval_ms != 0) {
                res += gremlin.sizes.sizeWireNumber(HeapprofdConfig.ContinuousDumpConfigWire.DUMP_INTERVAL_MS_WIRE) + gremlin.sizes.sizeU32(self.dump_interval_ms);
            }
            return res;
        }
        pub fn encode(self: *const HeapprofdConfig.ContinuousDumpConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const HeapprofdConfig.ContinuousDumpConfig, target: *gremlin.Writer) void {
            if (self.dump_phase_ms != 0) {
                target.appendUint32(HeapprofdConfig.ContinuousDumpConfigWire.DUMP_PHASE_MS_WIRE, self.dump_phase_ms);
            }
            if (self.dump_interval_ms != 0) {
                target.appendUint32(HeapprofdConfig.ContinuousDumpConfigWire.DUMP_INTERVAL_MS_WIRE, self.dump_interval_ms);
            }
        }
    };
    pub const ContinuousDumpConfigReader = struct {
        buf: gremlin.Reader,
        _dump_phase_ms: u32 = 0,
        _dump_interval_ms: u32 = 0,
        pub fn init(src: []const u8) gremlin.Error!HeapprofdConfig.ContinuousDumpConfigReader {
            const buf = gremlin.Reader.init(src);
            var res = HeapprofdConfig.ContinuousDumpConfigReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    HeapprofdConfig.ContinuousDumpConfigWire.DUMP_PHASE_MS_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._dump_phase_ms = result.value;
                    },
                    HeapprofdConfig.ContinuousDumpConfigWire.DUMP_INTERVAL_MS_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._dump_interval_ms = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getDumpPhaseMs(self: *const HeapprofdConfig.ContinuousDumpConfigReader) u32 {
            return self._dump_phase_ms;
        }
        pub inline fn getDumpIntervalMs(self: *const HeapprofdConfig.ContinuousDumpConfigReader) u32 {
            return self._dump_interval_ms;
        }
    };
    // fields
    sampling_interval_bytes: u64 = 0,
    adaptive_sampling_shmem_threshold: u64 = 0,
    adaptive_sampling_max_sampling_interval_bytes: u64 = 0,
    process_cmdline: ?[]const ?[]const u8 = null,
    pid: ?[]const u64 = null,
    target_installed_by: ?[]const ?[]const u8 = null,
    heaps: ?[]const ?[]const u8 = null,
    exclude_heaps: ?[]const ?[]const u8 = null,
    stream_allocations: bool = false,
    heap_sampling_intervals: ?[]const u64 = null,
    all_heaps: bool = false,
    all: bool = false,
    min_anonymous_memory_kb: u32 = 0,
    max_heapprofd_memory_kb: u32 = 0,
    max_heapprofd_cpu_secs: u64 = 0,
    skip_symbol_prefix: ?[]const ?[]const u8 = null,
    continuous_dump_config: ?HeapprofdConfig.ContinuousDumpConfig = null,
    shmem_size_bytes: u64 = 0,
    block_client: bool = false,
    block_client_timeout_us: u32 = 0,
    no_startup: bool = false,
    no_running: bool = false,
    dump_at_max: bool = false,
    disable_fork_teardown: bool = false,
    disable_vfork_detection: bool = false,
    pub fn calcProtobufSize(self: *const HeapprofdConfig) usize {
        var res: usize = 0;
        if (self.sampling_interval_bytes != 0) {
            res += gremlin.sizes.sizeWireNumber(HeapprofdConfigWire.SAMPLING_INTERVAL_BYTES_WIRE) + gremlin.sizes.sizeU64(self.sampling_interval_bytes);
        }
        if (self.adaptive_sampling_shmem_threshold != 0) {
            res += gremlin.sizes.sizeWireNumber(HeapprofdConfigWire.ADAPTIVE_SAMPLING_SHMEM_THRESHOLD_WIRE) + gremlin.sizes.sizeU64(self.adaptive_sampling_shmem_threshold);
        }
        if (self.adaptive_sampling_max_sampling_interval_bytes != 0) {
            res += gremlin.sizes.sizeWireNumber(HeapprofdConfigWire.ADAPTIVE_SAMPLING_MAX_SAMPLING_INTERVAL_BYTES_WIRE) + gremlin.sizes.sizeU64(self.adaptive_sampling_max_sampling_interval_bytes);
        }
        if (self.process_cmdline) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(HeapprofdConfigWire.PROCESS_CMDLINE_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.pid) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(HeapprofdConfigWire.PID_WIRE) + gremlin.sizes.sizeU64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                res += gremlin.sizes.sizeWireNumber(HeapprofdConfigWire.PID_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.target_installed_by) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(HeapprofdConfigWire.TARGET_INSTALLED_BY_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.heaps) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(HeapprofdConfigWire.HEAPS_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.exclude_heaps) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(HeapprofdConfigWire.EXCLUDE_HEAPS_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.stream_allocations != false) {
            res += gremlin.sizes.sizeWireNumber(HeapprofdConfigWire.STREAM_ALLOCATIONS_WIRE) + gremlin.sizes.sizeBool(self.stream_allocations);
        }
        if (self.heap_sampling_intervals) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(HeapprofdConfigWire.HEAP_SAMPLING_INTERVALS_WIRE) + gremlin.sizes.sizeU64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                res += gremlin.sizes.sizeWireNumber(HeapprofdConfigWire.HEAP_SAMPLING_INTERVALS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.all_heaps != false) {
            res += gremlin.sizes.sizeWireNumber(HeapprofdConfigWire.ALL_HEAPS_WIRE) + gremlin.sizes.sizeBool(self.all_heaps);
        }
        if (self.all != false) {
            res += gremlin.sizes.sizeWireNumber(HeapprofdConfigWire.ALL_WIRE) + gremlin.sizes.sizeBool(self.all);
        }
        if (self.min_anonymous_memory_kb != 0) {
            res += gremlin.sizes.sizeWireNumber(HeapprofdConfigWire.MIN_ANONYMOUS_MEMORY_KB_WIRE) + gremlin.sizes.sizeU32(self.min_anonymous_memory_kb);
        }
        if (self.max_heapprofd_memory_kb != 0) {
            res += gremlin.sizes.sizeWireNumber(HeapprofdConfigWire.MAX_HEAPPROFD_MEMORY_KB_WIRE) + gremlin.sizes.sizeU32(self.max_heapprofd_memory_kb);
        }
        if (self.max_heapprofd_cpu_secs != 0) {
            res += gremlin.sizes.sizeWireNumber(HeapprofdConfigWire.MAX_HEAPPROFD_CPU_SECS_WIRE) + gremlin.sizes.sizeU64(self.max_heapprofd_cpu_secs);
        }
        if (self.skip_symbol_prefix) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(HeapprofdConfigWire.SKIP_SYMBOL_PREFIX_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.continuous_dump_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(HeapprofdConfigWire.CONTINUOUS_DUMP_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.shmem_size_bytes != 0) {
            res += gremlin.sizes.sizeWireNumber(HeapprofdConfigWire.SHMEM_SIZE_BYTES_WIRE) + gremlin.sizes.sizeU64(self.shmem_size_bytes);
        }
        if (self.block_client != false) {
            res += gremlin.sizes.sizeWireNumber(HeapprofdConfigWire.BLOCK_CLIENT_WIRE) + gremlin.sizes.sizeBool(self.block_client);
        }
        if (self.block_client_timeout_us != 0) {
            res += gremlin.sizes.sizeWireNumber(HeapprofdConfigWire.BLOCK_CLIENT_TIMEOUT_US_WIRE) + gremlin.sizes.sizeU32(self.block_client_timeout_us);
        }
        if (self.no_startup != false) {
            res += gremlin.sizes.sizeWireNumber(HeapprofdConfigWire.NO_STARTUP_WIRE) + gremlin.sizes.sizeBool(self.no_startup);
        }
        if (self.no_running != false) {
            res += gremlin.sizes.sizeWireNumber(HeapprofdConfigWire.NO_RUNNING_WIRE) + gremlin.sizes.sizeBool(self.no_running);
        }
        if (self.dump_at_max != false) {
            res += gremlin.sizes.sizeWireNumber(HeapprofdConfigWire.DUMP_AT_MAX_WIRE) + gremlin.sizes.sizeBool(self.dump_at_max);
        }
        if (self.disable_fork_teardown != false) {
            res += gremlin.sizes.sizeWireNumber(HeapprofdConfigWire.DISABLE_FORK_TEARDOWN_WIRE) + gremlin.sizes.sizeBool(self.disable_fork_teardown);
        }
        if (self.disable_vfork_detection != false) {
            res += gremlin.sizes.sizeWireNumber(HeapprofdConfigWire.DISABLE_VFORK_DETECTION_WIRE) + gremlin.sizes.sizeBool(self.disable_vfork_detection);
        }
        return res;
    }
    pub fn encode(self: *const HeapprofdConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const HeapprofdConfig, target: *gremlin.Writer) void {
        if (self.sampling_interval_bytes != 0) {
            target.appendUint64(HeapprofdConfigWire.SAMPLING_INTERVAL_BYTES_WIRE, self.sampling_interval_bytes);
        }
        if (self.adaptive_sampling_shmem_threshold != 0) {
            target.appendUint64(HeapprofdConfigWire.ADAPTIVE_SAMPLING_SHMEM_THRESHOLD_WIRE, self.adaptive_sampling_shmem_threshold);
        }
        if (self.adaptive_sampling_max_sampling_interval_bytes != 0) {
            target.appendUint64(HeapprofdConfigWire.ADAPTIVE_SAMPLING_MAX_SAMPLING_INTERVAL_BYTES_WIRE, self.adaptive_sampling_max_sampling_interval_bytes);
        }
        if (self.process_cmdline) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(HeapprofdConfigWire.PROCESS_CMDLINE_WIRE, v);
                } else {
                    target.appendBytesTag(HeapprofdConfigWire.PROCESS_CMDLINE_WIRE, 0);
                }
            }
        }
        if (self.pid) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint64(HeapprofdConfigWire.PID_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                target.appendBytesTag(HeapprofdConfigWire.PID_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint64WithoutTag(v);
                }
            }
        }
        if (self.target_installed_by) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(HeapprofdConfigWire.TARGET_INSTALLED_BY_WIRE, v);
                } else {
                    target.appendBytesTag(HeapprofdConfigWire.TARGET_INSTALLED_BY_WIRE, 0);
                }
            }
        }
        if (self.heaps) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(HeapprofdConfigWire.HEAPS_WIRE, v);
                } else {
                    target.appendBytesTag(HeapprofdConfigWire.HEAPS_WIRE, 0);
                }
            }
        }
        if (self.exclude_heaps) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(HeapprofdConfigWire.EXCLUDE_HEAPS_WIRE, v);
                } else {
                    target.appendBytesTag(HeapprofdConfigWire.EXCLUDE_HEAPS_WIRE, 0);
                }
            }
        }
        if (self.stream_allocations != false) {
            target.appendBool(HeapprofdConfigWire.STREAM_ALLOCATIONS_WIRE, self.stream_allocations);
        }
        if (self.heap_sampling_intervals) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint64(HeapprofdConfigWire.HEAP_SAMPLING_INTERVALS_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                target.appendBytesTag(HeapprofdConfigWire.HEAP_SAMPLING_INTERVALS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint64WithoutTag(v);
                }
            }
        }
        if (self.all_heaps != false) {
            target.appendBool(HeapprofdConfigWire.ALL_HEAPS_WIRE, self.all_heaps);
        }
        if (self.all != false) {
            target.appendBool(HeapprofdConfigWire.ALL_WIRE, self.all);
        }
        if (self.min_anonymous_memory_kb != 0) {
            target.appendUint32(HeapprofdConfigWire.MIN_ANONYMOUS_MEMORY_KB_WIRE, self.min_anonymous_memory_kb);
        }
        if (self.max_heapprofd_memory_kb != 0) {
            target.appendUint32(HeapprofdConfigWire.MAX_HEAPPROFD_MEMORY_KB_WIRE, self.max_heapprofd_memory_kb);
        }
        if (self.max_heapprofd_cpu_secs != 0) {
            target.appendUint64(HeapprofdConfigWire.MAX_HEAPPROFD_CPU_SECS_WIRE, self.max_heapprofd_cpu_secs);
        }
        if (self.skip_symbol_prefix) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(HeapprofdConfigWire.SKIP_SYMBOL_PREFIX_WIRE, v);
                } else {
                    target.appendBytesTag(HeapprofdConfigWire.SKIP_SYMBOL_PREFIX_WIRE, 0);
                }
            }
        }
        if (self.continuous_dump_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(HeapprofdConfigWire.CONTINUOUS_DUMP_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.shmem_size_bytes != 0) {
            target.appendUint64(HeapprofdConfigWire.SHMEM_SIZE_BYTES_WIRE, self.shmem_size_bytes);
        }
        if (self.block_client != false) {
            target.appendBool(HeapprofdConfigWire.BLOCK_CLIENT_WIRE, self.block_client);
        }
        if (self.block_client_timeout_us != 0) {
            target.appendUint32(HeapprofdConfigWire.BLOCK_CLIENT_TIMEOUT_US_WIRE, self.block_client_timeout_us);
        }
        if (self.no_startup != false) {
            target.appendBool(HeapprofdConfigWire.NO_STARTUP_WIRE, self.no_startup);
        }
        if (self.no_running != false) {
            target.appendBool(HeapprofdConfigWire.NO_RUNNING_WIRE, self.no_running);
        }
        if (self.dump_at_max != false) {
            target.appendBool(HeapprofdConfigWire.DUMP_AT_MAX_WIRE, self.dump_at_max);
        }
        if (self.disable_fork_teardown != false) {
            target.appendBool(HeapprofdConfigWire.DISABLE_FORK_TEARDOWN_WIRE, self.disable_fork_teardown);
        }
        if (self.disable_vfork_detection != false) {
            target.appendBool(HeapprofdConfigWire.DISABLE_VFORK_DETECTION_WIRE, self.disable_vfork_detection);
        }
    }
};
pub const HeapprofdConfigReader = struct {
    buf: gremlin.Reader,
    _sampling_interval_bytes: u64 = 0,
    _adaptive_sampling_shmem_threshold: u64 = 0,
    _adaptive_sampling_max_sampling_interval_bytes: u64 = 0,
    _process_cmdline_offset: ?usize = null,
    _process_cmdline_last_offset: ?usize = null,
    _process_cmdline_cnt: usize = 0,
    _pid_offset: ?usize = null,
    _pid_last_offset: ?usize = null,
    _pid_packed: bool = false,
    _target_installed_by_offset: ?usize = null,
    _target_installed_by_last_offset: ?usize = null,
    _target_installed_by_cnt: usize = 0,
    _heaps_offset: ?usize = null,
    _heaps_last_offset: ?usize = null,
    _heaps_cnt: usize = 0,
    _exclude_heaps_offset: ?usize = null,
    _exclude_heaps_last_offset: ?usize = null,
    _exclude_heaps_cnt: usize = 0,
    _stream_allocations: bool = false,
    _heap_sampling_intervals_offset: ?usize = null,
    _heap_sampling_intervals_last_offset: ?usize = null,
    _heap_sampling_intervals_packed: bool = false,
    _all_heaps: bool = false,
    _all: bool = false,
    _min_anonymous_memory_kb: u32 = 0,
    _max_heapprofd_memory_kb: u32 = 0,
    _max_heapprofd_cpu_secs: u64 = 0,
    _skip_symbol_prefix_offset: ?usize = null,
    _skip_symbol_prefix_last_offset: ?usize = null,
    _skip_symbol_prefix_cnt: usize = 0,
    _continuous_dump_config_buf: ?[]const u8 = null,
    _shmem_size_bytes: u64 = 0,
    _block_client: bool = false,
    _block_client_timeout_us: u32 = 0,
    _no_startup: bool = false,
    _no_running: bool = false,
    _dump_at_max: bool = false,
    _disable_fork_teardown: bool = false,
    _disable_vfork_detection: bool = false,
    pub fn init(src: []const u8) gremlin.Error!HeapprofdConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = HeapprofdConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                HeapprofdConfigWire.SAMPLING_INTERVAL_BYTES_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._sampling_interval_bytes = result.value;
                },
                HeapprofdConfigWire.ADAPTIVE_SAMPLING_SHMEM_THRESHOLD_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._adaptive_sampling_shmem_threshold = result.value;
                },
                HeapprofdConfigWire.ADAPTIVE_SAMPLING_MAX_SAMPLING_INTERVAL_BYTES_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._adaptive_sampling_max_sampling_interval_bytes = result.value;
                },
                HeapprofdConfigWire.PROCESS_CMDLINE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._process_cmdline_offset == null) {
                        res._process_cmdline_offset = offset - result.size;
                    }
                    res._process_cmdline_last_offset = offset;
                    res._process_cmdline_cnt += 1;
                },
                HeapprofdConfigWire.PID_WIRE => {
                    if (res._pid_offset == null) {
                        res._pid_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._pid_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._pid_offset = offset + length_result.size;
                        res._pid_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._pid_last_offset.?;
                    } else {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._pid_last_offset = offset;
                    }
                },
                HeapprofdConfigWire.TARGET_INSTALLED_BY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._target_installed_by_offset == null) {
                        res._target_installed_by_offset = offset - result.size;
                    }
                    res._target_installed_by_last_offset = offset;
                    res._target_installed_by_cnt += 1;
                },
                HeapprofdConfigWire.HEAPS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._heaps_offset == null) {
                        res._heaps_offset = offset - result.size;
                    }
                    res._heaps_last_offset = offset;
                    res._heaps_cnt += 1;
                },
                HeapprofdConfigWire.EXCLUDE_HEAPS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._exclude_heaps_offset == null) {
                        res._exclude_heaps_offset = offset - result.size;
                    }
                    res._exclude_heaps_last_offset = offset;
                    res._exclude_heaps_cnt += 1;
                },
                HeapprofdConfigWire.STREAM_ALLOCATIONS_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._stream_allocations = result.value;
                },
                HeapprofdConfigWire.HEAP_SAMPLING_INTERVALS_WIRE => {
                    if (res._heap_sampling_intervals_offset == null) {
                        res._heap_sampling_intervals_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._heap_sampling_intervals_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._heap_sampling_intervals_offset = offset + length_result.size;
                        res._heap_sampling_intervals_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._heap_sampling_intervals_last_offset.?;
                    } else {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._heap_sampling_intervals_last_offset = offset;
                    }
                },
                HeapprofdConfigWire.ALL_HEAPS_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._all_heaps = result.value;
                },
                HeapprofdConfigWire.ALL_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._all = result.value;
                },
                HeapprofdConfigWire.MIN_ANONYMOUS_MEMORY_KB_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._min_anonymous_memory_kb = result.value;
                },
                HeapprofdConfigWire.MAX_HEAPPROFD_MEMORY_KB_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._max_heapprofd_memory_kb = result.value;
                },
                HeapprofdConfigWire.MAX_HEAPPROFD_CPU_SECS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._max_heapprofd_cpu_secs = result.value;
                },
                HeapprofdConfigWire.SKIP_SYMBOL_PREFIX_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._skip_symbol_prefix_offset == null) {
                        res._skip_symbol_prefix_offset = offset - result.size;
                    }
                    res._skip_symbol_prefix_last_offset = offset;
                    res._skip_symbol_prefix_cnt += 1;
                },
                HeapprofdConfigWire.CONTINUOUS_DUMP_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._continuous_dump_config_buf = result.value;
                },
                HeapprofdConfigWire.SHMEM_SIZE_BYTES_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._shmem_size_bytes = result.value;
                },
                HeapprofdConfigWire.BLOCK_CLIENT_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._block_client = result.value;
                },
                HeapprofdConfigWire.BLOCK_CLIENT_TIMEOUT_US_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._block_client_timeout_us = result.value;
                },
                HeapprofdConfigWire.NO_STARTUP_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._no_startup = result.value;
                },
                HeapprofdConfigWire.NO_RUNNING_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._no_running = result.value;
                },
                HeapprofdConfigWire.DUMP_AT_MAX_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._dump_at_max = result.value;
                },
                HeapprofdConfigWire.DISABLE_FORK_TEARDOWN_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._disable_fork_teardown = result.value;
                },
                HeapprofdConfigWire.DISABLE_VFORK_DETECTION_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._disable_vfork_detection = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getSamplingIntervalBytes(self: *const HeapprofdConfigReader) u64 {
        return self._sampling_interval_bytes;
    }
    pub inline fn getAdaptiveSamplingShmemThreshold(self: *const HeapprofdConfigReader) u64 {
        return self._adaptive_sampling_shmem_threshold;
    }
    pub inline fn getAdaptiveSamplingMaxSamplingIntervalBytes(self: *const HeapprofdConfigReader) u64 {
        return self._adaptive_sampling_max_sampling_interval_bytes;
    }
    pub fn processCmdlineCount(self: *const HeapprofdConfigReader) usize {
        return self._process_cmdline_cnt;
    }
    pub fn processCmdlineNext(self: *HeapprofdConfigReader) ?[]const u8 {
        if (self._process_cmdline_offset == null) return null;
        const current_offset = self._process_cmdline_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._process_cmdline_last_offset != null and current_offset >= self._process_cmdline_last_offset.?) {
            self._process_cmdline_offset = null;
            return result.value;
        }
        if (self._process_cmdline_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._process_cmdline_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == HeapprofdConfigWire.PROCESS_CMDLINE_WIRE) {
                self._process_cmdline_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._process_cmdline_offset = null;
        return result.value;
    }
    pub fn pidNext(self: *HeapprofdConfigReader) gremlin.Error!?u64 {
        if (self._pid_offset == null) return null;
        const current_offset = self._pid_offset.?;
        if (current_offset >= self._pid_last_offset.?) {
            self._pid_offset = null;
            return null;
        }
        if (self._pid_packed) {
            const value_result = try self.buf.readUInt64(current_offset);
            self._pid_offset = current_offset + value_result.size;
            if (self._pid_offset.? >= self._pid_last_offset.?) {
                self._pid_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._pid_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == HeapprofdConfigWire.PID_WIRE) {
                    self._pid_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._pid_offset = null;
            return value_result.value;
        }
    }
    pub fn targetInstalledByCount(self: *const HeapprofdConfigReader) usize {
        return self._target_installed_by_cnt;
    }
    pub fn targetInstalledByNext(self: *HeapprofdConfigReader) ?[]const u8 {
        if (self._target_installed_by_offset == null) return null;
        const current_offset = self._target_installed_by_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._target_installed_by_last_offset != null and current_offset >= self._target_installed_by_last_offset.?) {
            self._target_installed_by_offset = null;
            return result.value;
        }
        if (self._target_installed_by_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._target_installed_by_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == HeapprofdConfigWire.TARGET_INSTALLED_BY_WIRE) {
                self._target_installed_by_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._target_installed_by_offset = null;
        return result.value;
    }
    pub fn heapsCount(self: *const HeapprofdConfigReader) usize {
        return self._heaps_cnt;
    }
    pub fn heapsNext(self: *HeapprofdConfigReader) ?[]const u8 {
        if (self._heaps_offset == null) return null;
        const current_offset = self._heaps_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._heaps_last_offset != null and current_offset >= self._heaps_last_offset.?) {
            self._heaps_offset = null;
            return result.value;
        }
        if (self._heaps_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._heaps_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == HeapprofdConfigWire.HEAPS_WIRE) {
                self._heaps_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._heaps_offset = null;
        return result.value;
    }
    pub fn excludeHeapsCount(self: *const HeapprofdConfigReader) usize {
        return self._exclude_heaps_cnt;
    }
    pub fn excludeHeapsNext(self: *HeapprofdConfigReader) ?[]const u8 {
        if (self._exclude_heaps_offset == null) return null;
        const current_offset = self._exclude_heaps_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._exclude_heaps_last_offset != null and current_offset >= self._exclude_heaps_last_offset.?) {
            self._exclude_heaps_offset = null;
            return result.value;
        }
        if (self._exclude_heaps_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._exclude_heaps_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == HeapprofdConfigWire.EXCLUDE_HEAPS_WIRE) {
                self._exclude_heaps_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._exclude_heaps_offset = null;
        return result.value;
    }
    pub inline fn getStreamAllocations(self: *const HeapprofdConfigReader) bool {
        return self._stream_allocations;
    }
    pub fn heapSamplingIntervalsNext(self: *HeapprofdConfigReader) gremlin.Error!?u64 {
        if (self._heap_sampling_intervals_offset == null) return null;
        const current_offset = self._heap_sampling_intervals_offset.?;
        if (current_offset >= self._heap_sampling_intervals_last_offset.?) {
            self._heap_sampling_intervals_offset = null;
            return null;
        }
        if (self._heap_sampling_intervals_packed) {
            const value_result = try self.buf.readUInt64(current_offset);
            self._heap_sampling_intervals_offset = current_offset + value_result.size;
            if (self._heap_sampling_intervals_offset.? >= self._heap_sampling_intervals_last_offset.?) {
                self._heap_sampling_intervals_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._heap_sampling_intervals_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == HeapprofdConfigWire.HEAP_SAMPLING_INTERVALS_WIRE) {
                    self._heap_sampling_intervals_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._heap_sampling_intervals_offset = null;
            return value_result.value;
        }
    }
    pub inline fn getAllHeaps(self: *const HeapprofdConfigReader) bool {
        return self._all_heaps;
    }
    pub inline fn getAll(self: *const HeapprofdConfigReader) bool {
        return self._all;
    }
    pub inline fn getMinAnonymousMemoryKb(self: *const HeapprofdConfigReader) u32 {
        return self._min_anonymous_memory_kb;
    }
    pub inline fn getMaxHeapprofdMemoryKb(self: *const HeapprofdConfigReader) u32 {
        return self._max_heapprofd_memory_kb;
    }
    pub inline fn getMaxHeapprofdCpuSecs(self: *const HeapprofdConfigReader) u64 {
        return self._max_heapprofd_cpu_secs;
    }
    pub fn skipSymbolPrefixCount(self: *const HeapprofdConfigReader) usize {
        return self._skip_symbol_prefix_cnt;
    }
    pub fn skipSymbolPrefixNext(self: *HeapprofdConfigReader) ?[]const u8 {
        if (self._skip_symbol_prefix_offset == null) return null;
        const current_offset = self._skip_symbol_prefix_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._skip_symbol_prefix_last_offset != null and current_offset >= self._skip_symbol_prefix_last_offset.?) {
            self._skip_symbol_prefix_offset = null;
            return result.value;
        }
        if (self._skip_symbol_prefix_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._skip_symbol_prefix_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == HeapprofdConfigWire.SKIP_SYMBOL_PREFIX_WIRE) {
                self._skip_symbol_prefix_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._skip_symbol_prefix_offset = null;
        return result.value;
    }
    pub fn getContinuousDumpConfig(self: *const HeapprofdConfigReader) gremlin.Error!HeapprofdConfig.ContinuousDumpConfigReader {
        if (self._continuous_dump_config_buf) |buf| {
            return try HeapprofdConfig.ContinuousDumpConfigReader.init(buf);
        }
        return try HeapprofdConfig.ContinuousDumpConfigReader.init(&[_]u8{});
    }
    pub inline fn getShmemSizeBytes(self: *const HeapprofdConfigReader) u64 {
        return self._shmem_size_bytes;
    }
    pub inline fn getBlockClient(self: *const HeapprofdConfigReader) bool {
        return self._block_client;
    }
    pub inline fn getBlockClientTimeoutUs(self: *const HeapprofdConfigReader) u32 {
        return self._block_client_timeout_us;
    }
    pub inline fn getNoStartup(self: *const HeapprofdConfigReader) bool {
        return self._no_startup;
    }
    pub inline fn getNoRunning(self: *const HeapprofdConfigReader) bool {
        return self._no_running;
    }
    pub inline fn getDumpAtMax(self: *const HeapprofdConfigReader) bool {
        return self._dump_at_max;
    }
    pub inline fn getDisableForkTeardown(self: *const HeapprofdConfigReader) bool {
        return self._disable_fork_teardown;
    }
    pub inline fn getDisableVforkDetection(self: *const HeapprofdConfigReader) bool {
        return self._disable_vfork_detection;
    }
};
const JavaHprofConfigWire = struct {
    const PROCESS_CMDLINE_WIRE: gremlin.ProtoWireNumber = 1;
    const PID_WIRE: gremlin.ProtoWireNumber = 2;
    const TARGET_INSTALLED_BY_WIRE: gremlin.ProtoWireNumber = 7;
    const CONTINUOUS_DUMP_CONFIG_WIRE: gremlin.ProtoWireNumber = 3;
    const MIN_ANONYMOUS_MEMORY_KB_WIRE: gremlin.ProtoWireNumber = 4;
    const DUMP_SMAPS_WIRE: gremlin.ProtoWireNumber = 5;
    const IGNORED_TYPES_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const JavaHprofConfig = struct {
    // nested structs
    const ContinuousDumpConfigWire = struct {
        const DUMP_PHASE_MS_WIRE: gremlin.ProtoWireNumber = 1;
        const DUMP_INTERVAL_MS_WIRE: gremlin.ProtoWireNumber = 2;
        const SCAN_PIDS_ONLY_ON_START_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const ContinuousDumpConfig = struct {
        // fields
        dump_phase_ms: u32 = 0,
        dump_interval_ms: u32 = 0,
        scan_pids_only_on_start: bool = false,
        pub fn calcProtobufSize(self: *const JavaHprofConfig.ContinuousDumpConfig) usize {
            var res: usize = 0;
            if (self.dump_phase_ms != 0) {
                res += gremlin.sizes.sizeWireNumber(JavaHprofConfig.ContinuousDumpConfigWire.DUMP_PHASE_MS_WIRE) + gremlin.sizes.sizeU32(self.dump_phase_ms);
            }
            if (self.dump_interval_ms != 0) {
                res += gremlin.sizes.sizeWireNumber(JavaHprofConfig.ContinuousDumpConfigWire.DUMP_INTERVAL_MS_WIRE) + gremlin.sizes.sizeU32(self.dump_interval_ms);
            }
            if (self.scan_pids_only_on_start != false) {
                res += gremlin.sizes.sizeWireNumber(JavaHprofConfig.ContinuousDumpConfigWire.SCAN_PIDS_ONLY_ON_START_WIRE) + gremlin.sizes.sizeBool(self.scan_pids_only_on_start);
            }
            return res;
        }
        pub fn encode(self: *const JavaHprofConfig.ContinuousDumpConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const JavaHprofConfig.ContinuousDumpConfig, target: *gremlin.Writer) void {
            if (self.dump_phase_ms != 0) {
                target.appendUint32(JavaHprofConfig.ContinuousDumpConfigWire.DUMP_PHASE_MS_WIRE, self.dump_phase_ms);
            }
            if (self.dump_interval_ms != 0) {
                target.appendUint32(JavaHprofConfig.ContinuousDumpConfigWire.DUMP_INTERVAL_MS_WIRE, self.dump_interval_ms);
            }
            if (self.scan_pids_only_on_start != false) {
                target.appendBool(JavaHprofConfig.ContinuousDumpConfigWire.SCAN_PIDS_ONLY_ON_START_WIRE, self.scan_pids_only_on_start);
            }
        }
    };
    pub const ContinuousDumpConfigReader = struct {
        buf: gremlin.Reader,
        _dump_phase_ms: u32 = 0,
        _dump_interval_ms: u32 = 0,
        _scan_pids_only_on_start: bool = false,
        pub fn init(src: []const u8) gremlin.Error!JavaHprofConfig.ContinuousDumpConfigReader {
            const buf = gremlin.Reader.init(src);
            var res = JavaHprofConfig.ContinuousDumpConfigReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    JavaHprofConfig.ContinuousDumpConfigWire.DUMP_PHASE_MS_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._dump_phase_ms = result.value;
                    },
                    JavaHprofConfig.ContinuousDumpConfigWire.DUMP_INTERVAL_MS_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._dump_interval_ms = result.value;
                    },
                    JavaHprofConfig.ContinuousDumpConfigWire.SCAN_PIDS_ONLY_ON_START_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._scan_pids_only_on_start = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getDumpPhaseMs(self: *const JavaHprofConfig.ContinuousDumpConfigReader) u32 {
            return self._dump_phase_ms;
        }
        pub inline fn getDumpIntervalMs(self: *const JavaHprofConfig.ContinuousDumpConfigReader) u32 {
            return self._dump_interval_ms;
        }
        pub inline fn getScanPidsOnlyOnStart(self: *const JavaHprofConfig.ContinuousDumpConfigReader) bool {
            return self._scan_pids_only_on_start;
        }
    };
    // fields
    process_cmdline: ?[]const ?[]const u8 = null,
    pid: ?[]const u64 = null,
    target_installed_by: ?[]const ?[]const u8 = null,
    continuous_dump_config: ?JavaHprofConfig.ContinuousDumpConfig = null,
    min_anonymous_memory_kb: u32 = 0,
    dump_smaps: bool = false,
    ignored_types: ?[]const ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const JavaHprofConfig) usize {
        var res: usize = 0;
        if (self.process_cmdline) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(JavaHprofConfigWire.PROCESS_CMDLINE_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.pid) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(JavaHprofConfigWire.PID_WIRE) + gremlin.sizes.sizeU64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                res += gremlin.sizes.sizeWireNumber(JavaHprofConfigWire.PID_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.target_installed_by) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(JavaHprofConfigWire.TARGET_INSTALLED_BY_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.continuous_dump_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(JavaHprofConfigWire.CONTINUOUS_DUMP_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.min_anonymous_memory_kb != 0) {
            res += gremlin.sizes.sizeWireNumber(JavaHprofConfigWire.MIN_ANONYMOUS_MEMORY_KB_WIRE) + gremlin.sizes.sizeU32(self.min_anonymous_memory_kb);
        }
        if (self.dump_smaps != false) {
            res += gremlin.sizes.sizeWireNumber(JavaHprofConfigWire.DUMP_SMAPS_WIRE) + gremlin.sizes.sizeBool(self.dump_smaps);
        }
        if (self.ignored_types) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(JavaHprofConfigWire.IGNORED_TYPES_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const JavaHprofConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const JavaHprofConfig, target: *gremlin.Writer) void {
        if (self.process_cmdline) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(JavaHprofConfigWire.PROCESS_CMDLINE_WIRE, v);
                } else {
                    target.appendBytesTag(JavaHprofConfigWire.PROCESS_CMDLINE_WIRE, 0);
                }
            }
        }
        if (self.pid) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint64(JavaHprofConfigWire.PID_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                target.appendBytesTag(JavaHprofConfigWire.PID_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint64WithoutTag(v);
                }
            }
        }
        if (self.target_installed_by) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(JavaHprofConfigWire.TARGET_INSTALLED_BY_WIRE, v);
                } else {
                    target.appendBytesTag(JavaHprofConfigWire.TARGET_INSTALLED_BY_WIRE, 0);
                }
            }
        }
        if (self.continuous_dump_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(JavaHprofConfigWire.CONTINUOUS_DUMP_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.min_anonymous_memory_kb != 0) {
            target.appendUint32(JavaHprofConfigWire.MIN_ANONYMOUS_MEMORY_KB_WIRE, self.min_anonymous_memory_kb);
        }
        if (self.dump_smaps != false) {
            target.appendBool(JavaHprofConfigWire.DUMP_SMAPS_WIRE, self.dump_smaps);
        }
        if (self.ignored_types) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(JavaHprofConfigWire.IGNORED_TYPES_WIRE, v);
                } else {
                    target.appendBytesTag(JavaHprofConfigWire.IGNORED_TYPES_WIRE, 0);
                }
            }
        }
    }
};
pub const JavaHprofConfigReader = struct {
    buf: gremlin.Reader,
    _process_cmdline_offset: ?usize = null,
    _process_cmdline_last_offset: ?usize = null,
    _process_cmdline_cnt: usize = 0,
    _pid_offset: ?usize = null,
    _pid_last_offset: ?usize = null,
    _pid_packed: bool = false,
    _target_installed_by_offset: ?usize = null,
    _target_installed_by_last_offset: ?usize = null,
    _target_installed_by_cnt: usize = 0,
    _continuous_dump_config_buf: ?[]const u8 = null,
    _min_anonymous_memory_kb: u32 = 0,
    _dump_smaps: bool = false,
    _ignored_types_offset: ?usize = null,
    _ignored_types_last_offset: ?usize = null,
    _ignored_types_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!JavaHprofConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = JavaHprofConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                JavaHprofConfigWire.PROCESS_CMDLINE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._process_cmdline_offset == null) {
                        res._process_cmdline_offset = offset - result.size;
                    }
                    res._process_cmdline_last_offset = offset;
                    res._process_cmdline_cnt += 1;
                },
                JavaHprofConfigWire.PID_WIRE => {
                    if (res._pid_offset == null) {
                        res._pid_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._pid_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._pid_offset = offset + length_result.size;
                        res._pid_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._pid_last_offset.?;
                    } else {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._pid_last_offset = offset;
                    }
                },
                JavaHprofConfigWire.TARGET_INSTALLED_BY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._target_installed_by_offset == null) {
                        res._target_installed_by_offset = offset - result.size;
                    }
                    res._target_installed_by_last_offset = offset;
                    res._target_installed_by_cnt += 1;
                },
                JavaHprofConfigWire.CONTINUOUS_DUMP_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._continuous_dump_config_buf = result.value;
                },
                JavaHprofConfigWire.MIN_ANONYMOUS_MEMORY_KB_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._min_anonymous_memory_kb = result.value;
                },
                JavaHprofConfigWire.DUMP_SMAPS_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._dump_smaps = result.value;
                },
                JavaHprofConfigWire.IGNORED_TYPES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._ignored_types_offset == null) {
                        res._ignored_types_offset = offset - result.size;
                    }
                    res._ignored_types_last_offset = offset;
                    res._ignored_types_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn processCmdlineCount(self: *const JavaHprofConfigReader) usize {
        return self._process_cmdline_cnt;
    }
    pub fn processCmdlineNext(self: *JavaHprofConfigReader) ?[]const u8 {
        if (self._process_cmdline_offset == null) return null;
        const current_offset = self._process_cmdline_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._process_cmdline_last_offset != null and current_offset >= self._process_cmdline_last_offset.?) {
            self._process_cmdline_offset = null;
            return result.value;
        }
        if (self._process_cmdline_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._process_cmdline_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == JavaHprofConfigWire.PROCESS_CMDLINE_WIRE) {
                self._process_cmdline_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._process_cmdline_offset = null;
        return result.value;
    }
    pub fn pidNext(self: *JavaHprofConfigReader) gremlin.Error!?u64 {
        if (self._pid_offset == null) return null;
        const current_offset = self._pid_offset.?;
        if (current_offset >= self._pid_last_offset.?) {
            self._pid_offset = null;
            return null;
        }
        if (self._pid_packed) {
            const value_result = try self.buf.readUInt64(current_offset);
            self._pid_offset = current_offset + value_result.size;
            if (self._pid_offset.? >= self._pid_last_offset.?) {
                self._pid_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._pid_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == JavaHprofConfigWire.PID_WIRE) {
                    self._pid_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._pid_offset = null;
            return value_result.value;
        }
    }
    pub fn targetInstalledByCount(self: *const JavaHprofConfigReader) usize {
        return self._target_installed_by_cnt;
    }
    pub fn targetInstalledByNext(self: *JavaHprofConfigReader) ?[]const u8 {
        if (self._target_installed_by_offset == null) return null;
        const current_offset = self._target_installed_by_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._target_installed_by_last_offset != null and current_offset >= self._target_installed_by_last_offset.?) {
            self._target_installed_by_offset = null;
            return result.value;
        }
        if (self._target_installed_by_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._target_installed_by_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == JavaHprofConfigWire.TARGET_INSTALLED_BY_WIRE) {
                self._target_installed_by_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._target_installed_by_offset = null;
        return result.value;
    }
    pub fn getContinuousDumpConfig(self: *const JavaHprofConfigReader) gremlin.Error!JavaHprofConfig.ContinuousDumpConfigReader {
        if (self._continuous_dump_config_buf) |buf| {
            return try JavaHprofConfig.ContinuousDumpConfigReader.init(buf);
        }
        return try JavaHprofConfig.ContinuousDumpConfigReader.init(&[_]u8{});
    }
    pub inline fn getMinAnonymousMemoryKb(self: *const JavaHprofConfigReader) u32 {
        return self._min_anonymous_memory_kb;
    }
    pub inline fn getDumpSmaps(self: *const JavaHprofConfigReader) bool {
        return self._dump_smaps;
    }
    pub fn ignoredTypesCount(self: *const JavaHprofConfigReader) usize {
        return self._ignored_types_cnt;
    }
    pub fn ignoredTypesNext(self: *JavaHprofConfigReader) ?[]const u8 {
        if (self._ignored_types_offset == null) return null;
        const current_offset = self._ignored_types_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._ignored_types_last_offset != null and current_offset >= self._ignored_types_last_offset.?) {
            self._ignored_types_offset = null;
            return result.value;
        }
        if (self._ignored_types_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._ignored_types_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == JavaHprofConfigWire.IGNORED_TYPES_WIRE) {
                self._ignored_types_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._ignored_types_offset = null;
        return result.value;
    }
};
pub const PerfEvents = struct {
    // nested enums
    pub const Counter = enum(i32) {
        UNKNOWN_COUNTER = 0,
        SW_CPU_CLOCK = 1,
        SW_PAGE_FAULTS = 2,
        SW_TASK_CLOCK = 3,
        SW_CONTEXT_SWITCHES = 4,
        SW_CPU_MIGRATIONS = 5,
        SW_PAGE_FAULTS_MIN = 6,
        SW_PAGE_FAULTS_MAJ = 7,
        SW_ALIGNMENT_FAULTS = 8,
        SW_EMULATION_FAULTS = 9,
        SW_DUMMY = 20,
        HW_CPU_CYCLES = 10,
        HW_INSTRUCTIONS = 11,
        HW_CACHE_REFERENCES = 12,
        HW_CACHE_MISSES = 13,
        HW_BRANCH_INSTRUCTIONS = 14,
        HW_BRANCH_MISSES = 15,
        HW_BUS_CYCLES = 16,
        HW_STALLED_CYCLES_FRONTEND = 17,
        HW_STALLED_CYCLES_BACKEND = 18,
        HW_REF_CPU_CYCLES = 19,
    };
    pub const PerfClock = enum(i32) {
        UNKNOWN_PERF_CLOCK = 0,
        PERF_CLOCK_REALTIME = 1,
        PERF_CLOCK_MONOTONIC = 2,
        PERF_CLOCK_MONOTONIC_RAW = 3,
        PERF_CLOCK_BOOTTIME = 4,
    };
    pub const EventModifier = enum(i32) {
        UNKNOWN_EVENT_MODIFIER = 0,
        EVENT_MODIFIER_COUNT_USERSPACE = 1,
        EVENT_MODIFIER_COUNT_KERNEL = 2,
        EVENT_MODIFIER_COUNT_HYPERVISOR = 3,
    };
    // nested structs
    const TimebaseWire = struct {
        const MODIFIERS_WIRE: gremlin.ProtoWireNumber = 12;
        const TIMESTAMP_CLOCK_WIRE: gremlin.ProtoWireNumber = 11;
        const NAME_WIRE: gremlin.ProtoWireNumber = 10;
        const FREQUENCY_WIRE: gremlin.ProtoWireNumber = 2;
        const PERIOD_WIRE: gremlin.ProtoWireNumber = 1;
        const POLL_PERIOD_MS_WIRE: gremlin.ProtoWireNumber = 6;
        const COUNTER_WIRE: gremlin.ProtoWireNumber = 4;
        const TRACEPOINT_WIRE: gremlin.ProtoWireNumber = 3;
        const RAW_EVENT_WIRE: gremlin.ProtoWireNumber = 5;
    };
    pub const Timebase = struct {
        // fields
        modifiers: ?[]const PerfEvents.EventModifier = null,
        timestamp_clock: PerfEvents.PerfClock = @enumFromInt(0),
        name: ?[]const u8 = null,
        frequency: u64 = 0,
        period: u64 = 0,
        poll_period_ms: u32 = 0,
        counter: PerfEvents.Counter = @enumFromInt(0),
        tracepoint: ?PerfEvents.Tracepoint = null,
        raw_event: ?PerfEvents.RawEvent = null,
        pub fn calcProtobufSize(self: *const PerfEvents.Timebase) usize {
            var res: usize = 0;
            if (self.modifiers) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    res += gremlin.sizes.sizeWireNumber(PerfEvents.TimebaseWire.MODIFIERS_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(arr[0]));
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeI32(@intFromEnum(v));
                    }
                    res += gremlin.sizes.sizeWireNumber(PerfEvents.TimebaseWire.MODIFIERS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
                }
            }
            if (@intFromEnum(self.timestamp_clock) != 0) {
                res += gremlin.sizes.sizeWireNumber(PerfEvents.TimebaseWire.TIMESTAMP_CLOCK_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.timestamp_clock));
            }
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(PerfEvents.TimebaseWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.frequency != 0) {
                res += gremlin.sizes.sizeWireNumber(PerfEvents.TimebaseWire.FREQUENCY_WIRE) + gremlin.sizes.sizeU64(self.frequency);
            }
            if (self.period != 0) {
                res += gremlin.sizes.sizeWireNumber(PerfEvents.TimebaseWire.PERIOD_WIRE) + gremlin.sizes.sizeU64(self.period);
            }
            if (self.poll_period_ms != 0) {
                res += gremlin.sizes.sizeWireNumber(PerfEvents.TimebaseWire.POLL_PERIOD_MS_WIRE) + gremlin.sizes.sizeU32(self.poll_period_ms);
            }
            if (@intFromEnum(self.counter) != 0) {
                res += gremlin.sizes.sizeWireNumber(PerfEvents.TimebaseWire.COUNTER_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.counter));
            }
            if (self.tracepoint) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(PerfEvents.TimebaseWire.TRACEPOINT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.raw_event) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(PerfEvents.TimebaseWire.RAW_EVENT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            return res;
        }
        pub fn encode(self: *const PerfEvents.Timebase, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const PerfEvents.Timebase, target: *gremlin.Writer) void {
            if (self.modifiers) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    target.appendInt32(PerfEvents.TimebaseWire.MODIFIERS_WIRE, @intFromEnum(arr[0]));
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeI32(@intFromEnum(v));
                    }
                    target.appendBytesTag(PerfEvents.TimebaseWire.MODIFIERS_WIRE, packed_size);
                    for (arr) |v| {
                        target.appendInt32WithoutTag(@intFromEnum(v));
                    }
                }
            }
            if (@intFromEnum(self.timestamp_clock) != 0) {
                target.appendInt32(PerfEvents.TimebaseWire.TIMESTAMP_CLOCK_WIRE, @intFromEnum(self.timestamp_clock));
            }
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(PerfEvents.TimebaseWire.NAME_WIRE, v);
                }
            }
            if (self.frequency != 0) {
                target.appendUint64(PerfEvents.TimebaseWire.FREQUENCY_WIRE, self.frequency);
            }
            if (self.period != 0) {
                target.appendUint64(PerfEvents.TimebaseWire.PERIOD_WIRE, self.period);
            }
            if (self.poll_period_ms != 0) {
                target.appendUint32(PerfEvents.TimebaseWire.POLL_PERIOD_MS_WIRE, self.poll_period_ms);
            }
            if (@intFromEnum(self.counter) != 0) {
                target.appendInt32(PerfEvents.TimebaseWire.COUNTER_WIRE, @intFromEnum(self.counter));
            }
            if (self.tracepoint) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(PerfEvents.TimebaseWire.TRACEPOINT_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.raw_event) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(PerfEvents.TimebaseWire.RAW_EVENT_WIRE, size);
                    v.encodeTo(target);
                }
            }
        }
    };
    pub const TimebaseReader = struct {
        buf: gremlin.Reader,
        _modifiers_offset: ?usize = null,
        _modifiers_last_offset: ?usize = null,
        _modifiers_packed: bool = false,
        _timestamp_clock: PerfEvents.PerfClock = @enumFromInt(0),
        _name: ?[]const u8 = null,
        _frequency: u64 = 0,
        _period: u64 = 0,
        _poll_period_ms: u32 = 0,
        _counter: PerfEvents.Counter = @enumFromInt(0),
        _tracepoint_buf: ?[]const u8 = null,
        _raw_event_buf: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!PerfEvents.TimebaseReader {
            const buf = gremlin.Reader.init(src);
            var res = PerfEvents.TimebaseReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    PerfEvents.TimebaseWire.MODIFIERS_WIRE => {
                        if (res._modifiers_offset == null) {
                            res._modifiers_offset = offset;
                        }
                        if (tag.wire == gremlin.ProtoWireType.bytes) {
                            res._modifiers_packed = true;
                            const length_result = try buf.readVarInt(offset);
                            res._modifiers_offset = offset + length_result.size;
                            res._modifiers_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                            offset = res._modifiers_last_offset.?;
                        } else {
                            const result = try buf.readInt32(offset);
                            offset += result.size;
                            res._modifiers_last_offset = offset;
                        }
                    },
                    PerfEvents.TimebaseWire.TIMESTAMP_CLOCK_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._timestamp_clock = @enumFromInt(result.value);
                    },
                    PerfEvents.TimebaseWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    PerfEvents.TimebaseWire.FREQUENCY_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._frequency = result.value;
                    },
                    PerfEvents.TimebaseWire.PERIOD_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._period = result.value;
                    },
                    PerfEvents.TimebaseWire.POLL_PERIOD_MS_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._poll_period_ms = result.value;
                    },
                    PerfEvents.TimebaseWire.COUNTER_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._counter = @enumFromInt(result.value);
                    },
                    PerfEvents.TimebaseWire.TRACEPOINT_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._tracepoint_buf = result.value;
                    },
                    PerfEvents.TimebaseWire.RAW_EVENT_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._raw_event_buf = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn modifiersNext(self: *PerfEvents.TimebaseReader) gremlin.Error!?PerfEvents.EventModifier {
            if (self._modifiers_offset == null) return null;
            const current_offset = self._modifiers_offset.?;
            if (current_offset >= self._modifiers_last_offset.?) {
                self._modifiers_offset = null;
                return null;
            }
            if (self._modifiers_packed) {
                const value_result = try self.buf.readInt32(current_offset);
                self._modifiers_offset = current_offset + value_result.size;
                if (self._modifiers_offset.? >= self._modifiers_last_offset.?) {
                    self._modifiers_offset = null;
                }
                return @enumFromInt(value_result.value);
            } else {
                const value_result = try self.buf.readInt32(current_offset);
                var next_offset = current_offset + value_result.size;
                const max_offset = self._modifiers_last_offset.?;
                // Search for the next occurrence of this field
                while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                    const next_tag = try self.buf.readTagAt(next_offset);
                    next_offset += next_tag.size;
                    if (next_tag.number == PerfEvents.TimebaseWire.MODIFIERS_WIRE) {
                        self._modifiers_offset = next_offset;
                        return @enumFromInt(value_result.value);
                    } else {
                        next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                    }
                }
                self._modifiers_offset = null;
                return @enumFromInt(value_result.value);
            }
        }
        pub inline fn getTimestampClock(self: *const PerfEvents.TimebaseReader) PerfEvents.PerfClock {
            return self._timestamp_clock;
        }
        pub inline fn getName(self: *const PerfEvents.TimebaseReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub inline fn getFrequency(self: *const PerfEvents.TimebaseReader) u64 {
            return self._frequency;
        }
        pub inline fn getPeriod(self: *const PerfEvents.TimebaseReader) u64 {
            return self._period;
        }
        pub inline fn getPollPeriodMs(self: *const PerfEvents.TimebaseReader) u32 {
            return self._poll_period_ms;
        }
        pub inline fn getCounter(self: *const PerfEvents.TimebaseReader) PerfEvents.Counter {
            return self._counter;
        }
        pub fn getTracepoint(self: *const PerfEvents.TimebaseReader) gremlin.Error!PerfEvents.TracepointReader {
            if (self._tracepoint_buf) |buf| {
                return try PerfEvents.TracepointReader.init(buf);
            }
            return try PerfEvents.TracepointReader.init(&[_]u8{});
        }
        pub fn getRawEvent(self: *const PerfEvents.TimebaseReader) gremlin.Error!PerfEvents.RawEventReader {
            if (self._raw_event_buf) |buf| {
                return try PerfEvents.RawEventReader.init(buf);
            }
            return try PerfEvents.RawEventReader.init(&[_]u8{});
        }
    };
    const TracepointWire = struct {
        const NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const FILTER_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const Tracepoint = struct {
        // fields
        name: ?[]const u8 = null,
        filter: ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const PerfEvents.Tracepoint) usize {
            var res: usize = 0;
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(PerfEvents.TracepointWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.filter) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(PerfEvents.TracepointWire.FILTER_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            return res;
        }
        pub fn encode(self: *const PerfEvents.Tracepoint, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const PerfEvents.Tracepoint, target: *gremlin.Writer) void {
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(PerfEvents.TracepointWire.NAME_WIRE, v);
                }
            }
            if (self.filter) |v| {
                if (v.len > 0) {
                    target.appendBytes(PerfEvents.TracepointWire.FILTER_WIRE, v);
                }
            }
        }
    };
    pub const TracepointReader = struct {
        buf: gremlin.Reader,
        _name: ?[]const u8 = null,
        _filter: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!PerfEvents.TracepointReader {
            const buf = gremlin.Reader.init(src);
            var res = PerfEvents.TracepointReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    PerfEvents.TracepointWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    PerfEvents.TracepointWire.FILTER_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._filter = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getName(self: *const PerfEvents.TracepointReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub inline fn getFilter(self: *const PerfEvents.TracepointReader) []const u8 {
            return self._filter orelse &[_]u8{};
        }
    };
    const RawEventWire = struct {
        const TYPE_WIRE: gremlin.ProtoWireNumber = 1;
        const CONFIG_WIRE: gremlin.ProtoWireNumber = 2;
        const CONFIG1_WIRE: gremlin.ProtoWireNumber = 3;
        const CONFIG2_WIRE: gremlin.ProtoWireNumber = 4;
    };
    pub const RawEvent = struct {
        // fields
        type: u32 = 0,
        config: u64 = 0,
        config1: u64 = 0,
        config2: u64 = 0,
        pub fn calcProtobufSize(self: *const PerfEvents.RawEvent) usize {
            var res: usize = 0;
            if (self.type != 0) {
                res += gremlin.sizes.sizeWireNumber(PerfEvents.RawEventWire.TYPE_WIRE) + gremlin.sizes.sizeU32(self.type);
            }
            if (self.config != 0) {
                res += gremlin.sizes.sizeWireNumber(PerfEvents.RawEventWire.CONFIG_WIRE) + gremlin.sizes.sizeU64(self.config);
            }
            if (self.config1 != 0) {
                res += gremlin.sizes.sizeWireNumber(PerfEvents.RawEventWire.CONFIG1_WIRE) + gremlin.sizes.sizeU64(self.config1);
            }
            if (self.config2 != 0) {
                res += gremlin.sizes.sizeWireNumber(PerfEvents.RawEventWire.CONFIG2_WIRE) + gremlin.sizes.sizeU64(self.config2);
            }
            return res;
        }
        pub fn encode(self: *const PerfEvents.RawEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const PerfEvents.RawEvent, target: *gremlin.Writer) void {
            if (self.type != 0) {
                target.appendUint32(PerfEvents.RawEventWire.TYPE_WIRE, self.type);
            }
            if (self.config != 0) {
                target.appendUint64(PerfEvents.RawEventWire.CONFIG_WIRE, self.config);
            }
            if (self.config1 != 0) {
                target.appendUint64(PerfEvents.RawEventWire.CONFIG1_WIRE, self.config1);
            }
            if (self.config2 != 0) {
                target.appendUint64(PerfEvents.RawEventWire.CONFIG2_WIRE, self.config2);
            }
        }
    };
    pub const RawEventReader = struct {
        buf: gremlin.Reader,
        _type: u32 = 0,
        _config: u64 = 0,
        _config1: u64 = 0,
        _config2: u64 = 0,
        pub fn init(src: []const u8) gremlin.Error!PerfEvents.RawEventReader {
            const buf = gremlin.Reader.init(src);
            var res = PerfEvents.RawEventReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    PerfEvents.RawEventWire.TYPE_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._type = result.value;
                    },
                    PerfEvents.RawEventWire.CONFIG_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._config = result.value;
                    },
                    PerfEvents.RawEventWire.CONFIG1_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._config1 = result.value;
                    },
                    PerfEvents.RawEventWire.CONFIG2_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._config2 = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getType(self: *const PerfEvents.RawEventReader) u32 {
            return self._type;
        }
        pub inline fn getConfig(self: *const PerfEvents.RawEventReader) u64 {
            return self._config;
        }
        pub inline fn getConfig1(self: *const PerfEvents.RawEventReader) u64 {
            return self._config1;
        }
        pub inline fn getConfig2(self: *const PerfEvents.RawEventReader) u64 {
            return self._config2;
        }
    };
    pub fn calcProtobufSize(_: *const PerfEvents) usize {
        return 0;
    }
    pub fn encode(self: *const PerfEvents, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(_: *const PerfEvents, _: *gremlin.Writer) void {}
};
pub const PerfEventsReader = struct {
    buf: gremlin.Reader,
    pub fn init(src: []const u8) gremlin.Error!PerfEventsReader {
        const buf = gremlin.Reader.init(src);
        return PerfEventsReader{ .buf = buf };
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
};
const FollowerEventWire = struct {
    const MODIFIERS_WIRE: gremlin.ProtoWireNumber = 5;
    const NAME_WIRE: gremlin.ProtoWireNumber = 4;
    const COUNTER_WIRE: gremlin.ProtoWireNumber = 1;
    const TRACEPOINT_WIRE: gremlin.ProtoWireNumber = 2;
    const RAW_EVENT_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const FollowerEvent = struct {
    // fields
    modifiers: ?[]const PerfEvents.EventModifier = null,
    name: ?[]const u8 = null,
    counter: PerfEvents.Counter = @enumFromInt(0),
    tracepoint: ?PerfEvents.Tracepoint = null,
    raw_event: ?PerfEvents.RawEvent = null,
    pub fn calcProtobufSize(self: *const FollowerEvent) usize {
        var res: usize = 0;
        if (self.modifiers) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(FollowerEventWire.MODIFIERS_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(arr[0]));
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(@intFromEnum(v));
                }
                res += gremlin.sizes.sizeWireNumber(FollowerEventWire.MODIFIERS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(FollowerEventWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (@intFromEnum(self.counter) != 0) {
            res += gremlin.sizes.sizeWireNumber(FollowerEventWire.COUNTER_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.counter));
        }
        if (self.tracepoint) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FollowerEventWire.TRACEPOINT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.raw_event) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FollowerEventWire.RAW_EVENT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const FollowerEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const FollowerEvent, target: *gremlin.Writer) void {
        if (self.modifiers) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt32(FollowerEventWire.MODIFIERS_WIRE, @intFromEnum(arr[0]));
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(@intFromEnum(v));
                }
                target.appendBytesTag(FollowerEventWire.MODIFIERS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt32WithoutTag(@intFromEnum(v));
                }
            }
        }
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(FollowerEventWire.NAME_WIRE, v);
            }
        }
        if (@intFromEnum(self.counter) != 0) {
            target.appendInt32(FollowerEventWire.COUNTER_WIRE, @intFromEnum(self.counter));
        }
        if (self.tracepoint) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FollowerEventWire.TRACEPOINT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.raw_event) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FollowerEventWire.RAW_EVENT_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const FollowerEventReader = struct {
    buf: gremlin.Reader,
    _modifiers_offset: ?usize = null,
    _modifiers_last_offset: ?usize = null,
    _modifiers_packed: bool = false,
    _name: ?[]const u8 = null,
    _counter: PerfEvents.Counter = @enumFromInt(0),
    _tracepoint_buf: ?[]const u8 = null,
    _raw_event_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!FollowerEventReader {
        const buf = gremlin.Reader.init(src);
        var res = FollowerEventReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                FollowerEventWire.MODIFIERS_WIRE => {
                    if (res._modifiers_offset == null) {
                        res._modifiers_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._modifiers_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._modifiers_offset = offset + length_result.size;
                        res._modifiers_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._modifiers_last_offset.?;
                    } else {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._modifiers_last_offset = offset;
                    }
                },
                FollowerEventWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                FollowerEventWire.COUNTER_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._counter = @enumFromInt(result.value);
                },
                FollowerEventWire.TRACEPOINT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._tracepoint_buf = result.value;
                },
                FollowerEventWire.RAW_EVENT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._raw_event_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn modifiersNext(self: *FollowerEventReader) gremlin.Error!?PerfEvents.EventModifier {
        if (self._modifiers_offset == null) return null;
        const current_offset = self._modifiers_offset.?;
        if (current_offset >= self._modifiers_last_offset.?) {
            self._modifiers_offset = null;
            return null;
        }
        if (self._modifiers_packed) {
            const value_result = try self.buf.readInt32(current_offset);
            self._modifiers_offset = current_offset + value_result.size;
            if (self._modifiers_offset.? >= self._modifiers_last_offset.?) {
                self._modifiers_offset = null;
            }
            return @enumFromInt(value_result.value);
        } else {
            const value_result = try self.buf.readInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._modifiers_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == FollowerEventWire.MODIFIERS_WIRE) {
                    self._modifiers_offset = next_offset;
                    return @enumFromInt(value_result.value);
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._modifiers_offset = null;
            return @enumFromInt(value_result.value);
        }
    }
    pub inline fn getName(self: *const FollowerEventReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub inline fn getCounter(self: *const FollowerEventReader) PerfEvents.Counter {
        return self._counter;
    }
    pub fn getTracepoint(self: *const FollowerEventReader) gremlin.Error!PerfEvents.TracepointReader {
        if (self._tracepoint_buf) |buf| {
            return try PerfEvents.TracepointReader.init(buf);
        }
        return try PerfEvents.TracepointReader.init(&[_]u8{});
    }
    pub fn getRawEvent(self: *const FollowerEventReader) gremlin.Error!PerfEvents.RawEventReader {
        if (self._raw_event_buf) |buf| {
            return try PerfEvents.RawEventReader.init(buf);
        }
        return try PerfEvents.RawEventReader.init(&[_]u8{});
    }
};
const PerfEventConfigWire = struct {
    const TIMEBASE_WIRE: gremlin.ProtoWireNumber = 15;
    const FOLLOWERS_WIRE: gremlin.ProtoWireNumber = 19;
    const CALLSTACK_SAMPLING_WIRE: gremlin.ProtoWireNumber = 16;
    const TARGET_CPU_WIRE: gremlin.ProtoWireNumber = 20;
    const RING_BUFFER_READ_PERIOD_MS_WIRE: gremlin.ProtoWireNumber = 8;
    const RING_BUFFER_PAGES_WIRE: gremlin.ProtoWireNumber = 3;
    const MAX_ENQUEUED_FOOTPRINT_KB_WIRE: gremlin.ProtoWireNumber = 17;
    const MAX_DAEMON_MEMORY_KB_WIRE: gremlin.ProtoWireNumber = 13;
    const REMOTE_DESCRIPTOR_TIMEOUT_MS_WIRE: gremlin.ProtoWireNumber = 9;
    const UNWIND_STATE_CLEAR_PERIOD_MS_WIRE: gremlin.ProtoWireNumber = 10;
    const TARGET_INSTALLED_BY_WIRE: gremlin.ProtoWireNumber = 18;
    const ALL_CPUS_WIRE: gremlin.ProtoWireNumber = 1;
    const SAMPLING_FREQUENCY_WIRE: gremlin.ProtoWireNumber = 2;
    const KERNEL_FRAMES_WIRE: gremlin.ProtoWireNumber = 12;
    const TARGET_PID_WIRE: gremlin.ProtoWireNumber = 4;
    const TARGET_CMDLINE_WIRE: gremlin.ProtoWireNumber = 5;
    const EXCLUDE_PID_WIRE: gremlin.ProtoWireNumber = 6;
    const EXCLUDE_CMDLINE_WIRE: gremlin.ProtoWireNumber = 7;
    const ADDITIONAL_CMDLINE_COUNT_WIRE: gremlin.ProtoWireNumber = 11;
};
pub const PerfEventConfig = struct {
    // nested enums
    pub const UnwindMode = enum(i32) {
        UNWIND_UNKNOWN = 0,
        UNWIND_SKIP = 1,
        UNWIND_DWARF = 2,
        UNWIND_FRAME_POINTER = 3,
    };
    // nested structs
    const CallstackSamplingWire = struct {
        const SCOPE_WIRE: gremlin.ProtoWireNumber = 1;
        const KERNEL_FRAMES_WIRE: gremlin.ProtoWireNumber = 2;
        const USER_FRAMES_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const CallstackSampling = struct {
        // fields
        scope: ?PerfEventConfig.Scope = null,
        kernel_frames: bool = false,
        user_frames: PerfEventConfig.UnwindMode = @enumFromInt(0),
        pub fn calcProtobufSize(self: *const PerfEventConfig.CallstackSampling) usize {
            var res: usize = 0;
            if (self.scope) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(PerfEventConfig.CallstackSamplingWire.SCOPE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.kernel_frames != false) {
                res += gremlin.sizes.sizeWireNumber(PerfEventConfig.CallstackSamplingWire.KERNEL_FRAMES_WIRE) + gremlin.sizes.sizeBool(self.kernel_frames);
            }
            if (@intFromEnum(self.user_frames) != 0) {
                res += gremlin.sizes.sizeWireNumber(PerfEventConfig.CallstackSamplingWire.USER_FRAMES_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.user_frames));
            }
            return res;
        }
        pub fn encode(self: *const PerfEventConfig.CallstackSampling, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const PerfEventConfig.CallstackSampling, target: *gremlin.Writer) void {
            if (self.scope) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(PerfEventConfig.CallstackSamplingWire.SCOPE_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.kernel_frames != false) {
                target.appendBool(PerfEventConfig.CallstackSamplingWire.KERNEL_FRAMES_WIRE, self.kernel_frames);
            }
            if (@intFromEnum(self.user_frames) != 0) {
                target.appendInt32(PerfEventConfig.CallstackSamplingWire.USER_FRAMES_WIRE, @intFromEnum(self.user_frames));
            }
        }
    };
    pub const CallstackSamplingReader = struct {
        buf: gremlin.Reader,
        _scope_buf: ?[]const u8 = null,
        _kernel_frames: bool = false,
        _user_frames: PerfEventConfig.UnwindMode = @enumFromInt(0),
        pub fn init(src: []const u8) gremlin.Error!PerfEventConfig.CallstackSamplingReader {
            const buf = gremlin.Reader.init(src);
            var res = PerfEventConfig.CallstackSamplingReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    PerfEventConfig.CallstackSamplingWire.SCOPE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._scope_buf = result.value;
                    },
                    PerfEventConfig.CallstackSamplingWire.KERNEL_FRAMES_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._kernel_frames = result.value;
                    },
                    PerfEventConfig.CallstackSamplingWire.USER_FRAMES_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._user_frames = @enumFromInt(result.value);
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn getScope(self: *const PerfEventConfig.CallstackSamplingReader) gremlin.Error!PerfEventConfig.ScopeReader {
            if (self._scope_buf) |buf| {
                return try PerfEventConfig.ScopeReader.init(buf);
            }
            return try PerfEventConfig.ScopeReader.init(&[_]u8{});
        }
        pub inline fn getKernelFrames(self: *const PerfEventConfig.CallstackSamplingReader) bool {
            return self._kernel_frames;
        }
        pub inline fn getUserFrames(self: *const PerfEventConfig.CallstackSamplingReader) PerfEventConfig.UnwindMode {
            return self._user_frames;
        }
    };
    const ScopeWire = struct {
        const TARGET_PID_WIRE: gremlin.ProtoWireNumber = 1;
        const TARGET_CMDLINE_WIRE: gremlin.ProtoWireNumber = 2;
        const EXCLUDE_PID_WIRE: gremlin.ProtoWireNumber = 3;
        const EXCLUDE_CMDLINE_WIRE: gremlin.ProtoWireNumber = 4;
        const ADDITIONAL_CMDLINE_COUNT_WIRE: gremlin.ProtoWireNumber = 5;
        const PROCESS_SHARD_COUNT_WIRE: gremlin.ProtoWireNumber = 6;
    };
    pub const Scope = struct {
        // fields
        target_pid: ?[]const i32 = null,
        target_cmdline: ?[]const ?[]const u8 = null,
        exclude_pid: ?[]const i32 = null,
        exclude_cmdline: ?[]const ?[]const u8 = null,
        additional_cmdline_count: u32 = 0,
        process_shard_count: u32 = 0,
        pub fn calcProtobufSize(self: *const PerfEventConfig.Scope) usize {
            var res: usize = 0;
            if (self.target_pid) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    res += gremlin.sizes.sizeWireNumber(PerfEventConfig.ScopeWire.TARGET_PID_WIRE) + gremlin.sizes.sizeI32(arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeI32(v);
                    }
                    res += gremlin.sizes.sizeWireNumber(PerfEventConfig.ScopeWire.TARGET_PID_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
                }
            }
            if (self.target_cmdline) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(PerfEventConfig.ScopeWire.TARGET_CMDLINE_WIRE);
                    if (maybe_v) |v| {
                        res += gremlin.sizes.sizeUsize(v.len) + v.len;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.exclude_pid) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    res += gremlin.sizes.sizeWireNumber(PerfEventConfig.ScopeWire.EXCLUDE_PID_WIRE) + gremlin.sizes.sizeI32(arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeI32(v);
                    }
                    res += gremlin.sizes.sizeWireNumber(PerfEventConfig.ScopeWire.EXCLUDE_PID_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
                }
            }
            if (self.exclude_cmdline) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(PerfEventConfig.ScopeWire.EXCLUDE_CMDLINE_WIRE);
                    if (maybe_v) |v| {
                        res += gremlin.sizes.sizeUsize(v.len) + v.len;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.additional_cmdline_count != 0) {
                res += gremlin.sizes.sizeWireNumber(PerfEventConfig.ScopeWire.ADDITIONAL_CMDLINE_COUNT_WIRE) + gremlin.sizes.sizeU32(self.additional_cmdline_count);
            }
            if (self.process_shard_count != 0) {
                res += gremlin.sizes.sizeWireNumber(PerfEventConfig.ScopeWire.PROCESS_SHARD_COUNT_WIRE) + gremlin.sizes.sizeU32(self.process_shard_count);
            }
            return res;
        }
        pub fn encode(self: *const PerfEventConfig.Scope, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const PerfEventConfig.Scope, target: *gremlin.Writer) void {
            if (self.target_pid) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    target.appendInt32(PerfEventConfig.ScopeWire.TARGET_PID_WIRE, arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeI32(v);
                    }
                    target.appendBytesTag(PerfEventConfig.ScopeWire.TARGET_PID_WIRE, packed_size);
                    for (arr) |v| {
                        target.appendInt32WithoutTag(v);
                    }
                }
            }
            if (self.target_cmdline) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        target.appendBytes(PerfEventConfig.ScopeWire.TARGET_CMDLINE_WIRE, v);
                    } else {
                        target.appendBytesTag(PerfEventConfig.ScopeWire.TARGET_CMDLINE_WIRE, 0);
                    }
                }
            }
            if (self.exclude_pid) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    target.appendInt32(PerfEventConfig.ScopeWire.EXCLUDE_PID_WIRE, arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeI32(v);
                    }
                    target.appendBytesTag(PerfEventConfig.ScopeWire.EXCLUDE_PID_WIRE, packed_size);
                    for (arr) |v| {
                        target.appendInt32WithoutTag(v);
                    }
                }
            }
            if (self.exclude_cmdline) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        target.appendBytes(PerfEventConfig.ScopeWire.EXCLUDE_CMDLINE_WIRE, v);
                    } else {
                        target.appendBytesTag(PerfEventConfig.ScopeWire.EXCLUDE_CMDLINE_WIRE, 0);
                    }
                }
            }
            if (self.additional_cmdline_count != 0) {
                target.appendUint32(PerfEventConfig.ScopeWire.ADDITIONAL_CMDLINE_COUNT_WIRE, self.additional_cmdline_count);
            }
            if (self.process_shard_count != 0) {
                target.appendUint32(PerfEventConfig.ScopeWire.PROCESS_SHARD_COUNT_WIRE, self.process_shard_count);
            }
        }
    };
    pub const ScopeReader = struct {
        buf: gremlin.Reader,
        _target_pid_offset: ?usize = null,
        _target_pid_last_offset: ?usize = null,
        _target_pid_packed: bool = false,
        _target_cmdline_offset: ?usize = null,
        _target_cmdline_last_offset: ?usize = null,
        _target_cmdline_cnt: usize = 0,
        _exclude_pid_offset: ?usize = null,
        _exclude_pid_last_offset: ?usize = null,
        _exclude_pid_packed: bool = false,
        _exclude_cmdline_offset: ?usize = null,
        _exclude_cmdline_last_offset: ?usize = null,
        _exclude_cmdline_cnt: usize = 0,
        _additional_cmdline_count: u32 = 0,
        _process_shard_count: u32 = 0,
        pub fn init(src: []const u8) gremlin.Error!PerfEventConfig.ScopeReader {
            const buf = gremlin.Reader.init(src);
            var res = PerfEventConfig.ScopeReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    PerfEventConfig.ScopeWire.TARGET_PID_WIRE => {
                        if (res._target_pid_offset == null) {
                            res._target_pid_offset = offset;
                        }
                        if (tag.wire == gremlin.ProtoWireType.bytes) {
                            res._target_pid_packed = true;
                            const length_result = try buf.readVarInt(offset);
                            res._target_pid_offset = offset + length_result.size;
                            res._target_pid_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                            offset = res._target_pid_last_offset.?;
                        } else {
                            const result = try buf.readInt32(offset);
                            offset += result.size;
                            res._target_pid_last_offset = offset;
                        }
                    },
                    PerfEventConfig.ScopeWire.TARGET_CMDLINE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._target_cmdline_offset == null) {
                            res._target_cmdline_offset = offset - result.size;
                        }
                        res._target_cmdline_last_offset = offset;
                        res._target_cmdline_cnt += 1;
                    },
                    PerfEventConfig.ScopeWire.EXCLUDE_PID_WIRE => {
                        if (res._exclude_pid_offset == null) {
                            res._exclude_pid_offset = offset;
                        }
                        if (tag.wire == gremlin.ProtoWireType.bytes) {
                            res._exclude_pid_packed = true;
                            const length_result = try buf.readVarInt(offset);
                            res._exclude_pid_offset = offset + length_result.size;
                            res._exclude_pid_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                            offset = res._exclude_pid_last_offset.?;
                        } else {
                            const result = try buf.readInt32(offset);
                            offset += result.size;
                            res._exclude_pid_last_offset = offset;
                        }
                    },
                    PerfEventConfig.ScopeWire.EXCLUDE_CMDLINE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._exclude_cmdline_offset == null) {
                            res._exclude_cmdline_offset = offset - result.size;
                        }
                        res._exclude_cmdline_last_offset = offset;
                        res._exclude_cmdline_cnt += 1;
                    },
                    PerfEventConfig.ScopeWire.ADDITIONAL_CMDLINE_COUNT_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._additional_cmdline_count = result.value;
                    },
                    PerfEventConfig.ScopeWire.PROCESS_SHARD_COUNT_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._process_shard_count = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn targetPidNext(self: *PerfEventConfig.ScopeReader) gremlin.Error!?i32 {
            if (self._target_pid_offset == null) return null;
            const current_offset = self._target_pid_offset.?;
            if (current_offset >= self._target_pid_last_offset.?) {
                self._target_pid_offset = null;
                return null;
            }
            if (self._target_pid_packed) {
                const value_result = try self.buf.readInt32(current_offset);
                self._target_pid_offset = current_offset + value_result.size;
                if (self._target_pid_offset.? >= self._target_pid_last_offset.?) {
                    self._target_pid_offset = null;
                }
                return value_result.value;
            } else {
                const value_result = try self.buf.readInt32(current_offset);
                var next_offset = current_offset + value_result.size;
                const max_offset = self._target_pid_last_offset.?;
                // Search for the next occurrence of this field
                while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                    const next_tag = try self.buf.readTagAt(next_offset);
                    next_offset += next_tag.size;
                    if (next_tag.number == PerfEventConfig.ScopeWire.TARGET_PID_WIRE) {
                        self._target_pid_offset = next_offset;
                        return value_result.value;
                    } else {
                        next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                    }
                }
                self._target_pid_offset = null;
                return value_result.value;
            }
        }
        pub fn targetCmdlineCount(self: *const PerfEventConfig.ScopeReader) usize {
            return self._target_cmdline_cnt;
        }
        pub fn targetCmdlineNext(self: *PerfEventConfig.ScopeReader) ?[]const u8 {
            if (self._target_cmdline_offset == null) return null;
            const current_offset = self._target_cmdline_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            if (self._target_cmdline_last_offset != null and current_offset >= self._target_cmdline_last_offset.?) {
                self._target_cmdline_offset = null;
                return result.value;
            }
            if (self._target_cmdline_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._target_cmdline_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == PerfEventConfig.ScopeWire.TARGET_CMDLINE_WIRE) {
                    self._target_cmdline_offset = next_offset;
                    return result.value;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._target_cmdline_offset = null;
            return result.value;
        }
        pub fn excludePidNext(self: *PerfEventConfig.ScopeReader) gremlin.Error!?i32 {
            if (self._exclude_pid_offset == null) return null;
            const current_offset = self._exclude_pid_offset.?;
            if (current_offset >= self._exclude_pid_last_offset.?) {
                self._exclude_pid_offset = null;
                return null;
            }
            if (self._exclude_pid_packed) {
                const value_result = try self.buf.readInt32(current_offset);
                self._exclude_pid_offset = current_offset + value_result.size;
                if (self._exclude_pid_offset.? >= self._exclude_pid_last_offset.?) {
                    self._exclude_pid_offset = null;
                }
                return value_result.value;
            } else {
                const value_result = try self.buf.readInt32(current_offset);
                var next_offset = current_offset + value_result.size;
                const max_offset = self._exclude_pid_last_offset.?;
                // Search for the next occurrence of this field
                while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                    const next_tag = try self.buf.readTagAt(next_offset);
                    next_offset += next_tag.size;
                    if (next_tag.number == PerfEventConfig.ScopeWire.EXCLUDE_PID_WIRE) {
                        self._exclude_pid_offset = next_offset;
                        return value_result.value;
                    } else {
                        next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                    }
                }
                self._exclude_pid_offset = null;
                return value_result.value;
            }
        }
        pub fn excludeCmdlineCount(self: *const PerfEventConfig.ScopeReader) usize {
            return self._exclude_cmdline_cnt;
        }
        pub fn excludeCmdlineNext(self: *PerfEventConfig.ScopeReader) ?[]const u8 {
            if (self._exclude_cmdline_offset == null) return null;
            const current_offset = self._exclude_cmdline_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            if (self._exclude_cmdline_last_offset != null and current_offset >= self._exclude_cmdline_last_offset.?) {
                self._exclude_cmdline_offset = null;
                return result.value;
            }
            if (self._exclude_cmdline_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._exclude_cmdline_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == PerfEventConfig.ScopeWire.EXCLUDE_CMDLINE_WIRE) {
                    self._exclude_cmdline_offset = next_offset;
                    return result.value;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._exclude_cmdline_offset = null;
            return result.value;
        }
        pub inline fn getAdditionalCmdlineCount(self: *const PerfEventConfig.ScopeReader) u32 {
            return self._additional_cmdline_count;
        }
        pub inline fn getProcessShardCount(self: *const PerfEventConfig.ScopeReader) u32 {
            return self._process_shard_count;
        }
    };
    // fields
    timebase: ?PerfEvents.Timebase = null,
    followers: ?[]const ?FollowerEvent = null,
    callstack_sampling: ?PerfEventConfig.CallstackSampling = null,
    target_cpu: ?[]const u32 = null,
    ring_buffer_read_period_ms: u32 = 0,
    ring_buffer_pages: u32 = 0,
    max_enqueued_footprint_kb: u64 = 0,
    max_daemon_memory_kb: u32 = 0,
    remote_descriptor_timeout_ms: u32 = 0,
    unwind_state_clear_period_ms: u32 = 0,
    target_installed_by: ?[]const ?[]const u8 = null,
    all_cpus: bool = false,
    sampling_frequency: u32 = 0,
    kernel_frames: bool = false,
    target_pid: ?[]const i32 = null,
    target_cmdline: ?[]const ?[]const u8 = null,
    exclude_pid: ?[]const i32 = null,
    exclude_cmdline: ?[]const ?[]const u8 = null,
    additional_cmdline_count: u32 = 0,
    pub fn calcProtobufSize(self: *const PerfEventConfig) usize {
        var res: usize = 0;
        if (self.timebase) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(PerfEventConfigWire.TIMEBASE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.followers) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(PerfEventConfigWire.FOLLOWERS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.callstack_sampling) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(PerfEventConfigWire.CALLSTACK_SAMPLING_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.target_cpu) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(PerfEventConfigWire.TARGET_CPU_WIRE) + gremlin.sizes.sizeU32(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU32(v);
                }
                res += gremlin.sizes.sizeWireNumber(PerfEventConfigWire.TARGET_CPU_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.ring_buffer_read_period_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(PerfEventConfigWire.RING_BUFFER_READ_PERIOD_MS_WIRE) + gremlin.sizes.sizeU32(self.ring_buffer_read_period_ms);
        }
        if (self.ring_buffer_pages != 0) {
            res += gremlin.sizes.sizeWireNumber(PerfEventConfigWire.RING_BUFFER_PAGES_WIRE) + gremlin.sizes.sizeU32(self.ring_buffer_pages);
        }
        if (self.max_enqueued_footprint_kb != 0) {
            res += gremlin.sizes.sizeWireNumber(PerfEventConfigWire.MAX_ENQUEUED_FOOTPRINT_KB_WIRE) + gremlin.sizes.sizeU64(self.max_enqueued_footprint_kb);
        }
        if (self.max_daemon_memory_kb != 0) {
            res += gremlin.sizes.sizeWireNumber(PerfEventConfigWire.MAX_DAEMON_MEMORY_KB_WIRE) + gremlin.sizes.sizeU32(self.max_daemon_memory_kb);
        }
        if (self.remote_descriptor_timeout_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(PerfEventConfigWire.REMOTE_DESCRIPTOR_TIMEOUT_MS_WIRE) + gremlin.sizes.sizeU32(self.remote_descriptor_timeout_ms);
        }
        if (self.unwind_state_clear_period_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(PerfEventConfigWire.UNWIND_STATE_CLEAR_PERIOD_MS_WIRE) + gremlin.sizes.sizeU32(self.unwind_state_clear_period_ms);
        }
        if (self.target_installed_by) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(PerfEventConfigWire.TARGET_INSTALLED_BY_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.all_cpus != false) {
            res += gremlin.sizes.sizeWireNumber(PerfEventConfigWire.ALL_CPUS_WIRE) + gremlin.sizes.sizeBool(self.all_cpus);
        }
        if (self.sampling_frequency != 0) {
            res += gremlin.sizes.sizeWireNumber(PerfEventConfigWire.SAMPLING_FREQUENCY_WIRE) + gremlin.sizes.sizeU32(self.sampling_frequency);
        }
        if (self.kernel_frames != false) {
            res += gremlin.sizes.sizeWireNumber(PerfEventConfigWire.KERNEL_FRAMES_WIRE) + gremlin.sizes.sizeBool(self.kernel_frames);
        }
        if (self.target_pid) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(PerfEventConfigWire.TARGET_PID_WIRE) + gremlin.sizes.sizeI32(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(v);
                }
                res += gremlin.sizes.sizeWireNumber(PerfEventConfigWire.TARGET_PID_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.target_cmdline) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(PerfEventConfigWire.TARGET_CMDLINE_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.exclude_pid) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(PerfEventConfigWire.EXCLUDE_PID_WIRE) + gremlin.sizes.sizeI32(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(v);
                }
                res += gremlin.sizes.sizeWireNumber(PerfEventConfigWire.EXCLUDE_PID_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.exclude_cmdline) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(PerfEventConfigWire.EXCLUDE_CMDLINE_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.additional_cmdline_count != 0) {
            res += gremlin.sizes.sizeWireNumber(PerfEventConfigWire.ADDITIONAL_CMDLINE_COUNT_WIRE) + gremlin.sizes.sizeU32(self.additional_cmdline_count);
        }
        return res;
    }
    pub fn encode(self: *const PerfEventConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const PerfEventConfig, target: *gremlin.Writer) void {
        if (self.timebase) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(PerfEventConfigWire.TIMEBASE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.followers) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(PerfEventConfigWire.FOLLOWERS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(PerfEventConfigWire.FOLLOWERS_WIRE, 0);
                }
            }
        }
        if (self.callstack_sampling) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(PerfEventConfigWire.CALLSTACK_SAMPLING_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.target_cpu) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint32(PerfEventConfigWire.TARGET_CPU_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU32(v);
                }
                target.appendBytesTag(PerfEventConfigWire.TARGET_CPU_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint32WithoutTag(v);
                }
            }
        }
        if (self.ring_buffer_read_period_ms != 0) {
            target.appendUint32(PerfEventConfigWire.RING_BUFFER_READ_PERIOD_MS_WIRE, self.ring_buffer_read_period_ms);
        }
        if (self.ring_buffer_pages != 0) {
            target.appendUint32(PerfEventConfigWire.RING_BUFFER_PAGES_WIRE, self.ring_buffer_pages);
        }
        if (self.max_enqueued_footprint_kb != 0) {
            target.appendUint64(PerfEventConfigWire.MAX_ENQUEUED_FOOTPRINT_KB_WIRE, self.max_enqueued_footprint_kb);
        }
        if (self.max_daemon_memory_kb != 0) {
            target.appendUint32(PerfEventConfigWire.MAX_DAEMON_MEMORY_KB_WIRE, self.max_daemon_memory_kb);
        }
        if (self.remote_descriptor_timeout_ms != 0) {
            target.appendUint32(PerfEventConfigWire.REMOTE_DESCRIPTOR_TIMEOUT_MS_WIRE, self.remote_descriptor_timeout_ms);
        }
        if (self.unwind_state_clear_period_ms != 0) {
            target.appendUint32(PerfEventConfigWire.UNWIND_STATE_CLEAR_PERIOD_MS_WIRE, self.unwind_state_clear_period_ms);
        }
        if (self.target_installed_by) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(PerfEventConfigWire.TARGET_INSTALLED_BY_WIRE, v);
                } else {
                    target.appendBytesTag(PerfEventConfigWire.TARGET_INSTALLED_BY_WIRE, 0);
                }
            }
        }
        if (self.all_cpus != false) {
            target.appendBool(PerfEventConfigWire.ALL_CPUS_WIRE, self.all_cpus);
        }
        if (self.sampling_frequency != 0) {
            target.appendUint32(PerfEventConfigWire.SAMPLING_FREQUENCY_WIRE, self.sampling_frequency);
        }
        if (self.kernel_frames != false) {
            target.appendBool(PerfEventConfigWire.KERNEL_FRAMES_WIRE, self.kernel_frames);
        }
        if (self.target_pid) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt32(PerfEventConfigWire.TARGET_PID_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(v);
                }
                target.appendBytesTag(PerfEventConfigWire.TARGET_PID_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt32WithoutTag(v);
                }
            }
        }
        if (self.target_cmdline) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(PerfEventConfigWire.TARGET_CMDLINE_WIRE, v);
                } else {
                    target.appendBytesTag(PerfEventConfigWire.TARGET_CMDLINE_WIRE, 0);
                }
            }
        }
        if (self.exclude_pid) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt32(PerfEventConfigWire.EXCLUDE_PID_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(v);
                }
                target.appendBytesTag(PerfEventConfigWire.EXCLUDE_PID_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt32WithoutTag(v);
                }
            }
        }
        if (self.exclude_cmdline) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(PerfEventConfigWire.EXCLUDE_CMDLINE_WIRE, v);
                } else {
                    target.appendBytesTag(PerfEventConfigWire.EXCLUDE_CMDLINE_WIRE, 0);
                }
            }
        }
        if (self.additional_cmdline_count != 0) {
            target.appendUint32(PerfEventConfigWire.ADDITIONAL_CMDLINE_COUNT_WIRE, self.additional_cmdline_count);
        }
    }
};
pub const PerfEventConfigReader = struct {
    buf: gremlin.Reader,
    _timebase_buf: ?[]const u8 = null,
    _followers_offset: ?usize = null,
    _followers_last_offset: ?usize = null,
    _followers_cnt: usize = 0,
    _callstack_sampling_buf: ?[]const u8 = null,
    _target_cpu_offset: ?usize = null,
    _target_cpu_last_offset: ?usize = null,
    _target_cpu_packed: bool = false,
    _ring_buffer_read_period_ms: u32 = 0,
    _ring_buffer_pages: u32 = 0,
    _max_enqueued_footprint_kb: u64 = 0,
    _max_daemon_memory_kb: u32 = 0,
    _remote_descriptor_timeout_ms: u32 = 0,
    _unwind_state_clear_period_ms: u32 = 0,
    _target_installed_by_offset: ?usize = null,
    _target_installed_by_last_offset: ?usize = null,
    _target_installed_by_cnt: usize = 0,
    _all_cpus: bool = false,
    _sampling_frequency: u32 = 0,
    _kernel_frames: bool = false,
    _target_pid_offset: ?usize = null,
    _target_pid_last_offset: ?usize = null,
    _target_pid_packed: bool = false,
    _target_cmdline_offset: ?usize = null,
    _target_cmdline_last_offset: ?usize = null,
    _target_cmdline_cnt: usize = 0,
    _exclude_pid_offset: ?usize = null,
    _exclude_pid_last_offset: ?usize = null,
    _exclude_pid_packed: bool = false,
    _exclude_cmdline_offset: ?usize = null,
    _exclude_cmdline_last_offset: ?usize = null,
    _exclude_cmdline_cnt: usize = 0,
    _additional_cmdline_count: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!PerfEventConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = PerfEventConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                PerfEventConfigWire.TIMEBASE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._timebase_buf = result.value;
                },
                PerfEventConfigWire.FOLLOWERS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._followers_offset == null) {
                        res._followers_offset = offset - result.size;
                    }
                    res._followers_last_offset = offset;
                    res._followers_cnt += 1;
                },
                PerfEventConfigWire.CALLSTACK_SAMPLING_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._callstack_sampling_buf = result.value;
                },
                PerfEventConfigWire.TARGET_CPU_WIRE => {
                    if (res._target_cpu_offset == null) {
                        res._target_cpu_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._target_cpu_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._target_cpu_offset = offset + length_result.size;
                        res._target_cpu_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._target_cpu_last_offset.?;
                    } else {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._target_cpu_last_offset = offset;
                    }
                },
                PerfEventConfigWire.RING_BUFFER_READ_PERIOD_MS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._ring_buffer_read_period_ms = result.value;
                },
                PerfEventConfigWire.RING_BUFFER_PAGES_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._ring_buffer_pages = result.value;
                },
                PerfEventConfigWire.MAX_ENQUEUED_FOOTPRINT_KB_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._max_enqueued_footprint_kb = result.value;
                },
                PerfEventConfigWire.MAX_DAEMON_MEMORY_KB_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._max_daemon_memory_kb = result.value;
                },
                PerfEventConfigWire.REMOTE_DESCRIPTOR_TIMEOUT_MS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._remote_descriptor_timeout_ms = result.value;
                },
                PerfEventConfigWire.UNWIND_STATE_CLEAR_PERIOD_MS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._unwind_state_clear_period_ms = result.value;
                },
                PerfEventConfigWire.TARGET_INSTALLED_BY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._target_installed_by_offset == null) {
                        res._target_installed_by_offset = offset - result.size;
                    }
                    res._target_installed_by_last_offset = offset;
                    res._target_installed_by_cnt += 1;
                },
                PerfEventConfigWire.ALL_CPUS_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._all_cpus = result.value;
                },
                PerfEventConfigWire.SAMPLING_FREQUENCY_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._sampling_frequency = result.value;
                },
                PerfEventConfigWire.KERNEL_FRAMES_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._kernel_frames = result.value;
                },
                PerfEventConfigWire.TARGET_PID_WIRE => {
                    if (res._target_pid_offset == null) {
                        res._target_pid_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._target_pid_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._target_pid_offset = offset + length_result.size;
                        res._target_pid_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._target_pid_last_offset.?;
                    } else {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._target_pid_last_offset = offset;
                    }
                },
                PerfEventConfigWire.TARGET_CMDLINE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._target_cmdline_offset == null) {
                        res._target_cmdline_offset = offset - result.size;
                    }
                    res._target_cmdline_last_offset = offset;
                    res._target_cmdline_cnt += 1;
                },
                PerfEventConfigWire.EXCLUDE_PID_WIRE => {
                    if (res._exclude_pid_offset == null) {
                        res._exclude_pid_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._exclude_pid_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._exclude_pid_offset = offset + length_result.size;
                        res._exclude_pid_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._exclude_pid_last_offset.?;
                    } else {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._exclude_pid_last_offset = offset;
                    }
                },
                PerfEventConfigWire.EXCLUDE_CMDLINE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._exclude_cmdline_offset == null) {
                        res._exclude_cmdline_offset = offset - result.size;
                    }
                    res._exclude_cmdline_last_offset = offset;
                    res._exclude_cmdline_cnt += 1;
                },
                PerfEventConfigWire.ADDITIONAL_CMDLINE_COUNT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._additional_cmdline_count = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getTimebase(self: *const PerfEventConfigReader) gremlin.Error!PerfEvents.TimebaseReader {
        if (self._timebase_buf) |buf| {
            return try PerfEvents.TimebaseReader.init(buf);
        }
        return try PerfEvents.TimebaseReader.init(&[_]u8{});
    }
    pub fn followersCount(self: *const PerfEventConfigReader) usize {
        return self._followers_cnt;
    }
    pub fn followersNext(self: *PerfEventConfigReader) ?FollowerEventReader {
        if (self._followers_offset == null) return null;
        const current_offset = self._followers_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = FollowerEventReader.init(result.value) catch return null;
        if (self._followers_last_offset != null and current_offset >= self._followers_last_offset.?) {
            self._followers_offset = null;
            return msg;
        }
        if (self._followers_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._followers_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == PerfEventConfigWire.FOLLOWERS_WIRE) {
                self._followers_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._followers_offset = null;
        return msg;
    }
    pub fn getCallstackSampling(self: *const PerfEventConfigReader) gremlin.Error!PerfEventConfig.CallstackSamplingReader {
        if (self._callstack_sampling_buf) |buf| {
            return try PerfEventConfig.CallstackSamplingReader.init(buf);
        }
        return try PerfEventConfig.CallstackSamplingReader.init(&[_]u8{});
    }
    pub fn targetCpuNext(self: *PerfEventConfigReader) gremlin.Error!?u32 {
        if (self._target_cpu_offset == null) return null;
        const current_offset = self._target_cpu_offset.?;
        if (current_offset >= self._target_cpu_last_offset.?) {
            self._target_cpu_offset = null;
            return null;
        }
        if (self._target_cpu_packed) {
            const value_result = try self.buf.readUInt32(current_offset);
            self._target_cpu_offset = current_offset + value_result.size;
            if (self._target_cpu_offset.? >= self._target_cpu_last_offset.?) {
                self._target_cpu_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._target_cpu_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == PerfEventConfigWire.TARGET_CPU_WIRE) {
                    self._target_cpu_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._target_cpu_offset = null;
            return value_result.value;
        }
    }
    pub inline fn getRingBufferReadPeriodMs(self: *const PerfEventConfigReader) u32 {
        return self._ring_buffer_read_period_ms;
    }
    pub inline fn getRingBufferPages(self: *const PerfEventConfigReader) u32 {
        return self._ring_buffer_pages;
    }
    pub inline fn getMaxEnqueuedFootprintKb(self: *const PerfEventConfigReader) u64 {
        return self._max_enqueued_footprint_kb;
    }
    pub inline fn getMaxDaemonMemoryKb(self: *const PerfEventConfigReader) u32 {
        return self._max_daemon_memory_kb;
    }
    pub inline fn getRemoteDescriptorTimeoutMs(self: *const PerfEventConfigReader) u32 {
        return self._remote_descriptor_timeout_ms;
    }
    pub inline fn getUnwindStateClearPeriodMs(self: *const PerfEventConfigReader) u32 {
        return self._unwind_state_clear_period_ms;
    }
    pub fn targetInstalledByCount(self: *const PerfEventConfigReader) usize {
        return self._target_installed_by_cnt;
    }
    pub fn targetInstalledByNext(self: *PerfEventConfigReader) ?[]const u8 {
        if (self._target_installed_by_offset == null) return null;
        const current_offset = self._target_installed_by_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._target_installed_by_last_offset != null and current_offset >= self._target_installed_by_last_offset.?) {
            self._target_installed_by_offset = null;
            return result.value;
        }
        if (self._target_installed_by_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._target_installed_by_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == PerfEventConfigWire.TARGET_INSTALLED_BY_WIRE) {
                self._target_installed_by_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._target_installed_by_offset = null;
        return result.value;
    }
    pub inline fn getAllCpus(self: *const PerfEventConfigReader) bool {
        return self._all_cpus;
    }
    pub inline fn getSamplingFrequency(self: *const PerfEventConfigReader) u32 {
        return self._sampling_frequency;
    }
    pub inline fn getKernelFrames(self: *const PerfEventConfigReader) bool {
        return self._kernel_frames;
    }
    pub fn targetPidNext(self: *PerfEventConfigReader) gremlin.Error!?i32 {
        if (self._target_pid_offset == null) return null;
        const current_offset = self._target_pid_offset.?;
        if (current_offset >= self._target_pid_last_offset.?) {
            self._target_pid_offset = null;
            return null;
        }
        if (self._target_pid_packed) {
            const value_result = try self.buf.readInt32(current_offset);
            self._target_pid_offset = current_offset + value_result.size;
            if (self._target_pid_offset.? >= self._target_pid_last_offset.?) {
                self._target_pid_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._target_pid_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == PerfEventConfigWire.TARGET_PID_WIRE) {
                    self._target_pid_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._target_pid_offset = null;
            return value_result.value;
        }
    }
    pub fn targetCmdlineCount(self: *const PerfEventConfigReader) usize {
        return self._target_cmdline_cnt;
    }
    pub fn targetCmdlineNext(self: *PerfEventConfigReader) ?[]const u8 {
        if (self._target_cmdline_offset == null) return null;
        const current_offset = self._target_cmdline_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._target_cmdline_last_offset != null and current_offset >= self._target_cmdline_last_offset.?) {
            self._target_cmdline_offset = null;
            return result.value;
        }
        if (self._target_cmdline_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._target_cmdline_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == PerfEventConfigWire.TARGET_CMDLINE_WIRE) {
                self._target_cmdline_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._target_cmdline_offset = null;
        return result.value;
    }
    pub fn excludePidNext(self: *PerfEventConfigReader) gremlin.Error!?i32 {
        if (self._exclude_pid_offset == null) return null;
        const current_offset = self._exclude_pid_offset.?;
        if (current_offset >= self._exclude_pid_last_offset.?) {
            self._exclude_pid_offset = null;
            return null;
        }
        if (self._exclude_pid_packed) {
            const value_result = try self.buf.readInt32(current_offset);
            self._exclude_pid_offset = current_offset + value_result.size;
            if (self._exclude_pid_offset.? >= self._exclude_pid_last_offset.?) {
                self._exclude_pid_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._exclude_pid_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == PerfEventConfigWire.EXCLUDE_PID_WIRE) {
                    self._exclude_pid_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._exclude_pid_offset = null;
            return value_result.value;
        }
    }
    pub fn excludeCmdlineCount(self: *const PerfEventConfigReader) usize {
        return self._exclude_cmdline_cnt;
    }
    pub fn excludeCmdlineNext(self: *PerfEventConfigReader) ?[]const u8 {
        if (self._exclude_cmdline_offset == null) return null;
        const current_offset = self._exclude_cmdline_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._exclude_cmdline_last_offset != null and current_offset >= self._exclude_cmdline_last_offset.?) {
            self._exclude_cmdline_offset = null;
            return result.value;
        }
        if (self._exclude_cmdline_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._exclude_cmdline_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == PerfEventConfigWire.EXCLUDE_CMDLINE_WIRE) {
                self._exclude_cmdline_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._exclude_cmdline_offset = null;
        return result.value;
    }
    pub inline fn getAdditionalCmdlineCount(self: *const PerfEventConfigReader) u32 {
        return self._additional_cmdline_count;
    }
};
const StatsdTracingConfigWire = struct {
    const PUSH_ATOM_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const RAW_PUSH_ATOM_ID_WIRE: gremlin.ProtoWireNumber = 2;
    const PULL_CONFIG_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const StatsdTracingConfig = struct {
    // fields
    push_atom_id: ?[]const AtomId = null,
    raw_push_atom_id: ?[]const i32 = null,
    pull_config: ?[]const ?StatsdPullAtomConfig = null,
    pub fn calcProtobufSize(self: *const StatsdTracingConfig) usize {
        var res: usize = 0;
        if (self.push_atom_id) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(StatsdTracingConfigWire.PUSH_ATOM_ID_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(arr[0]));
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(@intFromEnum(v));
                }
                res += gremlin.sizes.sizeWireNumber(StatsdTracingConfigWire.PUSH_ATOM_ID_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.raw_push_atom_id) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(StatsdTracingConfigWire.RAW_PUSH_ATOM_ID_WIRE) + gremlin.sizes.sizeI32(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(v);
                }
                res += gremlin.sizes.sizeWireNumber(StatsdTracingConfigWire.RAW_PUSH_ATOM_ID_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.pull_config) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(StatsdTracingConfigWire.PULL_CONFIG_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const StatsdTracingConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const StatsdTracingConfig, target: *gremlin.Writer) void {
        if (self.push_atom_id) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt32(StatsdTracingConfigWire.PUSH_ATOM_ID_WIRE, @intFromEnum(arr[0]));
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(@intFromEnum(v));
                }
                target.appendBytesTag(StatsdTracingConfigWire.PUSH_ATOM_ID_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt32WithoutTag(@intFromEnum(v));
                }
            }
        }
        if (self.raw_push_atom_id) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt32(StatsdTracingConfigWire.RAW_PUSH_ATOM_ID_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(v);
                }
                target.appendBytesTag(StatsdTracingConfigWire.RAW_PUSH_ATOM_ID_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt32WithoutTag(v);
                }
            }
        }
        if (self.pull_config) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(StatsdTracingConfigWire.PULL_CONFIG_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(StatsdTracingConfigWire.PULL_CONFIG_WIRE, 0);
                }
            }
        }
    }
};
pub const StatsdTracingConfigReader = struct {
    buf: gremlin.Reader,
    _push_atom_id_offset: ?usize = null,
    _push_atom_id_last_offset: ?usize = null,
    _push_atom_id_packed: bool = false,
    _raw_push_atom_id_offset: ?usize = null,
    _raw_push_atom_id_last_offset: ?usize = null,
    _raw_push_atom_id_packed: bool = false,
    _pull_config_offset: ?usize = null,
    _pull_config_last_offset: ?usize = null,
    _pull_config_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!StatsdTracingConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = StatsdTracingConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                StatsdTracingConfigWire.PUSH_ATOM_ID_WIRE => {
                    if (res._push_atom_id_offset == null) {
                        res._push_atom_id_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._push_atom_id_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._push_atom_id_offset = offset + length_result.size;
                        res._push_atom_id_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._push_atom_id_last_offset.?;
                    } else {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._push_atom_id_last_offset = offset;
                    }
                },
                StatsdTracingConfigWire.RAW_PUSH_ATOM_ID_WIRE => {
                    if (res._raw_push_atom_id_offset == null) {
                        res._raw_push_atom_id_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._raw_push_atom_id_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._raw_push_atom_id_offset = offset + length_result.size;
                        res._raw_push_atom_id_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._raw_push_atom_id_last_offset.?;
                    } else {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._raw_push_atom_id_last_offset = offset;
                    }
                },
                StatsdTracingConfigWire.PULL_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._pull_config_offset == null) {
                        res._pull_config_offset = offset - result.size;
                    }
                    res._pull_config_last_offset = offset;
                    res._pull_config_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn pushAtomIdNext(self: *StatsdTracingConfigReader) gremlin.Error!?AtomId {
        if (self._push_atom_id_offset == null) return null;
        const current_offset = self._push_atom_id_offset.?;
        if (current_offset >= self._push_atom_id_last_offset.?) {
            self._push_atom_id_offset = null;
            return null;
        }
        if (self._push_atom_id_packed) {
            const value_result = try self.buf.readInt32(current_offset);
            self._push_atom_id_offset = current_offset + value_result.size;
            if (self._push_atom_id_offset.? >= self._push_atom_id_last_offset.?) {
                self._push_atom_id_offset = null;
            }
            return @enumFromInt(value_result.value);
        } else {
            const value_result = try self.buf.readInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._push_atom_id_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == StatsdTracingConfigWire.PUSH_ATOM_ID_WIRE) {
                    self._push_atom_id_offset = next_offset;
                    return @enumFromInt(value_result.value);
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._push_atom_id_offset = null;
            return @enumFromInt(value_result.value);
        }
    }
    pub fn rawPushAtomIdNext(self: *StatsdTracingConfigReader) gremlin.Error!?i32 {
        if (self._raw_push_atom_id_offset == null) return null;
        const current_offset = self._raw_push_atom_id_offset.?;
        if (current_offset >= self._raw_push_atom_id_last_offset.?) {
            self._raw_push_atom_id_offset = null;
            return null;
        }
        if (self._raw_push_atom_id_packed) {
            const value_result = try self.buf.readInt32(current_offset);
            self._raw_push_atom_id_offset = current_offset + value_result.size;
            if (self._raw_push_atom_id_offset.? >= self._raw_push_atom_id_last_offset.?) {
                self._raw_push_atom_id_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._raw_push_atom_id_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == StatsdTracingConfigWire.RAW_PUSH_ATOM_ID_WIRE) {
                    self._raw_push_atom_id_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._raw_push_atom_id_offset = null;
            return value_result.value;
        }
    }
    pub fn pullConfigCount(self: *const StatsdTracingConfigReader) usize {
        return self._pull_config_cnt;
    }
    pub fn pullConfigNext(self: *StatsdTracingConfigReader) ?StatsdPullAtomConfigReader {
        if (self._pull_config_offset == null) return null;
        const current_offset = self._pull_config_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = StatsdPullAtomConfigReader.init(result.value) catch return null;
        if (self._pull_config_last_offset != null and current_offset >= self._pull_config_last_offset.?) {
            self._pull_config_offset = null;
            return msg;
        }
        if (self._pull_config_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._pull_config_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == StatsdTracingConfigWire.PULL_CONFIG_WIRE) {
                self._pull_config_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._pull_config_offset = null;
        return msg;
    }
};
const StatsdPullAtomConfigWire = struct {
    const PULL_ATOM_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const RAW_PULL_ATOM_ID_WIRE: gremlin.ProtoWireNumber = 2;
    const PULL_FREQUENCY_MS_WIRE: gremlin.ProtoWireNumber = 3;
    const PACKAGES_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const StatsdPullAtomConfig = struct {
    // fields
    pull_atom_id: ?[]const AtomId = null,
    raw_pull_atom_id: ?[]const i32 = null,
    pull_frequency_ms: i32 = 0,
    packages: ?[]const ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const StatsdPullAtomConfig) usize {
        var res: usize = 0;
        if (self.pull_atom_id) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(StatsdPullAtomConfigWire.PULL_ATOM_ID_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(arr[0]));
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(@intFromEnum(v));
                }
                res += gremlin.sizes.sizeWireNumber(StatsdPullAtomConfigWire.PULL_ATOM_ID_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.raw_pull_atom_id) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(StatsdPullAtomConfigWire.RAW_PULL_ATOM_ID_WIRE) + gremlin.sizes.sizeI32(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(v);
                }
                res += gremlin.sizes.sizeWireNumber(StatsdPullAtomConfigWire.RAW_PULL_ATOM_ID_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.pull_frequency_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(StatsdPullAtomConfigWire.PULL_FREQUENCY_MS_WIRE) + gremlin.sizes.sizeI32(self.pull_frequency_ms);
        }
        if (self.packages) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(StatsdPullAtomConfigWire.PACKAGES_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const StatsdPullAtomConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const StatsdPullAtomConfig, target: *gremlin.Writer) void {
        if (self.pull_atom_id) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt32(StatsdPullAtomConfigWire.PULL_ATOM_ID_WIRE, @intFromEnum(arr[0]));
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(@intFromEnum(v));
                }
                target.appendBytesTag(StatsdPullAtomConfigWire.PULL_ATOM_ID_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt32WithoutTag(@intFromEnum(v));
                }
            }
        }
        if (self.raw_pull_atom_id) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt32(StatsdPullAtomConfigWire.RAW_PULL_ATOM_ID_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(v);
                }
                target.appendBytesTag(StatsdPullAtomConfigWire.RAW_PULL_ATOM_ID_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt32WithoutTag(v);
                }
            }
        }
        if (self.pull_frequency_ms != 0) {
            target.appendInt32(StatsdPullAtomConfigWire.PULL_FREQUENCY_MS_WIRE, self.pull_frequency_ms);
        }
        if (self.packages) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(StatsdPullAtomConfigWire.PACKAGES_WIRE, v);
                } else {
                    target.appendBytesTag(StatsdPullAtomConfigWire.PACKAGES_WIRE, 0);
                }
            }
        }
    }
};
pub const StatsdPullAtomConfigReader = struct {
    buf: gremlin.Reader,
    _pull_atom_id_offset: ?usize = null,
    _pull_atom_id_last_offset: ?usize = null,
    _pull_atom_id_packed: bool = false,
    _raw_pull_atom_id_offset: ?usize = null,
    _raw_pull_atom_id_last_offset: ?usize = null,
    _raw_pull_atom_id_packed: bool = false,
    _pull_frequency_ms: i32 = 0,
    _packages_offset: ?usize = null,
    _packages_last_offset: ?usize = null,
    _packages_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!StatsdPullAtomConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = StatsdPullAtomConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                StatsdPullAtomConfigWire.PULL_ATOM_ID_WIRE => {
                    if (res._pull_atom_id_offset == null) {
                        res._pull_atom_id_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._pull_atom_id_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._pull_atom_id_offset = offset + length_result.size;
                        res._pull_atom_id_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._pull_atom_id_last_offset.?;
                    } else {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._pull_atom_id_last_offset = offset;
                    }
                },
                StatsdPullAtomConfigWire.RAW_PULL_ATOM_ID_WIRE => {
                    if (res._raw_pull_atom_id_offset == null) {
                        res._raw_pull_atom_id_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._raw_pull_atom_id_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._raw_pull_atom_id_offset = offset + length_result.size;
                        res._raw_pull_atom_id_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._raw_pull_atom_id_last_offset.?;
                    } else {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._raw_pull_atom_id_last_offset = offset;
                    }
                },
                StatsdPullAtomConfigWire.PULL_FREQUENCY_MS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._pull_frequency_ms = result.value;
                },
                StatsdPullAtomConfigWire.PACKAGES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._packages_offset == null) {
                        res._packages_offset = offset - result.size;
                    }
                    res._packages_last_offset = offset;
                    res._packages_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn pullAtomIdNext(self: *StatsdPullAtomConfigReader) gremlin.Error!?AtomId {
        if (self._pull_atom_id_offset == null) return null;
        const current_offset = self._pull_atom_id_offset.?;
        if (current_offset >= self._pull_atom_id_last_offset.?) {
            self._pull_atom_id_offset = null;
            return null;
        }
        if (self._pull_atom_id_packed) {
            const value_result = try self.buf.readInt32(current_offset);
            self._pull_atom_id_offset = current_offset + value_result.size;
            if (self._pull_atom_id_offset.? >= self._pull_atom_id_last_offset.?) {
                self._pull_atom_id_offset = null;
            }
            return @enumFromInt(value_result.value);
        } else {
            const value_result = try self.buf.readInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._pull_atom_id_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == StatsdPullAtomConfigWire.PULL_ATOM_ID_WIRE) {
                    self._pull_atom_id_offset = next_offset;
                    return @enumFromInt(value_result.value);
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._pull_atom_id_offset = null;
            return @enumFromInt(value_result.value);
        }
    }
    pub fn rawPullAtomIdNext(self: *StatsdPullAtomConfigReader) gremlin.Error!?i32 {
        if (self._raw_pull_atom_id_offset == null) return null;
        const current_offset = self._raw_pull_atom_id_offset.?;
        if (current_offset >= self._raw_pull_atom_id_last_offset.?) {
            self._raw_pull_atom_id_offset = null;
            return null;
        }
        if (self._raw_pull_atom_id_packed) {
            const value_result = try self.buf.readInt32(current_offset);
            self._raw_pull_atom_id_offset = current_offset + value_result.size;
            if (self._raw_pull_atom_id_offset.? >= self._raw_pull_atom_id_last_offset.?) {
                self._raw_pull_atom_id_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._raw_pull_atom_id_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == StatsdPullAtomConfigWire.RAW_PULL_ATOM_ID_WIRE) {
                    self._raw_pull_atom_id_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._raw_pull_atom_id_offset = null;
            return value_result.value;
        }
    }
    pub inline fn getPullFrequencyMs(self: *const StatsdPullAtomConfigReader) i32 {
        return self._pull_frequency_ms;
    }
    pub fn packagesCount(self: *const StatsdPullAtomConfigReader) usize {
        return self._packages_cnt;
    }
    pub fn packagesNext(self: *StatsdPullAtomConfigReader) ?[]const u8 {
        if (self._packages_offset == null) return null;
        const current_offset = self._packages_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._packages_last_offset != null and current_offset >= self._packages_last_offset.?) {
            self._packages_offset = null;
            return result.value;
        }
        if (self._packages_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._packages_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == StatsdPullAtomConfigWire.PACKAGES_WIRE) {
                self._packages_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._packages_offset = null;
        return result.value;
    }
};
const SysStatsConfigWire = struct {
    const MEMINFO_PERIOD_MS_WIRE: gremlin.ProtoWireNumber = 1;
    const MEMINFO_COUNTERS_WIRE: gremlin.ProtoWireNumber = 2;
    const VMSTAT_PERIOD_MS_WIRE: gremlin.ProtoWireNumber = 3;
    const VMSTAT_COUNTERS_WIRE: gremlin.ProtoWireNumber = 4;
    const STAT_PERIOD_MS_WIRE: gremlin.ProtoWireNumber = 5;
    const STAT_COUNTERS_WIRE: gremlin.ProtoWireNumber = 6;
    const DEVFREQ_PERIOD_MS_WIRE: gremlin.ProtoWireNumber = 7;
    const CPUFREQ_PERIOD_MS_WIRE: gremlin.ProtoWireNumber = 8;
    const BUDDYINFO_PERIOD_MS_WIRE: gremlin.ProtoWireNumber = 9;
    const DISKSTAT_PERIOD_MS_WIRE: gremlin.ProtoWireNumber = 10;
    const PSI_PERIOD_MS_WIRE: gremlin.ProtoWireNumber = 11;
    const THERMAL_PERIOD_MS_WIRE: gremlin.ProtoWireNumber = 12;
    const CPUIDLE_PERIOD_MS_WIRE: gremlin.ProtoWireNumber = 13;
    const GPUFREQ_PERIOD_MS_WIRE: gremlin.ProtoWireNumber = 14;
};
pub const SysStatsConfig = struct {
    // nested enums
    pub const StatCounters = enum(i32) {
        STAT_UNSPECIFIED = 0,
        STAT_CPU_TIMES = 1,
        STAT_IRQ_COUNTS = 2,
        STAT_SOFTIRQ_COUNTS = 3,
        STAT_FORK_COUNT = 4,
    };
    // fields
    meminfo_period_ms: u32 = 0,
    meminfo_counters: ?[]const MeminfoCounters = null,
    vmstat_period_ms: u32 = 0,
    vmstat_counters: ?[]const VmstatCounters = null,
    stat_period_ms: u32 = 0,
    stat_counters: ?[]const SysStatsConfig.StatCounters = null,
    devfreq_period_ms: u32 = 0,
    cpufreq_period_ms: u32 = 0,
    buddyinfo_period_ms: u32 = 0,
    diskstat_period_ms: u32 = 0,
    psi_period_ms: u32 = 0,
    thermal_period_ms: u32 = 0,
    cpuidle_period_ms: u32 = 0,
    gpufreq_period_ms: u32 = 0,
    pub fn calcProtobufSize(self: *const SysStatsConfig) usize {
        var res: usize = 0;
        if (self.meminfo_period_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(SysStatsConfigWire.MEMINFO_PERIOD_MS_WIRE) + gremlin.sizes.sizeU32(self.meminfo_period_ms);
        }
        if (self.meminfo_counters) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(SysStatsConfigWire.MEMINFO_COUNTERS_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(arr[0]));
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(@intFromEnum(v));
                }
                res += gremlin.sizes.sizeWireNumber(SysStatsConfigWire.MEMINFO_COUNTERS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.vmstat_period_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(SysStatsConfigWire.VMSTAT_PERIOD_MS_WIRE) + gremlin.sizes.sizeU32(self.vmstat_period_ms);
        }
        if (self.vmstat_counters) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(SysStatsConfigWire.VMSTAT_COUNTERS_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(arr[0]));
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(@intFromEnum(v));
                }
                res += gremlin.sizes.sizeWireNumber(SysStatsConfigWire.VMSTAT_COUNTERS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.stat_period_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(SysStatsConfigWire.STAT_PERIOD_MS_WIRE) + gremlin.sizes.sizeU32(self.stat_period_ms);
        }
        if (self.stat_counters) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(SysStatsConfigWire.STAT_COUNTERS_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(arr[0]));
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(@intFromEnum(v));
                }
                res += gremlin.sizes.sizeWireNumber(SysStatsConfigWire.STAT_COUNTERS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.devfreq_period_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(SysStatsConfigWire.DEVFREQ_PERIOD_MS_WIRE) + gremlin.sizes.sizeU32(self.devfreq_period_ms);
        }
        if (self.cpufreq_period_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(SysStatsConfigWire.CPUFREQ_PERIOD_MS_WIRE) + gremlin.sizes.sizeU32(self.cpufreq_period_ms);
        }
        if (self.buddyinfo_period_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(SysStatsConfigWire.BUDDYINFO_PERIOD_MS_WIRE) + gremlin.sizes.sizeU32(self.buddyinfo_period_ms);
        }
        if (self.diskstat_period_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(SysStatsConfigWire.DISKSTAT_PERIOD_MS_WIRE) + gremlin.sizes.sizeU32(self.diskstat_period_ms);
        }
        if (self.psi_period_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(SysStatsConfigWire.PSI_PERIOD_MS_WIRE) + gremlin.sizes.sizeU32(self.psi_period_ms);
        }
        if (self.thermal_period_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(SysStatsConfigWire.THERMAL_PERIOD_MS_WIRE) + gremlin.sizes.sizeU32(self.thermal_period_ms);
        }
        if (self.cpuidle_period_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(SysStatsConfigWire.CPUIDLE_PERIOD_MS_WIRE) + gremlin.sizes.sizeU32(self.cpuidle_period_ms);
        }
        if (self.gpufreq_period_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(SysStatsConfigWire.GPUFREQ_PERIOD_MS_WIRE) + gremlin.sizes.sizeU32(self.gpufreq_period_ms);
        }
        return res;
    }
    pub fn encode(self: *const SysStatsConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SysStatsConfig, target: *gremlin.Writer) void {
        if (self.meminfo_period_ms != 0) {
            target.appendUint32(SysStatsConfigWire.MEMINFO_PERIOD_MS_WIRE, self.meminfo_period_ms);
        }
        if (self.meminfo_counters) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt32(SysStatsConfigWire.MEMINFO_COUNTERS_WIRE, @intFromEnum(arr[0]));
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(@intFromEnum(v));
                }
                target.appendBytesTag(SysStatsConfigWire.MEMINFO_COUNTERS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt32WithoutTag(@intFromEnum(v));
                }
            }
        }
        if (self.vmstat_period_ms != 0) {
            target.appendUint32(SysStatsConfigWire.VMSTAT_PERIOD_MS_WIRE, self.vmstat_period_ms);
        }
        if (self.vmstat_counters) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt32(SysStatsConfigWire.VMSTAT_COUNTERS_WIRE, @intFromEnum(arr[0]));
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(@intFromEnum(v));
                }
                target.appendBytesTag(SysStatsConfigWire.VMSTAT_COUNTERS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt32WithoutTag(@intFromEnum(v));
                }
            }
        }
        if (self.stat_period_ms != 0) {
            target.appendUint32(SysStatsConfigWire.STAT_PERIOD_MS_WIRE, self.stat_period_ms);
        }
        if (self.stat_counters) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt32(SysStatsConfigWire.STAT_COUNTERS_WIRE, @intFromEnum(arr[0]));
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(@intFromEnum(v));
                }
                target.appendBytesTag(SysStatsConfigWire.STAT_COUNTERS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt32WithoutTag(@intFromEnum(v));
                }
            }
        }
        if (self.devfreq_period_ms != 0) {
            target.appendUint32(SysStatsConfigWire.DEVFREQ_PERIOD_MS_WIRE, self.devfreq_period_ms);
        }
        if (self.cpufreq_period_ms != 0) {
            target.appendUint32(SysStatsConfigWire.CPUFREQ_PERIOD_MS_WIRE, self.cpufreq_period_ms);
        }
        if (self.buddyinfo_period_ms != 0) {
            target.appendUint32(SysStatsConfigWire.BUDDYINFO_PERIOD_MS_WIRE, self.buddyinfo_period_ms);
        }
        if (self.diskstat_period_ms != 0) {
            target.appendUint32(SysStatsConfigWire.DISKSTAT_PERIOD_MS_WIRE, self.diskstat_period_ms);
        }
        if (self.psi_period_ms != 0) {
            target.appendUint32(SysStatsConfigWire.PSI_PERIOD_MS_WIRE, self.psi_period_ms);
        }
        if (self.thermal_period_ms != 0) {
            target.appendUint32(SysStatsConfigWire.THERMAL_PERIOD_MS_WIRE, self.thermal_period_ms);
        }
        if (self.cpuidle_period_ms != 0) {
            target.appendUint32(SysStatsConfigWire.CPUIDLE_PERIOD_MS_WIRE, self.cpuidle_period_ms);
        }
        if (self.gpufreq_period_ms != 0) {
            target.appendUint32(SysStatsConfigWire.GPUFREQ_PERIOD_MS_WIRE, self.gpufreq_period_ms);
        }
    }
};
pub const SysStatsConfigReader = struct {
    buf: gremlin.Reader,
    _meminfo_period_ms: u32 = 0,
    _meminfo_counters_offset: ?usize = null,
    _meminfo_counters_last_offset: ?usize = null,
    _meminfo_counters_packed: bool = false,
    _vmstat_period_ms: u32 = 0,
    _vmstat_counters_offset: ?usize = null,
    _vmstat_counters_last_offset: ?usize = null,
    _vmstat_counters_packed: bool = false,
    _stat_period_ms: u32 = 0,
    _stat_counters_offset: ?usize = null,
    _stat_counters_last_offset: ?usize = null,
    _stat_counters_packed: bool = false,
    _devfreq_period_ms: u32 = 0,
    _cpufreq_period_ms: u32 = 0,
    _buddyinfo_period_ms: u32 = 0,
    _diskstat_period_ms: u32 = 0,
    _psi_period_ms: u32 = 0,
    _thermal_period_ms: u32 = 0,
    _cpuidle_period_ms: u32 = 0,
    _gpufreq_period_ms: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!SysStatsConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = SysStatsConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SysStatsConfigWire.MEMINFO_PERIOD_MS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._meminfo_period_ms = result.value;
                },
                SysStatsConfigWire.MEMINFO_COUNTERS_WIRE => {
                    if (res._meminfo_counters_offset == null) {
                        res._meminfo_counters_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._meminfo_counters_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._meminfo_counters_offset = offset + length_result.size;
                        res._meminfo_counters_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._meminfo_counters_last_offset.?;
                    } else {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._meminfo_counters_last_offset = offset;
                    }
                },
                SysStatsConfigWire.VMSTAT_PERIOD_MS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._vmstat_period_ms = result.value;
                },
                SysStatsConfigWire.VMSTAT_COUNTERS_WIRE => {
                    if (res._vmstat_counters_offset == null) {
                        res._vmstat_counters_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._vmstat_counters_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._vmstat_counters_offset = offset + length_result.size;
                        res._vmstat_counters_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._vmstat_counters_last_offset.?;
                    } else {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._vmstat_counters_last_offset = offset;
                    }
                },
                SysStatsConfigWire.STAT_PERIOD_MS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._stat_period_ms = result.value;
                },
                SysStatsConfigWire.STAT_COUNTERS_WIRE => {
                    if (res._stat_counters_offset == null) {
                        res._stat_counters_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._stat_counters_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._stat_counters_offset = offset + length_result.size;
                        res._stat_counters_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._stat_counters_last_offset.?;
                    } else {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._stat_counters_last_offset = offset;
                    }
                },
                SysStatsConfigWire.DEVFREQ_PERIOD_MS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._devfreq_period_ms = result.value;
                },
                SysStatsConfigWire.CPUFREQ_PERIOD_MS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._cpufreq_period_ms = result.value;
                },
                SysStatsConfigWire.BUDDYINFO_PERIOD_MS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._buddyinfo_period_ms = result.value;
                },
                SysStatsConfigWire.DISKSTAT_PERIOD_MS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._diskstat_period_ms = result.value;
                },
                SysStatsConfigWire.PSI_PERIOD_MS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._psi_period_ms = result.value;
                },
                SysStatsConfigWire.THERMAL_PERIOD_MS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._thermal_period_ms = result.value;
                },
                SysStatsConfigWire.CPUIDLE_PERIOD_MS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._cpuidle_period_ms = result.value;
                },
                SysStatsConfigWire.GPUFREQ_PERIOD_MS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._gpufreq_period_ms = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getMeminfoPeriodMs(self: *const SysStatsConfigReader) u32 {
        return self._meminfo_period_ms;
    }
    pub fn meminfoCountersNext(self: *SysStatsConfigReader) gremlin.Error!?MeminfoCounters {
        if (self._meminfo_counters_offset == null) return null;
        const current_offset = self._meminfo_counters_offset.?;
        if (current_offset >= self._meminfo_counters_last_offset.?) {
            self._meminfo_counters_offset = null;
            return null;
        }
        if (self._meminfo_counters_packed) {
            const value_result = try self.buf.readInt32(current_offset);
            self._meminfo_counters_offset = current_offset + value_result.size;
            if (self._meminfo_counters_offset.? >= self._meminfo_counters_last_offset.?) {
                self._meminfo_counters_offset = null;
            }
            return @enumFromInt(value_result.value);
        } else {
            const value_result = try self.buf.readInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._meminfo_counters_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == SysStatsConfigWire.MEMINFO_COUNTERS_WIRE) {
                    self._meminfo_counters_offset = next_offset;
                    return @enumFromInt(value_result.value);
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._meminfo_counters_offset = null;
            return @enumFromInt(value_result.value);
        }
    }
    pub inline fn getVmstatPeriodMs(self: *const SysStatsConfigReader) u32 {
        return self._vmstat_period_ms;
    }
    pub fn vmstatCountersNext(self: *SysStatsConfigReader) gremlin.Error!?VmstatCounters {
        if (self._vmstat_counters_offset == null) return null;
        const current_offset = self._vmstat_counters_offset.?;
        if (current_offset >= self._vmstat_counters_last_offset.?) {
            self._vmstat_counters_offset = null;
            return null;
        }
        if (self._vmstat_counters_packed) {
            const value_result = try self.buf.readInt32(current_offset);
            self._vmstat_counters_offset = current_offset + value_result.size;
            if (self._vmstat_counters_offset.? >= self._vmstat_counters_last_offset.?) {
                self._vmstat_counters_offset = null;
            }
            return @enumFromInt(value_result.value);
        } else {
            const value_result = try self.buf.readInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._vmstat_counters_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == SysStatsConfigWire.VMSTAT_COUNTERS_WIRE) {
                    self._vmstat_counters_offset = next_offset;
                    return @enumFromInt(value_result.value);
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._vmstat_counters_offset = null;
            return @enumFromInt(value_result.value);
        }
    }
    pub inline fn getStatPeriodMs(self: *const SysStatsConfigReader) u32 {
        return self._stat_period_ms;
    }
    pub fn statCountersNext(self: *SysStatsConfigReader) gremlin.Error!?SysStatsConfig.StatCounters {
        if (self._stat_counters_offset == null) return null;
        const current_offset = self._stat_counters_offset.?;
        if (current_offset >= self._stat_counters_last_offset.?) {
            self._stat_counters_offset = null;
            return null;
        }
        if (self._stat_counters_packed) {
            const value_result = try self.buf.readInt32(current_offset);
            self._stat_counters_offset = current_offset + value_result.size;
            if (self._stat_counters_offset.? >= self._stat_counters_last_offset.?) {
                self._stat_counters_offset = null;
            }
            return @enumFromInt(value_result.value);
        } else {
            const value_result = try self.buf.readInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._stat_counters_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == SysStatsConfigWire.STAT_COUNTERS_WIRE) {
                    self._stat_counters_offset = next_offset;
                    return @enumFromInt(value_result.value);
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._stat_counters_offset = null;
            return @enumFromInt(value_result.value);
        }
    }
    pub inline fn getDevfreqPeriodMs(self: *const SysStatsConfigReader) u32 {
        return self._devfreq_period_ms;
    }
    pub inline fn getCpufreqPeriodMs(self: *const SysStatsConfigReader) u32 {
        return self._cpufreq_period_ms;
    }
    pub inline fn getBuddyinfoPeriodMs(self: *const SysStatsConfigReader) u32 {
        return self._buddyinfo_period_ms;
    }
    pub inline fn getDiskstatPeriodMs(self: *const SysStatsConfigReader) u32 {
        return self._diskstat_period_ms;
    }
    pub inline fn getPsiPeriodMs(self: *const SysStatsConfigReader) u32 {
        return self._psi_period_ms;
    }
    pub inline fn getThermalPeriodMs(self: *const SysStatsConfigReader) u32 {
        return self._thermal_period_ms;
    }
    pub inline fn getCpuidlePeriodMs(self: *const SysStatsConfigReader) u32 {
        return self._cpuidle_period_ms;
    }
    pub inline fn getGpufreqPeriodMs(self: *const SysStatsConfigReader) u32 {
        return self._gpufreq_period_ms;
    }
};
pub const SystemInfoConfig = struct {
    pub fn calcProtobufSize(_: *const SystemInfoConfig) usize {
        return 0;
    }
    pub fn encode(self: *const SystemInfoConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(_: *const SystemInfoConfig, _: *gremlin.Writer) void {}
};
pub const SystemInfoConfigReader = struct {
    buf: gremlin.Reader,
    pub fn init(src: []const u8) gremlin.Error!SystemInfoConfigReader {
        const buf = gremlin.Reader.init(src);
        return SystemInfoConfigReader{ .buf = buf };
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
};
const TestConfigWire = struct {
    const MESSAGE_COUNT_WIRE: gremlin.ProtoWireNumber = 1;
    const MAX_MESSAGES_PER_SECOND_WIRE: gremlin.ProtoWireNumber = 2;
    const SEED_WIRE: gremlin.ProtoWireNumber = 3;
    const MESSAGE_SIZE_WIRE: gremlin.ProtoWireNumber = 4;
    const SEND_BATCH_ON_REGISTER_WIRE: gremlin.ProtoWireNumber = 5;
    const DUMMY_FIELDS_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const TestConfig = struct {
    // nested structs
    const DummyFieldsWire = struct {
        const FIELD_UINT32_WIRE: gremlin.ProtoWireNumber = 1;
        const FIELD_INT32_WIRE: gremlin.ProtoWireNumber = 2;
        const FIELD_UINT64_WIRE: gremlin.ProtoWireNumber = 3;
        const FIELD_INT64_WIRE: gremlin.ProtoWireNumber = 4;
        const FIELD_FIXED64_WIRE: gremlin.ProtoWireNumber = 5;
        const FIELD_SFIXED64_WIRE: gremlin.ProtoWireNumber = 6;
        const FIELD_FIXED32_WIRE: gremlin.ProtoWireNumber = 7;
        const FIELD_SFIXED32_WIRE: gremlin.ProtoWireNumber = 8;
        const FIELD_DOUBLE_WIRE: gremlin.ProtoWireNumber = 9;
        const FIELD_FLOAT_WIRE: gremlin.ProtoWireNumber = 10;
        const FIELD_SINT64_WIRE: gremlin.ProtoWireNumber = 11;
        const FIELD_SINT32_WIRE: gremlin.ProtoWireNumber = 12;
        const FIELD_STRING_WIRE: gremlin.ProtoWireNumber = 13;
        const FIELD_BYTES_WIRE: gremlin.ProtoWireNumber = 14;
    };
    pub const DummyFields = struct {
        // fields
        field_uint32: u32 = 0,
        field_int32: i32 = 0,
        field_uint64: u64 = 0,
        field_int64: i64 = 0,
        field_fixed64: u64 = 0,
        field_sfixed64: i64 = 0,
        field_fixed32: u32 = 0,
        field_sfixed32: i32 = 0,
        field_double: f64 = 0.0,
        field_float: f32 = 0.0,
        field_sint64: i64 = 0,
        field_sint32: i32 = 0,
        field_string: ?[]const u8 = null,
        field_bytes: ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const TestConfig.DummyFields) usize {
            var res: usize = 0;
            if (self.field_uint32 != 0) {
                res += gremlin.sizes.sizeWireNumber(TestConfig.DummyFieldsWire.FIELD_UINT32_WIRE) + gremlin.sizes.sizeU32(self.field_uint32);
            }
            if (self.field_int32 != 0) {
                res += gremlin.sizes.sizeWireNumber(TestConfig.DummyFieldsWire.FIELD_INT32_WIRE) + gremlin.sizes.sizeI32(self.field_int32);
            }
            if (self.field_uint64 != 0) {
                res += gremlin.sizes.sizeWireNumber(TestConfig.DummyFieldsWire.FIELD_UINT64_WIRE) + gremlin.sizes.sizeU64(self.field_uint64);
            }
            if (self.field_int64 != 0) {
                res += gremlin.sizes.sizeWireNumber(TestConfig.DummyFieldsWire.FIELD_INT64_WIRE) + gremlin.sizes.sizeI64(self.field_int64);
            }
            if (self.field_fixed64 != 0) {
                res += gremlin.sizes.sizeWireNumber(TestConfig.DummyFieldsWire.FIELD_FIXED64_WIRE) + gremlin.sizes.sizeFixed64(self.field_fixed64);
            }
            if (self.field_sfixed64 != 0) {
                res += gremlin.sizes.sizeWireNumber(TestConfig.DummyFieldsWire.FIELD_SFIXED64_WIRE) + gremlin.sizes.sizeSFixed64(self.field_sfixed64);
            }
            if (self.field_fixed32 != 0) {
                res += gremlin.sizes.sizeWireNumber(TestConfig.DummyFieldsWire.FIELD_FIXED32_WIRE) + gremlin.sizes.sizeFixed32(self.field_fixed32);
            }
            if (self.field_sfixed32 != 0) {
                res += gremlin.sizes.sizeWireNumber(TestConfig.DummyFieldsWire.FIELD_SFIXED32_WIRE) + gremlin.sizes.sizeSFixed32(self.field_sfixed32);
            }
            if (self.field_double != 0.0) {
                res += gremlin.sizes.sizeWireNumber(TestConfig.DummyFieldsWire.FIELD_DOUBLE_WIRE) + gremlin.sizes.sizeDouble(self.field_double);
            }
            if (self.field_float != 0.0) {
                res += gremlin.sizes.sizeWireNumber(TestConfig.DummyFieldsWire.FIELD_FLOAT_WIRE) + gremlin.sizes.sizeFloat(self.field_float);
            }
            if (self.field_sint64 != 0) {
                res += gremlin.sizes.sizeWireNumber(TestConfig.DummyFieldsWire.FIELD_SINT64_WIRE) + gremlin.sizes.sizeSI64(self.field_sint64);
            }
            if (self.field_sint32 != 0) {
                res += gremlin.sizes.sizeWireNumber(TestConfig.DummyFieldsWire.FIELD_SINT32_WIRE) + gremlin.sizes.sizeSI32(self.field_sint32);
            }
            if (self.field_string) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(TestConfig.DummyFieldsWire.FIELD_STRING_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.field_bytes) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(TestConfig.DummyFieldsWire.FIELD_BYTES_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            return res;
        }
        pub fn encode(self: *const TestConfig.DummyFields, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const TestConfig.DummyFields, target: *gremlin.Writer) void {
            if (self.field_uint32 != 0) {
                target.appendUint32(TestConfig.DummyFieldsWire.FIELD_UINT32_WIRE, self.field_uint32);
            }
            if (self.field_int32 != 0) {
                target.appendInt32(TestConfig.DummyFieldsWire.FIELD_INT32_WIRE, self.field_int32);
            }
            if (self.field_uint64 != 0) {
                target.appendUint64(TestConfig.DummyFieldsWire.FIELD_UINT64_WIRE, self.field_uint64);
            }
            if (self.field_int64 != 0) {
                target.appendInt64(TestConfig.DummyFieldsWire.FIELD_INT64_WIRE, self.field_int64);
            }
            if (self.field_fixed64 != 0) {
                target.appendFixed64(TestConfig.DummyFieldsWire.FIELD_FIXED64_WIRE, self.field_fixed64);
            }
            if (self.field_sfixed64 != 0) {
                target.appendSfixed64(TestConfig.DummyFieldsWire.FIELD_SFIXED64_WIRE, self.field_sfixed64);
            }
            if (self.field_fixed32 != 0) {
                target.appendFixed32(TestConfig.DummyFieldsWire.FIELD_FIXED32_WIRE, self.field_fixed32);
            }
            if (self.field_sfixed32 != 0) {
                target.appendSfixed32(TestConfig.DummyFieldsWire.FIELD_SFIXED32_WIRE, self.field_sfixed32);
            }
            if (self.field_double != 0.0) {
                target.appendFloat64(TestConfig.DummyFieldsWire.FIELD_DOUBLE_WIRE, self.field_double);
            }
            if (self.field_float != 0.0) {
                target.appendFloat32(TestConfig.DummyFieldsWire.FIELD_FLOAT_WIRE, self.field_float);
            }
            if (self.field_sint64 != 0) {
                target.appendSint64(TestConfig.DummyFieldsWire.FIELD_SINT64_WIRE, self.field_sint64);
            }
            if (self.field_sint32 != 0) {
                target.appendSint32(TestConfig.DummyFieldsWire.FIELD_SINT32_WIRE, self.field_sint32);
            }
            if (self.field_string) |v| {
                if (v.len > 0) {
                    target.appendBytes(TestConfig.DummyFieldsWire.FIELD_STRING_WIRE, v);
                }
            }
            if (self.field_bytes) |v| {
                if (v.len > 0) {
                    target.appendBytes(TestConfig.DummyFieldsWire.FIELD_BYTES_WIRE, v);
                }
            }
        }
    };
    pub const DummyFieldsReader = struct {
        buf: gremlin.Reader,
        _field_uint32: u32 = 0,
        _field_int32: i32 = 0,
        _field_uint64: u64 = 0,
        _field_int64: i64 = 0,
        _field_fixed64: u64 = 0,
        _field_sfixed64: i64 = 0,
        _field_fixed32: u32 = 0,
        _field_sfixed32: i32 = 0,
        _field_double: f64 = 0.0,
        _field_float: f32 = 0.0,
        _field_sint64: i64 = 0,
        _field_sint32: i32 = 0,
        _field_string: ?[]const u8 = null,
        _field_bytes: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!TestConfig.DummyFieldsReader {
            const buf = gremlin.Reader.init(src);
            var res = TestConfig.DummyFieldsReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    TestConfig.DummyFieldsWire.FIELD_UINT32_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._field_uint32 = result.value;
                    },
                    TestConfig.DummyFieldsWire.FIELD_INT32_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._field_int32 = result.value;
                    },
                    TestConfig.DummyFieldsWire.FIELD_UINT64_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._field_uint64 = result.value;
                    },
                    TestConfig.DummyFieldsWire.FIELD_INT64_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._field_int64 = result.value;
                    },
                    TestConfig.DummyFieldsWire.FIELD_FIXED64_WIRE => {
                        const result = try buf.readFixed64(offset);
                        offset += result.size;
                        res._field_fixed64 = result.value;
                    },
                    TestConfig.DummyFieldsWire.FIELD_SFIXED64_WIRE => {
                        const result = try buf.readSFixed64(offset);
                        offset += result.size;
                        res._field_sfixed64 = result.value;
                    },
                    TestConfig.DummyFieldsWire.FIELD_FIXED32_WIRE => {
                        const result = try buf.readFixed32(offset);
                        offset += result.size;
                        res._field_fixed32 = result.value;
                    },
                    TestConfig.DummyFieldsWire.FIELD_SFIXED32_WIRE => {
                        const result = try buf.readSFixed32(offset);
                        offset += result.size;
                        res._field_sfixed32 = result.value;
                    },
                    TestConfig.DummyFieldsWire.FIELD_DOUBLE_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._field_double = result.value;
                    },
                    TestConfig.DummyFieldsWire.FIELD_FLOAT_WIRE => {
                        const result = try buf.readFloat32(offset);
                        offset += result.size;
                        res._field_float = result.value;
                    },
                    TestConfig.DummyFieldsWire.FIELD_SINT64_WIRE => {
                        const result = try buf.readSInt64(offset);
                        offset += result.size;
                        res._field_sint64 = result.value;
                    },
                    TestConfig.DummyFieldsWire.FIELD_SINT32_WIRE => {
                        const result = try buf.readSInt32(offset);
                        offset += result.size;
                        res._field_sint32 = result.value;
                    },
                    TestConfig.DummyFieldsWire.FIELD_STRING_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._field_string = result.value;
                    },
                    TestConfig.DummyFieldsWire.FIELD_BYTES_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._field_bytes = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getFieldUint32(self: *const TestConfig.DummyFieldsReader) u32 {
            return self._field_uint32;
        }
        pub inline fn getFieldInt32(self: *const TestConfig.DummyFieldsReader) i32 {
            return self._field_int32;
        }
        pub inline fn getFieldUint64(self: *const TestConfig.DummyFieldsReader) u64 {
            return self._field_uint64;
        }
        pub inline fn getFieldInt64(self: *const TestConfig.DummyFieldsReader) i64 {
            return self._field_int64;
        }
        pub inline fn getFieldFixed64(self: *const TestConfig.DummyFieldsReader) u64 {
            return self._field_fixed64;
        }
        pub inline fn getFieldSfixed64(self: *const TestConfig.DummyFieldsReader) i64 {
            return self._field_sfixed64;
        }
        pub inline fn getFieldFixed32(self: *const TestConfig.DummyFieldsReader) u32 {
            return self._field_fixed32;
        }
        pub inline fn getFieldSfixed32(self: *const TestConfig.DummyFieldsReader) i32 {
            return self._field_sfixed32;
        }
        pub inline fn getFieldDouble(self: *const TestConfig.DummyFieldsReader) f64 {
            return self._field_double;
        }
        pub inline fn getFieldFloat(self: *const TestConfig.DummyFieldsReader) f32 {
            return self._field_float;
        }
        pub inline fn getFieldSint64(self: *const TestConfig.DummyFieldsReader) i64 {
            return self._field_sint64;
        }
        pub inline fn getFieldSint32(self: *const TestConfig.DummyFieldsReader) i32 {
            return self._field_sint32;
        }
        pub inline fn getFieldString(self: *const TestConfig.DummyFieldsReader) []const u8 {
            return self._field_string orelse &[_]u8{};
        }
        pub inline fn getFieldBytes(self: *const TestConfig.DummyFieldsReader) []const u8 {
            return self._field_bytes orelse &[_]u8{};
        }
    };
    // fields
    message_count: u32 = 0,
    max_messages_per_second: u32 = 0,
    seed: u32 = 0,
    message_size: u32 = 0,
    send_batch_on_register: bool = false,
    dummy_fields: ?TestConfig.DummyFields = null,
    pub fn calcProtobufSize(self: *const TestConfig) usize {
        var res: usize = 0;
        if (self.message_count != 0) {
            res += gremlin.sizes.sizeWireNumber(TestConfigWire.MESSAGE_COUNT_WIRE) + gremlin.sizes.sizeU32(self.message_count);
        }
        if (self.max_messages_per_second != 0) {
            res += gremlin.sizes.sizeWireNumber(TestConfigWire.MAX_MESSAGES_PER_SECOND_WIRE) + gremlin.sizes.sizeU32(self.max_messages_per_second);
        }
        if (self.seed != 0) {
            res += gremlin.sizes.sizeWireNumber(TestConfigWire.SEED_WIRE) + gremlin.sizes.sizeU32(self.seed);
        }
        if (self.message_size != 0) {
            res += gremlin.sizes.sizeWireNumber(TestConfigWire.MESSAGE_SIZE_WIRE) + gremlin.sizes.sizeU32(self.message_size);
        }
        if (self.send_batch_on_register != false) {
            res += gremlin.sizes.sizeWireNumber(TestConfigWire.SEND_BATCH_ON_REGISTER_WIRE) + gremlin.sizes.sizeBool(self.send_batch_on_register);
        }
        if (self.dummy_fields) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TestConfigWire.DUMMY_FIELDS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const TestConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TestConfig, target: *gremlin.Writer) void {
        if (self.message_count != 0) {
            target.appendUint32(TestConfigWire.MESSAGE_COUNT_WIRE, self.message_count);
        }
        if (self.max_messages_per_second != 0) {
            target.appendUint32(TestConfigWire.MAX_MESSAGES_PER_SECOND_WIRE, self.max_messages_per_second);
        }
        if (self.seed != 0) {
            target.appendUint32(TestConfigWire.SEED_WIRE, self.seed);
        }
        if (self.message_size != 0) {
            target.appendUint32(TestConfigWire.MESSAGE_SIZE_WIRE, self.message_size);
        }
        if (self.send_batch_on_register != false) {
            target.appendBool(TestConfigWire.SEND_BATCH_ON_REGISTER_WIRE, self.send_batch_on_register);
        }
        if (self.dummy_fields) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TestConfigWire.DUMMY_FIELDS_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const TestConfigReader = struct {
    buf: gremlin.Reader,
    _message_count: u32 = 0,
    _max_messages_per_second: u32 = 0,
    _seed: u32 = 0,
    _message_size: u32 = 0,
    _send_batch_on_register: bool = false,
    _dummy_fields_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!TestConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = TestConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TestConfigWire.MESSAGE_COUNT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._message_count = result.value;
                },
                TestConfigWire.MAX_MESSAGES_PER_SECOND_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._max_messages_per_second = result.value;
                },
                TestConfigWire.SEED_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._seed = result.value;
                },
                TestConfigWire.MESSAGE_SIZE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._message_size = result.value;
                },
                TestConfigWire.SEND_BATCH_ON_REGISTER_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._send_batch_on_register = result.value;
                },
                TestConfigWire.DUMMY_FIELDS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dummy_fields_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getMessageCount(self: *const TestConfigReader) u32 {
        return self._message_count;
    }
    pub inline fn getMaxMessagesPerSecond(self: *const TestConfigReader) u32 {
        return self._max_messages_per_second;
    }
    pub inline fn getSeed(self: *const TestConfigReader) u32 {
        return self._seed;
    }
    pub inline fn getMessageSize(self: *const TestConfigReader) u32 {
        return self._message_size;
    }
    pub inline fn getSendBatchOnRegister(self: *const TestConfigReader) bool {
        return self._send_batch_on_register;
    }
    pub fn getDummyFields(self: *const TestConfigReader) gremlin.Error!TestConfig.DummyFieldsReader {
        if (self._dummy_fields_buf) |buf| {
            return try TestConfig.DummyFieldsReader.init(buf);
        }
        return try TestConfig.DummyFieldsReader.init(&[_]u8{});
    }
};
const TrackEventConfigWire = struct {
    const DISABLED_CATEGORIES_WIRE: gremlin.ProtoWireNumber = 1;
    const ENABLED_CATEGORIES_WIRE: gremlin.ProtoWireNumber = 2;
    const DISABLED_TAGS_WIRE: gremlin.ProtoWireNumber = 3;
    const ENABLED_TAGS_WIRE: gremlin.ProtoWireNumber = 4;
    const DISABLE_INCREMENTAL_TIMESTAMPS_WIRE: gremlin.ProtoWireNumber = 5;
    const TIMESTAMP_UNIT_MULTIPLIER_WIRE: gremlin.ProtoWireNumber = 6;
    const FILTER_DEBUG_ANNOTATIONS_WIRE: gremlin.ProtoWireNumber = 7;
    const ENABLE_THREAD_TIME_SAMPLING_WIRE: gremlin.ProtoWireNumber = 8;
    const THREAD_TIME_SUBSAMPLING_NS_WIRE: gremlin.ProtoWireNumber = 10;
    const FILTER_DYNAMIC_EVENT_NAMES_WIRE: gremlin.ProtoWireNumber = 9;
};
pub const TrackEventConfig = struct {
    // fields
    disabled_categories: ?[]const ?[]const u8 = null,
    enabled_categories: ?[]const ?[]const u8 = null,
    disabled_tags: ?[]const ?[]const u8 = null,
    enabled_tags: ?[]const ?[]const u8 = null,
    disable_incremental_timestamps: bool = false,
    timestamp_unit_multiplier: u64 = 0,
    filter_debug_annotations: bool = false,
    enable_thread_time_sampling: bool = false,
    thread_time_subsampling_ns: u64 = 0,
    filter_dynamic_event_names: bool = false,
    pub fn calcProtobufSize(self: *const TrackEventConfig) usize {
        var res: usize = 0;
        if (self.disabled_categories) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TrackEventConfigWire.DISABLED_CATEGORIES_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.enabled_categories) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TrackEventConfigWire.ENABLED_CATEGORIES_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.disabled_tags) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TrackEventConfigWire.DISABLED_TAGS_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.enabled_tags) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TrackEventConfigWire.ENABLED_TAGS_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.disable_incremental_timestamps != false) {
            res += gremlin.sizes.sizeWireNumber(TrackEventConfigWire.DISABLE_INCREMENTAL_TIMESTAMPS_WIRE) + gremlin.sizes.sizeBool(self.disable_incremental_timestamps);
        }
        if (self.timestamp_unit_multiplier != 0) {
            res += gremlin.sizes.sizeWireNumber(TrackEventConfigWire.TIMESTAMP_UNIT_MULTIPLIER_WIRE) + gremlin.sizes.sizeU64(self.timestamp_unit_multiplier);
        }
        if (self.filter_debug_annotations != false) {
            res += gremlin.sizes.sizeWireNumber(TrackEventConfigWire.FILTER_DEBUG_ANNOTATIONS_WIRE) + gremlin.sizes.sizeBool(self.filter_debug_annotations);
        }
        if (self.enable_thread_time_sampling != false) {
            res += gremlin.sizes.sizeWireNumber(TrackEventConfigWire.ENABLE_THREAD_TIME_SAMPLING_WIRE) + gremlin.sizes.sizeBool(self.enable_thread_time_sampling);
        }
        if (self.thread_time_subsampling_ns != 0) {
            res += gremlin.sizes.sizeWireNumber(TrackEventConfigWire.THREAD_TIME_SUBSAMPLING_NS_WIRE) + gremlin.sizes.sizeU64(self.thread_time_subsampling_ns);
        }
        if (self.filter_dynamic_event_names != false) {
            res += gremlin.sizes.sizeWireNumber(TrackEventConfigWire.FILTER_DYNAMIC_EVENT_NAMES_WIRE) + gremlin.sizes.sizeBool(self.filter_dynamic_event_names);
        }
        return res;
    }
    pub fn encode(self: *const TrackEventConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TrackEventConfig, target: *gremlin.Writer) void {
        if (self.disabled_categories) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(TrackEventConfigWire.DISABLED_CATEGORIES_WIRE, v);
                } else {
                    target.appendBytesTag(TrackEventConfigWire.DISABLED_CATEGORIES_WIRE, 0);
                }
            }
        }
        if (self.enabled_categories) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(TrackEventConfigWire.ENABLED_CATEGORIES_WIRE, v);
                } else {
                    target.appendBytesTag(TrackEventConfigWire.ENABLED_CATEGORIES_WIRE, 0);
                }
            }
        }
        if (self.disabled_tags) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(TrackEventConfigWire.DISABLED_TAGS_WIRE, v);
                } else {
                    target.appendBytesTag(TrackEventConfigWire.DISABLED_TAGS_WIRE, 0);
                }
            }
        }
        if (self.enabled_tags) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(TrackEventConfigWire.ENABLED_TAGS_WIRE, v);
                } else {
                    target.appendBytesTag(TrackEventConfigWire.ENABLED_TAGS_WIRE, 0);
                }
            }
        }
        if (self.disable_incremental_timestamps != false) {
            target.appendBool(TrackEventConfigWire.DISABLE_INCREMENTAL_TIMESTAMPS_WIRE, self.disable_incremental_timestamps);
        }
        if (self.timestamp_unit_multiplier != 0) {
            target.appendUint64(TrackEventConfigWire.TIMESTAMP_UNIT_MULTIPLIER_WIRE, self.timestamp_unit_multiplier);
        }
        if (self.filter_debug_annotations != false) {
            target.appendBool(TrackEventConfigWire.FILTER_DEBUG_ANNOTATIONS_WIRE, self.filter_debug_annotations);
        }
        if (self.enable_thread_time_sampling != false) {
            target.appendBool(TrackEventConfigWire.ENABLE_THREAD_TIME_SAMPLING_WIRE, self.enable_thread_time_sampling);
        }
        if (self.thread_time_subsampling_ns != 0) {
            target.appendUint64(TrackEventConfigWire.THREAD_TIME_SUBSAMPLING_NS_WIRE, self.thread_time_subsampling_ns);
        }
        if (self.filter_dynamic_event_names != false) {
            target.appendBool(TrackEventConfigWire.FILTER_DYNAMIC_EVENT_NAMES_WIRE, self.filter_dynamic_event_names);
        }
    }
};
pub const TrackEventConfigReader = struct {
    buf: gremlin.Reader,
    _disabled_categories_offset: ?usize = null,
    _disabled_categories_last_offset: ?usize = null,
    _disabled_categories_cnt: usize = 0,
    _enabled_categories_offset: ?usize = null,
    _enabled_categories_last_offset: ?usize = null,
    _enabled_categories_cnt: usize = 0,
    _disabled_tags_offset: ?usize = null,
    _disabled_tags_last_offset: ?usize = null,
    _disabled_tags_cnt: usize = 0,
    _enabled_tags_offset: ?usize = null,
    _enabled_tags_last_offset: ?usize = null,
    _enabled_tags_cnt: usize = 0,
    _disable_incremental_timestamps: bool = false,
    _timestamp_unit_multiplier: u64 = 0,
    _filter_debug_annotations: bool = false,
    _enable_thread_time_sampling: bool = false,
    _thread_time_subsampling_ns: u64 = 0,
    _filter_dynamic_event_names: bool = false,
    pub fn init(src: []const u8) gremlin.Error!TrackEventConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = TrackEventConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TrackEventConfigWire.DISABLED_CATEGORIES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._disabled_categories_offset == null) {
                        res._disabled_categories_offset = offset - result.size;
                    }
                    res._disabled_categories_last_offset = offset;
                    res._disabled_categories_cnt += 1;
                },
                TrackEventConfigWire.ENABLED_CATEGORIES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._enabled_categories_offset == null) {
                        res._enabled_categories_offset = offset - result.size;
                    }
                    res._enabled_categories_last_offset = offset;
                    res._enabled_categories_cnt += 1;
                },
                TrackEventConfigWire.DISABLED_TAGS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._disabled_tags_offset == null) {
                        res._disabled_tags_offset = offset - result.size;
                    }
                    res._disabled_tags_last_offset = offset;
                    res._disabled_tags_cnt += 1;
                },
                TrackEventConfigWire.ENABLED_TAGS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._enabled_tags_offset == null) {
                        res._enabled_tags_offset = offset - result.size;
                    }
                    res._enabled_tags_last_offset = offset;
                    res._enabled_tags_cnt += 1;
                },
                TrackEventConfigWire.DISABLE_INCREMENTAL_TIMESTAMPS_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._disable_incremental_timestamps = result.value;
                },
                TrackEventConfigWire.TIMESTAMP_UNIT_MULTIPLIER_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._timestamp_unit_multiplier = result.value;
                },
                TrackEventConfigWire.FILTER_DEBUG_ANNOTATIONS_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._filter_debug_annotations = result.value;
                },
                TrackEventConfigWire.ENABLE_THREAD_TIME_SAMPLING_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._enable_thread_time_sampling = result.value;
                },
                TrackEventConfigWire.THREAD_TIME_SUBSAMPLING_NS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._thread_time_subsampling_ns = result.value;
                },
                TrackEventConfigWire.FILTER_DYNAMIC_EVENT_NAMES_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._filter_dynamic_event_names = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn disabledCategoriesCount(self: *const TrackEventConfigReader) usize {
        return self._disabled_categories_cnt;
    }
    pub fn disabledCategoriesNext(self: *TrackEventConfigReader) ?[]const u8 {
        if (self._disabled_categories_offset == null) return null;
        const current_offset = self._disabled_categories_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._disabled_categories_last_offset != null and current_offset >= self._disabled_categories_last_offset.?) {
            self._disabled_categories_offset = null;
            return result.value;
        }
        if (self._disabled_categories_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._disabled_categories_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TrackEventConfigWire.DISABLED_CATEGORIES_WIRE) {
                self._disabled_categories_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._disabled_categories_offset = null;
        return result.value;
    }
    pub fn enabledCategoriesCount(self: *const TrackEventConfigReader) usize {
        return self._enabled_categories_cnt;
    }
    pub fn enabledCategoriesNext(self: *TrackEventConfigReader) ?[]const u8 {
        if (self._enabled_categories_offset == null) return null;
        const current_offset = self._enabled_categories_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._enabled_categories_last_offset != null and current_offset >= self._enabled_categories_last_offset.?) {
            self._enabled_categories_offset = null;
            return result.value;
        }
        if (self._enabled_categories_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._enabled_categories_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TrackEventConfigWire.ENABLED_CATEGORIES_WIRE) {
                self._enabled_categories_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._enabled_categories_offset = null;
        return result.value;
    }
    pub fn disabledTagsCount(self: *const TrackEventConfigReader) usize {
        return self._disabled_tags_cnt;
    }
    pub fn disabledTagsNext(self: *TrackEventConfigReader) ?[]const u8 {
        if (self._disabled_tags_offset == null) return null;
        const current_offset = self._disabled_tags_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._disabled_tags_last_offset != null and current_offset >= self._disabled_tags_last_offset.?) {
            self._disabled_tags_offset = null;
            return result.value;
        }
        if (self._disabled_tags_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._disabled_tags_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TrackEventConfigWire.DISABLED_TAGS_WIRE) {
                self._disabled_tags_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._disabled_tags_offset = null;
        return result.value;
    }
    pub fn enabledTagsCount(self: *const TrackEventConfigReader) usize {
        return self._enabled_tags_cnt;
    }
    pub fn enabledTagsNext(self: *TrackEventConfigReader) ?[]const u8 {
        if (self._enabled_tags_offset == null) return null;
        const current_offset = self._enabled_tags_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._enabled_tags_last_offset != null and current_offset >= self._enabled_tags_last_offset.?) {
            self._enabled_tags_offset = null;
            return result.value;
        }
        if (self._enabled_tags_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._enabled_tags_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TrackEventConfigWire.ENABLED_TAGS_WIRE) {
                self._enabled_tags_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._enabled_tags_offset = null;
        return result.value;
    }
    pub inline fn getDisableIncrementalTimestamps(self: *const TrackEventConfigReader) bool {
        return self._disable_incremental_timestamps;
    }
    pub inline fn getTimestampUnitMultiplier(self: *const TrackEventConfigReader) u64 {
        return self._timestamp_unit_multiplier;
    }
    pub inline fn getFilterDebugAnnotations(self: *const TrackEventConfigReader) bool {
        return self._filter_debug_annotations;
    }
    pub inline fn getEnableThreadTimeSampling(self: *const TrackEventConfigReader) bool {
        return self._enable_thread_time_sampling;
    }
    pub inline fn getThreadTimeSubsamplingNs(self: *const TrackEventConfigReader) u64 {
        return self._thread_time_subsampling_ns;
    }
    pub inline fn getFilterDynamicEventNames(self: *const TrackEventConfigReader) bool {
        return self._filter_dynamic_event_names;
    }
};
const DataSourceConfigWire = struct {
    const NAME_WIRE: gremlin.ProtoWireNumber = 1;
    const TARGET_BUFFER_WIRE: gremlin.ProtoWireNumber = 2;
    const TRACE_DURATION_MS_WIRE: gremlin.ProtoWireNumber = 3;
    const PREFER_SUSPEND_CLOCK_FOR_DURATION_WIRE: gremlin.ProtoWireNumber = 122;
    const STOP_TIMEOUT_MS_WIRE: gremlin.ProtoWireNumber = 7;
    const ENABLE_EXTRA_GUARDRAILS_WIRE: gremlin.ProtoWireNumber = 6;
    const SESSION_INITIATOR_WIRE: gremlin.ProtoWireNumber = 8;
    const TRACING_SESSION_ID_WIRE: gremlin.ProtoWireNumber = 4;
    const BUFFER_EXHAUSTED_POLICY_WIRE: gremlin.ProtoWireNumber = 9;
    const PRIORITY_BOOST_WIRE: gremlin.ProtoWireNumber = 10;
    const FTRACE_CONFIG_WIRE: gremlin.ProtoWireNumber = 100;
    const INODE_FILE_CONFIG_WIRE: gremlin.ProtoWireNumber = 102;
    const PROCESS_STATS_CONFIG_WIRE: gremlin.ProtoWireNumber = 103;
    const SYS_STATS_CONFIG_WIRE: gremlin.ProtoWireNumber = 104;
    const HEAPPROFD_CONFIG_WIRE: gremlin.ProtoWireNumber = 105;
    const JAVA_HPROF_CONFIG_WIRE: gremlin.ProtoWireNumber = 110;
    const ANDROID_POWER_CONFIG_WIRE: gremlin.ProtoWireNumber = 106;
    const ANDROID_LOG_CONFIG_WIRE: gremlin.ProtoWireNumber = 107;
    const GPU_COUNTER_CONFIG_WIRE: gremlin.ProtoWireNumber = 108;
    const ANDROID_GAME_INTERVENTION_LIST_CONFIG_WIRE: gremlin.ProtoWireNumber = 116;
    const PACKAGES_LIST_CONFIG_WIRE: gremlin.ProtoWireNumber = 109;
    const PERF_EVENT_CONFIG_WIRE: gremlin.ProtoWireNumber = 111;
    const VULKAN_MEMORY_CONFIG_WIRE: gremlin.ProtoWireNumber = 112;
    const TRACK_EVENT_CONFIG_WIRE: gremlin.ProtoWireNumber = 113;
    const ANDROID_POLLED_STATE_CONFIG_WIRE: gremlin.ProtoWireNumber = 114;
    const ANDROID_SYSTEM_PROPERTY_CONFIG_WIRE: gremlin.ProtoWireNumber = 118;
    const STATSD_TRACING_CONFIG_WIRE: gremlin.ProtoWireNumber = 117;
    const SYSTEM_INFO_CONFIG_WIRE: gremlin.ProtoWireNumber = 119;
    const FROZEN_FTRACE_CONFIG_WIRE: gremlin.ProtoWireNumber = 136;
    const CHROME_CONFIG_WIRE: gremlin.ProtoWireNumber = 101;
    const V8_CONFIG_WIRE: gremlin.ProtoWireNumber = 127;
    const INTERCEPTOR_CONFIG_WIRE: gremlin.ProtoWireNumber = 115;
    const NETWORK_PACKET_TRACE_CONFIG_WIRE: gremlin.ProtoWireNumber = 120;
    const SURFACEFLINGER_LAYERS_CONFIG_WIRE: gremlin.ProtoWireNumber = 121;
    const SURFACEFLINGER_TRANSACTIONS_CONFIG_WIRE: gremlin.ProtoWireNumber = 123;
    const ANDROID_SDK_SYSPROP_GUARD_CONFIG_WIRE: gremlin.ProtoWireNumber = 124;
    const ETW_CONFIG_WIRE: gremlin.ProtoWireNumber = 125;
    const PROTOLOG_CONFIG_WIRE: gremlin.ProtoWireNumber = 126;
    const ANDROID_INPUT_EVENT_CONFIG_WIRE: gremlin.ProtoWireNumber = 128;
    const PIXEL_MODEM_CONFIG_WIRE: gremlin.ProtoWireNumber = 129;
    const WINDOWMANAGER_CONFIG_WIRE: gremlin.ProtoWireNumber = 130;
    const CHROMIUM_SYSTEM_METRICS_WIRE: gremlin.ProtoWireNumber = 131;
    const KERNEL_WAKELOCKS_CONFIG_WIRE: gremlin.ProtoWireNumber = 132;
    const GPU_RENDERSTAGES_CONFIG_WIRE: gremlin.ProtoWireNumber = 133;
    const CHROMIUM_HISTOGRAM_SAMPLES_WIRE: gremlin.ProtoWireNumber = 134;
    const APP_WAKELOCKS_CONFIG_WIRE: gremlin.ProtoWireNumber = 135;
    const CPU_PER_UID_CONFIG_WIRE: gremlin.ProtoWireNumber = 137;
    const LEGACY_CONFIG_WIRE: gremlin.ProtoWireNumber = 1000;
    const FOR_TESTING_WIRE: gremlin.ProtoWireNumber = 1001;
};
pub const DataSourceConfig = struct {
    // nested enums
    pub const SessionInitiator = enum(i32) {
        SESSION_INITIATOR_UNSPECIFIED = 0,
        SESSION_INITIATOR_TRUSTED_SYSTEM = 1,
    };
    pub const BufferExhaustedPolicy = enum(i32) {
        BUFFER_EXHAUSTED_UNSPECIFIED = 0,
        BUFFER_EXHAUSTED_DROP = 1,
        BUFFER_EXHAUSTED_STALL_THEN_ABORT = 2,
        BUFFER_EXHAUSTED_STALL_THEN_DROP = 3,
    };
    // fields
    name: ?[]const u8 = null,
    target_buffer: u32 = 0,
    trace_duration_ms: u32 = 0,
    prefer_suspend_clock_for_duration: bool = false,
    stop_timeout_ms: u32 = 0,
    enable_extra_guardrails: bool = false,
    session_initiator: DataSourceConfig.SessionInitiator = @enumFromInt(0),
    tracing_session_id: u64 = 0,
    buffer_exhausted_policy: DataSourceConfig.BufferExhaustedPolicy = @enumFromInt(0),
    priority_boost: ?PriorityBoostConfig = null,
    ftrace_config: ?FtraceConfig = null,
    inode_file_config: ?InodeFileConfig = null,
    process_stats_config: ?ProcessStatsConfig = null,
    sys_stats_config: ?SysStatsConfig = null,
    heapprofd_config: ?HeapprofdConfig = null,
    java_hprof_config: ?JavaHprofConfig = null,
    android_power_config: ?AndroidPowerConfig = null,
    android_log_config: ?AndroidLogConfig = null,
    gpu_counter_config: ?GpuCounterConfig = null,
    android_game_intervention_list_config: ?AndroidGameInterventionListConfig = null,
    packages_list_config: ?PackagesListConfig = null,
    perf_event_config: ?PerfEventConfig = null,
    vulkan_memory_config: ?VulkanMemoryConfig = null,
    track_event_config: ?TrackEventConfig = null,
    android_polled_state_config: ?AndroidPolledStateConfig = null,
    android_system_property_config: ?AndroidSystemPropertyConfig = null,
    statsd_tracing_config: ?StatsdTracingConfig = null,
    system_info_config: ?SystemInfoConfig = null,
    frozen_ftrace_config: ?FrozenFtraceConfig = null,
    chrome_config: ?ChromeConfig = null,
    v8_config: ?V8Config = null,
    interceptor_config: ?InterceptorConfig = null,
    network_packet_trace_config: ?NetworkPacketTraceConfig = null,
    surfaceflinger_layers_config: ?SurfaceFlingerLayersConfig = null,
    surfaceflinger_transactions_config: ?SurfaceFlingerTransactionsConfig = null,
    android_sdk_sysprop_guard_config: ?AndroidSdkSyspropGuardConfig = null,
    etw_config: ?EtwConfig = null,
    protolog_config: ?ProtoLogConfig = null,
    android_input_event_config: ?AndroidInputEventConfig = null,
    pixel_modem_config: ?PixelModemConfig = null,
    windowmanager_config: ?WindowManagerConfig = null,
    chromium_system_metrics: ?ChromiumSystemMetricsConfig = null,
    kernel_wakelocks_config: ?KernelWakelocksConfig = null,
    gpu_renderstages_config: ?GpuRenderStagesConfig = null,
    chromium_histogram_samples: ?ChromiumHistogramSamplesConfig = null,
    app_wakelocks_config: ?AppWakelocksConfig = null,
    cpu_per_uid_config: ?CpuPerUidConfig = null,
    legacy_config: ?[]const u8 = null,
    for_testing: ?TestConfig = null,
    pub fn calcProtobufSize(self: *const DataSourceConfig) usize {
        var res: usize = 0;
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.target_buffer != 0) {
            res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.TARGET_BUFFER_WIRE) + gremlin.sizes.sizeU32(self.target_buffer);
        }
        if (self.trace_duration_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.TRACE_DURATION_MS_WIRE) + gremlin.sizes.sizeU32(self.trace_duration_ms);
        }
        if (self.prefer_suspend_clock_for_duration != false) {
            res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.PREFER_SUSPEND_CLOCK_FOR_DURATION_WIRE) + gremlin.sizes.sizeBool(self.prefer_suspend_clock_for_duration);
        }
        if (self.stop_timeout_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.STOP_TIMEOUT_MS_WIRE) + gremlin.sizes.sizeU32(self.stop_timeout_ms);
        }
        if (self.enable_extra_guardrails != false) {
            res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.ENABLE_EXTRA_GUARDRAILS_WIRE) + gremlin.sizes.sizeBool(self.enable_extra_guardrails);
        }
        if (@intFromEnum(self.session_initiator) != 0) {
            res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.SESSION_INITIATOR_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.session_initiator));
        }
        if (self.tracing_session_id != 0) {
            res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.TRACING_SESSION_ID_WIRE) + gremlin.sizes.sizeU64(self.tracing_session_id);
        }
        if (@intFromEnum(self.buffer_exhausted_policy) != 0) {
            res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.BUFFER_EXHAUSTED_POLICY_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.buffer_exhausted_policy));
        }
        if (self.priority_boost) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.PRIORITY_BOOST_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.ftrace_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.FTRACE_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.inode_file_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.INODE_FILE_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.process_stats_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.PROCESS_STATS_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.sys_stats_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.SYS_STATS_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.heapprofd_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.HEAPPROFD_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.java_hprof_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.JAVA_HPROF_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_power_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.ANDROID_POWER_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_log_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.ANDROID_LOG_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.gpu_counter_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.GPU_COUNTER_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_game_intervention_list_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.ANDROID_GAME_INTERVENTION_LIST_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.packages_list_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.PACKAGES_LIST_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.perf_event_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.PERF_EVENT_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.vulkan_memory_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.VULKAN_MEMORY_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.track_event_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.TRACK_EVENT_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_polled_state_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.ANDROID_POLLED_STATE_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_system_property_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.ANDROID_SYSTEM_PROPERTY_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.statsd_tracing_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.STATSD_TRACING_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.system_info_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.SYSTEM_INFO_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.frozen_ftrace_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.FROZEN_FTRACE_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chrome_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.CHROME_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.v8_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.V8_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.interceptor_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.INTERCEPTOR_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.network_packet_trace_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.NETWORK_PACKET_TRACE_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.surfaceflinger_layers_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.SURFACEFLINGER_LAYERS_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.surfaceflinger_transactions_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.SURFACEFLINGER_TRANSACTIONS_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_sdk_sysprop_guard_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.ANDROID_SDK_SYSPROP_GUARD_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.etw_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.ETW_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.protolog_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.PROTOLOG_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_input_event_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.ANDROID_INPUT_EVENT_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.pixel_modem_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.PIXEL_MODEM_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.windowmanager_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.WINDOWMANAGER_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chromium_system_metrics) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.CHROMIUM_SYSTEM_METRICS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.kernel_wakelocks_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.KERNEL_WAKELOCKS_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.gpu_renderstages_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.GPU_RENDERSTAGES_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.chromium_histogram_samples) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.CHROMIUM_HISTOGRAM_SAMPLES_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.app_wakelocks_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.APP_WAKELOCKS_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cpu_per_uid_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.CPU_PER_UID_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.legacy_config) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.LEGACY_CONFIG_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.for_testing) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DataSourceConfigWire.FOR_TESTING_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const DataSourceConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const DataSourceConfig, target: *gremlin.Writer) void {
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(DataSourceConfigWire.NAME_WIRE, v);
            }
        }
        if (self.target_buffer != 0) {
            target.appendUint32(DataSourceConfigWire.TARGET_BUFFER_WIRE, self.target_buffer);
        }
        if (self.trace_duration_ms != 0) {
            target.appendUint32(DataSourceConfigWire.TRACE_DURATION_MS_WIRE, self.trace_duration_ms);
        }
        if (self.prefer_suspend_clock_for_duration != false) {
            target.appendBool(DataSourceConfigWire.PREFER_SUSPEND_CLOCK_FOR_DURATION_WIRE, self.prefer_suspend_clock_for_duration);
        }
        if (self.stop_timeout_ms != 0) {
            target.appendUint32(DataSourceConfigWire.STOP_TIMEOUT_MS_WIRE, self.stop_timeout_ms);
        }
        if (self.enable_extra_guardrails != false) {
            target.appendBool(DataSourceConfigWire.ENABLE_EXTRA_GUARDRAILS_WIRE, self.enable_extra_guardrails);
        }
        if (@intFromEnum(self.session_initiator) != 0) {
            target.appendInt32(DataSourceConfigWire.SESSION_INITIATOR_WIRE, @intFromEnum(self.session_initiator));
        }
        if (self.tracing_session_id != 0) {
            target.appendUint64(DataSourceConfigWire.TRACING_SESSION_ID_WIRE, self.tracing_session_id);
        }
        if (@intFromEnum(self.buffer_exhausted_policy) != 0) {
            target.appendInt32(DataSourceConfigWire.BUFFER_EXHAUSTED_POLICY_WIRE, @intFromEnum(self.buffer_exhausted_policy));
        }
        if (self.priority_boost) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DataSourceConfigWire.PRIORITY_BOOST_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.ftrace_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DataSourceConfigWire.FTRACE_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.inode_file_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DataSourceConfigWire.INODE_FILE_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.process_stats_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DataSourceConfigWire.PROCESS_STATS_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.sys_stats_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DataSourceConfigWire.SYS_STATS_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.heapprofd_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DataSourceConfigWire.HEAPPROFD_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.java_hprof_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DataSourceConfigWire.JAVA_HPROF_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_power_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DataSourceConfigWire.ANDROID_POWER_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_log_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DataSourceConfigWire.ANDROID_LOG_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.gpu_counter_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DataSourceConfigWire.GPU_COUNTER_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_game_intervention_list_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DataSourceConfigWire.ANDROID_GAME_INTERVENTION_LIST_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.packages_list_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DataSourceConfigWire.PACKAGES_LIST_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.perf_event_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DataSourceConfigWire.PERF_EVENT_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.vulkan_memory_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DataSourceConfigWire.VULKAN_MEMORY_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.track_event_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DataSourceConfigWire.TRACK_EVENT_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_polled_state_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DataSourceConfigWire.ANDROID_POLLED_STATE_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_system_property_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DataSourceConfigWire.ANDROID_SYSTEM_PROPERTY_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.statsd_tracing_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DataSourceConfigWire.STATSD_TRACING_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.system_info_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DataSourceConfigWire.SYSTEM_INFO_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.frozen_ftrace_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DataSourceConfigWire.FROZEN_FTRACE_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chrome_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DataSourceConfigWire.CHROME_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.v8_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DataSourceConfigWire.V8_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.interceptor_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DataSourceConfigWire.INTERCEPTOR_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.network_packet_trace_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DataSourceConfigWire.NETWORK_PACKET_TRACE_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.surfaceflinger_layers_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DataSourceConfigWire.SURFACEFLINGER_LAYERS_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.surfaceflinger_transactions_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DataSourceConfigWire.SURFACEFLINGER_TRANSACTIONS_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_sdk_sysprop_guard_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DataSourceConfigWire.ANDROID_SDK_SYSPROP_GUARD_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.etw_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DataSourceConfigWire.ETW_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.protolog_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DataSourceConfigWire.PROTOLOG_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_input_event_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DataSourceConfigWire.ANDROID_INPUT_EVENT_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.pixel_modem_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DataSourceConfigWire.PIXEL_MODEM_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.windowmanager_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DataSourceConfigWire.WINDOWMANAGER_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chromium_system_metrics) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DataSourceConfigWire.CHROMIUM_SYSTEM_METRICS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.kernel_wakelocks_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DataSourceConfigWire.KERNEL_WAKELOCKS_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.gpu_renderstages_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DataSourceConfigWire.GPU_RENDERSTAGES_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.chromium_histogram_samples) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DataSourceConfigWire.CHROMIUM_HISTOGRAM_SAMPLES_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.app_wakelocks_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DataSourceConfigWire.APP_WAKELOCKS_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cpu_per_uid_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DataSourceConfigWire.CPU_PER_UID_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.legacy_config) |v| {
            if (v.len > 0) {
                target.appendBytes(DataSourceConfigWire.LEGACY_CONFIG_WIRE, v);
            }
        }
        if (self.for_testing) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DataSourceConfigWire.FOR_TESTING_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const DataSourceConfigReader = struct {
    buf: gremlin.Reader,
    _name: ?[]const u8 = null,
    _target_buffer: u32 = 0,
    _trace_duration_ms: u32 = 0,
    _prefer_suspend_clock_for_duration: bool = false,
    _stop_timeout_ms: u32 = 0,
    _enable_extra_guardrails: bool = false,
    _session_initiator: DataSourceConfig.SessionInitiator = @enumFromInt(0),
    _tracing_session_id: u64 = 0,
    _buffer_exhausted_policy: DataSourceConfig.BufferExhaustedPolicy = @enumFromInt(0),
    _priority_boost_buf: ?[]const u8 = null,
    _ftrace_config_buf: ?[]const u8 = null,
    _inode_file_config_buf: ?[]const u8 = null,
    _process_stats_config_buf: ?[]const u8 = null,
    _sys_stats_config_buf: ?[]const u8 = null,
    _heapprofd_config_buf: ?[]const u8 = null,
    _java_hprof_config_buf: ?[]const u8 = null,
    _android_power_config_buf: ?[]const u8 = null,
    _android_log_config_buf: ?[]const u8 = null,
    _gpu_counter_config_buf: ?[]const u8 = null,
    _android_game_intervention_list_config_buf: ?[]const u8 = null,
    _packages_list_config_buf: ?[]const u8 = null,
    _perf_event_config_buf: ?[]const u8 = null,
    _vulkan_memory_config_buf: ?[]const u8 = null,
    _track_event_config_buf: ?[]const u8 = null,
    _android_polled_state_config_buf: ?[]const u8 = null,
    _android_system_property_config_buf: ?[]const u8 = null,
    _statsd_tracing_config_buf: ?[]const u8 = null,
    _system_info_config_buf: ?[]const u8 = null,
    _frozen_ftrace_config_buf: ?[]const u8 = null,
    _chrome_config_buf: ?[]const u8 = null,
    _v8_config_buf: ?[]const u8 = null,
    _interceptor_config_buf: ?[]const u8 = null,
    _network_packet_trace_config_buf: ?[]const u8 = null,
    _surfaceflinger_layers_config_buf: ?[]const u8 = null,
    _surfaceflinger_transactions_config_buf: ?[]const u8 = null,
    _android_sdk_sysprop_guard_config_buf: ?[]const u8 = null,
    _etw_config_buf: ?[]const u8 = null,
    _protolog_config_buf: ?[]const u8 = null,
    _android_input_event_config_buf: ?[]const u8 = null,
    _pixel_modem_config_buf: ?[]const u8 = null,
    _windowmanager_config_buf: ?[]const u8 = null,
    _chromium_system_metrics_buf: ?[]const u8 = null,
    _kernel_wakelocks_config_buf: ?[]const u8 = null,
    _gpu_renderstages_config_buf: ?[]const u8 = null,
    _chromium_histogram_samples_buf: ?[]const u8 = null,
    _app_wakelocks_config_buf: ?[]const u8 = null,
    _cpu_per_uid_config_buf: ?[]const u8 = null,
    _legacy_config: ?[]const u8 = null,
    _for_testing_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!DataSourceConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = DataSourceConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                DataSourceConfigWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                DataSourceConfigWire.TARGET_BUFFER_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._target_buffer = result.value;
                },
                DataSourceConfigWire.TRACE_DURATION_MS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._trace_duration_ms = result.value;
                },
                DataSourceConfigWire.PREFER_SUSPEND_CLOCK_FOR_DURATION_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._prefer_suspend_clock_for_duration = result.value;
                },
                DataSourceConfigWire.STOP_TIMEOUT_MS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._stop_timeout_ms = result.value;
                },
                DataSourceConfigWire.ENABLE_EXTRA_GUARDRAILS_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._enable_extra_guardrails = result.value;
                },
                DataSourceConfigWire.SESSION_INITIATOR_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._session_initiator = @enumFromInt(result.value);
                },
                DataSourceConfigWire.TRACING_SESSION_ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._tracing_session_id = result.value;
                },
                DataSourceConfigWire.BUFFER_EXHAUSTED_POLICY_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._buffer_exhausted_policy = @enumFromInt(result.value);
                },
                DataSourceConfigWire.PRIORITY_BOOST_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._priority_boost_buf = result.value;
                },
                DataSourceConfigWire.FTRACE_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._ftrace_config_buf = result.value;
                },
                DataSourceConfigWire.INODE_FILE_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._inode_file_config_buf = result.value;
                },
                DataSourceConfigWire.PROCESS_STATS_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._process_stats_config_buf = result.value;
                },
                DataSourceConfigWire.SYS_STATS_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._sys_stats_config_buf = result.value;
                },
                DataSourceConfigWire.HEAPPROFD_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._heapprofd_config_buf = result.value;
                },
                DataSourceConfigWire.JAVA_HPROF_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._java_hprof_config_buf = result.value;
                },
                DataSourceConfigWire.ANDROID_POWER_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_power_config_buf = result.value;
                },
                DataSourceConfigWire.ANDROID_LOG_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_log_config_buf = result.value;
                },
                DataSourceConfigWire.GPU_COUNTER_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._gpu_counter_config_buf = result.value;
                },
                DataSourceConfigWire.ANDROID_GAME_INTERVENTION_LIST_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_game_intervention_list_config_buf = result.value;
                },
                DataSourceConfigWire.PACKAGES_LIST_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._packages_list_config_buf = result.value;
                },
                DataSourceConfigWire.PERF_EVENT_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._perf_event_config_buf = result.value;
                },
                DataSourceConfigWire.VULKAN_MEMORY_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._vulkan_memory_config_buf = result.value;
                },
                DataSourceConfigWire.TRACK_EVENT_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._track_event_config_buf = result.value;
                },
                DataSourceConfigWire.ANDROID_POLLED_STATE_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_polled_state_config_buf = result.value;
                },
                DataSourceConfigWire.ANDROID_SYSTEM_PROPERTY_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_system_property_config_buf = result.value;
                },
                DataSourceConfigWire.STATSD_TRACING_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._statsd_tracing_config_buf = result.value;
                },
                DataSourceConfigWire.SYSTEM_INFO_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._system_info_config_buf = result.value;
                },
                DataSourceConfigWire.FROZEN_FTRACE_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._frozen_ftrace_config_buf = result.value;
                },
                DataSourceConfigWire.CHROME_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chrome_config_buf = result.value;
                },
                DataSourceConfigWire.V8_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._v8_config_buf = result.value;
                },
                DataSourceConfigWire.INTERCEPTOR_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._interceptor_config_buf = result.value;
                },
                DataSourceConfigWire.NETWORK_PACKET_TRACE_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._network_packet_trace_config_buf = result.value;
                },
                DataSourceConfigWire.SURFACEFLINGER_LAYERS_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._surfaceflinger_layers_config_buf = result.value;
                },
                DataSourceConfigWire.SURFACEFLINGER_TRANSACTIONS_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._surfaceflinger_transactions_config_buf = result.value;
                },
                DataSourceConfigWire.ANDROID_SDK_SYSPROP_GUARD_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_sdk_sysprop_guard_config_buf = result.value;
                },
                DataSourceConfigWire.ETW_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._etw_config_buf = result.value;
                },
                DataSourceConfigWire.PROTOLOG_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._protolog_config_buf = result.value;
                },
                DataSourceConfigWire.ANDROID_INPUT_EVENT_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_input_event_config_buf = result.value;
                },
                DataSourceConfigWire.PIXEL_MODEM_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._pixel_modem_config_buf = result.value;
                },
                DataSourceConfigWire.WINDOWMANAGER_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._windowmanager_config_buf = result.value;
                },
                DataSourceConfigWire.CHROMIUM_SYSTEM_METRICS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chromium_system_metrics_buf = result.value;
                },
                DataSourceConfigWire.KERNEL_WAKELOCKS_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._kernel_wakelocks_config_buf = result.value;
                },
                DataSourceConfigWire.GPU_RENDERSTAGES_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._gpu_renderstages_config_buf = result.value;
                },
                DataSourceConfigWire.CHROMIUM_HISTOGRAM_SAMPLES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._chromium_histogram_samples_buf = result.value;
                },
                DataSourceConfigWire.APP_WAKELOCKS_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._app_wakelocks_config_buf = result.value;
                },
                DataSourceConfigWire.CPU_PER_UID_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cpu_per_uid_config_buf = result.value;
                },
                DataSourceConfigWire.LEGACY_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._legacy_config = result.value;
                },
                DataSourceConfigWire.FOR_TESTING_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._for_testing_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getName(self: *const DataSourceConfigReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub inline fn getTargetBuffer(self: *const DataSourceConfigReader) u32 {
        return self._target_buffer;
    }
    pub inline fn getTraceDurationMs(self: *const DataSourceConfigReader) u32 {
        return self._trace_duration_ms;
    }
    pub inline fn getPreferSuspendClockForDuration(self: *const DataSourceConfigReader) bool {
        return self._prefer_suspend_clock_for_duration;
    }
    pub inline fn getStopTimeoutMs(self: *const DataSourceConfigReader) u32 {
        return self._stop_timeout_ms;
    }
    pub inline fn getEnableExtraGuardrails(self: *const DataSourceConfigReader) bool {
        return self._enable_extra_guardrails;
    }
    pub inline fn getSessionInitiator(self: *const DataSourceConfigReader) DataSourceConfig.SessionInitiator {
        return self._session_initiator;
    }
    pub inline fn getTracingSessionId(self: *const DataSourceConfigReader) u64 {
        return self._tracing_session_id;
    }
    pub inline fn getBufferExhaustedPolicy(self: *const DataSourceConfigReader) DataSourceConfig.BufferExhaustedPolicy {
        return self._buffer_exhausted_policy;
    }
    pub fn getPriorityBoost(self: *const DataSourceConfigReader) gremlin.Error!PriorityBoostConfigReader {
        if (self._priority_boost_buf) |buf| {
            return try PriorityBoostConfigReader.init(buf);
        }
        return try PriorityBoostConfigReader.init(&[_]u8{});
    }
    pub fn getFtraceConfig(self: *const DataSourceConfigReader) gremlin.Error!FtraceConfigReader {
        if (self._ftrace_config_buf) |buf| {
            return try FtraceConfigReader.init(buf);
        }
        return try FtraceConfigReader.init(&[_]u8{});
    }
    pub fn getInodeFileConfig(self: *const DataSourceConfigReader) gremlin.Error!InodeFileConfigReader {
        if (self._inode_file_config_buf) |buf| {
            return try InodeFileConfigReader.init(buf);
        }
        return try InodeFileConfigReader.init(&[_]u8{});
    }
    pub fn getProcessStatsConfig(self: *const DataSourceConfigReader) gremlin.Error!ProcessStatsConfigReader {
        if (self._process_stats_config_buf) |buf| {
            return try ProcessStatsConfigReader.init(buf);
        }
        return try ProcessStatsConfigReader.init(&[_]u8{});
    }
    pub fn getSysStatsConfig(self: *const DataSourceConfigReader) gremlin.Error!SysStatsConfigReader {
        if (self._sys_stats_config_buf) |buf| {
            return try SysStatsConfigReader.init(buf);
        }
        return try SysStatsConfigReader.init(&[_]u8{});
    }
    pub fn getHeapprofdConfig(self: *const DataSourceConfigReader) gremlin.Error!HeapprofdConfigReader {
        if (self._heapprofd_config_buf) |buf| {
            return try HeapprofdConfigReader.init(buf);
        }
        return try HeapprofdConfigReader.init(&[_]u8{});
    }
    pub fn getJavaHprofConfig(self: *const DataSourceConfigReader) gremlin.Error!JavaHprofConfigReader {
        if (self._java_hprof_config_buf) |buf| {
            return try JavaHprofConfigReader.init(buf);
        }
        return try JavaHprofConfigReader.init(&[_]u8{});
    }
    pub fn getAndroidPowerConfig(self: *const DataSourceConfigReader) gremlin.Error!AndroidPowerConfigReader {
        if (self._android_power_config_buf) |buf| {
            return try AndroidPowerConfigReader.init(buf);
        }
        return try AndroidPowerConfigReader.init(&[_]u8{});
    }
    pub fn getAndroidLogConfig(self: *const DataSourceConfigReader) gremlin.Error!AndroidLogConfigReader {
        if (self._android_log_config_buf) |buf| {
            return try AndroidLogConfigReader.init(buf);
        }
        return try AndroidLogConfigReader.init(&[_]u8{});
    }
    pub fn getGpuCounterConfig(self: *const DataSourceConfigReader) gremlin.Error!GpuCounterConfigReader {
        if (self._gpu_counter_config_buf) |buf| {
            return try GpuCounterConfigReader.init(buf);
        }
        return try GpuCounterConfigReader.init(&[_]u8{});
    }
    pub fn getAndroidGameInterventionListConfig(self: *const DataSourceConfigReader) gremlin.Error!AndroidGameInterventionListConfigReader {
        if (self._android_game_intervention_list_config_buf) |buf| {
            return try AndroidGameInterventionListConfigReader.init(buf);
        }
        return try AndroidGameInterventionListConfigReader.init(&[_]u8{});
    }
    pub fn getPackagesListConfig(self: *const DataSourceConfigReader) gremlin.Error!PackagesListConfigReader {
        if (self._packages_list_config_buf) |buf| {
            return try PackagesListConfigReader.init(buf);
        }
        return try PackagesListConfigReader.init(&[_]u8{});
    }
    pub fn getPerfEventConfig(self: *const DataSourceConfigReader) gremlin.Error!PerfEventConfigReader {
        if (self._perf_event_config_buf) |buf| {
            return try PerfEventConfigReader.init(buf);
        }
        return try PerfEventConfigReader.init(&[_]u8{});
    }
    pub fn getVulkanMemoryConfig(self: *const DataSourceConfigReader) gremlin.Error!VulkanMemoryConfigReader {
        if (self._vulkan_memory_config_buf) |buf| {
            return try VulkanMemoryConfigReader.init(buf);
        }
        return try VulkanMemoryConfigReader.init(&[_]u8{});
    }
    pub fn getTrackEventConfig(self: *const DataSourceConfigReader) gremlin.Error!TrackEventConfigReader {
        if (self._track_event_config_buf) |buf| {
            return try TrackEventConfigReader.init(buf);
        }
        return try TrackEventConfigReader.init(&[_]u8{});
    }
    pub fn getAndroidPolledStateConfig(self: *const DataSourceConfigReader) gremlin.Error!AndroidPolledStateConfigReader {
        if (self._android_polled_state_config_buf) |buf| {
            return try AndroidPolledStateConfigReader.init(buf);
        }
        return try AndroidPolledStateConfigReader.init(&[_]u8{});
    }
    pub fn getAndroidSystemPropertyConfig(self: *const DataSourceConfigReader) gremlin.Error!AndroidSystemPropertyConfigReader {
        if (self._android_system_property_config_buf) |buf| {
            return try AndroidSystemPropertyConfigReader.init(buf);
        }
        return try AndroidSystemPropertyConfigReader.init(&[_]u8{});
    }
    pub fn getStatsdTracingConfig(self: *const DataSourceConfigReader) gremlin.Error!StatsdTracingConfigReader {
        if (self._statsd_tracing_config_buf) |buf| {
            return try StatsdTracingConfigReader.init(buf);
        }
        return try StatsdTracingConfigReader.init(&[_]u8{});
    }
    pub fn getSystemInfoConfig(self: *const DataSourceConfigReader) gremlin.Error!SystemInfoConfigReader {
        if (self._system_info_config_buf) |buf| {
            return try SystemInfoConfigReader.init(buf);
        }
        return try SystemInfoConfigReader.init(&[_]u8{});
    }
    pub fn getFrozenFtraceConfig(self: *const DataSourceConfigReader) gremlin.Error!FrozenFtraceConfigReader {
        if (self._frozen_ftrace_config_buf) |buf| {
            return try FrozenFtraceConfigReader.init(buf);
        }
        return try FrozenFtraceConfigReader.init(&[_]u8{});
    }
    pub fn getChromeConfig(self: *const DataSourceConfigReader) gremlin.Error!ChromeConfigReader {
        if (self._chrome_config_buf) |buf| {
            return try ChromeConfigReader.init(buf);
        }
        return try ChromeConfigReader.init(&[_]u8{});
    }
    pub fn getV8Config(self: *const DataSourceConfigReader) gremlin.Error!V8ConfigReader {
        if (self._v8_config_buf) |buf| {
            return try V8ConfigReader.init(buf);
        }
        return try V8ConfigReader.init(&[_]u8{});
    }
    pub fn getInterceptorConfig(self: *const DataSourceConfigReader) gremlin.Error!InterceptorConfigReader {
        if (self._interceptor_config_buf) |buf| {
            return try InterceptorConfigReader.init(buf);
        }
        return try InterceptorConfigReader.init(&[_]u8{});
    }
    pub fn getNetworkPacketTraceConfig(self: *const DataSourceConfigReader) gremlin.Error!NetworkPacketTraceConfigReader {
        if (self._network_packet_trace_config_buf) |buf| {
            return try NetworkPacketTraceConfigReader.init(buf);
        }
        return try NetworkPacketTraceConfigReader.init(&[_]u8{});
    }
    pub fn getSurfaceflingerLayersConfig(self: *const DataSourceConfigReader) gremlin.Error!SurfaceFlingerLayersConfigReader {
        if (self._surfaceflinger_layers_config_buf) |buf| {
            return try SurfaceFlingerLayersConfigReader.init(buf);
        }
        return try SurfaceFlingerLayersConfigReader.init(&[_]u8{});
    }
    pub fn getSurfaceflingerTransactionsConfig(self: *const DataSourceConfigReader) gremlin.Error!SurfaceFlingerTransactionsConfigReader {
        if (self._surfaceflinger_transactions_config_buf) |buf| {
            return try SurfaceFlingerTransactionsConfigReader.init(buf);
        }
        return try SurfaceFlingerTransactionsConfigReader.init(&[_]u8{});
    }
    pub fn getAndroidSdkSyspropGuardConfig(self: *const DataSourceConfigReader) gremlin.Error!AndroidSdkSyspropGuardConfigReader {
        if (self._android_sdk_sysprop_guard_config_buf) |buf| {
            return try AndroidSdkSyspropGuardConfigReader.init(buf);
        }
        return try AndroidSdkSyspropGuardConfigReader.init(&[_]u8{});
    }
    pub fn getEtwConfig(self: *const DataSourceConfigReader) gremlin.Error!EtwConfigReader {
        if (self._etw_config_buf) |buf| {
            return try EtwConfigReader.init(buf);
        }
        return try EtwConfigReader.init(&[_]u8{});
    }
    pub fn getProtologConfig(self: *const DataSourceConfigReader) gremlin.Error!ProtoLogConfigReader {
        if (self._protolog_config_buf) |buf| {
            return try ProtoLogConfigReader.init(buf);
        }
        return try ProtoLogConfigReader.init(&[_]u8{});
    }
    pub fn getAndroidInputEventConfig(self: *const DataSourceConfigReader) gremlin.Error!AndroidInputEventConfigReader {
        if (self._android_input_event_config_buf) |buf| {
            return try AndroidInputEventConfigReader.init(buf);
        }
        return try AndroidInputEventConfigReader.init(&[_]u8{});
    }
    pub fn getPixelModemConfig(self: *const DataSourceConfigReader) gremlin.Error!PixelModemConfigReader {
        if (self._pixel_modem_config_buf) |buf| {
            return try PixelModemConfigReader.init(buf);
        }
        return try PixelModemConfigReader.init(&[_]u8{});
    }
    pub fn getWindowmanagerConfig(self: *const DataSourceConfigReader) gremlin.Error!WindowManagerConfigReader {
        if (self._windowmanager_config_buf) |buf| {
            return try WindowManagerConfigReader.init(buf);
        }
        return try WindowManagerConfigReader.init(&[_]u8{});
    }
    pub fn getChromiumSystemMetrics(self: *const DataSourceConfigReader) gremlin.Error!ChromiumSystemMetricsConfigReader {
        if (self._chromium_system_metrics_buf) |buf| {
            return try ChromiumSystemMetricsConfigReader.init(buf);
        }
        return try ChromiumSystemMetricsConfigReader.init(&[_]u8{});
    }
    pub fn getKernelWakelocksConfig(self: *const DataSourceConfigReader) gremlin.Error!KernelWakelocksConfigReader {
        if (self._kernel_wakelocks_config_buf) |buf| {
            return try KernelWakelocksConfigReader.init(buf);
        }
        return try KernelWakelocksConfigReader.init(&[_]u8{});
    }
    pub fn getGpuRenderstagesConfig(self: *const DataSourceConfigReader) gremlin.Error!GpuRenderStagesConfigReader {
        if (self._gpu_renderstages_config_buf) |buf| {
            return try GpuRenderStagesConfigReader.init(buf);
        }
        return try GpuRenderStagesConfigReader.init(&[_]u8{});
    }
    pub fn getChromiumHistogramSamples(self: *const DataSourceConfigReader) gremlin.Error!ChromiumHistogramSamplesConfigReader {
        if (self._chromium_histogram_samples_buf) |buf| {
            return try ChromiumHistogramSamplesConfigReader.init(buf);
        }
        return try ChromiumHistogramSamplesConfigReader.init(&[_]u8{});
    }
    pub fn getAppWakelocksConfig(self: *const DataSourceConfigReader) gremlin.Error!AppWakelocksConfigReader {
        if (self._app_wakelocks_config_buf) |buf| {
            return try AppWakelocksConfigReader.init(buf);
        }
        return try AppWakelocksConfigReader.init(&[_]u8{});
    }
    pub fn getCpuPerUidConfig(self: *const DataSourceConfigReader) gremlin.Error!CpuPerUidConfigReader {
        if (self._cpu_per_uid_config_buf) |buf| {
            return try CpuPerUidConfigReader.init(buf);
        }
        return try CpuPerUidConfigReader.init(&[_]u8{});
    }
    pub inline fn getLegacyConfig(self: *const DataSourceConfigReader) []const u8 {
        return self._legacy_config orelse &[_]u8{};
    }
    pub fn getForTesting(self: *const DataSourceConfigReader) gremlin.Error!TestConfigReader {
        if (self._for_testing_buf) |buf| {
            return try TestConfigReader.init(buf);
        }
        return try TestConfigReader.init(&[_]u8{});
    }
};
const TraceConfigWire = struct {
    const BUFFERS_WIRE: gremlin.ProtoWireNumber = 1;
    const DATA_SOURCES_WIRE: gremlin.ProtoWireNumber = 2;
    const BUILTIN_DATA_SOURCES_WIRE: gremlin.ProtoWireNumber = 20;
    const DURATION_MS_WIRE: gremlin.ProtoWireNumber = 3;
    const PREFER_SUSPEND_CLOCK_FOR_DURATION_WIRE: gremlin.ProtoWireNumber = 36;
    const ENABLE_EXTRA_GUARDRAILS_WIRE: gremlin.ProtoWireNumber = 4;
    const LOCKDOWN_MODE_WIRE: gremlin.ProtoWireNumber = 5;
    const PRODUCERS_WIRE: gremlin.ProtoWireNumber = 6;
    const STATSD_METADATA_WIRE: gremlin.ProtoWireNumber = 7;
    const WRITE_INTO_FILE_WIRE: gremlin.ProtoWireNumber = 8;
    const OUTPUT_PATH_WIRE: gremlin.ProtoWireNumber = 29;
    const FILE_WRITE_PERIOD_MS_WIRE: gremlin.ProtoWireNumber = 9;
    const MAX_FILE_SIZE_BYTES_WIRE: gremlin.ProtoWireNumber = 10;
    const GUARDRAIL_OVERRIDES_WIRE: gremlin.ProtoWireNumber = 11;
    const DEFERRED_START_WIRE: gremlin.ProtoWireNumber = 12;
    const FLUSH_PERIOD_MS_WIRE: gremlin.ProtoWireNumber = 13;
    const FLUSH_TIMEOUT_MS_WIRE: gremlin.ProtoWireNumber = 14;
    const DATA_SOURCE_STOP_TIMEOUT_MS_WIRE: gremlin.ProtoWireNumber = 23;
    const NOTIFY_TRACEUR_WIRE: gremlin.ProtoWireNumber = 16;
    const BUGREPORT_SCORE_WIRE: gremlin.ProtoWireNumber = 30;
    const BUGREPORT_FILENAME_WIRE: gremlin.ProtoWireNumber = 38;
    const TRIGGER_CONFIG_WIRE: gremlin.ProtoWireNumber = 17;
    const ACTIVATE_TRIGGERS_WIRE: gremlin.ProtoWireNumber = 18;
    const INCREMENTAL_STATE_CONFIG_WIRE: gremlin.ProtoWireNumber = 21;
    const ALLOW_USER_BUILD_TRACING_WIRE: gremlin.ProtoWireNumber = 19;
    const UNIQUE_SESSION_NAME_WIRE: gremlin.ProtoWireNumber = 22;
    const COMPRESSION_TYPE_WIRE: gremlin.ProtoWireNumber = 24;
    const INCIDENT_REPORT_CONFIG_WIRE: gremlin.ProtoWireNumber = 25;
    const STATSD_LOGGING_WIRE: gremlin.ProtoWireNumber = 31;
    const TRACE_UUID_MSB_WIRE: gremlin.ProtoWireNumber = 27;
    const TRACE_UUID_LSB_WIRE: gremlin.ProtoWireNumber = 28;
    const TRACE_FILTER_WIRE: gremlin.ProtoWireNumber = 33;
    const ANDROID_REPORT_CONFIG_WIRE: gremlin.ProtoWireNumber = 34;
    const CMD_TRACE_START_DELAY_WIRE: gremlin.ProtoWireNumber = 35;
    const SESSION_SEMAPHORES_WIRE: gremlin.ProtoWireNumber = 39;
    const PRIORITY_BOOST_WIRE: gremlin.ProtoWireNumber = 40;
    const EXCLUSIVE_PRIO_WIRE: gremlin.ProtoWireNumber = 41;
    const NO_FLUSH_BEFORE_WRITE_INTO_FILE_WIRE: gremlin.ProtoWireNumber = 42;
};
pub const TraceConfig = struct {
    // nested enums
    pub const LockdownModeOperation = enum(i32) {
        LOCKDOWN_UNCHANGED = 0,
        LOCKDOWN_CLEAR = 1,
        LOCKDOWN_SET = 2,
    };
    pub const CompressionType = enum(i32) {
        COMPRESSION_TYPE_UNSPECIFIED = 0,
        COMPRESSION_TYPE_DEFLATE = 1,
    };
    pub const StatsdLogging = enum(i32) {
        STATSD_LOGGING_UNSPECIFIED = 0,
        STATSD_LOGGING_ENABLED = 1,
        STATSD_LOGGING_DISABLED = 2,
    };
    // nested structs
    const BufferConfigWire = struct {
        const SIZE_KB_WIRE: gremlin.ProtoWireNumber = 1;
        const FILL_POLICY_WIRE: gremlin.ProtoWireNumber = 4;
        const TRANSFER_ON_CLONE_WIRE: gremlin.ProtoWireNumber = 5;
        const CLEAR_BEFORE_CLONE_WIRE: gremlin.ProtoWireNumber = 6;
    };
    pub const BufferConfig = struct {
        // nested enums
        pub const FillPolicy = enum(i32) {
            UNSPECIFIED = 0,
            RING_BUFFER = 1,
            DISCARD = 2,
        };
        // fields
        size_kb: u32 = 0,
        fill_policy: TraceConfig.BufferConfig.FillPolicy = @enumFromInt(0),
        transfer_on_clone: bool = false,
        clear_before_clone: bool = false,
        pub fn calcProtobufSize(self: *const TraceConfig.BufferConfig) usize {
            var res: usize = 0;
            if (self.size_kb != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceConfig.BufferConfigWire.SIZE_KB_WIRE) + gremlin.sizes.sizeU32(self.size_kb);
            }
            if (@intFromEnum(self.fill_policy) != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceConfig.BufferConfigWire.FILL_POLICY_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.fill_policy));
            }
            if (self.transfer_on_clone != false) {
                res += gremlin.sizes.sizeWireNumber(TraceConfig.BufferConfigWire.TRANSFER_ON_CLONE_WIRE) + gremlin.sizes.sizeBool(self.transfer_on_clone);
            }
            if (self.clear_before_clone != false) {
                res += gremlin.sizes.sizeWireNumber(TraceConfig.BufferConfigWire.CLEAR_BEFORE_CLONE_WIRE) + gremlin.sizes.sizeBool(self.clear_before_clone);
            }
            return res;
        }
        pub fn encode(self: *const TraceConfig.BufferConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const TraceConfig.BufferConfig, target: *gremlin.Writer) void {
            if (self.size_kb != 0) {
                target.appendUint32(TraceConfig.BufferConfigWire.SIZE_KB_WIRE, self.size_kb);
            }
            if (@intFromEnum(self.fill_policy) != 0) {
                target.appendInt32(TraceConfig.BufferConfigWire.FILL_POLICY_WIRE, @intFromEnum(self.fill_policy));
            }
            if (self.transfer_on_clone != false) {
                target.appendBool(TraceConfig.BufferConfigWire.TRANSFER_ON_CLONE_WIRE, self.transfer_on_clone);
            }
            if (self.clear_before_clone != false) {
                target.appendBool(TraceConfig.BufferConfigWire.CLEAR_BEFORE_CLONE_WIRE, self.clear_before_clone);
            }
        }
    };
    pub const BufferConfigReader = struct {
        buf: gremlin.Reader,
        _size_kb: u32 = 0,
        _fill_policy: TraceConfig.BufferConfig.FillPolicy = @enumFromInt(0),
        _transfer_on_clone: bool = false,
        _clear_before_clone: bool = false,
        pub fn init(src: []const u8) gremlin.Error!TraceConfig.BufferConfigReader {
            const buf = gremlin.Reader.init(src);
            var res = TraceConfig.BufferConfigReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    TraceConfig.BufferConfigWire.SIZE_KB_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._size_kb = result.value;
                    },
                    TraceConfig.BufferConfigWire.FILL_POLICY_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._fill_policy = @enumFromInt(result.value);
                    },
                    TraceConfig.BufferConfigWire.TRANSFER_ON_CLONE_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._transfer_on_clone = result.value;
                    },
                    TraceConfig.BufferConfigWire.CLEAR_BEFORE_CLONE_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._clear_before_clone = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getSizeKb(self: *const TraceConfig.BufferConfigReader) u32 {
            return self._size_kb;
        }
        pub inline fn getFillPolicy(self: *const TraceConfig.BufferConfigReader) TraceConfig.BufferConfig.FillPolicy {
            return self._fill_policy;
        }
        pub inline fn getTransferOnClone(self: *const TraceConfig.BufferConfigReader) bool {
            return self._transfer_on_clone;
        }
        pub inline fn getClearBeforeClone(self: *const TraceConfig.BufferConfigReader) bool {
            return self._clear_before_clone;
        }
    };
    const DataSourceWire = struct {
        const CONFIG_WIRE: gremlin.ProtoWireNumber = 1;
        const PRODUCER_NAME_FILTER_WIRE: gremlin.ProtoWireNumber = 2;
        const PRODUCER_NAME_REGEX_FILTER_WIRE: gremlin.ProtoWireNumber = 3;
        const MACHINE_NAME_FILTER_WIRE: gremlin.ProtoWireNumber = 4;
    };
    pub const DataSource = struct {
        // fields
        config: ?DataSourceConfig = null,
        producer_name_filter: ?[]const ?[]const u8 = null,
        producer_name_regex_filter: ?[]const ?[]const u8 = null,
        machine_name_filter: ?[]const ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const TraceConfig.DataSource) usize {
            var res: usize = 0;
            if (self.config) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(TraceConfig.DataSourceWire.CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.producer_name_filter) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(TraceConfig.DataSourceWire.PRODUCER_NAME_FILTER_WIRE);
                    if (maybe_v) |v| {
                        res += gremlin.sizes.sizeUsize(v.len) + v.len;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.producer_name_regex_filter) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(TraceConfig.DataSourceWire.PRODUCER_NAME_REGEX_FILTER_WIRE);
                    if (maybe_v) |v| {
                        res += gremlin.sizes.sizeUsize(v.len) + v.len;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.machine_name_filter) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(TraceConfig.DataSourceWire.MACHINE_NAME_FILTER_WIRE);
                    if (maybe_v) |v| {
                        res += gremlin.sizes.sizeUsize(v.len) + v.len;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const TraceConfig.DataSource, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const TraceConfig.DataSource, target: *gremlin.Writer) void {
            if (self.config) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(TraceConfig.DataSourceWire.CONFIG_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.producer_name_filter) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        target.appendBytes(TraceConfig.DataSourceWire.PRODUCER_NAME_FILTER_WIRE, v);
                    } else {
                        target.appendBytesTag(TraceConfig.DataSourceWire.PRODUCER_NAME_FILTER_WIRE, 0);
                    }
                }
            }
            if (self.producer_name_regex_filter) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        target.appendBytes(TraceConfig.DataSourceWire.PRODUCER_NAME_REGEX_FILTER_WIRE, v);
                    } else {
                        target.appendBytesTag(TraceConfig.DataSourceWire.PRODUCER_NAME_REGEX_FILTER_WIRE, 0);
                    }
                }
            }
            if (self.machine_name_filter) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        target.appendBytes(TraceConfig.DataSourceWire.MACHINE_NAME_FILTER_WIRE, v);
                    } else {
                        target.appendBytesTag(TraceConfig.DataSourceWire.MACHINE_NAME_FILTER_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const DataSourceReader = struct {
        buf: gremlin.Reader,
        _config_buf: ?[]const u8 = null,
        _producer_name_filter_offset: ?usize = null,
        _producer_name_filter_last_offset: ?usize = null,
        _producer_name_filter_cnt: usize = 0,
        _producer_name_regex_filter_offset: ?usize = null,
        _producer_name_regex_filter_last_offset: ?usize = null,
        _producer_name_regex_filter_cnt: usize = 0,
        _machine_name_filter_offset: ?usize = null,
        _machine_name_filter_last_offset: ?usize = null,
        _machine_name_filter_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!TraceConfig.DataSourceReader {
            const buf = gremlin.Reader.init(src);
            var res = TraceConfig.DataSourceReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    TraceConfig.DataSourceWire.CONFIG_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._config_buf = result.value;
                    },
                    TraceConfig.DataSourceWire.PRODUCER_NAME_FILTER_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._producer_name_filter_offset == null) {
                            res._producer_name_filter_offset = offset - result.size;
                        }
                        res._producer_name_filter_last_offset = offset;
                        res._producer_name_filter_cnt += 1;
                    },
                    TraceConfig.DataSourceWire.PRODUCER_NAME_REGEX_FILTER_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._producer_name_regex_filter_offset == null) {
                            res._producer_name_regex_filter_offset = offset - result.size;
                        }
                        res._producer_name_regex_filter_last_offset = offset;
                        res._producer_name_regex_filter_cnt += 1;
                    },
                    TraceConfig.DataSourceWire.MACHINE_NAME_FILTER_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._machine_name_filter_offset == null) {
                            res._machine_name_filter_offset = offset - result.size;
                        }
                        res._machine_name_filter_last_offset = offset;
                        res._machine_name_filter_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn getConfig(self: *const TraceConfig.DataSourceReader) gremlin.Error!DataSourceConfigReader {
            if (self._config_buf) |buf| {
                return try DataSourceConfigReader.init(buf);
            }
            return try DataSourceConfigReader.init(&[_]u8{});
        }
        pub fn producerNameFilterCount(self: *const TraceConfig.DataSourceReader) usize {
            return self._producer_name_filter_cnt;
        }
        pub fn producerNameFilterNext(self: *TraceConfig.DataSourceReader) ?[]const u8 {
            if (self._producer_name_filter_offset == null) return null;
            const current_offset = self._producer_name_filter_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            if (self._producer_name_filter_last_offset != null and current_offset >= self._producer_name_filter_last_offset.?) {
                self._producer_name_filter_offset = null;
                return result.value;
            }
            if (self._producer_name_filter_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._producer_name_filter_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == TraceConfig.DataSourceWire.PRODUCER_NAME_FILTER_WIRE) {
                    self._producer_name_filter_offset = next_offset;
                    return result.value;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._producer_name_filter_offset = null;
            return result.value;
        }
        pub fn producerNameRegexFilterCount(self: *const TraceConfig.DataSourceReader) usize {
            return self._producer_name_regex_filter_cnt;
        }
        pub fn producerNameRegexFilterNext(self: *TraceConfig.DataSourceReader) ?[]const u8 {
            if (self._producer_name_regex_filter_offset == null) return null;
            const current_offset = self._producer_name_regex_filter_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            if (self._producer_name_regex_filter_last_offset != null and current_offset >= self._producer_name_regex_filter_last_offset.?) {
                self._producer_name_regex_filter_offset = null;
                return result.value;
            }
            if (self._producer_name_regex_filter_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._producer_name_regex_filter_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == TraceConfig.DataSourceWire.PRODUCER_NAME_REGEX_FILTER_WIRE) {
                    self._producer_name_regex_filter_offset = next_offset;
                    return result.value;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._producer_name_regex_filter_offset = null;
            return result.value;
        }
        pub fn machineNameFilterCount(self: *const TraceConfig.DataSourceReader) usize {
            return self._machine_name_filter_cnt;
        }
        pub fn machineNameFilterNext(self: *TraceConfig.DataSourceReader) ?[]const u8 {
            if (self._machine_name_filter_offset == null) return null;
            const current_offset = self._machine_name_filter_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            if (self._machine_name_filter_last_offset != null and current_offset >= self._machine_name_filter_last_offset.?) {
                self._machine_name_filter_offset = null;
                return result.value;
            }
            if (self._machine_name_filter_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._machine_name_filter_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == TraceConfig.DataSourceWire.MACHINE_NAME_FILTER_WIRE) {
                    self._machine_name_filter_offset = next_offset;
                    return result.value;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._machine_name_filter_offset = null;
            return result.value;
        }
    };
    const BuiltinDataSourceWire = struct {
        const DISABLE_CLOCK_SNAPSHOTTING_WIRE: gremlin.ProtoWireNumber = 1;
        const DISABLE_TRACE_CONFIG_WIRE: gremlin.ProtoWireNumber = 2;
        const DISABLE_SYSTEM_INFO_WIRE: gremlin.ProtoWireNumber = 3;
        const DISABLE_SERVICE_EVENTS_WIRE: gremlin.ProtoWireNumber = 4;
        const PRIMARY_TRACE_CLOCK_WIRE: gremlin.ProtoWireNumber = 5;
        const SNAPSHOT_INTERVAL_MS_WIRE: gremlin.ProtoWireNumber = 6;
        const PREFER_SUSPEND_CLOCK_FOR_SNAPSHOT_WIRE: gremlin.ProtoWireNumber = 7;
        const DISABLE_CHUNK_USAGE_HISTOGRAMS_WIRE: gremlin.ProtoWireNumber = 8;
    };
    pub const BuiltinDataSource = struct {
        // fields
        disable_clock_snapshotting: bool = false,
        disable_trace_config: bool = false,
        disable_system_info: bool = false,
        disable_service_events: bool = false,
        primary_trace_clock: BuiltinClock = @enumFromInt(0),
        snapshot_interval_ms: u32 = 0,
        prefer_suspend_clock_for_snapshot: bool = false,
        disable_chunk_usage_histograms: bool = false,
        pub fn calcProtobufSize(self: *const TraceConfig.BuiltinDataSource) usize {
            var res: usize = 0;
            if (self.disable_clock_snapshotting != false) {
                res += gremlin.sizes.sizeWireNumber(TraceConfig.BuiltinDataSourceWire.DISABLE_CLOCK_SNAPSHOTTING_WIRE) + gremlin.sizes.sizeBool(self.disable_clock_snapshotting);
            }
            if (self.disable_trace_config != false) {
                res += gremlin.sizes.sizeWireNumber(TraceConfig.BuiltinDataSourceWire.DISABLE_TRACE_CONFIG_WIRE) + gremlin.sizes.sizeBool(self.disable_trace_config);
            }
            if (self.disable_system_info != false) {
                res += gremlin.sizes.sizeWireNumber(TraceConfig.BuiltinDataSourceWire.DISABLE_SYSTEM_INFO_WIRE) + gremlin.sizes.sizeBool(self.disable_system_info);
            }
            if (self.disable_service_events != false) {
                res += gremlin.sizes.sizeWireNumber(TraceConfig.BuiltinDataSourceWire.DISABLE_SERVICE_EVENTS_WIRE) + gremlin.sizes.sizeBool(self.disable_service_events);
            }
            if (@intFromEnum(self.primary_trace_clock) != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceConfig.BuiltinDataSourceWire.PRIMARY_TRACE_CLOCK_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.primary_trace_clock));
            }
            if (self.snapshot_interval_ms != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceConfig.BuiltinDataSourceWire.SNAPSHOT_INTERVAL_MS_WIRE) + gremlin.sizes.sizeU32(self.snapshot_interval_ms);
            }
            if (self.prefer_suspend_clock_for_snapshot != false) {
                res += gremlin.sizes.sizeWireNumber(TraceConfig.BuiltinDataSourceWire.PREFER_SUSPEND_CLOCK_FOR_SNAPSHOT_WIRE) + gremlin.sizes.sizeBool(self.prefer_suspend_clock_for_snapshot);
            }
            if (self.disable_chunk_usage_histograms != false) {
                res += gremlin.sizes.sizeWireNumber(TraceConfig.BuiltinDataSourceWire.DISABLE_CHUNK_USAGE_HISTOGRAMS_WIRE) + gremlin.sizes.sizeBool(self.disable_chunk_usage_histograms);
            }
            return res;
        }
        pub fn encode(self: *const TraceConfig.BuiltinDataSource, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const TraceConfig.BuiltinDataSource, target: *gremlin.Writer) void {
            if (self.disable_clock_snapshotting != false) {
                target.appendBool(TraceConfig.BuiltinDataSourceWire.DISABLE_CLOCK_SNAPSHOTTING_WIRE, self.disable_clock_snapshotting);
            }
            if (self.disable_trace_config != false) {
                target.appendBool(TraceConfig.BuiltinDataSourceWire.DISABLE_TRACE_CONFIG_WIRE, self.disable_trace_config);
            }
            if (self.disable_system_info != false) {
                target.appendBool(TraceConfig.BuiltinDataSourceWire.DISABLE_SYSTEM_INFO_WIRE, self.disable_system_info);
            }
            if (self.disable_service_events != false) {
                target.appendBool(TraceConfig.BuiltinDataSourceWire.DISABLE_SERVICE_EVENTS_WIRE, self.disable_service_events);
            }
            if (@intFromEnum(self.primary_trace_clock) != 0) {
                target.appendInt32(TraceConfig.BuiltinDataSourceWire.PRIMARY_TRACE_CLOCK_WIRE, @intFromEnum(self.primary_trace_clock));
            }
            if (self.snapshot_interval_ms != 0) {
                target.appendUint32(TraceConfig.BuiltinDataSourceWire.SNAPSHOT_INTERVAL_MS_WIRE, self.snapshot_interval_ms);
            }
            if (self.prefer_suspend_clock_for_snapshot != false) {
                target.appendBool(TraceConfig.BuiltinDataSourceWire.PREFER_SUSPEND_CLOCK_FOR_SNAPSHOT_WIRE, self.prefer_suspend_clock_for_snapshot);
            }
            if (self.disable_chunk_usage_histograms != false) {
                target.appendBool(TraceConfig.BuiltinDataSourceWire.DISABLE_CHUNK_USAGE_HISTOGRAMS_WIRE, self.disable_chunk_usage_histograms);
            }
        }
    };
    pub const BuiltinDataSourceReader = struct {
        buf: gremlin.Reader,
        _disable_clock_snapshotting: bool = false,
        _disable_trace_config: bool = false,
        _disable_system_info: bool = false,
        _disable_service_events: bool = false,
        _primary_trace_clock: BuiltinClock = @enumFromInt(0),
        _snapshot_interval_ms: u32 = 0,
        _prefer_suspend_clock_for_snapshot: bool = false,
        _disable_chunk_usage_histograms: bool = false,
        pub fn init(src: []const u8) gremlin.Error!TraceConfig.BuiltinDataSourceReader {
            const buf = gremlin.Reader.init(src);
            var res = TraceConfig.BuiltinDataSourceReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    TraceConfig.BuiltinDataSourceWire.DISABLE_CLOCK_SNAPSHOTTING_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._disable_clock_snapshotting = result.value;
                    },
                    TraceConfig.BuiltinDataSourceWire.DISABLE_TRACE_CONFIG_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._disable_trace_config = result.value;
                    },
                    TraceConfig.BuiltinDataSourceWire.DISABLE_SYSTEM_INFO_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._disable_system_info = result.value;
                    },
                    TraceConfig.BuiltinDataSourceWire.DISABLE_SERVICE_EVENTS_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._disable_service_events = result.value;
                    },
                    TraceConfig.BuiltinDataSourceWire.PRIMARY_TRACE_CLOCK_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._primary_trace_clock = @enumFromInt(result.value);
                    },
                    TraceConfig.BuiltinDataSourceWire.SNAPSHOT_INTERVAL_MS_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._snapshot_interval_ms = result.value;
                    },
                    TraceConfig.BuiltinDataSourceWire.PREFER_SUSPEND_CLOCK_FOR_SNAPSHOT_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._prefer_suspend_clock_for_snapshot = result.value;
                    },
                    TraceConfig.BuiltinDataSourceWire.DISABLE_CHUNK_USAGE_HISTOGRAMS_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._disable_chunk_usage_histograms = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getDisableClockSnapshotting(self: *const TraceConfig.BuiltinDataSourceReader) bool {
            return self._disable_clock_snapshotting;
        }
        pub inline fn getDisableTraceConfig(self: *const TraceConfig.BuiltinDataSourceReader) bool {
            return self._disable_trace_config;
        }
        pub inline fn getDisableSystemInfo(self: *const TraceConfig.BuiltinDataSourceReader) bool {
            return self._disable_system_info;
        }
        pub inline fn getDisableServiceEvents(self: *const TraceConfig.BuiltinDataSourceReader) bool {
            return self._disable_service_events;
        }
        pub inline fn getPrimaryTraceClock(self: *const TraceConfig.BuiltinDataSourceReader) BuiltinClock {
            return self._primary_trace_clock;
        }
        pub inline fn getSnapshotIntervalMs(self: *const TraceConfig.BuiltinDataSourceReader) u32 {
            return self._snapshot_interval_ms;
        }
        pub inline fn getPreferSuspendClockForSnapshot(self: *const TraceConfig.BuiltinDataSourceReader) bool {
            return self._prefer_suspend_clock_for_snapshot;
        }
        pub inline fn getDisableChunkUsageHistograms(self: *const TraceConfig.BuiltinDataSourceReader) bool {
            return self._disable_chunk_usage_histograms;
        }
    };
    const ProducerConfigWire = struct {
        const PRODUCER_NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const SHM_SIZE_KB_WIRE: gremlin.ProtoWireNumber = 2;
        const PAGE_SIZE_KB_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const ProducerConfig = struct {
        // fields
        producer_name: ?[]const u8 = null,
        shm_size_kb: u32 = 0,
        page_size_kb: u32 = 0,
        pub fn calcProtobufSize(self: *const TraceConfig.ProducerConfig) usize {
            var res: usize = 0;
            if (self.producer_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(TraceConfig.ProducerConfigWire.PRODUCER_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.shm_size_kb != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceConfig.ProducerConfigWire.SHM_SIZE_KB_WIRE) + gremlin.sizes.sizeU32(self.shm_size_kb);
            }
            if (self.page_size_kb != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceConfig.ProducerConfigWire.PAGE_SIZE_KB_WIRE) + gremlin.sizes.sizeU32(self.page_size_kb);
            }
            return res;
        }
        pub fn encode(self: *const TraceConfig.ProducerConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const TraceConfig.ProducerConfig, target: *gremlin.Writer) void {
            if (self.producer_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(TraceConfig.ProducerConfigWire.PRODUCER_NAME_WIRE, v);
                }
            }
            if (self.shm_size_kb != 0) {
                target.appendUint32(TraceConfig.ProducerConfigWire.SHM_SIZE_KB_WIRE, self.shm_size_kb);
            }
            if (self.page_size_kb != 0) {
                target.appendUint32(TraceConfig.ProducerConfigWire.PAGE_SIZE_KB_WIRE, self.page_size_kb);
            }
        }
    };
    pub const ProducerConfigReader = struct {
        buf: gremlin.Reader,
        _producer_name: ?[]const u8 = null,
        _shm_size_kb: u32 = 0,
        _page_size_kb: u32 = 0,
        pub fn init(src: []const u8) gremlin.Error!TraceConfig.ProducerConfigReader {
            const buf = gremlin.Reader.init(src);
            var res = TraceConfig.ProducerConfigReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    TraceConfig.ProducerConfigWire.PRODUCER_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._producer_name = result.value;
                    },
                    TraceConfig.ProducerConfigWire.SHM_SIZE_KB_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._shm_size_kb = result.value;
                    },
                    TraceConfig.ProducerConfigWire.PAGE_SIZE_KB_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._page_size_kb = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getProducerName(self: *const TraceConfig.ProducerConfigReader) []const u8 {
            return self._producer_name orelse &[_]u8{};
        }
        pub inline fn getShmSizeKb(self: *const TraceConfig.ProducerConfigReader) u32 {
            return self._shm_size_kb;
        }
        pub inline fn getPageSizeKb(self: *const TraceConfig.ProducerConfigReader) u32 {
            return self._page_size_kb;
        }
    };
    const StatsdMetadataWire = struct {
        const TRIGGERING_ALERT_ID_WIRE: gremlin.ProtoWireNumber = 1;
        const TRIGGERING_CONFIG_UID_WIRE: gremlin.ProtoWireNumber = 2;
        const TRIGGERING_CONFIG_ID_WIRE: gremlin.ProtoWireNumber = 3;
        const TRIGGERING_SUBSCRIPTION_ID_WIRE: gremlin.ProtoWireNumber = 4;
    };
    pub const StatsdMetadata = struct {
        // fields
        triggering_alert_id: i64 = 0,
        triggering_config_uid: i32 = 0,
        triggering_config_id: i64 = 0,
        triggering_subscription_id: i64 = 0,
        pub fn calcProtobufSize(self: *const TraceConfig.StatsdMetadata) usize {
            var res: usize = 0;
            if (self.triggering_alert_id != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceConfig.StatsdMetadataWire.TRIGGERING_ALERT_ID_WIRE) + gremlin.sizes.sizeI64(self.triggering_alert_id);
            }
            if (self.triggering_config_uid != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceConfig.StatsdMetadataWire.TRIGGERING_CONFIG_UID_WIRE) + gremlin.sizes.sizeI32(self.triggering_config_uid);
            }
            if (self.triggering_config_id != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceConfig.StatsdMetadataWire.TRIGGERING_CONFIG_ID_WIRE) + gremlin.sizes.sizeI64(self.triggering_config_id);
            }
            if (self.triggering_subscription_id != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceConfig.StatsdMetadataWire.TRIGGERING_SUBSCRIPTION_ID_WIRE) + gremlin.sizes.sizeI64(self.triggering_subscription_id);
            }
            return res;
        }
        pub fn encode(self: *const TraceConfig.StatsdMetadata, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const TraceConfig.StatsdMetadata, target: *gremlin.Writer) void {
            if (self.triggering_alert_id != 0) {
                target.appendInt64(TraceConfig.StatsdMetadataWire.TRIGGERING_ALERT_ID_WIRE, self.triggering_alert_id);
            }
            if (self.triggering_config_uid != 0) {
                target.appendInt32(TraceConfig.StatsdMetadataWire.TRIGGERING_CONFIG_UID_WIRE, self.triggering_config_uid);
            }
            if (self.triggering_config_id != 0) {
                target.appendInt64(TraceConfig.StatsdMetadataWire.TRIGGERING_CONFIG_ID_WIRE, self.triggering_config_id);
            }
            if (self.triggering_subscription_id != 0) {
                target.appendInt64(TraceConfig.StatsdMetadataWire.TRIGGERING_SUBSCRIPTION_ID_WIRE, self.triggering_subscription_id);
            }
        }
    };
    pub const StatsdMetadataReader = struct {
        buf: gremlin.Reader,
        _triggering_alert_id: i64 = 0,
        _triggering_config_uid: i32 = 0,
        _triggering_config_id: i64 = 0,
        _triggering_subscription_id: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!TraceConfig.StatsdMetadataReader {
            const buf = gremlin.Reader.init(src);
            var res = TraceConfig.StatsdMetadataReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    TraceConfig.StatsdMetadataWire.TRIGGERING_ALERT_ID_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._triggering_alert_id = result.value;
                    },
                    TraceConfig.StatsdMetadataWire.TRIGGERING_CONFIG_UID_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._triggering_config_uid = result.value;
                    },
                    TraceConfig.StatsdMetadataWire.TRIGGERING_CONFIG_ID_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._triggering_config_id = result.value;
                    },
                    TraceConfig.StatsdMetadataWire.TRIGGERING_SUBSCRIPTION_ID_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._triggering_subscription_id = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getTriggeringAlertId(self: *const TraceConfig.StatsdMetadataReader) i64 {
            return self._triggering_alert_id;
        }
        pub inline fn getTriggeringConfigUid(self: *const TraceConfig.StatsdMetadataReader) i32 {
            return self._triggering_config_uid;
        }
        pub inline fn getTriggeringConfigId(self: *const TraceConfig.StatsdMetadataReader) i64 {
            return self._triggering_config_id;
        }
        pub inline fn getTriggeringSubscriptionId(self: *const TraceConfig.StatsdMetadataReader) i64 {
            return self._triggering_subscription_id;
        }
    };
    const GuardrailOverridesWire = struct {
        const MAX_UPLOAD_PER_DAY_BYTES_WIRE: gremlin.ProtoWireNumber = 1;
        const MAX_TRACING_BUFFER_SIZE_KB_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const GuardrailOverrides = struct {
        // fields
        max_upload_per_day_bytes: u64 = 0,
        max_tracing_buffer_size_kb: u32 = 0,
        pub fn calcProtobufSize(self: *const TraceConfig.GuardrailOverrides) usize {
            var res: usize = 0;
            if (self.max_upload_per_day_bytes != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceConfig.GuardrailOverridesWire.MAX_UPLOAD_PER_DAY_BYTES_WIRE) + gremlin.sizes.sizeU64(self.max_upload_per_day_bytes);
            }
            if (self.max_tracing_buffer_size_kb != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceConfig.GuardrailOverridesWire.MAX_TRACING_BUFFER_SIZE_KB_WIRE) + gremlin.sizes.sizeU32(self.max_tracing_buffer_size_kb);
            }
            return res;
        }
        pub fn encode(self: *const TraceConfig.GuardrailOverrides, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const TraceConfig.GuardrailOverrides, target: *gremlin.Writer) void {
            if (self.max_upload_per_day_bytes != 0) {
                target.appendUint64(TraceConfig.GuardrailOverridesWire.MAX_UPLOAD_PER_DAY_BYTES_WIRE, self.max_upload_per_day_bytes);
            }
            if (self.max_tracing_buffer_size_kb != 0) {
                target.appendUint32(TraceConfig.GuardrailOverridesWire.MAX_TRACING_BUFFER_SIZE_KB_WIRE, self.max_tracing_buffer_size_kb);
            }
        }
    };
    pub const GuardrailOverridesReader = struct {
        buf: gremlin.Reader,
        _max_upload_per_day_bytes: u64 = 0,
        _max_tracing_buffer_size_kb: u32 = 0,
        pub fn init(src: []const u8) gremlin.Error!TraceConfig.GuardrailOverridesReader {
            const buf = gremlin.Reader.init(src);
            var res = TraceConfig.GuardrailOverridesReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    TraceConfig.GuardrailOverridesWire.MAX_UPLOAD_PER_DAY_BYTES_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._max_upload_per_day_bytes = result.value;
                    },
                    TraceConfig.GuardrailOverridesWire.MAX_TRACING_BUFFER_SIZE_KB_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._max_tracing_buffer_size_kb = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getMaxUploadPerDayBytes(self: *const TraceConfig.GuardrailOverridesReader) u64 {
            return self._max_upload_per_day_bytes;
        }
        pub inline fn getMaxTracingBufferSizeKb(self: *const TraceConfig.GuardrailOverridesReader) u32 {
            return self._max_tracing_buffer_size_kb;
        }
    };
    const TriggerConfigWire = struct {
        const TRIGGER_MODE_WIRE: gremlin.ProtoWireNumber = 1;
        const USE_CLONE_SNAPSHOT_IF_AVAILABLE_WIRE: gremlin.ProtoWireNumber = 5;
        const TRIGGERS_WIRE: gremlin.ProtoWireNumber = 2;
        const TRIGGER_TIMEOUT_MS_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const TriggerConfig = struct {
        // nested enums
        pub const TriggerMode = enum(i32) {
            UNSPECIFIED = 0,
            START_TRACING = 1,
            STOP_TRACING = 2,
            CLONE_SNAPSHOT = 4,
        };
        // nested structs
        const TriggerWire = struct {
            const NAME_WIRE: gremlin.ProtoWireNumber = 1;
            const PRODUCER_NAME_REGEX_WIRE: gremlin.ProtoWireNumber = 2;
            const STOP_DELAY_MS_WIRE: gremlin.ProtoWireNumber = 3;
            const MAX_PER_24_H_WIRE: gremlin.ProtoWireNumber = 4;
            const SKIP_PROBABILITY_WIRE: gremlin.ProtoWireNumber = 5;
        };
        pub const Trigger = struct {
            // fields
            name: ?[]const u8 = null,
            producer_name_regex: ?[]const u8 = null,
            stop_delay_ms: u32 = 0,
            max_per_24_h: u32 = 0,
            skip_probability: f64 = 0.0,
            pub fn calcProtobufSize(self: *const TraceConfig.TriggerConfig.Trigger) usize {
                var res: usize = 0;
                if (self.name) |v| {
                    if (v.len > 0) {
                        res += gremlin.sizes.sizeWireNumber(TraceConfig.TriggerConfig.TriggerWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                    }
                }
                if (self.producer_name_regex) |v| {
                    if (v.len > 0) {
                        res += gremlin.sizes.sizeWireNumber(TraceConfig.TriggerConfig.TriggerWire.PRODUCER_NAME_REGEX_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                    }
                }
                if (self.stop_delay_ms != 0) {
                    res += gremlin.sizes.sizeWireNumber(TraceConfig.TriggerConfig.TriggerWire.STOP_DELAY_MS_WIRE) + gremlin.sizes.sizeU32(self.stop_delay_ms);
                }
                if (self.max_per_24_h != 0) {
                    res += gremlin.sizes.sizeWireNumber(TraceConfig.TriggerConfig.TriggerWire.MAX_PER_24_H_WIRE) + gremlin.sizes.sizeU32(self.max_per_24_h);
                }
                if (self.skip_probability != 0.0) {
                    res += gremlin.sizes.sizeWireNumber(TraceConfig.TriggerConfig.TriggerWire.SKIP_PROBABILITY_WIRE) + gremlin.sizes.sizeDouble(self.skip_probability);
                }
                return res;
            }
            pub fn encode(self: *const TraceConfig.TriggerConfig.Trigger, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const TraceConfig.TriggerConfig.Trigger, target: *gremlin.Writer) void {
                if (self.name) |v| {
                    if (v.len > 0) {
                        target.appendBytes(TraceConfig.TriggerConfig.TriggerWire.NAME_WIRE, v);
                    }
                }
                if (self.producer_name_regex) |v| {
                    if (v.len > 0) {
                        target.appendBytes(TraceConfig.TriggerConfig.TriggerWire.PRODUCER_NAME_REGEX_WIRE, v);
                    }
                }
                if (self.stop_delay_ms != 0) {
                    target.appendUint32(TraceConfig.TriggerConfig.TriggerWire.STOP_DELAY_MS_WIRE, self.stop_delay_ms);
                }
                if (self.max_per_24_h != 0) {
                    target.appendUint32(TraceConfig.TriggerConfig.TriggerWire.MAX_PER_24_H_WIRE, self.max_per_24_h);
                }
                if (self.skip_probability != 0.0) {
                    target.appendFloat64(TraceConfig.TriggerConfig.TriggerWire.SKIP_PROBABILITY_WIRE, self.skip_probability);
                }
            }
        };
        pub const TriggerReader = struct {
            buf: gremlin.Reader,
            _name: ?[]const u8 = null,
            _producer_name_regex: ?[]const u8 = null,
            _stop_delay_ms: u32 = 0,
            _max_per_24_h: u32 = 0,
            _skip_probability: f64 = 0.0,
            pub fn init(src: []const u8) gremlin.Error!TraceConfig.TriggerConfig.TriggerReader {
                const buf = gremlin.Reader.init(src);
                var res = TraceConfig.TriggerConfig.TriggerReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        TraceConfig.TriggerConfig.TriggerWire.NAME_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._name = result.value;
                        },
                        TraceConfig.TriggerConfig.TriggerWire.PRODUCER_NAME_REGEX_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._producer_name_regex = result.value;
                        },
                        TraceConfig.TriggerConfig.TriggerWire.STOP_DELAY_MS_WIRE => {
                            const result = try buf.readUInt32(offset);
                            offset += result.size;
                            res._stop_delay_ms = result.value;
                        },
                        TraceConfig.TriggerConfig.TriggerWire.MAX_PER_24_H_WIRE => {
                            const result = try buf.readUInt32(offset);
                            offset += result.size;
                            res._max_per_24_h = result.value;
                        },
                        TraceConfig.TriggerConfig.TriggerWire.SKIP_PROBABILITY_WIRE => {
                            const result = try buf.readFloat64(offset);
                            offset += result.size;
                            res._skip_probability = result.value;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub inline fn getName(self: *const TraceConfig.TriggerConfig.TriggerReader) []const u8 {
                return self._name orelse &[_]u8{};
            }
            pub inline fn getProducerNameRegex(self: *const TraceConfig.TriggerConfig.TriggerReader) []const u8 {
                return self._producer_name_regex orelse &[_]u8{};
            }
            pub inline fn getStopDelayMs(self: *const TraceConfig.TriggerConfig.TriggerReader) u32 {
                return self._stop_delay_ms;
            }
            pub inline fn getMaxPer24H(self: *const TraceConfig.TriggerConfig.TriggerReader) u32 {
                return self._max_per_24_h;
            }
            pub inline fn getSkipProbability(self: *const TraceConfig.TriggerConfig.TriggerReader) f64 {
                return self._skip_probability;
            }
        };
        // fields
        trigger_mode: TraceConfig.TriggerConfig.TriggerMode = @enumFromInt(0),
        use_clone_snapshot_if_available: bool = false,
        triggers: ?[]const ?TraceConfig.TriggerConfig.Trigger = null,
        trigger_timeout_ms: u32 = 0,
        pub fn calcProtobufSize(self: *const TraceConfig.TriggerConfig) usize {
            var res: usize = 0;
            if (@intFromEnum(self.trigger_mode) != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceConfig.TriggerConfigWire.TRIGGER_MODE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.trigger_mode));
            }
            if (self.use_clone_snapshot_if_available != false) {
                res += gremlin.sizes.sizeWireNumber(TraceConfig.TriggerConfigWire.USE_CLONE_SNAPSHOT_IF_AVAILABLE_WIRE) + gremlin.sizes.sizeBool(self.use_clone_snapshot_if_available);
            }
            if (self.triggers) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(TraceConfig.TriggerConfigWire.TRIGGERS_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.trigger_timeout_ms != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceConfig.TriggerConfigWire.TRIGGER_TIMEOUT_MS_WIRE) + gremlin.sizes.sizeU32(self.trigger_timeout_ms);
            }
            return res;
        }
        pub fn encode(self: *const TraceConfig.TriggerConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const TraceConfig.TriggerConfig, target: *gremlin.Writer) void {
            if (@intFromEnum(self.trigger_mode) != 0) {
                target.appendInt32(TraceConfig.TriggerConfigWire.TRIGGER_MODE_WIRE, @intFromEnum(self.trigger_mode));
            }
            if (self.use_clone_snapshot_if_available != false) {
                target.appendBool(TraceConfig.TriggerConfigWire.USE_CLONE_SNAPSHOT_IF_AVAILABLE_WIRE, self.use_clone_snapshot_if_available);
            }
            if (self.triggers) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(TraceConfig.TriggerConfigWire.TRIGGERS_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(TraceConfig.TriggerConfigWire.TRIGGERS_WIRE, 0);
                    }
                }
            }
            if (self.trigger_timeout_ms != 0) {
                target.appendUint32(TraceConfig.TriggerConfigWire.TRIGGER_TIMEOUT_MS_WIRE, self.trigger_timeout_ms);
            }
        }
    };
    pub const TriggerConfigReader = struct {
        buf: gremlin.Reader,
        _trigger_mode: TraceConfig.TriggerConfig.TriggerMode = @enumFromInt(0),
        _use_clone_snapshot_if_available: bool = false,
        _triggers_offset: ?usize = null,
        _triggers_last_offset: ?usize = null,
        _triggers_cnt: usize = 0,
        _trigger_timeout_ms: u32 = 0,
        pub fn init(src: []const u8) gremlin.Error!TraceConfig.TriggerConfigReader {
            const buf = gremlin.Reader.init(src);
            var res = TraceConfig.TriggerConfigReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    TraceConfig.TriggerConfigWire.TRIGGER_MODE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._trigger_mode = @enumFromInt(result.value);
                    },
                    TraceConfig.TriggerConfigWire.USE_CLONE_SNAPSHOT_IF_AVAILABLE_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._use_clone_snapshot_if_available = result.value;
                    },
                    TraceConfig.TriggerConfigWire.TRIGGERS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._triggers_offset == null) {
                            res._triggers_offset = offset - result.size;
                        }
                        res._triggers_last_offset = offset;
                        res._triggers_cnt += 1;
                    },
                    TraceConfig.TriggerConfigWire.TRIGGER_TIMEOUT_MS_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._trigger_timeout_ms = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getTriggerMode(self: *const TraceConfig.TriggerConfigReader) TraceConfig.TriggerConfig.TriggerMode {
            return self._trigger_mode;
        }
        pub inline fn getUseCloneSnapshotIfAvailable(self: *const TraceConfig.TriggerConfigReader) bool {
            return self._use_clone_snapshot_if_available;
        }
        pub fn triggersCount(self: *const TraceConfig.TriggerConfigReader) usize {
            return self._triggers_cnt;
        }
        pub fn triggersNext(self: *TraceConfig.TriggerConfigReader) ?TraceConfig.TriggerConfig.TriggerReader {
            if (self._triggers_offset == null) return null;
            const current_offset = self._triggers_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = TraceConfig.TriggerConfig.TriggerReader.init(result.value) catch return null;
            if (self._triggers_last_offset != null and current_offset >= self._triggers_last_offset.?) {
                self._triggers_offset = null;
                return msg;
            }
            if (self._triggers_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._triggers_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == TraceConfig.TriggerConfigWire.TRIGGERS_WIRE) {
                    self._triggers_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._triggers_offset = null;
            return msg;
        }
        pub inline fn getTriggerTimeoutMs(self: *const TraceConfig.TriggerConfigReader) u32 {
            return self._trigger_timeout_ms;
        }
    };
    const IncrementalStateConfigWire = struct {
        const CLEAR_PERIOD_MS_WIRE: gremlin.ProtoWireNumber = 1;
    };
    pub const IncrementalStateConfig = struct {
        // fields
        clear_period_ms: u32 = 0,
        pub fn calcProtobufSize(self: *const TraceConfig.IncrementalStateConfig) usize {
            var res: usize = 0;
            if (self.clear_period_ms != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceConfig.IncrementalStateConfigWire.CLEAR_PERIOD_MS_WIRE) + gremlin.sizes.sizeU32(self.clear_period_ms);
            }
            return res;
        }
        pub fn encode(self: *const TraceConfig.IncrementalStateConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const TraceConfig.IncrementalStateConfig, target: *gremlin.Writer) void {
            if (self.clear_period_ms != 0) {
                target.appendUint32(TraceConfig.IncrementalStateConfigWire.CLEAR_PERIOD_MS_WIRE, self.clear_period_ms);
            }
        }
    };
    pub const IncrementalStateConfigReader = struct {
        buf: gremlin.Reader,
        _clear_period_ms: u32 = 0,
        pub fn init(src: []const u8) gremlin.Error!TraceConfig.IncrementalStateConfigReader {
            const buf = gremlin.Reader.init(src);
            var res = TraceConfig.IncrementalStateConfigReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    TraceConfig.IncrementalStateConfigWire.CLEAR_PERIOD_MS_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._clear_period_ms = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getClearPeriodMs(self: *const TraceConfig.IncrementalStateConfigReader) u32 {
            return self._clear_period_ms;
        }
    };
    const IncidentReportConfigWire = struct {
        const DESTINATION_PACKAGE_WIRE: gremlin.ProtoWireNumber = 1;
        const DESTINATION_CLASS_WIRE: gremlin.ProtoWireNumber = 2;
        const PRIVACY_LEVEL_WIRE: gremlin.ProtoWireNumber = 3;
        const SKIP_INCIDENTD_WIRE: gremlin.ProtoWireNumber = 5;
        const SKIP_DROPBOX_WIRE: gremlin.ProtoWireNumber = 4;
    };
    pub const IncidentReportConfig = struct {
        // fields
        destination_package: ?[]const u8 = null,
        destination_class: ?[]const u8 = null,
        privacy_level: i32 = 0,
        skip_incidentd: bool = false,
        skip_dropbox: bool = false,
        pub fn calcProtobufSize(self: *const TraceConfig.IncidentReportConfig) usize {
            var res: usize = 0;
            if (self.destination_package) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(TraceConfig.IncidentReportConfigWire.DESTINATION_PACKAGE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.destination_class) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(TraceConfig.IncidentReportConfigWire.DESTINATION_CLASS_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.privacy_level != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceConfig.IncidentReportConfigWire.PRIVACY_LEVEL_WIRE) + gremlin.sizes.sizeI32(self.privacy_level);
            }
            if (self.skip_incidentd != false) {
                res += gremlin.sizes.sizeWireNumber(TraceConfig.IncidentReportConfigWire.SKIP_INCIDENTD_WIRE) + gremlin.sizes.sizeBool(self.skip_incidentd);
            }
            if (self.skip_dropbox != false) {
                res += gremlin.sizes.sizeWireNumber(TraceConfig.IncidentReportConfigWire.SKIP_DROPBOX_WIRE) + gremlin.sizes.sizeBool(self.skip_dropbox);
            }
            return res;
        }
        pub fn encode(self: *const TraceConfig.IncidentReportConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const TraceConfig.IncidentReportConfig, target: *gremlin.Writer) void {
            if (self.destination_package) |v| {
                if (v.len > 0) {
                    target.appendBytes(TraceConfig.IncidentReportConfigWire.DESTINATION_PACKAGE_WIRE, v);
                }
            }
            if (self.destination_class) |v| {
                if (v.len > 0) {
                    target.appendBytes(TraceConfig.IncidentReportConfigWire.DESTINATION_CLASS_WIRE, v);
                }
            }
            if (self.privacy_level != 0) {
                target.appendInt32(TraceConfig.IncidentReportConfigWire.PRIVACY_LEVEL_WIRE, self.privacy_level);
            }
            if (self.skip_incidentd != false) {
                target.appendBool(TraceConfig.IncidentReportConfigWire.SKIP_INCIDENTD_WIRE, self.skip_incidentd);
            }
            if (self.skip_dropbox != false) {
                target.appendBool(TraceConfig.IncidentReportConfigWire.SKIP_DROPBOX_WIRE, self.skip_dropbox);
            }
        }
    };
    pub const IncidentReportConfigReader = struct {
        buf: gremlin.Reader,
        _destination_package: ?[]const u8 = null,
        _destination_class: ?[]const u8 = null,
        _privacy_level: i32 = 0,
        _skip_incidentd: bool = false,
        _skip_dropbox: bool = false,
        pub fn init(src: []const u8) gremlin.Error!TraceConfig.IncidentReportConfigReader {
            const buf = gremlin.Reader.init(src);
            var res = TraceConfig.IncidentReportConfigReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    TraceConfig.IncidentReportConfigWire.DESTINATION_PACKAGE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._destination_package = result.value;
                    },
                    TraceConfig.IncidentReportConfigWire.DESTINATION_CLASS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._destination_class = result.value;
                    },
                    TraceConfig.IncidentReportConfigWire.PRIVACY_LEVEL_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._privacy_level = result.value;
                    },
                    TraceConfig.IncidentReportConfigWire.SKIP_INCIDENTD_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._skip_incidentd = result.value;
                    },
                    TraceConfig.IncidentReportConfigWire.SKIP_DROPBOX_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._skip_dropbox = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getDestinationPackage(self: *const TraceConfig.IncidentReportConfigReader) []const u8 {
            return self._destination_package orelse &[_]u8{};
        }
        pub inline fn getDestinationClass(self: *const TraceConfig.IncidentReportConfigReader) []const u8 {
            return self._destination_class orelse &[_]u8{};
        }
        pub inline fn getPrivacyLevel(self: *const TraceConfig.IncidentReportConfigReader) i32 {
            return self._privacy_level;
        }
        pub inline fn getSkipIncidentd(self: *const TraceConfig.IncidentReportConfigReader) bool {
            return self._skip_incidentd;
        }
        pub inline fn getSkipDropbox(self: *const TraceConfig.IncidentReportConfigReader) bool {
            return self._skip_dropbox;
        }
    };
    const TraceFilterWire = struct {
        const BYTECODE_WIRE: gremlin.ProtoWireNumber = 1;
        const BYTECODE_V2_WIRE: gremlin.ProtoWireNumber = 2;
        const STRING_FILTER_CHAIN_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const TraceFilter = struct {
        // nested enums
        pub const StringFilterPolicy = enum(i32) {
            SFP_UNSPECIFIED = 0,
            SFP_MATCH_REDACT_GROUPS = 1,
            SFP_ATRACE_MATCH_REDACT_GROUPS = 2,
            SFP_MATCH_BREAK = 3,
            SFP_ATRACE_MATCH_BREAK = 4,
            SFP_ATRACE_REPEATED_SEARCH_REDACT_GROUPS = 5,
        };
        // nested structs
        const StringFilterRuleWire = struct {
            const POLICY_WIRE: gremlin.ProtoWireNumber = 1;
            const REGEX_PATTERN_WIRE: gremlin.ProtoWireNumber = 2;
            const ATRACE_PAYLOAD_STARTS_WITH_WIRE: gremlin.ProtoWireNumber = 3;
        };
        pub const StringFilterRule = struct {
            // fields
            policy: TraceConfig.TraceFilter.StringFilterPolicy = @enumFromInt(0),
            regex_pattern: ?[]const u8 = null,
            atrace_payload_starts_with: ?[]const u8 = null,
            pub fn calcProtobufSize(self: *const TraceConfig.TraceFilter.StringFilterRule) usize {
                var res: usize = 0;
                if (@intFromEnum(self.policy) != 0) {
                    res += gremlin.sizes.sizeWireNumber(TraceConfig.TraceFilter.StringFilterRuleWire.POLICY_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.policy));
                }
                if (self.regex_pattern) |v| {
                    if (v.len > 0) {
                        res += gremlin.sizes.sizeWireNumber(TraceConfig.TraceFilter.StringFilterRuleWire.REGEX_PATTERN_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                    }
                }
                if (self.atrace_payload_starts_with) |v| {
                    if (v.len > 0) {
                        res += gremlin.sizes.sizeWireNumber(TraceConfig.TraceFilter.StringFilterRuleWire.ATRACE_PAYLOAD_STARTS_WITH_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                    }
                }
                return res;
            }
            pub fn encode(self: *const TraceConfig.TraceFilter.StringFilterRule, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const TraceConfig.TraceFilter.StringFilterRule, target: *gremlin.Writer) void {
                if (@intFromEnum(self.policy) != 0) {
                    target.appendInt32(TraceConfig.TraceFilter.StringFilterRuleWire.POLICY_WIRE, @intFromEnum(self.policy));
                }
                if (self.regex_pattern) |v| {
                    if (v.len > 0) {
                        target.appendBytes(TraceConfig.TraceFilter.StringFilterRuleWire.REGEX_PATTERN_WIRE, v);
                    }
                }
                if (self.atrace_payload_starts_with) |v| {
                    if (v.len > 0) {
                        target.appendBytes(TraceConfig.TraceFilter.StringFilterRuleWire.ATRACE_PAYLOAD_STARTS_WITH_WIRE, v);
                    }
                }
            }
        };
        pub const StringFilterRuleReader = struct {
            buf: gremlin.Reader,
            _policy: TraceConfig.TraceFilter.StringFilterPolicy = @enumFromInt(0),
            _regex_pattern: ?[]const u8 = null,
            _atrace_payload_starts_with: ?[]const u8 = null,
            pub fn init(src: []const u8) gremlin.Error!TraceConfig.TraceFilter.StringFilterRuleReader {
                const buf = gremlin.Reader.init(src);
                var res = TraceConfig.TraceFilter.StringFilterRuleReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        TraceConfig.TraceFilter.StringFilterRuleWire.POLICY_WIRE => {
                            const result = try buf.readInt32(offset);
                            offset += result.size;
                            res._policy = @enumFromInt(result.value);
                        },
                        TraceConfig.TraceFilter.StringFilterRuleWire.REGEX_PATTERN_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._regex_pattern = result.value;
                        },
                        TraceConfig.TraceFilter.StringFilterRuleWire.ATRACE_PAYLOAD_STARTS_WITH_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._atrace_payload_starts_with = result.value;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub inline fn getPolicy(self: *const TraceConfig.TraceFilter.StringFilterRuleReader) TraceConfig.TraceFilter.StringFilterPolicy {
                return self._policy;
            }
            pub inline fn getRegexPattern(self: *const TraceConfig.TraceFilter.StringFilterRuleReader) []const u8 {
                return self._regex_pattern orelse &[_]u8{};
            }
            pub inline fn getAtracePayloadStartsWith(self: *const TraceConfig.TraceFilter.StringFilterRuleReader) []const u8 {
                return self._atrace_payload_starts_with orelse &[_]u8{};
            }
        };
        const StringFilterChainWire = struct {
            const RULES_WIRE: gremlin.ProtoWireNumber = 1;
        };
        pub const StringFilterChain = struct {
            // fields
            rules: ?[]const ?TraceConfig.TraceFilter.StringFilterRule = null,
            pub fn calcProtobufSize(self: *const TraceConfig.TraceFilter.StringFilterChain) usize {
                var res: usize = 0;
                if (self.rules) |arr| {
                    for (arr) |maybe_v| {
                        res += gremlin.sizes.sizeWireNumber(TraceConfig.TraceFilter.StringFilterChainWire.RULES_WIRE);
                        if (maybe_v) |v| {
                            const size = v.calcProtobufSize();
                            res += gremlin.sizes.sizeUsize(size) + size;
                        } else {
                            res += gremlin.sizes.sizeUsize(0);
                        }
                    }
                }
                return res;
            }
            pub fn encode(self: *const TraceConfig.TraceFilter.StringFilterChain, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const TraceConfig.TraceFilter.StringFilterChain, target: *gremlin.Writer) void {
                if (self.rules) |arr| {
                    for (arr) |maybe_v| {
                        if (maybe_v) |v| {
                            const size = v.calcProtobufSize();
                            target.appendBytesTag(TraceConfig.TraceFilter.StringFilterChainWire.RULES_WIRE, size);
                            v.encodeTo(target);
                        } else {
                            target.appendBytesTag(TraceConfig.TraceFilter.StringFilterChainWire.RULES_WIRE, 0);
                        }
                    }
                }
            }
        };
        pub const StringFilterChainReader = struct {
            buf: gremlin.Reader,
            _rules_offset: ?usize = null,
            _rules_last_offset: ?usize = null,
            _rules_cnt: usize = 0,
            pub fn init(src: []const u8) gremlin.Error!TraceConfig.TraceFilter.StringFilterChainReader {
                const buf = gremlin.Reader.init(src);
                var res = TraceConfig.TraceFilter.StringFilterChainReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        TraceConfig.TraceFilter.StringFilterChainWire.RULES_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            if (res._rules_offset == null) {
                                res._rules_offset = offset - result.size;
                            }
                            res._rules_last_offset = offset;
                            res._rules_cnt += 1;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub fn rulesCount(self: *const TraceConfig.TraceFilter.StringFilterChainReader) usize {
                return self._rules_cnt;
            }
            pub fn rulesNext(self: *TraceConfig.TraceFilter.StringFilterChainReader) ?TraceConfig.TraceFilter.StringFilterRuleReader {
                if (self._rules_offset == null) return null;
                const current_offset = self._rules_offset.?;
                const result = self.buf.readBytes(current_offset) catch return null;
                const msg = TraceConfig.TraceFilter.StringFilterRuleReader.init(result.value) catch return null;
                if (self._rules_last_offset != null and current_offset >= self._rules_last_offset.?) {
                    self._rules_offset = null;
                    return msg;
                }
                if (self._rules_last_offset == null) unreachable;
                var next_offset = current_offset + result.size;
                const max_offset = self._rules_last_offset.?;
                while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                    const tag = self.buf.readTagAt(next_offset) catch break;
                    next_offset += tag.size;
                    if (tag.number == TraceConfig.TraceFilter.StringFilterChainWire.RULES_WIRE) {
                        self._rules_offset = next_offset;
                        return msg;
                    } else {
                        next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                    }
                }
                self._rules_offset = null;
                return msg;
            }
        };
        // fields
        bytecode: ?[]const u8 = null,
        bytecode_v2: ?[]const u8 = null,
        string_filter_chain: ?TraceConfig.TraceFilter.StringFilterChain = null,
        pub fn calcProtobufSize(self: *const TraceConfig.TraceFilter) usize {
            var res: usize = 0;
            if (self.bytecode) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(TraceConfig.TraceFilterWire.BYTECODE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.bytecode_v2) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(TraceConfig.TraceFilterWire.BYTECODE_V2_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.string_filter_chain) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(TraceConfig.TraceFilterWire.STRING_FILTER_CHAIN_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            return res;
        }
        pub fn encode(self: *const TraceConfig.TraceFilter, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const TraceConfig.TraceFilter, target: *gremlin.Writer) void {
            if (self.bytecode) |v| {
                if (v.len > 0) {
                    target.appendBytes(TraceConfig.TraceFilterWire.BYTECODE_WIRE, v);
                }
            }
            if (self.bytecode_v2) |v| {
                if (v.len > 0) {
                    target.appendBytes(TraceConfig.TraceFilterWire.BYTECODE_V2_WIRE, v);
                }
            }
            if (self.string_filter_chain) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(TraceConfig.TraceFilterWire.STRING_FILTER_CHAIN_WIRE, size);
                    v.encodeTo(target);
                }
            }
        }
    };
    pub const TraceFilterReader = struct {
        buf: gremlin.Reader,
        _bytecode: ?[]const u8 = null,
        _bytecode_v2: ?[]const u8 = null,
        _string_filter_chain_buf: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!TraceConfig.TraceFilterReader {
            const buf = gremlin.Reader.init(src);
            var res = TraceConfig.TraceFilterReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    TraceConfig.TraceFilterWire.BYTECODE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._bytecode = result.value;
                    },
                    TraceConfig.TraceFilterWire.BYTECODE_V2_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._bytecode_v2 = result.value;
                    },
                    TraceConfig.TraceFilterWire.STRING_FILTER_CHAIN_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._string_filter_chain_buf = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getBytecode(self: *const TraceConfig.TraceFilterReader) []const u8 {
            return self._bytecode orelse &[_]u8{};
        }
        pub inline fn getBytecodeV2(self: *const TraceConfig.TraceFilterReader) []const u8 {
            return self._bytecode_v2 orelse &[_]u8{};
        }
        pub fn getStringFilterChain(self: *const TraceConfig.TraceFilterReader) gremlin.Error!TraceConfig.TraceFilter.StringFilterChainReader {
            if (self._string_filter_chain_buf) |buf| {
                return try TraceConfig.TraceFilter.StringFilterChainReader.init(buf);
            }
            return try TraceConfig.TraceFilter.StringFilterChainReader.init(&[_]u8{});
        }
    };
    const AndroidReportConfigWire = struct {
        const REPORTER_SERVICE_PACKAGE_WIRE: gremlin.ProtoWireNumber = 1;
        const REPORTER_SERVICE_CLASS_WIRE: gremlin.ProtoWireNumber = 2;
        const SKIP_REPORT_WIRE: gremlin.ProtoWireNumber = 3;
        const USE_PIPE_IN_FRAMEWORK_FOR_TESTING_WIRE: gremlin.ProtoWireNumber = 4;
    };
    pub const AndroidReportConfig = struct {
        // fields
        reporter_service_package: ?[]const u8 = null,
        reporter_service_class: ?[]const u8 = null,
        skip_report: bool = false,
        use_pipe_in_framework_for_testing: bool = false,
        pub fn calcProtobufSize(self: *const TraceConfig.AndroidReportConfig) usize {
            var res: usize = 0;
            if (self.reporter_service_package) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(TraceConfig.AndroidReportConfigWire.REPORTER_SERVICE_PACKAGE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.reporter_service_class) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(TraceConfig.AndroidReportConfigWire.REPORTER_SERVICE_CLASS_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.skip_report != false) {
                res += gremlin.sizes.sizeWireNumber(TraceConfig.AndroidReportConfigWire.SKIP_REPORT_WIRE) + gremlin.sizes.sizeBool(self.skip_report);
            }
            if (self.use_pipe_in_framework_for_testing != false) {
                res += gremlin.sizes.sizeWireNumber(TraceConfig.AndroidReportConfigWire.USE_PIPE_IN_FRAMEWORK_FOR_TESTING_WIRE) + gremlin.sizes.sizeBool(self.use_pipe_in_framework_for_testing);
            }
            return res;
        }
        pub fn encode(self: *const TraceConfig.AndroidReportConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const TraceConfig.AndroidReportConfig, target: *gremlin.Writer) void {
            if (self.reporter_service_package) |v| {
                if (v.len > 0) {
                    target.appendBytes(TraceConfig.AndroidReportConfigWire.REPORTER_SERVICE_PACKAGE_WIRE, v);
                }
            }
            if (self.reporter_service_class) |v| {
                if (v.len > 0) {
                    target.appendBytes(TraceConfig.AndroidReportConfigWire.REPORTER_SERVICE_CLASS_WIRE, v);
                }
            }
            if (self.skip_report != false) {
                target.appendBool(TraceConfig.AndroidReportConfigWire.SKIP_REPORT_WIRE, self.skip_report);
            }
            if (self.use_pipe_in_framework_for_testing != false) {
                target.appendBool(TraceConfig.AndroidReportConfigWire.USE_PIPE_IN_FRAMEWORK_FOR_TESTING_WIRE, self.use_pipe_in_framework_for_testing);
            }
        }
    };
    pub const AndroidReportConfigReader = struct {
        buf: gremlin.Reader,
        _reporter_service_package: ?[]const u8 = null,
        _reporter_service_class: ?[]const u8 = null,
        _skip_report: bool = false,
        _use_pipe_in_framework_for_testing: bool = false,
        pub fn init(src: []const u8) gremlin.Error!TraceConfig.AndroidReportConfigReader {
            const buf = gremlin.Reader.init(src);
            var res = TraceConfig.AndroidReportConfigReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    TraceConfig.AndroidReportConfigWire.REPORTER_SERVICE_PACKAGE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._reporter_service_package = result.value;
                    },
                    TraceConfig.AndroidReportConfigWire.REPORTER_SERVICE_CLASS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._reporter_service_class = result.value;
                    },
                    TraceConfig.AndroidReportConfigWire.SKIP_REPORT_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._skip_report = result.value;
                    },
                    TraceConfig.AndroidReportConfigWire.USE_PIPE_IN_FRAMEWORK_FOR_TESTING_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._use_pipe_in_framework_for_testing = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getReporterServicePackage(self: *const TraceConfig.AndroidReportConfigReader) []const u8 {
            return self._reporter_service_package orelse &[_]u8{};
        }
        pub inline fn getReporterServiceClass(self: *const TraceConfig.AndroidReportConfigReader) []const u8 {
            return self._reporter_service_class orelse &[_]u8{};
        }
        pub inline fn getSkipReport(self: *const TraceConfig.AndroidReportConfigReader) bool {
            return self._skip_report;
        }
        pub inline fn getUsePipeInFrameworkForTesting(self: *const TraceConfig.AndroidReportConfigReader) bool {
            return self._use_pipe_in_framework_for_testing;
        }
    };
    const CmdTraceStartDelayWire = struct {
        const MIN_DELAY_MS_WIRE: gremlin.ProtoWireNumber = 1;
        const MAX_DELAY_MS_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const CmdTraceStartDelay = struct {
        // fields
        min_delay_ms: u32 = 0,
        max_delay_ms: u32 = 0,
        pub fn calcProtobufSize(self: *const TraceConfig.CmdTraceStartDelay) usize {
            var res: usize = 0;
            if (self.min_delay_ms != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceConfig.CmdTraceStartDelayWire.MIN_DELAY_MS_WIRE) + gremlin.sizes.sizeU32(self.min_delay_ms);
            }
            if (self.max_delay_ms != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceConfig.CmdTraceStartDelayWire.MAX_DELAY_MS_WIRE) + gremlin.sizes.sizeU32(self.max_delay_ms);
            }
            return res;
        }
        pub fn encode(self: *const TraceConfig.CmdTraceStartDelay, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const TraceConfig.CmdTraceStartDelay, target: *gremlin.Writer) void {
            if (self.min_delay_ms != 0) {
                target.appendUint32(TraceConfig.CmdTraceStartDelayWire.MIN_DELAY_MS_WIRE, self.min_delay_ms);
            }
            if (self.max_delay_ms != 0) {
                target.appendUint32(TraceConfig.CmdTraceStartDelayWire.MAX_DELAY_MS_WIRE, self.max_delay_ms);
            }
        }
    };
    pub const CmdTraceStartDelayReader = struct {
        buf: gremlin.Reader,
        _min_delay_ms: u32 = 0,
        _max_delay_ms: u32 = 0,
        pub fn init(src: []const u8) gremlin.Error!TraceConfig.CmdTraceStartDelayReader {
            const buf = gremlin.Reader.init(src);
            var res = TraceConfig.CmdTraceStartDelayReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    TraceConfig.CmdTraceStartDelayWire.MIN_DELAY_MS_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._min_delay_ms = result.value;
                    },
                    TraceConfig.CmdTraceStartDelayWire.MAX_DELAY_MS_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._max_delay_ms = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getMinDelayMs(self: *const TraceConfig.CmdTraceStartDelayReader) u32 {
            return self._min_delay_ms;
        }
        pub inline fn getMaxDelayMs(self: *const TraceConfig.CmdTraceStartDelayReader) u32 {
            return self._max_delay_ms;
        }
    };
    const SessionSemaphoreWire = struct {
        const NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const MAX_OTHER_SESSION_COUNT_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const SessionSemaphore = struct {
        // fields
        name: ?[]const u8 = null,
        max_other_session_count: u64 = 0,
        pub fn calcProtobufSize(self: *const TraceConfig.SessionSemaphore) usize {
            var res: usize = 0;
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(TraceConfig.SessionSemaphoreWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.max_other_session_count != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceConfig.SessionSemaphoreWire.MAX_OTHER_SESSION_COUNT_WIRE) + gremlin.sizes.sizeU64(self.max_other_session_count);
            }
            return res;
        }
        pub fn encode(self: *const TraceConfig.SessionSemaphore, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const TraceConfig.SessionSemaphore, target: *gremlin.Writer) void {
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(TraceConfig.SessionSemaphoreWire.NAME_WIRE, v);
                }
            }
            if (self.max_other_session_count != 0) {
                target.appendUint64(TraceConfig.SessionSemaphoreWire.MAX_OTHER_SESSION_COUNT_WIRE, self.max_other_session_count);
            }
        }
    };
    pub const SessionSemaphoreReader = struct {
        buf: gremlin.Reader,
        _name: ?[]const u8 = null,
        _max_other_session_count: u64 = 0,
        pub fn init(src: []const u8) gremlin.Error!TraceConfig.SessionSemaphoreReader {
            const buf = gremlin.Reader.init(src);
            var res = TraceConfig.SessionSemaphoreReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    TraceConfig.SessionSemaphoreWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    TraceConfig.SessionSemaphoreWire.MAX_OTHER_SESSION_COUNT_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._max_other_session_count = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getName(self: *const TraceConfig.SessionSemaphoreReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub inline fn getMaxOtherSessionCount(self: *const TraceConfig.SessionSemaphoreReader) u64 {
            return self._max_other_session_count;
        }
    };
    // fields
    buffers: ?[]const ?TraceConfig.BufferConfig = null,
    data_sources: ?[]const ?TraceConfig.DataSource = null,
    builtin_data_sources: ?TraceConfig.BuiltinDataSource = null,
    duration_ms: u32 = 0,
    prefer_suspend_clock_for_duration: bool = false,
    enable_extra_guardrails: bool = false,
    lockdown_mode: TraceConfig.LockdownModeOperation = @enumFromInt(0),
    producers: ?[]const ?TraceConfig.ProducerConfig = null,
    statsd_metadata: ?TraceConfig.StatsdMetadata = null,
    write_into_file: bool = false,
    output_path: ?[]const u8 = null,
    file_write_period_ms: u32 = 0,
    max_file_size_bytes: u64 = 0,
    guardrail_overrides: ?TraceConfig.GuardrailOverrides = null,
    deferred_start: bool = false,
    flush_period_ms: u32 = 0,
    flush_timeout_ms: u32 = 0,
    data_source_stop_timeout_ms: u32 = 0,
    notify_traceur: bool = false,
    bugreport_score: i32 = 0,
    bugreport_filename: ?[]const u8 = null,
    trigger_config: ?TraceConfig.TriggerConfig = null,
    activate_triggers: ?[]const ?[]const u8 = null,
    incremental_state_config: ?TraceConfig.IncrementalStateConfig = null,
    allow_user_build_tracing: bool = false,
    unique_session_name: ?[]const u8 = null,
    compression_type: TraceConfig.CompressionType = @enumFromInt(0),
    incident_report_config: ?TraceConfig.IncidentReportConfig = null,
    statsd_logging: TraceConfig.StatsdLogging = @enumFromInt(0),
    trace_uuid_msb: i64 = 0,
    trace_uuid_lsb: i64 = 0,
    trace_filter: ?TraceConfig.TraceFilter = null,
    android_report_config: ?TraceConfig.AndroidReportConfig = null,
    cmd_trace_start_delay: ?TraceConfig.CmdTraceStartDelay = null,
    session_semaphores: ?[]const ?TraceConfig.SessionSemaphore = null,
    priority_boost: ?PriorityBoostConfig = null,
    exclusive_prio: u32 = 0,
    no_flush_before_write_into_file: bool = false,
    pub fn calcProtobufSize(self: *const TraceConfig) usize {
        var res: usize = 0;
        if (self.buffers) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TraceConfigWire.BUFFERS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.data_sources) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TraceConfigWire.DATA_SOURCES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.builtin_data_sources) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceConfigWire.BUILTIN_DATA_SOURCES_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.duration_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceConfigWire.DURATION_MS_WIRE) + gremlin.sizes.sizeU32(self.duration_ms);
        }
        if (self.prefer_suspend_clock_for_duration != false) {
            res += gremlin.sizes.sizeWireNumber(TraceConfigWire.PREFER_SUSPEND_CLOCK_FOR_DURATION_WIRE) + gremlin.sizes.sizeBool(self.prefer_suspend_clock_for_duration);
        }
        if (self.enable_extra_guardrails != false) {
            res += gremlin.sizes.sizeWireNumber(TraceConfigWire.ENABLE_EXTRA_GUARDRAILS_WIRE) + gremlin.sizes.sizeBool(self.enable_extra_guardrails);
        }
        if (@intFromEnum(self.lockdown_mode) != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceConfigWire.LOCKDOWN_MODE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.lockdown_mode));
        }
        if (self.producers) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TraceConfigWire.PRODUCERS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.statsd_metadata) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceConfigWire.STATSD_METADATA_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.write_into_file != false) {
            res += gremlin.sizes.sizeWireNumber(TraceConfigWire.WRITE_INTO_FILE_WIRE) + gremlin.sizes.sizeBool(self.write_into_file);
        }
        if (self.output_path) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceConfigWire.OUTPUT_PATH_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.file_write_period_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceConfigWire.FILE_WRITE_PERIOD_MS_WIRE) + gremlin.sizes.sizeU32(self.file_write_period_ms);
        }
        if (self.max_file_size_bytes != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceConfigWire.MAX_FILE_SIZE_BYTES_WIRE) + gremlin.sizes.sizeU64(self.max_file_size_bytes);
        }
        if (self.guardrail_overrides) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceConfigWire.GUARDRAIL_OVERRIDES_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.deferred_start != false) {
            res += gremlin.sizes.sizeWireNumber(TraceConfigWire.DEFERRED_START_WIRE) + gremlin.sizes.sizeBool(self.deferred_start);
        }
        if (self.flush_period_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceConfigWire.FLUSH_PERIOD_MS_WIRE) + gremlin.sizes.sizeU32(self.flush_period_ms);
        }
        if (self.flush_timeout_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceConfigWire.FLUSH_TIMEOUT_MS_WIRE) + gremlin.sizes.sizeU32(self.flush_timeout_ms);
        }
        if (self.data_source_stop_timeout_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceConfigWire.DATA_SOURCE_STOP_TIMEOUT_MS_WIRE) + gremlin.sizes.sizeU32(self.data_source_stop_timeout_ms);
        }
        if (self.notify_traceur != false) {
            res += gremlin.sizes.sizeWireNumber(TraceConfigWire.NOTIFY_TRACEUR_WIRE) + gremlin.sizes.sizeBool(self.notify_traceur);
        }
        if (self.bugreport_score != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceConfigWire.BUGREPORT_SCORE_WIRE) + gremlin.sizes.sizeI32(self.bugreport_score);
        }
        if (self.bugreport_filename) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceConfigWire.BUGREPORT_FILENAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.trigger_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceConfigWire.TRIGGER_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.activate_triggers) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TraceConfigWire.ACTIVATE_TRIGGERS_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.incremental_state_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceConfigWire.INCREMENTAL_STATE_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.allow_user_build_tracing != false) {
            res += gremlin.sizes.sizeWireNumber(TraceConfigWire.ALLOW_USER_BUILD_TRACING_WIRE) + gremlin.sizes.sizeBool(self.allow_user_build_tracing);
        }
        if (self.unique_session_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceConfigWire.UNIQUE_SESSION_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (@intFromEnum(self.compression_type) != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceConfigWire.COMPRESSION_TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.compression_type));
        }
        if (self.incident_report_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceConfigWire.INCIDENT_REPORT_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (@intFromEnum(self.statsd_logging) != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceConfigWire.STATSD_LOGGING_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.statsd_logging));
        }
        if (self.trace_uuid_msb != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceConfigWire.TRACE_UUID_MSB_WIRE) + gremlin.sizes.sizeI64(self.trace_uuid_msb);
        }
        if (self.trace_uuid_lsb != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceConfigWire.TRACE_UUID_LSB_WIRE) + gremlin.sizes.sizeI64(self.trace_uuid_lsb);
        }
        if (self.trace_filter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceConfigWire.TRACE_FILTER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.android_report_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceConfigWire.ANDROID_REPORT_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.cmd_trace_start_delay) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceConfigWire.CMD_TRACE_START_DELAY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.session_semaphores) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TraceConfigWire.SESSION_SEMAPHORES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.priority_boost) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceConfigWire.PRIORITY_BOOST_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.exclusive_prio != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceConfigWire.EXCLUSIVE_PRIO_WIRE) + gremlin.sizes.sizeU32(self.exclusive_prio);
        }
        if (self.no_flush_before_write_into_file != false) {
            res += gremlin.sizes.sizeWireNumber(TraceConfigWire.NO_FLUSH_BEFORE_WRITE_INTO_FILE_WIRE) + gremlin.sizes.sizeBool(self.no_flush_before_write_into_file);
        }
        return res;
    }
    pub fn encode(self: *const TraceConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TraceConfig, target: *gremlin.Writer) void {
        if (self.buffers) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(TraceConfigWire.BUFFERS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(TraceConfigWire.BUFFERS_WIRE, 0);
                }
            }
        }
        if (self.data_sources) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(TraceConfigWire.DATA_SOURCES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(TraceConfigWire.DATA_SOURCES_WIRE, 0);
                }
            }
        }
        if (self.builtin_data_sources) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceConfigWire.BUILTIN_DATA_SOURCES_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.duration_ms != 0) {
            target.appendUint32(TraceConfigWire.DURATION_MS_WIRE, self.duration_ms);
        }
        if (self.prefer_suspend_clock_for_duration != false) {
            target.appendBool(TraceConfigWire.PREFER_SUSPEND_CLOCK_FOR_DURATION_WIRE, self.prefer_suspend_clock_for_duration);
        }
        if (self.enable_extra_guardrails != false) {
            target.appendBool(TraceConfigWire.ENABLE_EXTRA_GUARDRAILS_WIRE, self.enable_extra_guardrails);
        }
        if (@intFromEnum(self.lockdown_mode) != 0) {
            target.appendInt32(TraceConfigWire.LOCKDOWN_MODE_WIRE, @intFromEnum(self.lockdown_mode));
        }
        if (self.producers) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(TraceConfigWire.PRODUCERS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(TraceConfigWire.PRODUCERS_WIRE, 0);
                }
            }
        }
        if (self.statsd_metadata) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceConfigWire.STATSD_METADATA_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.write_into_file != false) {
            target.appendBool(TraceConfigWire.WRITE_INTO_FILE_WIRE, self.write_into_file);
        }
        if (self.output_path) |v| {
            if (v.len > 0) {
                target.appendBytes(TraceConfigWire.OUTPUT_PATH_WIRE, v);
            }
        }
        if (self.file_write_period_ms != 0) {
            target.appendUint32(TraceConfigWire.FILE_WRITE_PERIOD_MS_WIRE, self.file_write_period_ms);
        }
        if (self.max_file_size_bytes != 0) {
            target.appendUint64(TraceConfigWire.MAX_FILE_SIZE_BYTES_WIRE, self.max_file_size_bytes);
        }
        if (self.guardrail_overrides) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceConfigWire.GUARDRAIL_OVERRIDES_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.deferred_start != false) {
            target.appendBool(TraceConfigWire.DEFERRED_START_WIRE, self.deferred_start);
        }
        if (self.flush_period_ms != 0) {
            target.appendUint32(TraceConfigWire.FLUSH_PERIOD_MS_WIRE, self.flush_period_ms);
        }
        if (self.flush_timeout_ms != 0) {
            target.appendUint32(TraceConfigWire.FLUSH_TIMEOUT_MS_WIRE, self.flush_timeout_ms);
        }
        if (self.data_source_stop_timeout_ms != 0) {
            target.appendUint32(TraceConfigWire.DATA_SOURCE_STOP_TIMEOUT_MS_WIRE, self.data_source_stop_timeout_ms);
        }
        if (self.notify_traceur != false) {
            target.appendBool(TraceConfigWire.NOTIFY_TRACEUR_WIRE, self.notify_traceur);
        }
        if (self.bugreport_score != 0) {
            target.appendInt32(TraceConfigWire.BUGREPORT_SCORE_WIRE, self.bugreport_score);
        }
        if (self.bugreport_filename) |v| {
            if (v.len > 0) {
                target.appendBytes(TraceConfigWire.BUGREPORT_FILENAME_WIRE, v);
            }
        }
        if (self.trigger_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceConfigWire.TRIGGER_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.activate_triggers) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(TraceConfigWire.ACTIVATE_TRIGGERS_WIRE, v);
                } else {
                    target.appendBytesTag(TraceConfigWire.ACTIVATE_TRIGGERS_WIRE, 0);
                }
            }
        }
        if (self.incremental_state_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceConfigWire.INCREMENTAL_STATE_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.allow_user_build_tracing != false) {
            target.appendBool(TraceConfigWire.ALLOW_USER_BUILD_TRACING_WIRE, self.allow_user_build_tracing);
        }
        if (self.unique_session_name) |v| {
            if (v.len > 0) {
                target.appendBytes(TraceConfigWire.UNIQUE_SESSION_NAME_WIRE, v);
            }
        }
        if (@intFromEnum(self.compression_type) != 0) {
            target.appendInt32(TraceConfigWire.COMPRESSION_TYPE_WIRE, @intFromEnum(self.compression_type));
        }
        if (self.incident_report_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceConfigWire.INCIDENT_REPORT_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (@intFromEnum(self.statsd_logging) != 0) {
            target.appendInt32(TraceConfigWire.STATSD_LOGGING_WIRE, @intFromEnum(self.statsd_logging));
        }
        if (self.trace_uuid_msb != 0) {
            target.appendInt64(TraceConfigWire.TRACE_UUID_MSB_WIRE, self.trace_uuid_msb);
        }
        if (self.trace_uuid_lsb != 0) {
            target.appendInt64(TraceConfigWire.TRACE_UUID_LSB_WIRE, self.trace_uuid_lsb);
        }
        if (self.trace_filter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceConfigWire.TRACE_FILTER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.android_report_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceConfigWire.ANDROID_REPORT_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.cmd_trace_start_delay) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceConfigWire.CMD_TRACE_START_DELAY_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.session_semaphores) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(TraceConfigWire.SESSION_SEMAPHORES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(TraceConfigWire.SESSION_SEMAPHORES_WIRE, 0);
                }
            }
        }
        if (self.priority_boost) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceConfigWire.PRIORITY_BOOST_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.exclusive_prio != 0) {
            target.appendUint32(TraceConfigWire.EXCLUSIVE_PRIO_WIRE, self.exclusive_prio);
        }
        if (self.no_flush_before_write_into_file != false) {
            target.appendBool(TraceConfigWire.NO_FLUSH_BEFORE_WRITE_INTO_FILE_WIRE, self.no_flush_before_write_into_file);
        }
    }
};
pub const TraceConfigReader = struct {
    buf: gremlin.Reader,
    _buffers_offset: ?usize = null,
    _buffers_last_offset: ?usize = null,
    _buffers_cnt: usize = 0,
    _data_sources_offset: ?usize = null,
    _data_sources_last_offset: ?usize = null,
    _data_sources_cnt: usize = 0,
    _builtin_data_sources_buf: ?[]const u8 = null,
    _duration_ms: u32 = 0,
    _prefer_suspend_clock_for_duration: bool = false,
    _enable_extra_guardrails: bool = false,
    _lockdown_mode: TraceConfig.LockdownModeOperation = @enumFromInt(0),
    _producers_offset: ?usize = null,
    _producers_last_offset: ?usize = null,
    _producers_cnt: usize = 0,
    _statsd_metadata_buf: ?[]const u8 = null,
    _write_into_file: bool = false,
    _output_path: ?[]const u8 = null,
    _file_write_period_ms: u32 = 0,
    _max_file_size_bytes: u64 = 0,
    _guardrail_overrides_buf: ?[]const u8 = null,
    _deferred_start: bool = false,
    _flush_period_ms: u32 = 0,
    _flush_timeout_ms: u32 = 0,
    _data_source_stop_timeout_ms: u32 = 0,
    _notify_traceur: bool = false,
    _bugreport_score: i32 = 0,
    _bugreport_filename: ?[]const u8 = null,
    _trigger_config_buf: ?[]const u8 = null,
    _activate_triggers_offset: ?usize = null,
    _activate_triggers_last_offset: ?usize = null,
    _activate_triggers_cnt: usize = 0,
    _incremental_state_config_buf: ?[]const u8 = null,
    _allow_user_build_tracing: bool = false,
    _unique_session_name: ?[]const u8 = null,
    _compression_type: TraceConfig.CompressionType = @enumFromInt(0),
    _incident_report_config_buf: ?[]const u8 = null,
    _statsd_logging: TraceConfig.StatsdLogging = @enumFromInt(0),
    _trace_uuid_msb: i64 = 0,
    _trace_uuid_lsb: i64 = 0,
    _trace_filter_buf: ?[]const u8 = null,
    _android_report_config_buf: ?[]const u8 = null,
    _cmd_trace_start_delay_buf: ?[]const u8 = null,
    _session_semaphores_offset: ?usize = null,
    _session_semaphores_last_offset: ?usize = null,
    _session_semaphores_cnt: usize = 0,
    _priority_boost_buf: ?[]const u8 = null,
    _exclusive_prio: u32 = 0,
    _no_flush_before_write_into_file: bool = false,
    pub fn init(src: []const u8) gremlin.Error!TraceConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = TraceConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TraceConfigWire.BUFFERS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._buffers_offset == null) {
                        res._buffers_offset = offset - result.size;
                    }
                    res._buffers_last_offset = offset;
                    res._buffers_cnt += 1;
                },
                TraceConfigWire.DATA_SOURCES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._data_sources_offset == null) {
                        res._data_sources_offset = offset - result.size;
                    }
                    res._data_sources_last_offset = offset;
                    res._data_sources_cnt += 1;
                },
                TraceConfigWire.BUILTIN_DATA_SOURCES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._builtin_data_sources_buf = result.value;
                },
                TraceConfigWire.DURATION_MS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._duration_ms = result.value;
                },
                TraceConfigWire.PREFER_SUSPEND_CLOCK_FOR_DURATION_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._prefer_suspend_clock_for_duration = result.value;
                },
                TraceConfigWire.ENABLE_EXTRA_GUARDRAILS_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._enable_extra_guardrails = result.value;
                },
                TraceConfigWire.LOCKDOWN_MODE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._lockdown_mode = @enumFromInt(result.value);
                },
                TraceConfigWire.PRODUCERS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._producers_offset == null) {
                        res._producers_offset = offset - result.size;
                    }
                    res._producers_last_offset = offset;
                    res._producers_cnt += 1;
                },
                TraceConfigWire.STATSD_METADATA_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._statsd_metadata_buf = result.value;
                },
                TraceConfigWire.WRITE_INTO_FILE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._write_into_file = result.value;
                },
                TraceConfigWire.OUTPUT_PATH_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._output_path = result.value;
                },
                TraceConfigWire.FILE_WRITE_PERIOD_MS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._file_write_period_ms = result.value;
                },
                TraceConfigWire.MAX_FILE_SIZE_BYTES_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._max_file_size_bytes = result.value;
                },
                TraceConfigWire.GUARDRAIL_OVERRIDES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._guardrail_overrides_buf = result.value;
                },
                TraceConfigWire.DEFERRED_START_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._deferred_start = result.value;
                },
                TraceConfigWire.FLUSH_PERIOD_MS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._flush_period_ms = result.value;
                },
                TraceConfigWire.FLUSH_TIMEOUT_MS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._flush_timeout_ms = result.value;
                },
                TraceConfigWire.DATA_SOURCE_STOP_TIMEOUT_MS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._data_source_stop_timeout_ms = result.value;
                },
                TraceConfigWire.NOTIFY_TRACEUR_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._notify_traceur = result.value;
                },
                TraceConfigWire.BUGREPORT_SCORE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._bugreport_score = result.value;
                },
                TraceConfigWire.BUGREPORT_FILENAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._bugreport_filename = result.value;
                },
                TraceConfigWire.TRIGGER_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._trigger_config_buf = result.value;
                },
                TraceConfigWire.ACTIVATE_TRIGGERS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._activate_triggers_offset == null) {
                        res._activate_triggers_offset = offset - result.size;
                    }
                    res._activate_triggers_last_offset = offset;
                    res._activate_triggers_cnt += 1;
                },
                TraceConfigWire.INCREMENTAL_STATE_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._incremental_state_config_buf = result.value;
                },
                TraceConfigWire.ALLOW_USER_BUILD_TRACING_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._allow_user_build_tracing = result.value;
                },
                TraceConfigWire.UNIQUE_SESSION_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._unique_session_name = result.value;
                },
                TraceConfigWire.COMPRESSION_TYPE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._compression_type = @enumFromInt(result.value);
                },
                TraceConfigWire.INCIDENT_REPORT_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._incident_report_config_buf = result.value;
                },
                TraceConfigWire.STATSD_LOGGING_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._statsd_logging = @enumFromInt(result.value);
                },
                TraceConfigWire.TRACE_UUID_MSB_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._trace_uuid_msb = result.value;
                },
                TraceConfigWire.TRACE_UUID_LSB_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._trace_uuid_lsb = result.value;
                },
                TraceConfigWire.TRACE_FILTER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._trace_filter_buf = result.value;
                },
                TraceConfigWire.ANDROID_REPORT_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._android_report_config_buf = result.value;
                },
                TraceConfigWire.CMD_TRACE_START_DELAY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._cmd_trace_start_delay_buf = result.value;
                },
                TraceConfigWire.SESSION_SEMAPHORES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._session_semaphores_offset == null) {
                        res._session_semaphores_offset = offset - result.size;
                    }
                    res._session_semaphores_last_offset = offset;
                    res._session_semaphores_cnt += 1;
                },
                TraceConfigWire.PRIORITY_BOOST_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._priority_boost_buf = result.value;
                },
                TraceConfigWire.EXCLUSIVE_PRIO_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._exclusive_prio = result.value;
                },
                TraceConfigWire.NO_FLUSH_BEFORE_WRITE_INTO_FILE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._no_flush_before_write_into_file = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn buffersCount(self: *const TraceConfigReader) usize {
        return self._buffers_cnt;
    }
    pub fn buffersNext(self: *TraceConfigReader) ?TraceConfig.BufferConfigReader {
        if (self._buffers_offset == null) return null;
        const current_offset = self._buffers_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = TraceConfig.BufferConfigReader.init(result.value) catch return null;
        if (self._buffers_last_offset != null and current_offset >= self._buffers_last_offset.?) {
            self._buffers_offset = null;
            return msg;
        }
        if (self._buffers_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._buffers_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TraceConfigWire.BUFFERS_WIRE) {
                self._buffers_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._buffers_offset = null;
        return msg;
    }
    pub fn dataSourcesCount(self: *const TraceConfigReader) usize {
        return self._data_sources_cnt;
    }
    pub fn dataSourcesNext(self: *TraceConfigReader) ?TraceConfig.DataSourceReader {
        if (self._data_sources_offset == null) return null;
        const current_offset = self._data_sources_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = TraceConfig.DataSourceReader.init(result.value) catch return null;
        if (self._data_sources_last_offset != null and current_offset >= self._data_sources_last_offset.?) {
            self._data_sources_offset = null;
            return msg;
        }
        if (self._data_sources_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._data_sources_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TraceConfigWire.DATA_SOURCES_WIRE) {
                self._data_sources_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._data_sources_offset = null;
        return msg;
    }
    pub fn getBuiltinDataSources(self: *const TraceConfigReader) gremlin.Error!TraceConfig.BuiltinDataSourceReader {
        if (self._builtin_data_sources_buf) |buf| {
            return try TraceConfig.BuiltinDataSourceReader.init(buf);
        }
        return try TraceConfig.BuiltinDataSourceReader.init(&[_]u8{});
    }
    pub inline fn getDurationMs(self: *const TraceConfigReader) u32 {
        return self._duration_ms;
    }
    pub inline fn getPreferSuspendClockForDuration(self: *const TraceConfigReader) bool {
        return self._prefer_suspend_clock_for_duration;
    }
    pub inline fn getEnableExtraGuardrails(self: *const TraceConfigReader) bool {
        return self._enable_extra_guardrails;
    }
    pub inline fn getLockdownMode(self: *const TraceConfigReader) TraceConfig.LockdownModeOperation {
        return self._lockdown_mode;
    }
    pub fn producersCount(self: *const TraceConfigReader) usize {
        return self._producers_cnt;
    }
    pub fn producersNext(self: *TraceConfigReader) ?TraceConfig.ProducerConfigReader {
        if (self._producers_offset == null) return null;
        const current_offset = self._producers_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = TraceConfig.ProducerConfigReader.init(result.value) catch return null;
        if (self._producers_last_offset != null and current_offset >= self._producers_last_offset.?) {
            self._producers_offset = null;
            return msg;
        }
        if (self._producers_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._producers_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TraceConfigWire.PRODUCERS_WIRE) {
                self._producers_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._producers_offset = null;
        return msg;
    }
    pub fn getStatsdMetadata(self: *const TraceConfigReader) gremlin.Error!TraceConfig.StatsdMetadataReader {
        if (self._statsd_metadata_buf) |buf| {
            return try TraceConfig.StatsdMetadataReader.init(buf);
        }
        return try TraceConfig.StatsdMetadataReader.init(&[_]u8{});
    }
    pub inline fn getWriteIntoFile(self: *const TraceConfigReader) bool {
        return self._write_into_file;
    }
    pub inline fn getOutputPath(self: *const TraceConfigReader) []const u8 {
        return self._output_path orelse &[_]u8{};
    }
    pub inline fn getFileWritePeriodMs(self: *const TraceConfigReader) u32 {
        return self._file_write_period_ms;
    }
    pub inline fn getMaxFileSizeBytes(self: *const TraceConfigReader) u64 {
        return self._max_file_size_bytes;
    }
    pub fn getGuardrailOverrides(self: *const TraceConfigReader) gremlin.Error!TraceConfig.GuardrailOverridesReader {
        if (self._guardrail_overrides_buf) |buf| {
            return try TraceConfig.GuardrailOverridesReader.init(buf);
        }
        return try TraceConfig.GuardrailOverridesReader.init(&[_]u8{});
    }
    pub inline fn getDeferredStart(self: *const TraceConfigReader) bool {
        return self._deferred_start;
    }
    pub inline fn getFlushPeriodMs(self: *const TraceConfigReader) u32 {
        return self._flush_period_ms;
    }
    pub inline fn getFlushTimeoutMs(self: *const TraceConfigReader) u32 {
        return self._flush_timeout_ms;
    }
    pub inline fn getDataSourceStopTimeoutMs(self: *const TraceConfigReader) u32 {
        return self._data_source_stop_timeout_ms;
    }
    pub inline fn getNotifyTraceur(self: *const TraceConfigReader) bool {
        return self._notify_traceur;
    }
    pub inline fn getBugreportScore(self: *const TraceConfigReader) i32 {
        return self._bugreport_score;
    }
    pub inline fn getBugreportFilename(self: *const TraceConfigReader) []const u8 {
        return self._bugreport_filename orelse &[_]u8{};
    }
    pub fn getTriggerConfig(self: *const TraceConfigReader) gremlin.Error!TraceConfig.TriggerConfigReader {
        if (self._trigger_config_buf) |buf| {
            return try TraceConfig.TriggerConfigReader.init(buf);
        }
        return try TraceConfig.TriggerConfigReader.init(&[_]u8{});
    }
    pub fn activateTriggersCount(self: *const TraceConfigReader) usize {
        return self._activate_triggers_cnt;
    }
    pub fn activateTriggersNext(self: *TraceConfigReader) ?[]const u8 {
        if (self._activate_triggers_offset == null) return null;
        const current_offset = self._activate_triggers_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._activate_triggers_last_offset != null and current_offset >= self._activate_triggers_last_offset.?) {
            self._activate_triggers_offset = null;
            return result.value;
        }
        if (self._activate_triggers_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._activate_triggers_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TraceConfigWire.ACTIVATE_TRIGGERS_WIRE) {
                self._activate_triggers_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._activate_triggers_offset = null;
        return result.value;
    }
    pub fn getIncrementalStateConfig(self: *const TraceConfigReader) gremlin.Error!TraceConfig.IncrementalStateConfigReader {
        if (self._incremental_state_config_buf) |buf| {
            return try TraceConfig.IncrementalStateConfigReader.init(buf);
        }
        return try TraceConfig.IncrementalStateConfigReader.init(&[_]u8{});
    }
    pub inline fn getAllowUserBuildTracing(self: *const TraceConfigReader) bool {
        return self._allow_user_build_tracing;
    }
    pub inline fn getUniqueSessionName(self: *const TraceConfigReader) []const u8 {
        return self._unique_session_name orelse &[_]u8{};
    }
    pub inline fn getCompressionType(self: *const TraceConfigReader) TraceConfig.CompressionType {
        return self._compression_type;
    }
    pub fn getIncidentReportConfig(self: *const TraceConfigReader) gremlin.Error!TraceConfig.IncidentReportConfigReader {
        if (self._incident_report_config_buf) |buf| {
            return try TraceConfig.IncidentReportConfigReader.init(buf);
        }
        return try TraceConfig.IncidentReportConfigReader.init(&[_]u8{});
    }
    pub inline fn getStatsdLogging(self: *const TraceConfigReader) TraceConfig.StatsdLogging {
        return self._statsd_logging;
    }
    pub inline fn getTraceUuidMsb(self: *const TraceConfigReader) i64 {
        return self._trace_uuid_msb;
    }
    pub inline fn getTraceUuidLsb(self: *const TraceConfigReader) i64 {
        return self._trace_uuid_lsb;
    }
    pub fn getTraceFilter(self: *const TraceConfigReader) gremlin.Error!TraceConfig.TraceFilterReader {
        if (self._trace_filter_buf) |buf| {
            return try TraceConfig.TraceFilterReader.init(buf);
        }
        return try TraceConfig.TraceFilterReader.init(&[_]u8{});
    }
    pub fn getAndroidReportConfig(self: *const TraceConfigReader) gremlin.Error!TraceConfig.AndroidReportConfigReader {
        if (self._android_report_config_buf) |buf| {
            return try TraceConfig.AndroidReportConfigReader.init(buf);
        }
        return try TraceConfig.AndroidReportConfigReader.init(&[_]u8{});
    }
    pub fn getCmdTraceStartDelay(self: *const TraceConfigReader) gremlin.Error!TraceConfig.CmdTraceStartDelayReader {
        if (self._cmd_trace_start_delay_buf) |buf| {
            return try TraceConfig.CmdTraceStartDelayReader.init(buf);
        }
        return try TraceConfig.CmdTraceStartDelayReader.init(&[_]u8{});
    }
    pub fn sessionSemaphoresCount(self: *const TraceConfigReader) usize {
        return self._session_semaphores_cnt;
    }
    pub fn sessionSemaphoresNext(self: *TraceConfigReader) ?TraceConfig.SessionSemaphoreReader {
        if (self._session_semaphores_offset == null) return null;
        const current_offset = self._session_semaphores_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = TraceConfig.SessionSemaphoreReader.init(result.value) catch return null;
        if (self._session_semaphores_last_offset != null and current_offset >= self._session_semaphores_last_offset.?) {
            self._session_semaphores_offset = null;
            return msg;
        }
        if (self._session_semaphores_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._session_semaphores_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TraceConfigWire.SESSION_SEMAPHORES_WIRE) {
                self._session_semaphores_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._session_semaphores_offset = null;
        return msg;
    }
    pub fn getPriorityBoost(self: *const TraceConfigReader) gremlin.Error!PriorityBoostConfigReader {
        if (self._priority_boost_buf) |buf| {
            return try PriorityBoostConfigReader.init(buf);
        }
        return try PriorityBoostConfigReader.init(&[_]u8{});
    }
    pub inline fn getExclusivePrio(self: *const TraceConfigReader) u32 {
        return self._exclusive_prio;
    }
    pub inline fn getNoFlushBeforeWriteIntoFile(self: *const TraceConfigReader) bool {
        return self._no_flush_before_write_into_file;
    }
};
