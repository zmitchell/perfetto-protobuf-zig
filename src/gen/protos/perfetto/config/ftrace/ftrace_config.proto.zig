// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const FtraceConfigWire = struct {
    const FTRACE_EVENTS_WIRE: gremlin.ProtoWireNumber = 1;
    const ATRACE_CATEGORIES_WIRE: gremlin.ProtoWireNumber = 2;
    const ATRACE_APPS_WIRE: gremlin.ProtoWireNumber = 3;
    const ATRACE_CATEGORIES_PREFER_SDK_WIRE: gremlin.ProtoWireNumber = 28;
    const ATRACE_USERSPACE_ONLY_WIRE: gremlin.ProtoWireNumber = 34;
    const BUFFER_SIZE_KB_WIRE: gremlin.ProtoWireNumber = 10;
    const BUFFER_SIZE_LOWER_BOUND_WIRE: gremlin.ProtoWireNumber = 27;
    const DRAIN_PERIOD_MS_WIRE: gremlin.ProtoWireNumber = 11;
    const DRAIN_BUFFER_PERCENT_WIRE: gremlin.ProtoWireNumber = 29;
    const COMPACT_SCHED_WIRE: gremlin.ProtoWireNumber = 12;
    const PRINT_FILTER_WIRE: gremlin.ProtoWireNumber = 22;
    const SYMBOLIZE_KSYMS_WIRE: gremlin.ProtoWireNumber = 13;
    const KSYMS_MEM_POLICY_WIRE: gremlin.ProtoWireNumber = 17;
    const THROTTLE_RSS_STAT_WIRE: gremlin.ProtoWireNumber = 15;
    const DENSER_GENERIC_EVENT_ENCODING_WIRE: gremlin.ProtoWireNumber = 32;
    const DISABLE_GENERIC_EVENTS_WIRE: gremlin.ProtoWireNumber = 16;
    const SYSCALL_EVENTS_WIRE: gremlin.ProtoWireNumber = 18;
    const ENABLE_FUNCTION_GRAPH_WIRE: gremlin.ProtoWireNumber = 19;
    const FUNCTION_FILTERS_WIRE: gremlin.ProtoWireNumber = 20;
    const FUNCTION_GRAPH_ROOTS_WIRE: gremlin.ProtoWireNumber = 21;
    const FUNCTION_GRAPH_MAX_DEPTH_WIRE: gremlin.ProtoWireNumber = 33;
    const KPROBE_EVENTS_WIRE: gremlin.ProtoWireNumber = 30;
    const PRESERVE_FTRACE_BUFFER_WIRE: gremlin.ProtoWireNumber = 23;
    const USE_MONOTONIC_RAW_CLOCK_WIRE: gremlin.ProtoWireNumber = 24;
    const INSTANCE_NAME_WIRE: gremlin.ProtoWireNumber = 25;
    const DEBUG_FTRACE_ABI_WIRE: gremlin.ProtoWireNumber = 31;
    const TIDS_TO_TRACE_WIRE: gremlin.ProtoWireNumber = 35;
    const TRACEFS_OPTIONS_WIRE: gremlin.ProtoWireNumber = 36;
    const TRACING_CPUMASK_WIRE: gremlin.ProtoWireNumber = 37;
    const INITIALIZE_KSYMS_SYNCHRONOUSLY_FOR_TESTING_WIRE: gremlin.ProtoWireNumber = 14;
};
pub const FtraceConfig = struct {
    // nested enums
    pub const KsymsMemPolicy = enum(i32) {
        KSYMS_UNSPECIFIED = 0,
        KSYMS_CLEANUP_ON_STOP = 1,
        KSYMS_RETAIN = 2,
    };
    // nested structs
    const CompactSchedConfigWire = struct {
        const ENABLED_WIRE: gremlin.ProtoWireNumber = 1;
    };
    pub const CompactSchedConfig = struct {
        // fields
        enabled: bool = false,
        pub fn calcProtobufSize(self: *const FtraceConfig.CompactSchedConfig) usize {
            var res: usize = 0;
            if (self.enabled != false) {
                res += gremlin.sizes.sizeWireNumber(FtraceConfig.CompactSchedConfigWire.ENABLED_WIRE) + gremlin.sizes.sizeBool(self.enabled);
            }
            return res;
        }
        pub fn encode(self: *const FtraceConfig.CompactSchedConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const FtraceConfig.CompactSchedConfig, target: *gremlin.Writer) void {
            if (self.enabled != false) {
                target.appendBool(FtraceConfig.CompactSchedConfigWire.ENABLED_WIRE, self.enabled);
            }
        }
    };
    pub const CompactSchedConfigReader = struct {
        buf: gremlin.Reader,
        _enabled: bool = false,
        pub fn init(src: []const u8) gremlin.Error!FtraceConfig.CompactSchedConfigReader {
            const buf = gremlin.Reader.init(src);
            var res = FtraceConfig.CompactSchedConfigReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    FtraceConfig.CompactSchedConfigWire.ENABLED_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._enabled = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getEnabled(self: *const FtraceConfig.CompactSchedConfigReader) bool {
            return self._enabled;
        }
    };
    const PrintFilterWire = struct {
        const RULES_WIRE: gremlin.ProtoWireNumber = 1;
    };
    pub const PrintFilter = struct {
        // nested structs
        const RuleWire = struct {
            const ALLOW_WIRE: gremlin.ProtoWireNumber = 2;
            const PREFIX_WIRE: gremlin.ProtoWireNumber = 1;
            const ATRACE_MSG_WIRE: gremlin.ProtoWireNumber = 3;
        };
        pub const Rule = struct {
            // nested structs
            const AtraceMessageWire = struct {
                const TYPE_WIRE: gremlin.ProtoWireNumber = 1;
                const PREFIX_WIRE: gremlin.ProtoWireNumber = 2;
            };
            pub const AtraceMessage = struct {
                // fields
                type: ?[]const u8 = null,
                prefix: ?[]const u8 = null,
                pub fn calcProtobufSize(self: *const FtraceConfig.PrintFilter.Rule.AtraceMessage) usize {
                    var res: usize = 0;
                    if (self.type) |v| {
                        if (v.len > 0) {
                            res += gremlin.sizes.sizeWireNumber(FtraceConfig.PrintFilter.Rule.AtraceMessageWire.TYPE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                        }
                    }
                    if (self.prefix) |v| {
                        if (v.len > 0) {
                            res += gremlin.sizes.sizeWireNumber(FtraceConfig.PrintFilter.Rule.AtraceMessageWire.PREFIX_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                        }
                    }
                    return res;
                }
                pub fn encode(self: *const FtraceConfig.PrintFilter.Rule.AtraceMessage, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                    const size = self.calcProtobufSize();
                    if (size == 0) {
                        return &[_]u8{};
                    }
                    const buf = try allocator.alloc(u8, self.calcProtobufSize());
                    var writer = gremlin.Writer.init(buf);
                    self.encodeTo(&writer);
                    return buf;
                }
                pub fn encodeTo(self: *const FtraceConfig.PrintFilter.Rule.AtraceMessage, target: *gremlin.Writer) void {
                    if (self.type) |v| {
                        if (v.len > 0) {
                            target.appendBytes(FtraceConfig.PrintFilter.Rule.AtraceMessageWire.TYPE_WIRE, v);
                        }
                    }
                    if (self.prefix) |v| {
                        if (v.len > 0) {
                            target.appendBytes(FtraceConfig.PrintFilter.Rule.AtraceMessageWire.PREFIX_WIRE, v);
                        }
                    }
                }
            };
            pub const AtraceMessageReader = struct {
                buf: gremlin.Reader,
                _type: ?[]const u8 = null,
                _prefix: ?[]const u8 = null,
                pub fn init(src: []const u8) gremlin.Error!FtraceConfig.PrintFilter.Rule.AtraceMessageReader {
                    const buf = gremlin.Reader.init(src);
                    var res = FtraceConfig.PrintFilter.Rule.AtraceMessageReader{ .buf = buf };
                    if (buf.buf.len == 0) {
                        return res;
                    }
                    var offset: usize = 0;
                    while (buf.hasNext(offset, 0)) {
                        const tag = try buf.readTagAt(offset);
                        offset += tag.size;
                        switch (tag.number) {
                            FtraceConfig.PrintFilter.Rule.AtraceMessageWire.TYPE_WIRE => {
                                const result = try buf.readBytes(offset);
                                offset += result.size;
                                res._type = result.value;
                            },
                            FtraceConfig.PrintFilter.Rule.AtraceMessageWire.PREFIX_WIRE => {
                                const result = try buf.readBytes(offset);
                                offset += result.size;
                                res._prefix = result.value;
                            },
                            else => {
                                offset = try buf.skipData(offset, tag.wire);
                            },
                        }
                    }
                    return res;
                }
                pub fn sourceBytes(self: *const @This()) []const u8 {
                    return self.buf.buf;
                }
                pub inline fn getType(self: *const FtraceConfig.PrintFilter.Rule.AtraceMessageReader) []const u8 {
                    return self._type orelse &[_]u8{};
                }
                pub inline fn getPrefix(self: *const FtraceConfig.PrintFilter.Rule.AtraceMessageReader) []const u8 {
                    return self._prefix orelse &[_]u8{};
                }
            };
            // fields
            allow: bool = false,
            prefix: ?[]const u8 = null,
            atrace_msg: ?FtraceConfig.PrintFilter.Rule.AtraceMessage = null,
            pub fn calcProtobufSize(self: *const FtraceConfig.PrintFilter.Rule) usize {
                var res: usize = 0;
                if (self.allow != false) {
                    res += gremlin.sizes.sizeWireNumber(FtraceConfig.PrintFilter.RuleWire.ALLOW_WIRE) + gremlin.sizes.sizeBool(self.allow);
                }
                if (self.prefix) |v| {
                    if (v.len > 0) {
                        res += gremlin.sizes.sizeWireNumber(FtraceConfig.PrintFilter.RuleWire.PREFIX_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                    }
                }
                if (self.atrace_msg) |v| {
                    const size = v.calcProtobufSize();
                    if (size > 0) {
                        res += gremlin.sizes.sizeWireNumber(FtraceConfig.PrintFilter.RuleWire.ATRACE_MSG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                    }
                }
                return res;
            }
            pub fn encode(self: *const FtraceConfig.PrintFilter.Rule, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const FtraceConfig.PrintFilter.Rule, target: *gremlin.Writer) void {
                if (self.allow != false) {
                    target.appendBool(FtraceConfig.PrintFilter.RuleWire.ALLOW_WIRE, self.allow);
                }
                if (self.prefix) |v| {
                    if (v.len > 0) {
                        target.appendBytes(FtraceConfig.PrintFilter.RuleWire.PREFIX_WIRE, v);
                    }
                }
                if (self.atrace_msg) |v| {
                    const size = v.calcProtobufSize();
                    if (size > 0) {
                        target.appendBytesTag(FtraceConfig.PrintFilter.RuleWire.ATRACE_MSG_WIRE, size);
                        v.encodeTo(target);
                    }
                }
            }
        };
        pub const RuleReader = struct {
            buf: gremlin.Reader,
            _allow: bool = false,
            _prefix: ?[]const u8 = null,
            _atrace_msg_buf: ?[]const u8 = null,
            pub fn init(src: []const u8) gremlin.Error!FtraceConfig.PrintFilter.RuleReader {
                const buf = gremlin.Reader.init(src);
                var res = FtraceConfig.PrintFilter.RuleReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        FtraceConfig.PrintFilter.RuleWire.ALLOW_WIRE => {
                            const result = try buf.readBool(offset);
                            offset += result.size;
                            res._allow = result.value;
                        },
                        FtraceConfig.PrintFilter.RuleWire.PREFIX_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._prefix = result.value;
                        },
                        FtraceConfig.PrintFilter.RuleWire.ATRACE_MSG_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._atrace_msg_buf = result.value;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub inline fn getAllow(self: *const FtraceConfig.PrintFilter.RuleReader) bool {
                return self._allow;
            }
            pub inline fn getPrefix(self: *const FtraceConfig.PrintFilter.RuleReader) []const u8 {
                return self._prefix orelse &[_]u8{};
            }
            pub fn getAtraceMsg(self: *const FtraceConfig.PrintFilter.RuleReader) gremlin.Error!FtraceConfig.PrintFilter.Rule.AtraceMessageReader {
                if (self._atrace_msg_buf) |buf| {
                    return try FtraceConfig.PrintFilter.Rule.AtraceMessageReader.init(buf);
                }
                return try FtraceConfig.PrintFilter.Rule.AtraceMessageReader.init(&[_]u8{});
            }
        };
        // fields
        rules: ?[]const ?FtraceConfig.PrintFilter.Rule = null,
        pub fn calcProtobufSize(self: *const FtraceConfig.PrintFilter) usize {
            var res: usize = 0;
            if (self.rules) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(FtraceConfig.PrintFilterWire.RULES_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const FtraceConfig.PrintFilter, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const FtraceConfig.PrintFilter, target: *gremlin.Writer) void {
            if (self.rules) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(FtraceConfig.PrintFilterWire.RULES_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(FtraceConfig.PrintFilterWire.RULES_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const PrintFilterReader = struct {
        buf: gremlin.Reader,
        _rules_offset: ?usize = null,
        _rules_last_offset: ?usize = null,
        _rules_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!FtraceConfig.PrintFilterReader {
            const buf = gremlin.Reader.init(src);
            var res = FtraceConfig.PrintFilterReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    FtraceConfig.PrintFilterWire.RULES_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._rules_offset == null) {
                            res._rules_offset = offset - result.size;
                        }
                        res._rules_last_offset = offset;
                        res._rules_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn rulesCount(self: *const FtraceConfig.PrintFilterReader) usize {
            return self._rules_cnt;
        }
        pub fn rulesNext(self: *FtraceConfig.PrintFilterReader) ?FtraceConfig.PrintFilter.RuleReader {
            if (self._rules_offset == null) return null;
            const current_offset = self._rules_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = FtraceConfig.PrintFilter.RuleReader.init(result.value) catch return null;
            if (self._rules_last_offset != null and current_offset >= self._rules_last_offset.?) {
                self._rules_offset = null;
                return msg;
            }
            if (self._rules_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._rules_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == FtraceConfig.PrintFilterWire.RULES_WIRE) {
                    self._rules_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._rules_offset = null;
            return msg;
        }
    };
    const KprobeEventWire = struct {
        const PROBE_WIRE: gremlin.ProtoWireNumber = 1;
        const TYPE_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const KprobeEvent = struct {
        // nested enums
        pub const KprobeType = enum(i32) {
            KPROBE_TYPE_UNKNOWN = 0,
            KPROBE_TYPE_KPROBE = 1,
            KPROBE_TYPE_KRETPROBE = 2,
            KPROBE_TYPE_BOTH = 3,
        };
        // fields
        probe: ?[]const u8 = null,
        type: FtraceConfig.KprobeEvent.KprobeType = @enumFromInt(0),
        pub fn calcProtobufSize(self: *const FtraceConfig.KprobeEvent) usize {
            var res: usize = 0;
            if (self.probe) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(FtraceConfig.KprobeEventWire.PROBE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (@intFromEnum(self.type) != 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceConfig.KprobeEventWire.TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.type));
            }
            return res;
        }
        pub fn encode(self: *const FtraceConfig.KprobeEvent, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const FtraceConfig.KprobeEvent, target: *gremlin.Writer) void {
            if (self.probe) |v| {
                if (v.len > 0) {
                    target.appendBytes(FtraceConfig.KprobeEventWire.PROBE_WIRE, v);
                }
            }
            if (@intFromEnum(self.type) != 0) {
                target.appendInt32(FtraceConfig.KprobeEventWire.TYPE_WIRE, @intFromEnum(self.type));
            }
        }
    };
    pub const KprobeEventReader = struct {
        buf: gremlin.Reader,
        _probe: ?[]const u8 = null,
        _type: FtraceConfig.KprobeEvent.KprobeType = @enumFromInt(0),
        pub fn init(src: []const u8) gremlin.Error!FtraceConfig.KprobeEventReader {
            const buf = gremlin.Reader.init(src);
            var res = FtraceConfig.KprobeEventReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    FtraceConfig.KprobeEventWire.PROBE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._probe = result.value;
                    },
                    FtraceConfig.KprobeEventWire.TYPE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._type = @enumFromInt(result.value);
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getProbe(self: *const FtraceConfig.KprobeEventReader) []const u8 {
            return self._probe orelse &[_]u8{};
        }
        pub inline fn getType(self: *const FtraceConfig.KprobeEventReader) FtraceConfig.KprobeEvent.KprobeType {
            return self._type;
        }
    };
    const TracefsOptionWire = struct {
        const NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const STATE_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const TracefsOption = struct {
        // nested enums
        pub const State = enum(i32) {
            STATE_UNKNOWN = 0,
            STATE_ENABLED = 1,
            STATE_DISABLED = 2,
        };
        // fields
        name: ?[]const u8 = null,
        state: FtraceConfig.TracefsOption.State = @enumFromInt(0),
        pub fn calcProtobufSize(self: *const FtraceConfig.TracefsOption) usize {
            var res: usize = 0;
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(FtraceConfig.TracefsOptionWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (@intFromEnum(self.state) != 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceConfig.TracefsOptionWire.STATE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.state));
            }
            return res;
        }
        pub fn encode(self: *const FtraceConfig.TracefsOption, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const FtraceConfig.TracefsOption, target: *gremlin.Writer) void {
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(FtraceConfig.TracefsOptionWire.NAME_WIRE, v);
                }
            }
            if (@intFromEnum(self.state) != 0) {
                target.appendInt32(FtraceConfig.TracefsOptionWire.STATE_WIRE, @intFromEnum(self.state));
            }
        }
    };
    pub const TracefsOptionReader = struct {
        buf: gremlin.Reader,
        _name: ?[]const u8 = null,
        _state: FtraceConfig.TracefsOption.State = @enumFromInt(0),
        pub fn init(src: []const u8) gremlin.Error!FtraceConfig.TracefsOptionReader {
            const buf = gremlin.Reader.init(src);
            var res = FtraceConfig.TracefsOptionReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    FtraceConfig.TracefsOptionWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    FtraceConfig.TracefsOptionWire.STATE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._state = @enumFromInt(result.value);
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getName(self: *const FtraceConfig.TracefsOptionReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub inline fn getState(self: *const FtraceConfig.TracefsOptionReader) FtraceConfig.TracefsOption.State {
            return self._state;
        }
    };
    // fields
    ftrace_events: ?[]const ?[]const u8 = null,
    atrace_categories: ?[]const ?[]const u8 = null,
    atrace_apps: ?[]const ?[]const u8 = null,
    atrace_categories_prefer_sdk: ?[]const ?[]const u8 = null,
    atrace_userspace_only: bool = false,
    buffer_size_kb: u32 = 0,
    buffer_size_lower_bound: bool = false,
    drain_period_ms: u32 = 0,
    drain_buffer_percent: u32 = 0,
    compact_sched: ?FtraceConfig.CompactSchedConfig = null,
    print_filter: ?FtraceConfig.PrintFilter = null,
    symbolize_ksyms: bool = false,
    ksyms_mem_policy: FtraceConfig.KsymsMemPolicy = @enumFromInt(0),
    throttle_rss_stat: bool = false,
    denser_generic_event_encoding: bool = false,
    disable_generic_events: bool = false,
    syscall_events: ?[]const ?[]const u8 = null,
    enable_function_graph: bool = false,
    function_filters: ?[]const ?[]const u8 = null,
    function_graph_roots: ?[]const ?[]const u8 = null,
    function_graph_max_depth: u32 = 0,
    kprobe_events: ?[]const ?FtraceConfig.KprobeEvent = null,
    preserve_ftrace_buffer: bool = false,
    use_monotonic_raw_clock: bool = false,
    instance_name: ?[]const u8 = null,
    debug_ftrace_abi: bool = false,
    tids_to_trace: ?[]const u32 = null,
    tracefs_options: ?[]const ?FtraceConfig.TracefsOption = null,
    tracing_cpumask: ?[]const u8 = null,
    initialize_ksyms_synchronously_for_testing: bool = false,
    pub fn calcProtobufSize(self: *const FtraceConfig) usize {
        var res: usize = 0;
        if (self.ftrace_events) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.FTRACE_EVENTS_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.atrace_categories) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.ATRACE_CATEGORIES_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.atrace_apps) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.ATRACE_APPS_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.atrace_categories_prefer_sdk) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.ATRACE_CATEGORIES_PREFER_SDK_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.atrace_userspace_only != false) {
            res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.ATRACE_USERSPACE_ONLY_WIRE) + gremlin.sizes.sizeBool(self.atrace_userspace_only);
        }
        if (self.buffer_size_kb != 0) {
            res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.BUFFER_SIZE_KB_WIRE) + gremlin.sizes.sizeU32(self.buffer_size_kb);
        }
        if (self.buffer_size_lower_bound != false) {
            res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.BUFFER_SIZE_LOWER_BOUND_WIRE) + gremlin.sizes.sizeBool(self.buffer_size_lower_bound);
        }
        if (self.drain_period_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.DRAIN_PERIOD_MS_WIRE) + gremlin.sizes.sizeU32(self.drain_period_ms);
        }
        if (self.drain_buffer_percent != 0) {
            res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.DRAIN_BUFFER_PERCENT_WIRE) + gremlin.sizes.sizeU32(self.drain_buffer_percent);
        }
        if (self.compact_sched) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.COMPACT_SCHED_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.print_filter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.PRINT_FILTER_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.symbolize_ksyms != false) {
            res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.SYMBOLIZE_KSYMS_WIRE) + gremlin.sizes.sizeBool(self.symbolize_ksyms);
        }
        if (@intFromEnum(self.ksyms_mem_policy) != 0) {
            res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.KSYMS_MEM_POLICY_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.ksyms_mem_policy));
        }
        if (self.throttle_rss_stat != false) {
            res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.THROTTLE_RSS_STAT_WIRE) + gremlin.sizes.sizeBool(self.throttle_rss_stat);
        }
        if (self.denser_generic_event_encoding != false) {
            res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.DENSER_GENERIC_EVENT_ENCODING_WIRE) + gremlin.sizes.sizeBool(self.denser_generic_event_encoding);
        }
        if (self.disable_generic_events != false) {
            res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.DISABLE_GENERIC_EVENTS_WIRE) + gremlin.sizes.sizeBool(self.disable_generic_events);
        }
        if (self.syscall_events) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.SYSCALL_EVENTS_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.enable_function_graph != false) {
            res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.ENABLE_FUNCTION_GRAPH_WIRE) + gremlin.sizes.sizeBool(self.enable_function_graph);
        }
        if (self.function_filters) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.FUNCTION_FILTERS_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.function_graph_roots) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.FUNCTION_GRAPH_ROOTS_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.function_graph_max_depth != 0) {
            res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.FUNCTION_GRAPH_MAX_DEPTH_WIRE) + gremlin.sizes.sizeU32(self.function_graph_max_depth);
        }
        if (self.kprobe_events) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.KPROBE_EVENTS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.preserve_ftrace_buffer != false) {
            res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.PRESERVE_FTRACE_BUFFER_WIRE) + gremlin.sizes.sizeBool(self.preserve_ftrace_buffer);
        }
        if (self.use_monotonic_raw_clock != false) {
            res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.USE_MONOTONIC_RAW_CLOCK_WIRE) + gremlin.sizes.sizeBool(self.use_monotonic_raw_clock);
        }
        if (self.instance_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.INSTANCE_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.debug_ftrace_abi != false) {
            res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.DEBUG_FTRACE_ABI_WIRE) + gremlin.sizes.sizeBool(self.debug_ftrace_abi);
        }
        if (self.tids_to_trace) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.TIDS_TO_TRACE_WIRE) + gremlin.sizes.sizeU32(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU32(v);
                }
                res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.TIDS_TO_TRACE_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.tracefs_options) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.TRACEFS_OPTIONS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.tracing_cpumask) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.TRACING_CPUMASK_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.initialize_ksyms_synchronously_for_testing != false) {
            res += gremlin.sizes.sizeWireNumber(FtraceConfigWire.INITIALIZE_KSYMS_SYNCHRONOUSLY_FOR_TESTING_WIRE) + gremlin.sizes.sizeBool(self.initialize_ksyms_synchronously_for_testing);
        }
        return res;
    }
    pub fn encode(self: *const FtraceConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const FtraceConfig, target: *gremlin.Writer) void {
        if (self.ftrace_events) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(FtraceConfigWire.FTRACE_EVENTS_WIRE, v);
                } else {
                    target.appendBytesTag(FtraceConfigWire.FTRACE_EVENTS_WIRE, 0);
                }
            }
        }
        if (self.atrace_categories) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(FtraceConfigWire.ATRACE_CATEGORIES_WIRE, v);
                } else {
                    target.appendBytesTag(FtraceConfigWire.ATRACE_CATEGORIES_WIRE, 0);
                }
            }
        }
        if (self.atrace_apps) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(FtraceConfigWire.ATRACE_APPS_WIRE, v);
                } else {
                    target.appendBytesTag(FtraceConfigWire.ATRACE_APPS_WIRE, 0);
                }
            }
        }
        if (self.atrace_categories_prefer_sdk) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(FtraceConfigWire.ATRACE_CATEGORIES_PREFER_SDK_WIRE, v);
                } else {
                    target.appendBytesTag(FtraceConfigWire.ATRACE_CATEGORIES_PREFER_SDK_WIRE, 0);
                }
            }
        }
        if (self.atrace_userspace_only != false) {
            target.appendBool(FtraceConfigWire.ATRACE_USERSPACE_ONLY_WIRE, self.atrace_userspace_only);
        }
        if (self.buffer_size_kb != 0) {
            target.appendUint32(FtraceConfigWire.BUFFER_SIZE_KB_WIRE, self.buffer_size_kb);
        }
        if (self.buffer_size_lower_bound != false) {
            target.appendBool(FtraceConfigWire.BUFFER_SIZE_LOWER_BOUND_WIRE, self.buffer_size_lower_bound);
        }
        if (self.drain_period_ms != 0) {
            target.appendUint32(FtraceConfigWire.DRAIN_PERIOD_MS_WIRE, self.drain_period_ms);
        }
        if (self.drain_buffer_percent != 0) {
            target.appendUint32(FtraceConfigWire.DRAIN_BUFFER_PERCENT_WIRE, self.drain_buffer_percent);
        }
        if (self.compact_sched) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceConfigWire.COMPACT_SCHED_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.print_filter) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(FtraceConfigWire.PRINT_FILTER_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.symbolize_ksyms != false) {
            target.appendBool(FtraceConfigWire.SYMBOLIZE_KSYMS_WIRE, self.symbolize_ksyms);
        }
        if (@intFromEnum(self.ksyms_mem_policy) != 0) {
            target.appendInt32(FtraceConfigWire.KSYMS_MEM_POLICY_WIRE, @intFromEnum(self.ksyms_mem_policy));
        }
        if (self.throttle_rss_stat != false) {
            target.appendBool(FtraceConfigWire.THROTTLE_RSS_STAT_WIRE, self.throttle_rss_stat);
        }
        if (self.denser_generic_event_encoding != false) {
            target.appendBool(FtraceConfigWire.DENSER_GENERIC_EVENT_ENCODING_WIRE, self.denser_generic_event_encoding);
        }
        if (self.disable_generic_events != false) {
            target.appendBool(FtraceConfigWire.DISABLE_GENERIC_EVENTS_WIRE, self.disable_generic_events);
        }
        if (self.syscall_events) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(FtraceConfigWire.SYSCALL_EVENTS_WIRE, v);
                } else {
                    target.appendBytesTag(FtraceConfigWire.SYSCALL_EVENTS_WIRE, 0);
                }
            }
        }
        if (self.enable_function_graph != false) {
            target.appendBool(FtraceConfigWire.ENABLE_FUNCTION_GRAPH_WIRE, self.enable_function_graph);
        }
        if (self.function_filters) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(FtraceConfigWire.FUNCTION_FILTERS_WIRE, v);
                } else {
                    target.appendBytesTag(FtraceConfigWire.FUNCTION_FILTERS_WIRE, 0);
                }
            }
        }
        if (self.function_graph_roots) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(FtraceConfigWire.FUNCTION_GRAPH_ROOTS_WIRE, v);
                } else {
                    target.appendBytesTag(FtraceConfigWire.FUNCTION_GRAPH_ROOTS_WIRE, 0);
                }
            }
        }
        if (self.function_graph_max_depth != 0) {
            target.appendUint32(FtraceConfigWire.FUNCTION_GRAPH_MAX_DEPTH_WIRE, self.function_graph_max_depth);
        }
        if (self.kprobe_events) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(FtraceConfigWire.KPROBE_EVENTS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(FtraceConfigWire.KPROBE_EVENTS_WIRE, 0);
                }
            }
        }
        if (self.preserve_ftrace_buffer != false) {
            target.appendBool(FtraceConfigWire.PRESERVE_FTRACE_BUFFER_WIRE, self.preserve_ftrace_buffer);
        }
        if (self.use_monotonic_raw_clock != false) {
            target.appendBool(FtraceConfigWire.USE_MONOTONIC_RAW_CLOCK_WIRE, self.use_monotonic_raw_clock);
        }
        if (self.instance_name) |v| {
            if (v.len > 0) {
                target.appendBytes(FtraceConfigWire.INSTANCE_NAME_WIRE, v);
            }
        }
        if (self.debug_ftrace_abi != false) {
            target.appendBool(FtraceConfigWire.DEBUG_FTRACE_ABI_WIRE, self.debug_ftrace_abi);
        }
        if (self.tids_to_trace) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint32(FtraceConfigWire.TIDS_TO_TRACE_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU32(v);
                }
                target.appendBytesTag(FtraceConfigWire.TIDS_TO_TRACE_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint32WithoutTag(v);
                }
            }
        }
        if (self.tracefs_options) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(FtraceConfigWire.TRACEFS_OPTIONS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(FtraceConfigWire.TRACEFS_OPTIONS_WIRE, 0);
                }
            }
        }
        if (self.tracing_cpumask) |v| {
            if (v.len > 0) {
                target.appendBytes(FtraceConfigWire.TRACING_CPUMASK_WIRE, v);
            }
        }
        if (self.initialize_ksyms_synchronously_for_testing != false) {
            target.appendBool(FtraceConfigWire.INITIALIZE_KSYMS_SYNCHRONOUSLY_FOR_TESTING_WIRE, self.initialize_ksyms_synchronously_for_testing);
        }
    }
};
pub const FtraceConfigReader = struct {
    buf: gremlin.Reader,
    _ftrace_events_offset: ?usize = null,
    _ftrace_events_last_offset: ?usize = null,
    _ftrace_events_cnt: usize = 0,
    _atrace_categories_offset: ?usize = null,
    _atrace_categories_last_offset: ?usize = null,
    _atrace_categories_cnt: usize = 0,
    _atrace_apps_offset: ?usize = null,
    _atrace_apps_last_offset: ?usize = null,
    _atrace_apps_cnt: usize = 0,
    _atrace_categories_prefer_sdk_offset: ?usize = null,
    _atrace_categories_prefer_sdk_last_offset: ?usize = null,
    _atrace_categories_prefer_sdk_cnt: usize = 0,
    _atrace_userspace_only: bool = false,
    _buffer_size_kb: u32 = 0,
    _buffer_size_lower_bound: bool = false,
    _drain_period_ms: u32 = 0,
    _drain_buffer_percent: u32 = 0,
    _compact_sched_buf: ?[]const u8 = null,
    _print_filter_buf: ?[]const u8 = null,
    _symbolize_ksyms: bool = false,
    _ksyms_mem_policy: FtraceConfig.KsymsMemPolicy = @enumFromInt(0),
    _throttle_rss_stat: bool = false,
    _denser_generic_event_encoding: bool = false,
    _disable_generic_events: bool = false,
    _syscall_events_offset: ?usize = null,
    _syscall_events_last_offset: ?usize = null,
    _syscall_events_cnt: usize = 0,
    _enable_function_graph: bool = false,
    _function_filters_offset: ?usize = null,
    _function_filters_last_offset: ?usize = null,
    _function_filters_cnt: usize = 0,
    _function_graph_roots_offset: ?usize = null,
    _function_graph_roots_last_offset: ?usize = null,
    _function_graph_roots_cnt: usize = 0,
    _function_graph_max_depth: u32 = 0,
    _kprobe_events_offset: ?usize = null,
    _kprobe_events_last_offset: ?usize = null,
    _kprobe_events_cnt: usize = 0,
    _preserve_ftrace_buffer: bool = false,
    _use_monotonic_raw_clock: bool = false,
    _instance_name: ?[]const u8 = null,
    _debug_ftrace_abi: bool = false,
    _tids_to_trace_offset: ?usize = null,
    _tids_to_trace_last_offset: ?usize = null,
    _tids_to_trace_packed: bool = false,
    _tracefs_options_offset: ?usize = null,
    _tracefs_options_last_offset: ?usize = null,
    _tracefs_options_cnt: usize = 0,
    _tracing_cpumask: ?[]const u8 = null,
    _initialize_ksyms_synchronously_for_testing: bool = false,
    pub fn init(src: []const u8) gremlin.Error!FtraceConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = FtraceConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                FtraceConfigWire.FTRACE_EVENTS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._ftrace_events_offset == null) {
                        res._ftrace_events_offset = offset - result.size;
                    }
                    res._ftrace_events_last_offset = offset;
                    res._ftrace_events_cnt += 1;
                },
                FtraceConfigWire.ATRACE_CATEGORIES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._atrace_categories_offset == null) {
                        res._atrace_categories_offset = offset - result.size;
                    }
                    res._atrace_categories_last_offset = offset;
                    res._atrace_categories_cnt += 1;
                },
                FtraceConfigWire.ATRACE_APPS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._atrace_apps_offset == null) {
                        res._atrace_apps_offset = offset - result.size;
                    }
                    res._atrace_apps_last_offset = offset;
                    res._atrace_apps_cnt += 1;
                },
                FtraceConfigWire.ATRACE_CATEGORIES_PREFER_SDK_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._atrace_categories_prefer_sdk_offset == null) {
                        res._atrace_categories_prefer_sdk_offset = offset - result.size;
                    }
                    res._atrace_categories_prefer_sdk_last_offset = offset;
                    res._atrace_categories_prefer_sdk_cnt += 1;
                },
                FtraceConfigWire.ATRACE_USERSPACE_ONLY_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._atrace_userspace_only = result.value;
                },
                FtraceConfigWire.BUFFER_SIZE_KB_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._buffer_size_kb = result.value;
                },
                FtraceConfigWire.BUFFER_SIZE_LOWER_BOUND_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._buffer_size_lower_bound = result.value;
                },
                FtraceConfigWire.DRAIN_PERIOD_MS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._drain_period_ms = result.value;
                },
                FtraceConfigWire.DRAIN_BUFFER_PERCENT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._drain_buffer_percent = result.value;
                },
                FtraceConfigWire.COMPACT_SCHED_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._compact_sched_buf = result.value;
                },
                FtraceConfigWire.PRINT_FILTER_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._print_filter_buf = result.value;
                },
                FtraceConfigWire.SYMBOLIZE_KSYMS_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._symbolize_ksyms = result.value;
                },
                FtraceConfigWire.KSYMS_MEM_POLICY_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._ksyms_mem_policy = @enumFromInt(result.value);
                },
                FtraceConfigWire.THROTTLE_RSS_STAT_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._throttle_rss_stat = result.value;
                },
                FtraceConfigWire.DENSER_GENERIC_EVENT_ENCODING_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._denser_generic_event_encoding = result.value;
                },
                FtraceConfigWire.DISABLE_GENERIC_EVENTS_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._disable_generic_events = result.value;
                },
                FtraceConfigWire.SYSCALL_EVENTS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._syscall_events_offset == null) {
                        res._syscall_events_offset = offset - result.size;
                    }
                    res._syscall_events_last_offset = offset;
                    res._syscall_events_cnt += 1;
                },
                FtraceConfigWire.ENABLE_FUNCTION_GRAPH_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._enable_function_graph = result.value;
                },
                FtraceConfigWire.FUNCTION_FILTERS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._function_filters_offset == null) {
                        res._function_filters_offset = offset - result.size;
                    }
                    res._function_filters_last_offset = offset;
                    res._function_filters_cnt += 1;
                },
                FtraceConfigWire.FUNCTION_GRAPH_ROOTS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._function_graph_roots_offset == null) {
                        res._function_graph_roots_offset = offset - result.size;
                    }
                    res._function_graph_roots_last_offset = offset;
                    res._function_graph_roots_cnt += 1;
                },
                FtraceConfigWire.FUNCTION_GRAPH_MAX_DEPTH_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._function_graph_max_depth = result.value;
                },
                FtraceConfigWire.KPROBE_EVENTS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._kprobe_events_offset == null) {
                        res._kprobe_events_offset = offset - result.size;
                    }
                    res._kprobe_events_last_offset = offset;
                    res._kprobe_events_cnt += 1;
                },
                FtraceConfigWire.PRESERVE_FTRACE_BUFFER_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._preserve_ftrace_buffer = result.value;
                },
                FtraceConfigWire.USE_MONOTONIC_RAW_CLOCK_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._use_monotonic_raw_clock = result.value;
                },
                FtraceConfigWire.INSTANCE_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._instance_name = result.value;
                },
                FtraceConfigWire.DEBUG_FTRACE_ABI_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._debug_ftrace_abi = result.value;
                },
                FtraceConfigWire.TIDS_TO_TRACE_WIRE => {
                    if (res._tids_to_trace_offset == null) {
                        res._tids_to_trace_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._tids_to_trace_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._tids_to_trace_offset = offset + length_result.size;
                        res._tids_to_trace_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._tids_to_trace_last_offset.?;
                    } else {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._tids_to_trace_last_offset = offset;
                    }
                },
                FtraceConfigWire.TRACEFS_OPTIONS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._tracefs_options_offset == null) {
                        res._tracefs_options_offset = offset - result.size;
                    }
                    res._tracefs_options_last_offset = offset;
                    res._tracefs_options_cnt += 1;
                },
                FtraceConfigWire.TRACING_CPUMASK_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._tracing_cpumask = result.value;
                },
                FtraceConfigWire.INITIALIZE_KSYMS_SYNCHRONOUSLY_FOR_TESTING_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._initialize_ksyms_synchronously_for_testing = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn ftraceEventsCount(self: *const FtraceConfigReader) usize {
        return self._ftrace_events_cnt;
    }
    pub fn ftraceEventsNext(self: *FtraceConfigReader) ?[]const u8 {
        if (self._ftrace_events_offset == null) return null;
        const current_offset = self._ftrace_events_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._ftrace_events_last_offset != null and current_offset >= self._ftrace_events_last_offset.?) {
            self._ftrace_events_offset = null;
            return result.value;
        }
        if (self._ftrace_events_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._ftrace_events_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == FtraceConfigWire.FTRACE_EVENTS_WIRE) {
                self._ftrace_events_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._ftrace_events_offset = null;
        return result.value;
    }
    pub fn atraceCategoriesCount(self: *const FtraceConfigReader) usize {
        return self._atrace_categories_cnt;
    }
    pub fn atraceCategoriesNext(self: *FtraceConfigReader) ?[]const u8 {
        if (self._atrace_categories_offset == null) return null;
        const current_offset = self._atrace_categories_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._atrace_categories_last_offset != null and current_offset >= self._atrace_categories_last_offset.?) {
            self._atrace_categories_offset = null;
            return result.value;
        }
        if (self._atrace_categories_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._atrace_categories_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == FtraceConfigWire.ATRACE_CATEGORIES_WIRE) {
                self._atrace_categories_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._atrace_categories_offset = null;
        return result.value;
    }
    pub fn atraceAppsCount(self: *const FtraceConfigReader) usize {
        return self._atrace_apps_cnt;
    }
    pub fn atraceAppsNext(self: *FtraceConfigReader) ?[]const u8 {
        if (self._atrace_apps_offset == null) return null;
        const current_offset = self._atrace_apps_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._atrace_apps_last_offset != null and current_offset >= self._atrace_apps_last_offset.?) {
            self._atrace_apps_offset = null;
            return result.value;
        }
        if (self._atrace_apps_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._atrace_apps_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == FtraceConfigWire.ATRACE_APPS_WIRE) {
                self._atrace_apps_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._atrace_apps_offset = null;
        return result.value;
    }
    pub fn atraceCategoriesPreferSdkCount(self: *const FtraceConfigReader) usize {
        return self._atrace_categories_prefer_sdk_cnt;
    }
    pub fn atraceCategoriesPreferSdkNext(self: *FtraceConfigReader) ?[]const u8 {
        if (self._atrace_categories_prefer_sdk_offset == null) return null;
        const current_offset = self._atrace_categories_prefer_sdk_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._atrace_categories_prefer_sdk_last_offset != null and current_offset >= self._atrace_categories_prefer_sdk_last_offset.?) {
            self._atrace_categories_prefer_sdk_offset = null;
            return result.value;
        }
        if (self._atrace_categories_prefer_sdk_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._atrace_categories_prefer_sdk_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == FtraceConfigWire.ATRACE_CATEGORIES_PREFER_SDK_WIRE) {
                self._atrace_categories_prefer_sdk_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._atrace_categories_prefer_sdk_offset = null;
        return result.value;
    }
    pub inline fn getAtraceUserspaceOnly(self: *const FtraceConfigReader) bool {
        return self._atrace_userspace_only;
    }
    pub inline fn getBufferSizeKb(self: *const FtraceConfigReader) u32 {
        return self._buffer_size_kb;
    }
    pub inline fn getBufferSizeLowerBound(self: *const FtraceConfigReader) bool {
        return self._buffer_size_lower_bound;
    }
    pub inline fn getDrainPeriodMs(self: *const FtraceConfigReader) u32 {
        return self._drain_period_ms;
    }
    pub inline fn getDrainBufferPercent(self: *const FtraceConfigReader) u32 {
        return self._drain_buffer_percent;
    }
    pub fn getCompactSched(self: *const FtraceConfigReader) gremlin.Error!FtraceConfig.CompactSchedConfigReader {
        if (self._compact_sched_buf) |buf| {
            return try FtraceConfig.CompactSchedConfigReader.init(buf);
        }
        return try FtraceConfig.CompactSchedConfigReader.init(&[_]u8{});
    }
    pub fn getPrintFilter(self: *const FtraceConfigReader) gremlin.Error!FtraceConfig.PrintFilterReader {
        if (self._print_filter_buf) |buf| {
            return try FtraceConfig.PrintFilterReader.init(buf);
        }
        return try FtraceConfig.PrintFilterReader.init(&[_]u8{});
    }
    pub inline fn getSymbolizeKsyms(self: *const FtraceConfigReader) bool {
        return self._symbolize_ksyms;
    }
    pub inline fn getKsymsMemPolicy(self: *const FtraceConfigReader) FtraceConfig.KsymsMemPolicy {
        return self._ksyms_mem_policy;
    }
    pub inline fn getThrottleRssStat(self: *const FtraceConfigReader) bool {
        return self._throttle_rss_stat;
    }
    pub inline fn getDenserGenericEventEncoding(self: *const FtraceConfigReader) bool {
        return self._denser_generic_event_encoding;
    }
    pub inline fn getDisableGenericEvents(self: *const FtraceConfigReader) bool {
        return self._disable_generic_events;
    }
    pub fn syscallEventsCount(self: *const FtraceConfigReader) usize {
        return self._syscall_events_cnt;
    }
    pub fn syscallEventsNext(self: *FtraceConfigReader) ?[]const u8 {
        if (self._syscall_events_offset == null) return null;
        const current_offset = self._syscall_events_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._syscall_events_last_offset != null and current_offset >= self._syscall_events_last_offset.?) {
            self._syscall_events_offset = null;
            return result.value;
        }
        if (self._syscall_events_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._syscall_events_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == FtraceConfigWire.SYSCALL_EVENTS_WIRE) {
                self._syscall_events_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._syscall_events_offset = null;
        return result.value;
    }
    pub inline fn getEnableFunctionGraph(self: *const FtraceConfigReader) bool {
        return self._enable_function_graph;
    }
    pub fn functionFiltersCount(self: *const FtraceConfigReader) usize {
        return self._function_filters_cnt;
    }
    pub fn functionFiltersNext(self: *FtraceConfigReader) ?[]const u8 {
        if (self._function_filters_offset == null) return null;
        const current_offset = self._function_filters_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._function_filters_last_offset != null and current_offset >= self._function_filters_last_offset.?) {
            self._function_filters_offset = null;
            return result.value;
        }
        if (self._function_filters_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._function_filters_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == FtraceConfigWire.FUNCTION_FILTERS_WIRE) {
                self._function_filters_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._function_filters_offset = null;
        return result.value;
    }
    pub fn functionGraphRootsCount(self: *const FtraceConfigReader) usize {
        return self._function_graph_roots_cnt;
    }
    pub fn functionGraphRootsNext(self: *FtraceConfigReader) ?[]const u8 {
        if (self._function_graph_roots_offset == null) return null;
        const current_offset = self._function_graph_roots_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._function_graph_roots_last_offset != null and current_offset >= self._function_graph_roots_last_offset.?) {
            self._function_graph_roots_offset = null;
            return result.value;
        }
        if (self._function_graph_roots_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._function_graph_roots_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == FtraceConfigWire.FUNCTION_GRAPH_ROOTS_WIRE) {
                self._function_graph_roots_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._function_graph_roots_offset = null;
        return result.value;
    }
    pub inline fn getFunctionGraphMaxDepth(self: *const FtraceConfigReader) u32 {
        return self._function_graph_max_depth;
    }
    pub fn kprobeEventsCount(self: *const FtraceConfigReader) usize {
        return self._kprobe_events_cnt;
    }
    pub fn kprobeEventsNext(self: *FtraceConfigReader) ?FtraceConfig.KprobeEventReader {
        if (self._kprobe_events_offset == null) return null;
        const current_offset = self._kprobe_events_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = FtraceConfig.KprobeEventReader.init(result.value) catch return null;
        if (self._kprobe_events_last_offset != null and current_offset >= self._kprobe_events_last_offset.?) {
            self._kprobe_events_offset = null;
            return msg;
        }
        if (self._kprobe_events_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._kprobe_events_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == FtraceConfigWire.KPROBE_EVENTS_WIRE) {
                self._kprobe_events_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._kprobe_events_offset = null;
        return msg;
    }
    pub inline fn getPreserveFtraceBuffer(self: *const FtraceConfigReader) bool {
        return self._preserve_ftrace_buffer;
    }
    pub inline fn getUseMonotonicRawClock(self: *const FtraceConfigReader) bool {
        return self._use_monotonic_raw_clock;
    }
    pub inline fn getInstanceName(self: *const FtraceConfigReader) []const u8 {
        return self._instance_name orelse &[_]u8{};
    }
    pub inline fn getDebugFtraceAbi(self: *const FtraceConfigReader) bool {
        return self._debug_ftrace_abi;
    }
    pub fn tidsToTraceNext(self: *FtraceConfigReader) gremlin.Error!?u32 {
        if (self._tids_to_trace_offset == null) return null;
        const current_offset = self._tids_to_trace_offset.?;
        if (current_offset >= self._tids_to_trace_last_offset.?) {
            self._tids_to_trace_offset = null;
            return null;
        }
        if (self._tids_to_trace_packed) {
            const value_result = try self.buf.readUInt32(current_offset);
            self._tids_to_trace_offset = current_offset + value_result.size;
            if (self._tids_to_trace_offset.? >= self._tids_to_trace_last_offset.?) {
                self._tids_to_trace_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._tids_to_trace_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == FtraceConfigWire.TIDS_TO_TRACE_WIRE) {
                    self._tids_to_trace_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._tids_to_trace_offset = null;
            return value_result.value;
        }
    }
    pub fn tracefsOptionsCount(self: *const FtraceConfigReader) usize {
        return self._tracefs_options_cnt;
    }
    pub fn tracefsOptionsNext(self: *FtraceConfigReader) ?FtraceConfig.TracefsOptionReader {
        if (self._tracefs_options_offset == null) return null;
        const current_offset = self._tracefs_options_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = FtraceConfig.TracefsOptionReader.init(result.value) catch return null;
        if (self._tracefs_options_last_offset != null and current_offset >= self._tracefs_options_last_offset.?) {
            self._tracefs_options_offset = null;
            return msg;
        }
        if (self._tracefs_options_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._tracefs_options_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == FtraceConfigWire.TRACEFS_OPTIONS_WIRE) {
                self._tracefs_options_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._tracefs_options_offset = null;
        return msg;
    }
    pub inline fn getTracingCpumask(self: *const FtraceConfigReader) []const u8 {
        return self._tracing_cpumask orelse &[_]u8{};
    }
    pub inline fn getInitializeKsymsSynchronouslyForTesting(self: *const FtraceConfigReader) bool {
        return self._initialize_ksyms_synchronously_for_testing;
    }
};
