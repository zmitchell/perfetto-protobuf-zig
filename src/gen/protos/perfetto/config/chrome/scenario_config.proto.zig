// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
const trace_config = @import("src/gen/protos/perfetto/config/trace_config.proto.zig");
// structs
const TriggerRuleWire = struct {
    const NAME_WIRE: gremlin.ProtoWireNumber = 1;
    const TRIGGER_CHANCE_WIRE: gremlin.ProtoWireNumber = 2;
    const DELAY_MS_WIRE: gremlin.ProtoWireNumber = 3;
    const ACTIVATION_DELAY_MS_WIRE: gremlin.ProtoWireNumber = 8;
    const MANUAL_TRIGGER_NAME_WIRE: gremlin.ProtoWireNumber = 4;
    const HISTOGRAM_WIRE: gremlin.ProtoWireNumber = 5;
    const REPEATING_INTERVAL_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const TriggerRule = struct {
    // nested structs
    const HistogramTriggerWire = struct {
        const HISTOGRAM_NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const MIN_VALUE_WIRE: gremlin.ProtoWireNumber = 2;
        const MAX_VALUE_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const HistogramTrigger = struct {
        // fields
        histogram_name: ?[]const u8 = null,
        min_value: i64 = 0,
        max_value: i64 = 0,
        pub fn calcProtobufSize(self: *const TriggerRule.HistogramTrigger) usize {
            var res: usize = 0;
            if (self.histogram_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(TriggerRule.HistogramTriggerWire.HISTOGRAM_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.min_value != 0) {
                res += gremlin.sizes.sizeWireNumber(TriggerRule.HistogramTriggerWire.MIN_VALUE_WIRE) + gremlin.sizes.sizeI64(self.min_value);
            }
            if (self.max_value != 0) {
                res += gremlin.sizes.sizeWireNumber(TriggerRule.HistogramTriggerWire.MAX_VALUE_WIRE) + gremlin.sizes.sizeI64(self.max_value);
            }
            return res;
        }
        pub fn encode(self: *const TriggerRule.HistogramTrigger, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const TriggerRule.HistogramTrigger, target: *gremlin.Writer) void {
            if (self.histogram_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(TriggerRule.HistogramTriggerWire.HISTOGRAM_NAME_WIRE, v);
                }
            }
            if (self.min_value != 0) {
                target.appendInt64(TriggerRule.HistogramTriggerWire.MIN_VALUE_WIRE, self.min_value);
            }
            if (self.max_value != 0) {
                target.appendInt64(TriggerRule.HistogramTriggerWire.MAX_VALUE_WIRE, self.max_value);
            }
        }
    };
    pub const HistogramTriggerReader = struct {
        buf: gremlin.Reader,
        _histogram_name: ?[]const u8 = null,
        _min_value: i64 = 0,
        _max_value: i64 = 0,
        pub fn init(src: []const u8) gremlin.Error!TriggerRule.HistogramTriggerReader {
            const buf = gremlin.Reader.init(src);
            var res = TriggerRule.HistogramTriggerReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    TriggerRule.HistogramTriggerWire.HISTOGRAM_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._histogram_name = result.value;
                    },
                    TriggerRule.HistogramTriggerWire.MIN_VALUE_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._min_value = result.value;
                    },
                    TriggerRule.HistogramTriggerWire.MAX_VALUE_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._max_value = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getHistogramName(self: *const TriggerRule.HistogramTriggerReader) []const u8 {
            return self._histogram_name orelse &[_]u8{};
        }
        pub inline fn getMinValue(self: *const TriggerRule.HistogramTriggerReader) i64 {
            return self._min_value;
        }
        pub inline fn getMaxValue(self: *const TriggerRule.HistogramTriggerReader) i64 {
            return self._max_value;
        }
    };
    const RepeatingIntervalWire = struct {
        const PERIOD_MS_WIRE: gremlin.ProtoWireNumber = 1;
        const RANDOMIZED_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const RepeatingInterval = struct {
        // fields
        period_ms: u64 = 0,
        randomized: bool = false,
        pub fn calcProtobufSize(self: *const TriggerRule.RepeatingInterval) usize {
            var res: usize = 0;
            if (self.period_ms != 0) {
                res += gremlin.sizes.sizeWireNumber(TriggerRule.RepeatingIntervalWire.PERIOD_MS_WIRE) + gremlin.sizes.sizeU64(self.period_ms);
            }
            if (self.randomized != false) {
                res += gremlin.sizes.sizeWireNumber(TriggerRule.RepeatingIntervalWire.RANDOMIZED_WIRE) + gremlin.sizes.sizeBool(self.randomized);
            }
            return res;
        }
        pub fn encode(self: *const TriggerRule.RepeatingInterval, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const TriggerRule.RepeatingInterval, target: *gremlin.Writer) void {
            if (self.period_ms != 0) {
                target.appendUint64(TriggerRule.RepeatingIntervalWire.PERIOD_MS_WIRE, self.period_ms);
            }
            if (self.randomized != false) {
                target.appendBool(TriggerRule.RepeatingIntervalWire.RANDOMIZED_WIRE, self.randomized);
            }
        }
    };
    pub const RepeatingIntervalReader = struct {
        buf: gremlin.Reader,
        _period_ms: u64 = 0,
        _randomized: bool = false,
        pub fn init(src: []const u8) gremlin.Error!TriggerRule.RepeatingIntervalReader {
            const buf = gremlin.Reader.init(src);
            var res = TriggerRule.RepeatingIntervalReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    TriggerRule.RepeatingIntervalWire.PERIOD_MS_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._period_ms = result.value;
                    },
                    TriggerRule.RepeatingIntervalWire.RANDOMIZED_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._randomized = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getPeriodMs(self: *const TriggerRule.RepeatingIntervalReader) u64 {
            return self._period_ms;
        }
        pub inline fn getRandomized(self: *const TriggerRule.RepeatingIntervalReader) bool {
            return self._randomized;
        }
    };
    // fields
    name: ?[]const u8 = null,
    trigger_chance: f32 = 0.0,
    delay_ms: u64 = 0,
    activation_delay_ms: u64 = 0,
    manual_trigger_name: ?[]const u8 = null,
    histogram: ?TriggerRule.HistogramTrigger = null,
    repeating_interval: ?TriggerRule.RepeatingInterval = null,
    pub fn calcProtobufSize(self: *const TriggerRule) usize {
        var res: usize = 0;
        if (self.name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TriggerRuleWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.trigger_chance != 0.0) {
            res += gremlin.sizes.sizeWireNumber(TriggerRuleWire.TRIGGER_CHANCE_WIRE) + gremlin.sizes.sizeFloat(self.trigger_chance);
        }
        if (self.delay_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(TriggerRuleWire.DELAY_MS_WIRE) + gremlin.sizes.sizeU64(self.delay_ms);
        }
        if (self.activation_delay_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(TriggerRuleWire.ACTIVATION_DELAY_MS_WIRE) + gremlin.sizes.sizeU64(self.activation_delay_ms);
        }
        if (self.manual_trigger_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TriggerRuleWire.MANUAL_TRIGGER_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.histogram) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TriggerRuleWire.HISTOGRAM_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.repeating_interval) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TriggerRuleWire.REPEATING_INTERVAL_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const TriggerRule, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TriggerRule, target: *gremlin.Writer) void {
        if (self.name) |v| {
            if (v.len > 0) {
                target.appendBytes(TriggerRuleWire.NAME_WIRE, v);
            }
        }
        if (self.trigger_chance != 0.0) {
            target.appendFloat32(TriggerRuleWire.TRIGGER_CHANCE_WIRE, self.trigger_chance);
        }
        if (self.delay_ms != 0) {
            target.appendUint64(TriggerRuleWire.DELAY_MS_WIRE, self.delay_ms);
        }
        if (self.activation_delay_ms != 0) {
            target.appendUint64(TriggerRuleWire.ACTIVATION_DELAY_MS_WIRE, self.activation_delay_ms);
        }
        if (self.manual_trigger_name) |v| {
            if (v.len > 0) {
                target.appendBytes(TriggerRuleWire.MANUAL_TRIGGER_NAME_WIRE, v);
            }
        }
        if (self.histogram) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TriggerRuleWire.HISTOGRAM_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.repeating_interval) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TriggerRuleWire.REPEATING_INTERVAL_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const TriggerRuleReader = struct {
    buf: gremlin.Reader,
    _name: ?[]const u8 = null,
    _trigger_chance: f32 = 0.0,
    _delay_ms: u64 = 0,
    _activation_delay_ms: u64 = 0,
    _manual_trigger_name: ?[]const u8 = null,
    _histogram_buf: ?[]const u8 = null,
    _repeating_interval_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!TriggerRuleReader {
        const buf = gremlin.Reader.init(src);
        var res = TriggerRuleReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TriggerRuleWire.NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._name = result.value;
                },
                TriggerRuleWire.TRIGGER_CHANCE_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._trigger_chance = result.value;
                },
                TriggerRuleWire.DELAY_MS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._delay_ms = result.value;
                },
                TriggerRuleWire.ACTIVATION_DELAY_MS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._activation_delay_ms = result.value;
                },
                TriggerRuleWire.MANUAL_TRIGGER_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._manual_trigger_name = result.value;
                },
                TriggerRuleWire.HISTOGRAM_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._histogram_buf = result.value;
                },
                TriggerRuleWire.REPEATING_INTERVAL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._repeating_interval_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getName(self: *const TriggerRuleReader) []const u8 {
        return self._name orelse &[_]u8{};
    }
    pub inline fn getTriggerChance(self: *const TriggerRuleReader) f32 {
        return self._trigger_chance;
    }
    pub inline fn getDelayMs(self: *const TriggerRuleReader) u64 {
        return self._delay_ms;
    }
    pub inline fn getActivationDelayMs(self: *const TriggerRuleReader) u64 {
        return self._activation_delay_ms;
    }
    pub inline fn getManualTriggerName(self: *const TriggerRuleReader) []const u8 {
        return self._manual_trigger_name orelse &[_]u8{};
    }
    pub fn getHistogram(self: *const TriggerRuleReader) gremlin.Error!TriggerRule.HistogramTriggerReader {
        if (self._histogram_buf) |buf| {
            return try TriggerRule.HistogramTriggerReader.init(buf);
        }
        return try TriggerRule.HistogramTriggerReader.init(&[_]u8{});
    }
    pub fn getRepeatingInterval(self: *const TriggerRuleReader) gremlin.Error!TriggerRule.RepeatingIntervalReader {
        if (self._repeating_interval_buf) |buf| {
            return try TriggerRule.RepeatingIntervalReader.init(buf);
        }
        return try TriggerRule.RepeatingIntervalReader.init(&[_]u8{});
    }
};
const NestedScenarioConfigWire = struct {
    const SCENARIO_NAME_WIRE: gremlin.ProtoWireNumber = 1;
    const START_RULES_WIRE: gremlin.ProtoWireNumber = 2;
    const STOP_RULES_WIRE: gremlin.ProtoWireNumber = 3;
    const UPLOAD_RULES_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const NestedScenarioConfig = struct {
    // fields
    scenario_name: ?[]const u8 = null,
    start_rules: ?[]const ?TriggerRule = null,
    stop_rules: ?[]const ?TriggerRule = null,
    upload_rules: ?[]const ?TriggerRule = null,
    pub fn calcProtobufSize(self: *const NestedScenarioConfig) usize {
        var res: usize = 0;
        if (self.scenario_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(NestedScenarioConfigWire.SCENARIO_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.start_rules) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(NestedScenarioConfigWire.START_RULES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.stop_rules) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(NestedScenarioConfigWire.STOP_RULES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.upload_rules) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(NestedScenarioConfigWire.UPLOAD_RULES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const NestedScenarioConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const NestedScenarioConfig, target: *gremlin.Writer) void {
        if (self.scenario_name) |v| {
            if (v.len > 0) {
                target.appendBytes(NestedScenarioConfigWire.SCENARIO_NAME_WIRE, v);
            }
        }
        if (self.start_rules) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(NestedScenarioConfigWire.START_RULES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(NestedScenarioConfigWire.START_RULES_WIRE, 0);
                }
            }
        }
        if (self.stop_rules) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(NestedScenarioConfigWire.STOP_RULES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(NestedScenarioConfigWire.STOP_RULES_WIRE, 0);
                }
            }
        }
        if (self.upload_rules) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(NestedScenarioConfigWire.UPLOAD_RULES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(NestedScenarioConfigWire.UPLOAD_RULES_WIRE, 0);
                }
            }
        }
    }
};
pub const NestedScenarioConfigReader = struct {
    buf: gremlin.Reader,
    _scenario_name: ?[]const u8 = null,
    _start_rules_offset: ?usize = null,
    _start_rules_last_offset: ?usize = null,
    _start_rules_cnt: usize = 0,
    _stop_rules_offset: ?usize = null,
    _stop_rules_last_offset: ?usize = null,
    _stop_rules_cnt: usize = 0,
    _upload_rules_offset: ?usize = null,
    _upload_rules_last_offset: ?usize = null,
    _upload_rules_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!NestedScenarioConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = NestedScenarioConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                NestedScenarioConfigWire.SCENARIO_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._scenario_name = result.value;
                },
                NestedScenarioConfigWire.START_RULES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._start_rules_offset == null) {
                        res._start_rules_offset = offset - result.size;
                    }
                    res._start_rules_last_offset = offset;
                    res._start_rules_cnt += 1;
                },
                NestedScenarioConfigWire.STOP_RULES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._stop_rules_offset == null) {
                        res._stop_rules_offset = offset - result.size;
                    }
                    res._stop_rules_last_offset = offset;
                    res._stop_rules_cnt += 1;
                },
                NestedScenarioConfigWire.UPLOAD_RULES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._upload_rules_offset == null) {
                        res._upload_rules_offset = offset - result.size;
                    }
                    res._upload_rules_last_offset = offset;
                    res._upload_rules_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getScenarioName(self: *const NestedScenarioConfigReader) []const u8 {
        return self._scenario_name orelse &[_]u8{};
    }
    pub fn startRulesCount(self: *const NestedScenarioConfigReader) usize {
        return self._start_rules_cnt;
    }
    pub fn startRulesNext(self: *NestedScenarioConfigReader) ?TriggerRuleReader {
        if (self._start_rules_offset == null) return null;
        const current_offset = self._start_rules_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = TriggerRuleReader.init(result.value) catch return null;
        if (self._start_rules_last_offset != null and current_offset >= self._start_rules_last_offset.?) {
            self._start_rules_offset = null;
            return msg;
        }
        if (self._start_rules_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._start_rules_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == NestedScenarioConfigWire.START_RULES_WIRE) {
                self._start_rules_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._start_rules_offset = null;
        return msg;
    }
    pub fn stopRulesCount(self: *const NestedScenarioConfigReader) usize {
        return self._stop_rules_cnt;
    }
    pub fn stopRulesNext(self: *NestedScenarioConfigReader) ?TriggerRuleReader {
        if (self._stop_rules_offset == null) return null;
        const current_offset = self._stop_rules_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = TriggerRuleReader.init(result.value) catch return null;
        if (self._stop_rules_last_offset != null and current_offset >= self._stop_rules_last_offset.?) {
            self._stop_rules_offset = null;
            return msg;
        }
        if (self._stop_rules_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._stop_rules_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == NestedScenarioConfigWire.STOP_RULES_WIRE) {
                self._stop_rules_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._stop_rules_offset = null;
        return msg;
    }
    pub fn uploadRulesCount(self: *const NestedScenarioConfigReader) usize {
        return self._upload_rules_cnt;
    }
    pub fn uploadRulesNext(self: *NestedScenarioConfigReader) ?TriggerRuleReader {
        if (self._upload_rules_offset == null) return null;
        const current_offset = self._upload_rules_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = TriggerRuleReader.init(result.value) catch return null;
        if (self._upload_rules_last_offset != null and current_offset >= self._upload_rules_last_offset.?) {
            self._upload_rules_offset = null;
            return msg;
        }
        if (self._upload_rules_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._upload_rules_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == NestedScenarioConfigWire.UPLOAD_RULES_WIRE) {
                self._upload_rules_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._upload_rules_offset = null;
        return msg;
    }
};
const ScenarioConfigWire = struct {
    const SCENARIO_NAME_WIRE: gremlin.ProtoWireNumber = 1;
    const SCENARIO_DESCRIPTION_WIRE: gremlin.ProtoWireNumber = 9;
    const START_RULES_WIRE: gremlin.ProtoWireNumber = 2;
    const STOP_RULES_WIRE: gremlin.ProtoWireNumber = 3;
    const UPLOAD_RULES_WIRE: gremlin.ProtoWireNumber = 4;
    const SETUP_RULES_WIRE: gremlin.ProtoWireNumber = 5;
    const TRACE_CONFIG_WIRE: gremlin.ProtoWireNumber = 6;
    const NESTED_SCENARIOS_WIRE: gremlin.ProtoWireNumber = 7;
    const USE_SYSTEM_BACKEND_WIRE: gremlin.ProtoWireNumber = 8;
};
pub const ScenarioConfig = struct {
    // fields
    scenario_name: ?[]const u8 = null,
    scenario_description: ?[]const u8 = null,
    start_rules: ?[]const ?TriggerRule = null,
    stop_rules: ?[]const ?TriggerRule = null,
    upload_rules: ?[]const ?TriggerRule = null,
    setup_rules: ?[]const ?TriggerRule = null,
    trace_config: ?trace_config.TraceConfig = null,
    nested_scenarios: ?[]const ?NestedScenarioConfig = null,
    use_system_backend: bool = false,
    pub fn calcProtobufSize(self: *const ScenarioConfig) usize {
        var res: usize = 0;
        if (self.scenario_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(ScenarioConfigWire.SCENARIO_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.scenario_description) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(ScenarioConfigWire.SCENARIO_DESCRIPTION_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.start_rules) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ScenarioConfigWire.START_RULES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.stop_rules) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ScenarioConfigWire.STOP_RULES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.upload_rules) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ScenarioConfigWire.UPLOAD_RULES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.setup_rules) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ScenarioConfigWire.SETUP_RULES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.trace_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ScenarioConfigWire.TRACE_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.nested_scenarios) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ScenarioConfigWire.NESTED_SCENARIOS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.use_system_backend != false) {
            res += gremlin.sizes.sizeWireNumber(ScenarioConfigWire.USE_SYSTEM_BACKEND_WIRE) + gremlin.sizes.sizeBool(self.use_system_backend);
        }
        return res;
    }
    pub fn encode(self: *const ScenarioConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ScenarioConfig, target: *gremlin.Writer) void {
        if (self.scenario_name) |v| {
            if (v.len > 0) {
                target.appendBytes(ScenarioConfigWire.SCENARIO_NAME_WIRE, v);
            }
        }
        if (self.scenario_description) |v| {
            if (v.len > 0) {
                target.appendBytes(ScenarioConfigWire.SCENARIO_DESCRIPTION_WIRE, v);
            }
        }
        if (self.start_rules) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(ScenarioConfigWire.START_RULES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(ScenarioConfigWire.START_RULES_WIRE, 0);
                }
            }
        }
        if (self.stop_rules) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(ScenarioConfigWire.STOP_RULES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(ScenarioConfigWire.STOP_RULES_WIRE, 0);
                }
            }
        }
        if (self.upload_rules) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(ScenarioConfigWire.UPLOAD_RULES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(ScenarioConfigWire.UPLOAD_RULES_WIRE, 0);
                }
            }
        }
        if (self.setup_rules) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(ScenarioConfigWire.SETUP_RULES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(ScenarioConfigWire.SETUP_RULES_WIRE, 0);
                }
            }
        }
        if (self.trace_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ScenarioConfigWire.TRACE_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.nested_scenarios) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(ScenarioConfigWire.NESTED_SCENARIOS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(ScenarioConfigWire.NESTED_SCENARIOS_WIRE, 0);
                }
            }
        }
        if (self.use_system_backend != false) {
            target.appendBool(ScenarioConfigWire.USE_SYSTEM_BACKEND_WIRE, self.use_system_backend);
        }
    }
};
pub const ScenarioConfigReader = struct {
    buf: gremlin.Reader,
    _scenario_name: ?[]const u8 = null,
    _scenario_description: ?[]const u8 = null,
    _start_rules_offset: ?usize = null,
    _start_rules_last_offset: ?usize = null,
    _start_rules_cnt: usize = 0,
    _stop_rules_offset: ?usize = null,
    _stop_rules_last_offset: ?usize = null,
    _stop_rules_cnt: usize = 0,
    _upload_rules_offset: ?usize = null,
    _upload_rules_last_offset: ?usize = null,
    _upload_rules_cnt: usize = 0,
    _setup_rules_offset: ?usize = null,
    _setup_rules_last_offset: ?usize = null,
    _setup_rules_cnt: usize = 0,
    _trace_config_buf: ?[]const u8 = null,
    _nested_scenarios_offset: ?usize = null,
    _nested_scenarios_last_offset: ?usize = null,
    _nested_scenarios_cnt: usize = 0,
    _use_system_backend: bool = false,
    pub fn init(src: []const u8) gremlin.Error!ScenarioConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = ScenarioConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ScenarioConfigWire.SCENARIO_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._scenario_name = result.value;
                },
                ScenarioConfigWire.SCENARIO_DESCRIPTION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._scenario_description = result.value;
                },
                ScenarioConfigWire.START_RULES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._start_rules_offset == null) {
                        res._start_rules_offset = offset - result.size;
                    }
                    res._start_rules_last_offset = offset;
                    res._start_rules_cnt += 1;
                },
                ScenarioConfigWire.STOP_RULES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._stop_rules_offset == null) {
                        res._stop_rules_offset = offset - result.size;
                    }
                    res._stop_rules_last_offset = offset;
                    res._stop_rules_cnt += 1;
                },
                ScenarioConfigWire.UPLOAD_RULES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._upload_rules_offset == null) {
                        res._upload_rules_offset = offset - result.size;
                    }
                    res._upload_rules_last_offset = offset;
                    res._upload_rules_cnt += 1;
                },
                ScenarioConfigWire.SETUP_RULES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._setup_rules_offset == null) {
                        res._setup_rules_offset = offset - result.size;
                    }
                    res._setup_rules_last_offset = offset;
                    res._setup_rules_cnt += 1;
                },
                ScenarioConfigWire.TRACE_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._trace_config_buf = result.value;
                },
                ScenarioConfigWire.NESTED_SCENARIOS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._nested_scenarios_offset == null) {
                        res._nested_scenarios_offset = offset - result.size;
                    }
                    res._nested_scenarios_last_offset = offset;
                    res._nested_scenarios_cnt += 1;
                },
                ScenarioConfigWire.USE_SYSTEM_BACKEND_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._use_system_backend = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getScenarioName(self: *const ScenarioConfigReader) []const u8 {
        return self._scenario_name orelse &[_]u8{};
    }
    pub inline fn getScenarioDescription(self: *const ScenarioConfigReader) []const u8 {
        return self._scenario_description orelse &[_]u8{};
    }
    pub fn startRulesCount(self: *const ScenarioConfigReader) usize {
        return self._start_rules_cnt;
    }
    pub fn startRulesNext(self: *ScenarioConfigReader) ?TriggerRuleReader {
        if (self._start_rules_offset == null) return null;
        const current_offset = self._start_rules_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = TriggerRuleReader.init(result.value) catch return null;
        if (self._start_rules_last_offset != null and current_offset >= self._start_rules_last_offset.?) {
            self._start_rules_offset = null;
            return msg;
        }
        if (self._start_rules_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._start_rules_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ScenarioConfigWire.START_RULES_WIRE) {
                self._start_rules_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._start_rules_offset = null;
        return msg;
    }
    pub fn stopRulesCount(self: *const ScenarioConfigReader) usize {
        return self._stop_rules_cnt;
    }
    pub fn stopRulesNext(self: *ScenarioConfigReader) ?TriggerRuleReader {
        if (self._stop_rules_offset == null) return null;
        const current_offset = self._stop_rules_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = TriggerRuleReader.init(result.value) catch return null;
        if (self._stop_rules_last_offset != null and current_offset >= self._stop_rules_last_offset.?) {
            self._stop_rules_offset = null;
            return msg;
        }
        if (self._stop_rules_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._stop_rules_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ScenarioConfigWire.STOP_RULES_WIRE) {
                self._stop_rules_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._stop_rules_offset = null;
        return msg;
    }
    pub fn uploadRulesCount(self: *const ScenarioConfigReader) usize {
        return self._upload_rules_cnt;
    }
    pub fn uploadRulesNext(self: *ScenarioConfigReader) ?TriggerRuleReader {
        if (self._upload_rules_offset == null) return null;
        const current_offset = self._upload_rules_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = TriggerRuleReader.init(result.value) catch return null;
        if (self._upload_rules_last_offset != null and current_offset >= self._upload_rules_last_offset.?) {
            self._upload_rules_offset = null;
            return msg;
        }
        if (self._upload_rules_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._upload_rules_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ScenarioConfigWire.UPLOAD_RULES_WIRE) {
                self._upload_rules_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._upload_rules_offset = null;
        return msg;
    }
    pub fn setupRulesCount(self: *const ScenarioConfigReader) usize {
        return self._setup_rules_cnt;
    }
    pub fn setupRulesNext(self: *ScenarioConfigReader) ?TriggerRuleReader {
        if (self._setup_rules_offset == null) return null;
        const current_offset = self._setup_rules_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = TriggerRuleReader.init(result.value) catch return null;
        if (self._setup_rules_last_offset != null and current_offset >= self._setup_rules_last_offset.?) {
            self._setup_rules_offset = null;
            return msg;
        }
        if (self._setup_rules_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._setup_rules_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ScenarioConfigWire.SETUP_RULES_WIRE) {
                self._setup_rules_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._setup_rules_offset = null;
        return msg;
    }
    pub fn getTraceConfig(self: *const ScenarioConfigReader) gremlin.Error!trace_config.TraceConfigReader {
        if (self._trace_config_buf) |buf| {
            return try trace_config.TraceConfigReader.init(buf);
        }
        return try trace_config.TraceConfigReader.init(&[_]u8{});
    }
    pub fn nestedScenariosCount(self: *const ScenarioConfigReader) usize {
        return self._nested_scenarios_cnt;
    }
    pub fn nestedScenariosNext(self: *ScenarioConfigReader) ?NestedScenarioConfigReader {
        if (self._nested_scenarios_offset == null) return null;
        const current_offset = self._nested_scenarios_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = NestedScenarioConfigReader.init(result.value) catch return null;
        if (self._nested_scenarios_last_offset != null and current_offset >= self._nested_scenarios_last_offset.?) {
            self._nested_scenarios_offset = null;
            return msg;
        }
        if (self._nested_scenarios_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._nested_scenarios_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ScenarioConfigWire.NESTED_SCENARIOS_WIRE) {
                self._nested_scenarios_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._nested_scenarios_offset = null;
        return msg;
    }
    pub inline fn getUseSystemBackend(self: *const ScenarioConfigReader) bool {
        return self._use_system_backend;
    }
};
const ChromeFieldTracingConfigWire = struct {
    const SCENARIOS_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const ChromeFieldTracingConfig = struct {
    // fields
    scenarios: ?[]const ?ScenarioConfig = null,
    pub fn calcProtobufSize(self: *const ChromeFieldTracingConfig) usize {
        var res: usize = 0;
        if (self.scenarios) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ChromeFieldTracingConfigWire.SCENARIOS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const ChromeFieldTracingConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ChromeFieldTracingConfig, target: *gremlin.Writer) void {
        if (self.scenarios) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(ChromeFieldTracingConfigWire.SCENARIOS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(ChromeFieldTracingConfigWire.SCENARIOS_WIRE, 0);
                }
            }
        }
    }
};
pub const ChromeFieldTracingConfigReader = struct {
    buf: gremlin.Reader,
    _scenarios_offset: ?usize = null,
    _scenarios_last_offset: ?usize = null,
    _scenarios_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!ChromeFieldTracingConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = ChromeFieldTracingConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ChromeFieldTracingConfigWire.SCENARIOS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._scenarios_offset == null) {
                        res._scenarios_offset = offset - result.size;
                    }
                    res._scenarios_last_offset = offset;
                    res._scenarios_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn scenariosCount(self: *const ChromeFieldTracingConfigReader) usize {
        return self._scenarios_cnt;
    }
    pub fn scenariosNext(self: *ChromeFieldTracingConfigReader) ?ScenarioConfigReader {
        if (self._scenarios_offset == null) return null;
        const current_offset = self._scenarios_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = ScenarioConfigReader.init(result.value) catch return null;
        if (self._scenarios_last_offset != null and current_offset >= self._scenarios_last_offset.?) {
            self._scenarios_offset = null;
            return msg;
        }
        if (self._scenarios_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._scenarios_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ChromeFieldTracingConfigWire.SCENARIOS_WIRE) {
                self._scenarios_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._scenarios_offset = null;
        return msg;
    }
};
const TracingTriggerRulesConfigWire = struct {
    const RULES_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const TracingTriggerRulesConfig = struct {
    // fields
    rules: ?[]const ?TriggerRule = null,
    pub fn calcProtobufSize(self: *const TracingTriggerRulesConfig) usize {
        var res: usize = 0;
        if (self.rules) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TracingTriggerRulesConfigWire.RULES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const TracingTriggerRulesConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TracingTriggerRulesConfig, target: *gremlin.Writer) void {
        if (self.rules) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(TracingTriggerRulesConfigWire.RULES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(TracingTriggerRulesConfigWire.RULES_WIRE, 0);
                }
            }
        }
    }
};
pub const TracingTriggerRulesConfigReader = struct {
    buf: gremlin.Reader,
    _rules_offset: ?usize = null,
    _rules_last_offset: ?usize = null,
    _rules_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!TracingTriggerRulesConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = TracingTriggerRulesConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TracingTriggerRulesConfigWire.RULES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._rules_offset == null) {
                        res._rules_offset = offset - result.size;
                    }
                    res._rules_last_offset = offset;
                    res._rules_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn rulesCount(self: *const TracingTriggerRulesConfigReader) usize {
        return self._rules_cnt;
    }
    pub fn rulesNext(self: *TracingTriggerRulesConfigReader) ?TriggerRuleReader {
        if (self._rules_offset == null) return null;
        const current_offset = self._rules_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = TriggerRuleReader.init(result.value) catch return null;
        if (self._rules_last_offset != null and current_offset >= self._rules_last_offset.?) {
            self._rules_offset = null;
            return msg;
        }
        if (self._rules_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._rules_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TracingTriggerRulesConfigWire.RULES_WIRE) {
                self._rules_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._rules_offset = null;
        return msg;
    }
};
