// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const TestConfigWire = struct {
    const MESSAGE_COUNT_WIRE: gremlin.ProtoWireNumber = 1;
    const MAX_MESSAGES_PER_SECOND_WIRE: gremlin.ProtoWireNumber = 2;
    const SEED_WIRE: gremlin.ProtoWireNumber = 3;
    const MESSAGE_SIZE_WIRE: gremlin.ProtoWireNumber = 4;
    const SEND_BATCH_ON_REGISTER_WIRE: gremlin.ProtoWireNumber = 5;
    const DUMMY_FIELDS_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const TestConfig = struct {
    // nested structs
    const DummyFieldsWire = struct {
        const FIELD_UINT32_WIRE: gremlin.ProtoWireNumber = 1;
        const FIELD_INT32_WIRE: gremlin.ProtoWireNumber = 2;
        const FIELD_UINT64_WIRE: gremlin.ProtoWireNumber = 3;
        const FIELD_INT64_WIRE: gremlin.ProtoWireNumber = 4;
        const FIELD_FIXED64_WIRE: gremlin.ProtoWireNumber = 5;
        const FIELD_SFIXED64_WIRE: gremlin.ProtoWireNumber = 6;
        const FIELD_FIXED32_WIRE: gremlin.ProtoWireNumber = 7;
        const FIELD_SFIXED32_WIRE: gremlin.ProtoWireNumber = 8;
        const FIELD_DOUBLE_WIRE: gremlin.ProtoWireNumber = 9;
        const FIELD_FLOAT_WIRE: gremlin.ProtoWireNumber = 10;
        const FIELD_SINT64_WIRE: gremlin.ProtoWireNumber = 11;
        const FIELD_SINT32_WIRE: gremlin.ProtoWireNumber = 12;
        const FIELD_STRING_WIRE: gremlin.ProtoWireNumber = 13;
        const FIELD_BYTES_WIRE: gremlin.ProtoWireNumber = 14;
    };
    pub const DummyFields = struct {
        // fields
        field_uint32: u32 = 0,
        field_int32: i32 = 0,
        field_uint64: u64 = 0,
        field_int64: i64 = 0,
        field_fixed64: u64 = 0,
        field_sfixed64: i64 = 0,
        field_fixed32: u32 = 0,
        field_sfixed32: i32 = 0,
        field_double: f64 = 0.0,
        field_float: f32 = 0.0,
        field_sint64: i64 = 0,
        field_sint32: i32 = 0,
        field_string: ?[]const u8 = null,
        field_bytes: ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const TestConfig.DummyFields) usize {
            var res: usize = 0;
            if (self.field_uint32 != 0) {
                res += gremlin.sizes.sizeWireNumber(TestConfig.DummyFieldsWire.FIELD_UINT32_WIRE) + gremlin.sizes.sizeU32(self.field_uint32);
            }
            if (self.field_int32 != 0) {
                res += gremlin.sizes.sizeWireNumber(TestConfig.DummyFieldsWire.FIELD_INT32_WIRE) + gremlin.sizes.sizeI32(self.field_int32);
            }
            if (self.field_uint64 != 0) {
                res += gremlin.sizes.sizeWireNumber(TestConfig.DummyFieldsWire.FIELD_UINT64_WIRE) + gremlin.sizes.sizeU64(self.field_uint64);
            }
            if (self.field_int64 != 0) {
                res += gremlin.sizes.sizeWireNumber(TestConfig.DummyFieldsWire.FIELD_INT64_WIRE) + gremlin.sizes.sizeI64(self.field_int64);
            }
            if (self.field_fixed64 != 0) {
                res += gremlin.sizes.sizeWireNumber(TestConfig.DummyFieldsWire.FIELD_FIXED64_WIRE) + gremlin.sizes.sizeFixed64(self.field_fixed64);
            }
            if (self.field_sfixed64 != 0) {
                res += gremlin.sizes.sizeWireNumber(TestConfig.DummyFieldsWire.FIELD_SFIXED64_WIRE) + gremlin.sizes.sizeSFixed64(self.field_sfixed64);
            }
            if (self.field_fixed32 != 0) {
                res += gremlin.sizes.sizeWireNumber(TestConfig.DummyFieldsWire.FIELD_FIXED32_WIRE) + gremlin.sizes.sizeFixed32(self.field_fixed32);
            }
            if (self.field_sfixed32 != 0) {
                res += gremlin.sizes.sizeWireNumber(TestConfig.DummyFieldsWire.FIELD_SFIXED32_WIRE) + gremlin.sizes.sizeSFixed32(self.field_sfixed32);
            }
            if (self.field_double != 0.0) {
                res += gremlin.sizes.sizeWireNumber(TestConfig.DummyFieldsWire.FIELD_DOUBLE_WIRE) + gremlin.sizes.sizeDouble(self.field_double);
            }
            if (self.field_float != 0.0) {
                res += gremlin.sizes.sizeWireNumber(TestConfig.DummyFieldsWire.FIELD_FLOAT_WIRE) + gremlin.sizes.sizeFloat(self.field_float);
            }
            if (self.field_sint64 != 0) {
                res += gremlin.sizes.sizeWireNumber(TestConfig.DummyFieldsWire.FIELD_SINT64_WIRE) + gremlin.sizes.sizeSI64(self.field_sint64);
            }
            if (self.field_sint32 != 0) {
                res += gremlin.sizes.sizeWireNumber(TestConfig.DummyFieldsWire.FIELD_SINT32_WIRE) + gremlin.sizes.sizeSI32(self.field_sint32);
            }
            if (self.field_string) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(TestConfig.DummyFieldsWire.FIELD_STRING_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.field_bytes) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(TestConfig.DummyFieldsWire.FIELD_BYTES_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            return res;
        }
        pub fn encode(self: *const TestConfig.DummyFields, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const TestConfig.DummyFields, target: *gremlin.Writer) void {
            if (self.field_uint32 != 0) {
                target.appendUint32(TestConfig.DummyFieldsWire.FIELD_UINT32_WIRE, self.field_uint32);
            }
            if (self.field_int32 != 0) {
                target.appendInt32(TestConfig.DummyFieldsWire.FIELD_INT32_WIRE, self.field_int32);
            }
            if (self.field_uint64 != 0) {
                target.appendUint64(TestConfig.DummyFieldsWire.FIELD_UINT64_WIRE, self.field_uint64);
            }
            if (self.field_int64 != 0) {
                target.appendInt64(TestConfig.DummyFieldsWire.FIELD_INT64_WIRE, self.field_int64);
            }
            if (self.field_fixed64 != 0) {
                target.appendFixed64(TestConfig.DummyFieldsWire.FIELD_FIXED64_WIRE, self.field_fixed64);
            }
            if (self.field_sfixed64 != 0) {
                target.appendSfixed64(TestConfig.DummyFieldsWire.FIELD_SFIXED64_WIRE, self.field_sfixed64);
            }
            if (self.field_fixed32 != 0) {
                target.appendFixed32(TestConfig.DummyFieldsWire.FIELD_FIXED32_WIRE, self.field_fixed32);
            }
            if (self.field_sfixed32 != 0) {
                target.appendSfixed32(TestConfig.DummyFieldsWire.FIELD_SFIXED32_WIRE, self.field_sfixed32);
            }
            if (self.field_double != 0.0) {
                target.appendFloat64(TestConfig.DummyFieldsWire.FIELD_DOUBLE_WIRE, self.field_double);
            }
            if (self.field_float != 0.0) {
                target.appendFloat32(TestConfig.DummyFieldsWire.FIELD_FLOAT_WIRE, self.field_float);
            }
            if (self.field_sint64 != 0) {
                target.appendSint64(TestConfig.DummyFieldsWire.FIELD_SINT64_WIRE, self.field_sint64);
            }
            if (self.field_sint32 != 0) {
                target.appendSint32(TestConfig.DummyFieldsWire.FIELD_SINT32_WIRE, self.field_sint32);
            }
            if (self.field_string) |v| {
                if (v.len > 0) {
                    target.appendBytes(TestConfig.DummyFieldsWire.FIELD_STRING_WIRE, v);
                }
            }
            if (self.field_bytes) |v| {
                if (v.len > 0) {
                    target.appendBytes(TestConfig.DummyFieldsWire.FIELD_BYTES_WIRE, v);
                }
            }
        }
    };
    pub const DummyFieldsReader = struct {
        buf: gremlin.Reader,
        _field_uint32: u32 = 0,
        _field_int32: i32 = 0,
        _field_uint64: u64 = 0,
        _field_int64: i64 = 0,
        _field_fixed64: u64 = 0,
        _field_sfixed64: i64 = 0,
        _field_fixed32: u32 = 0,
        _field_sfixed32: i32 = 0,
        _field_double: f64 = 0.0,
        _field_float: f32 = 0.0,
        _field_sint64: i64 = 0,
        _field_sint32: i32 = 0,
        _field_string: ?[]const u8 = null,
        _field_bytes: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!TestConfig.DummyFieldsReader {
            const buf = gremlin.Reader.init(src);
            var res = TestConfig.DummyFieldsReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    TestConfig.DummyFieldsWire.FIELD_UINT32_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._field_uint32 = result.value;
                    },
                    TestConfig.DummyFieldsWire.FIELD_INT32_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._field_int32 = result.value;
                    },
                    TestConfig.DummyFieldsWire.FIELD_UINT64_WIRE => {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._field_uint64 = result.value;
                    },
                    TestConfig.DummyFieldsWire.FIELD_INT64_WIRE => {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._field_int64 = result.value;
                    },
                    TestConfig.DummyFieldsWire.FIELD_FIXED64_WIRE => {
                        const result = try buf.readFixed64(offset);
                        offset += result.size;
                        res._field_fixed64 = result.value;
                    },
                    TestConfig.DummyFieldsWire.FIELD_SFIXED64_WIRE => {
                        const result = try buf.readSFixed64(offset);
                        offset += result.size;
                        res._field_sfixed64 = result.value;
                    },
                    TestConfig.DummyFieldsWire.FIELD_FIXED32_WIRE => {
                        const result = try buf.readFixed32(offset);
                        offset += result.size;
                        res._field_fixed32 = result.value;
                    },
                    TestConfig.DummyFieldsWire.FIELD_SFIXED32_WIRE => {
                        const result = try buf.readSFixed32(offset);
                        offset += result.size;
                        res._field_sfixed32 = result.value;
                    },
                    TestConfig.DummyFieldsWire.FIELD_DOUBLE_WIRE => {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._field_double = result.value;
                    },
                    TestConfig.DummyFieldsWire.FIELD_FLOAT_WIRE => {
                        const result = try buf.readFloat32(offset);
                        offset += result.size;
                        res._field_float = result.value;
                    },
                    TestConfig.DummyFieldsWire.FIELD_SINT64_WIRE => {
                        const result = try buf.readSInt64(offset);
                        offset += result.size;
                        res._field_sint64 = result.value;
                    },
                    TestConfig.DummyFieldsWire.FIELD_SINT32_WIRE => {
                        const result = try buf.readSInt32(offset);
                        offset += result.size;
                        res._field_sint32 = result.value;
                    },
                    TestConfig.DummyFieldsWire.FIELD_STRING_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._field_string = result.value;
                    },
                    TestConfig.DummyFieldsWire.FIELD_BYTES_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._field_bytes = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getFieldUint32(self: *const TestConfig.DummyFieldsReader) u32 {
            return self._field_uint32;
        }
        pub inline fn getFieldInt32(self: *const TestConfig.DummyFieldsReader) i32 {
            return self._field_int32;
        }
        pub inline fn getFieldUint64(self: *const TestConfig.DummyFieldsReader) u64 {
            return self._field_uint64;
        }
        pub inline fn getFieldInt64(self: *const TestConfig.DummyFieldsReader) i64 {
            return self._field_int64;
        }
        pub inline fn getFieldFixed64(self: *const TestConfig.DummyFieldsReader) u64 {
            return self._field_fixed64;
        }
        pub inline fn getFieldSfixed64(self: *const TestConfig.DummyFieldsReader) i64 {
            return self._field_sfixed64;
        }
        pub inline fn getFieldFixed32(self: *const TestConfig.DummyFieldsReader) u32 {
            return self._field_fixed32;
        }
        pub inline fn getFieldSfixed32(self: *const TestConfig.DummyFieldsReader) i32 {
            return self._field_sfixed32;
        }
        pub inline fn getFieldDouble(self: *const TestConfig.DummyFieldsReader) f64 {
            return self._field_double;
        }
        pub inline fn getFieldFloat(self: *const TestConfig.DummyFieldsReader) f32 {
            return self._field_float;
        }
        pub inline fn getFieldSint64(self: *const TestConfig.DummyFieldsReader) i64 {
            return self._field_sint64;
        }
        pub inline fn getFieldSint32(self: *const TestConfig.DummyFieldsReader) i32 {
            return self._field_sint32;
        }
        pub inline fn getFieldString(self: *const TestConfig.DummyFieldsReader) []const u8 {
            return self._field_string orelse &[_]u8{};
        }
        pub inline fn getFieldBytes(self: *const TestConfig.DummyFieldsReader) []const u8 {
            return self._field_bytes orelse &[_]u8{};
        }
    };
    // fields
    message_count: u32 = 0,
    max_messages_per_second: u32 = 0,
    seed: u32 = 0,
    message_size: u32 = 0,
    send_batch_on_register: bool = false,
    dummy_fields: ?TestConfig.DummyFields = null,
    pub fn calcProtobufSize(self: *const TestConfig) usize {
        var res: usize = 0;
        if (self.message_count != 0) {
            res += gremlin.sizes.sizeWireNumber(TestConfigWire.MESSAGE_COUNT_WIRE) + gremlin.sizes.sizeU32(self.message_count);
        }
        if (self.max_messages_per_second != 0) {
            res += gremlin.sizes.sizeWireNumber(TestConfigWire.MAX_MESSAGES_PER_SECOND_WIRE) + gremlin.sizes.sizeU32(self.max_messages_per_second);
        }
        if (self.seed != 0) {
            res += gremlin.sizes.sizeWireNumber(TestConfigWire.SEED_WIRE) + gremlin.sizes.sizeU32(self.seed);
        }
        if (self.message_size != 0) {
            res += gremlin.sizes.sizeWireNumber(TestConfigWire.MESSAGE_SIZE_WIRE) + gremlin.sizes.sizeU32(self.message_size);
        }
        if (self.send_batch_on_register != false) {
            res += gremlin.sizes.sizeWireNumber(TestConfigWire.SEND_BATCH_ON_REGISTER_WIRE) + gremlin.sizes.sizeBool(self.send_batch_on_register);
        }
        if (self.dummy_fields) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TestConfigWire.DUMMY_FIELDS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const TestConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TestConfig, target: *gremlin.Writer) void {
        if (self.message_count != 0) {
            target.appendUint32(TestConfigWire.MESSAGE_COUNT_WIRE, self.message_count);
        }
        if (self.max_messages_per_second != 0) {
            target.appendUint32(TestConfigWire.MAX_MESSAGES_PER_SECOND_WIRE, self.max_messages_per_second);
        }
        if (self.seed != 0) {
            target.appendUint32(TestConfigWire.SEED_WIRE, self.seed);
        }
        if (self.message_size != 0) {
            target.appendUint32(TestConfigWire.MESSAGE_SIZE_WIRE, self.message_size);
        }
        if (self.send_batch_on_register != false) {
            target.appendBool(TestConfigWire.SEND_BATCH_ON_REGISTER_WIRE, self.send_batch_on_register);
        }
        if (self.dummy_fields) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TestConfigWire.DUMMY_FIELDS_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const TestConfigReader = struct {
    buf: gremlin.Reader,
    _message_count: u32 = 0,
    _max_messages_per_second: u32 = 0,
    _seed: u32 = 0,
    _message_size: u32 = 0,
    _send_batch_on_register: bool = false,
    _dummy_fields_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!TestConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = TestConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TestConfigWire.MESSAGE_COUNT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._message_count = result.value;
                },
                TestConfigWire.MAX_MESSAGES_PER_SECOND_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._max_messages_per_second = result.value;
                },
                TestConfigWire.SEED_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._seed = result.value;
                },
                TestConfigWire.MESSAGE_SIZE_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._message_size = result.value;
                },
                TestConfigWire.SEND_BATCH_ON_REGISTER_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._send_batch_on_register = result.value;
                },
                TestConfigWire.DUMMY_FIELDS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._dummy_fields_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getMessageCount(self: *const TestConfigReader) u32 {
        return self._message_count;
    }
    pub inline fn getMaxMessagesPerSecond(self: *const TestConfigReader) u32 {
        return self._max_messages_per_second;
    }
    pub inline fn getSeed(self: *const TestConfigReader) u32 {
        return self._seed;
    }
    pub inline fn getMessageSize(self: *const TestConfigReader) u32 {
        return self._message_size;
    }
    pub inline fn getSendBatchOnRegister(self: *const TestConfigReader) bool {
        return self._send_batch_on_register;
    }
    pub fn getDummyFields(self: *const TestConfigReader) gremlin.Error!TestConfig.DummyFieldsReader {
        if (self._dummy_fields_buf) |buf| {
            return try TestConfig.DummyFieldsReader.init(buf);
        }
        return try TestConfig.DummyFieldsReader.init(&[_]u8{});
    }
};
