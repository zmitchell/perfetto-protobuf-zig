// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
const perf_events = @import("src/gen/protos/perfetto/common/perf_events.proto.zig");
// structs
const PerfEventConfigWire = struct {
    const TIMEBASE_WIRE: gremlin.ProtoWireNumber = 15;
    const FOLLOWERS_WIRE: gremlin.ProtoWireNumber = 19;
    const CALLSTACK_SAMPLING_WIRE: gremlin.ProtoWireNumber = 16;
    const TARGET_CPU_WIRE: gremlin.ProtoWireNumber = 20;
    const RING_BUFFER_READ_PERIOD_MS_WIRE: gremlin.ProtoWireNumber = 8;
    const RING_BUFFER_PAGES_WIRE: gremlin.ProtoWireNumber = 3;
    const MAX_ENQUEUED_FOOTPRINT_KB_WIRE: gremlin.ProtoWireNumber = 17;
    const MAX_DAEMON_MEMORY_KB_WIRE: gremlin.ProtoWireNumber = 13;
    const REMOTE_DESCRIPTOR_TIMEOUT_MS_WIRE: gremlin.ProtoWireNumber = 9;
    const UNWIND_STATE_CLEAR_PERIOD_MS_WIRE: gremlin.ProtoWireNumber = 10;
    const TARGET_INSTALLED_BY_WIRE: gremlin.ProtoWireNumber = 18;
    const ALL_CPUS_WIRE: gremlin.ProtoWireNumber = 1;
    const SAMPLING_FREQUENCY_WIRE: gremlin.ProtoWireNumber = 2;
    const KERNEL_FRAMES_WIRE: gremlin.ProtoWireNumber = 12;
    const TARGET_PID_WIRE: gremlin.ProtoWireNumber = 4;
    const TARGET_CMDLINE_WIRE: gremlin.ProtoWireNumber = 5;
    const EXCLUDE_PID_WIRE: gremlin.ProtoWireNumber = 6;
    const EXCLUDE_CMDLINE_WIRE: gremlin.ProtoWireNumber = 7;
    const ADDITIONAL_CMDLINE_COUNT_WIRE: gremlin.ProtoWireNumber = 11;
};
pub const PerfEventConfig = struct {
    // nested enums
    pub const UnwindMode = enum(i32) {
        UNWIND_UNKNOWN = 0,
        UNWIND_SKIP = 1,
        UNWIND_DWARF = 2,
        UNWIND_FRAME_POINTER = 3,
    };
    // nested structs
    const CallstackSamplingWire = struct {
        const SCOPE_WIRE: gremlin.ProtoWireNumber = 1;
        const KERNEL_FRAMES_WIRE: gremlin.ProtoWireNumber = 2;
        const USER_FRAMES_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const CallstackSampling = struct {
        // fields
        scope: ?PerfEventConfig.Scope = null,
        kernel_frames: bool = false,
        user_frames: PerfEventConfig.UnwindMode = @enumFromInt(0),
        pub fn calcProtobufSize(self: *const PerfEventConfig.CallstackSampling) usize {
            var res: usize = 0;
            if (self.scope) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(PerfEventConfig.CallstackSamplingWire.SCOPE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.kernel_frames != false) {
                res += gremlin.sizes.sizeWireNumber(PerfEventConfig.CallstackSamplingWire.KERNEL_FRAMES_WIRE) + gremlin.sizes.sizeBool(self.kernel_frames);
            }
            if (@intFromEnum(self.user_frames) != 0) {
                res += gremlin.sizes.sizeWireNumber(PerfEventConfig.CallstackSamplingWire.USER_FRAMES_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.user_frames));
            }
            return res;
        }
        pub fn encode(self: *const PerfEventConfig.CallstackSampling, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const PerfEventConfig.CallstackSampling, target: *gremlin.Writer) void {
            if (self.scope) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(PerfEventConfig.CallstackSamplingWire.SCOPE_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.kernel_frames != false) {
                target.appendBool(PerfEventConfig.CallstackSamplingWire.KERNEL_FRAMES_WIRE, self.kernel_frames);
            }
            if (@intFromEnum(self.user_frames) != 0) {
                target.appendInt32(PerfEventConfig.CallstackSamplingWire.USER_FRAMES_WIRE, @intFromEnum(self.user_frames));
            }
        }
    };
    pub const CallstackSamplingReader = struct {
        buf: gremlin.Reader,
        _scope_buf: ?[]const u8 = null,
        _kernel_frames: bool = false,
        _user_frames: PerfEventConfig.UnwindMode = @enumFromInt(0),
        pub fn init(src: []const u8) gremlin.Error!PerfEventConfig.CallstackSamplingReader {
            const buf = gremlin.Reader.init(src);
            var res = PerfEventConfig.CallstackSamplingReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    PerfEventConfig.CallstackSamplingWire.SCOPE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._scope_buf = result.value;
                    },
                    PerfEventConfig.CallstackSamplingWire.KERNEL_FRAMES_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._kernel_frames = result.value;
                    },
                    PerfEventConfig.CallstackSamplingWire.USER_FRAMES_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._user_frames = @enumFromInt(result.value);
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn getScope(self: *const PerfEventConfig.CallstackSamplingReader) gremlin.Error!PerfEventConfig.ScopeReader {
            if (self._scope_buf) |buf| {
                return try PerfEventConfig.ScopeReader.init(buf);
            }
            return try PerfEventConfig.ScopeReader.init(&[_]u8{});
        }
        pub inline fn getKernelFrames(self: *const PerfEventConfig.CallstackSamplingReader) bool {
            return self._kernel_frames;
        }
        pub inline fn getUserFrames(self: *const PerfEventConfig.CallstackSamplingReader) PerfEventConfig.UnwindMode {
            return self._user_frames;
        }
    };
    const ScopeWire = struct {
        const TARGET_PID_WIRE: gremlin.ProtoWireNumber = 1;
        const TARGET_CMDLINE_WIRE: gremlin.ProtoWireNumber = 2;
        const EXCLUDE_PID_WIRE: gremlin.ProtoWireNumber = 3;
        const EXCLUDE_CMDLINE_WIRE: gremlin.ProtoWireNumber = 4;
        const ADDITIONAL_CMDLINE_COUNT_WIRE: gremlin.ProtoWireNumber = 5;
        const PROCESS_SHARD_COUNT_WIRE: gremlin.ProtoWireNumber = 6;
    };
    pub const Scope = struct {
        // fields
        target_pid: ?[]const i32 = null,
        target_cmdline: ?[]const ?[]const u8 = null,
        exclude_pid: ?[]const i32 = null,
        exclude_cmdline: ?[]const ?[]const u8 = null,
        additional_cmdline_count: u32 = 0,
        process_shard_count: u32 = 0,
        pub fn calcProtobufSize(self: *const PerfEventConfig.Scope) usize {
            var res: usize = 0;
            if (self.target_pid) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    res += gremlin.sizes.sizeWireNumber(PerfEventConfig.ScopeWire.TARGET_PID_WIRE) + gremlin.sizes.sizeI32(arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeI32(v);
                    }
                    res += gremlin.sizes.sizeWireNumber(PerfEventConfig.ScopeWire.TARGET_PID_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
                }
            }
            if (self.target_cmdline) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(PerfEventConfig.ScopeWire.TARGET_CMDLINE_WIRE);
                    if (maybe_v) |v| {
                        res += gremlin.sizes.sizeUsize(v.len) + v.len;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.exclude_pid) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    res += gremlin.sizes.sizeWireNumber(PerfEventConfig.ScopeWire.EXCLUDE_PID_WIRE) + gremlin.sizes.sizeI32(arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeI32(v);
                    }
                    res += gremlin.sizes.sizeWireNumber(PerfEventConfig.ScopeWire.EXCLUDE_PID_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
                }
            }
            if (self.exclude_cmdline) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(PerfEventConfig.ScopeWire.EXCLUDE_CMDLINE_WIRE);
                    if (maybe_v) |v| {
                        res += gremlin.sizes.sizeUsize(v.len) + v.len;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.additional_cmdline_count != 0) {
                res += gremlin.sizes.sizeWireNumber(PerfEventConfig.ScopeWire.ADDITIONAL_CMDLINE_COUNT_WIRE) + gremlin.sizes.sizeU32(self.additional_cmdline_count);
            }
            if (self.process_shard_count != 0) {
                res += gremlin.sizes.sizeWireNumber(PerfEventConfig.ScopeWire.PROCESS_SHARD_COUNT_WIRE) + gremlin.sizes.sizeU32(self.process_shard_count);
            }
            return res;
        }
        pub fn encode(self: *const PerfEventConfig.Scope, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const PerfEventConfig.Scope, target: *gremlin.Writer) void {
            if (self.target_pid) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    target.appendInt32(PerfEventConfig.ScopeWire.TARGET_PID_WIRE, arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeI32(v);
                    }
                    target.appendBytesTag(PerfEventConfig.ScopeWire.TARGET_PID_WIRE, packed_size);
                    for (arr) |v| {
                        target.appendInt32WithoutTag(v);
                    }
                }
            }
            if (self.target_cmdline) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        target.appendBytes(PerfEventConfig.ScopeWire.TARGET_CMDLINE_WIRE, v);
                    } else {
                        target.appendBytesTag(PerfEventConfig.ScopeWire.TARGET_CMDLINE_WIRE, 0);
                    }
                }
            }
            if (self.exclude_pid) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    target.appendInt32(PerfEventConfig.ScopeWire.EXCLUDE_PID_WIRE, arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeI32(v);
                    }
                    target.appendBytesTag(PerfEventConfig.ScopeWire.EXCLUDE_PID_WIRE, packed_size);
                    for (arr) |v| {
                        target.appendInt32WithoutTag(v);
                    }
                }
            }
            if (self.exclude_cmdline) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        target.appendBytes(PerfEventConfig.ScopeWire.EXCLUDE_CMDLINE_WIRE, v);
                    } else {
                        target.appendBytesTag(PerfEventConfig.ScopeWire.EXCLUDE_CMDLINE_WIRE, 0);
                    }
                }
            }
            if (self.additional_cmdline_count != 0) {
                target.appendUint32(PerfEventConfig.ScopeWire.ADDITIONAL_CMDLINE_COUNT_WIRE, self.additional_cmdline_count);
            }
            if (self.process_shard_count != 0) {
                target.appendUint32(PerfEventConfig.ScopeWire.PROCESS_SHARD_COUNT_WIRE, self.process_shard_count);
            }
        }
    };
    pub const ScopeReader = struct {
        buf: gremlin.Reader,
        _target_pid_offset: ?usize = null,
        _target_pid_last_offset: ?usize = null,
        _target_pid_packed: bool = false,
        _target_cmdline_offset: ?usize = null,
        _target_cmdline_last_offset: ?usize = null,
        _target_cmdline_cnt: usize = 0,
        _exclude_pid_offset: ?usize = null,
        _exclude_pid_last_offset: ?usize = null,
        _exclude_pid_packed: bool = false,
        _exclude_cmdline_offset: ?usize = null,
        _exclude_cmdline_last_offset: ?usize = null,
        _exclude_cmdline_cnt: usize = 0,
        _additional_cmdline_count: u32 = 0,
        _process_shard_count: u32 = 0,
        pub fn init(src: []const u8) gremlin.Error!PerfEventConfig.ScopeReader {
            const buf = gremlin.Reader.init(src);
            var res = PerfEventConfig.ScopeReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    PerfEventConfig.ScopeWire.TARGET_PID_WIRE => {
                        if (res._target_pid_offset == null) {
                            res._target_pid_offset = offset;
                        }
                        if (tag.wire == gremlin.ProtoWireType.bytes) {
                            res._target_pid_packed = true;
                            const length_result = try buf.readVarInt(offset);
                            res._target_pid_offset = offset + length_result.size;
                            res._target_pid_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                            offset = res._target_pid_last_offset.?;
                        } else {
                            const result = try buf.readInt32(offset);
                            offset += result.size;
                            res._target_pid_last_offset = offset;
                        }
                    },
                    PerfEventConfig.ScopeWire.TARGET_CMDLINE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._target_cmdline_offset == null) {
                            res._target_cmdline_offset = offset - result.size;
                        }
                        res._target_cmdline_last_offset = offset;
                        res._target_cmdline_cnt += 1;
                    },
                    PerfEventConfig.ScopeWire.EXCLUDE_PID_WIRE => {
                        if (res._exclude_pid_offset == null) {
                            res._exclude_pid_offset = offset;
                        }
                        if (tag.wire == gremlin.ProtoWireType.bytes) {
                            res._exclude_pid_packed = true;
                            const length_result = try buf.readVarInt(offset);
                            res._exclude_pid_offset = offset + length_result.size;
                            res._exclude_pid_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                            offset = res._exclude_pid_last_offset.?;
                        } else {
                            const result = try buf.readInt32(offset);
                            offset += result.size;
                            res._exclude_pid_last_offset = offset;
                        }
                    },
                    PerfEventConfig.ScopeWire.EXCLUDE_CMDLINE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._exclude_cmdline_offset == null) {
                            res._exclude_cmdline_offset = offset - result.size;
                        }
                        res._exclude_cmdline_last_offset = offset;
                        res._exclude_cmdline_cnt += 1;
                    },
                    PerfEventConfig.ScopeWire.ADDITIONAL_CMDLINE_COUNT_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._additional_cmdline_count = result.value;
                    },
                    PerfEventConfig.ScopeWire.PROCESS_SHARD_COUNT_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._process_shard_count = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn targetPidNext(self: *PerfEventConfig.ScopeReader) gremlin.Error!?i32 {
            if (self._target_pid_offset == null) return null;
            const current_offset = self._target_pid_offset.?;
            if (current_offset >= self._target_pid_last_offset.?) {
                self._target_pid_offset = null;
                return null;
            }
            if (self._target_pid_packed) {
                const value_result = try self.buf.readInt32(current_offset);
                self._target_pid_offset = current_offset + value_result.size;
                if (self._target_pid_offset.? >= self._target_pid_last_offset.?) {
                    self._target_pid_offset = null;
                }
                return value_result.value;
            } else {
                const value_result = try self.buf.readInt32(current_offset);
                var next_offset = current_offset + value_result.size;
                const max_offset = self._target_pid_last_offset.?;
                // Search for the next occurrence of this field
                while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                    const next_tag = try self.buf.readTagAt(next_offset);
                    next_offset += next_tag.size;
                    if (next_tag.number == PerfEventConfig.ScopeWire.TARGET_PID_WIRE) {
                        self._target_pid_offset = next_offset;
                        return value_result.value;
                    } else {
                        next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                    }
                }
                self._target_pid_offset = null;
                return value_result.value;
            }
        }
        pub fn targetCmdlineCount(self: *const PerfEventConfig.ScopeReader) usize {
            return self._target_cmdline_cnt;
        }
        pub fn targetCmdlineNext(self: *PerfEventConfig.ScopeReader) ?[]const u8 {
            if (self._target_cmdline_offset == null) return null;
            const current_offset = self._target_cmdline_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            if (self._target_cmdline_last_offset != null and current_offset >= self._target_cmdline_last_offset.?) {
                self._target_cmdline_offset = null;
                return result.value;
            }
            if (self._target_cmdline_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._target_cmdline_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == PerfEventConfig.ScopeWire.TARGET_CMDLINE_WIRE) {
                    self._target_cmdline_offset = next_offset;
                    return result.value;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._target_cmdline_offset = null;
            return result.value;
        }
        pub fn excludePidNext(self: *PerfEventConfig.ScopeReader) gremlin.Error!?i32 {
            if (self._exclude_pid_offset == null) return null;
            const current_offset = self._exclude_pid_offset.?;
            if (current_offset >= self._exclude_pid_last_offset.?) {
                self._exclude_pid_offset = null;
                return null;
            }
            if (self._exclude_pid_packed) {
                const value_result = try self.buf.readInt32(current_offset);
                self._exclude_pid_offset = current_offset + value_result.size;
                if (self._exclude_pid_offset.? >= self._exclude_pid_last_offset.?) {
                    self._exclude_pid_offset = null;
                }
                return value_result.value;
            } else {
                const value_result = try self.buf.readInt32(current_offset);
                var next_offset = current_offset + value_result.size;
                const max_offset = self._exclude_pid_last_offset.?;
                // Search for the next occurrence of this field
                while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                    const next_tag = try self.buf.readTagAt(next_offset);
                    next_offset += next_tag.size;
                    if (next_tag.number == PerfEventConfig.ScopeWire.EXCLUDE_PID_WIRE) {
                        self._exclude_pid_offset = next_offset;
                        return value_result.value;
                    } else {
                        next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                    }
                }
                self._exclude_pid_offset = null;
                return value_result.value;
            }
        }
        pub fn excludeCmdlineCount(self: *const PerfEventConfig.ScopeReader) usize {
            return self._exclude_cmdline_cnt;
        }
        pub fn excludeCmdlineNext(self: *PerfEventConfig.ScopeReader) ?[]const u8 {
            if (self._exclude_cmdline_offset == null) return null;
            const current_offset = self._exclude_cmdline_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            if (self._exclude_cmdline_last_offset != null and current_offset >= self._exclude_cmdline_last_offset.?) {
                self._exclude_cmdline_offset = null;
                return result.value;
            }
            if (self._exclude_cmdline_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._exclude_cmdline_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == PerfEventConfig.ScopeWire.EXCLUDE_CMDLINE_WIRE) {
                    self._exclude_cmdline_offset = next_offset;
                    return result.value;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._exclude_cmdline_offset = null;
            return result.value;
        }
        pub inline fn getAdditionalCmdlineCount(self: *const PerfEventConfig.ScopeReader) u32 {
            return self._additional_cmdline_count;
        }
        pub inline fn getProcessShardCount(self: *const PerfEventConfig.ScopeReader) u32 {
            return self._process_shard_count;
        }
    };
    // fields
    timebase: ?perf_events.PerfEvents.Timebase = null,
    followers: ?[]const ?perf_events.FollowerEvent = null,
    callstack_sampling: ?PerfEventConfig.CallstackSampling = null,
    target_cpu: ?[]const u32 = null,
    ring_buffer_read_period_ms: u32 = 0,
    ring_buffer_pages: u32 = 0,
    max_enqueued_footprint_kb: u64 = 0,
    max_daemon_memory_kb: u32 = 0,
    remote_descriptor_timeout_ms: u32 = 0,
    unwind_state_clear_period_ms: u32 = 0,
    target_installed_by: ?[]const ?[]const u8 = null,
    all_cpus: bool = false,
    sampling_frequency: u32 = 0,
    kernel_frames: bool = false,
    target_pid: ?[]const i32 = null,
    target_cmdline: ?[]const ?[]const u8 = null,
    exclude_pid: ?[]const i32 = null,
    exclude_cmdline: ?[]const ?[]const u8 = null,
    additional_cmdline_count: u32 = 0,
    pub fn calcProtobufSize(self: *const PerfEventConfig) usize {
        var res: usize = 0;
        if (self.timebase) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(PerfEventConfigWire.TIMEBASE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.followers) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(PerfEventConfigWire.FOLLOWERS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.callstack_sampling) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(PerfEventConfigWire.CALLSTACK_SAMPLING_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.target_cpu) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(PerfEventConfigWire.TARGET_CPU_WIRE) + gremlin.sizes.sizeU32(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU32(v);
                }
                res += gremlin.sizes.sizeWireNumber(PerfEventConfigWire.TARGET_CPU_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.ring_buffer_read_period_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(PerfEventConfigWire.RING_BUFFER_READ_PERIOD_MS_WIRE) + gremlin.sizes.sizeU32(self.ring_buffer_read_period_ms);
        }
        if (self.ring_buffer_pages != 0) {
            res += gremlin.sizes.sizeWireNumber(PerfEventConfigWire.RING_BUFFER_PAGES_WIRE) + gremlin.sizes.sizeU32(self.ring_buffer_pages);
        }
        if (self.max_enqueued_footprint_kb != 0) {
            res += gremlin.sizes.sizeWireNumber(PerfEventConfigWire.MAX_ENQUEUED_FOOTPRINT_KB_WIRE) + gremlin.sizes.sizeU64(self.max_enqueued_footprint_kb);
        }
        if (self.max_daemon_memory_kb != 0) {
            res += gremlin.sizes.sizeWireNumber(PerfEventConfigWire.MAX_DAEMON_MEMORY_KB_WIRE) + gremlin.sizes.sizeU32(self.max_daemon_memory_kb);
        }
        if (self.remote_descriptor_timeout_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(PerfEventConfigWire.REMOTE_DESCRIPTOR_TIMEOUT_MS_WIRE) + gremlin.sizes.sizeU32(self.remote_descriptor_timeout_ms);
        }
        if (self.unwind_state_clear_period_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(PerfEventConfigWire.UNWIND_STATE_CLEAR_PERIOD_MS_WIRE) + gremlin.sizes.sizeU32(self.unwind_state_clear_period_ms);
        }
        if (self.target_installed_by) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(PerfEventConfigWire.TARGET_INSTALLED_BY_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.all_cpus != false) {
            res += gremlin.sizes.sizeWireNumber(PerfEventConfigWire.ALL_CPUS_WIRE) + gremlin.sizes.sizeBool(self.all_cpus);
        }
        if (self.sampling_frequency != 0) {
            res += gremlin.sizes.sizeWireNumber(PerfEventConfigWire.SAMPLING_FREQUENCY_WIRE) + gremlin.sizes.sizeU32(self.sampling_frequency);
        }
        if (self.kernel_frames != false) {
            res += gremlin.sizes.sizeWireNumber(PerfEventConfigWire.KERNEL_FRAMES_WIRE) + gremlin.sizes.sizeBool(self.kernel_frames);
        }
        if (self.target_pid) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(PerfEventConfigWire.TARGET_PID_WIRE) + gremlin.sizes.sizeI32(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(v);
                }
                res += gremlin.sizes.sizeWireNumber(PerfEventConfigWire.TARGET_PID_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.target_cmdline) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(PerfEventConfigWire.TARGET_CMDLINE_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.exclude_pid) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(PerfEventConfigWire.EXCLUDE_PID_WIRE) + gremlin.sizes.sizeI32(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(v);
                }
                res += gremlin.sizes.sizeWireNumber(PerfEventConfigWire.EXCLUDE_PID_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.exclude_cmdline) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(PerfEventConfigWire.EXCLUDE_CMDLINE_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.additional_cmdline_count != 0) {
            res += gremlin.sizes.sizeWireNumber(PerfEventConfigWire.ADDITIONAL_CMDLINE_COUNT_WIRE) + gremlin.sizes.sizeU32(self.additional_cmdline_count);
        }
        return res;
    }
    pub fn encode(self: *const PerfEventConfig, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const PerfEventConfig, target: *gremlin.Writer) void {
        if (self.timebase) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(PerfEventConfigWire.TIMEBASE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.followers) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(PerfEventConfigWire.FOLLOWERS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(PerfEventConfigWire.FOLLOWERS_WIRE, 0);
                }
            }
        }
        if (self.callstack_sampling) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(PerfEventConfigWire.CALLSTACK_SAMPLING_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.target_cpu) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint32(PerfEventConfigWire.TARGET_CPU_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU32(v);
                }
                target.appendBytesTag(PerfEventConfigWire.TARGET_CPU_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint32WithoutTag(v);
                }
            }
        }
        if (self.ring_buffer_read_period_ms != 0) {
            target.appendUint32(PerfEventConfigWire.RING_BUFFER_READ_PERIOD_MS_WIRE, self.ring_buffer_read_period_ms);
        }
        if (self.ring_buffer_pages != 0) {
            target.appendUint32(PerfEventConfigWire.RING_BUFFER_PAGES_WIRE, self.ring_buffer_pages);
        }
        if (self.max_enqueued_footprint_kb != 0) {
            target.appendUint64(PerfEventConfigWire.MAX_ENQUEUED_FOOTPRINT_KB_WIRE, self.max_enqueued_footprint_kb);
        }
        if (self.max_daemon_memory_kb != 0) {
            target.appendUint32(PerfEventConfigWire.MAX_DAEMON_MEMORY_KB_WIRE, self.max_daemon_memory_kb);
        }
        if (self.remote_descriptor_timeout_ms != 0) {
            target.appendUint32(PerfEventConfigWire.REMOTE_DESCRIPTOR_TIMEOUT_MS_WIRE, self.remote_descriptor_timeout_ms);
        }
        if (self.unwind_state_clear_period_ms != 0) {
            target.appendUint32(PerfEventConfigWire.UNWIND_STATE_CLEAR_PERIOD_MS_WIRE, self.unwind_state_clear_period_ms);
        }
        if (self.target_installed_by) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(PerfEventConfigWire.TARGET_INSTALLED_BY_WIRE, v);
                } else {
                    target.appendBytesTag(PerfEventConfigWire.TARGET_INSTALLED_BY_WIRE, 0);
                }
            }
        }
        if (self.all_cpus != false) {
            target.appendBool(PerfEventConfigWire.ALL_CPUS_WIRE, self.all_cpus);
        }
        if (self.sampling_frequency != 0) {
            target.appendUint32(PerfEventConfigWire.SAMPLING_FREQUENCY_WIRE, self.sampling_frequency);
        }
        if (self.kernel_frames != false) {
            target.appendBool(PerfEventConfigWire.KERNEL_FRAMES_WIRE, self.kernel_frames);
        }
        if (self.target_pid) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt32(PerfEventConfigWire.TARGET_PID_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(v);
                }
                target.appendBytesTag(PerfEventConfigWire.TARGET_PID_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt32WithoutTag(v);
                }
            }
        }
        if (self.target_cmdline) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(PerfEventConfigWire.TARGET_CMDLINE_WIRE, v);
                } else {
                    target.appendBytesTag(PerfEventConfigWire.TARGET_CMDLINE_WIRE, 0);
                }
            }
        }
        if (self.exclude_pid) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt32(PerfEventConfigWire.EXCLUDE_PID_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(v);
                }
                target.appendBytesTag(PerfEventConfigWire.EXCLUDE_PID_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt32WithoutTag(v);
                }
            }
        }
        if (self.exclude_cmdline) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(PerfEventConfigWire.EXCLUDE_CMDLINE_WIRE, v);
                } else {
                    target.appendBytesTag(PerfEventConfigWire.EXCLUDE_CMDLINE_WIRE, 0);
                }
            }
        }
        if (self.additional_cmdline_count != 0) {
            target.appendUint32(PerfEventConfigWire.ADDITIONAL_CMDLINE_COUNT_WIRE, self.additional_cmdline_count);
        }
    }
};
pub const PerfEventConfigReader = struct {
    buf: gremlin.Reader,
    _timebase_buf: ?[]const u8 = null,
    _followers_offset: ?usize = null,
    _followers_last_offset: ?usize = null,
    _followers_cnt: usize = 0,
    _callstack_sampling_buf: ?[]const u8 = null,
    _target_cpu_offset: ?usize = null,
    _target_cpu_last_offset: ?usize = null,
    _target_cpu_packed: bool = false,
    _ring_buffer_read_period_ms: u32 = 0,
    _ring_buffer_pages: u32 = 0,
    _max_enqueued_footprint_kb: u64 = 0,
    _max_daemon_memory_kb: u32 = 0,
    _remote_descriptor_timeout_ms: u32 = 0,
    _unwind_state_clear_period_ms: u32 = 0,
    _target_installed_by_offset: ?usize = null,
    _target_installed_by_last_offset: ?usize = null,
    _target_installed_by_cnt: usize = 0,
    _all_cpus: bool = false,
    _sampling_frequency: u32 = 0,
    _kernel_frames: bool = false,
    _target_pid_offset: ?usize = null,
    _target_pid_last_offset: ?usize = null,
    _target_pid_packed: bool = false,
    _target_cmdline_offset: ?usize = null,
    _target_cmdline_last_offset: ?usize = null,
    _target_cmdline_cnt: usize = 0,
    _exclude_pid_offset: ?usize = null,
    _exclude_pid_last_offset: ?usize = null,
    _exclude_pid_packed: bool = false,
    _exclude_cmdline_offset: ?usize = null,
    _exclude_cmdline_last_offset: ?usize = null,
    _exclude_cmdline_cnt: usize = 0,
    _additional_cmdline_count: u32 = 0,
    pub fn init(src: []const u8) gremlin.Error!PerfEventConfigReader {
        const buf = gremlin.Reader.init(src);
        var res = PerfEventConfigReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                PerfEventConfigWire.TIMEBASE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._timebase_buf = result.value;
                },
                PerfEventConfigWire.FOLLOWERS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._followers_offset == null) {
                        res._followers_offset = offset - result.size;
                    }
                    res._followers_last_offset = offset;
                    res._followers_cnt += 1;
                },
                PerfEventConfigWire.CALLSTACK_SAMPLING_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._callstack_sampling_buf = result.value;
                },
                PerfEventConfigWire.TARGET_CPU_WIRE => {
                    if (res._target_cpu_offset == null) {
                        res._target_cpu_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._target_cpu_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._target_cpu_offset = offset + length_result.size;
                        res._target_cpu_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._target_cpu_last_offset.?;
                    } else {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._target_cpu_last_offset = offset;
                    }
                },
                PerfEventConfigWire.RING_BUFFER_READ_PERIOD_MS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._ring_buffer_read_period_ms = result.value;
                },
                PerfEventConfigWire.RING_BUFFER_PAGES_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._ring_buffer_pages = result.value;
                },
                PerfEventConfigWire.MAX_ENQUEUED_FOOTPRINT_KB_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._max_enqueued_footprint_kb = result.value;
                },
                PerfEventConfigWire.MAX_DAEMON_MEMORY_KB_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._max_daemon_memory_kb = result.value;
                },
                PerfEventConfigWire.REMOTE_DESCRIPTOR_TIMEOUT_MS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._remote_descriptor_timeout_ms = result.value;
                },
                PerfEventConfigWire.UNWIND_STATE_CLEAR_PERIOD_MS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._unwind_state_clear_period_ms = result.value;
                },
                PerfEventConfigWire.TARGET_INSTALLED_BY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._target_installed_by_offset == null) {
                        res._target_installed_by_offset = offset - result.size;
                    }
                    res._target_installed_by_last_offset = offset;
                    res._target_installed_by_cnt += 1;
                },
                PerfEventConfigWire.ALL_CPUS_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._all_cpus = result.value;
                },
                PerfEventConfigWire.SAMPLING_FREQUENCY_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._sampling_frequency = result.value;
                },
                PerfEventConfigWire.KERNEL_FRAMES_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._kernel_frames = result.value;
                },
                PerfEventConfigWire.TARGET_PID_WIRE => {
                    if (res._target_pid_offset == null) {
                        res._target_pid_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._target_pid_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._target_pid_offset = offset + length_result.size;
                        res._target_pid_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._target_pid_last_offset.?;
                    } else {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._target_pid_last_offset = offset;
                    }
                },
                PerfEventConfigWire.TARGET_CMDLINE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._target_cmdline_offset == null) {
                        res._target_cmdline_offset = offset - result.size;
                    }
                    res._target_cmdline_last_offset = offset;
                    res._target_cmdline_cnt += 1;
                },
                PerfEventConfigWire.EXCLUDE_PID_WIRE => {
                    if (res._exclude_pid_offset == null) {
                        res._exclude_pid_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._exclude_pid_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._exclude_pid_offset = offset + length_result.size;
                        res._exclude_pid_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._exclude_pid_last_offset.?;
                    } else {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._exclude_pid_last_offset = offset;
                    }
                },
                PerfEventConfigWire.EXCLUDE_CMDLINE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._exclude_cmdline_offset == null) {
                        res._exclude_cmdline_offset = offset - result.size;
                    }
                    res._exclude_cmdline_last_offset = offset;
                    res._exclude_cmdline_cnt += 1;
                },
                PerfEventConfigWire.ADDITIONAL_CMDLINE_COUNT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._additional_cmdline_count = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getTimebase(self: *const PerfEventConfigReader) gremlin.Error!perf_events.PerfEvents.TimebaseReader {
        if (self._timebase_buf) |buf| {
            return try perf_events.PerfEvents.TimebaseReader.init(buf);
        }
        return try perf_events.PerfEvents.TimebaseReader.init(&[_]u8{});
    }
    pub fn followersCount(self: *const PerfEventConfigReader) usize {
        return self._followers_cnt;
    }
    pub fn followersNext(self: *PerfEventConfigReader) ?perf_events.FollowerEventReader {
        if (self._followers_offset == null) return null;
        const current_offset = self._followers_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = perf_events.FollowerEventReader.init(result.value) catch return null;
        if (self._followers_last_offset != null and current_offset >= self._followers_last_offset.?) {
            self._followers_offset = null;
            return msg;
        }
        if (self._followers_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._followers_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == PerfEventConfigWire.FOLLOWERS_WIRE) {
                self._followers_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._followers_offset = null;
        return msg;
    }
    pub fn getCallstackSampling(self: *const PerfEventConfigReader) gremlin.Error!PerfEventConfig.CallstackSamplingReader {
        if (self._callstack_sampling_buf) |buf| {
            return try PerfEventConfig.CallstackSamplingReader.init(buf);
        }
        return try PerfEventConfig.CallstackSamplingReader.init(&[_]u8{});
    }
    pub fn targetCpuNext(self: *PerfEventConfigReader) gremlin.Error!?u32 {
        if (self._target_cpu_offset == null) return null;
        const current_offset = self._target_cpu_offset.?;
        if (current_offset >= self._target_cpu_last_offset.?) {
            self._target_cpu_offset = null;
            return null;
        }
        if (self._target_cpu_packed) {
            const value_result = try self.buf.readUInt32(current_offset);
            self._target_cpu_offset = current_offset + value_result.size;
            if (self._target_cpu_offset.? >= self._target_cpu_last_offset.?) {
                self._target_cpu_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._target_cpu_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == PerfEventConfigWire.TARGET_CPU_WIRE) {
                    self._target_cpu_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._target_cpu_offset = null;
            return value_result.value;
        }
    }
    pub inline fn getRingBufferReadPeriodMs(self: *const PerfEventConfigReader) u32 {
        return self._ring_buffer_read_period_ms;
    }
    pub inline fn getRingBufferPages(self: *const PerfEventConfigReader) u32 {
        return self._ring_buffer_pages;
    }
    pub inline fn getMaxEnqueuedFootprintKb(self: *const PerfEventConfigReader) u64 {
        return self._max_enqueued_footprint_kb;
    }
    pub inline fn getMaxDaemonMemoryKb(self: *const PerfEventConfigReader) u32 {
        return self._max_daemon_memory_kb;
    }
    pub inline fn getRemoteDescriptorTimeoutMs(self: *const PerfEventConfigReader) u32 {
        return self._remote_descriptor_timeout_ms;
    }
    pub inline fn getUnwindStateClearPeriodMs(self: *const PerfEventConfigReader) u32 {
        return self._unwind_state_clear_period_ms;
    }
    pub fn targetInstalledByCount(self: *const PerfEventConfigReader) usize {
        return self._target_installed_by_cnt;
    }
    pub fn targetInstalledByNext(self: *PerfEventConfigReader) ?[]const u8 {
        if (self._target_installed_by_offset == null) return null;
        const current_offset = self._target_installed_by_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._target_installed_by_last_offset != null and current_offset >= self._target_installed_by_last_offset.?) {
            self._target_installed_by_offset = null;
            return result.value;
        }
        if (self._target_installed_by_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._target_installed_by_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == PerfEventConfigWire.TARGET_INSTALLED_BY_WIRE) {
                self._target_installed_by_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._target_installed_by_offset = null;
        return result.value;
    }
    pub inline fn getAllCpus(self: *const PerfEventConfigReader) bool {
        return self._all_cpus;
    }
    pub inline fn getSamplingFrequency(self: *const PerfEventConfigReader) u32 {
        return self._sampling_frequency;
    }
    pub inline fn getKernelFrames(self: *const PerfEventConfigReader) bool {
        return self._kernel_frames;
    }
    pub fn targetPidNext(self: *PerfEventConfigReader) gremlin.Error!?i32 {
        if (self._target_pid_offset == null) return null;
        const current_offset = self._target_pid_offset.?;
        if (current_offset >= self._target_pid_last_offset.?) {
            self._target_pid_offset = null;
            return null;
        }
        if (self._target_pid_packed) {
            const value_result = try self.buf.readInt32(current_offset);
            self._target_pid_offset = current_offset + value_result.size;
            if (self._target_pid_offset.? >= self._target_pid_last_offset.?) {
                self._target_pid_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._target_pid_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == PerfEventConfigWire.TARGET_PID_WIRE) {
                    self._target_pid_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._target_pid_offset = null;
            return value_result.value;
        }
    }
    pub fn targetCmdlineCount(self: *const PerfEventConfigReader) usize {
        return self._target_cmdline_cnt;
    }
    pub fn targetCmdlineNext(self: *PerfEventConfigReader) ?[]const u8 {
        if (self._target_cmdline_offset == null) return null;
        const current_offset = self._target_cmdline_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._target_cmdline_last_offset != null and current_offset >= self._target_cmdline_last_offset.?) {
            self._target_cmdline_offset = null;
            return result.value;
        }
        if (self._target_cmdline_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._target_cmdline_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == PerfEventConfigWire.TARGET_CMDLINE_WIRE) {
                self._target_cmdline_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._target_cmdline_offset = null;
        return result.value;
    }
    pub fn excludePidNext(self: *PerfEventConfigReader) gremlin.Error!?i32 {
        if (self._exclude_pid_offset == null) return null;
        const current_offset = self._exclude_pid_offset.?;
        if (current_offset >= self._exclude_pid_last_offset.?) {
            self._exclude_pid_offset = null;
            return null;
        }
        if (self._exclude_pid_packed) {
            const value_result = try self.buf.readInt32(current_offset);
            self._exclude_pid_offset = current_offset + value_result.size;
            if (self._exclude_pid_offset.? >= self._exclude_pid_last_offset.?) {
                self._exclude_pid_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._exclude_pid_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == PerfEventConfigWire.EXCLUDE_PID_WIRE) {
                    self._exclude_pid_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._exclude_pid_offset = null;
            return value_result.value;
        }
    }
    pub fn excludeCmdlineCount(self: *const PerfEventConfigReader) usize {
        return self._exclude_cmdline_cnt;
    }
    pub fn excludeCmdlineNext(self: *PerfEventConfigReader) ?[]const u8 {
        if (self._exclude_cmdline_offset == null) return null;
        const current_offset = self._exclude_cmdline_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._exclude_cmdline_last_offset != null and current_offset >= self._exclude_cmdline_last_offset.?) {
            self._exclude_cmdline_offset = null;
            return result.value;
        }
        if (self._exclude_cmdline_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._exclude_cmdline_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == PerfEventConfigWire.EXCLUDE_CMDLINE_WIRE) {
                self._exclude_cmdline_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._exclude_cmdline_offset = null;
        return result.value;
    }
    pub inline fn getAdditionalCmdlineCount(self: *const PerfEventConfigReader) u32 {
        return self._additional_cmdline_count;
    }
};
