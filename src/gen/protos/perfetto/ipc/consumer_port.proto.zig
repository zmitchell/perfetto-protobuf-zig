// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
const trace_config = @import("src/gen/protos/perfetto/config/trace_config.proto.zig");
const trace_stats = @import("src/gen/protos/perfetto/common/trace_stats.proto.zig");
const observable_events = @import("src/gen/protos/perfetto/common/observable_events.proto.zig");
const tracing_service_state = @import("src/gen/protos/perfetto/common/tracing_service_state.proto.zig");
const tracing_service_capabilities = @import("src/gen/protos/perfetto/common/tracing_service_capabilities.proto.zig");
// structs
const EnableTracingRequestWire = struct {
    const TRACE_CONFIG_WIRE: gremlin.ProtoWireNumber = 1;
    const ATTACH_NOTIFICATION_ONLY_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const EnableTracingRequest = struct {
    // fields
    trace_config: ?trace_config.TraceConfig = null,
    attach_notification_only: bool = false,
    pub fn calcProtobufSize(self: *const EnableTracingRequest) usize {
        var res: usize = 0;
        if (self.trace_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(EnableTracingRequestWire.TRACE_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.attach_notification_only != false) {
            res += gremlin.sizes.sizeWireNumber(EnableTracingRequestWire.ATTACH_NOTIFICATION_ONLY_WIRE) + gremlin.sizes.sizeBool(self.attach_notification_only);
        }
        return res;
    }
    pub fn encode(self: *const EnableTracingRequest, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const EnableTracingRequest, target: *gremlin.Writer) void {
        if (self.trace_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(EnableTracingRequestWire.TRACE_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.attach_notification_only != false) {
            target.appendBool(EnableTracingRequestWire.ATTACH_NOTIFICATION_ONLY_WIRE, self.attach_notification_only);
        }
    }
};
pub const EnableTracingRequestReader = struct {
    buf: gremlin.Reader,
    _trace_config_buf: ?[]const u8 = null,
    _attach_notification_only: bool = false,
    pub fn init(src: []const u8) gremlin.Error!EnableTracingRequestReader {
        const buf = gremlin.Reader.init(src);
        var res = EnableTracingRequestReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                EnableTracingRequestWire.TRACE_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._trace_config_buf = result.value;
                },
                EnableTracingRequestWire.ATTACH_NOTIFICATION_ONLY_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._attach_notification_only = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getTraceConfig(self: *const EnableTracingRequestReader) gremlin.Error!trace_config.TraceConfigReader {
        if (self._trace_config_buf) |buf| {
            return try trace_config.TraceConfigReader.init(buf);
        }
        return try trace_config.TraceConfigReader.init(&[_]u8{});
    }
    pub inline fn getAttachNotificationOnly(self: *const EnableTracingRequestReader) bool {
        return self._attach_notification_only;
    }
};
const EnableTracingResponseWire = struct {
    const ERROR_WIRE: gremlin.ProtoWireNumber = 3;
    const DISABLED_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const EnableTracingResponse = struct {
    // fields
    error_: ?[]const u8 = null,
    disabled: bool = false,
    pub fn calcProtobufSize(self: *const EnableTracingResponse) usize {
        var res: usize = 0;
        if (self.error_) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(EnableTracingResponseWire.ERROR_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.disabled != false) {
            res += gremlin.sizes.sizeWireNumber(EnableTracingResponseWire.DISABLED_WIRE) + gremlin.sizes.sizeBool(self.disabled);
        }
        return res;
    }
    pub fn encode(self: *const EnableTracingResponse, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const EnableTracingResponse, target: *gremlin.Writer) void {
        if (self.error_) |v| {
            if (v.len > 0) {
                target.appendBytes(EnableTracingResponseWire.ERROR_WIRE, v);
            }
        }
        if (self.disabled != false) {
            target.appendBool(EnableTracingResponseWire.DISABLED_WIRE, self.disabled);
        }
    }
};
pub const EnableTracingResponseReader = struct {
    buf: gremlin.Reader,
    _error_: ?[]const u8 = null,
    _disabled: bool = false,
    pub fn init(src: []const u8) gremlin.Error!EnableTracingResponseReader {
        const buf = gremlin.Reader.init(src);
        var res = EnableTracingResponseReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                EnableTracingResponseWire.ERROR_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._error_ = result.value;
                },
                EnableTracingResponseWire.DISABLED_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._disabled = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getError(self: *const EnableTracingResponseReader) []const u8 {
        return self._error_ orelse &[_]u8{};
    }
    pub inline fn getDisabled(self: *const EnableTracingResponseReader) bool {
        return self._disabled;
    }
};
pub const StartTracingRequest = struct {
    pub fn calcProtobufSize(_: *const StartTracingRequest) usize {
        return 0;
    }
    pub fn encode(self: *const StartTracingRequest, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(_: *const StartTracingRequest, _: *gremlin.Writer) void {}
};
pub const StartTracingRequestReader = struct {
    buf: gremlin.Reader,
    pub fn init(src: []const u8) gremlin.Error!StartTracingRequestReader {
        const buf = gremlin.Reader.init(src);
        return StartTracingRequestReader{ .buf = buf };
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
};
pub const StartTracingResponse = struct {
    pub fn calcProtobufSize(_: *const StartTracingResponse) usize {
        return 0;
    }
    pub fn encode(self: *const StartTracingResponse, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(_: *const StartTracingResponse, _: *gremlin.Writer) void {}
};
pub const StartTracingResponseReader = struct {
    buf: gremlin.Reader,
    pub fn init(src: []const u8) gremlin.Error!StartTracingResponseReader {
        const buf = gremlin.Reader.init(src);
        return StartTracingResponseReader{ .buf = buf };
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
};
const ChangeTraceConfigRequestWire = struct {
    const TRACE_CONFIG_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const ChangeTraceConfigRequest = struct {
    // fields
    trace_config: ?trace_config.TraceConfig = null,
    pub fn calcProtobufSize(self: *const ChangeTraceConfigRequest) usize {
        var res: usize = 0;
        if (self.trace_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ChangeTraceConfigRequestWire.TRACE_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const ChangeTraceConfigRequest, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ChangeTraceConfigRequest, target: *gremlin.Writer) void {
        if (self.trace_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ChangeTraceConfigRequestWire.TRACE_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const ChangeTraceConfigRequestReader = struct {
    buf: gremlin.Reader,
    _trace_config_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!ChangeTraceConfigRequestReader {
        const buf = gremlin.Reader.init(src);
        var res = ChangeTraceConfigRequestReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ChangeTraceConfigRequestWire.TRACE_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._trace_config_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getTraceConfig(self: *const ChangeTraceConfigRequestReader) gremlin.Error!trace_config.TraceConfigReader {
        if (self._trace_config_buf) |buf| {
            return try trace_config.TraceConfigReader.init(buf);
        }
        return try trace_config.TraceConfigReader.init(&[_]u8{});
    }
};
pub const ChangeTraceConfigResponse = struct {
    pub fn calcProtobufSize(_: *const ChangeTraceConfigResponse) usize {
        return 0;
    }
    pub fn encode(self: *const ChangeTraceConfigResponse, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(_: *const ChangeTraceConfigResponse, _: *gremlin.Writer) void {}
};
pub const ChangeTraceConfigResponseReader = struct {
    buf: gremlin.Reader,
    pub fn init(src: []const u8) gremlin.Error!ChangeTraceConfigResponseReader {
        const buf = gremlin.Reader.init(src);
        return ChangeTraceConfigResponseReader{ .buf = buf };
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
};
pub const DisableTracingRequest = struct {
    pub fn calcProtobufSize(_: *const DisableTracingRequest) usize {
        return 0;
    }
    pub fn encode(self: *const DisableTracingRequest, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(_: *const DisableTracingRequest, _: *gremlin.Writer) void {}
};
pub const DisableTracingRequestReader = struct {
    buf: gremlin.Reader,
    pub fn init(src: []const u8) gremlin.Error!DisableTracingRequestReader {
        const buf = gremlin.Reader.init(src);
        return DisableTracingRequestReader{ .buf = buf };
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
};
pub const DisableTracingResponse = struct {
    pub fn calcProtobufSize(_: *const DisableTracingResponse) usize {
        return 0;
    }
    pub fn encode(self: *const DisableTracingResponse, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(_: *const DisableTracingResponse, _: *gremlin.Writer) void {}
};
pub const DisableTracingResponseReader = struct {
    buf: gremlin.Reader,
    pub fn init(src: []const u8) gremlin.Error!DisableTracingResponseReader {
        const buf = gremlin.Reader.init(src);
        return DisableTracingResponseReader{ .buf = buf };
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
};
pub const ReadBuffersRequest = struct {
    pub fn calcProtobufSize(_: *const ReadBuffersRequest) usize {
        return 0;
    }
    pub fn encode(self: *const ReadBuffersRequest, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(_: *const ReadBuffersRequest, _: *gremlin.Writer) void {}
};
pub const ReadBuffersRequestReader = struct {
    buf: gremlin.Reader,
    pub fn init(src: []const u8) gremlin.Error!ReadBuffersRequestReader {
        const buf = gremlin.Reader.init(src);
        return ReadBuffersRequestReader{ .buf = buf };
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
};
const ReadBuffersResponseWire = struct {
    const SLICES_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const ReadBuffersResponse = struct {
    // nested structs
    const SliceWire = struct {
        const DATA_WIRE: gremlin.ProtoWireNumber = 1;
        const LAST_SLICE_FOR_PACKET_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const Slice = struct {
        // fields
        data: ?[]const u8 = null,
        last_slice_for_packet: bool = false,
        pub fn calcProtobufSize(self: *const ReadBuffersResponse.Slice) usize {
            var res: usize = 0;
            if (self.data) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(ReadBuffersResponse.SliceWire.DATA_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.last_slice_for_packet != false) {
                res += gremlin.sizes.sizeWireNumber(ReadBuffersResponse.SliceWire.LAST_SLICE_FOR_PACKET_WIRE) + gremlin.sizes.sizeBool(self.last_slice_for_packet);
            }
            return res;
        }
        pub fn encode(self: *const ReadBuffersResponse.Slice, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const ReadBuffersResponse.Slice, target: *gremlin.Writer) void {
            if (self.data) |v| {
                if (v.len > 0) {
                    target.appendBytes(ReadBuffersResponse.SliceWire.DATA_WIRE, v);
                }
            }
            if (self.last_slice_for_packet != false) {
                target.appendBool(ReadBuffersResponse.SliceWire.LAST_SLICE_FOR_PACKET_WIRE, self.last_slice_for_packet);
            }
        }
    };
    pub const SliceReader = struct {
        buf: gremlin.Reader,
        _data: ?[]const u8 = null,
        _last_slice_for_packet: bool = false,
        pub fn init(src: []const u8) gremlin.Error!ReadBuffersResponse.SliceReader {
            const buf = gremlin.Reader.init(src);
            var res = ReadBuffersResponse.SliceReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    ReadBuffersResponse.SliceWire.DATA_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._data = result.value;
                    },
                    ReadBuffersResponse.SliceWire.LAST_SLICE_FOR_PACKET_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._last_slice_for_packet = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getData(self: *const ReadBuffersResponse.SliceReader) []const u8 {
            return self._data orelse &[_]u8{};
        }
        pub inline fn getLastSliceForPacket(self: *const ReadBuffersResponse.SliceReader) bool {
            return self._last_slice_for_packet;
        }
    };
    // fields
    slices: ?[]const ?ReadBuffersResponse.Slice = null,
    pub fn calcProtobufSize(self: *const ReadBuffersResponse) usize {
        var res: usize = 0;
        if (self.slices) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ReadBuffersResponseWire.SLICES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const ReadBuffersResponse, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ReadBuffersResponse, target: *gremlin.Writer) void {
        if (self.slices) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(ReadBuffersResponseWire.SLICES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(ReadBuffersResponseWire.SLICES_WIRE, 0);
                }
            }
        }
    }
};
pub const ReadBuffersResponseReader = struct {
    buf: gremlin.Reader,
    _slices_offset: ?usize = null,
    _slices_last_offset: ?usize = null,
    _slices_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!ReadBuffersResponseReader {
        const buf = gremlin.Reader.init(src);
        var res = ReadBuffersResponseReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ReadBuffersResponseWire.SLICES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._slices_offset == null) {
                        res._slices_offset = offset - result.size;
                    }
                    res._slices_last_offset = offset;
                    res._slices_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn slicesCount(self: *const ReadBuffersResponseReader) usize {
        return self._slices_cnt;
    }
    pub fn slicesNext(self: *ReadBuffersResponseReader) ?ReadBuffersResponse.SliceReader {
        if (self._slices_offset == null) return null;
        const current_offset = self._slices_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = ReadBuffersResponse.SliceReader.init(result.value) catch return null;
        if (self._slices_last_offset != null and current_offset >= self._slices_last_offset.?) {
            self._slices_offset = null;
            return msg;
        }
        if (self._slices_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._slices_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ReadBuffersResponseWire.SLICES_WIRE) {
                self._slices_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._slices_offset = null;
        return msg;
    }
};
const FreeBuffersRequestWire = struct {
    const BUFFER_IDS_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const FreeBuffersRequest = struct {
    // fields
    buffer_ids: ?[]const u32 = null,
    pub fn calcProtobufSize(self: *const FreeBuffersRequest) usize {
        var res: usize = 0;
        if (self.buffer_ids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(FreeBuffersRequestWire.BUFFER_IDS_WIRE) + gremlin.sizes.sizeU32(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU32(v);
                }
                res += gremlin.sizes.sizeWireNumber(FreeBuffersRequestWire.BUFFER_IDS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        return res;
    }
    pub fn encode(self: *const FreeBuffersRequest, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const FreeBuffersRequest, target: *gremlin.Writer) void {
        if (self.buffer_ids) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint32(FreeBuffersRequestWire.BUFFER_IDS_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU32(v);
                }
                target.appendBytesTag(FreeBuffersRequestWire.BUFFER_IDS_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint32WithoutTag(v);
                }
            }
        }
    }
};
pub const FreeBuffersRequestReader = struct {
    buf: gremlin.Reader,
    _buffer_ids_offset: ?usize = null,
    _buffer_ids_last_offset: ?usize = null,
    _buffer_ids_packed: bool = false,
    pub fn init(src: []const u8) gremlin.Error!FreeBuffersRequestReader {
        const buf = gremlin.Reader.init(src);
        var res = FreeBuffersRequestReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                FreeBuffersRequestWire.BUFFER_IDS_WIRE => {
                    if (res._buffer_ids_offset == null) {
                        res._buffer_ids_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._buffer_ids_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._buffer_ids_offset = offset + length_result.size;
                        res._buffer_ids_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._buffer_ids_last_offset.?;
                    } else {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._buffer_ids_last_offset = offset;
                    }
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn bufferIdsNext(self: *FreeBuffersRequestReader) gremlin.Error!?u32 {
        if (self._buffer_ids_offset == null) return null;
        const current_offset = self._buffer_ids_offset.?;
        if (current_offset >= self._buffer_ids_last_offset.?) {
            self._buffer_ids_offset = null;
            return null;
        }
        if (self._buffer_ids_packed) {
            const value_result = try self.buf.readUInt32(current_offset);
            self._buffer_ids_offset = current_offset + value_result.size;
            if (self._buffer_ids_offset.? >= self._buffer_ids_last_offset.?) {
                self._buffer_ids_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._buffer_ids_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == FreeBuffersRequestWire.BUFFER_IDS_WIRE) {
                    self._buffer_ids_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._buffer_ids_offset = null;
            return value_result.value;
        }
    }
};
pub const FreeBuffersResponse = struct {
    pub fn calcProtobufSize(_: *const FreeBuffersResponse) usize {
        return 0;
    }
    pub fn encode(self: *const FreeBuffersResponse, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(_: *const FreeBuffersResponse, _: *gremlin.Writer) void {}
};
pub const FreeBuffersResponseReader = struct {
    buf: gremlin.Reader,
    pub fn init(src: []const u8) gremlin.Error!FreeBuffersResponseReader {
        const buf = gremlin.Reader.init(src);
        return FreeBuffersResponseReader{ .buf = buf };
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
};
const FlushRequestWire = struct {
    const TIMEOUT_MS_WIRE: gremlin.ProtoWireNumber = 1;
    const FLAGS_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const FlushRequest = struct {
    // fields
    timeout_ms: u32 = 0,
    flags: u64 = 0,
    pub fn calcProtobufSize(self: *const FlushRequest) usize {
        var res: usize = 0;
        if (self.timeout_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(FlushRequestWire.TIMEOUT_MS_WIRE) + gremlin.sizes.sizeU32(self.timeout_ms);
        }
        if (self.flags != 0) {
            res += gremlin.sizes.sizeWireNumber(FlushRequestWire.FLAGS_WIRE) + gremlin.sizes.sizeU64(self.flags);
        }
        return res;
    }
    pub fn encode(self: *const FlushRequest, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const FlushRequest, target: *gremlin.Writer) void {
        if (self.timeout_ms != 0) {
            target.appendUint32(FlushRequestWire.TIMEOUT_MS_WIRE, self.timeout_ms);
        }
        if (self.flags != 0) {
            target.appendUint64(FlushRequestWire.FLAGS_WIRE, self.flags);
        }
    }
};
pub const FlushRequestReader = struct {
    buf: gremlin.Reader,
    _timeout_ms: u32 = 0,
    _flags: u64 = 0,
    pub fn init(src: []const u8) gremlin.Error!FlushRequestReader {
        const buf = gremlin.Reader.init(src);
        var res = FlushRequestReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                FlushRequestWire.TIMEOUT_MS_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._timeout_ms = result.value;
                },
                FlushRequestWire.FLAGS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._flags = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getTimeoutMs(self: *const FlushRequestReader) u32 {
        return self._timeout_ms;
    }
    pub inline fn getFlags(self: *const FlushRequestReader) u64 {
        return self._flags;
    }
};
pub const FlushResponse = struct {
    pub fn calcProtobufSize(_: *const FlushResponse) usize {
        return 0;
    }
    pub fn encode(self: *const FlushResponse, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(_: *const FlushResponse, _: *gremlin.Writer) void {}
};
pub const FlushResponseReader = struct {
    buf: gremlin.Reader,
    pub fn init(src: []const u8) gremlin.Error!FlushResponseReader {
        const buf = gremlin.Reader.init(src);
        return FlushResponseReader{ .buf = buf };
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
};
const DetachRequestWire = struct {
    const KEY_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const DetachRequest = struct {
    // fields
    key: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const DetachRequest) usize {
        var res: usize = 0;
        if (self.key) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(DetachRequestWire.KEY_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const DetachRequest, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const DetachRequest, target: *gremlin.Writer) void {
        if (self.key) |v| {
            if (v.len > 0) {
                target.appendBytes(DetachRequestWire.KEY_WIRE, v);
            }
        }
    }
};
pub const DetachRequestReader = struct {
    buf: gremlin.Reader,
    _key: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!DetachRequestReader {
        const buf = gremlin.Reader.init(src);
        var res = DetachRequestReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                DetachRequestWire.KEY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._key = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getKey(self: *const DetachRequestReader) []const u8 {
        return self._key orelse &[_]u8{};
    }
};
pub const DetachResponse = struct {
    pub fn calcProtobufSize(_: *const DetachResponse) usize {
        return 0;
    }
    pub fn encode(self: *const DetachResponse, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(_: *const DetachResponse, _: *gremlin.Writer) void {}
};
pub const DetachResponseReader = struct {
    buf: gremlin.Reader,
    pub fn init(src: []const u8) gremlin.Error!DetachResponseReader {
        const buf = gremlin.Reader.init(src);
        return DetachResponseReader{ .buf = buf };
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
};
const AttachRequestWire = struct {
    const KEY_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const AttachRequest = struct {
    // fields
    key: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const AttachRequest) usize {
        var res: usize = 0;
        if (self.key) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(AttachRequestWire.KEY_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const AttachRequest, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AttachRequest, target: *gremlin.Writer) void {
        if (self.key) |v| {
            if (v.len > 0) {
                target.appendBytes(AttachRequestWire.KEY_WIRE, v);
            }
        }
    }
};
pub const AttachRequestReader = struct {
    buf: gremlin.Reader,
    _key: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!AttachRequestReader {
        const buf = gremlin.Reader.init(src);
        var res = AttachRequestReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AttachRequestWire.KEY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._key = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getKey(self: *const AttachRequestReader) []const u8 {
        return self._key orelse &[_]u8{};
    }
};
const AttachResponseWire = struct {
    const TRACE_CONFIG_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const AttachResponse = struct {
    // fields
    trace_config: ?trace_config.TraceConfig = null,
    pub fn calcProtobufSize(self: *const AttachResponse) usize {
        var res: usize = 0;
        if (self.trace_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(AttachResponseWire.TRACE_CONFIG_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const AttachResponse, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AttachResponse, target: *gremlin.Writer) void {
        if (self.trace_config) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(AttachResponseWire.TRACE_CONFIG_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const AttachResponseReader = struct {
    buf: gremlin.Reader,
    _trace_config_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!AttachResponseReader {
        const buf = gremlin.Reader.init(src);
        var res = AttachResponseReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AttachResponseWire.TRACE_CONFIG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._trace_config_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getTraceConfig(self: *const AttachResponseReader) gremlin.Error!trace_config.TraceConfigReader {
        if (self._trace_config_buf) |buf| {
            return try trace_config.TraceConfigReader.init(buf);
        }
        return try trace_config.TraceConfigReader.init(&[_]u8{});
    }
};
pub const GetTraceStatsRequest = struct {
    pub fn calcProtobufSize(_: *const GetTraceStatsRequest) usize {
        return 0;
    }
    pub fn encode(self: *const GetTraceStatsRequest, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(_: *const GetTraceStatsRequest, _: *gremlin.Writer) void {}
};
pub const GetTraceStatsRequestReader = struct {
    buf: gremlin.Reader,
    pub fn init(src: []const u8) gremlin.Error!GetTraceStatsRequestReader {
        const buf = gremlin.Reader.init(src);
        return GetTraceStatsRequestReader{ .buf = buf };
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
};
const GetTraceStatsResponseWire = struct {
    const TRACE_STATS_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const GetTraceStatsResponse = struct {
    // fields
    trace_stats: ?trace_stats.TraceStats = null,
    pub fn calcProtobufSize(self: *const GetTraceStatsResponse) usize {
        var res: usize = 0;
        if (self.trace_stats) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(GetTraceStatsResponseWire.TRACE_STATS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const GetTraceStatsResponse, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const GetTraceStatsResponse, target: *gremlin.Writer) void {
        if (self.trace_stats) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(GetTraceStatsResponseWire.TRACE_STATS_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const GetTraceStatsResponseReader = struct {
    buf: gremlin.Reader,
    _trace_stats_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!GetTraceStatsResponseReader {
        const buf = gremlin.Reader.init(src);
        var res = GetTraceStatsResponseReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                GetTraceStatsResponseWire.TRACE_STATS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._trace_stats_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getTraceStats(self: *const GetTraceStatsResponseReader) gremlin.Error!trace_stats.TraceStatsReader {
        if (self._trace_stats_buf) |buf| {
            return try trace_stats.TraceStatsReader.init(buf);
        }
        return try trace_stats.TraceStatsReader.init(&[_]u8{});
    }
};
const ObserveEventsRequestWire = struct {
    const EVENTS_TO_OBSERVE_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const ObserveEventsRequest = struct {
    // fields
    events_to_observe: ?[]const observable_events.ObservableEvents.Type = null,
    pub fn calcProtobufSize(self: *const ObserveEventsRequest) usize {
        var res: usize = 0;
        if (self.events_to_observe) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(ObserveEventsRequestWire.EVENTS_TO_OBSERVE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(arr[0]));
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(@intFromEnum(v));
                }
                res += gremlin.sizes.sizeWireNumber(ObserveEventsRequestWire.EVENTS_TO_OBSERVE_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        return res;
    }
    pub fn encode(self: *const ObserveEventsRequest, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ObserveEventsRequest, target: *gremlin.Writer) void {
        if (self.events_to_observe) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt32(ObserveEventsRequestWire.EVENTS_TO_OBSERVE_WIRE, @intFromEnum(arr[0]));
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(@intFromEnum(v));
                }
                target.appendBytesTag(ObserveEventsRequestWire.EVENTS_TO_OBSERVE_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt32WithoutTag(@intFromEnum(v));
                }
            }
        }
    }
};
pub const ObserveEventsRequestReader = struct {
    buf: gremlin.Reader,
    _events_to_observe_offset: ?usize = null,
    _events_to_observe_last_offset: ?usize = null,
    _events_to_observe_packed: bool = false,
    pub fn init(src: []const u8) gremlin.Error!ObserveEventsRequestReader {
        const buf = gremlin.Reader.init(src);
        var res = ObserveEventsRequestReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ObserveEventsRequestWire.EVENTS_TO_OBSERVE_WIRE => {
                    if (res._events_to_observe_offset == null) {
                        res._events_to_observe_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._events_to_observe_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._events_to_observe_offset = offset + length_result.size;
                        res._events_to_observe_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._events_to_observe_last_offset.?;
                    } else {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._events_to_observe_last_offset = offset;
                    }
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn eventsToObserveNext(self: *ObserveEventsRequestReader) gremlin.Error!?observable_events.ObservableEvents.Type {
        if (self._events_to_observe_offset == null) return null;
        const current_offset = self._events_to_observe_offset.?;
        if (current_offset >= self._events_to_observe_last_offset.?) {
            self._events_to_observe_offset = null;
            return null;
        }
        if (self._events_to_observe_packed) {
            const value_result = try self.buf.readInt32(current_offset);
            self._events_to_observe_offset = current_offset + value_result.size;
            if (self._events_to_observe_offset.? >= self._events_to_observe_last_offset.?) {
                self._events_to_observe_offset = null;
            }
            return @enumFromInt(value_result.value);
        } else {
            const value_result = try self.buf.readInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._events_to_observe_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == ObserveEventsRequestWire.EVENTS_TO_OBSERVE_WIRE) {
                    self._events_to_observe_offset = next_offset;
                    return @enumFromInt(value_result.value);
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._events_to_observe_offset = null;
            return @enumFromInt(value_result.value);
        }
    }
};
const ObserveEventsResponseWire = struct {
    const EVENTS_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const ObserveEventsResponse = struct {
    // fields
    events: ?observable_events.ObservableEvents = null,
    pub fn calcProtobufSize(self: *const ObserveEventsResponse) usize {
        var res: usize = 0;
        if (self.events) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(ObserveEventsResponseWire.EVENTS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const ObserveEventsResponse, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ObserveEventsResponse, target: *gremlin.Writer) void {
        if (self.events) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(ObserveEventsResponseWire.EVENTS_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const ObserveEventsResponseReader = struct {
    buf: gremlin.Reader,
    _events_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!ObserveEventsResponseReader {
        const buf = gremlin.Reader.init(src);
        var res = ObserveEventsResponseReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ObserveEventsResponseWire.EVENTS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._events_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getEvents(self: *const ObserveEventsResponseReader) gremlin.Error!observable_events.ObservableEventsReader {
        if (self._events_buf) |buf| {
            return try observable_events.ObservableEventsReader.init(buf);
        }
        return try observable_events.ObservableEventsReader.init(&[_]u8{});
    }
};
const QueryServiceStateRequestWire = struct {
    const SESSIONS_ONLY_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const QueryServiceStateRequest = struct {
    // fields
    sessions_only: bool = false,
    pub fn calcProtobufSize(self: *const QueryServiceStateRequest) usize {
        var res: usize = 0;
        if (self.sessions_only != false) {
            res += gremlin.sizes.sizeWireNumber(QueryServiceStateRequestWire.SESSIONS_ONLY_WIRE) + gremlin.sizes.sizeBool(self.sessions_only);
        }
        return res;
    }
    pub fn encode(self: *const QueryServiceStateRequest, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const QueryServiceStateRequest, target: *gremlin.Writer) void {
        if (self.sessions_only != false) {
            target.appendBool(QueryServiceStateRequestWire.SESSIONS_ONLY_WIRE, self.sessions_only);
        }
    }
};
pub const QueryServiceStateRequestReader = struct {
    buf: gremlin.Reader,
    _sessions_only: bool = false,
    pub fn init(src: []const u8) gremlin.Error!QueryServiceStateRequestReader {
        const buf = gremlin.Reader.init(src);
        var res = QueryServiceStateRequestReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                QueryServiceStateRequestWire.SESSIONS_ONLY_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._sessions_only = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getSessionsOnly(self: *const QueryServiceStateRequestReader) bool {
        return self._sessions_only;
    }
};
const QueryServiceStateResponseWire = struct {
    const SERVICE_STATE_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const QueryServiceStateResponse = struct {
    // fields
    service_state: ?tracing_service_state.TracingServiceState = null,
    pub fn calcProtobufSize(self: *const QueryServiceStateResponse) usize {
        var res: usize = 0;
        if (self.service_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(QueryServiceStateResponseWire.SERVICE_STATE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const QueryServiceStateResponse, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const QueryServiceStateResponse, target: *gremlin.Writer) void {
        if (self.service_state) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(QueryServiceStateResponseWire.SERVICE_STATE_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const QueryServiceStateResponseReader = struct {
    buf: gremlin.Reader,
    _service_state_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!QueryServiceStateResponseReader {
        const buf = gremlin.Reader.init(src);
        var res = QueryServiceStateResponseReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                QueryServiceStateResponseWire.SERVICE_STATE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._service_state_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getServiceState(self: *const QueryServiceStateResponseReader) gremlin.Error!tracing_service_state.TracingServiceStateReader {
        if (self._service_state_buf) |buf| {
            return try tracing_service_state.TracingServiceStateReader.init(buf);
        }
        return try tracing_service_state.TracingServiceStateReader.init(&[_]u8{});
    }
};
pub const QueryCapabilitiesRequest = struct {
    pub fn calcProtobufSize(_: *const QueryCapabilitiesRequest) usize {
        return 0;
    }
    pub fn encode(self: *const QueryCapabilitiesRequest, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(_: *const QueryCapabilitiesRequest, _: *gremlin.Writer) void {}
};
pub const QueryCapabilitiesRequestReader = struct {
    buf: gremlin.Reader,
    pub fn init(src: []const u8) gremlin.Error!QueryCapabilitiesRequestReader {
        const buf = gremlin.Reader.init(src);
        return QueryCapabilitiesRequestReader{ .buf = buf };
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
};
const QueryCapabilitiesResponseWire = struct {
    const CAPABILITIES_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const QueryCapabilitiesResponse = struct {
    // fields
    capabilities: ?tracing_service_capabilities.TracingServiceCapabilities = null,
    pub fn calcProtobufSize(self: *const QueryCapabilitiesResponse) usize {
        var res: usize = 0;
        if (self.capabilities) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(QueryCapabilitiesResponseWire.CAPABILITIES_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const QueryCapabilitiesResponse, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const QueryCapabilitiesResponse, target: *gremlin.Writer) void {
        if (self.capabilities) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(QueryCapabilitiesResponseWire.CAPABILITIES_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const QueryCapabilitiesResponseReader = struct {
    buf: gremlin.Reader,
    _capabilities_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!QueryCapabilitiesResponseReader {
        const buf = gremlin.Reader.init(src);
        var res = QueryCapabilitiesResponseReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                QueryCapabilitiesResponseWire.CAPABILITIES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._capabilities_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getCapabilities(self: *const QueryCapabilitiesResponseReader) gremlin.Error!tracing_service_capabilities.TracingServiceCapabilitiesReader {
        if (self._capabilities_buf) |buf| {
            return try tracing_service_capabilities.TracingServiceCapabilitiesReader.init(buf);
        }
        return try tracing_service_capabilities.TracingServiceCapabilitiesReader.init(&[_]u8{});
    }
};
pub const SaveTraceForBugreportRequest = struct {
    pub fn calcProtobufSize(_: *const SaveTraceForBugreportRequest) usize {
        return 0;
    }
    pub fn encode(self: *const SaveTraceForBugreportRequest, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(_: *const SaveTraceForBugreportRequest, _: *gremlin.Writer) void {}
};
pub const SaveTraceForBugreportRequestReader = struct {
    buf: gremlin.Reader,
    pub fn init(src: []const u8) gremlin.Error!SaveTraceForBugreportRequestReader {
        const buf = gremlin.Reader.init(src);
        return SaveTraceForBugreportRequestReader{ .buf = buf };
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
};
const SaveTraceForBugreportResponseWire = struct {
    const SUCCESS_WIRE: gremlin.ProtoWireNumber = 1;
    const MSG_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const SaveTraceForBugreportResponse = struct {
    // fields
    success: bool = false,
    msg: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const SaveTraceForBugreportResponse) usize {
        var res: usize = 0;
        if (self.success != false) {
            res += gremlin.sizes.sizeWireNumber(SaveTraceForBugreportResponseWire.SUCCESS_WIRE) + gremlin.sizes.sizeBool(self.success);
        }
        if (self.msg) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(SaveTraceForBugreportResponseWire.MSG_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const SaveTraceForBugreportResponse, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SaveTraceForBugreportResponse, target: *gremlin.Writer) void {
        if (self.success != false) {
            target.appendBool(SaveTraceForBugreportResponseWire.SUCCESS_WIRE, self.success);
        }
        if (self.msg) |v| {
            if (v.len > 0) {
                target.appendBytes(SaveTraceForBugreportResponseWire.MSG_WIRE, v);
            }
        }
    }
};
pub const SaveTraceForBugreportResponseReader = struct {
    buf: gremlin.Reader,
    _success: bool = false,
    _msg: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!SaveTraceForBugreportResponseReader {
        const buf = gremlin.Reader.init(src);
        var res = SaveTraceForBugreportResponseReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SaveTraceForBugreportResponseWire.SUCCESS_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._success = result.value;
                },
                SaveTraceForBugreportResponseWire.MSG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._msg = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getSuccess(self: *const SaveTraceForBugreportResponseReader) bool {
        return self._success;
    }
    pub inline fn getMsg(self: *const SaveTraceForBugreportResponseReader) []const u8 {
        return self._msg orelse &[_]u8{};
    }
};
const CloneSessionRequestWire = struct {
    const SKIP_TRACE_FILTER_WIRE: gremlin.ProtoWireNumber = 2;
    const FOR_BUGREPORT_WIRE: gremlin.ProtoWireNumber = 3;
    const CLONE_TRIGGER_NAME_WIRE: gremlin.ProtoWireNumber = 5;
    const CLONE_TRIGGER_PRODUCER_NAME_WIRE: gremlin.ProtoWireNumber = 6;
    const CLONE_TRIGGER_TRUSTED_PRODUCER_UID_WIRE: gremlin.ProtoWireNumber = 7;
    const CLONE_TRIGGER_BOOT_TIME_NS_WIRE: gremlin.ProtoWireNumber = 8;
    const CLONE_TRIGGER_DELAY_MS_WIRE: gremlin.ProtoWireNumber = 9;
    const SESSION_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const UNIQUE_SESSION_NAME_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const CloneSessionRequest = struct {
    // fields
    skip_trace_filter: bool = false,
    for_bugreport: bool = false,
    clone_trigger_name: ?[]const u8 = null,
    clone_trigger_producer_name: ?[]const u8 = null,
    clone_trigger_trusted_producer_uid: i32 = 0,
    clone_trigger_boot_time_ns: u64 = 0,
    clone_trigger_delay_ms: u64 = 0,
    session_id: u64 = 0,
    unique_session_name: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const CloneSessionRequest) usize {
        var res: usize = 0;
        if (self.skip_trace_filter != false) {
            res += gremlin.sizes.sizeWireNumber(CloneSessionRequestWire.SKIP_TRACE_FILTER_WIRE) + gremlin.sizes.sizeBool(self.skip_trace_filter);
        }
        if (self.for_bugreport != false) {
            res += gremlin.sizes.sizeWireNumber(CloneSessionRequestWire.FOR_BUGREPORT_WIRE) + gremlin.sizes.sizeBool(self.for_bugreport);
        }
        if (self.clone_trigger_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(CloneSessionRequestWire.CLONE_TRIGGER_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.clone_trigger_producer_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(CloneSessionRequestWire.CLONE_TRIGGER_PRODUCER_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.clone_trigger_trusted_producer_uid != 0) {
            res += gremlin.sizes.sizeWireNumber(CloneSessionRequestWire.CLONE_TRIGGER_TRUSTED_PRODUCER_UID_WIRE) + gremlin.sizes.sizeI32(self.clone_trigger_trusted_producer_uid);
        }
        if (self.clone_trigger_boot_time_ns != 0) {
            res += gremlin.sizes.sizeWireNumber(CloneSessionRequestWire.CLONE_TRIGGER_BOOT_TIME_NS_WIRE) + gremlin.sizes.sizeU64(self.clone_trigger_boot_time_ns);
        }
        if (self.clone_trigger_delay_ms != 0) {
            res += gremlin.sizes.sizeWireNumber(CloneSessionRequestWire.CLONE_TRIGGER_DELAY_MS_WIRE) + gremlin.sizes.sizeU64(self.clone_trigger_delay_ms);
        }
        if (self.session_id != 0) {
            res += gremlin.sizes.sizeWireNumber(CloneSessionRequestWire.SESSION_ID_WIRE) + gremlin.sizes.sizeU64(self.session_id);
        }
        if (self.unique_session_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(CloneSessionRequestWire.UNIQUE_SESSION_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const CloneSessionRequest, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const CloneSessionRequest, target: *gremlin.Writer) void {
        if (self.skip_trace_filter != false) {
            target.appendBool(CloneSessionRequestWire.SKIP_TRACE_FILTER_WIRE, self.skip_trace_filter);
        }
        if (self.for_bugreport != false) {
            target.appendBool(CloneSessionRequestWire.FOR_BUGREPORT_WIRE, self.for_bugreport);
        }
        if (self.clone_trigger_name) |v| {
            if (v.len > 0) {
                target.appendBytes(CloneSessionRequestWire.CLONE_TRIGGER_NAME_WIRE, v);
            }
        }
        if (self.clone_trigger_producer_name) |v| {
            if (v.len > 0) {
                target.appendBytes(CloneSessionRequestWire.CLONE_TRIGGER_PRODUCER_NAME_WIRE, v);
            }
        }
        if (self.clone_trigger_trusted_producer_uid != 0) {
            target.appendInt32(CloneSessionRequestWire.CLONE_TRIGGER_TRUSTED_PRODUCER_UID_WIRE, self.clone_trigger_trusted_producer_uid);
        }
        if (self.clone_trigger_boot_time_ns != 0) {
            target.appendUint64(CloneSessionRequestWire.CLONE_TRIGGER_BOOT_TIME_NS_WIRE, self.clone_trigger_boot_time_ns);
        }
        if (self.clone_trigger_delay_ms != 0) {
            target.appendUint64(CloneSessionRequestWire.CLONE_TRIGGER_DELAY_MS_WIRE, self.clone_trigger_delay_ms);
        }
        if (self.session_id != 0) {
            target.appendUint64(CloneSessionRequestWire.SESSION_ID_WIRE, self.session_id);
        }
        if (self.unique_session_name) |v| {
            if (v.len > 0) {
                target.appendBytes(CloneSessionRequestWire.UNIQUE_SESSION_NAME_WIRE, v);
            }
        }
    }
};
pub const CloneSessionRequestReader = struct {
    buf: gremlin.Reader,
    _skip_trace_filter: bool = false,
    _for_bugreport: bool = false,
    _clone_trigger_name: ?[]const u8 = null,
    _clone_trigger_producer_name: ?[]const u8 = null,
    _clone_trigger_trusted_producer_uid: i32 = 0,
    _clone_trigger_boot_time_ns: u64 = 0,
    _clone_trigger_delay_ms: u64 = 0,
    _session_id: u64 = 0,
    _unique_session_name: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!CloneSessionRequestReader {
        const buf = gremlin.Reader.init(src);
        var res = CloneSessionRequestReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                CloneSessionRequestWire.SKIP_TRACE_FILTER_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._skip_trace_filter = result.value;
                },
                CloneSessionRequestWire.FOR_BUGREPORT_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._for_bugreport = result.value;
                },
                CloneSessionRequestWire.CLONE_TRIGGER_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._clone_trigger_name = result.value;
                },
                CloneSessionRequestWire.CLONE_TRIGGER_PRODUCER_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._clone_trigger_producer_name = result.value;
                },
                CloneSessionRequestWire.CLONE_TRIGGER_TRUSTED_PRODUCER_UID_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._clone_trigger_trusted_producer_uid = result.value;
                },
                CloneSessionRequestWire.CLONE_TRIGGER_BOOT_TIME_NS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._clone_trigger_boot_time_ns = result.value;
                },
                CloneSessionRequestWire.CLONE_TRIGGER_DELAY_MS_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._clone_trigger_delay_ms = result.value;
                },
                CloneSessionRequestWire.SESSION_ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._session_id = result.value;
                },
                CloneSessionRequestWire.UNIQUE_SESSION_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._unique_session_name = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getSkipTraceFilter(self: *const CloneSessionRequestReader) bool {
        return self._skip_trace_filter;
    }
    pub inline fn getForBugreport(self: *const CloneSessionRequestReader) bool {
        return self._for_bugreport;
    }
    pub inline fn getCloneTriggerName(self: *const CloneSessionRequestReader) []const u8 {
        return self._clone_trigger_name orelse &[_]u8{};
    }
    pub inline fn getCloneTriggerProducerName(self: *const CloneSessionRequestReader) []const u8 {
        return self._clone_trigger_producer_name orelse &[_]u8{};
    }
    pub inline fn getCloneTriggerTrustedProducerUid(self: *const CloneSessionRequestReader) i32 {
        return self._clone_trigger_trusted_producer_uid;
    }
    pub inline fn getCloneTriggerBootTimeNs(self: *const CloneSessionRequestReader) u64 {
        return self._clone_trigger_boot_time_ns;
    }
    pub inline fn getCloneTriggerDelayMs(self: *const CloneSessionRequestReader) u64 {
        return self._clone_trigger_delay_ms;
    }
    pub inline fn getSessionId(self: *const CloneSessionRequestReader) u64 {
        return self._session_id;
    }
    pub inline fn getUniqueSessionName(self: *const CloneSessionRequestReader) []const u8 {
        return self._unique_session_name orelse &[_]u8{};
    }
};
const CloneSessionResponseWire = struct {
    const SUCCESS_WIRE: gremlin.ProtoWireNumber = 1;
    const ERROR_WIRE: gremlin.ProtoWireNumber = 2;
    const UUID_MSB_WIRE: gremlin.ProtoWireNumber = 3;
    const UUID_LSB_WIRE: gremlin.ProtoWireNumber = 4;
    const WAS_WRITE_INTO_FILE_WIRE: gremlin.ProtoWireNumber = 5;
};
pub const CloneSessionResponse = struct {
    // fields
    success: bool = false,
    error_: ?[]const u8 = null,
    uuid_msb: i64 = 0,
    uuid_lsb: i64 = 0,
    was_write_into_file: bool = false,
    pub fn calcProtobufSize(self: *const CloneSessionResponse) usize {
        var res: usize = 0;
        if (self.success != false) {
            res += gremlin.sizes.sizeWireNumber(CloneSessionResponseWire.SUCCESS_WIRE) + gremlin.sizes.sizeBool(self.success);
        }
        if (self.error_) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(CloneSessionResponseWire.ERROR_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.uuid_msb != 0) {
            res += gremlin.sizes.sizeWireNumber(CloneSessionResponseWire.UUID_MSB_WIRE) + gremlin.sizes.sizeI64(self.uuid_msb);
        }
        if (self.uuid_lsb != 0) {
            res += gremlin.sizes.sizeWireNumber(CloneSessionResponseWire.UUID_LSB_WIRE) + gremlin.sizes.sizeI64(self.uuid_lsb);
        }
        if (self.was_write_into_file != false) {
            res += gremlin.sizes.sizeWireNumber(CloneSessionResponseWire.WAS_WRITE_INTO_FILE_WIRE) + gremlin.sizes.sizeBool(self.was_write_into_file);
        }
        return res;
    }
    pub fn encode(self: *const CloneSessionResponse, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const CloneSessionResponse, target: *gremlin.Writer) void {
        if (self.success != false) {
            target.appendBool(CloneSessionResponseWire.SUCCESS_WIRE, self.success);
        }
        if (self.error_) |v| {
            if (v.len > 0) {
                target.appendBytes(CloneSessionResponseWire.ERROR_WIRE, v);
            }
        }
        if (self.uuid_msb != 0) {
            target.appendInt64(CloneSessionResponseWire.UUID_MSB_WIRE, self.uuid_msb);
        }
        if (self.uuid_lsb != 0) {
            target.appendInt64(CloneSessionResponseWire.UUID_LSB_WIRE, self.uuid_lsb);
        }
        if (self.was_write_into_file != false) {
            target.appendBool(CloneSessionResponseWire.WAS_WRITE_INTO_FILE_WIRE, self.was_write_into_file);
        }
    }
};
pub const CloneSessionResponseReader = struct {
    buf: gremlin.Reader,
    _success: bool = false,
    _error_: ?[]const u8 = null,
    _uuid_msb: i64 = 0,
    _uuid_lsb: i64 = 0,
    _was_write_into_file: bool = false,
    pub fn init(src: []const u8) gremlin.Error!CloneSessionResponseReader {
        const buf = gremlin.Reader.init(src);
        var res = CloneSessionResponseReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                CloneSessionResponseWire.SUCCESS_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._success = result.value;
                },
                CloneSessionResponseWire.ERROR_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._error_ = result.value;
                },
                CloneSessionResponseWire.UUID_MSB_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._uuid_msb = result.value;
                },
                CloneSessionResponseWire.UUID_LSB_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._uuid_lsb = result.value;
                },
                CloneSessionResponseWire.WAS_WRITE_INTO_FILE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._was_write_into_file = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getSuccess(self: *const CloneSessionResponseReader) bool {
        return self._success;
    }
    pub inline fn getError(self: *const CloneSessionResponseReader) []const u8 {
        return self._error_ orelse &[_]u8{};
    }
    pub inline fn getUuidMsb(self: *const CloneSessionResponseReader) i64 {
        return self._uuid_msb;
    }
    pub inline fn getUuidLsb(self: *const CloneSessionResponseReader) i64 {
        return self._uuid_lsb;
    }
    pub inline fn getWasWriteIntoFile(self: *const CloneSessionResponseReader) bool {
        return self._was_write_into_file;
    }
};
