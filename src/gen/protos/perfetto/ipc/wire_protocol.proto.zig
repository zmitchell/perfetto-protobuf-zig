// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const IPCFrameWire = struct {
    const REQUEST_ID_WIRE: gremlin.ProtoWireNumber = 2;
    const DATA_FOR_TESTING_WIRE: gremlin.ProtoWireNumber = 1;
    const MSG_BIND_SERVICE_WIRE: gremlin.ProtoWireNumber = 3;
    const MSG_BIND_SERVICE_REPLY_WIRE: gremlin.ProtoWireNumber = 4;
    const MSG_INVOKE_METHOD_WIRE: gremlin.ProtoWireNumber = 5;
    const MSG_INVOKE_METHOD_REPLY_WIRE: gremlin.ProtoWireNumber = 6;
    const MSG_REQUEST_ERROR_WIRE: gremlin.ProtoWireNumber = 7;
    const SET_PEER_IDENTITY_WIRE: gremlin.ProtoWireNumber = 8;
};
pub const IPCFrame = struct {
    // nested structs
    const BindServiceWire = struct {
        const SERVICE_NAME_WIRE: gremlin.ProtoWireNumber = 1;
    };
    pub const BindService = struct {
        // fields
        service_name: ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const IPCFrame.BindService) usize {
            var res: usize = 0;
            if (self.service_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(IPCFrame.BindServiceWire.SERVICE_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            return res;
        }
        pub fn encode(self: *const IPCFrame.BindService, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const IPCFrame.BindService, target: *gremlin.Writer) void {
            if (self.service_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(IPCFrame.BindServiceWire.SERVICE_NAME_WIRE, v);
                }
            }
        }
    };
    pub const BindServiceReader = struct {
        buf: gremlin.Reader,
        _service_name: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!IPCFrame.BindServiceReader {
            const buf = gremlin.Reader.init(src);
            var res = IPCFrame.BindServiceReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    IPCFrame.BindServiceWire.SERVICE_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._service_name = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getServiceName(self: *const IPCFrame.BindServiceReader) []const u8 {
            return self._service_name orelse &[_]u8{};
        }
    };
    const BindServiceReplyWire = struct {
        const SUCCESS_WIRE: gremlin.ProtoWireNumber = 1;
        const SERVICE_ID_WIRE: gremlin.ProtoWireNumber = 2;
        const METHODS_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const BindServiceReply = struct {
        // nested structs
        const MethodInfoWire = struct {
            const ID_WIRE: gremlin.ProtoWireNumber = 1;
            const NAME_WIRE: gremlin.ProtoWireNumber = 2;
        };
        pub const MethodInfo = struct {
            // fields
            id: u32 = 0,
            name: ?[]const u8 = null,
            pub fn calcProtobufSize(self: *const IPCFrame.BindServiceReply.MethodInfo) usize {
                var res: usize = 0;
                if (self.id != 0) {
                    res += gremlin.sizes.sizeWireNumber(IPCFrame.BindServiceReply.MethodInfoWire.ID_WIRE) + gremlin.sizes.sizeU32(self.id);
                }
                if (self.name) |v| {
                    if (v.len > 0) {
                        res += gremlin.sizes.sizeWireNumber(IPCFrame.BindServiceReply.MethodInfoWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                    }
                }
                return res;
            }
            pub fn encode(self: *const IPCFrame.BindServiceReply.MethodInfo, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const IPCFrame.BindServiceReply.MethodInfo, target: *gremlin.Writer) void {
                if (self.id != 0) {
                    target.appendUint32(IPCFrame.BindServiceReply.MethodInfoWire.ID_WIRE, self.id);
                }
                if (self.name) |v| {
                    if (v.len > 0) {
                        target.appendBytes(IPCFrame.BindServiceReply.MethodInfoWire.NAME_WIRE, v);
                    }
                }
            }
        };
        pub const MethodInfoReader = struct {
            buf: gremlin.Reader,
            _id: u32 = 0,
            _name: ?[]const u8 = null,
            pub fn init(src: []const u8) gremlin.Error!IPCFrame.BindServiceReply.MethodInfoReader {
                const buf = gremlin.Reader.init(src);
                var res = IPCFrame.BindServiceReply.MethodInfoReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        IPCFrame.BindServiceReply.MethodInfoWire.ID_WIRE => {
                            const result = try buf.readUInt32(offset);
                            offset += result.size;
                            res._id = result.value;
                        },
                        IPCFrame.BindServiceReply.MethodInfoWire.NAME_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._name = result.value;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub inline fn getId(self: *const IPCFrame.BindServiceReply.MethodInfoReader) u32 {
                return self._id;
            }
            pub inline fn getName(self: *const IPCFrame.BindServiceReply.MethodInfoReader) []const u8 {
                return self._name orelse &[_]u8{};
            }
        };
        // fields
        success: bool = false,
        service_id: u32 = 0,
        methods: ?[]const ?IPCFrame.BindServiceReply.MethodInfo = null,
        pub fn calcProtobufSize(self: *const IPCFrame.BindServiceReply) usize {
            var res: usize = 0;
            if (self.success != false) {
                res += gremlin.sizes.sizeWireNumber(IPCFrame.BindServiceReplyWire.SUCCESS_WIRE) + gremlin.sizes.sizeBool(self.success);
            }
            if (self.service_id != 0) {
                res += gremlin.sizes.sizeWireNumber(IPCFrame.BindServiceReplyWire.SERVICE_ID_WIRE) + gremlin.sizes.sizeU32(self.service_id);
            }
            if (self.methods) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(IPCFrame.BindServiceReplyWire.METHODS_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const IPCFrame.BindServiceReply, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const IPCFrame.BindServiceReply, target: *gremlin.Writer) void {
            if (self.success != false) {
                target.appendBool(IPCFrame.BindServiceReplyWire.SUCCESS_WIRE, self.success);
            }
            if (self.service_id != 0) {
                target.appendUint32(IPCFrame.BindServiceReplyWire.SERVICE_ID_WIRE, self.service_id);
            }
            if (self.methods) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(IPCFrame.BindServiceReplyWire.METHODS_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(IPCFrame.BindServiceReplyWire.METHODS_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const BindServiceReplyReader = struct {
        buf: gremlin.Reader,
        _success: bool = false,
        _service_id: u32 = 0,
        _methods_offset: ?usize = null,
        _methods_last_offset: ?usize = null,
        _methods_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!IPCFrame.BindServiceReplyReader {
            const buf = gremlin.Reader.init(src);
            var res = IPCFrame.BindServiceReplyReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    IPCFrame.BindServiceReplyWire.SUCCESS_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._success = result.value;
                    },
                    IPCFrame.BindServiceReplyWire.SERVICE_ID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._service_id = result.value;
                    },
                    IPCFrame.BindServiceReplyWire.METHODS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._methods_offset == null) {
                            res._methods_offset = offset - result.size;
                        }
                        res._methods_last_offset = offset;
                        res._methods_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getSuccess(self: *const IPCFrame.BindServiceReplyReader) bool {
            return self._success;
        }
        pub inline fn getServiceId(self: *const IPCFrame.BindServiceReplyReader) u32 {
            return self._service_id;
        }
        pub fn methodsCount(self: *const IPCFrame.BindServiceReplyReader) usize {
            return self._methods_cnt;
        }
        pub fn methodsNext(self: *IPCFrame.BindServiceReplyReader) ?IPCFrame.BindServiceReply.MethodInfoReader {
            if (self._methods_offset == null) return null;
            const current_offset = self._methods_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = IPCFrame.BindServiceReply.MethodInfoReader.init(result.value) catch return null;
            if (self._methods_last_offset != null and current_offset >= self._methods_last_offset.?) {
                self._methods_offset = null;
                return msg;
            }
            if (self._methods_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._methods_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == IPCFrame.BindServiceReplyWire.METHODS_WIRE) {
                    self._methods_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._methods_offset = null;
            return msg;
        }
    };
    const InvokeMethodWire = struct {
        const SERVICE_ID_WIRE: gremlin.ProtoWireNumber = 1;
        const METHOD_ID_WIRE: gremlin.ProtoWireNumber = 2;
        const ARGS_PROTO_WIRE: gremlin.ProtoWireNumber = 3;
        const DROP_REPLY_WIRE: gremlin.ProtoWireNumber = 4;
    };
    pub const InvokeMethod = struct {
        // fields
        service_id: u32 = 0,
        method_id: u32 = 0,
        args_proto: ?[]const u8 = null,
        drop_reply: bool = false,
        pub fn calcProtobufSize(self: *const IPCFrame.InvokeMethod) usize {
            var res: usize = 0;
            if (self.service_id != 0) {
                res += gremlin.sizes.sizeWireNumber(IPCFrame.InvokeMethodWire.SERVICE_ID_WIRE) + gremlin.sizes.sizeU32(self.service_id);
            }
            if (self.method_id != 0) {
                res += gremlin.sizes.sizeWireNumber(IPCFrame.InvokeMethodWire.METHOD_ID_WIRE) + gremlin.sizes.sizeU32(self.method_id);
            }
            if (self.args_proto) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(IPCFrame.InvokeMethodWire.ARGS_PROTO_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.drop_reply != false) {
                res += gremlin.sizes.sizeWireNumber(IPCFrame.InvokeMethodWire.DROP_REPLY_WIRE) + gremlin.sizes.sizeBool(self.drop_reply);
            }
            return res;
        }
        pub fn encode(self: *const IPCFrame.InvokeMethod, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const IPCFrame.InvokeMethod, target: *gremlin.Writer) void {
            if (self.service_id != 0) {
                target.appendUint32(IPCFrame.InvokeMethodWire.SERVICE_ID_WIRE, self.service_id);
            }
            if (self.method_id != 0) {
                target.appendUint32(IPCFrame.InvokeMethodWire.METHOD_ID_WIRE, self.method_id);
            }
            if (self.args_proto) |v| {
                if (v.len > 0) {
                    target.appendBytes(IPCFrame.InvokeMethodWire.ARGS_PROTO_WIRE, v);
                }
            }
            if (self.drop_reply != false) {
                target.appendBool(IPCFrame.InvokeMethodWire.DROP_REPLY_WIRE, self.drop_reply);
            }
        }
    };
    pub const InvokeMethodReader = struct {
        buf: gremlin.Reader,
        _service_id: u32 = 0,
        _method_id: u32 = 0,
        _args_proto: ?[]const u8 = null,
        _drop_reply: bool = false,
        pub fn init(src: []const u8) gremlin.Error!IPCFrame.InvokeMethodReader {
            const buf = gremlin.Reader.init(src);
            var res = IPCFrame.InvokeMethodReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    IPCFrame.InvokeMethodWire.SERVICE_ID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._service_id = result.value;
                    },
                    IPCFrame.InvokeMethodWire.METHOD_ID_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._method_id = result.value;
                    },
                    IPCFrame.InvokeMethodWire.ARGS_PROTO_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._args_proto = result.value;
                    },
                    IPCFrame.InvokeMethodWire.DROP_REPLY_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._drop_reply = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getServiceId(self: *const IPCFrame.InvokeMethodReader) u32 {
            return self._service_id;
        }
        pub inline fn getMethodId(self: *const IPCFrame.InvokeMethodReader) u32 {
            return self._method_id;
        }
        pub inline fn getArgsProto(self: *const IPCFrame.InvokeMethodReader) []const u8 {
            return self._args_proto orelse &[_]u8{};
        }
        pub inline fn getDropReply(self: *const IPCFrame.InvokeMethodReader) bool {
            return self._drop_reply;
        }
    };
    const InvokeMethodReplyWire = struct {
        const SUCCESS_WIRE: gremlin.ProtoWireNumber = 1;
        const HAS_MORE_WIRE: gremlin.ProtoWireNumber = 2;
        const REPLY_PROTO_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const InvokeMethodReply = struct {
        // fields
        success: bool = false,
        has_more: bool = false,
        reply_proto: ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const IPCFrame.InvokeMethodReply) usize {
            var res: usize = 0;
            if (self.success != false) {
                res += gremlin.sizes.sizeWireNumber(IPCFrame.InvokeMethodReplyWire.SUCCESS_WIRE) + gremlin.sizes.sizeBool(self.success);
            }
            if (self.has_more != false) {
                res += gremlin.sizes.sizeWireNumber(IPCFrame.InvokeMethodReplyWire.HAS_MORE_WIRE) + gremlin.sizes.sizeBool(self.has_more);
            }
            if (self.reply_proto) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(IPCFrame.InvokeMethodReplyWire.REPLY_PROTO_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            return res;
        }
        pub fn encode(self: *const IPCFrame.InvokeMethodReply, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const IPCFrame.InvokeMethodReply, target: *gremlin.Writer) void {
            if (self.success != false) {
                target.appendBool(IPCFrame.InvokeMethodReplyWire.SUCCESS_WIRE, self.success);
            }
            if (self.has_more != false) {
                target.appendBool(IPCFrame.InvokeMethodReplyWire.HAS_MORE_WIRE, self.has_more);
            }
            if (self.reply_proto) |v| {
                if (v.len > 0) {
                    target.appendBytes(IPCFrame.InvokeMethodReplyWire.REPLY_PROTO_WIRE, v);
                }
            }
        }
    };
    pub const InvokeMethodReplyReader = struct {
        buf: gremlin.Reader,
        _success: bool = false,
        _has_more: bool = false,
        _reply_proto: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!IPCFrame.InvokeMethodReplyReader {
            const buf = gremlin.Reader.init(src);
            var res = IPCFrame.InvokeMethodReplyReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    IPCFrame.InvokeMethodReplyWire.SUCCESS_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._success = result.value;
                    },
                    IPCFrame.InvokeMethodReplyWire.HAS_MORE_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._has_more = result.value;
                    },
                    IPCFrame.InvokeMethodReplyWire.REPLY_PROTO_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._reply_proto = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getSuccess(self: *const IPCFrame.InvokeMethodReplyReader) bool {
            return self._success;
        }
        pub inline fn getHasMore(self: *const IPCFrame.InvokeMethodReplyReader) bool {
            return self._has_more;
        }
        pub inline fn getReplyProto(self: *const IPCFrame.InvokeMethodReplyReader) []const u8 {
            return self._reply_proto orelse &[_]u8{};
        }
    };
    const RequestErrorWire = struct {
        const ERROR_WIRE: gremlin.ProtoWireNumber = 1;
    };
    pub const RequestError = struct {
        // fields
        error_: ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const IPCFrame.RequestError) usize {
            var res: usize = 0;
            if (self.error_) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(IPCFrame.RequestErrorWire.ERROR_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            return res;
        }
        pub fn encode(self: *const IPCFrame.RequestError, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const IPCFrame.RequestError, target: *gremlin.Writer) void {
            if (self.error_) |v| {
                if (v.len > 0) {
                    target.appendBytes(IPCFrame.RequestErrorWire.ERROR_WIRE, v);
                }
            }
        }
    };
    pub const RequestErrorReader = struct {
        buf: gremlin.Reader,
        _error_: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!IPCFrame.RequestErrorReader {
            const buf = gremlin.Reader.init(src);
            var res = IPCFrame.RequestErrorReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    IPCFrame.RequestErrorWire.ERROR_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._error_ = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getError(self: *const IPCFrame.RequestErrorReader) []const u8 {
            return self._error_ orelse &[_]u8{};
        }
    };
    const SetPeerIdentityWire = struct {
        const PID_WIRE: gremlin.ProtoWireNumber = 1;
        const UID_WIRE: gremlin.ProtoWireNumber = 2;
        const MACHINE_ID_HINT_WIRE: gremlin.ProtoWireNumber = 3;
        const MACHINE_NAME_WIRE: gremlin.ProtoWireNumber = 4;
    };
    pub const SetPeerIdentity = struct {
        // fields
        pid: i32 = 0,
        uid: i32 = 0,
        machine_id_hint: ?[]const u8 = null,
        machine_name: ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const IPCFrame.SetPeerIdentity) usize {
            var res: usize = 0;
            if (self.pid != 0) {
                res += gremlin.sizes.sizeWireNumber(IPCFrame.SetPeerIdentityWire.PID_WIRE) + gremlin.sizes.sizeI32(self.pid);
            }
            if (self.uid != 0) {
                res += gremlin.sizes.sizeWireNumber(IPCFrame.SetPeerIdentityWire.UID_WIRE) + gremlin.sizes.sizeI32(self.uid);
            }
            if (self.machine_id_hint) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(IPCFrame.SetPeerIdentityWire.MACHINE_ID_HINT_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.machine_name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(IPCFrame.SetPeerIdentityWire.MACHINE_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            return res;
        }
        pub fn encode(self: *const IPCFrame.SetPeerIdentity, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const IPCFrame.SetPeerIdentity, target: *gremlin.Writer) void {
            if (self.pid != 0) {
                target.appendInt32(IPCFrame.SetPeerIdentityWire.PID_WIRE, self.pid);
            }
            if (self.uid != 0) {
                target.appendInt32(IPCFrame.SetPeerIdentityWire.UID_WIRE, self.uid);
            }
            if (self.machine_id_hint) |v| {
                if (v.len > 0) {
                    target.appendBytes(IPCFrame.SetPeerIdentityWire.MACHINE_ID_HINT_WIRE, v);
                }
            }
            if (self.machine_name) |v| {
                if (v.len > 0) {
                    target.appendBytes(IPCFrame.SetPeerIdentityWire.MACHINE_NAME_WIRE, v);
                }
            }
        }
    };
    pub const SetPeerIdentityReader = struct {
        buf: gremlin.Reader,
        _pid: i32 = 0,
        _uid: i32 = 0,
        _machine_id_hint: ?[]const u8 = null,
        _machine_name: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!IPCFrame.SetPeerIdentityReader {
            const buf = gremlin.Reader.init(src);
            var res = IPCFrame.SetPeerIdentityReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    IPCFrame.SetPeerIdentityWire.PID_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._pid = result.value;
                    },
                    IPCFrame.SetPeerIdentityWire.UID_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._uid = result.value;
                    },
                    IPCFrame.SetPeerIdentityWire.MACHINE_ID_HINT_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._machine_id_hint = result.value;
                    },
                    IPCFrame.SetPeerIdentityWire.MACHINE_NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._machine_name = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getPid(self: *const IPCFrame.SetPeerIdentityReader) i32 {
            return self._pid;
        }
        pub inline fn getUid(self: *const IPCFrame.SetPeerIdentityReader) i32 {
            return self._uid;
        }
        pub inline fn getMachineIdHint(self: *const IPCFrame.SetPeerIdentityReader) []const u8 {
            return self._machine_id_hint orelse &[_]u8{};
        }
        pub inline fn getMachineName(self: *const IPCFrame.SetPeerIdentityReader) []const u8 {
            return self._machine_name orelse &[_]u8{};
        }
    };
    // fields
    request_id: u64 = 0,
    data_for_testing: ?[]const ?[]const u8 = null,
    msg_bind_service: ?IPCFrame.BindService = null,
    msg_bind_service_reply: ?IPCFrame.BindServiceReply = null,
    msg_invoke_method: ?IPCFrame.InvokeMethod = null,
    msg_invoke_method_reply: ?IPCFrame.InvokeMethodReply = null,
    msg_request_error: ?IPCFrame.RequestError = null,
    set_peer_identity: ?IPCFrame.SetPeerIdentity = null,
    pub fn calcProtobufSize(self: *const IPCFrame) usize {
        var res: usize = 0;
        if (self.request_id != 0) {
            res += gremlin.sizes.sizeWireNumber(IPCFrameWire.REQUEST_ID_WIRE) + gremlin.sizes.sizeU64(self.request_id);
        }
        if (self.data_for_testing) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(IPCFrameWire.DATA_FOR_TESTING_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.msg_bind_service) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(IPCFrameWire.MSG_BIND_SERVICE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.msg_bind_service_reply) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(IPCFrameWire.MSG_BIND_SERVICE_REPLY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.msg_invoke_method) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(IPCFrameWire.MSG_INVOKE_METHOD_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.msg_invoke_method_reply) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(IPCFrameWire.MSG_INVOKE_METHOD_REPLY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.msg_request_error) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(IPCFrameWire.MSG_REQUEST_ERROR_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.set_peer_identity) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(IPCFrameWire.SET_PEER_IDENTITY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const IPCFrame, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const IPCFrame, target: *gremlin.Writer) void {
        if (self.request_id != 0) {
            target.appendUint64(IPCFrameWire.REQUEST_ID_WIRE, self.request_id);
        }
        if (self.data_for_testing) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(IPCFrameWire.DATA_FOR_TESTING_WIRE, v);
                } else {
                    target.appendBytesTag(IPCFrameWire.DATA_FOR_TESTING_WIRE, 0);
                }
            }
        }
        if (self.msg_bind_service) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(IPCFrameWire.MSG_BIND_SERVICE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.msg_bind_service_reply) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(IPCFrameWire.MSG_BIND_SERVICE_REPLY_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.msg_invoke_method) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(IPCFrameWire.MSG_INVOKE_METHOD_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.msg_invoke_method_reply) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(IPCFrameWire.MSG_INVOKE_METHOD_REPLY_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.msg_request_error) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(IPCFrameWire.MSG_REQUEST_ERROR_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.set_peer_identity) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(IPCFrameWire.SET_PEER_IDENTITY_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const IPCFrameReader = struct {
    buf: gremlin.Reader,
    _request_id: u64 = 0,
    _data_for_testing_offset: ?usize = null,
    _data_for_testing_last_offset: ?usize = null,
    _data_for_testing_cnt: usize = 0,
    _msg_bind_service_buf: ?[]const u8 = null,
    _msg_bind_service_reply_buf: ?[]const u8 = null,
    _msg_invoke_method_buf: ?[]const u8 = null,
    _msg_invoke_method_reply_buf: ?[]const u8 = null,
    _msg_request_error_buf: ?[]const u8 = null,
    _set_peer_identity_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!IPCFrameReader {
        const buf = gremlin.Reader.init(src);
        var res = IPCFrameReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                IPCFrameWire.REQUEST_ID_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._request_id = result.value;
                },
                IPCFrameWire.DATA_FOR_TESTING_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._data_for_testing_offset == null) {
                        res._data_for_testing_offset = offset - result.size;
                    }
                    res._data_for_testing_last_offset = offset;
                    res._data_for_testing_cnt += 1;
                },
                IPCFrameWire.MSG_BIND_SERVICE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._msg_bind_service_buf = result.value;
                },
                IPCFrameWire.MSG_BIND_SERVICE_REPLY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._msg_bind_service_reply_buf = result.value;
                },
                IPCFrameWire.MSG_INVOKE_METHOD_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._msg_invoke_method_buf = result.value;
                },
                IPCFrameWire.MSG_INVOKE_METHOD_REPLY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._msg_invoke_method_reply_buf = result.value;
                },
                IPCFrameWire.MSG_REQUEST_ERROR_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._msg_request_error_buf = result.value;
                },
                IPCFrameWire.SET_PEER_IDENTITY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._set_peer_identity_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getRequestId(self: *const IPCFrameReader) u64 {
        return self._request_id;
    }
    pub fn dataForTestingCount(self: *const IPCFrameReader) usize {
        return self._data_for_testing_cnt;
    }
    pub fn dataForTestingNext(self: *IPCFrameReader) ?[]const u8 {
        if (self._data_for_testing_offset == null) return null;
        const current_offset = self._data_for_testing_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._data_for_testing_last_offset != null and current_offset >= self._data_for_testing_last_offset.?) {
            self._data_for_testing_offset = null;
            return result.value;
        }
        if (self._data_for_testing_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._data_for_testing_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == IPCFrameWire.DATA_FOR_TESTING_WIRE) {
                self._data_for_testing_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._data_for_testing_offset = null;
        return result.value;
    }
    pub fn getMsgBindService(self: *const IPCFrameReader) gremlin.Error!IPCFrame.BindServiceReader {
        if (self._msg_bind_service_buf) |buf| {
            return try IPCFrame.BindServiceReader.init(buf);
        }
        return try IPCFrame.BindServiceReader.init(&[_]u8{});
    }
    pub fn getMsgBindServiceReply(self: *const IPCFrameReader) gremlin.Error!IPCFrame.BindServiceReplyReader {
        if (self._msg_bind_service_reply_buf) |buf| {
            return try IPCFrame.BindServiceReplyReader.init(buf);
        }
        return try IPCFrame.BindServiceReplyReader.init(&[_]u8{});
    }
    pub fn getMsgInvokeMethod(self: *const IPCFrameReader) gremlin.Error!IPCFrame.InvokeMethodReader {
        if (self._msg_invoke_method_buf) |buf| {
            return try IPCFrame.InvokeMethodReader.init(buf);
        }
        return try IPCFrame.InvokeMethodReader.init(&[_]u8{});
    }
    pub fn getMsgInvokeMethodReply(self: *const IPCFrameReader) gremlin.Error!IPCFrame.InvokeMethodReplyReader {
        if (self._msg_invoke_method_reply_buf) |buf| {
            return try IPCFrame.InvokeMethodReplyReader.init(buf);
        }
        return try IPCFrame.InvokeMethodReplyReader.init(&[_]u8{});
    }
    pub fn getMsgRequestError(self: *const IPCFrameReader) gremlin.Error!IPCFrame.RequestErrorReader {
        if (self._msg_request_error_buf) |buf| {
            return try IPCFrame.RequestErrorReader.init(buf);
        }
        return try IPCFrame.RequestErrorReader.init(&[_]u8{});
    }
    pub fn getSetPeerIdentity(self: *const IPCFrameReader) gremlin.Error!IPCFrame.SetPeerIdentityReader {
        if (self._set_peer_identity_buf) |buf| {
            return try IPCFrame.SetPeerIdentityReader.init(buf);
        }
        return try IPCFrame.SetPeerIdentityReader.init(&[_]u8{});
    }
};
